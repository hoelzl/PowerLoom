This is manual.info, produced by makeinfo version 4.3 from manual.texi.

   This file documents the knowledge representation and reasoning
system.


File: manual.info,  Node: Language Specific Interface,  Prev: API Functions,  Up: PowerLoom API

Language Specific Interface
===========================

   This section contains the description of the programming language
specific aspects of using the PowerLoom API.  Each section describes the
naming conventions and namespace issues related to calling the API
functions from that programming language.

* Menu:

* Lisp API::
* C++ API::
* Java API::


File: manual.info,  Node: Lisp API,  Next: C++ API,  Prev: Language Specific Interface,  Up: Language Specific Interface

Lisp API
--------

   This section tells how to call the API functions in PowerLoom's
Common Lisp implementation from a Lisp program.  The function names are
identical to the Stella names in the PowerLoom API description *Note
PowerLoom API::.  They are exported from the `PLI' package.  Other
Stella symbols and names are in the `STELLA' package, but *currently
none of the Stella symbols are exported!*.

   PowerLoom can be used from Allegro Common Lisp, CMU Common Lisp,
LispWorks Common Lisp and Macintosh Common Lisp.  It may be possible to
use the system from other Common Lisp systems, but they have not been
tested.

* Menu:

* Initialization::
* Type Declarations::
* NULL Values::
* Wrapped Literal Values::
* Special Variables::
* CLOS Objects versus Structs::


File: manual.info,  Node: Initialization,  Next: Type Declarations,  Prev: Lisp API,  Up: Lisp API

Common Lisp Initialization
..........................

   Loading the Common Lisp version of PowerLoom will normally initialize
the system as part of the loading process.  The Common Lisp version can
be loaded by loading the file `load-powerloom.lisp' from the top-level
`powerloom' directory.  This will make the system available for use.


File: manual.info,  Node: Type Declarations,  Next: NULL Values,  Prev: Initialization,  Up: Lisp API

Type Declarations
.................

   Stella is a typed language, and the Common Lisp translation uses the
type information for Common Lisp type declarations.  That means that
values specified as being of type INTEGER, STRING and FLOAT must have
the correct type.  In particular, integer values will not be coerced to
floating point values by the code.  The following native type
assignments are made:

         Stella      Common Lisp
         =======     ===========
         INTEGER     FIXNUM
         FLOAT       DOUBLE-FLOAT
         STRING      SIMPLE-STRING

   *For convenience, loading PowerLoom will set the default format for
reading floating point numbers in Common Lisp to be `double-float'.*

   Stella `CONS' objects are implmented as native Lisp conses.  Boolean
values can take on the values `stella::true' or `stella::false'.


File: manual.info,  Node: NULL Values,  Next: Wrapped Literal Values,  Prev: Type Declarations,  Up: Lisp API

NULL values
...........

   One additional consequence of the strong typing of the language is
that there are specialized `NULL' values for numeric and string
parameters.

       Stella Type   Null Value
       ===========   ===========
         INTEGER     stella::null-integer
         FLOAT       stella::null-float
         STRING      stella::null-string


File: manual.info,  Node: Wrapped Literal Values,  Next: Special Variables,  Prev: NULL Values,  Up: Lisp API

Wrapped Literal Values
......................

   Literal values (integers, floats, strings, etc.) that are used in
PowerLoom appear as wrapped values.  The PowerLoom API functions
`object-to-...' can be used to coerce the values into the appropriate
return type.

   <to be written:  wrapping values>


File: manual.info,  Node: Special Variables,  Next: CLOS Objects versus Structs,  Prev: Wrapped Literal Values,  Up: Lisp API

Special Variables
.................

   All Stella special variables are implemented as Common Lisp special
variables.  Binding of the values can be used normally.


File: manual.info,  Node: CLOS Objects versus Structs,  Prev: Special Variables,  Up: Lisp API

CLOS Objects versus Structs
...........................

   PowerLoom can be translated in one of two ways for Common Lisp.  One
method uses CLOS objects as the basis for all Stella and PowerLoom
objects.  For faster execution, it is also possible to use a version in
which Stella and PowerLoom objects are implemented using Common Lisp
structs instead.  This is controlled by the special variable
`cl-user::*load-cl-struct-stella?*'.  If this is set to `cl:t', then
the struct version will be loaded.  This needs to be set before loading
the `load-powerloom.lisp' file.


File: manual.info,  Node: C++ API,  Next: Java API,  Prev: Lisp API,  Up: Language Specific Interface

C++ API
-------

   <to be written>


File: manual.info,  Node: Java API,  Prev: C++ API,  Up: Language Specific Interface

Java API
--------

   This section tells how to call the API functions in PowerLoom's Java
implementation from a Java program.  The Java translation is written for
Java version 1.2.  All of the PowerLoom Interface functions appear as
static methods of the class `edu.isi.powerloom.PLI'.

* Menu:

* Initializing PowerLoom::
* PowerLoom Java Conventions::
* Using the PLI Class::
* Using Stella Objects::
* PowerLoom and Threads::
* Setting and Restoring Global Variable Values::
* Java Character Mapping::
* Stella Exceptions in Java::
* Iteration in Java::
* Utility Classes for Java::


File: manual.info,  Node: Initializing PowerLoom,  Next: PowerLoom Java Conventions,  Prev: Java API,  Up: Java API

Initializing PowerLoom
......................

   PowerLoom needs to run initialization functions to set up its
environment for proper operation when it starts up.  The simplest method
for initializing PowerLoom is to use the static method call:

             PLI.initialize()

   This must be called before using any PowerLoom features and before
loading any PowerLoom knowledge bases.  It may be called more than once
without ill effect.


File: manual.info,  Node: PowerLoom Java Conventions,  Next: Using the PLI Class,  Prev: Initializing PowerLoom,  Up: Java API

PowerLoom Java Conventions
..........................

   PowerLoom's Java code is automatically generated by a translator from
underlying Stella code.  The character set for legal Stella names is
larger than the character set for legal Java identifiers, so there is
some mapping involved.

   PowerLoom names are words separated by hyphen (-) characters.  For
Java, we have attempted to closely follow the Java conventions:

   * Class names begin with a capital letter and each word is
     capitalized.  The hyphens from the PowerLoom names are removed.
     Example:
                  string-wrapper   =>  StringWrapper
        Exceptions are made for class names that would otherwise
     conflict with    normal Java Classes.  In that case, the prefix
     "Stella_" is added to each    class name.  At the moment this
     applies only to the following exceptions:
                  object    =>  Stella_Object
                  class     =>  Stella_Class

   * Method and Function names begin with a lower case letter but each
     subsequent word is capitalized.  The hyphens from PowerLoom names
     are removed.  Example:
                  wrapper-value    =>  wrapperValue

   * Storage slots are implemented as Java fields.  The names begin
     with a lower case letter but each subsequent word is capitalized.
     The hyphens from PowerLoom names are removed.  Example:
                  dynamic-slots    =>  dynamicSlots

   * Global and Special variable names are written in all uppercase.
     The hyphens from PowerLoom are replaced by underscore (_)
     characters.  By convention, special variables are written in
     PowerLoom with surrounding asterisk (*) characters.  The asterisks
     are replaced by dollar signs ($).  Example:
                  *html-quoted-characters*  =>  $HTML_QUOTED_CHARACTERS$

   The most common non-alphanumeric characters are mapped as follows.  A
full set of mappings is in section *Note Java Character Mapping::.
        ?  =>  P      (for Predicate)
        !  =>  X      (eXclamation)
        $  =>  B      (Buck)
        %  =>  R      (peRcent)
        &  =>  A      (Ampersand)
        *  =>  $      Special variable marker.

   The character mappings use uppercase characters if the basic
identifier uses mixed or lower case.  The mappings use lowercase
characters if the basic identifier uses upper case.

   Stella modules are mapped to Java packages.  The basic system
distribution includes the following package hierarchy:

       edu
          isi
             stella
                 javalib
             powerloom
                 logic
                 pl_kernel_kb
                     loom_api

   Basic system functionality and data structures such as Cons and List
objects are defined in stella.  PowerLoom's logic (concepts, relations,
rules, etc.) are defined in the logic package.  There is a set of
interface functions in the PLI class in the powerloom package.  They
are described in their own section below.

   We recommend the following import statements in Java files that use
PowerLoom:
             import edu.isi.stella.*;
             import edu.isi.stella.javalib.*;
             import edu.isi.powerloom.PLI;
             import edu.isi.powerloom.logic.*;

   Functions (in Java terms, static Methods) are translated as static
methods on the class of their first argument (as long as that argument
is not a primitive type and is in the same Stella module).  Functions
which take no arguments, those whose first argument is a primitive
type, and those whose first argument is a class not defined in the same
module are all placed into a class with the same name as the Stella
module in which it appers.  It will be in the package corresponding to
that Stella module.  Java constructors should not be called directly.
Instead, there will be a static method `new<ClassName>' (with the class
name in mixed case!) that should be used instead.

   Most of the functions of interest will be in the
edu.isi.stella.Stella, edu.isi.powerloom.PLI or
edu.isi.powerloom.logic.Logic classes.

   Methods typically refer to their first argument as "self".

   Methods which return more than one return value will take a final
argument which is an array of `Stella_Object', which will be used to
return the additional arguments.

   Primitive types in Stella have the following mapping in Java:
             Stella          Java
             ======          ====
             INTEGER         int
             FLOAT           double
             NUMBER          double
             CHARACTER       char
             BOOLEAN         boolean
             STRING          String
             MUTABLE-STRING  StringBuffer
     
       NATIVE-OUTPUT-STREAM  java.io.PrintStream
       NATIVE-INPUT-STREAM   java.io.PushbackInputStream  (May change!!!)

   Inside Stella/PowerLoom objects and collections, primitive types are
wrapped using Stella wrappers instead of Java's primitive classes.  So
integers will be wrapped as edu.isi.stella.IntegerWrapper rather than
java.lang.Integer.  Wrappers have a field called wrapperValue which
accesses the internal value.  Example of use:

         import edu.isi.stella.*;
         import edu.isi.stella.javalib.*;
         ...
         IntegerWrapper iWrap = IntegerWrapper.wrapInteger(42);
         ...
         int answer = iWrap.wrapperValue;
         ...


File: manual.info,  Node: Using the PLI Class,  Next: Using Stella Objects,  Prev: PowerLoom Java Conventions,  Up: Java API

Using the PLI Class
...................

   To make interoperability between PowerLoom and Java a little
simpler, we are providing a (PowerLoom Interface class named `PLI' which
handles synchronization issues, setting and restoring the reasoning
context, and the a more convenient use of some Java-native objects
rather than Stella objects.  Generally that means that strings are used
for PowerLoom expressions and return values rather than Stella `Cons'
objects.

   Details about the methods can be found in the section *Note
PowerLoom API::.  The names of functions in that section will need to
be converted to their Java equivalents using the conventions described
in *Note PowerLoom Java Conventions::.  We also provide javadoc
documentation for the `edu.isi.powerloom.PLI' class.  We recommend
using this method for accessing PowerLoom functionality.  We expect to
expand the range of PowerLoom interface functions that have an analog in
the `PLI' class over time.


File: manual.info,  Node: Using Stella Objects,  Next: PowerLoom and Threads,  Prev: Using the PLI Class,  Up: Java API

Using Stella Objects
....................

   Stella objects can also be used directly.  The most common ones used
by PowerLoom users are `Module' and `LogicObject'.  Other potentially
useful Stella objects are `Cons', `Symbol', `Keyword' and `List'.
Except for `LogicObject', these are in the `edu.isi.stella' package.
`LogicObject' is in the `edu.isi.powerloom.logic' package.

   If one wishes to construct `Cons' objects (for example to create
objects to pass to interface functions, one would begin by building
items up using `Stella_Object.cons' static method, which takes a stella
object and a cons.  The empty cons is kept in the
`edu.isi.stella.Stella.NIL' static variable.  Another way to create
stella objects is to use `edu.isi.stella.Stella.unstringify' static
method.  This method takes a string representation of a stella object
and returns the object.  If passed a list, an object of type `Cons'
will be returned.

   As an alternative, one can also convert one and two dimensional
arrays of `Stella_Object' into `Cons' objects using the overloaded
function `edu.isi.stella.javalib.arrayToCons'.  These functions will
return `Cons' objects constructed from the input arrays.

   Keywords and symbols are objects that are stored in global static
variables.  The variable names are all in upper case and are constructed
by concatenating the tag SYM with the module name and the name of the
symbol or concatenating the tag KWD with the name of the keyword.  For
example, the symbol BACKWARD in the logic module would be stored in

             edu.isi.powerloom.logic.Logic.SYM_LOGIC_BACKWARD

   whereas the keyword :ERROR in the stella module would be in

             edu.isi.stella.Stella.KWD_ERROR


File: manual.info,  Node: PowerLoom and Threads,  Next: Setting and Restoring Global Variable Values,  Prev: Using Stella Objects,  Up: Java API

PowerLoom and Threads
.....................

   The most important consideration when using PowerLoom in a threaded
environment is that the core of PowerLoom must not execute in
concurrently running threads.  The PLI class takes care of this for
interface functions that run through that class.  Other PowerLoom
functions that are called need to synchronize on a lock object

             edu.isi.powerloom.logic.Logic.$POWERLOOM_LOCK$

   for proper operation.  This is not needed for setting Special
Variables, since they are implemented on a per-thread basis.  The most
important special variable is the reasoning context.  *Note Setting and
Restoring Global Variable Values::.


File: manual.info,  Node: Setting and Restoring Global Variable Values,  Next: Java Character Mapping,  Prev: PowerLoom and Threads,  Up: Java API

Setting and Restoring Global Variable Values
............................................

   As noted above, special variables in Stella are implemented as static
fields in a catchall class named the same as the Stella module.  It will
be in the java package corresponding to that Stella module.  The values
of Special variables are stored in Java objects of the type
`StellaSpecialVariable', a subclass of Java's `InheritableThreadLocal'.
Any changes made to the values will not affect any other running
threads.  This means that the changes don't need to be synchronized.
Note that global (as opposed to special) variables don't use these
objects.

   Numbers and boolean values are stored in special variables using the
corresponding Java classes `Integer', `Double', `Boolean', etc.  The
naming convention is to have all upper case letters with a dollar sign
($) at the beginning and end of the name.

   To temporarily change the value of one of these variables, users will
need to be responsible for saving and restoring the old values.  Use of
the "`try ... finally ...'" construct is very useful for this, since it
guarantees that the restore of values will be done.  An example follows
of how to safely change modules.  Contexts should be changed using the
functions, although other global variables can be changed by using the
set method.  Note that we use variables of type Object to hold the
values, since that avoids the need to cast when extracting the current
value, since the only operation we do with the current value is save it
to restore it later.

        import edu.isi.stella.*;
     
        // CONTEXT CHANGE.
        Object savedModule = Stella.$MODULE$.get();
        Module newModule
           = Stella.getStellaModule(contextName, true);
        if (newModule == null) { // Handle missing module
        }
        try {
          Module.changeCurrentModule(newModule)
          // Code that uses the newModule
     
        } finally {
          Module.changeCurrentModule(savedModule);
        }
     
     
        // INTEGER VALUE CHANGE:
        Object savedValue = Stella.$SAFETY$.get();
        try {
          Stella.$SAFETY$.set(new Integer(3));
          // Code that uses the newModule
     
        } finally {
          Stella.$SAFETY$.set(savedValue);
        }
     
     
        // BOOLEAN VALUE CHANGE:
        Object savedValue = Stella.$PRINTREADABLY$.get();
        try {
          Stella.$PRINTREADABLY$.set(Boolean.TRUE);
          // Code that uses the newModule
     
        } finally {
          Stella.$PRINTREADABLY$.set(savedValue);
        }

   The need to change the module using this type of code can be largely
avoided by using the functions in the PLI interface package.  They take
a module argument and can handle the binding and restoration of the
module value themselves.


File: manual.info,  Node: Java Character Mapping,  Next: Stella Exceptions in Java,  Prev: Setting and Restoring Global Variable Values,  Up: Java API

Java Character Mapping
......................

   The full Stella to Java character mapping is the following. The
character mappings use uppercase characters if the basic identifier uses
mixed or lower case.  The mappings use lowercase characters if the basic
identifier uses upper case.

        Stella  Java     Mnemonic
        ======  ====     ========
          !   =>  X      (eXclamation)
          "   =>  _
          #   =>  H      (Hash)
          $   =>  B      (Buck)
          %   =>  R      (peRcent)
          &   =>  A      (Ampersand)
          '   =>  Q      (Quote)
          (   =>  _
          )   =>  _
          *   =>  $
          +   =>  I      (Increase)
          ,   =>  _
          -   =>  _
          .   =>  D      (Dot)
          /   =>  S      (Slash)
          :   =>  C      (Colon)
          ;   =>  _
          <   =>  L      (Less than)
          =   =>  E      (Equal)
          >   =>  G      (Greater than)
          ?   =>  P      (Predicate)
          @   =>  M      (Monkey tail)
          [   =>  J      (Arbitrary (array index?))
          \   =>  _
          ]   =>  K      (Arbitrary (array index?)
          ^   =>  U      (Up arrow)
          `   =>  _
          {   =>  Y      (Arbitrary (adjacent free letter))
          |   =>  V      (Vertical bar)
          }   =>  Z      (Arbitrary (adjacent free letter))
          ~   =>  T      (Tilde)
     <space>  => _


File: manual.info,  Node: Stella Exceptions in Java,  Next: Iteration in Java,  Prev: Java Character Mapping,  Up: Java API

Stella Exceptions in Java
.........................

   Stella exceptions are implemented as a subtype of
`java.lang.Exception' (actually `RunTimeException') and may be caught
normally.  All Stella Exceptions belong to the
`edu.isi.stella.StellaException' class or one of its subclasses.  The
more specfic PowerLoom exceptions belong to the
`edu.isi.powerloom.logic.LogicException' class or one of its subclasses.

   Exceptions thrown during I/O operations will not use the standard
Java exceptions.  Instead, they will descend from
`edu.isi.stella.InputOutputException'.  The most useful descendents are
`edu.isi.stella.NoSuchFileException' and
`edu.isi.stella.EndOfFileException'.


File: manual.info,  Node: Iteration in Java,  Next: Utility Classes for Java,  Prev: Stella Exceptions in Java,  Up: Java API

Iteration in Java
.................

   Iteration in Stella (and by extension) PowerLoom is organized a
little bit differently than in Java.  You can either use the Stella
iterators directly, or else use one of the wrapper classes described in
the section *Note Utility Classes for Java::.  It will present a more
familiar Java interface.  Since the iteration models are a bit
different, it would be unwise to mix accesses between the iteration
models.

   Stella iterators do not compute any values until the next? method (in
Java: `nextP') is called.  This method will try to compute the next
value of the iterator and it will return a boolean value which is true
if more values are present.  Each time it is called, the iteration
advances.  Values can be read out of the value field of the iterator,
which will have type `Stella_Object'.  Some iterators will also have a
key field which can be read.

   The way one would normally use a Stella iterator is as follows, with
possible casting of the value field:

         Stella.Iterator iter = ...;
     
         while (iter.nextP()) {
             processValue(iter.value);
         }

   The PLI class also contains a number of functions for simplifying the
interaction with `PlIterator' objects that are returned by various API
functions.  These are the `getNth...' functions.  They work on
sequences and sequence-like objects such as `Proposition' and and the
value slot of `PlIterator' objects.  Note that they do not return
sequential elements of the iterator, but rather elements of the
implicit sequence that is the value of iterators that have more than
one return variable.  For convenience, they also work (with index = 0)
on the value of `PlIterator' objects that have only a single return
variable.  For example:

         // Get values of (object name age) in the iterator and then
         // print out a message with the name and age (position 1 & 2).
         // This skips the PowerLoom object bound to ?X in position 0.
         PlIterator iter =
             PLI.sRetrieve("all (and (name ?x ?name) (age ?x ?age))",
                           null,
                           null);
     
         while (iter.nextP()) {
             System.out.println(PLI.getNthString(iter, 1, null, null) + " is " +
                                PLI.getNthInteger(iter, 2, null, null ) + " years old.");
         }


File: manual.info,  Node: Utility Classes for Java,  Prev: Iteration in Java,  Up: Java API

Utility Classes for Java
........................

   To make interoperation of Stella and Java easier, there are several
convenience classes for wrapping Stella iterators and having them behave
like Java enumerations or iterators.  These convenience classes are in
the `edu.isi.stella.javalib' package:

       ConsEnumeration.java      Enumeration class for Cons objects
       ConsIterator.java         Iterator class for Cons objects
       StellaEnumeration.java    Enumeration interface to Stella's Iterator
       StellaIterator.java       Iterator interface to Stella's Iterator

   All of the iterators and enumerators return objects that are
actually of type `Stella_Object', but the signature specifies
`java.lang.Object' as required for compatibility with the standard Java
signature.  The `Cons...' classes take a `Cons' in their constructor.
The `Stella...' classes take a `edu.isi.stella.Iterator' object in
their constructor.

