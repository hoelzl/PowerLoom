<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<!-- Created on May, 25  2006 by texi2html 1.65 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>PowerLoom Manual: PowerLoom API</TITLE>

<META NAME="description" CONTENT="PowerLoom Manual: PowerLoom API">
<META NAME="keywords" CONTENT="PowerLoom Manual: PowerLoom API">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.65">

</HEAD>

<BODY LANG="en" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC40"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC39"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC41"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC39"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_8.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 7. PowerLoom API </H1>
<!--docid::SEC40::-->
<P>

This chapter lists functions that collectively define the PowerLoom
API.  The first section describes the API functions themselves.  The
signature is the basic Stella signature.  Information on how to
translate the names of the functions and their arguments into the
programming languages Common Lisp, C++ or Java is given in the Language
Specific Interface section.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_7.html#SEC41">7.1 API Functions</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_7.html#SEC42">7.2 Language Specific Interface</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="API Functions"></A>
<HR SIZE="6">
<A NAME="SEC41"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC42"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_8.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 7.1 API Functions </H2>
<!--docid::SEC41::-->
<P>

Many of the functions take a `module' argument that causes the function to be
evaluated in the context of that module. Passing in a NULL value for the module
argument means that evaluation takes place in the current module. The module
argument is frequently followed by an `environment' argument that specifies
which inference environment should be assumed during evaluation. Values for
`environment' are `ASSERTION-ENV', `TAXONOMIC-ENV', and `INFERENCE-ENV'.
`ASSERTION-ENV' specifies that a knowledge base query or lookup should take
into account only explicitly asserted propositions. `TAXONOMIC-ENV' 
specifies that a knowledge base query should take into account
explicitly-asserted propositions plus any rules that specify subsumption
relationships.   `INFERENCE-ENV' specifies that a knowledge base query
should take all relevant propositions into account, including those
generated during forward inferencing.  A NULL value for the `environment'
argument defaults to `TAXONOMIC-ENV'.
</P><P>

Many of the functions that take PowerLoom or Stella objects as inputs
also have an analog version whose name starts with the prefix "s-" that
take strings as inputs.  This is provided as a convenience so that
programmers will not necessarily need to manipulate PowerLoom objects
directly.
</P><P>

<A NAME="IDX60"></A>
<DL>
<DT><U>Function:</U> <B>ask</B> <I>((query CONS) (module MODULE) (environment ENVIRONMENT)) : TRUTH-VALUE</I>
<DD>Returns a truth value for <VAR>query</VAR> in <VAR>module</VAR> and <VAR>environment</VAR>.
<VAR>query</VAR> has the same syntax as the PowerLoom <CODE>ask</CODE> command (which see)
but with the <CODE>ask</CODE> operator omitted.  For example, here are some legal
<VAR>query</VAR> arguments:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    ((happy Fred))
    ((happy Fred) :inference-level :assertion)
    ((happy Fred) :inference-level :assertion :timeout 1.0)
</pre></td></tr></table></P><P>

As a convenience, a <VAR>query</VAR> argument whose first element is a symbol is
interpreted as a sentence that is queried without any options.  For example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    (happy Fred)
</pre></td></tr></table></P><P>

is a legal <VAR>query</VAR> argument.  Note that for a setence whose relation is a list
itself, e.g., <CODE>((FruitFn BananaTree) MyBanana)</CODE> this shortcut is not available,
that is, in that case an extra level of list nesting is always necessary.
The returned truth value represents the logical truth of the queried sentence
as determined by PowerLoom.  It can be be tested via the functions <CODE>is-true</CODE>,
<CODE>is-false</CODE> and <CODE>is-unknown</CODE> (which see).
</DL>
</P><P>

<A NAME="IDX61"></A>
<DL>
<DT><U>Function:</U> <B>assert-binary-proposition</B> <I>((relation LOGIC-OBJECT) (arg OBJECT) (value OBJECT) (module MODULE) (environment ENVIRONMENT)) : PROPOSITION</I>
<DD>Assert that the proposition (<VAR>relation</VAR> <VAR>arg</VAR> <VAR>value</VAR>) is TRUE
in <VAR>module</VAR>.  Return the asserted proposition.
</DL>
</P><P>

<A NAME="IDX62"></A>
<DL>
<DT><U>Function:</U> <B>assert-nary-proposition</B> <I>((relation-and-arguments OBJECT) (module MODULE) (environment ENVIRONMENT)) : PROPOSITION</I>
<DD>Assert that the proposition represented by the list <CODE> relation-and-arguments</CODE> satisfies
the relation <CODE>relation</CODE>.
</DL>
</P><P>

<A NAME="IDX63"></A>
<DL>
<DT><U>Function:</U> <B>assert-proposition</B> <I>((proposition PROPOSITION) (module MODULE) (environment ENVIRONMENT)) : PROPOSITION</I>
<DD>Assert that the proposition <VAR>proposition</VAR> is true in <VAR>module</VAR>.
Return the asserted proposition.
</DL>
</P><P>

<A NAME="IDX64"></A>
<DL>
<DT><U>Function:</U> <B>assert-unary-proposition</B> <I>((relation LOGIC-OBJECT) (arg OBJECT) (module MODULE) (environment ENVIRONMENT)) : PROPOSITION</I>
<DD>Assert that the proposition (<VAR>relation</VAR> <VAR>arg</VAR>) is TRUE in <VAR>module</VAR>.  Return the asserted proposition.
</DL>
</P><P>

<A NAME="IDX65"></A>
<DL>
<DT><U>Function:</U> <B>change-module</B> <I>((module MODULE)) : MODULE</I>
<DD>Set the current module to <VAR>module</VAR> and return it.
If <VAR>module</VAR> is <CODE>null</CODE>, then no switch is performed and the current
module is returned.
</DL>
</P><P>

<A NAME="IDX66"></A>
<DL>
<DT><U>Function:</U> <B>clear-caches</B> <I>() :</I>
<DD>Clear all query and memoization caches.
</DL>
</P><P>

<A NAME="IDX67"></A>
<DL>
<DT><U>Function:</U> <B>clear-module</B> <I>((module MODULE)) : MODULE</I>
<DD>Destroy the contents of the module <VAR>module</VAR> as well as
the contents of all of its children, recursively.
</DL>
</P><P>

<A NAME="IDX68"></A>
<DL>
<DT><U>Function:</U> <B>conceive</B> <I>((sentence OBJECT) (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Create one or more proposition objects from the sentence <VAR>sentence</VAR>
in the  module <VAR>module</VAR>.  Return an iterator of the propositions.
If any of the new propositions has the same structure as an already existing
proposition, an automatic check for duplicates will return the pre-existing
proposition.  Multiple propositions may be returned for a single sentence
because of normalization of equivalences, conjunctions, etc.
</P><P>

Signals a <CODE>Proposition-Error</CODE> if PowerLoom could not conceive <VAR>sentence</VAR>.
</DL>
</P><P>

<A NAME="IDX69"></A>
<DL>
<DT><U>Function:</U> <B>cons-to-pl-iterator</B> <I>((self CONS)) : PL-ITERATOR</I>
<DD>Convert a Stella cons list into an API iterator.
</DL>
</P><P>

<A NAME="IDX70"></A>
<DL>
<DT><U>Function:</U> <B>create-concept</B> <I>((name STRING) (parent LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT)) : LOGIC-OBJECT</I>
<DD>Create a concept named <VAR>name</VAR> in the designated <VAR>module</VAR>, with the
designated <VAR>parent</VAR> superconcept (which can be left undefined).  Additional
superconcepts can be added via assertions of the <CODE>subset-of</CODE> relation.  Note
that a specified <VAR>parent</VAR> concept needs to be created separately.
</P><P>

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match <VAR>name</VAR> exactly.
</DL>
</P><P>

<A NAME="IDX71"></A>
<DL>
<DT><U>Function:</U> <B>create-enumerated-list</B> <I>((members CONS) (module MODULE) (environment ENVIRONMENT)) : LOGIC-OBJECT</I>
<DD>Create a logical term that denotes a list containing <VAR>members</VAR> in
<VAR>module</VAR> using <VAR>environment</VAR>.  Useful for passing lists as arguments
to parameterized queries.
</DL>
</P><P>

<A NAME="IDX72"></A>
<DL>
<DT><U>Function:</U> <B>create-enumerated-set</B> <I>((members CONS) (module MODULE) (environment ENVIRONMENT)) : LOGIC-OBJECT</I>
<DD>Create a logical term that denotes the enumerated set containing <VAR>members</VAR>
in <VAR>module</VAR> using <VAR>environment</VAR>.
</DL>
</P><P>

<A NAME="IDX73"></A>
<DL>
<DT><U>Function:</U> <B>create-function</B> <I>((name STRING) (arity INTEGER) (module MODULE) (environment ENVIRONMENT)) : LOGIC-OBJECT</I>
<DD>Create a function named <VAR>name</VAR> with arity <VAR>arity</VAR>  in the designated 
<VAR>module</VAR>.  Domain and range information can be added via assertions of
<CODE>nth-domain</CODE> (or <CODE>domain</CODE> and <CODE>range</CODE>) relations.
</P><P>

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match <VAR>name</VAR> exactly.
</DL>
</P><P>

<A NAME="IDX74"></A>
<DL>
<DT><U>Function:</U> <B>create-module</B> <I>((name STRING) (parent MODULE) (case-sensitive? BOOLEAN)) : MODULE</I>
<DD>Creates a new module <VAR>name</VAR> as a child of <VAR>parent</VAR>.  The flag
<VAR>case-sensitive?</VAR> controls whether names read in this module will be
case sensitive or not.
</DL>
</P><P>

<A NAME="IDX75"></A>
<DL>
<DT><U>Function:</U> <B>create-object</B> <I>((name STRING) (concept LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT)) : LOGIC-OBJECT</I>
<DD>Create an object named <VAR>name</VAR> of type <VAR>concept</VAR> in the designated
module.  Both <VAR>name</VAR> and <VAR>concept</VAR> can be <CODE>null</CODE>.  If <VAR>name</VAR> is <CODE>null</CODE> then an
object will be created with a new, non-conflicting name based on the name of
<VAR>concept</VAR>, or system-generated if no concept is specified.  If <VAR>concept</VAR> is
<CODE>null</CODE>, then the object will be of type THING.  It is an error to create an
object with the same name as an existing object.
</P><P>

Note that the string can be a qualified name, in which case the object
will be created in the module specified, but with a name as determined
by the qualified name.  Vertical bars in the name string are interpreted
as Stella escape characters.
</P><P>

Note that because names in modules that are not case-sensitive are
canonicalized, the name of the returned object may not match <VAR>name</VAR>
exactly.
</P><P>

Return the object.
</DL>
</P><P>

<A NAME="IDX76"></A>
<DL>
<DT><U>Function:</U> <B>create-relation</B> <I>((name STRING) (arity INTEGER) (module MODULE) (environment ENVIRONMENT)) : LOGIC-OBJECT</I>
<DD>Create a relation named <VAR>name</VAR> with arity <VAR>arity</VAR> in the
designated module.  Domain and range information can be added via assertions
of <CODE>nth-domain</CODE> (or <CODE>domain</CODE> and <CODE>range</CODE>) relations.
</P><P>

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match <VAR>name</VAR> exactly.
</DL>
</P><P>

<A NAME="IDX77"></A>
<DL>
<DT><U>Function:</U> <B>destroy-object</B> <I>((object LOGIC-OBJECT)) :</I>
<DD>Delete the object <VAR>object</VAR>, retracting all facts attached to it.
</DL>
</P><P>

<A NAME="IDX78"></A>
<DL>
<DT><U>Method:</U> PL-ITERATOR <B>empty?</B> <I>(self) : BOOLEAN</I>
<DD>Return TRUE if the iterator <VAR>self</VAR> has no more elements.
</DL>
</P><P>

<A NAME="IDX79"></A>
<DL>
<DT><U>Function:</U> <B>evaluate</B> <I>((command OBJECT) (module MODULE) (environment ENVIRONMENT)) : OBJECT</I>
<DD>Evaluate the command <VAR>command</VAR> within <VAR>module</VAR> and return
the result. Currently, only the evaluation of (possibly nested) commands and
global variables is supported.  Commands are simple to program in Common Lisp,
since they are built into the language, and relatively awkward in Java and C++.
Users of either of those languages are more likely to want to call <CODE>s-evaluate</CODE>.
</DL>
</P><P>

<A NAME="IDX80"></A>
<DL>
<DT><U>Function:</U> <B>generate-unique-name</B> <I>((prefix STRING) (module MODULE) (environment ENVIRONMENT)) : STRING</I>
<DD>Generates a name based on <VAR>prefix</VAR> with a number appended that
is not currently in use in <CODE>module.</CODE>  In a non-case-sensitive module, the returned
name will be all upper case (This latter feature may change!)
</DL>
</P><P>

<A NAME="IDX81"></A>
<DL>
<DT><U>Function:</U> <B>get-arity</B> <I>((relation LOGIC-OBJECT)) : INTEGER</I>
<DD>Return the arity of the relation <VAR>relation</VAR>.
</DL>
</P><P>

<A NAME="IDX82"></A>
<DL>
<DT><U>Function:</U> <B>get-binary-proposition</B> <I>((relation LOGIC-OBJECT) (arg1 OBJECT) (arg2 OBJECT) (module MODULE) (environment ENVIRONMENT)) : PROPOSITION</I>
<DD>Return a proposition such that (<VAR>relation</VAR> <VAR>arg1</VAR> <VAR>arg2</VAR>)
is true.  The <VAR>relation</VAR> argument must be bound to a relation.  One or both
of the <VAR>arg1</VAR> and <VAR>arg2</VAR> arguments may be set to NULL, which is interpreted
as a wildcard. If more than one proposition matches the input criteria,
the selection is arbitrary.  This procedure is normally applied to single-valued
relations or functions.
</DL>
</P><P>

<A NAME="IDX83"></A>
<DL>
<DT><U>Function:</U> <B>get-binary-propositions</B> <I>((relation LOGIC-OBJECT) (arg1 OBJECT) (arg2 OBJECT) (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Return propositions such that (<VAR>relation</VAR> <VAR>arg1</VAR> <VAR>arg2</VAR>)
is true.  The <VAR>relation</VAR> argument
must be bound to a relation.  One or both of the <VAR>arg1</VAR> and <VAR>arg2</VAR> arguments
may be set to NULL, which is interpreted as a wildcard.
</DL>
</P><P>

<A NAME="IDX84"></A>
<DL>
<DT><U>Function:</U> <B>get-child-modules</B> <I>((module MODULE)) : (PL-ITERATOR OF MODULE)</I>
<DD>Return the modules that are immediate children of <VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX85"></A>
<DL>
<DT><U>Function:</U> <B>get-column-count</B> <I>((obj OBJECT)) : INTEGER</I>
<DD>Return the number of columns in <VAR>obj</VAR>, which must
be of type proposition, cons, vector or PL-iterator.  For a proposition,
the number includes both the predidate and arguments. For the PL-iterator
case,the number of columns is for the current value of the iterator.
</P><P>

For non sequence objects, the column count is zero.
</DL>
</P><P>

<A NAME="IDX86"></A>
<DL>
<DT><U>Function:</U> <B>get-concept</B> <I>((name STRING) (module MODULE) (environment ENVIRONMENT)) : LOGIC-OBJECT</I>
<DD>Return a class/concept named <VAR>name</VAR> that is local to
or visible from the module <VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX87"></A>
<DL>
<DT><U>Function:</U> <B>get-concept-instance-matching-value</B> <I>((concept LOGIC-OBJECT) (relation LOGIC-OBJECT) (value OBJECT) (module MODULE) (environment ENVIRONMENT)) : OBJECT</I>
<DD>Return a member of concept <VAR>concept</VAR> that
has an attribute matching <VAR>value</VAR> for the binary relation <VAR>relation</VAR>, i.e.,
<CODE>(relation &#60;result&#62; value)</CODE> holds.
</DL>
</P><P>

<A NAME="IDX88"></A>
<DL>
<DT><U>Function:</U> <B>get-concept-instances</B> <I>((concept LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT)) : PL-ITERATOR</I>
<DD>Return instances of the concept <VAR>concept</VAR>.
Include instances of subconcepts of <VAR>concept</VAR>.  Depending on <VAR>concept</VAR>,
the return values could be (wrapped) literals.
</DL>
</P><P>

<A NAME="IDX89"></A>
<DL>
<DT><U>Function:</U> <B>get-concept-instances-matching-value</B> <I>((concept LOGIC-OBJECT) (relation LOGIC-OBJECT) (value OBJECT) (module MODULE) (environment ENVIRONMENT)) : PL-ITERATOR</I>
<DD>Return members of concept <VAR>concept</VAR> that
have an attribute matching <VAR>value</VAR> for the binary relation <VAR>relation</VAR>, i.e.,
<CODE>(relation &#60;result&#62; value)</CODE> holds.
</DL>
</P><P>

<A NAME="IDX90"></A>
<DL>
<DT><U>Function:</U> <B>get-current-module</B> <I>((environment ENVIRONMENT)) : MODULE</I>
<DD>Return the currently set module
</DL>
</P><P>

<A NAME="IDX91"></A>
<DL>
<DT><U>Function:</U> <B>get-direct-concept-instances</B> <I>((concept LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT)) : PL-ITERATOR</I>
<DD>Return instances of concept <VAR>concept</VAR>.
Exclude instances of subconcepts of <VAR>concept</VAR>.  Depending on <VAR>concept</VAR>,
the return values could be (wrapped) literals.
</DL>
</P><P>

<A NAME="IDX92"></A>
<DL>
<DT><U>Function:</U> <B>get-direct-subrelations</B> <I>((relation LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF LOGIC-OBJECT)</I>
<DD>Return relations that directly specialize <VAR>relation</VAR>.
Non-reflexive.
</DL>
</P><P>

<A NAME="IDX93"></A>
<DL>
<DT><U>Function:</U> <B>get-direct-superrelations</B> <I>((relation LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF LOGIC-OBJECT)</I>
<DD>Return relations that directly generalize <VAR>relation</VAR>.
Non-reflexive.
</DL>
</P><P>

<A NAME="IDX94"></A>
<DL>
<DT><U>Function:</U> <B>get-direct-types</B> <I>((object LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF LOGIC-OBJECT)</I>
<DD>Return most specific concepts that <VAR>object</VAR> belongs to.
</DL>
</P><P>

<A NAME="IDX95"></A>
<DL>
<DT><U>Function:</U> <B>get-domain</B> <I>((relation LOGIC-OBJECT)) : LOGIC-OBJECT</I>
<DD>Return the type (a concept) for the first argument to the binary
relation <VAR>relation</VAR>.
</DL>
</P><P>

<A NAME="IDX96"></A>
<DL>
<DT><U>Function:</U> <B>get-enumerated-collection-members</B> <I>((collection OBJECT) (module MODULE) (environment ENVIRONMENT)) : CONS</I>
<DD>Returns the members of an enumerated collection.  This works on all types
of collection, i.e., sets and lists
</DL>
</P><P>

<A NAME="IDX97"></A>
<DL>
<DT><U>Function:</U> <B>get-home-module</B> <I>((object LOGIC-OBJECT)) : MODULE</I>
<DD>Return the module in which <VAR>object</VAR> was created.
</DL>
</P><P>

<A NAME="IDX98"></A>
<DL>
<DT><U>Function:</U> <B>get-inferred-binary-proposition-values</B> <I>((relation LOGIC-OBJECT) (arg OBJECT) (module MODULE) (environment ENVIRONMENT)) : PL-ITERATOR</I>
<DD>Return all values <CODE>v</CODE> such that (<VAR>relation</VAR> <VAR>arg</VAR> <CODE>v</CODE>)
has been asserted or can be inferred.
</DL>
</P><P>

<A NAME="IDX99"></A>
<DL>
<DT><U>Function:</U> <B>get-module</B> <I>((name STRING) (environment ENVIRONMENT)) : MODULE</I>
<DD>Return a module named <VAR>name</VAR>.
</DL>
</P><P>

<A NAME="IDX100"></A>
<DL>
<DT><U>Function:</U> <B>get-modules</B> <I>((kb-modules-only? BOOLEAN)) : (PL-ITERATOR OF MODULE)</I>
<DD>Return all modules currently loaded into PowerLoom.  If <VAR>kb-modules-only?</VAR>
is <CODE>true</CODE>, then Stella modules that are used only for program code are
not included in the list.
</DL>
</P><P>

<A NAME="IDX101"></A>
<DL>
<DT><U>Function:</U> <B>get-name</B> <I>((obj OBJECT)) : STRING</I>
<DD>Return the fully qualified name of <VAR>obj</VAR>, if it has one.  Otherwise return <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX102"></A>
<DL>
<DT><U>Function:</U> <B>get-nth-domain</B> <I>((relation LOGIC-OBJECT) (n INTEGER)) : LOGIC-OBJECT</I>
<DD>Return the type (a concept) for the the nth argument of the
relation <VAR>relation</VAR>.  Counting starts at zero.
</DL>
</P><P>

<A NAME="IDX103"></A>
<DL>
<DT><U>Function:</U> <B>get-nth-float</B> <I>((sequence OBJECT) (n INTEGER) (module MODULE) (environment ENVIRONMENT)) : FLOAT</I>
<DD>Return the floating point value in the <CODE>nth</CODE> column of
<VAR>sequence</VAR>. Counting starts at zero.  <VAR>sequence</VAR> must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  If this is not
a floating point value, then an exception will be thrown.
</P><P>

As a special case, a column number of zero will also return the floating
point value of <VAR>sequence</VAR> itself if it is not one of the types enumerated
above.  This allows the use of <CODE>get-nth-float</CODE> on PL-iterators with only
a single return variable.    If  <VAR>sequence</VAR> cannot be turned into a floating
point value, an exception will be thrown.
</DL>
</P><P>

<A NAME="IDX104"></A>
<DL>
<DT><U>Function:</U> <B>get-nth-integer</B> <I>((sequence OBJECT) (n INTEGER) (module MODULE) (environment ENVIRONMENT)) : INTEGER</I>
<DD>Return an integer representation of the value in the <CODE>nth</CODE> column of
<VAR>sequence</VAR>. Counting starts at zero.   Unless <VAR>n</VAR> is zero, <VAR>sequence</VAR> must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  If this is not
an integer value, then an exception will be thrown.
</P><P>

As a special case, a column number of zero will also return the integer
value of <VAR>sequence</VAR> itself if it is not one of the types enumerated
above.   This allows the use of <CODE>get-nth-integer</CODE> on PL-iterators with
only a single return variable.  If  <VAR>sequence</VAR> cannot be turned into an
integer, an exception will be thrown.
</DL>
</P><P>

<A NAME="IDX105"></A>
<DL>
<DT><U>Function:</U> <B>get-nth-logic-object</B> <I>((sequence OBJECT) (n INTEGER) (module MODULE) (environment ENVIRONMENT)) : LOGIC-OBJECT</I>
<DD>Return a logic object representation of the value in the <CODE>nth</CODE> column
of <VAR>sequence</VAR>.  Counting starts at zero.   Unless <VAR>n</VAR> is zero, <VAR>sequence</VAR> must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  A zero column number
returns the proposition's relational predicate.  If the return value is
not a LOGIC-OBJECT, an exception is thrown.
</P><P>

As a special case, a column number of zero will also return <VAR>sequence</VAR> itself
if it is not one of the types enumerated above.  This is done to allow the
use of <CODE>get-nth-value</CODE> on PL-iterators with only a single return variable.
If <VAR>sequence</VAR> is not a LOGIC-OBJECT, an exception is thrown.
</DL>
</P><P>

<A NAME="IDX106"></A>
<DL>
<DT><U>Function:</U> <B>get-nth-string</B> <I>((sequence OBJECT) (n INTEGER) (module MODULE) (environment ENVIRONMENT)) : STRING</I>
<DD>Return a string representation of the value in the <CODE>nth</CODE> column of
<VAR>sequence</VAR>. Counting starts at zero.   Unless <VAR>n</VAR> is zero, <VAR>sequence</VAR> must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  This will always
succeed, even if the <CODE>nth</CODE> value is not a string object.  In that case, a
string reprensentation will be returned.
</P><P>

As a special case, a column number of zero will also return <VAR>sequence</VAR> itself
as a string if it is not one of the types enumerated above.  This is done to 
allow the use of <CODE>get-nth-string</CODE> on PL-iterators with only a single return variable.
</DL>
</P><P>

<A NAME="IDX107"></A>
<DL>
<DT><U>Function:</U> <B>get-nth-value</B> <I>((sequence OBJECT) (n INTEGER) (module MODULE) (environment ENVIRONMENT)) : OBJECT</I>
<DD>Return the value in the <CODE>nth</CODE> column of <VAR>sequence</VAR>.
Counting starts at zero.  Unless <VAR>n</VAR> is zero, <VAR>sequence</VAR> must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the number
of columns is for the current value of the iterator.
</P><P>

As a special case, a column number of zero will also return <VAR>sequence</VAR> itself
if it is not one of the types enumerated above.  This is done to allow the
use of <CODE>get-nth-value</CODE> on PL-iterators with only a single return variable.
</DL>
</P><P>

<A NAME="IDX108"></A>
<DL>
<DT><U>Function:</U> <B>get-operator</B> <I>((name STRING)) : SYMBOL</I>
<DD>Returns the logical operator object (a Stella SYMBOL) for <VAR>name</VAR>.
If no such operator exists then a <CODE>no-such-object</CODE> exception is thrown.
</DL>
</P><P>

<A NAME="IDX109"></A>
<DL>
<DT><U>Function:</U> <B>get-object</B> <I>((name STRING) (module MODULE) (environment ENVIRONMENT)) : OBJECT</I>
<DD>Look for an object named <VAR>name</VAR> that is local to
or visible from the module <VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX110"></A>
<DL>
<DT><U>Function:</U> <B>get-parent-modules</B> <I>((module MODULE)) : (PL-ITERATOR OF MODULE)</I>
<DD>Return the modules that are immediate parents of <VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX111"></A>
<DL>
<DT><U>Function:</U> <B>get-predicate</B> <I>((prop PROPOSITION)) : LOGIC-OBJECT</I>
<DD>Return the concept or relation predicate for
the proposition <VAR>prop</VAR>.
</DL>
</P><P>

<A NAME="IDX112"></A>
<DL>
<DT><U>Function:</U> <B>get-proper-subrelations</B> <I>((relation LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF LOGIC-OBJECT)</I>
<DD>Return relations that specialize <VAR>relation</VAR>.
Non-reflexive.
</DL>
</P><P>

<A NAME="IDX113"></A>
<DL>
<DT><U>Function:</U> <B>get-proper-superrelations</B> <I>((relation LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF LOGIC-OBJECT)</I>
<DD>Return relations that generalize <VAR>relation</VAR>.
Non-reflexive.
</DL>
</P><P>

<A NAME="IDX114"></A>
<DL>
<DT><U>Function:</U> <B>get-proposition</B> <I>((relation-and-arguments OBJECT) (module MODULE) (environment ENVIRONMENT)) : PROPOSITION</I>
<DD>Return a proposition matching <VAR>relation-and-arguments</VAR> that
has been asserted (or inferred by forward chaining).  <VAR>relation-and-arguments</VAR>
is a sequence containing objects and nulls.  The first argument must be the
name of a relation.  A null value acts like a wild card.  If more than one 
proposition matches the input criteria, the selection among satisficing
propositions is arbitrary.  This procedure is normally applied to single-valued
relations or functions.
</DL>
</P><P>

<A NAME="IDX115"></A>
<DL>
<DT><U>Function:</U> <B>get-propositions</B> <I>((relation-and-arguments OBJECT) (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Return propositions matching <VAR>relation-and-arguments</VAR> that
have been asserted (or inferred by forward chaining).  <VAR>relation-and-arguments</VAR>
is a sequence containing objects and nulls.  The first argument must be the
name of a relation.  A null value acts like a wild card.
</DL>
</P><P>

<A NAME="IDX116"></A>
<DL>
<DT><U>Function:</U> <B>get-propositions-in-module</B> <I>((module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Return propositions that have been conceived in
the module <VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX117"></A>
<DL>
<DT><U>Function:</U> <B>get-propositions-of</B> <I>((object LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Return all propositions that have <VAR>object</VAR> among their arguments,
and that are TRUE in the scope of the module <VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX118"></A>
<DL>
<DT><U>Function:</U> <B>get-range</B> <I>((relation LOGIC-OBJECT)) : LOGIC-OBJECT</I>
<DD>Return the type (a concept) for fillers of the binary relation
<VAR>relation</VAR>.
</DL>
</P><P>

<A NAME="IDX119"></A>
<DL>
<DT><U>Function:</U> <B>get-relation</B> <I>((name STRING) (module MODULE) (environment ENVIRONMENT)) : LOGIC-OBJECT</I>
<DD>Return a concept or relation named <VAR>name</VAR> that is local to
or visible from the module <VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX120"></A>
<DL>
<DT><U>Function:</U> <B>get-relation-extension</B> <I>((relation LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Return propositions that satisfy <VAR>relation</VAR>.
Include propositions that satisfy subrelations of <VAR>relation</VAR>.
</DL>
</P><P>

<A NAME="IDX121"></A>
<DL>
<DT><U>Function:</U> <B>get-rules</B> <I>((relation LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Return rules attached to the concept/relation <VAR>relation</VAR>
in either antecedent or consequent position.
</DL>
</P><P>

<A NAME="IDX122"></A>
<DL>
<DT><U>Function:</U> <B>get-types</B> <I>((object LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF LOGIC-OBJECT)</I>
<DD>Return all named concepts that <VAR>object</VAR> belongs to.
</DL>
</P><P>

<A NAME="IDX123"></A>
<DL>
<DT><U>Function:</U> <B>initialize</B> <I>() :</I>
<DD>Initialize the PowerLoom logic system.  This function
needs to be called by all applications before using PowerLoom.  If it
is called more than once, every call after the first one is a no-op.
</DL>
</P><P>

<A NAME="IDX124"></A>
<DL>
<DT><U>Function:</U> <B>is-a</B> <I>((object OBJECT) (concept LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>object</VAR> is a member of the concept <VAR>concept</VAR>.
</DL>
</P><P>

<A NAME="IDX125"></A>
<DL>
<DT><U>Function:</U> <B>is-default</B> <I>((tv TRUTH-VALUE)) : BOOLEAN</I>
<DD>Tests whether <VAR>tv</VAR> is a default truth value.
</DL>
</P><P>

<A NAME="IDX126"></A>
<DL>
<DT><U>Function:</U> <B>is-enumerated-collection</B> <I>((obj OBJECT)) : BOOLEAN</I>
<DD>Test whether <VAR>obj</VAR> is an enumerated collection.  This
subsumes both sets and lists.
</DL>
</P><P>

<A NAME="IDX127"></A>
<DL>
<DT><U>Function:</U> <B>is-enumerated-list</B> <I>((obj OBJECT)) : BOOLEAN</I>
<DD>Test whether <VAR>obj</VAR> is an enumerated list
</DL>
</P><P>

<A NAME="IDX128"></A>
<DL>
<DT><U>Function:</U> <B>is-enumerated-set</B> <I>((obj OBJECT)) : BOOLEAN</I>
<DD>Test whether <VAR>obj</VAR> is an enumerated set.
</DL>
</P><P>

<A NAME="IDX129"></A>
<DL>
<DT><U>Function:</U> <B>is-false</B> <I>((tv TRUTH-VALUE)) : BOOLEAN</I>
<DD>Tests whether <VAR>tv</VAR> is a false truth value.  It can be false
either absolutely or by default.
</DL>
</P><P>

<A NAME="IDX130"></A>
<DL>
<DT><U>Function:</U> <B>is-float</B> <I>((obj OBJECT)) : BOOLEAN</I>
<DD>Test whether <VAR>obj</VAR> is of type FLOAT (double)
</DL>
</P><P>

<A NAME="IDX131"></A>
<DL>
<DT><U>Function:</U> <B>is-inconsistent</B> <I>((tv TRUTH-VALUE)) : BOOLEAN</I>
<DD>Tests whether <VAR>tv</VAR> is an inconsistent truth value.
</DL>
</P><P>

<A NAME="IDX132"></A>
<DL>
<DT><U>Function:</U> <B>is-integer</B> <I>((obj OBJECT)) : BOOLEAN</I>
<DD>Test whether <VAR>obj</VAR> is of type INTEGER
</DL>
</P><P>

<A NAME="IDX133"></A>
<DL>
<DT><U>Function:</U> <B>is-logic-object</B> <I>((obj OBJECT)) : BOOLEAN</I>
<DD>Test whether <VAR>obj</VAR> is of type LOGIC-OBJECT
</DL>
</P><P>

<A NAME="IDX134"></A>
<DL>
<DT><U>Function:</U> <B>is-number</B> <I>((obj OBJECT)) : BOOLEAN</I>
<DD>Test whether <VAR>obj</VAR> is of type NUMBER.  This can
be either an integer or a floating point number.  One key characteristic
is that <CODE>object-to-integer</CODE> and <CODE>object-to-float</CODE> will both work on it.
</DL>
</P><P>

<A NAME="IDX135"></A>
<DL>
<DT><U>Function:</U> <B>is-strict</B> <I>((tv TRUTH-VALUE)) : BOOLEAN</I>
<DD>Tests whether <VAR>tv</VAR> is a strict (non-default) truth value.
</DL>
</P><P>

<A NAME="IDX136"></A>
<DL>
<DT><U>Function:</U> <B>is-string</B> <I>((obj OBJECT)) : BOOLEAN</I>
<DD>Test whether <VAR>obj</VAR> is of type STRING
</DL>
</P><P>

<A NAME="IDX137"></A>
<DL>
<DT><U>Function:</U> <B>is-subrelation</B> <I>((sub LOGIC-OBJECT) (super LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>sub</VAR> is a subconcept/subrelation of <VAR>super</VAR>.
</DL>
</P><P>

<A NAME="IDX138"></A>
<DL>
<DT><U>Function:</U> <B>is-true</B> <I>((tv TRUTH-VALUE)) : BOOLEAN</I>
<DD>Tests whether <VAR>tv</VAR> is a true truth value.  It can be true
either absolutely or by default.
</DL>
</P><P>

<A NAME="IDX139"></A>
<DL>
<DT><U>Function:</U> <B>is-true-binary-proposition</B> <I>((relation LOGIC-OBJECT) (arg OBJECT) (value OBJECT) (module MODULE) (environment ENVIRONMENT)) : BOOLEAN</I>
<DD>Return TRUE if the proposition (<VAR>relation</VAR> <VAR>arg</VAR> <VAR>value</VAR>) has
been asserted (or inferred by forward chaining).
</DL>
</P><P>

<A NAME="IDX140"></A>
<DL>
<DT><U>Function:</U> <B>is-true-proposition</B> <I>((proposition PROPOSITION) (module MODULE) (environment ENVIRONMENT)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>proposition</VAR> is  TRUE in the module <VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX141"></A>
<DL>
<DT><U>Function:</U> <B>is-true-unary-proposition</B> <I>((relation LOGIC-OBJECT) (arg OBJECT) (module MODULE) (environment ENVIRONMENT)) : BOOLEAN</I>
<DD>Return TRUE if the proposition (<VAR>relation</VAR> <VAR>arg</VAR>) has
been asserted (or inferred by forward chaining).
</DL>
</P><P>

<A NAME="IDX142"></A>
<DL>
<DT><U>Function:</U> <B>is-unknown</B> <I>((tv TRUTH-VALUE)) : BOOLEAN</I>
<DD>Tests whether <VAR>tv</VAR> is an unknown truth value.
</DL>
</P><P>

<A NAME="IDX143"></A>
<DL>
<DT><U>Function:</U> <B>iterator-to-pl-iterator</B> <I>((self ITERATOR)) : PL-ITERATOR</I>
<DD>Convert an arbitrary Stella iterator into an API iterator.
</DL>
</P><P>

<A NAME="IDX144"></A>
<DL>
<DT><U>Method:</U> PL-ITERATOR <B>length</B> <I>(self) : INTEGER</I>
<DD>Number of items remaining in <VAR>self</VAR>.  Non destructive.
</DL>
</P><P>

<A NAME="IDX145"></A>
<DL>
<DT><U>Function:</U> <B>list-to-pl-iterator</B> <I>((self LIST)) : PL-ITERATOR</I>
<DD>Convert a Stella list into an API iterator.
</DL>
</P><P>

<A NAME="IDX146"></A>
<DL>
<DT><U>Function:</U> <B>load</B> <I>((filename STRING) (environment ENVIRONMENT)) :</I>
<DD>Read logic commands from the file named <VAR>filename</VAR> and evaluate them.
The file should begin with an <CODE>in-module</CODE> declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
<CODE>evaluate</CODE> to each of them.
</DL>
</P><P>

<A NAME="IDX147"></A>
<DL>
<DT><U>Function:</U> <B>load-stream</B> <I>((stream INPUT-STREAM) (environment ENVIRONMENT)) :</I>
<DD>Read logic commands from the STELLA stream <VAR>stream</VAR> and evaluate them.
The stream should begin with an <CODE>in-module</CODE> declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
<CODE>evaluate</CODE> to each of them.
</DL>
</P><P>

<A NAME="IDX148"></A>
<DL>
<DT><U>Function:</U> <B>load-native-stream</B> <I>((stream NATIVE-INPUT-STREAM) (environment ENVIRONMENT)) :</I>
<DD>Read logic commands from the native input stream <VAR>stream</VAR> and evaluate them.
Assumes <VAR>stream</VAR> is a line-buffered stream which is a safe compromise but does
not generate the best efficiency for block-buffered streams such as files.
The stream should begin with an <CODE>in-module</CODE> declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
<CODE>evaluate</CODE> to each of them.
</DL>
</P><P>

<A NAME="IDX149"></A>
<DL>
<DT><U>Method:</U> PL-ITERATOR <B>next?</B> <I>(self) : BOOLEAN</I>
<DD>Advance the PL-Iterator <VAR>self</VAR> and return <CODE>true</CODE> if more
elements are available, <CODE>false</CODE> otherwise.
</DL>
</P><P>

<A NAME="IDX150"></A>
<DL>
<DT><U>Function:</U> <B>object-to-float</B> <I>((self OBJECT)) : FLOAT</I>
<DD>Coerce <VAR>self</VAR> to a float, or throw a Stella Exception if the coersion is not feasible.
</DL>
</P><P>

<A NAME="IDX151"></A>
<DL>
<DT><U>Function:</U> <B>object-to-integer</B> <I>((self OBJECT)) : INTEGER</I>
<DD>Coerce <VAR>self</VAR> to an integer, or throw a Stella Exception if the coersion is not feasible.
Floating point values will be coerced by rounding.
</DL>
</P><P>

<A NAME="IDX152"></A>
<DL>
<DT><U>Function:</U> <B>object-to-parsable-string</B> <I>((self OBJECT)) : STRING</I>
<DD>Return a string representing a printed
representation of the object <VAR>self</VAR>.  Like <CODE>object-to-string</CODE>, but puts
escaped double quotes around strings.
</DL>
</P><P>

<A NAME="IDX153"></A>
<DL>
<DT><U>Function:</U> <B>object-to-string</B> <I>((self OBJECT)) : STRING</I>
<DD>Return a printed representation of the term <VAR>self</VAR> as a string.
</DL>
</P><P>

<A NAME="IDX154"></A>
<DL>
<DT><U>N-Command:</U> <B>print-rules</B> <I>((relation OBJECT)) :</I>
<DD>Print the list of true rules associated with <VAR>relation</VAR>.
</DL>
</P><P>

<A NAME="IDX155"></A>
<DL>
<DT><U>Function:</U> <B>reset-powerloom</B> <I>() :</I>
<DD>Reset PowerLoom to its initial state.
CAUTION: This will destroy all loaded knowledge bases and might break other
loaded STELLA systems if they do reference PowerLoom symbols in their code.
</DL>
</P><P>

<A NAME="IDX156"></A>
<DL>
<DT><U>N-Command:</U> <B>retract</B> <I>((proposition PARSE-TREE)) : OBJECT</I>
<DD>Retract the truth of <VAR>proposition</VAR>.  Return the retracted proposition
object.  KIF example:  "(retract (happy Fred))" retracts that Fred is
happy.  Note that for this assertion to succeed, the relation <CODE>happy</CODE> must already
be defined.  If the constant <CODE>Fred</CODE> has not yet been created, it is
automatically created as a side-effect of calling <CODE>retract</CODE>.
</DL>
</P><P>

<A NAME="IDX157"></A>
<DL>
<DT><U>Function:</U> <B>retract-binary-proposition</B> <I>((relation LOGIC-OBJECT) (arg OBJECT) (value OBJECT) (module MODULE) (environment ENVIRONMENT)) : PROPOSITION</I>
<DD>Retract that the proposition (<VAR>relation</VAR> <VAR>arg</VAR> <VAR>value</VAR>) is TRUE
in <VAR>module</VAR>.  Return the asserted proposition.
</DL>
</P><P>

<A NAME="IDX158"></A>
<DL>
<DT><U>Function:</U> <B>retract-nary-proposition</B> <I>((relation-and-arguments OBJECT) (module MODULE) (environment ENVIRONMENT)) : PROPOSITION</I>
<DD>Retract the proposition that <CODE>arguments</CODE> satisfies
the relation <CODE>relation</CODE>.
</DL>
</P><P>

<A NAME="IDX159"></A>
<DL>
<DT><U>Function:</U> <B>retract-proposition</B> <I>((proposition PROPOSITION) (module MODULE) (environment ENVIRONMENT)) : PROPOSITION</I>
<DD>Retract the truth of the proposition <VAR>proposition</VAR> in <VAR>module</VAR>.
Return the retracted proposition.
</DL>
</P><P>

<A NAME="IDX160"></A>
<DL>
<DT><U>Function:</U> <B>retract-unary-proposition</B> <I>((relation LOGIC-OBJECT) (arg OBJECT) (module MODULE) (environment ENVIRONMENT)) : PROPOSITION</I>
<DD>Retract that the proposition (<VAR>relation</VAR> <VAR>arg</VAR>) is TRUE in <VAR>module</VAR>.  Return the asserted proposition.
</DL>
</P><P>

<A NAME="IDX161"></A>
<DL>
<DT><U>Function:</U> <B>retrieve</B> <I>((query CONS) (module MODULE) (environment ENVIRONMENT)) : PL-ITERATOR</I>
<DD>Returns an iterator of variable bindings that when substituted for the
open variables in <VAR>query</VAR> satisfy the query proposition.  The query is
run in <VAR>module</VAR> and relative to <VAR>environment</VAR>.  <VAR>query</VAR> has the same syntax
as the PowerLoom <CODE>retrieve</CODE> command (which see) but with the <CODE>retrieve</CODE>
operator omitted.    For example, here are some legal <VAR>query</VAR> arguments:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    ((happy ?x))
    (10 (happy ?x))
    (all (happy ?x))
    (all ?x (happy ?x))
    (10 (happy ?x) :inference-level :assertion)
    (10 (happy ?x) :inference-level :assertion :timeout 1.0)
</pre></td></tr></table></P><P>

If there is only a single output variable (as in all the examples above)
each element generated by the returned iterator will be a binding for
that variable - unless, the output variable was declared with a surrounding
pair of parentheses.  For example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    (all (?x) (happy ?x))
</pre></td></tr></table></P><P>

In that case, the generated elements will be one-element lists.  If there
are multiple output variables, each element generated by the returned
iterator will be a list of variable bindings that can be accessed using
the various <CODE>get-nth-...</CODE> functions.  The list of output variables does
not need to be declared in which case they are taken to be the open variables
in the query proposition in the order in which they were encountered.  If
order does matter or should be different from its default, it can be forced
by declaring the set of output variables.
</DL>
</P><P>

<A NAME="IDX162"></A>
<DL>
<DT><U>Function:</U> <B>run-forward-rules</B> <I>((module OBJECT) (force? BOOLEAN)) :</I>
<DD>Run forward inference rules in module <VAR>module</VAR>.
If <VAR>module</VAR> is NULL, the
current module will be used.  If forward inferencing is already up-to-date
in the designated module, no additional inferencing will occur, unless <CODE>force</CODE>
is set to TRUE, in which case all forward rules are run or rerun.
</P><P>

Calling <CODE>run-forward-rules</CODE> temporarily puts the module into a mode where
future assertional (monotonic) updates will trigger additional forward
inference.  Once a non-monotonic update is performed, i.e., a retraction
or clipping of relation value, all cached forward inferences will be discarded
and forward inferencing will be disabled until this function is
called again.
</DL>
</P><P>

<A NAME="IDX163"></A>
<DL>
<DT><U>Function:</U> <B>s-ask</B> <I>((query STRING) (module-name STRING) (environment ENVIRONMENT)) : TRUTH-VALUE</I>
<DD>Returns a truth value for <VAR>query</VAR> in module <VAR>module-name</VAR> and <VAR>environment</VAR>.
<VAR>query</VAR> has the same syntax as the PowerLoom <CODE>ask</CODE> command (which see) but
with the <CODE>ask</CODE> operator omitted.  Different from the PLI <CODE>ask</CODE> function, <CODE>s-ask</CODE>
does not expect a top-level pair of parentheses.  For example, here are some legal
<VAR>query</VAR> arguments:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    "(happy Fred)"
    "(happy Fred) :inference-level :assertion"
    "(happy Fred) :inference-level :assertion :timeout 1.0"
</pre></td></tr></table></P><P>

Names in <VAR>query</VAR> will be interpreted relative to module <VAR>module-name</VAR>.
A null <VAR>module-name</VAR> or the empty string refers to the current module.
If no module can be found with the name <VAR>module-name</VAR>, then a STELLA
<CODE>no-such-context-exception</CODE> is thrown.
The returned truth value represents the logical truth of the queried sentence
as determined by PowerLoom.  It can be be tested via the functions <CODE>is-true</CODE>,
<CODE>is-false</CODE> and <CODE>is-unknown</CODE> (which see).
</DL>
</P><P>

<A NAME="IDX164"></A>
<DL>
<DT><U>Function:</U> <B>s-assert-proposition</B> <I>((sentence STRING) (module-name STRING) (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Assert that the logical sentence <VAR>sentence</VAR> is true in the module
named <VAR>module-name</VAR>.  A module name of <CODE>null</CODE> or the empty string refers to the
current module.  If no module can be found with the name <VAR>module-name</VAR>,
then a Stella <CODE>no-such-context-exception</CODE> is thrown.
</P><P>

Return an iterator of the propositions resulting from sentence.
</DL>
</P><P>

<A NAME="IDX165"></A>
<DL>
<DT><U>Function:</U> <B>s-change-module</B> <I>((name STRING) (environment ENVIRONMENT)) : MODULE</I>
<DD>Set the current module to the module named <VAR>name</VAR>.
The return value is the module named <VAR>name</VAR> unless <VAR>name</VAR> is null or
the empty string.  In that case, the current module is returned.
If no module named <VAR>name</VAR> exists, a Stella <CODE>no-such-context-exception</CODE>
is thrown.
</DL>
</P><P>

<A NAME="IDX166"></A>
<DL>
<DT><U>Function:</U> <B>s-clear-module</B> <I>((name STRING) (environment ENVIRONMENT)) : MODULE</I>
<DD>Destroy the contents of the module named <VAR>name</VAR>, as
well as the contents of all of its children, recursively.  If no module
named <VAR>name</VAR> exists, a Stella <CODE>no-such-context-exception</CODE> is thrown.
</DL>
</P><P>

<A NAME="IDX167"></A>
<DL>
<DT><U>Function:</U> <B>s-conceive</B> <I>((sentence STRING) (module-name STRING) (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Create one or more proposition objects from the sentence <VAR>sentence</VAR>
in the  module named <VAR>module-name</VAR>.  Return an iterator of the propositions.
If any of the new propositions has the same structure as an already existing
proposition, an automatic check for duplicates will return the pre-existing
proposition.  Multiple propositions may be returned for a single sentence
because of normalization of equivalences, conjunctions, etc.
</P><P>

A module name of <CODE>null</CODE> or the empty string refers to the current module.
If no module can be found with the name <VAR>module-name</VAR>, then a Stella
<CODE>No-Such-Context-Exception</CODE> is thrown.
</P><P>

Signals a <CODE>Proposition-Error</CODE> if PowerLoom could not conceive <VAR>sentence</VAR>.
</DL>
</P><P>

<A NAME="IDX168"></A>
<DL>
<DT><U>Function:</U> <B>s-create-concept</B> <I>((name STRING) (parent-name STRING) (module-name STRING) (environment ENVIRONMENT)) : LOGIC-OBJECT</I>
<DD>Create a concept named <VAR>name</VAR> in the designated module, with
with the concept named <VAR>parent-name</VAR> as superconcept (which can be left
undefined).  Additional superconcepts can be added via assertions of the
<CODE>subset-of</CODE> relation.  Note that a specified parent concept needs to be
created separately.
</P><P>

A module name of <CODE>null</CODE> or the empty string refers to the current module. 
If no module can be found with the name <VAR>module-name</VAR>, then a Stella 
<CODE>no-such-context-exception</CODE> is thrown.
</P><P>

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match <VAR>name</VAR> exactly.
</DL>
</P><P>

<A NAME="IDX169"></A>
<DL>
<DT><U>Function:</U> <B>s-create-function</B> <I>((name STRING) (arity INTEGER) (module-name STRING) (environment ENVIRONMENT)) : LOGIC-OBJECT</I>
<DD>Create a function named <VAR>name</VAR> with arity <VAR>arity</VAR> in the designated 
module.  Domain and range information can be added via assertions of
<CODE>domain</CODE>, <CODE>nth-domain</CODE> and <CODE>range</CODE> relations.
</P><P>

A module name of <CODE>null</CODE> or the empty string refers to the current module. 
If no module can be found with the name <VAR>module-name</VAR>, then a Stella 
<CODE>no-such-context-exception</CODE> is thrown.
</P><P>

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match <VAR>name</VAR> exactly.
</DL>
</P><P>

<A NAME="IDX170"></A>
<DL>
<DT><U>Function:</U> <B>s-create-object</B> <I>((name STRING) (concept-name STRING) (module-name STRING) (environment ENVIRONMENT)) : LOGIC-OBJECT</I>
<DD>Create an object named <VAR>name</VAR> of type <VAR>concept-name</VAR> in the designated
module.  Both <VAR>name</VAR> and <VAR>concept-name</VAR> can be null strings.  If <VAR>name</VAR> is a null string
then an object will be created with a new, non-conflicting name based on <VAR>concept-name</VAR>, or
system-generated if no concept nameis specified.  If <VAR>concept-name</VAR> is the null string, then
the object will be of type THING.
</P><P>

A module name of <CODE>null</CODE> or the empty string refers to the current module. 
If no module can be found with the name <VAR>module-name</VAR>, then a Stella 
<CODE>no-such-context-exception</CODE> is thrown.
</P><P>

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match <VAR>name</VAR> exactly.
</P><P>

Return the object.
</DL>
</P><P>

<A NAME="IDX171"></A>
<DL>
<DT><U>Function:</U> <B>s-create-module</B> <I>((name STRING) (parent-name STRING) (case-sensitive? BOOLEAN) (environment ENVIRONMENT)) : MODULE</I>
<DD>Creates a new module <VAR>name</VAR> as a child of <VAR>parent-name</VAR>.  The flag
<VAR>case-sensitive?</VAR> controls whether names read in this module will be
case sensitive or not.
</DL>
</P><P>

<A NAME="IDX172"></A>
<DL>
<DT><U>Function:</U> <B>s-create-relation</B> <I>((name STRING) (arity INTEGER) (module-name STRING) (environment ENVIRONMENT)) : LOGIC-OBJECT</I>
<DD>Create a relation named <VAR>name</VAR> with arity <VAR>arity</VAR> in the
designated module.  Domain and range information can be added via assertions
of <CODE>nth-domain</CODE> (or <CODE>domain</CODE> and <CODE>range</CODE>) relations.
</P><P>

A module name of <CODE>null</CODE> or the empty string refers to the current module. 
If no module can be found with the name <VAR>module-name</VAR>, then a Stella 
<CODE>no-such-context-exception</CODE> is thrown.
</P><P>

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match <VAR>name</VAR> exactly.
</DL>
</P><P>

<A NAME="IDX173"></A>
<DL>
<DT><U>Function:</U> <B>s-destroy-object</B> <I>((object-name STRING) (module-name STRING) (environment ENVIRONMENT)) :</I>
<DD>Delete the object named <VAR>object-name</VAR>, retracting all facts
attached to it.
</P><P>

A module name of <CODE>null</CODE> or the empty string refers to the current module. 
If no module can be found with the name <VAR>module-name</VAR>, then a Stella 
<CODE>no-such-context-exception</CODE> is thrown.
</DL>
</P><P>

<A NAME="IDX174"></A>
<DL>
<DT><U>Function:</U> <B>s-evaluate</B> <I>((command STRING) (module-name STRING) (environment ENVIRONMENT)) : OBJECT</I>
<DD>Evaluate the command represented by the string <VAR>command</VAR> within <CODE>module</CODE> and
return the result.  Currently, only the evaluation of (possibly nested) commands and
global variables is supported.
</P><P>

 A module name of <CODE>null</CODE> or the empty string refers to the
current module.  If no module can be found with the name <VAR>module-name</VAR>,
then a Stella <CODE>no-such-context-exception</CODE> is thrown.
</DL>
</P><P>

<A NAME="IDX175"></A>
<DL>
<DT><U>Function:</U> <B>s-get-arity</B> <I>((relation-name STRING) (module-name STRING) (environment ENVIRONMENT)) : INTEGER</I>
<DD>Return the arity of the relation named <VAR>relation-name</VAR>.
</P><P>

 A module name of <CODE>null</CODE> or the empty string refers to the
current module.  If no module can be found with the name <VAR>module-name</VAR>,
then a Stella <CODE>no-such-context-exception</CODE> is thrown.
</DL>
</P><P>

<A NAME="IDX176"></A>
<DL>
<DT><U>Function:</U> <B>s-get-child-modules</B> <I>((name STRING) (environment ENVIRONMENT)) : (PL-ITERATOR OF MODULE)</I>
<DD>Return the modules that are immediate children of module <VAR>name</VAR>.
If no module named <VAR>name</VAR> exists, a Stella <CODE>no-such-context-exception</CODE>
is thrown.
</DL>
</P><P>

<A NAME="IDX177"></A>
<DL>
<DT><U>Function:</U> <B>s-get-concept</B> <I>((name STRING) (module-name STRING) (environment ENVIRONMENT)) : LOGIC-OBJECT</I>
<DD>Return a class/concept named <VAR>name</VAR> that is local to
or visible from the module <VAR>module-name</VAR>.  A module name of <CODE>null</CODE> or the
empty string refers to the current module.  If no module can be found
with the name <VAR>module-name</VAR>, then a Stella <CODE>no-such-context-exception</CODE> is thrown.
</DL>
</P><P>

<A NAME="IDX178"></A>
<DL>
<DT><U>Function:</U> <B>s-get-concept-instances</B> <I>((concept-name STRING) (module-name STRING) (environment ENVIRONMENT)) : PL-ITERATOR</I>
<DD>Return instances of concept <VAR>concept-name</VAR>.
Include instances of subconcepts of <VAR>concept-name</VAR>.  Depending on <VAR>concept-name</VAR>,
the return values could be (wrapped) literals.
</P><P>

A module name of <CODE>null</CODE> or the empty string refers to the current module. 
If no module can be found with the name <VAR>module-name</VAR>, then a Stella 
<CODE>no-such-context-exception</CODE> is thrown.
</DL>
</P><P>

<A NAME="IDX179"></A>
<DL>
<DT><U>Function:</U> <B>s-get-direct-concept-instances</B> <I>((concept-name STRING) (module-name STRING) (environment ENVIRONMENT)) : PL-ITERATOR</I>
<DD>Return instances of concept <VAR>concept-name</VAR>.
Exclude instances of subconcepts of <VAR>concept-name</VAR>.  Depending on <VAR>concept-name</VAR>,
the return values could be (wrapped) literals.
</P><P>

A module name of <CODE>null</CODE> or the empty string refers to the current module. 
If no module can be found with the name <VAR>module-name</VAR>, then a Stella 
<CODE>no-such-context-exception</CODE> is thrown.
</DL>
</P><P>

<A NAME="IDX180"></A>
<DL>
<DT><U>Function:</U> <B>s-get-domain</B> <I>((relation-name STRING) (module-name STRING) (environment ENVIRONMENT)) : LOGIC-OBJECT</I>
<DD>Return the type (concept) for the first argument to the binary
relation <VAR>relation-name</VAR>.
</P><P>

A module name of <CODE>null</CODE> or the empty string refers to the
current module.  If no module can be found with the name <VAR>module-name</VAR>,
then a Stella <CODE>no-such-context-exception</CODE> is thrown.
</DL>
</P><P>

<A NAME="IDX181"></A>
<DL>
<DT><U>Function:</U> <B>s-get-inferred-binary-proposition-values</B> <I>((relation-name STRING) (arg-name STRING) (module-name STRING) (environment ENVIRONMENT)) : PL-ITERATOR</I>
<DD>Return all values <CODE>v</CODE> such that (<VAR>relation-name</VAR> <VAR>arg-name</VAR> <CODE>v</CODE>)
has been asserted or can be inferred.
</P><P>

A module name of <CODE>null</CODE> or the empty string refers to the current module. 
If no module can be found with the name <VAR>module-name</VAR>, then a Stella 
<CODE>no-such-context-exception</CODE> is thrown.
</DL>
</P><P>

<A NAME="IDX182"></A>
<DL>
<DT><U>Function:</U> <B>s-get-nth-domain</B> <I>((relation-name STRING) (n INTEGER) (module-name STRING) (environment ENVIRONMENT)) : LOGIC-OBJECT</I>
<DD>Return the type (a concept) for the nth argument of the relation
named <VAR>relation-name</VAR>.  Counting starts at zero.
</P><P>

A module name of <CODE>null</CODE> or the empty string refers to the
current module.  If no module can be found with the name <VAR>module-name</VAR>,
then a Stella <CODE>no-such-context-exception</CODE> is thrown.
</DL>
</P><P>

<A NAME="IDX183"></A>
<DL>
<DT><U>Function:</U> <B>s-get-object</B> <I>((name STRING) (module-name STRING) (environment ENVIRONMENT)) : OBJECT</I>
<DD>Look for an object named <VAR>name</VAR> that is local to
or visible from the module <VAR>module-name</VAR>.  A module name of <CODE>null</CODE> or the
empty string refers to the current module.  If no module can be found
with the name <VAR>module-name</VAR>, then a Stella <CODE>no-such-context-exception</CODE> is thrown.
</DL>
</P><P>

<A NAME="IDX184"></A>
<DL>
<DT><U>Function:</U> <B>s-get-parent-modules</B> <I>((name STRING) (environment ENVIRONMENT)) : (PL-ITERATOR OF MODULE)</I>
<DD>Return the modules that are immediate parents of module <VAR>name</VAR>.
If no module named <VAR>name</VAR> exists, a Stella <CODE>no-such-context-exception</CODE>
is thrown.
</DL>
</P><P>

<A NAME="IDX185"></A>
<DL>
<DT><U>Function:</U> <B>s-get-parent-modules</B> <I>((name STRING) (environment ENVIRONMENT)) : (PL-ITERATOR OF MODULE)</I>
<DD>Return the modules that are immediate parents of module <VAR>name</VAR>.
If no module named <VAR>name</VAR> exists, a Stella <CODE>no-such-context-exception</CODE>
is thrown.
</DL>
</P><P>

<A NAME="IDX186"></A>
<DL>
<DT><U>Function:</U> <B>s-get-proposition</B> <I>((relation-and-arguments STRING) (module-name STRING) (environment ENVIRONMENT)) : PROPOSITION</I>
<DD>Return a proposition matching <VAR>relation-and-arguments</VAR> that
has been asserted (or inferred by forward chaining).  <VAR>relation-and-arguments</VAR>
is a string that begins with a left parenthesis, followed by a relation name, 
one or more argument identifiers, and terminated by a right parenthesis.  Each
argument identifier can be the name of a logical constant, a literal
reference (e.g., a number), the null identifier, or a variable (an identifier that begins
with a question mark). Each occurrence of a null or a variable acts like a wild card.
If more than one proposition matches the input criteria, the selection among
satisficing propositions is arbitrary.  This procedure is normally applied to
single-valued relations or functions.
</P><P>

A module name of <CODE>null</CODE> or the
empty string refers to the current module.  If no module can be found
with the name <VAR>module-name</VAR>, then a Stella <CODE>no-such-context-exception</CODE> is thrown.
</DL>
</P><P>

<A NAME="IDX187"></A>
<DL>
<DT><U>Function:</U> <B>s-get-propositions</B> <I>((relation-and-arguments STRING) (module-name STRING) (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Return propositions matching <VAR>relation-and-arguments</VAR> that
have been asserted (or inferred by forward chaining).  <VAR>relation-and-arguments</VAR>
is a string that begins with a left parenthesis, followed by a relation name, 
one or more argument identifiers, and terminated by a right parenthesis.  Each
argument identifier can be the name of a logical constant, a literal 
reference (e.g., a number), the null identifier, or a variable (an identifier that begins
with a question mark). Each occurrence of a null or a variable acts like a wild card.
</P><P>

A module name of <CODE>null</CODE> or the
empty string refers to the current module.  If no module can be found
with the name <VAR>module-name</VAR>, then a Stella <CODE>no-such-context-exception</CODE> is thrown.
</DL>
</P><P>

<A NAME="IDX188"></A>
<DL>
<DT><U>Function:</U> <B>s-get-propositions-of</B> <I>((object-name STRING) (module-name STRING) (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Return all propositions that have the object named <VAR>object-name</VAR> among
their arguments, and that are TRUE in the scope of the module <VAR>module-name</VAR>.
A module name of <CODE>null</CODE> or the empty string refers to the current module. 
If no module can be found with the name <VAR>module-name</VAR>, then a Stella 
<CODE>no-such-context-exception</CODE> is thrown.
</DL>
</P><P>

<A NAME="IDX189"></A>
<DL>
<DT><U>Function:</U> <B>s-get-range</B> <I>((relation-name STRING) (module-name STRING) (environment ENVIRONMENT)) : LOGIC-OBJECT</I>
<DD>Return the type (a concept) for fillers of the binary relation
<VAR>relation-name</VAR>.
</P><P>

A module name of <CODE>null</CODE> or the empty string refers to the
current module.  If no module can be found with the name <VAR>module-name</VAR>,
then a Stella <CODE>no-such-context-exception</CODE> is thrown.
</DL>
</P><P>

<A NAME="IDX190"></A>
<DL>
<DT><U>Function:</U> <B>s-get-relation</B> <I>((name STRING) (module-name STRING) (environment ENVIRONMENT)) : LOGIC-OBJECT</I>
<DD>Return a concept or relation named <VAR>name</VAR> that is local to
or visible from the module <VAR>module-name</VAR>.  A module name of <CODE>null</CODE> or the
empty string refers to the current module.  If no module can be found
with the name <VAR>module-name</VAR>, then a Stella <CODE>no-such-context-exception</CODE> is thrown.
</DL>
</P><P>

<A NAME="IDX191"></A>
<DL>
<DT><U>Function:</U> <B>s-get-relation-extension</B> <I>((relation-name STRING) (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Return propositions that satisfy the relation named
<VAR>relation-name</VAR>.  Include propositions that satisfy subrelations of the relation.
</DL>
</P><P>

<A NAME="IDX192"></A>
<DL>
<DT><U>Function:</U> <B>s-get-rules</B> <I>((relation-name STRING) (module-name STRING) (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Return rules attached to the concept/relation named
<VAR>relation-name</VAR> found in the module named <VAR>module-name</VAR>.
</P><P>

A module name of <CODE>null</CODE> or the empty string refers to the current module.
If no module can be found with the name <VAR>module-name</VAR>, then a Stella
<CODE>No-Such-Context-Exception</CODE> is thrown.
</DL>
</P><P>

<A NAME="IDX193"></A>
<DL>
<DT><U>Function:</U> <B>s-is-true-proposition</B> <I>((relation-and-arguments STRING) (module-name STRING) (environment ENVIRONMENT)) : BOOLEAN</I>
<DD>Return TRUE if a proposition that prints as the string
<VAR>relation-and-arguments</VAR> is true in the module named <VAR>module-name</VAR>.
A module name of <CODE>null</CODE> or the empty string refers to the current module. 
If no module can be found with the name <VAR>module-name</VAR>, then a Stella 
<CODE>no-such-context-exception</CODE> is thrown.
</DL>
</P><P>

<A NAME="IDX194"></A>
<DL>
<DT><U>Function:</U> <B>s-print-rules</B> <I>((name STRING) (stream OUTPUT-STREAM) (module-name STRING) (environment ENVIRONMENT)) :</I>
<DD>Print rules attached to the concept/relation named <VAR>name</VAR>.
</P><P>

A module name of <CODE>null</CODE> or the empty string refers to the
current module.  If no module can be found with the name <VAR>module-name</VAR>,
then a Stella <CODE>no-such-context-exception</CODE> is thrown.
</DL>
</P><P>

<A NAME="IDX195"></A>
<DL>
<DT><U>Function:</U> <B>s-retract-proposition</B> <I>((sentence STRING) (module-name STRING) (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Retract the truth of the logical sentence <VAR>sentence</VAR> in the module named
<VAR>module-name</VAR>.  A module name of <CODE>null</CODE> or the empty string refers to the
current module.  If no module can be found with the name <VAR>module-name</VAR>,
then a Stella <CODE>no-such-context-exception</CODE> is thrown.
</P><P>

Return an iterator of the retracted propositions resulting from sentence.
</DL>
</P><P>

<A NAME="IDX196"></A>
<DL>
<DT><U>Function:</U> <B>s-retrieve</B> <I>((query STRING) (module-name STRING) (environment ENVIRONMENT)) : PL-ITERATOR</I>
<DD>Returns an iterator of variable bindings that when substituted for the
open variables in <VAR>query</VAR> satisfy the query proposition.  The query is
run in <CODE>module</CODE> and relative to <VAR>environment</VAR>.  <VAR>query</VAR> has the same syntax
as the PowerLoom <CODE>retrieve</CODE> command (which see) but with the <CODE>retrieve</CODE>
operator omitted.  Different from the PLI <CODE>retrieve</CODE> function, <CODE>s-retrieve</CODE>
does not expect a top-level pair of parentheses.  For example, here are some
legal <VAR>query</VAR> arguments:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    "(happy ?x)"
    "10 (happy ?x)"
    "all (happy ?x)"
    "all ?x (happy ?x)"
    "10 (happy ?x) :inference-level :assertion"
    "10 (happy ?x) :inference-level :assertion :timeout 1.0"
</pre></td></tr></table></P><P>

If there is only a single output variable (as in all the examples above)
each element generated by the returned iterator will be a binding for
that variable - unless, the output variable was declared with a surrounding
pair of parentheses.  For example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    "all (?x) (happy ?x)"
</pre></td></tr></table></P><P>

In that case, the generated elements will be one-element lists.  If there
are multiple output variables, each element generated by the returned
iterator will be a list of variable bindings that can be accessed using
the various <CODE>get-nth-...</CODE> functions.  The list of output variables does
not need to be declared in which case they are taken to be the open variables
in the query proposition in the order in which they were encountered.  If
order does matter or should be different from its default, it can be forced
by declaring the set of output variables.
</P><P>

Names in <VAR>query</VAR> will be interpreted relative to module <VAR>module-name</VAR>.
A null <VAR>module-name</VAR> or the empty string refers to the current module.
If no module can be found with the name <VAR>module-name</VAR>, then a STELLA
<CODE>no-such-context-exception</CODE> is thrown.
</DL>
</P><P>

<A NAME="IDX197"></A>
<DL>
<DT><U>Function:</U> <B>s-save-module</B> <I>((module-name STRING) (filename STRING) (ifexists STRING) (environment ENVIRONMENT)) :</I>
<DD>Save the contents of the module <VAR>module-name</VAR> into a file named <VAR>filename</VAR>.
If a file named <VAR>filename</VAR> already exists, then the action taken depends on the
value of <VAR>ifexists</VAR>.  Possible values are "ASK", "REPLACE", "WARN" and "ERROR":
</P><P>

  REPLACE =&#62; Means overwrite without warning.
  WARN    =&#62; Means overwrite with a warning.
  ERROR   =&#62; Means don't overwrite, signal an error instead.
  ASK     =&#62; Ask the user whether to overwrite or not.  If not overwritten, an
             exception is thrown.
</P><P>

A module name of <CODE>null</CODE> or the empty string refers to the
current module.  If no module can be found with the name <VAR>module-name</VAR>,
then a Stella <CODE>no-such-context-exception</CODE> is thrown.
</DL>
</P><P>

<A NAME="IDX198"></A>
<DL>
<DT><U>Function:</U> <B>save-module</B> <I>((module MODULE) (filename STRING) (ifexists STRING) (environment ENVIRONMENT)) :</I>
<DD>Save the contents of the module <CODE>mod</CODE> into a file named <VAR>filename</VAR>.
If a file named <VAR>filename</VAR> already exists, then the action taken depends on the
value of <VAR>ifexists</VAR>.  Possible values are "ASK", "REPLACE", "WARN" and "ERROR":
</P><P>

  REPLACE =&#62; Means overwrite without warning.
  WARN    =&#62; Means overwrite with a warning.
  ERROR   =&#62; Means don't overwrite, signal an error instead.
  ASK     =&#62; Ask the user whether to overwrite or not.  If not overwritten, an 
             exception is thrown.
</DL>
</P><P>

<A NAME="IDX199"></A>
<DL>
<DT><U>Function:</U> <B>string-to-object</B> <I>((string STRING) (type LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT)) : OBJECT</I>
<DD>Evaluate <VAR>string</VAR> with respect to <VAR>module</VAR> and <VAR>environment</VAR>
and return the corresponding logical term.  <VAR>type</VAR> is a concept used to assist the
correct interpretation of <VAR>string</VAR>.
</P><P>

Currently <VAR>type</VAR> only has an effect on the interpretation of literal types.
</DL>
</P><P>

<A NAME="Language Specific Interface"></A>
<HR SIZE="6">
<A NAME="SEC42"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC41"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC43"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_8.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 7.2 Language Specific Interface </H2>
<!--docid::SEC42::-->
<P>

This section contains the description of the programming language
specific aspects of using the PowerLoom API.  Each section describes the 
naming conventions and namespace issues related to calling the API
functions from that programming language.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_7.html#SEC43">7.2.1 Lisp API</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_7.html#SEC50">7.2.2 C++ API</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_7.html#SEC51">7.2.3 Java API</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Lisp API"></A>
<HR SIZE="6">
<A NAME="SEC43"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC42"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC44"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC41"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC42"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC50"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 7.2.1 Lisp API </H3>
<!--docid::SEC43::-->
<P>

This section tells how to call the API functions in PowerLoom's Common
Lisp implementation from a Lisp program.  The function names are
identical to the Stella names in the PowerLoom API description
See section <A HREF="manual_7.html#SEC40">7. PowerLoom API</A>.  They are exported from the <CODE>PLI</CODE> package.
Other Stella symbols and names are in the <CODE>STELLA</CODE> package, but
<STRONG>currently none of the Stella symbols are exported!</STRONG>.
</P><P>

PowerLoom can be used from Allegro Common Lisp, CMU Common Lisp,
LispWorks Common Lisp and Macintosh Common Lisp.  It may be possible to
use the system from other Common Lisp systems, but they have not been
tested.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_7.html#SEC44">7.2.1.1 Common Lisp Initialization</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_7.html#SEC45">7.2.1.2 Type Declarations</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_7.html#SEC46">7.2.1.3 NULL values</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_7.html#SEC47">7.2.1.4 Wrapped Literal Values</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_7.html#SEC48">7.2.1.5 Special Variables</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_7.html#SEC49">7.2.1.6 CLOS Objects versus Structs</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Initialization"></A>
<HR SIZE="6">
<A NAME="SEC44"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC43"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC45"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC42"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC43"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC50"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 7.2.1.1 Common Lisp Initialization </H4>
<!--docid::SEC44::-->
<P>

Loading the Common Lisp version of PowerLoom will normally initialize
the system as part of the loading process.  The Common Lisp version can
be loaded by loading the file `<TT>load-powerloom.lisp</TT>' from the
top-level `<TT>powerloom</TT>' directory.  This will make the system
available for use.
</P><P>

<A NAME="Type Declarations"></A>
<HR SIZE="6">
<A NAME="SEC45"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC44"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC46"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC42"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC43"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC50"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 7.2.1.2 Type Declarations </H4>
<!--docid::SEC45::-->
<P>

Stella is a typed language, and the Common Lisp translation uses the
type information for Common Lisp type declarations.  That means that
values specified as being of type INTEGER, STRING and FLOAT must have
the correct type.  In particular, integer values will not be coerced to
floating point values by the code.  The following native type
assignments are made:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    Stella      Common Lisp
    =======     ===========
    INTEGER     FIXNUM
    FLOAT       DOUBLE-FLOAT
    STRING      SIMPLE-STRING
</pre></td></tr></table></P><P>

<STRONG>For convenience, loading PowerLoom will set the default format for
reading floating point numbers in Common Lisp to be <CODE>double-float</CODE>.</STRONG>
</P><P>

Stella <CODE>CONS</CODE> objects are implmented as native Lisp conses.
Boolean values can take on the values <CODE>stella::true</CODE> or
<CODE>stella::false</CODE>.
</P><P>

<A NAME="NULL Values"></A>
<HR SIZE="6">
<A NAME="SEC46"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC45"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC47"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC42"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC43"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC50"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 7.2.1.3 NULL values </H4>
<!--docid::SEC46::-->
<P>

One additional consequence of the strong typing of the language is that
there are specialized <CODE>NULL</CODE> values for numeric and string parameters.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  Stella Type   Null Value
  ===========   ===========
    INTEGER     stella::null-integer
    FLOAT       stella::null-float
    STRING      stella::null-string
</pre></td></tr></table></P><P>

<A NAME="Wrapped Literal Values"></A>
<HR SIZE="6">
<A NAME="SEC47"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC46"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC48"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC42"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC43"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC50"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 7.2.1.4 Wrapped Literal Values </H4>
<!--docid::SEC47::-->
<P>

Literal values (integers, floats, strings, etc.) that are used in
PowerLoom appear as wrapped values.  The PowerLoom API functions
<CODE>object-to-...</CODE> can be used to coerce the values into the
appropriate return type.
</P><P>

&#60;to be written:  wrapping values&#62;
</P><P>

<A NAME="Special Variables"></A>
<HR SIZE="6">
<A NAME="SEC48"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC47"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC49"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC42"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC43"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC50"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 7.2.1.5 Special Variables </H4>
<!--docid::SEC48::-->
<P>

All Stella special variables are implemented as Common Lisp special
variables.  Binding of the values can be used normally.
</P><P>

<A NAME="CLOS Objects versus Structs"></A>
<HR SIZE="6">
<A NAME="SEC49"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC48"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC50"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC42"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC43"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC50"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 7.2.1.6 CLOS Objects versus Structs </H4>
<!--docid::SEC49::-->
<P>

PowerLoom can be translated in one of two ways for Common Lisp.  One
method uses CLOS objects as the basis for all Stella and PowerLoom
objects.  For faster execution, it is also possible to use a version in
which Stella and PowerLoom objects are implemented using Common Lisp
structs instead.  This is controlled by the special variable 
<CODE>cl-user::*load-cl-struct-stella?*</CODE>.  If this is set to
<CODE>cl:t</CODE>, then the struct version will be loaded.  This needs to be
set before loading the `<TT>load-powerloom.lisp</TT>' file.
</P><P>

<A NAME="C++ API"></A>
<HR SIZE="6">
<A NAME="SEC50"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC49"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC51"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC43"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC42"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_8.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 7.2.2 C++ API </H3>
<!--docid::SEC50::-->
<P>

&#60;to be written&#62;
</P><P>

<A NAME="Java API"></A>
<HR SIZE="6">
<A NAME="SEC51"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC50"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC41"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC42"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_8.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 7.2.3 Java API </H3>
<!--docid::SEC51::-->
<P>

This section tells how to call the API functions in PowerLoom's Java
implementation from a Java program.  The Java translation is written for
Java version 1.2.  All of the PowerLoom Interface functions appear as
static methods of the class <CODE>edu.isi.powerloom.PLI</CODE>.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_7.html#SEC52">7.2.3.1 Initializing PowerLoom</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_7.html#SEC53">7.2.3.2 PowerLoom Java Conventions</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_7.html#SEC54">7.2.3.3 Using the PLI Class</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_7.html#SEC55">7.2.3.4 Using Stella Objects</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_7.html#SEC56">7.2.3.5 PowerLoom and Threads</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_7.html#SEC57">7.2.3.6 Setting and Restoring Global Variable Values</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_7.html#SEC58">7.2.3.7 Java Character Mapping</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_7.html#SEC59">7.2.3.8 Stella Exceptions in Java</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_7.html#SEC60">7.2.3.9 Iteration in Java</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_7.html#SEC61">7.2.3.10 Utility Classes for Java</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Initializing PowerLoom"></A>
<HR SIZE="6">
<A NAME="SEC52"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC51"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC53"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC50"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC51"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_8.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 7.2.3.1 Initializing PowerLoom </H4>
<!--docid::SEC52::-->
<P>

PowerLoom needs to run initialization functions to set up its
environment for proper operation when it starts up.  The simplest method 
for initializing PowerLoom is to use the static method call:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>        PLI.initialize()
</pre></td></tr></table></P><P>

This must be called before using any PowerLoom features and before
loading any PowerLoom knowledge bases.  It may be called more than once
without ill effect.
</P><P>

<A NAME="PowerLoom Java Conventions"></A>
<HR SIZE="6">
<A NAME="SEC53"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC54"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC50"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC51"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_8.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 7.2.3.2 PowerLoom Java Conventions </H4>
<!--docid::SEC53::-->
<P>

PowerLoom's Java code is automatically generated by a translator from
underlying Stella code.  The character set for legal Stella names is larger
than the character set for legal Java identifiers, so there is some mapping
involved.
</P><P>

PowerLoom names are words separated by hyphen (-) characters.  For Java,
we have attempted to closely follow the Java conventions:
</P><P>

<UL>
<LI>
Class names begin with a capital letter and each word is capitalized.
The hyphens from the PowerLoom names are removed.  Example:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>        string-wrapper   =&#62;  StringWrapper
</pre></td></tr></table>   Exceptions are made for class names that would otherwise conflict with
   normal Java Classes.  In that case, the prefix "Stella_" is added to each
   class name.  At the moment this applies only to the following exceptions:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>        object    =&#62;  Stella_Object
        class     =&#62;  Stella_Class
</pre></td></tr></table><P>

<LI>
Method and Function names begin with a lower case letter but each
subsequent word is capitalized.  The hyphens from PowerLoom names are
removed.  Example:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>        wrapper-value    =&#62;  wrapperValue
</pre></td></tr></table><P>

<LI>
Storage slots are implemented as Java fields.  The names begin with a
lower case letter but each subsequent word is capitalized.  The hyphens
from PowerLoom names are removed.  Example:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>        dynamic-slots    =&#62;  dynamicSlots
</pre></td></tr></table><P>

<LI>
Global and Special variable names are written in all uppercase.  The
hyphens from PowerLoom are replaced by underscore (_) characters.  By
convention, special variables are written in PowerLoom with surrounding
asterisk (*) characters.  The asterisks are replaced by dollar signs ($).
Example:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>        *html-quoted-characters*  =&#62;  $HTML_QUOTED_CHARACTERS$
</pre></td></tr></table></UL>
<P>

The most common non-alphanumeric characters are mapped as follows.  A
full set of mappings is in section <A HREF="manual_7.html#SEC58">7.2.3.7 Java Character Mapping</A>.
<TABLE><tr><td>&nbsp;</td><td class=example><pre>   ?  =&#62;  P      (for Predicate)
   !  =&#62;  X      (eXclamation)
   $  =&#62;  B      (Buck)
   %  =&#62;  R      (peRcent)
   &#38;  =&#62;  A      (Ampersand)
   *  =&#62;  $      Special variable marker.
</pre></td></tr></table></P><P>

The character mappings use uppercase characters if the basic identifier
uses mixed or lower case.  The mappings use lowercase characters if the
basic identifier uses upper case.
</P><P>

Stella modules are mapped to Java packages.  The basic system
distribution includes the following package hierarchy:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  edu
     isi
        stella
            javalib
        powerloom
            logic
            pl_kernel_kb
                loom_api
</pre></td></tr></table></P><P>

Basic system functionality and data structures such as Cons and List
objects are defined in stella.  PowerLoom's logic (concepts,
relations, rules, etc.) are defined in the logic package.  There is a
set of interface functions in the PLI class in the powerloom package.
They are described in their own section below.
</P><P>

We recommend the following import statements in Java files that use
PowerLoom:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>        import edu.isi.stella.*;
        import edu.isi.stella.javalib.*;
        import edu.isi.powerloom.PLI;
        import edu.isi.powerloom.logic.*;
</pre></td></tr></table></P><P>

Functions (in Java terms, static Methods) are translated as static methods
on the class of their first argument (as long as that argument is not a
primitive type and is in the same Stella module).  Functions which take no
arguments, those whose first argument is a primitive type, and those whose
first argument is a class not defined in the same module are all placed
into a class with the same name as the Stella module in which it appers.
It will be in the package corresponding to that Stella module.  Java
constructors should not be called directly.  Instead, there will be a
static method <CODE>new&#60;ClassName&#62;</CODE> (with the class name in mixed case!) that
should be used instead.
</P><P>

Most of the functions of interest will be in the edu.isi.stella.Stella, 
edu.isi.powerloom.PLI or edu.isi.powerloom.logic.Logic classes.
</P><P>

Methods typically refer to their first argument as "self".
</P><P>

Methods which return more than one return value will take a final
argument which is an array of <CODE>Stella_Object</CODE>, which will be used to
return the additional arguments.
</P><P>

Primitive types in Stella have the following mapping in Java:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>        Stella          Java
        ======          ====
        INTEGER         int
        FLOAT           double
        NUMBER          double
        CHARACTER       char
        BOOLEAN         boolean
        STRING          String
        MUTABLE-STRING  StringBuffer

  NATIVE-OUTPUT-STREAM  java.io.PrintStream
  NATIVE-INPUT-STREAM   java.io.PushbackInputStream  (May change!!!)
</pre></td></tr></table></P><P>

Inside Stella/PowerLoom objects and collections, primitive types are
wrapped using Stella wrappers instead of Java's primitive classes.  So
integers will be wrapped as edu.isi.stella.IntegerWrapper rather than
java.lang.Integer.  Wrappers have a field called wrapperValue which
accesses the internal value.  Example of use:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    import edu.isi.stella.*;
    import edu.isi.stella.javalib.*;
    ...
    IntegerWrapper iWrap = IntegerWrapper.wrapInteger(42);
    ...
    int answer = iWrap.wrapperValue;
    ...
</pre></td></tr></table></P><P>

<A NAME="Using the PLI Class"></A>
<HR SIZE="6">
<A NAME="SEC54"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC53"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC55"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC50"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC51"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_8.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 7.2.3.3 Using the PLI Class </H4>
<!--docid::SEC54::-->
<P>

To make interoperability between PowerLoom and Java a little simpler, we
are providing a (PowerLoom Interface class named <CODE>PLI</CODE> which
handles synchronization issues, setting and restoring the reasoning
context, and the a more convenient use of some Java-native objects
rather than Stella objects.  Generally that means that strings are used
for PowerLoom expressions and return values rather than Stella
<CODE>Cons</CODE> objects.
</P><P>

Details about the methods can be found in the section <A HREF="manual_7.html#SEC40">7. PowerLoom API</A>.  The names of functions in that section will need to be converted
to their Java equivalents using the conventions described in
<A HREF="manual_7.html#SEC53">7.2.3.2 PowerLoom Java Conventions</A>.  We also provide javadoc
documentation for the <CODE>edu.isi.powerloom.PLI</CODE> class.  We recommend
using this method for accessing PowerLoom functionality.  We expect to
expand the range of PowerLoom interface functions that have an analog in
the <CODE>PLI</CODE> class over time.
</P><P>

<A NAME="Using Stella Objects"></A>
<HR SIZE="6">
<A NAME="SEC55"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC54"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC56"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC50"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC51"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_8.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 7.2.3.4 Using Stella Objects </H4>
<!--docid::SEC55::-->
<P>

Stella objects can also be used directly.  The most common ones used by
PowerLoom users are <CODE>Module</CODE> and <CODE>LogicObject</CODE>.  Other
potentially useful Stella objects are <CODE>Cons</CODE>, <CODE>Symbol</CODE>,
<CODE>Keyword</CODE> and <CODE>List</CODE>.  Except for <CODE>LogicObject</CODE>, these are in
the <CODE>edu.isi.stella</CODE> package.  <CODE>LogicObject</CODE> is in the
<CODE>edu.isi.powerloom.logic</CODE> package.
</P><P>

If one wishes to construct <CODE>Cons</CODE> objects (for example to create
objects to pass to interface functions, one would begin by building
items up using <CODE>Stella_Object.cons</CODE> static method, which takes a
stella object and a cons.  The empty cons is kept in the
<CODE>edu.isi.stella.Stella.NIL</CODE> static variable.  Another way to create
stella objects is to use <CODE>edu.isi.stella.Stella.unstringify</CODE> static
method.  This method takes a string representation of a stella object
and returns the object.  If passed a list, an object of type <CODE>Cons</CODE>
will be returned.
</P><P>

As an alternative, one can also convert one and two dimensional arrays
of <CODE>Stella_Object</CODE> into <CODE>Cons</CODE> objects using the overloaded
function <CODE>edu.isi.stella.javalib.arrayToCons</CODE>.  These functions
will return <CODE>Cons</CODE> objects constructed from the input arrays.
</P><P>

Keywords and symbols are objects that are stored in global static
variables.  The variable names are all in upper case and are constructed
by concatenating the tag SYM with the module name and the name of the
symbol or concatenating the tag KWD with the name of the keyword.  For
example, the symbol BACKWARD in the logic module would be stored in
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>        edu.isi.powerloom.logic.Logic.SYM_LOGIC_BACKWARD
</pre></td></tr></table></P><P>

whereas the keyword :ERROR in the stella module would be in
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>        edu.isi.stella.Stella.KWD_ERROR
</pre></td></tr></table></P><P>

<A NAME="PowerLoom and Threads"></A>
<HR SIZE="6">
<A NAME="SEC56"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC55"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC57"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC50"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC51"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_8.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 7.2.3.5 PowerLoom and Threads </H4>
<!--docid::SEC56::-->
<P>

The most important consideration when using PowerLoom in a threaded
environment is that the core of PowerLoom must not execute in
concurrently running threads.  The PLI class takes care of this for
interface functions that run through that class.  Other PowerLoom
functions that are called need to synchronize on a lock object
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>        edu.isi.powerloom.logic.Logic.$POWERLOOM_LOCK$
</pre></td></tr></table></P><P>

for proper operation.  This is not needed for setting Special Variables,
since they are implemented on a per-thread basis.  The most important
special variable is the reasoning context.  See section <A HREF="manual_7.html#SEC57">7.2.3.6 Setting and Restoring Global Variable Values</A>.
</P><P>

<A NAME="Setting and Restoring Global Variable Values"></A>
<HR SIZE="6">
<A NAME="SEC57"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC56"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC58"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC50"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC51"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_8.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 7.2.3.6 Setting and Restoring Global Variable Values </H4>
<!--docid::SEC57::-->
<P>

As noted above, special variables in Stella are implemented as static
fields in a catchall class named the same as the Stella module.  It will
be in the java package corresponding to that Stella module.  The values
of Special variables are stored in Java objects of the type
<CODE>StellaSpecialVariable</CODE>, a subclass of Java's <CODE>InheritableThreadLocal</CODE>.  Any
changes made to the values will not affect any other running threads.
This means that the changes don't need to be synchronized.  Note that
global (as opposed to special) variables don't use these objects.
</P><P>

Numbers and boolean values are stored in special variables using the
corresponding Java classes <CODE>Integer</CODE>, <CODE>Double</CODE>,
<CODE>Boolean</CODE>, etc.  The naming convention is to have all upper case
letters with a dollar sign ($) at the beginning and end of the name.
</P><P>

To temporarily change the value of one of these variables, users will
need to be responsible for saving and restoring the old values.  Use of
the "<CODE>try ... finally ...</CODE>" construct is very useful for this, since it
guarantees that the restore of values will be done.  An example follows
of how to safely change modules.  Contexts should be changed using the
functions, although other global variables can be changed by using the
set method.  Note that we use variables of type Object to hold the
values, since that avoids the need to cast when extracting the current
value, since the only operation we do with the current value is save it
to restore it later.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>   import edu.isi.stella.*;

   // CONTEXT CHANGE.
   Object savedModule = Stella.$MODULE$.get();
   Module newModule
      = Stella.getStellaModule(contextName, true);
   if (newModule == null) { // Handle missing module
   }
   try {
     Module.changeCurrentModule(newModule)
     // Code that uses the newModule

   } finally {
     Module.changeCurrentModule(savedModule);
   }


   // INTEGER VALUE CHANGE:
   Object savedValue = Stella.$SAFETY$.get();
   try {
     Stella.$SAFETY$.set(new Integer(3));
     // Code that uses the newModule

   } finally {
     Stella.$SAFETY$.set(savedValue);
   }


   // BOOLEAN VALUE CHANGE:
   Object savedValue = Stella.$PRINTREADABLY$.get();
   try {
     Stella.$PRINTREADABLY$.set(Boolean.TRUE);
     // Code that uses the newModule

   } finally {
     Stella.$PRINTREADABLY$.set(savedValue);
   }
</pre></td></tr></table></P><P>

The need to change the module using this type of code can be largely
avoided by using the functions in the PLI interface package.  They take
a module argument and can handle the binding and restoration of the
module value themselves.
</P><P>

<A NAME="Java Character Mapping"></A>
<HR SIZE="6">
<A NAME="SEC58"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC57"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC59"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC50"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC51"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_8.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 7.2.3.7 Java Character Mapping </H4>
<!--docid::SEC58::-->
<P>

The full Stella to Java character mapping is the following. The
character mappings use uppercase characters if the basic identifier uses
mixed or lower case.  The mappings use lowercase characters if the basic
identifier uses upper case.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>   Stella  Java     Mnemonic
   ======  ====     ========
     !   =&#62;  X      (eXclamation)
     "   =&#62;  _
     #   =&#62;  H      (Hash)
     $   =&#62;  B      (Buck)
     %   =&#62;  R      (peRcent)
     &#38;   =&#62;  A      (Ampersand)
     '   =&#62;  Q      (Quote)
     (   =&#62;  _
     )   =&#62;  _
     *   =&#62;  $
     +   =&#62;  I      (Increase)
     ,   =&#62;  _
     -   =&#62;  _
     .   =&#62;  D      (Dot)
     /   =&#62;  S      (Slash)
     :   =&#62;  C      (Colon)
     ;   =&#62;  _
     &#60;   =&#62;  L      (Less than)
     =   =&#62;  E      (Equal)
     &#62;   =&#62;  G      (Greater than)
     ?   =&#62;  P      (Predicate)
     @   =&#62;  M      (Monkey tail)
     [   =&#62;  J      (Arbitrary (array index?))
     \   =&#62;  _
     ]   =&#62;  K      (Arbitrary (array index?)
     ^   =&#62;  U      (Up arrow)
     `   =&#62;  _
     {   =&#62;  Y      (Arbitrary (adjacent free letter))
     |   =&#62;  V      (Vertical bar)
     }   =&#62;  Z      (Arbitrary (adjacent free letter))
     ~   =&#62;  T      (Tilde)
&#60;space&#62;  =&#62; _
</pre></td></tr></table></P><P>

<A NAME="Stella Exceptions in Java"></A>
<HR SIZE="6">
<A NAME="SEC59"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC58"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC60"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC50"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC51"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_8.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 7.2.3.8 Stella Exceptions in Java </H4>
<!--docid::SEC59::-->
<P>

Stella exceptions are implemented as a subtype of <CODE>java.lang.Exception</CODE>
(actually <CODE>RunTimeException</CODE>) and may be caught normally.  All Stella
Exceptions belong to the <CODE>edu.isi.stella.StellaException</CODE> class or one of
its subclasses.  The more specfic PowerLoom exceptions belong to the
<CODE>edu.isi.powerloom.logic.LogicException</CODE> class or one of its subclasses.
</P><P>

Exceptions thrown during I/O operations will not use the standard Java
exceptions.  Instead, they will descend from
<CODE>edu.isi.stella.InputOutputException</CODE>.  The most useful
descendents are <CODE>edu.isi.stella.NoSuchFileException</CODE> and
<CODE>edu.isi.stella.EndOfFileException</CODE>.
</P><P>

<A NAME="Iteration in Java"></A>
<HR SIZE="6">
<A NAME="SEC60"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC59"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC61"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC50"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC51"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_8.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 7.2.3.9 Iteration in Java </H4>
<!--docid::SEC60::-->
<P>

Iteration in Stella (and by extension) PowerLoom is organized a little
bit differently than in Java.  You can either use the Stella iterators
directly, or else use one of the wrapper classes described in the
section <A HREF="manual_7.html#SEC61">7.2.3.10 Utility Classes for Java</A>.  It will present a more
familiar Java interface.  Since the iteration models are a bit
different, it would be unwise to mix accesses between the iteration
models.
</P><P>

Stella iterators do not compute any values until the next? method (in
Java: <CODE>nextP</CODE>) is called.  This method will try to compute the next
value of the iterator and it will return a boolean value which is true
if more values are present.  Each time it is called, the iteration
advances.  Values can be read out of the value field of the iterator,
which will have type <CODE>Stella_Object</CODE>.  Some iterators will also
have a key field which can be read.
</P><P>

The way one would normally use a Stella iterator is as follows, with
possible casting of the value field:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    Stella.Iterator iter = ...;

    while (iter.nextP()) {
        processValue(iter.value);
    }
</pre></td></tr></table></P><P>

The PLI class also contains a number of functions for simplifying the
interaction with <CODE>PlIterator</CODE> objects that are returned by various
API functions.  These are the <CODE>getNth...</CODE> functions.  They work
on sequences and sequence-like objects such as <CODE>Proposition</CODE> and
and the value slot of <CODE>PlIterator</CODE> objects.  Note that they do
not return sequential elements of the iterator, but rather elements
of the implicit sequence that is the value of iterators that have
more than one return variable.  For convenience, they also work (with
index = 0) on the value of <CODE>PlIterator</CODE> objects that have only a
single return variable.  For example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    // Get values of (object name age) in the iterator and then
    // print out a message with the name and age (position 1 &#38; 2).
    // This skips the PowerLoom object bound to ?X in position 0.
    PlIterator iter = 
        PLI.sRetrieve("all (and (name ?x ?name) (age ?x ?age))",
                      null,
                      null);

    while (iter.nextP()) {
        System.out.println(PLI.getNthString(iter, 1, null, null) + " is " +
                           PLI.getNthInteger(iter, 2, null, null ) + " years old.");
    }
</pre></td></tr></table></P><P>

<A NAME="Utility Classes for Java"></A>
<HR SIZE="6">
<A NAME="SEC61"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC60"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_8.html#SEC62"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC50"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC51"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_8.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 7.2.3.10 Utility Classes for Java </H4>
<!--docid::SEC61::-->
<P>

To make interoperation of Stella and Java easier, there are several
convenience classes for wrapping Stella iterators and having them behave
like Java enumerations or iterators.  These convenience classes are in the
<CODE>edu.isi.stella.javalib</CODE> package:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  ConsEnumeration.java      Enumeration class for Cons objects
  ConsIterator.java         Iterator class for Cons objects
  StellaEnumeration.java    Enumeration interface to Stella's Iterator
  StellaIterator.java       Iterator interface to Stella's Iterator
</pre></td></tr></table></P><P>

All of the iterators and enumerators return objects that are actually of
type <CODE>Stella_Object</CODE>, but the signature specifies
<CODE>java.lang.Object</CODE> as required for compatibility with the standard
Java signature.  The <CODE>Cons...</CODE> classes take a <CODE>Cons</CODE> in their
constructor.  The <CODE>Stella...</CODE> classes take a
<CODE>edu.isi.stella.Iterator</CODE> object in their constructor.
</P><P>

 
<A NAME="Built-In Relations"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC50"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_8.html#SEC62"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Hans Chalupsky</I> on <I>May, 25  2006</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>
</FONT>

</BODY>
</HTML>
