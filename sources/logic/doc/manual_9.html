<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on September, 30  2003 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>PowerLoom Manual: PowerLoom API</TITLE>

<META NAME="description" CONTENT="PowerLoom Manual: PowerLoom API">
<META NAME="keywords" CONTENT="PowerLoom Manual: PowerLoom API">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC43"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_8.html#SEC42"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC44"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_8.html#SEC42"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_10.html#SEC65"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC75">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 9. PowerLoom API </H1>
<!--docid::SEC43::-->
<P>

This chapter lists functions that collectively define the PowerLoom
API.  The first section describes the API functions themselves.  The
signature is the basic Stella signature.  Information on how to
translate the names of the functions and their arguments into the
programming languages Common Lisp, C++ or Java is given in the Language
Specific Interface section.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_9.html#SEC44">9.1 API Functions</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_9.html#SEC45">9.2 Language Specific Interface</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="API Functions"></A>
<HR SIZE="6">
<A NAME="SEC44"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC43"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC45"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC43"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC43"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_10.html#SEC65"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC75">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 9.1 API Functions </H2>
<!--docid::SEC44::-->
<P>

Many of the functions take a `module' argument that causes the function to be
evaluated in the context of that module. Passing in a NULL value for the module
argument means that evaluation takes place in the current module. The module
argument is frequently followed by an `environment' argument that specifies
which inference environment should be assumed during evaluation. Values for
`environment' are `ASSERTION-ENV', `TAXONOMIC-ENV', and `INFERENCE-ENV'.
`ASSERTION-ENV' specifies that a knowledge base query or lookup should take
into account only explicitly asserted propositions. `TAXONOMIC-ENV' 
specifies that a knowledge base query should take into account
explicitly-asserted propositions plus any rules that specify subsumption
relationships.   `INFERENCE-ENV' specifies that a knowledge base query
should take all relevant propositions into account, including those
generated during forward inferencing.  A NULL value for the the `environment'
argument defaults to `TAXONOMIC-ENV'.
</P><P>

Many of the functions that take PowerLoom or Stella objects as inputs
also have an analog version whose name starts with the prefix "s-" that
take strings as inputs.  This is provided as a convenience so that
programmers will not necessarily need to manipulate PowerLoom objects
directly.
</P><P>

<A NAME="IDX50"></A>
<DL>
<DT><U>Function:</U> <B>ask</B> <I>((query CONS) (module MODULE) (environment OBJECT)) : TRUTH-VALUE</I>
<DD>Returns a truth value for the <VAR>query</VAR> in <VAR>module</VAR> and <VAR>environment</VAR>.
The truth value represents the degree of belief in the answer.  See also the
helping functions <CODE>is-true</CODE>, <CODE>is-false</CODE> , <CODE>is-unknown</CODE>.
</DL>
</P><P>

<A NAME="IDX51"></A>
<DL>
<DT><U>Function:</U> <B>assert-binary-proposition</B> <I>((relation LOGIC-OBJECT) (arg OBJECT) (value OBJECT) (module MODULE) (environment OBJECT)) : PROPOSITION</I>
<DD>Assert that the proposition (<VAR>relation</VAR> <VAR>arg</VAR> <VAR>value</VAR>) is TRUE
in <VAR>module</VAR>.  Return the asserted proposition.
</DL>
</P><P>

<A NAME="IDX52"></A>
<DL>
<DT><U>Function:</U> <B>assert-nary-proposition</B> <I>((relation-and-arguments OBJECT) (module MODULE) (environment OBJECT)) : PROPOSITION</I>
<DD>Assert that the proposition represented by the list <CODE>arguments</CODE> satisfies
the relation <CODE>relation</CODE>.
</DL>
</P><P>

<A NAME="IDX53"></A>
<DL>
<DT><U>Function:</U> <B>assert-proposition</B> <I>((proposition PROPOSITION) (module MODULE) (environment OBJECT)) : PROPOSITION</I>
<DD>Assert that the proposition <VAR>proposition</VAR> is true in <VAR>module</VAR>.
Return the asserted proposition.
</DL>
</P><P>

<A NAME="IDX54"></A>
<DL>
<DT><U>Function:</U> <B>assert-unary-proposition</B> <I>((relation LOGIC-OBJECT) (arg OBJECT) (module MODULE) (environment OBJECT)) : PROPOSITION</I>
<DD>Assert that the proposition (<VAR>relation</VAR> <VAR>arg</VAR>) is TRUE in <VAR>module</VAR>.  Return the asserted proposition.
</DL>
</P><P>

<A NAME="IDX55"></A>
<DL>
<DT><U>Function:</U> <B>change-module</B> <I>((module MODULE)) : OBJECT</I>
<DD>Set the current module to <VAR>module</VAR>.  The return value
is <VAR>module</VAR> unless the context switch cannot be performed, in which case
the current module is returned.
</DL>
</P><P>

<A NAME="IDX56"></A>
<DL>
<DT><U>Function:</U> <B>clear-module</B> <I>((module MODULE)) : MODULE</I>
<DD>Destroy the contents of the module <VAR>module</VAR> as well as
the contents of all of its children, recursively.
</DL>
</P><P>

<A NAME="IDX57"></A>
<DL>
<DT><U>Function:</U> <B>conceive</B> <I>((sentence OBJECT) (module MODULE) (environment OBJECT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Create one or more proposition objects from the sentence <VAR>sentence</VAR>
in the  module <VAR>module</VAR>.  Return an iterator of the propositions.
If any of the new propositions has the same structure as an already existing
proposition, an automatic check for duplicates will return the pre-existing
proposition.  Multiple propositions may be returned for a single sentence
because of normalization of equivalences, conjunctions, etc.
</P><P>

Signals a <CODE>Proposition-Error</CODE> if PowerLoom could not conceive <VAR>sentence</VAR>.
</DL>
</P><P>

<A NAME="IDX58"></A>
<DL>
<DT><U>Function:</U> <B>cons-to-pl-iterator</B> <I>((self CONS)) : PL-ITERATOR</I>
<DD>Convert a Stella cons list into an API iterator.
</DL>
</P><P>

<A NAME="IDX59"></A>
<DL>
<DT><U>Function:</U> <B>create-concept</B> <I>((name STRING) (parent LOGIC-OBJECT) (module MODULE) (environment OBJECT)) : LOGIC-OBJECT</I>
<DD>Create a concept named <VAR>name</VAR> in the designated <VAR>module</VAR>, with the
designated <VAR>parent</VAR> superconcept (which can be left undefined).  Additional
superconcepts can be added via assertions of the <CODE>subset-of</CODE> relation.  Note
that a specified <VAR>parent</VAR> concept needs to be created separately.
</DL>
</P><P>

<A NAME="IDX60"></A>
<DL>
<DT><U>Function:</U> <B>create-enumerated-list</B> <I>((members CONS)) : LOGIC-OBJECT</I>
<DD>Create a logical term that denotes a list containing <VAR>members</VAR>.
Useful for passing lists as arguments to parameterized queries.
</DL>
</P><P>

<A NAME="IDX61"></A>
<DL>
<DT><U>Function:</U> <B>create-enumerated-set</B> <I>((members CONS)) : LOGIC-OBJECT</I>
<DD>Create a logical term that denotes the enumerated set containing <VAR>members</VAR>.
</DL>
</P><P>

<A NAME="IDX62"></A>
<DL>
<DT><U>Function:</U> <B>create-function</B> <I>((name STRING) (arity INTEGER) (module MODULE) (environment OBJECT)) : LOGIC-OBJECT</I>
<DD>Create a function named <VAR>name</VAR> with arity <VAR>arity</VAR>  in the designated 
<VAR>module</VAR>.  Domain and range information can be added via assertions of
<CODE>nth-domain</CODE> (or <CODE>domain</CODE> and <CODE>range</CODE>) relations.
</DL>
</P><P>

<A NAME="IDX63"></A>
<DL>
<DT><U>Function:</U> <B>create-object</B> <I>((name STRING) (concept LOGIC-OBJECT) (module MODULE) (environment OBJECT)) : LOGIC-OBJECT</I>
<DD>Create an object named <VAR>name</VAR> of type <VAR>concept</VAR> in the designated
module.  Both <VAR>name</VAR> and <VAR>concept</VAR> can be <CODE>null</CODE>.  If <VAR>name</VAR> is <CODE>null</CODE> then an object
will be created with a new, non-conflicting name based on the name of <VAR>concept</VAR>, or
system-generated if no concept is specified.  If <VAR>concept</VAR> is <CODE>null</CODE>, then the object
will be of type THING.
</P><P>

Return the object.
</DL>
</P><P>

<A NAME="IDX64"></A>
<DL>
<DT><U>Function:</U> <B>create-relation</B> <I>((name STRING) (arity INTEGER) (module MODULE) (environment OBJECT)) : LOGIC-OBJECT</I>
<DD>Create a relation named <VAR>name</VAR> with arity <VAR>arity</VAR> in the
designated module.  Domain and range information can be added via assertions
of <CODE>nth-domain</CODE> (or <CODE>domain</CODE> and <CODE>range</CODE>) relations.
</DL>
</P><P>

<A NAME="IDX65"></A>
<DL>
<DT><U>Function:</U> <B>destroy-object</B> <I>((object LOGIC-OBJECT)) :</I>
<DD>Delete the object <VAR>object</VAR>, retracting all facts attached to it.
</DL>
</P><P>

<A NAME="IDX66"></A>
<DL>
<DT><U>Method:</U> <B>empty?</B> <I>((self PL-ITERATOR)) : BOOLEAN</I>
<DD>Return TRUE if the iterator <VAR>self</VAR> has no more elements.
</DL>
</P><P>

<A NAME="IDX67"></A>
<DL>
<DT><U>Function:</U> <B>evaluate</B> <I>((command OBJECT) (module MODULE) (environment OBJECT)) : OBJECT</I>
<DD>Evaluate the command <VAR>command</VAR> within <VAR>module</VAR> and return
the result. Currently, only the evaluation of (possibly nested) commands and
global variables is supported.  Commands are simple to program in Common Lisp,
since they are built into the language, and relatively awkward in Java and C++.
Users of either of those languages are more likely to want to call <CODE>s-evaluate</CODE>.
</DL>
</P><P>

<A NAME="IDX68"></A>
<DL>
<DT><U>Function:</U> <B>generate-unique-name</B> <I>((prefix STRING) (module MODULE) (environment OBJECT)) : STRING</I>
<DD>Generates a name based on <VAR>prefix</VAR> with a number appended that
is not currently in use in the knowledge base.
</DL>
</P><P>

<A NAME="IDX69"></A>
<DL>
<DT><U>Function:</U> <B>get-arity</B> <I>((relation LOGIC-OBJECT)) : INTEGER</I>
<DD>Return the arity of the relation <VAR>relation</VAR>.
</DL>
</P><P>

<A NAME="IDX70"></A>
<DL>
<DT><U>Function:</U> <B>get-binary-proposition</B> <I>((relation LOGIC-OBJECT) (arg1 OBJECT) (arg2 OBJECT) (module MODULE) (environment OBJECT)) : PROPOSITION</I>
<DD>Return a proposition such that (<VAR>relation</VAR> <VAR>arg1</VAR> <VAR>arg2</VAR>)
is true.  The <VAR>relation</VAR> argument must be bound to a relation.  One or both
of the <VAR>arg1</VAR> and <VAR>arg2</VAR> arguments may be set to NULL, which is interpreted
as a wildcard. If more than one proposition matches the input criteria,
the selection is arbitrary.  This procedure is normally applied to single-valued
relations or functions.
</DL>
</P><P>

<A NAME="IDX71"></A>
<DL>
<DT><U>Function:</U> <B>get-binary-propositions</B> <I>((relation LOGIC-OBJECT) (arg1 OBJECT) (arg2 OBJECT) (module MODULE) (environment OBJECT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Return propositions such that (<VAR>relation</VAR> <VAR>arg1</VAR> <VAR>arg2</VAR>)
is true.  The <VAR>relation</VAR> argument
must be bound to a relation.  One or both of the <VAR>arg1</VAR> and <VAR>arg2</VAR> arguments
may be set to NULL, which is interpreted as a wildcard.
</DL>
</P><P>

<A NAME="IDX72"></A>
<DL>
<DT><U>Function:</U> <B>get-child-modules</B> <I>((module MODULE)) : (PL-ITERATOR OF MODULE)</I>
<DD>Return the modules that are immediate children of <VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX73"></A>
<DL>
<DT><U>Function:</U> <B>get-column-count</B> <I>((obj OBJECT)) : INTEGER</I>
<DD>Return the number of columns in <VAR>obj</VAR>, which must
be of type proposition, cons, vector or PL-iterator.  For a proposition,
the number includes both the predidate and arguments. For the PL-iterator
case,the number of columns is for the current value of the iterator.
</DL>
</P><P>

<A NAME="IDX74"></A>
<DL>
<DT><U>Function:</U> <B>get-concept</B> <I>((name STRING) (module MODULE) (environment OBJECT)) : LOGIC-OBJECT</I>
<DD>Return a class/concept named <VAR>name</VAR> that is local to
or visible from the module <VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX75"></A>
<DL>
<DT><U>Function:</U> <B>get-concept-instance-matching-value</B> <I>((concept LOGIC-OBJECT) (relation LOGIC-OBJECT) (value OBJECT) (module MODULE) (environment OBJECT)) : OBJECT</I>
<DD>Return a member of concept <VAR>concept</VAR> that
has an attribute matching <VAR>value</VAR> for the binary relation <VAR>relation</VAR>, i.e.,
<CODE>(relation &#60;result&#62; value)</CODE> holds.
</DL>
</P><P>

<A NAME="IDX76"></A>
<DL>
<DT><U>Function:</U> <B>get-concept-instances</B> <I>((concept LOGIC-OBJECT) (module MODULE) (environment OBJECT)) : PL-ITERATOR</I>
<DD>Return instances of the concept <VAR>concept</VAR>.
Include instances of subconcepts of <VAR>concept</VAR>.  Depending on <VAR>concept</VAR>,
the return values could be (wrapped) literals.
</DL>
</P><P>

<A NAME="IDX77"></A>
<DL>
<DT><U>Function:</U> <B>get-concept-instances-matching-value</B> <I>((concept LOGIC-OBJECT) (relation LOGIC-OBJECT) (value OBJECT) (module MODULE) (environment OBJECT)) : PL-ITERATOR</I>
<DD>Return members of concept <VAR>concept</VAR> that
have an attribute matching <VAR>value</VAR> for the binary relation <VAR>relation</VAR>, i.e.,
<CODE>(relation &#60;result&#62; value)</CODE> holds.
</DL>
</P><P>

<A NAME="IDX78"></A>
<DL>
<DT><U>Function:</U> <B>get-direct-concept-instances</B> <I>((concept LOGIC-OBJECT) (module MODULE) (environment OBJECT)) : PL-ITERATOR</I>
<DD>Return instances of concept <VAR>concept</VAR>.
Exclude instances of subconcepts of <VAR>concept</VAR>.  Depending on <VAR>concept</VAR>,
the return values could be (wrapped) literals.
</DL>
</P><P>

<A NAME="IDX79"></A>
<DL>
<DT><U>Function:</U> <B>get-direct-subrelations</B> <I>((relation LOGIC-OBJECT) (module MODULE) (environment OBJECT)) : (PL-ITERATOR OF LOGIC-OBJECT)</I>
<DD>Return relations that directly specialize <VAR>relation</VAR>.
Non-reflexive.
</DL>
</P><P>

<A NAME="IDX80"></A>
<DL>
<DT><U>Function:</U> <B>get-direct-superrelations</B> <I>((relation LOGIC-OBJECT) (module MODULE) (environment OBJECT)) : (PL-ITERATOR OF LOGIC-OBJECT)</I>
<DD>Return relations that directly generalize <VAR>relation</VAR>.
Non-reflexive.
</DL>
</P><P>

<A NAME="IDX81"></A>
<DL>
<DT><U>Function:</U> <B>get-direct-types</B> <I>((object LOGIC-OBJECT) (module MODULE) (environment OBJECT)) : (PL-ITERATOR OF LOGIC-OBJECT)</I>
<DD>Return most specific concepts that <VAR>object</VAR> belongs to.
</DL>
</P><P>

<A NAME="IDX82"></A>
<DL>
<DT><U>Function:</U> <B>get-domain</B> <I>((relation LOGIC-OBJECT)) : LOGIC-OBJECT</I>
<DD>Return the type (a concept) for the first argument to the binary
relation <VAR>relation</VAR>.
</DL>
</P><P>

<A NAME="IDX83"></A>
<DL>
<DT><U>Function:</U> <B>get-enumerated-collection-members</B> <I>((collection OBJECT)) : CONS</I>
<DD>Returns the members of an enumerated collection.  This works on all types
of collection, i.e., sets and lists
</DL>
</P><P>

<A NAME="IDX84"></A>
<DL>
<DT><U>Function:</U> <B>get-home-module</B> <I>((object LOGIC-OBJECT)) : MODULE</I>
<DD>Return the module in which <VAR>object</VAR> was created.
</DL>
</P><P>

<A NAME="IDX85"></A>
<DL>
<DT><U>Function:</U> <B>get-inferred-binary-proposition-values</B> <I>((relation LOGIC-OBJECT) (arg OBJECT) (module MODULE) (environment OBJECT)) : PL-ITERATOR</I>
<DD>Return all values <CODE>v</CODE> such that (<VAR>relation</VAR> <VAR>arg</VAR> <CODE>v</CODE>)
has been asserted or can be inferred.
</DL>
</P><P>

<A NAME="IDX86"></A>
<DL>
<DT><U>Function:</U> <B>get-module</B> <I>((name STRING) (environment OBJECT)) : MODULE</I>
<DD>Return a module named <VAR>name</VAR>.
</DL>
</P><P>

<A NAME="IDX87"></A>
<DL>
<DT><U>Function:</U> <B>get-modules</B> <I>() : (PL-ITERATOR OF MODULE)</I>
<DD>Return all modules currently loaded into PowerLoom.
</DL>
</P><P>

<A NAME="IDX88"></A>
<DL>
<DT><U>Function:</U> <B>get-name</B> <I>((obj OBJECT)) : STRING</I>
<DD>Return the name of <VAR>obj</VAR>, if it has one.  Otherwise return <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX89"></A>
<DL>
<DT><U>Function:</U> <B>get-nth-domain</B> <I>((relation LOGIC-OBJECT) (n INTEGER)) : LOGIC-OBJECT</I>
<DD>Return the type (a concept) for the the nth argument of the
relation <VAR>relation</VAR>.  Counting starts at zero.
</DL>
</P><P>

<A NAME="IDX90"></A>
<DL>
<DT><U>Function:</U> <B>get-nth-float</B> <I>((sequence OBJECT) (n INTEGER)) : FLOAT</I>
<DD>Return the floating point value in the <CODE>nth</CODE> column of
<VAR>sequence</VAR>. Counting starts at zero.  <VAR>sequence</VAR> must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  If this is not
a floating point value, then NULL-FLOAT will be returned.
</DL>
</P><P>

<A NAME="IDX91"></A>
<DL>
<DT><U>Function:</U> <B>get-nth-integer</B> <I>((sequence OBJECT) (n INTEGER)) : INTEGER</I>
<DD>Return an integer representation of the value in the <CODE>nth</CODE> column of
<VAR>sequence</VAR>. Counting starts at zero.  <VAR>sequence</VAR> must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  If this is not
an integer value, then NULL-INTEGER will be returned.
</DL>
</P><P>

<A NAME="IDX92"></A>
<DL>
<DT><U>Function:</U> <B>get-nth-logic-object</B> <I>((sequence OBJECT) (n INTEGER)) : LOGIC-OBJECT</I>
<DD>Return a logic object representation of the value in the <CODE>nth</CODE> column
of <VAR>sequence</VAR>.  Counting starts at zero.  <VAR>sequence</VAR> must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  A zero column number
returns the proposition's relational predicate.
</DL>
</P><P>

<A NAME="IDX93"></A>
<DL>
<DT><U>Function:</U> <B>get-nth-string</B> <I>((sequence OBJECT) (n INTEGER)) : STRING</I>
<DD>Return a string representation of the value in the <CODE>nth</CODE> column of
<VAR>sequence</VAR>. Counting starts at zero.  <VAR>sequence</VAR> must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  This will always
succeed, even if the <CODE>nth</CODE> value is not a string object.  In that case, a
string reprensentation will be returned.
</DL>
</P><P>

<A NAME="IDX94"></A>
<DL>
<DT><U>Function:</U> <B>get-nth-value</B> <I>((sequence OBJECT) (n INTEGER)) : OBJECT</I>
<DD>Return the value in the <CODE>nth</CODE> column of <VAR>sequence</VAR>.
Counting starts at zero.  <VAR>sequence</VAR> must be of type proposition, cons,
vector or PL-iterator.  A zero column number returns a proposition's 
relational predicate.  For the PL-iterator case, the number of columns
is for the current value of the iterator.
</DL>
</P><P>

<A NAME="IDX95"></A>
<DL>
<DT><U>Function:</U> <B>get-object</B> <I>((name STRING) (module MODULE) (environment OBJECT)) : OBJECT</I>
<DD>Look for an object named <VAR>name</VAR> that is local to
or visible from the module <VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX96"></A>
<DL>
<DT><U>Function:</U> <B>get-parent-modules</B> <I>((module MODULE)) : (PL-ITERATOR OF MODULE)</I>
<DD>Return the modules that are immediate parents of <VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX97"></A>
<DL>
<DT><U>Function:</U> <B>get-predicate</B> <I>((prop PROPOSITION)) : LOGIC-OBJECT</I>
<DD>Return the concept or relation predicate for
the proposition <VAR>prop</VAR>.
</DL>
</P><P>

<A NAME="IDX98"></A>
<DL>
<DT><U>Function:</U> <B>get-proper-subrelations</B> <I>((relation LOGIC-OBJECT) (module MODULE) (environment OBJECT)) : (PL-ITERATOR OF LOGIC-OBJECT)</I>
<DD>Return relations that specialize <VAR>relation</VAR>.
Non-reflexive.
</DL>
</P><P>

<A NAME="IDX99"></A>
<DL>
<DT><U>Function:</U> <B>get-proper-superrelations</B> <I>((relation LOGIC-OBJECT) (module MODULE) (environment OBJECT)) : (PL-ITERATOR OF LOGIC-OBJECT)</I>
<DD>Return relations that generalize <VAR>relation</VAR>.
Non-reflexive.
</DL>
</P><P>

<A NAME="IDX100"></A>
<DL>
<DT><U>Function:</U> <B>get-proposition</B> <I>((relation-and-arguments OBJECT) (module MODULE) (environment OBJECT)) : PROPOSITION</I>
<DD>Return a proposition matching <VAR>relation-and-arguments</VAR> that
has been asserted (or inferred by forward chaining).  <VAR>relation-and-arguments</VAR>
is a sequence containing objects and nulls.  The first argument must be the
name of a relation.  A null value acts like a wild card.  If more than one 
proposition matches the input criteria, the selection among satisficing
propositions is arbitrary.  This procedure is normally applied to single-valued
relations or functions.
</DL>
</P><P>

<A NAME="IDX101"></A>
<DL>
<DT><U>Function:</U> <B>get-propositions</B> <I>((relation-and-arguments OBJECT) (module MODULE) (environment OBJECT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Return propositions matching <VAR>relation-and-arguments</VAR> that
have been asserted (or inferred by forward chaining).  <VAR>relation-and-arguments</VAR>
is a sequence containing objects and nulls.  The first argument must be the
name of a relation.  A null value acts like a wild card.
</DL>
</P><P>

<A NAME="IDX102"></A>
<DL>
<DT><U>Function:</U> <B>get-propositions-in-module</B> <I>((module MODULE) (environment OBJECT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Return propositions that have been conceived in
the module <VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX103"></A>
<DL>
<DT><U>Function:</U> <B>get-propositions-of</B> <I>((object LOGIC-OBJECT) (module MODULE) (environment OBJECT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Return all propositions that have <VAR>object</VAR> among their arguments,
and that are TRUE in the scope of the module <VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX104"></A>
<DL>
<DT><U>Function:</U> <B>get-range</B> <I>((relation LOGIC-OBJECT)) : LOGIC-OBJECT</I>
<DD>Return the type (a concept) for fillers of the binary relation
<VAR>relation</VAR>.
</DL>
</P><P>

<A NAME="IDX105"></A>
<DL>
<DT><U>Function:</U> <B>get-relation</B> <I>((name STRING) (module MODULE) (environment OBJECT)) : LOGIC-OBJECT</I>
<DD>Return a concept or relation named <VAR>name</VAR> that is local to
or visible from the module <VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX106"></A>
<DL>
<DT><U>Function:</U> <B>get-relation-extension</B> <I>((relation LOGIC-OBJECT) (module MODULE) (environment OBJECT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Return propositions that satisfy <VAR>relation</VAR>.
Include propositions that satisfy subrelations of <VAR>relation</VAR>.
</DL>
</P><P>

<A NAME="IDX107"></A>
<DL>
<DT><U>Function:</U> <B>get-rules</B> <I>((relation LOGIC-OBJECT) (module MODULE) (environment OBJECT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Return rules attached to the concept/relation <VAR>relation</VAR>
in either antecedent or consequent position.
</DL>
</P><P>

<A NAME="IDX108"></A>
<DL>
<DT><U>Function:</U> <B>get-types</B> <I>((object LOGIC-OBJECT) (module MODULE) (environment OBJECT)) : (PL-ITERATOR OF LOGIC-OBJECT)</I>
<DD>Return all named concepts that <VAR>object</VAR> belongs to.
</DL>
</P><P>

<A NAME="IDX109"></A>
<DL>
<DT><U>Function:</U> <B>initialize</B> <I>() :</I>
<DD>Initialize the PowerLoom logic system.  This needs to
be called by all applications before using PowerLoom.
</DL>
</P><P>

<A NAME="IDX110"></A>
<DL>
<DT><U>Function:</U> <B>is-a</B> <I>((object OBJECT) (concept LOGIC-OBJECT) (module MODULE) (environment OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>object</VAR> is a member of the concept <VAR>concept</VAR>.
</DL>
</P><P>

<A NAME="IDX111"></A>
<DL>
<DT><U>Function:</U> <B>is-default</B> <I>((tv TRUTH-VALUE)) : BOOLEAN</I>
<DD>Tests whether <VAR>tv</VAR> is a default truth value.
</DL>
</P><P>

<A NAME="IDX112"></A>
<DL>
<DT><U>Function:</U> <B>is-enumerated-collection</B> <I>((obj OBJECT)) : BOOLEAN</I>
<DD>Test whether <VAR>obj</VAR> is an enumerated collection.  This
subsumes both sets and lists.
</DL>
</P><P>

<A NAME="IDX113"></A>
<DL>
<DT><U>Function:</U> <B>is-enumerated-list</B> <I>((obj OBJECT)) : BOOLEAN</I>
<DD>Test whether <VAR>obj</VAR> is an enumerated list
</DL>
</P><P>

<A NAME="IDX114"></A>
<DL>
<DT><U>Function:</U> <B>is-enumerated-set</B> <I>((obj OBJECT)) : BOOLEAN</I>
<DD>Test whether <VAR>obj</VAR> is an enumerated set.
</DL>
</P><P>

<A NAME="IDX115"></A>
<DL>
<DT><U>Function:</U> <B>is-false</B> <I>((tv TRUTH-VALUE)) : BOOLEAN</I>
<DD>Tests whether <VAR>tv</VAR> is a false truth value.  It can be false
either absolutely or by default.
</DL>
</P><P>

<A NAME="IDX116"></A>
<DL>
<DT><U>Function:</U> <B>is-float</B> <I>((obj OBJECT)) : BOOLEAN</I>
<DD>Test whether <VAR>obj</VAR> is of type FLOAT (double)
</DL>
</P><P>

<A NAME="IDX117"></A>
<DL>
<DT><U>Function:</U> <B>is-integer</B> <I>((obj OBJECT)) : BOOLEAN</I>
<DD>Test whether <VAR>obj</VAR> is of type INTEGER
</DL>
</P><P>

<A NAME="IDX118"></A>
<DL>
<DT><U>Function:</U> <B>is-logic-object</B> <I>((obj OBJECT)) : BOOLEAN</I>
<DD>Test whether <VAR>obj</VAR> is of type LOGIC-OBJECT
</DL>
</P><P>

<A NAME="IDX119"></A>
<DL>
<DT><U>Function:</U> <B>is-number</B> <I>((obj OBJECT)) : BOOLEAN</I>
<DD>Test whether <VAR>obj</VAR> is of type NUMBER.  This can
be either an integer or a floating point number.  One key characteristic
is that <CODE>object-to-integer</CODE> and <CODE>object-to-float</CODE> will both work on it.
</DL>
</P><P>

<A NAME="IDX120"></A>
<DL>
<DT><U>Function:</U> <B>is-strict</B> <I>((tv TRUTH-VALUE)) : BOOLEAN</I>
<DD>Tests whether <VAR>tv</VAR> is a strict (non-default) truth value.
</DL>
</P><P>

<A NAME="IDX121"></A>
<DL>
<DT><U>Function:</U> <B>is-string</B> <I>((obj OBJECT)) : BOOLEAN</I>
<DD>Test whether <VAR>obj</VAR> is of type STRING
</DL>
</P><P>

<A NAME="IDX122"></A>
<DL>
<DT><U>Function:</U> <B>is-subrelation</B> <I>((sub LOGIC-OBJECT) (super LOGIC-OBJECT) (module MODULE) (environment OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>sub</VAR> is a subconcept/subrelation of <VAR>super</VAR>.
</DL>
</P><P>

<A NAME="IDX123"></A>
<DL>
<DT><U>Function:</U> <B>is-true</B> <I>((tv TRUTH-VALUE)) : BOOLEAN</I>
<DD>Tests whether <VAR>tv</VAR> is a true truth value.  It can be true
either absolutely or by default.
</DL>
</P><P>

<A NAME="IDX124"></A>
<DL>
<DT><U>Function:</U> <B>is-true-binary-proposition</B> <I>((relation LOGIC-OBJECT) (arg OBJECT) (value OBJECT) (module MODULE) (environment OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if the proposition (<VAR>relation</VAR> <VAR>arg</VAR> <VAR>value</VAR>) has
been asserted (or inferred by forward chaining).
</DL>
</P><P>

<A NAME="IDX125"></A>
<DL>
<DT><U>Function:</U> <B>is-true-proposition</B> <I>((proposition PROPOSITION) (module MODULE) (environment OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>proposition</VAR> is  TRUE in the module <VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX126"></A>
<DL>
<DT><U>Function:</U> <B>is-true-unary-proposition</B> <I>((relation LOGIC-OBJECT) (arg OBJECT) (module MODULE) (environment OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if the proposition (<VAR>relation</VAR> <VAR>arg</VAR>) has
been asserted (or inferred by forward chaining).
</DL>
</P><P>

<A NAME="IDX127"></A>
<DL>
<DT><U>Function:</U> <B>is-unknown</B> <I>((tv TRUTH-VALUE)) : BOOLEAN</I>
<DD>Tests whether <VAR>tv</VAR> is an unknown truth value.
</DL>
</P><P>

<A NAME="IDX128"></A>
<DL>
<DT><U>Function:</U> <B>iterator-to-pl-iterator</B> <I>((self ITERATOR)) : PL-ITERATOR</I>
<DD>Convert an arbitrary Stella iterator into an API iterator.
</DL>
</P><P>

<A NAME="IDX129"></A>
<DL>
<DT><U>Method:</U> <B>length</B> <I>((self PL-ITERATOR)) : INTEGER</I>
<DD>Number of items in <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX130"></A>
<DL>
<DT><U>Function:</U> <B>list-to-pl-iterator</B> <I>((self LIST)) : PL-ITERATOR</I>
<DD>Convert a Stella list into an API iterator.
</DL>
</P><P>

<A NAME="IDX131"></A>
<DL>
<DT><U>Function:</U> <B>load</B> <I>((filename STRING)) :</I>
<DD>Read logic commands from the file named <VAR>filename</VAR> and evaluate them.
The file should begin with an <CODE>in-module</CODE> declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
<CODE>evaluate</CODE> to each of them.
</DL>
</P><P>

<A NAME="IDX132"></A>
<DL>
<DT><U>Method:</U> <B>next?</B> <I>((self PL-ITERATOR)) : BOOLEAN</I>
<DD>Advance the PL-Iterator <VAR>self</VAR> and return <CODE>true</CODE> if more
elements are available, <CODE>false</CODE> otherwise.
</DL>
</P><P>

<A NAME="IDX133"></A>
<DL>
<DT><U>Function:</U> <B>object-to-float</B> <I>((self OBJECT)) : FLOAT</I>
<DD>Coerce <VAR>self</VAR> to a float, or throw a Stella Exception if the coersion is not feasible.
</DL>
</P><P>

<A NAME="IDX134"></A>
<DL>
<DT><U>Function:</U> <B>object-to-integer</B> <I>((self OBJECT)) : INTEGER</I>
<DD>Coerce <VAR>self</VAR> to an integer, or throw a Stella Exception if the coersion is not feasible.
</DL>
</P><P>

<A NAME="IDX135"></A>
<DL>
<DT><U>Function:</U> <B>object-to-parsable-string</B> <I>((self OBJECT)) : STRING</I>
<DD>Return a string representing a printed
representation of the object <VAR>self</VAR>.  Like <CODE>object-to-string</CODE>, but puts
escaped double quotes around strings.
</DL>
</P><P>

<A NAME="IDX136"></A>
<DL>
<DT><U>Function:</U> <B>object-to-string</B> <I>((self OBJECT)) : STRING</I>
<DD>Return a printed representation of the term <VAR>self</VAR> as a string.
</DL>
</P><P>

<A NAME="IDX137"></A>
<DL>
<DT><U>Command:</U> <B>print-rules</B> <I>((relation OBJECT)) :</I>
<DD>Print the list of rules associated with <VAR>relation</VAR>.
</DL>
</P><P>

<A NAME="IDX138"></A>
<DL>
<DT><U>Command:</U> <B>retract</B> <I>((proposition PARSE-TREE)) : OBJECT</I>
<DD>Retract the truth of <VAR>proposition</VAR>.  Return the retracted proposition
object.  KIF example:  "(retract (happy Fred))" retracts that Fred is
happy.  Note that for this assertion to succeed, the relation <CODE>happy</CODE> must already
be defined.  If the constant <CODE>Fred</CODE> has not yet been created, it is
automatically created as a side-effect of calling <CODE>retract</CODE>.
</DL>
</P><P>

<A NAME="IDX139"></A>
<DL>
<DT><U>Function:</U> <B>retract-binary-proposition</B> <I>((relation LOGIC-OBJECT) (arg OBJECT) (value OBJECT) (module MODULE) (environment OBJECT)) : PROPOSITION</I>
<DD>Retract that the proposition (<VAR>relation</VAR> <VAR>arg</VAR> <VAR>value</VAR>) is TRUE
in <VAR>module</VAR>.  Return the asserted proposition.
</DL>
</P><P>

<A NAME="IDX140"></A>
<DL>
<DT><U>Function:</U> <B>retract-nary-proposition</B> <I>((relation-and-arguments OBJECT) (module MODULE) (environment OBJECT)) : PROPOSITION</I>
<DD>Retract the proposition that <CODE>arguments</CODE> satisfies
the relation <CODE>relation</CODE>.
</DL>
</P><P>

<A NAME="IDX141"></A>
<DL>
<DT><U>Function:</U> <B>retract-proposition</B> <I>((proposition PROPOSITION) (module MODULE) (environment OBJECT)) : PROPOSITION</I>
<DD>Retract the truth of the proposition <VAR>proposition</VAR> in <VAR>module</VAR>.
Return the retracted proposition.
</DL>
</P><P>

<A NAME="IDX142"></A>
<DL>
<DT><U>Function:</U> <B>retract-unary-proposition</B> <I>((relation LOGIC-OBJECT) (arg OBJECT) (module MODULE) (environment OBJECT)) : PROPOSITION</I>
<DD>Retract that the proposition (<VAR>relation</VAR> <VAR>arg</VAR>) is TRUE in <VAR>module</VAR>.  Return the asserted proposition.
</DL>
</P><P>

<A NAME="IDX143"></A>
<DL>
<DT><U>Function:</U> <B>retrieve</B> <I>((query CONS) (module MODULE) (environment OBJECT)) : PL-ITERATOR</I>
<DD>Returns an iterator for variables that satisfy <VAR>query</VAR> in <CODE>module-name</CODE>
and <VAR>environment</VAR>.  This uses the normal PowerLoom query syntax:
</P><P>

   <CODE>[n-values] output-variables query-form [options]</CODE>
</P><P>

The <CODE>output-variables</CODE> should either be a single variable name
-- preceded by the <CODE>?</CODE> character -- or a list of one or more such names.
If a single variable name is provided, then each element in the returned
iterator will be a value binding.  If a list (even of one variable name)
is provided, then each element in the returned iterator can be accessed
using the <CODE>get-nth-</CODE>... functions.
</DL>
</P><P>

<A NAME="IDX144"></A>
<DL>
<DT><U>Function:</U> <B>run-forward-rules</B> <I>((module OBJECT) (force? BOOLEAN)) :</I>
<DD>Run forward inference rules in module <VAR>module</VAR>.
If <VAR>module</VAR> is NULL, the
current module will be used.  If forward inferencing is already up-to-date
in the designated module, no additional inferencing will occur, unless <CODE>force</CODE>
is set to TRUE, in which case all forward rules are run or rerun.
</P><P>

Calling <CODE>run-forward-rules</CODE> temporarily puts the module into a mode where
future assertional (monotonic) updates will trigger additional forward
inference.  Once a non-monotonic update is performed, i.e., a retraction
or clipping of relation value, all cached forward inferences will be discarded
and forward inferencing will be disabled until this function is
called again.
</DL>
</P><P>

<A NAME="IDX145"></A>
<DL>
<DT><U>Function:</U> <B>s-ask</B> <I>((query STRING) (module-name STRING) (environment OBJECT)) : TRUTH-VALUE</I>
<DD>Returns a truth value for the <VAR>query</VAR> in <VAR>module-name</VAR> and <VAR>environment</VAR>.
The truth value represents the degree of belief in the answer.  See also the
helping functions <CODE>is-true</CODE>, <CODE>is-false</CODE> , <CODE>is-unknown</CODE>.
</DL>
</P><P>

<A NAME="IDX146"></A>
<DL>
<DT><U>Function:</U> <B>s-assert-proposition</B> <I>((sentence STRING) (module-name STRING) (environment OBJECT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Assert that the logical sentence <VAR>sentence</VAR> is true in the module
named <VAR>module-name</VAR>. Return an iterator of the propositions resulting
from sentence.
</DL>
</P><P>

<A NAME="IDX147"></A>
<DL>
<DT><U>Function:</U> <B>s-change-module</B> <I>((name STRING) (environment OBJECT)) : OBJECT</I>
<DD>Set the current module to the module named <VAR>name</VAR>.  
The return value is the module named <VAR>name</VAR> unless the context switch
cannot be performed, in which case the current module is returned.
</DL>
</P><P>

<A NAME="IDX148"></A>
<DL>
<DT><U>Function:</U> <B>s-clear-module</B> <I>((name STRING) (environment OBJECT)) : MODULE</I>
<DD>Destroy the contents of the module named <VAR>name</VAR>, as
well as the contents of all of its children, recursively.
</DL>
</P><P>

<A NAME="IDX149"></A>
<DL>
<DT><U>Function:</U> <B>s-conceive</B> <I>((sentence STRING) (module-name STRING) (environment OBJECT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Create one or more proposition objects from the sentence <VAR>sentence</VAR>
in the  module named <VAR>module-name</VAR>.  Return an iterator of the propositions.
If any of the new propositions has the same structure as an already existing
proposition, an automatic check for duplicates will return the pre-existing
proposition.  Multiple propositions may be returned for a single sentence
because of normalization of equivalences, conjunctions, etc.
</P><P>

Signals a <CODE>Proposition-Error</CODE> if PowerLoom could not conceive <VAR>sentence</VAR>.
</DL>
</P><P>

<A NAME="IDX150"></A>
<DL>
<DT><U>Function:</U> <B>s-create-concept</B> <I>((name STRING) (parent-name STRING) (module-name STRING) (environment OBJECT)) : LOGIC-OBJECT</I>
<DD>Create a concept named <VAR>name</VAR> in the designated module, with
with the concept named <VAR>parent-name</VAR> as superconcept (which can be left
undefined).  Additional superconcepts can be added via assertions of the
<CODE>subset-of</CODE> relation.  Note that a specified parent concept needs to be
created separately.
</DL>
</P><P>

<A NAME="IDX151"></A>
<DL>
<DT><U>Function:</U> <B>s-create-function</B> <I>((name STRING) (arity INTEGER) (module-name STRING) (environment OBJECT)) : LOGIC-OBJECT</I>
<DD>Create a function named <VAR>name</VAR> with arity <VAR>arity</VAR> in the designated 
module.  Domain and range information can be added via assertions of
<CODE>domain</CODE>, <CODE>nth-domain</CODE> and <CODE>range</CODE> relations.
</DL>
</P><P>

<A NAME="IDX152"></A>
<DL>
<DT><U>Function:</U> <B>s-create-object</B> <I>((name STRING) (concept-name STRING) (module-name STRING) (environment OBJECT)) : LOGIC-OBJECT</I>
<DD>Create an object named <VAR>name</VAR> of type <VAR>concept-name</VAR> in the designated
module.  Both <VAR>name</VAR> and <VAR>concept-name</VAR> can be null strings.  If <VAR>name</VAR> is a null string
then an object will be created with a new, non-conflicting name based on <VAR>concept-name</VAR>, or
system-generated if no concept nameis specified.  If <VAR>concept-name</VAR> is the null string, then
the object will be of type THING.
</P><P>

Return the object.
</DL>
</P><P>

<A NAME="IDX153"></A>
<DL>
<DT><U>Function:</U> <B>s-create-relation</B> <I>((name STRING) (arity INTEGER) (module-name STRING) (environment OBJECT)) : LOGIC-OBJECT</I>
<DD>Create a relation named <VAR>name</VAR> with arity <VAR>arity</VAR> in the
designated module.  Domain and range information can be added via assertions
of <CODE>nth-domain</CODE> (or <CODE>domain</CODE> and <CODE>range</CODE>) relations.
</DL>
</P><P>

<A NAME="IDX154"></A>
<DL>
<DT><U>Function:</U> <B>s-destroy-object</B> <I>((object-name STRING) (module-name STRING) (environment OBJECT)) :</I>
<DD>Delete the object named <VAR>object-name</VAR>, retracting all facts
attached to it.
</DL>
</P><P>

<A NAME="IDX155"></A>
<DL>
<DT><U>Function:</U> <B>s-evaluate</B> <I>((command STRING) (module-name STRING) (environment OBJECT)) : OBJECT</I>
<DD>Evaluate the command represented by the string <VAR>command</VAR> within <CODE>module</CODE> and
return the result.  Currently, only the evaluation of (possibly nested) commands and
global variables is supported.
</DL>
</P><P>

<A NAME="IDX156"></A>
<DL>
<DT><U>Function:</U> <B>s-get-arity</B> <I>((relation-name STRING) (module-name STRING) (environment OBJECT)) : INTEGER</I>
<DD>Return the arity of the relation named <VAR>relation-name</VAR>.
</DL>
</P><P>

<A NAME="IDX157"></A>
<DL>
<DT><U>Function:</U> <B>s-get-child-modules</B> <I>((name STRING) (environment OBJECT)) : (PL-ITERATOR OF MODULE)</I>
<DD>Return the modules that are immediate children of module <VAR>name</VAR>.
</DL>
</P><P>

<A NAME="IDX158"></A>
<DL>
<DT><U>Function:</U> <B>s-get-concept</B> <I>((name STRING) (module-name STRING) (environment OBJECT)) : LOGIC-OBJECT</I>
<DD>Return a class/concept named <VAR>name</VAR> that is local to
or visible from the module <VAR>module-name</VAR>.
</DL>
</P><P>

<A NAME="IDX159"></A>
<DL>
<DT><U>Function:</U> <B>s-get-concept-instances</B> <I>((concept-name STRING) (module-name STRING) (environment OBJECT)) : PL-ITERATOR</I>
<DD>Return instances of concept <VAR>concept-name</VAR>.
Include instances of subconcepts of <VAR>concept-name</VAR>.  Depending on <VAR>concept-name</VAR>,
the return values could be (wrapped) literals.
</DL>
</P><P>

<A NAME="IDX160"></A>
<DL>
<DT><U>Function:</U> <B>s-get-direct-concept-instances</B> <I>((concept-name STRING) (module-name STRING) (environment OBJECT)) : PL-ITERATOR</I>
<DD>Return instances of concept <VAR>concept-name</VAR>.
Exclude instances of subconcepts of <VAR>concept-name</VAR>.  Depending on <VAR>concept-name</VAR>,
the return values could be (wrapped) literals.
</DL>
</P><P>

<A NAME="IDX161"></A>
<DL>
<DT><U>Function:</U> <B>s-get-domain</B> <I>((relation-name STRING) (module-name STRING) (environment OBJECT)) : LOGIC-OBJECT</I>
<DD>Return the type (concept) for the first argument to the binary
relation <VAR>relation-name</VAR>.
</DL>
</P><P>

<A NAME="IDX162"></A>
<DL>
<DT><U>Function:</U> <B>s-get-inferred-binary-proposition-values</B> <I>((relation-name STRING) (arg-name STRING) (module-name STRING) (environment OBJECT)) : PL-ITERATOR</I>
<DD>Return all values <CODE>v</CODE> such that (<VAR>relation-name</VAR> <VAR>arg-name</VAR> <CODE>v</CODE>)
has been asserted or can be inferred.
</DL>
</P><P>

<A NAME="IDX163"></A>
<DL>
<DT><U>Function:</U> <B>s-get-nth-domain</B> <I>((relation-name STRING) (n INTEGER) (module-name STRING) (environment OBJECT)) : LOGIC-OBJECT</I>
<DD>Return the type (a concept) for the nth argument of the relation
named <VAR>relation-name</VAR>.  Counting starts at zero.
</DL>
</P><P>

<A NAME="IDX164"></A>
<DL>
<DT><U>Function:</U> <B>s-get-object</B> <I>((name STRING) (module-name STRING) (environment OBJECT)) : OBJECT</I>
<DD>Look for an object named <VAR>name</VAR> that is local to
or visible from the module <VAR>module-name</VAR>.
</DL>
</P><P>

<A NAME="IDX165"></A>
<DL>
<DT><U>Function:</U> <B>s-get-parent-modules</B> <I>((name STRING) (environment OBJECT)) : (PL-ITERATOR OF MODULE)</I>
<DD>Return the modules that are immediate parents of module <VAR>name</VAR>.
</DL>
</P><P>

<A NAME="IDX166"></A>
<DL>
<DT><U>Function:</U> <B>s-get-parent-modules</B> <I>((name STRING) (environment OBJECT)) : (PL-ITERATOR OF MODULE)</I>
<DD>Return the modules that are immediate parents of module <VAR>name</VAR>.
</DL>
</P><P>

<A NAME="IDX167"></A>
<DL>
<DT><U>Function:</U> <B>s-get-proposition</B> <I>((relation-and-arguments STRING) (module-name STRING) (environment OBJECT)) : PROPOSITION</I>
<DD>Return a proposition matching <VAR>relation-and-arguments</VAR> that
has been asserted (or inferred by forward chaining).  <VAR>relation-and-arguments</VAR>
is a string that begins with a left parenthesis, followed by a relation name, 
one or more argument identifiers, and terminated by a right parenthesis.  Each
argument identifier can be the name of a logical constant, a literal
reference (e.g., a number), the null identifier, or a variable (an identifier that begins
with a question mark). Each occurrence of a null or a variable acts like a wild card.
If more than one proposition matches the input criteria, the selection among
satisficing propositions is arbitrary.  This procedure is normally applied to
single-valued relations or functions.
</DL>
</P><P>

<A NAME="IDX168"></A>
<DL>
<DT><U>Function:</U> <B>s-get-propositions</B> <I>((relation-and-arguments STRING) (module-name STRING) (environment OBJECT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Return propositions matching <VAR>relation-and-arguments</VAR> that
have been asserted (or inferred by forward chaining).  <VAR>relation-and-arguments</VAR>
is a string that begins with a left parenthesis, followed by a relation name, 
one or more argument identifiers, and terminated by a right parenthesis.  Each
argument identifier can be the name of a logical constant, a literal 
reference (e.g., a number), the null identifier, or a variable (an identifier that begins
with a question mark). Each occurrence of a null or a variable acts like a wild card.
</DL>
</P><P>

<A NAME="IDX169"></A>
<DL>
<DT><U>Function:</U> <B>s-get-propositions-of</B> <I>((object-name STRING) (module-name STRING) (environment OBJECT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Return all propositions that have the object named <VAR>object-name</VAR> among
their arguments, and that are TRUE in the scope of the module <CODE>module</CODE>.
</DL>
</P><P>

<A NAME="IDX170"></A>
<DL>
<DT><U>Function:</U> <B>s-get-range</B> <I>((relation-name STRING) (module-name STRING) (environment OBJECT)) : LOGIC-OBJECT</I>
<DD>Return the type (a concept) for fillers of the binary relation
<VAR>relation-name</VAR>.
</DL>
</P><P>

<A NAME="IDX171"></A>
<DL>
<DT><U>Function:</U> <B>s-get-relation</B> <I>((name STRING) (module-name STRING) (environment OBJECT)) : LOGIC-OBJECT</I>
<DD>Return a concept or relation named <VAR>name</VAR> that is local to
or visible from the module <VAR>module-name</VAR>.
</DL>
</P><P>

<A NAME="IDX172"></A>
<DL>
<DT><U>Function:</U> <B>s-get-relation-extension</B> <I>((relation-name STRING) (module MODULE) (environment OBJECT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Return propositions that satisfy the relation named
<VAR>relation-name</VAR>.  Include propositions that satisfy subrelations of the relation.
</DL>
</P><P>

<A NAME="IDX173"></A>
<DL>
<DT><U>Function:</U> <B>s-get-rules</B> <I>((relation-name STRING) (module-name STRING) (environment OBJECT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Return rules attached to the concept/relation named
<VAR>relation-name</VAR> found in the module named <VAR>module-name</VAR>.
</DL>
</P><P>

<A NAME="IDX174"></A>
<DL>
<DT><U>Function:</U> <B>s-is-true-proposition</B> <I>((relation-and-arguments STRING) (module-name STRING) (environment OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if a proposition that prints as the string
<VAR>relation-and-arguments</VAR> is true in the module named <VAR>module-name</VAR>.
</DL>
</P><P>

<A NAME="IDX175"></A>
<DL>
<DT><U>Function:</U> <B>s-print-rules</B> <I>((name STRING) (stream OUTPUT-STREAM) (module-name STRING) (environment OBJECT)) :</I>
<DD>Print rules attached to the concept/relation named <VAR>name</VAR>.
</DL>
</P><P>

<A NAME="IDX176"></A>
<DL>
<DT><U>Function:</U> <B>s-retract-proposition</B> <I>((sentence STRING) (module-name STRING) (environment OBJECT)) : (PL-ITERATOR OF PROPOSITION)</I>
<DD>Retract the truth of the logical sentence <VAR>sentence</VAR> in the module named
<VAR>module-name</VAR>.  Return an iterator of the retracted propositions resulting
from sentence.
</DL>
</P><P>

<A NAME="IDX177"></A>
<DL>
<DT><U>Function:</U> <B>s-retrieve</B> <I>((query STRING) (module-name STRING) (environment OBJECT)) : PL-ITERATOR</I>
<DD>Returns an iterator for variables that satisfy <VAR>query</VAR> in <VAR>module-name</VAR>
and <VAR>environment</VAR>.  This uses the normal PowerLoom query syntax:
</P><P>

   <CODE>"[n-values] output-variables query-form [options]"</CODE>
</P><P>

The <CODE>output-variables</CODE> should either be a single variable name
-- preceded by the <CODE>?</CODE> character -- or a list of one or more such names.
If a single variable name is provided, then each element in the returned
iterator will be a value binding.  If a list (even of one variable name)
is provided, then each element in the returned iterator can be accessed
using the <CODE>get-nth-</CODE>... functions.
</DL>
</P><P>

<A NAME="IDX178"></A>
<DL>
<DT><U>Function:</U> <B>s-save-module</B> <I>((module-name STRING) (filename STRING) (ifexists STRING) (environment OBJECT)) :</I>
<DD>Save the contents of the module <VAR>module-name</VAR> into a file named <VAR>filename</VAR>.
If a file named <VAR>filename</VAR> already exists, then the action taken depends on the
value of <VAR>ifexists</VAR>.  Possible values are "ASK", "REPLACE", "WARN" and "ERROR":
</P><P>

  REPLACE =&#62; Means overwrite without warning.
  WARN    =&#62; Means overwrite with a warning.
  ERROR   =&#62; Means don't overwrite, signal an error instead.
  ASK     =&#62; Ask the user whether to overwrite or not.  If not overwritten, an
             exception is thrown.
</DL>
</P><P>

<A NAME="IDX179"></A>
<DL>
<DT><U>Function:</U> <B>save-module</B> <I>((module MODULE) (filename STRING) (ifexists STRING) (environment OBJECT)) :</I>
<DD>Save the contents of the module <CODE>mod</CODE> into a file named <VAR>filename</VAR>.
If a file named <VAR>filename</VAR> already exists, then the action taken depends on the
value of <VAR>ifexists</VAR>.  Possible values are "ASK", "REPLACE", "WARN" and "ERROR":
</P><P>

  REPLACE =&#62; Means overwrite without warning.
  WARN    =&#62; Means overwrite with a warning.
  ERROR   =&#62; Means don't overwrite, signal an error instead.
  ASK     =&#62; Ask the user whether to overwrite or not.  If not overwritten, an
             exception is thrown.
</DL>
</P><P>

<A NAME="IDX180"></A>
<DL>
<DT><U>Function:</U> <B>string-to-object</B> <I>((string STRING) (type LOGIC-OBJECT) (module MODULE) (environment OBJECT)) : OBJECT</I>
<DD>Evaluate <VAR>string</VAR> with respect to <VAR>module</VAR> and <VAR>environment</VAR>
and return the corresponding logical term.  <VAR>type</VAR> is a concept used to assist the
correct interpretation of <VAR>string</VAR>.
</P><P>

Currently <VAR>type</VAR> only has an effect on the interpretation of literal types.
</DL>
</P><P>

<A NAME="Language Specific Interface"></A>
<HR SIZE="6">
<A NAME="SEC45"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC44"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC46"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC43"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC43"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_10.html#SEC65"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC75">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 9.2 Language Specific Interface </H2>
<!--docid::SEC45::-->
<P>

This section contains the description of the programming language
specific aspects of using the PowerLoom API.  Each section describes the 
naming conventions and namespace issues related to calling the API
functions from that programming language.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_9.html#SEC46">9.2.1 Lisp API</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_9.html#SEC53">9.2.2 C++ API</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_9.html#SEC54">9.2.3 Java API</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Lisp API"></A>
<HR SIZE="6">
<A NAME="SEC46"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC45"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC47"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC44"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC45"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC53"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC75">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 9.2.1 Lisp API </H3>
<!--docid::SEC46::-->
<P>

This section tells how to call the API functions in PowerLoom's Common
Lisp implementation from a Lisp program.  The function names are
identical to the Stella names in the PowerLoom API description
See section <A HREF="manual_9.html#SEC43">9. PowerLoom API</A>.  They are exported from the <CODE>PLI</CODE> package.
Other Stella symbols and names are in the <CODE>STELLA</CODE> package, but
<STRONG>currently none of the Stella symbols are exported!</STRONG>.
</P><P>

PowerLoom can be used from Allegro Common Lisp, CMU Common Lisp,
LispWorks Common Lisp and Macintosh Common Lisp.  It may be possible to
use the system from other Common Lisp systems, but they have not been
tested.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_9.html#SEC47">9.2.1.1 Common Lisp Initialization</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_9.html#SEC48">9.2.1.2 Type Declarations</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_9.html#SEC49">9.2.1.3 NULL values</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_9.html#SEC50">9.2.1.4 Wrapped Literal Values</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_9.html#SEC51">9.2.1.5 Special Variables</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_9.html#SEC52">9.2.1.6 CLOS Objects versus Structs</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Initialization"></A>
<HR SIZE="6">
<A NAME="SEC47"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC46"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC48"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC45"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC46"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC53"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC75">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 9.2.1.1 Common Lisp Initialization </H4>
<!--docid::SEC47::-->
<P>

Loading the Common Lisp version of PowerLoom will normally initialize
the system as part of the loading process.  The Common Lisp version can
be loaded by loading the file <TT>`load-powerloom.lisp'</TT> from the
top-level <TT>`powerloom'</TT> directory.  This will make the system
available for use.
</P><P>

<A NAME="Type Declarations"></A>
<HR SIZE="6">
<A NAME="SEC48"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC47"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC49"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC45"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC46"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC53"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC75">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 9.2.1.2 Type Declarations </H4>
<!--docid::SEC48::-->
<P>

Stella is a typed language, and the Common Lisp translation uses the
type information for Common Lisp type declarations.  That means that
values specified as being of type INTEGER, STRING and FLOAT must have
the correct type.  In particular, integer values will not be coerced to
floating point values by the code.  The following native type
assignments are made:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    Stella      Common Lisp
    =======     ===========
    INTEGER     FIXNUM
    FLOAT       DOUBLE-FLOAT
    STRING      SIMPLE-STRING
</pre></td></tr></table></P><P>

<STRONG>For convenience, loading PowerLoom will set the default format for
reading floating point numbers in Common Lisp to be <CODE>double-float</CODE>.</STRONG>
</P><P>

Stella <CODE>CONS</CODE> objects are implmented as native Lisp conses.
Boolean values can take on the values <CODE>stella::true</CODE> or
<CODE>stella::false</CODE>.
</P><P>

<A NAME="NULL Values"></A>
<HR SIZE="6">
<A NAME="SEC49"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC48"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC50"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC45"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC46"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC53"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC75">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 9.2.1.3 NULL values </H4>
<!--docid::SEC49::-->
<P>

One additional consequence of the strong typing of the language is that
there are specialized <CODE>NULL</CODE> values for numeric and string parameters.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  Stella Type   Null Value
  ===========   ===========
    INTEGER     stella::null-integer
    FLOAT       stella::null-float
    STRING      stella::null-string
</pre></td></tr></table></P><P>

<A NAME="Wrapped Literal Values"></A>
<HR SIZE="6">
<A NAME="SEC50"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC49"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC51"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC45"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC46"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC53"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC75">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 9.2.1.4 Wrapped Literal Values </H4>
<!--docid::SEC50::-->
<P>

Literal values (integers, floats, strings, etc.) that are used in
PowerLoom appear as wrapped values.  The PowerLoom API functions
<CODE>object-to-...</CODE> can be used to coerce the values into the
appropriate return type.
</P><P>

&#60;to be written:  wrapping values&#62;
</P><P>

<A NAME="Special Variables"></A>
<HR SIZE="6">
<A NAME="SEC51"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC50"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC52"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC45"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC46"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC53"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC75">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 9.2.1.5 Special Variables </H4>
<!--docid::SEC51::-->
<P>

All Stella special variables are implemented as Common Lisp special
variables.  Binding of the values can be used normally.
</P><P>

<A NAME="CLOS Objects versus Structs"></A>
<HR SIZE="6">
<A NAME="SEC52"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC51"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC53"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC45"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC46"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC53"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC75">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 9.2.1.6 CLOS Objects versus Structs </H4>
<!--docid::SEC52::-->
<P>

PowerLoom can be translated in one of two ways for Common Lisp.  One
method uses CLOS objects as the basis for all Stella and PowerLoom
objects.  For faster execution, it is also possible to use a version in
which Stella and PowerLoom objects are implemented using Common Lisp
structs instead.  This is controlled by the special variable 
<CODE>cl-user::*load-cl-struct-stella?*</CODE>.  If this is set to
<CODE>cl:t</CODE>, then the struct version will be loaded.  This needs to be
set before loading the <TT>`load-powerloom.lisp'</TT> file.
</P><P>

<A NAME="C++ API"></A>
<HR SIZE="6">
<A NAME="SEC53"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC52"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC54"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC46"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC45"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_10.html#SEC65"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC75">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 9.2.2 C++ API </H3>
<!--docid::SEC53::-->
<P>

&#60;to be written&#62;
</P><P>

<A NAME="Java API"></A>
<HR SIZE="6">
<A NAME="SEC54"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC53"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC55"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC44"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC45"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_10.html#SEC65"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC75">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 9.2.3 Java API </H3>
<!--docid::SEC54::-->
<P>

This section tells how to call the API functions in PowerLoom's Java
implementation from a Java program.  The Java translation is written for
Java version 1.2.  All of the PowerLoom Interface functions appear as
static methods of the class <CODE>edu.isi.powerloom.PLI</CODE>.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_9.html#SEC55">9.2.3.1 Initializing PowerLoom</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_9.html#SEC56">9.2.3.2 PowerLoom Java Conventions</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_9.html#SEC57">9.2.3.3 Using the PLI Class</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_9.html#SEC58">9.2.3.4 Using Stella Objects</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_9.html#SEC59">9.2.3.5 PowerLoom and Threads</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_9.html#SEC60">9.2.3.6 Setting and Restoring Global Variable Values</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_9.html#SEC61">9.2.3.7 Java Character Mapping</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_9.html#SEC62">9.2.3.8 Stella Exceptions in Java</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_9.html#SEC63">9.2.3.9 Iteration in Java</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_9.html#SEC64">9.2.3.10 Utility Classes for Java</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Initializing PowerLoom"></A>
<HR SIZE="6">
<A NAME="SEC55"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC54"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC56"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC53"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC54"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_10.html#SEC65"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC75">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 9.2.3.1 Initializing PowerLoom </H4>
<!--docid::SEC55::-->
<P>

PowerLoom needs to run initialization functions to set up its
environment for proper operation when it starts up.  The simplest method 
for initializing PowerLoom is to use the static method call:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>        PLI.initialize()
</pre></td></tr></table></P><P>

This must be called before using any PowerLoom features and before
loading any PowerLoom knowledge bases.  It may be called more than once
without ill effect.
</P><P>

<A NAME="PowerLoom Java Conventions"></A>
<HR SIZE="6">
<A NAME="SEC56"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC55"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC57"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC53"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC54"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_10.html#SEC65"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC75">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 9.2.3.2 PowerLoom Java Conventions </H4>
<!--docid::SEC56::-->
<P>

PowerLoom's Java code is automatically generated by a translator from
underlying Stella code.  The character set for legal Stella names is larger
than the character set for legal Java identifiers, so there is some mapping
involved.
</P><P>

PowerLoom names are words separated by hyphen (-) characters.  For Java,
we have attempted to closely follow the Java conventions:
</P><P>

<UL>
<LI>
Class names begin with a capital letter and each word is capitalized.
The hyphens from the PowerLoom names are removed.  Example:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>        string-wrapper   =&#62;  StringWrapper
</pre></td></tr></table>   Exceptions are made for class names that would otherwise conflict with
   normal Java Classes.  In that case, the prefix "Stella_" is added to each
   class name.  At the moment this applies only to the following exceptions:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>        object    =&#62;  Stella_Object
        class     =&#62;  Stella_Class
</pre></td></tr></table><P>

<LI>
Method and Function names begin with a lower case letter but each
subsequent word is capitalized.  The hyphens from PowerLoom names are
removed.  Example:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>        wrapper-value    =&#62;  wrapperValue
</pre></td></tr></table><P>

<LI>
Storage slots are implemented as Java fields.  The names begin with a
lower case letter but each subsequent word is capitalized.  The hyphens
from PowerLoom names are removed.  Example:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>        dynamic-slots    =&#62;  dynamicSlots
</pre></td></tr></table><P>

<LI>
Global and Special variable names are written in all uppercase.  The
hyphens from PowerLoom are replaced by underscore (_) characters.  By
convention, special variables are written in PowerLoom with surrounding
asterisk (*) characters.  The asterisks are replaced by dollar signs ($).
Example:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>        *html-quoted-characters*  =&#62;  $HTML_QUOTED_CHARACTERS$
</pre></td></tr></table></UL>
<P>

The most common non-alphanumeric characters are mapped as follows.  A
full set of mappings is in section See section <A HREF="manual_9.html#SEC61">9.2.3.7 Java Character Mapping</A>.
<TABLE><tr><td>&nbsp;</td><td class=example><pre>   ?  =&#62;  P      (for Predicate)
   !  =&#62;  X      (eXclamation)
   $  =&#62;  B      (Buck)
   %  =&#62;  R      (peRcent)
   &#38;  =&#62;  A      (Ampersand)
   *  =&#62;  $      Special variable marker.
</pre></td></tr></table></P><P>

The character mappings use uppercase characters if the basic identifier
uses mixed or lower case.  The mappings use lowercase characters if the
basic identifier uses upper case.
</P><P>

Stella modules are mapped to Java packages.  The basic system
distribution includes the following package hierarchy:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  edu
     isi
        stella
            javalib
        powerloom
            logic
            pl_kernel_kb
                loom_api
</pre></td></tr></table></P><P>

Basic system functionality and data structures such as Cons and List
objects are defined in stella.  PowerLoom's logic (concepts, relations,
rules, etc.) are defined in the logic package.  There is a set of
interface functions in the PLI package.  They are described in their
own section below.
</P><P>

We recommend the following import statements in Java files that use
PowerLoom:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>        import edu.isi.stella.*;
        import edu.isi.stella.javalib.*;
        import edu.isi.powerloom.PLI;
        import edu.isi.powerloom.logic.*;
</pre></td></tr></table></P><P>

Functions (in Java terms, static Methods) are translated as static methods
on the class of their first argument (as long as that argument is not a
primitive type and is in the same Stella module).  Functions which take no
arguments, those whose first argument is a primitive type, and those whose
first argument is a class not defined in the same module are all placed
into a class with the same name as the Stella module in which it appers.
It will be in the package corresponding to that Stella module.  Java
constructors should not be called directly.  Instead, there will be a
static method <CODE>new&#60;ClassName&#62;</CODE> (with the class name in mixed case!) that
should be used instead.
</P><P>

Most of the functions of interest will be in the edu.isi.stella.Stella, 
edu.isi.powerloom.PLI or edu.isi.powerloom.logic.Logic classes.
</P><P>

Methods typically refer to their first argument as "self".
</P><P>

Methods which return more than one return value will take a final
argument which is an array of <CODE>Stella_Object</CODE>, which will be used to
return the additional arguments.
</P><P>

Primitive types in Stella have the following mapping in Java:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>        Stella          Java
        ======          ====
        INTEGER         int
        FLOAT           double
        NUMBER          double
        CHARACTER       char
        BOOLEAN         boolean
        STRING          String
        MUTABLE-STRING  StringBuffer

  NATIVE-OUTPUT-STREAM  java.io.PrintStream
  NATIVE-INPUT-STREAM   java.io.PushbackInputStream  (May change!!!)
</pre></td></tr></table></P><P>

Inside Stella/PowerLoom objects and collections, primitive types are
wrapped using Stella wrappers instead of Java's primitive classes.  So
integers will be wrapped as edu.isi.stella.IntegerWrapper rather than
java.lang.Integer.  Wrappers have a field called wrapperValue which
accesses the internal value.  Example of use:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    import edu.isi.stella.*;
    import edu.isi.stella.javalib.*;
    ...
    IntegerWrapper iWrap = IntegerWrapper.newIntegerWrapper(42);
    ...
    int answer = iWrap.wrapperValue;
    ...
</pre></td></tr></table></P><P>

<A NAME="Using the PLI Class"></A>
<HR SIZE="6">
<A NAME="SEC57"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC56"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC58"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC53"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC54"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_10.html#SEC65"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC75">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 9.2.3.3 Using the PLI Class </H4>
<!--docid::SEC57::-->
<P>

To make interoperability between PowerLoom and Java a little simpler, we
are providing a (PowerLoom Interface class named <CODE>PLI</CODE> which
handles synchronization issues, setting and restoring the reasoning
context, and the a more convenient use of some Java-native objects
rather than Stella objects.  Generally that means that strings are used
for PowerLoom expressions and return values rather than Stella
<CODE>Cons</CODE> objects.
</P><P>

Details about the methods can be found in the section See section <A HREF="manual_9.html#SEC43">9. PowerLoom API</A>.  The names of functions in that section will need to be converted
to their Java equivalents using the conventions described in
See section <A HREF="manual_9.html#SEC56">9.2.3.2 PowerLoom Java Conventions</A>.  We also provide javadoc
documentation for the <CODE>edu.isi.powerloom.PLI</CODE> class.  We recommend
using this method for accessing PowerLoom functionality.  We expect to
expand the range of PowerLoom interface functions that have an analog in
the <CODE>PLI</CODE> class over time.
</P><P>

<A NAME="Using Stella Objects"></A>
<HR SIZE="6">
<A NAME="SEC58"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC57"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC59"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC53"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC54"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_10.html#SEC65"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC75">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 9.2.3.4 Using Stella Objects </H4>
<!--docid::SEC58::-->
<P>

Stella objects can also be used directly.  The most common ones used by
PowerLoom users are <CODE>Module</CODE> and <CODE>LogicObject</CODE>.  Other
potentially useful Stella objects are <CODE>Cons</CODE>, <CODE>Symbol</CODE>,
<CODE>Keyword</CODE> and <CODE>List</CODE>.  Except for <CODE>LogicObject</CODE>, these are in
the <CODE>edu.isi.stella package</CODE>.  <CODE>LogicObject</CODE> is in the
<CODE>edu.isi.powerloom.logic</CODE> package.
</P><P>

If one wishes to construct <CODE>Cons</CODE> objects (for example to create
objects to pass to interface functions, one would begin by building
items up using <CODE>Stella_Object.cons</CODE> static method, which takes a
stella object and a cons.  The empty cons is kept in the
<CODE>edu.isi.stella.Stella.NIL</CODE> static variable.  Another way to create
stella objects is to use <CODE>edu.isi.stella.Stella.unstringify</CODE> static
method.  This method takes a string representation of a stella object
and returns the object.  If passed a list, an object of type <CODE>Cons</CODE>
will be returned.
</P><P>

As an alternative, one can also convert one and two dimensional arrays
of <CODE>Stella_Object</CODE> into <CODE>Cons</CODE> objects using the overloaded
function <CODE>edu.isi.stella.javalib.arrayToCons</CODE>.  These functions
will return <CODE>Cons</CODE> objects constructed from the input arrays.
</P><P>

Keywords and symbols are objects that are stored in global static
variables.  The variable names are all in upper case and are constructed
by concatenating the tag SYM with the module name and the name of the
symbol or concatenating the tag KWD with the name of the keyword.  For
example, the symbol BACKWARD in the logic module would be stored in
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>        edu.isi.powerloom.logic.Logic.SYM_LOGIC_BACKWARD
</pre></td></tr></table></P><P>

whereas the keyword :ERROR in the stella module would be in
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>        edu.isi.stella.Stella.KWD_ERROR
</pre></td></tr></table></P><P>

<A NAME="PowerLoom and Threads"></A>
<HR SIZE="6">
<A NAME="SEC59"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC58"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC60"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC53"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC54"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_10.html#SEC65"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC75">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 9.2.3.5 PowerLoom and Threads </H4>
<!--docid::SEC59::-->
<P>

The most important consideration when using PowerLoom in a threaded
environment is that the core of PowerLoom must not execute in
concurrently running threads.  The PLI class takes care of this for
interface functions that run through that class.  Other PowerLoom
functions that are called need to synchronize on a lock object
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>        edu.isi.powerloom.logic.Logic.$POWERLOOM_LOCK$
</pre></td></tr></table></P><P>

for proper operation.  This is not needed for setting Special Variables,
since they are implemented on a per-thread basis.  The most important
special variable is the reasoning context.  See See section <A HREF="manual_9.html#SEC60">9.2.3.6 Setting and Restoring Global Variable Values</A>.
</P><P>

<A NAME="Setting and Restoring Global Variable Values"></A>
<HR SIZE="6">
<A NAME="SEC60"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC59"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC61"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC53"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC54"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_10.html#SEC65"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC75">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 9.2.3.6 Setting and Restoring Global Variable Values </H4>
<!--docid::SEC60::-->
<P>

As noted above, special variables in Stella are implemented as static
fields in a catchall class named the same as the Stella module.  It will
be in the java package corresponding to that Stella module.  The values
of Special variables are stored in Java objects of the type
<CODE>StellaSpecialVariable</CODE>, a subclass of Java's <CODE>InheritableThreadLocal</CODE>.  Any
changes made to the values will not affect any other running threads.
This means that the changes don't need to be synchronized.  Note that
global (as opposed to special) variables don't use these objects.
</P><P>

Numbers and boolean values are stored in special variables using the
corresponding Java classes <CODE>Integer</CODE>, <CODE>Double</CODE>,
<CODE>Boolean</CODE>, etc.  The naming convention is to have all upper case
letters with a dollar sign ($) at the beginning and end of the name.
</P><P>

To temporarily change the value of one of these variables, users will
need to be responsible for saving and restoring the old values.  Use of
the "<CODE>try ... finally ...</CODE>" construct is very useful for this, since it
guarantees that the restore of values will be done.  An example follows
of how to safely change modules.  Contexts should be changed using the
functions, although other global variables can be changed by using the
set method.  Note that we use variables of type Object to hold the
values, since that avoids the need to cast when extracting the current
value, since the only operation we do with the current value is save it
to restore it later.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>   import edu.isi.stella.*;

   // CONTEXT CHANGE.
   Object savedModule = Stella.$MODULE$.get();
   Module newModule
      = Stella.getStellaModule(contextName, true);
   if (newModule == null) { // Handle missing module
   }
   try {
     Module.changeCurrentModule(newModule)
     // Code that uses the newModule

   } finally {
     Module.changeCurrentModule(savedModule);
   }


   // INTEGER VALUE CHANGE:
   Object savedValue = Stella.$SAFETY$.get();
   try {
     Stella.$SAFETY$.set(new Integer(3));
     // Code that uses the newModule

   } finally {
     Stella.$SAFETY$.set(savedValue);
   }


   // BOOLEAN VALUE CHANGE:
   Object savedValue = Stella.$PRINTREADABLY$.get();
   try {
     Stella.$PRINTREADABLY$.set(Boolean.TRUE);
     // Code that uses the newModule

   } finally {
     Stella.$PRINTREADABLY$.set(savedValue);
   }
</pre></td></tr></table></P><P>

The need to change the module using this type of code can be largely
avoided by using the functions in the PLI interface package.  They take
a module argument and can handle the binding and restoration of the
module value themselves.
</P><P>

<A NAME="Java Character Mapping"></A>
<HR SIZE="6">
<A NAME="SEC61"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC60"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC62"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC53"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC54"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_10.html#SEC65"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC75">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 9.2.3.7 Java Character Mapping </H4>
<!--docid::SEC61::-->
<P>

The full Stella to Java character mapping is the following. The
character mappings use uppercase characters if the basic identifier uses
mixed or lower case.  The mappings use lowercase characters if the basic
identifier uses upper case.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>   Stella  Java     Mnemonic
   ======  ====     ========
     !   =&#62;  X      (eXclamation)
     "   =&#62;  _
     #   =&#62;  H      (Hash)
     $   =&#62;  B      (Buck)
     %   =&#62;  R      (peRcent)
     &#38;   =&#62;  A      (Ampersand)
     '   =&#62;  Q      (Quote)
     (   =&#62;  _
     )   =&#62;  _
     *   =&#62;  $
     +   =&#62;  I      (Increase)
     ,   =&#62;  _
     -   =&#62;  _
     .   =&#62;  D      (Dot)
     /   =&#62;  S      (Slash)
     :   =&#62;  C      (Colon)
     ;   =&#62;  _
     &#60;   =&#62;  L      (Less than)
     =   =&#62;  E      (Equal)
     &#62;   =&#62;  G      (Greater than)
     ?   =&#62;  P      (Predicate)
     @   =&#62;  M      (Monkey tail)
     [   =&#62;  J      (Arbitrary (array index?))
     \   =&#62;  _
     ]   =&#62;  K      (Arbitrary (array index?)
     ^   =&#62;  U      (Up arrow)
     `   =&#62;  _
     {   =&#62;  Y      (Arbitrary (adjacent free letter))
     |   =&#62;  V      (Vertical bar)
     }   =&#62;  Z      (Arbitrary (adjacent free letter))
     ~   =&#62;  T      (Tilde)
&#60;space&#62;  =&#62; _
</pre></td></tr></table></P><P>

<A NAME="Stella Exceptions in Java"></A>
<HR SIZE="6">
<A NAME="SEC62"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC61"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC63"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC53"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC54"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_10.html#SEC65"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC75">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 9.2.3.8 Stella Exceptions in Java </H4>
<!--docid::SEC62::-->
<P>

Stella exceptions are implemented as a subtype of <CODE>java.lang.Exception</CODE>
(actually <CODE>RunTimeException</CODE>) and may be caught normally.  All Stella
Exceptions belong to the <CODE>edu.isi.stella.StellaException</CODE> class or one of
its subclasses.  The more specfic PowerLoom exceptions belong to the
<CODE>edu.isi.powerloom.logic.LogicException</CODE> class or one of its subclasses.
</P><P>

<A NAME="Iteration in Java"></A>
<HR SIZE="6">
<A NAME="SEC63"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC62"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC64"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC53"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC54"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_10.html#SEC65"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC75">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 9.2.3.9 Iteration in Java </H4>
<!--docid::SEC63::-->
<P>

Iteration in Stella (and by extension) PowerLoom is organized a little
bit differently than in Java.  You can either use the Stella iterators
directly, or else use one of the wrapper classes described in the
section See section <A HREF="manual_9.html#SEC64">9.2.3.10 Utility Classes for Java</A>.  It will present a more
familiar Java interface.  Since the iteration models are a bit
different, it would be unwise to mix accesses between the iteration
models.
</P><P>

Stella iterators do not compute any values until the next? method (in
Java: <CODE>nextP</CODE>) is called.  This method will try to compute the next
value of the iterator and it will return a boolean value which is true
if more values are present.  Each time it is called, the iteration
advances.  Values can be read out of the value field of the iterator,
which will have type <CODE>Stella_Object</CODE>.  Some iterators will also
have a key field which can be read.
</P><P>

The way one would normally use a Stella iterator is as follows, with
possible casting of the value field:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    Iterator iter = ...;

    while (iter.nextP()) {
        processValue(iter.value);
    }
</pre></td></tr></table></P><P>

<A NAME="Utility Classes for Java"></A>
<HR SIZE="6">
<A NAME="SEC64"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC63"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_10.html#SEC65"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC53"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC54"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_10.html#SEC65"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC75">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 9.2.3.10 Utility Classes for Java </H4>
<!--docid::SEC64::-->
<P>

To make interoperation of Stella and Java easier, there are several
convenience classes for wrapping Stella iterators and having them behave
like Java enumerations or iterators.  These convenience classes are in the
<CODE>edu.isi.stella.javalib</CODE> package:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>      ConsEnumeration.java      Enumeration class for Cons objects
      ConsIterator.java         Iterator class for Cons objects
      StellaEnumeration.java    Enumeration interface to Stella's Iterator
      StellaIterator.java       Iterator interface to Stella's Iterator
</pre></td></tr></table></P><P>

All of the iterators and enumerators return objects that are actually of
type <CODE>Stella_Object</CODE>, but the signature specifies
<CODE>java.lang.Object</CODE> as required for compatibility with the standard
Java signature.  The <CODE>Cons...</CODE> classes take a <CODE>Cons</CODE> in their
constructor.  The <CODE>Stella...</CODE> classes take a
<CODE>edu.isi.stella.Iterator</CODE> object in their constructor.
</P><P>

 
<A NAME="Built-In Relations"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC53"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_10.html#SEC65"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC75">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Hans Chalupsky</I> on <I>September, 30  2003</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
