This is manual.info, produced by makeinfo version 4.3 from manual.texi.

   This file documents the knowledge representation and reasoning
system.


File: manual.info,  Node: Built-In Relations,  Next: Installation,  Prev: PowerLoom API,  Up: Top

Built-In Relations
******************

   This chapter lists all of the relations that come predefined in
PowerLoom. They are defined in the module `PL-KERNEL'; users can access
them by including or using the `PL-KERNEL' module within the
declarations of their own modules.

 - Function: * ((?x NUMBER) (?y NUMBER)) :-> (?z NUMBER)
     Function that multiplies two numbers.

 - Function: + ((?x NUMBER) (?y NUMBER)) :-> (?z NUMBER)
     Function that adds two numbers.

 - Function: - ((?x NUMBER) (?y NUMBER)) :-> (?z NUMBER)
     Function that subtracts two numbers.

 - Function: / ((?x NUMBER) (?y NUMBER)) :-> (?z NUMBER)
     Function that divides two numbers.

 - Relation: < ((?x THING) (?y THING))
     True if ?x < ?y.

 - Relation: =< ((?x THING) (?y THING))
     True if ?x <= ?y.

 - Relation: > ((?x THING) (?y THING))
     True if ?x > ?y.

 - Relation: >= ((?x THING) (?y THING))
     True if ?x >= ?y.

 - Relation: ABSTRACT ((?r RELATION))
     True if there are no direct assertions made to the relation ?r.

 - Concept: AGGREGATE ((?a AGGREGATE))
     ?a is an aggregate

 - Relation: ANTISYMMETRIC ((?r RELATION))
     A binary relation ?r is antisymmetric if whenever (?r ?x ?y) is
     true (?r ?y ?x) is false unless ?x equals ?y.

 - Function: ARITY ((?r RELATION)) :-> (?arity INTEGER)
     The number of arguments/domains of the relation ?R.

 - Concept: BINARY-RELATION ((?r RELATION))
     The class of binary relations.

 - Relation: BOUND-VARIABLES ((?arguments THING))
     True if all arguments are bound.  The `bound-variables' predicate
     is used as a performance enhancer, to prevent other predicates
     from backchaining excessively while searching for bindings of
     certain of their arguments. Purists will shun the use of this
     predicate, but some rules are inherently inefficient without the
     addition of some kind of control logic.  Because evaluation of the
     `bound-variables' predicate evaluation of predicates being
     `guarded', using this predicate has the side-effect of locally
     disabling query optimization.  (See `collect-into-set' for an
     example that uses `bound-variables'.

 - Function: CARDINALITY ((?c SET)) :-> (?card INTEGER)
     Function that returns the cardinality of a set.

 - Relation: CLOSED ((?c COLLECTION))
     The collection ?c is closed if all of its members are known.
     Asserting that a relation is closed makes certain computations
     easier.  For example, suppose that the relation `happy' is closed,
     implying that all things that are happy will be asserted as such.
     To prove `(not (happy Fred))', PowerLoom can use a
     negation-as-failure proof strategy which returns TRUE if `Fred'
     cannot be proved to be happy.  Also, if the relation `children' is
     closed, then a value for the expression `(range-max-cardinality
     children Fred)' can be inferred merely by counting the number of
     fillers of the `children' role on `Fred'.

 - Function: COLLECT-INTO-SET ((?c COLLECTION)) :-> (?l SET)
     Infer as many members of ?c as possible and collect them into a
     set ?l.  For example, here is a rule used to compute bindings for
     the `fillers' predicate:

            (<= (fillers ?r ?i ?members)
                (and (bound-variables ?r ?i)
                     (collect-into-set (setofall ?v (holds ?r ?i ?v)) ?members)))

     When `?r' and `?i' are bound, the term `(setofall ?v (holds ?r ?i
     ?v))' evaluates to a unary relation satisfied for each filler of
     the relation in `?r' applied to the instance in `?i'.
     `collect-into-set' causes the extension of this
     (dynamically-defined) unary relation to be computed.  Note the use
     of `bound-variables' to screen out unbound variables before they
     are passed to the `setofall' term.

 - Class: COLLECTION : ABSTRACT-COLLECTION
     Not documented.

      - Class Parameter of : any-value : OBJECT
          Not documented.

 - Function: COLLECTIONOF ((?m THING)) :-> (?c COLLECTION)
     Abstract function existing to subsume `SETOF' and `LISTOF'.

 - Relation: COMMENT ((?x THING) (?s STRING))
     ?s is a comment attached to ?x.  Comments are a generalization of
     other annotations such as `documentation' and `issue' strings.

 - Relation: COMMUTATIVE ((?r RELATION))
     A relation ?r is commutative if its truth value is invariant with
     any permutation of its arguments.

 - Concept: CONCEPT ((?x RELATION))
     The class of reified unary relations.  The Powerloom notion of
     `concept' corresponds to the object-oriented notion of `class'.
     From a logic standpoint, the notion of a concept is hard to
     distinguish from the notion of `unary relation'.  The conceptual
     distinction is best illustrated in the domain of linguistics,
     where concepts are identified with collective nouns while unary
     relations are identified with adjectives.  For example, `Rock' is
     a concept, while `rocky' is a unary relation.

 - Function: CONCEPT-PROTOTYPE ((?c CONCEPT)) :-> (?i THING)
     Function that, given a concept, returns a prototypical instance
     that inherits all constraints that apply to any concept member,
     and has no additional constraints.

 - Class: CONTEXT : THING
     Not documented.

      - Slot of : child-contexts : (LIST OF CONTEXT)
          Not documented.

      - Slot of : base-module : MODULE
          Not documented.

      - Slot of : all-super-contexts : (CONS OF CONTEXT)
          Not documented.

      - Slot of : context-number : INTEGER
          Not documented.

 - Relation: COVERING ((?c COLLECTION) (?cover SET))
     True if ?c is a subset of the union of all collections in the set
     ?cover (see `disjoint-covering').

 - Relation: CUT ((?arguments THING))
     Prolog-like CUT.  Succeeds the first time and then fails.
     Side-effect:  Locally disables query optimization.

 - Relation: DIRECT-SUBRELATION ((?r RELATION) (?sub RELATION))
     True iff ?sub is a direct subrelation of ?r; written in set
     notation, ?sub < ?r, and there is no ?s such that ?sub < ?s < ?r.
     This relation will generate bindings for at most one unbound
     argument.

 - Relation: DIRECT-SUPERRELATION ((?r RELATION) (?super RELATION))
     True iff ?super is a direct superrelation of ?r; in set notation,
     ?super > ?r, and there is no ?s such that ?super > ?s > ?r.  This
     relation will generate bindings for at most one unbound argument.

 - Relation: DISJOINT ((?c1 COLLECTION) (?c2 COLLECTION))
     True if the intersection of ?c1 and ?c2 is empty.

 - Relation: DISJOINT-COVERING ((?c COLLECTION) (?disjointcover SET))
     True if ?c is covered by the collections in ?disjointCover and if
     the member sets in ?disjointCover are mutually-disjoint.  For
     example the concepts `Igneous-Rock', `Metamorphic-Rock', and
     `Sedimentary-Rock' together form a disjoint covering of the
     concept `Rock'.

 - Relation: DOCUMENTATION ((?x THING) (?s STRING))
     ?s is a documentation string attached to ?x.  Some of the
     PowerLoom text processing tools look for documentation strings and
     import them into documents.

 - Relation: DOMAIN ((?r RELATION) (?d COLLECTION))
     True if for any tuple `T' that satifies ?r, the first argument of
     `T' necessarily belongs to the concept ?d.  `domain' exists for
     convenience only and is defined in terms of `nth-domain'.  `domain'
     assertions should be avoided, since they create redundant
     `nth-domain' propositions (use `nth-domain' directly).

 - Relation: DUPLICATE-FREE ((?c COLLECTION))
     ?c is duplicate-free if no two members denote the same object.

 - Concept: DUPLICATE-FREE-COLLECTION ((?c COLLECTION))
     ?c is free of duplicates

 - Relation: EMPTY ((?c COLLECTION))
     The collection ?c is empty if it has no members.  Note that for
     collections possessing open-world semantics, (e.g., most concepts)
     the fact that the collection has no known members does not
     necessarily imply that it is empty.

 - Relation: EQUIVALENT-RELATION ((?r RELATION) (?equiv RELATION))
     True if ?r is equivalent to ?equiv; written in set notation, ?r =
     ?equiv.  This relation will generate bindings for at most one
     unbound argument.

 - Relation: EXAMPLE ((?r RELATION) (?e THING))
     ?e is an example of (the use of) ?r.

 - Function: FILLERS ((?r RELATION) (?i THING)) :-> (?members SET)
     Given a relation ?r and instance ?i, returns a set of known
     fillers of ?r applied to ?i.  IMPORTANT: this also collects
     intensional fillers such as skolems that might be identical
     extensionally.

 - Concept: FRAME-PREDICATE ((?c RELATION))
     A frame predicate is a second-order relation that is used to
     describe constraints on the set of fillers for a binary relation
     applied to an instance.  Examples of frame predicates are
     `range-cardinality', `range-type', and `numeric-inclusive-minimum'.
     Frame predicates are typically used to capture the kinds of
     relations manipulated by description logics such as USC/ISI's Loom
     and W3C's OWL.

 - Class: METHOD-SLOT : SLOT
     Not documented.

      - Slot of : method-setter? : BOOLEAN
          Not documented.

      - Slot of : method-parameter-names : (LIST OF SYMBOL)
          Not documented.

      - Slot of : method-parameter-type-specifiers : (LIST OF TYPE-SPEC)
          Not documented.

      - Slot of : method-return-type-specifiers : (LIST OF TYPE-SPEC)
          Not documented.

      - Slot of : method-stringified-source : STRING
          Not documented.

      - Slot of : method-code : METHOD-CODE
          Not documented.

      - Slot of : function-code : FUNCTION-CODE
          Not documented.

      - Slot of : method-function? : BOOLEAN
          Not documented.

 - Relation: GOES-FALSE-DEMON ((?r RELATION)
          (?computation COMPUTED-PROCEDURE))
     Names a `computation' (a function) that is attached (logically) to
     ?r  Each time a proposition with predicate ?r becomes false, the
     function is applied to that proposition.

 - Relation: GOES-TRUE-DEMON ((?r RELATION)
          (?computation COMPUTED-PROCEDURE))
     Names a `computation' (a function) that is attached (logically) to
     ?r  Each time a proposition with predicate ?r becomes true, the
     function is applied to that proposition.

 - Relation: GOES-UNKNOWN-DEMON ((?r RELATION)
          (?computation COMPUTED-PROCEDURE))
     Names a `computation' (a function) that is attached (logically) to
     ?r  Each time a proposition with predicate ?r becomes unknown, the
     function is applied to that proposition.

 - Relation: HOLDS ((?relation RELATION) (?arguments THING))
     True if the tuple ?ARGUMENTS is a member of the relation
     ?RELATION.  `holds' is a variable arity predicate that takes a
     relation as its first argument, and zero or more additional
     arguments.  It returns values equivalent to a subgoal that has the
     first argument as a predicate and the remaining arguments shifted
     one place to the left.  For `holds' to succeed, the (first)
     relation argument must be bound - PowerLoom will NOT cycle through
     all relations searching for ones that permit the proof to succeed.
     However, users can obtain the same effect if they choose by using
     other second-order predicates to generate relation bindings.  For
     example, the query

             (retrieve all ?x (and (Relation ?r)
                                   (holds ?r Fred ?x)))

     retrieves all constants for which there is some binary relation
     that relates `Fred' to that relation.

 - Relation: IMAGE-URL ((?x THING) (?url STRING))
     ?url is a URL pointing to an image illustrating ?x.  The
     Ontosaurus browser looks for `image-url' values attached to
     objects it is presenting, and displays them prominently, thereby
     spiffing up its displays.

 - Relation: INEQUALITY ((?x THING) (?y THING))
     Abstract superrelation of inequality relations.

 - Relation: INSTANCE-OF ((?x THING) (?c COLLECTION))
     True if ?x is an instance of ?c.  Can be used to generate concept
     values of ?c, given an instance ?x.

 - Function: INVERSE ((?r BINARY-RELATION)) :-> (?inverserelation THING)
     Function that returns the inverse relation for ?r.  PERFORMANCE
     NOTE: for best results there should be only one `(inverse R I)'
     assertion per relation pair `R' and `I'.  In that case `R' is
     viewed as the canonical relation and `I' simply provides a
     different access mechanism to the canonical relation.  In a
     logic-based KR paradigm inverse relations are redundant and do not
     add anything that couldn't be represented or queried without them,
     however, sometimes they can provide some extra convenience for
     users.  Asserting `(inverse I R)' also will not cause an error but
     can degrade backward inference performance due to the extra
     redundant rule that gets generated.  If domain rules will be
     written in terms of both `R' and `I' (as opposed to only `R'),
     `(inverse I R)' should be asserted also to get full inferential
     connectivity between the two relations.

 - Relation: IRREFLEXIVE ((?r RELATION))
     A binary relation ?r is irreflexive if it is false when both of
     its arguments are identical.

 - Relation: ISSUE ((?x THING) (?s STRING))
     ?s is an issue attached to ?x.  An issue string normally comments
     on a topic that has not been resolved to everyone's satisfaction.

 - Relation: IST ((?context CONTEXT) (?p PROPOSITION))
     True if proposition ?P is true in context ?CONTEXT.  The `IST' (is
     true) relation allows one to evaluate a query or rule in more than
     one context.  A common use of `IST' is in defining `lifting axioms'
     that import knowledge from one context to another.  For example,
     below is a rule that accesses a `patient-record' relation in a
     module called `Medical-Kb', `lifts-out' the `age' column, and
     imports it into a `has-age' relation in the current context.

            (<= (has-age ?person ?age)
                (and (has-ssn ?person ?ssn)
                     (exists (?1 ?2 ?3 ?4)
                        (ist Medical-Kb (patient-record ?ssn ?1 ?2 ?age ?3 ?4)))))


 - Function: LENGTH ((?x THING)) :-> (?z INTEGER)
     Function that returns the length of a string or a logical list.
     NOT YET IMPLEMENTED FOR LISTS.

 - Relation: LENGTH-OF-LIST ((?l COLLECTION) (?length INTEGER))
     Computes the length of the list or set ?l.

 - Relation: LEXEME ((?r THING) (?s STRING))
     ?s is a lexeme for the relation or individual ?r.  A relation or
     individual ?r can have zero or more lexemes, words that are
     natural langage equivalents of a logical constant.  The same
     lexeme may be attached to more than one constant.

 - Class: LIST : SEQUENCE
     Not documented.

      - Class Parameter of : any-value : OBJECT
          Not documented.

      - Slot of : the-cons-list : (CONS OF (LIKE (ANY-VALUE SELF)))
          Not documented.

 - Function: LISTOF ((?m THING)) :-> (?c LIST)
     Term-forming function that defines an ordered list consisting of
     all function arguments.  Within logical expressions `listof' is
     most commonly used in conjunction with the `member-of' predicate.
     For example the query

            (retrieve ?x (member-of ?x (listof a b c)))

     returns the constants `a', `b', and `c' on successive iterations.

 - Relation: MAXIMUM-VALUE ((?l COLLECTION) (?max NUMBER))
     Binds ?max to the maximum of the numbers in the list ?l.

 - Relation: MEAN-VALUE ((?l COLLECTION) (?mean NUMBER))
     Binds ?mean to the mean of the numbers in ?l.

 - Relation: MEDIAN-VALUE ((?l COLLECTION) (?median NUMBER))
     Binds ?median to the median of the numbers in ?l.

 - Relation: MEMBER-OF ((?x THING) (?c COLLECTION))
     TRUE if ?x is a member of collection ?c.  A common use of
     `member-of' is for binding a variable to successive members in a
     list or set (see `listof' and `setof').

 - Relation: MINIMUM-VALUE ((?l COLLECTION) (?min NUMBER))
     Binds ?min to the minimum of the numbers in the list ?l.

 - Relation: MUTUALLY-DISJOINT-COLLECTION ((?s SET))
     True if the members of ?s are pair-wise disjoint.  Used most often
     to expresse disjointness constraints between concepts.  For example

             (mutually-disjoint-collection (setof MAN WOMAN))

     states that the concepts MAN and WOMAN are disjoint.


 - Relation: NTH-DOMAIN ((?r RELATION) (?i INTEGER) (?d COLLECTION))
     True if the nth value for a tuple T satisfying ?r must belong to
     the concept ?d.  Argument counting starts at zero.

 - Relation: NUMERIC-MAXIMUM ((?r RELATION) (?i THING) (?n NUMBER))
     Relation that specifies an upper bound ?N on any numeric value
     that can belong to the set of fillers of the relation ?r applied
     to ?i.

 - Relation: NUMERIC-MINIMUM ((?r RELATION) (?i THING) (?n NUMBER))
     Relation that specifies a lower bound ?N on any numeric value that
     can belong to the set of fillers of the relation ?r applied to ?i.

 - Concept: NUMERIC-SET ((?s COLLECTION))
     ?s is a set of numbers

 - Relation: ORDERED ((?c COLLECTION))
     ?c is ordered if the ordering of its members is significant.
     Lists are ordered, while sets are not.

 - Relation: PHRASE ((?r THING) (?s STRING))
     A phrase is a variablized sentence, a template, that is used to
     express individual axiomatic facts as natural language sentences.
     By convention, a phrase contains one or more occurrences of each
     variable in a relation or concept definition, it does not begin
     with a capital letter, and it has no concluding period.
     Systematic attachment of phrases to relations can be leveraged by
     tools that generate natural language paraphrases of logic
     sentences.

 - Function: PROJECT-COLUMN ((?i INTEGER) (?c COLLECTION)) :-> (?l LIST)
     Project elements in column ?i (zero-based) of the tuples of ?c and
     collect them into a list ?l.

 - Relation: PROPER-SUBRELATION ((?r RELATION) (?sub RELATION))
     True iff ?sub is a proper subrelation of ?r; written in set
     notation, ?sub < ?r.  This relation will generate bindings for at
     most one unbound argument.

 - Relation: PROPER-SUPERRELATION ((?r RELATION) (?super RELATION))
     True iff ?super is a proper superrelation of ?r; written in set
     notation, ?super > ?r.  This relation will generate bindings for
     at most one unbound argument.

 - Class: PROPOSITION : CONTEXT-SENSITIVE-OBJECT, DYNAMIC-SLOTS-MIXIN,
          BACKLINKS-MIXIN
      - Slot of : home-context : CONTEXT
          Not documented.

      - Slot of : kind : KEYWORD
          Not documented.

      - Slot of : truth-value : TRUTH-VALUE
          Not documented.

      - Slot of : arguments : VECTOR
          Not documented.

      - Slot of : operator : GENERALIZED-SYMBOL
          Not documented.

      - Slot of : dependent-propositions : (NON-PAGING-INDEX OF
               PROPOSITION)
          Not documented.

 - Relation: RANGE ((?r RELATION) (?rng COLLECTION))
     True if for any tuple `T' that satifies ?r, the last argument of
     `T' necessarily belongs to the concept ?rng.  `range' exists for
     convenience only and is defined in terms of `nth-domain'.  `range'
     assertions should be avoided, since they create redundant
     `nth-domain' propositions (use `nth-domain' directly).

 - Function: RANGE-CARDINALITY ((?r RELATION) (?i THING)) :->
          (?card INTEGER)
     Function that returns the cardinality of the set of fillers of the
     relation ?r applied to ?i.  The cardinality function returns a
     value only when the relations `range-min-cardinality' and
     `range-max-cardinality' compute identical values, i.e., when the
     best lower and upper bounds on the cardinality are equal.  Each of
     these bounding functions employs a variety of rules to try and
     compute a tight bound.

 - Relation: RANGE-CARDINALITY-LOWER-BOUND ((?r RELATION) (?i THING)
          (?lb INTEGER))
     Relation that specifies a lower bound on the cardinality of the
     set of fillers of the relation ?r applied to ?i.  The difference
     between `range-cardinality-lower-bound' and
     `range-min-cardinality' is subtle but significant.   Suppose we
     state that nine is a lower bound on the number of planets in the
     solar system, and then ask if eight is (also) a lower bound:

             (assert (range-cardinality-lower-bound hasPlanets SolarSystem 9))
             (ask (range-cardinality-lower-bound hasPlanets SolarSystem 8))  ==> TRUE

     PowerLoom will return TRUE.  However if we ask if the minimum
     cardinality of the solar system's planets is eight, we get back
     UNKNOWN

             (ask (range-min-cardinality hasPlanets SolarSystem 8)) ==> UNKNOWN

     because eight is not the tightest lower bound.

 - Relation: RANGE-CARDINALITY-UPPER-BOUND ((?r RELATION) (?i THING)
          (?ub INTEGER))
     Relation that specifies an upper bound on the cardinality of the
     set of fillers of the relation ?r applied to ?i. (see the
     discussion for `range-cardinality-lower-bound').

 - Function: RANGE-MAX-CARDINALITY ((?r RELATION) (?i THING)) :->
          (?maxcard INTEGER)
     Returns the strictest computable upper bound on the cardinality of
     the set of fillers of the relation ?r applied to ?i.  (see the
     discussion for `range-cardinality-lower-bound').

 - Function: RANGE-MIN-CARDINALITY ((?r RELATION) (?i THING)) :->
          (?mincard INTEGER)
     Returns the strictest computable lower bound on the cardinality of
     the set of fillers of the relation ?r applied to ?i.  (see the
     discussion for `range-cardinality-lower-bound').

 - Relation: RANGE-TYPE ((?r RELATION) (?i THING) (?type COLLECTION))
     Relation that specifies a type/range of the relation ?r applied to
     ?i.  Multiple range types may be asserted for a single pair
     <?r,?i>.  Technically, a retrieval of types for a given pair
     should include all supertypes (superconcepts) of any type that is
     produced, but for utility's sake, only asserted or directly
     inferrable types are returned.

 - Relation: REFLEXIVE ((?r RELATION))
     A binary relation ?r is reflexive if it is always true when both
     of its arguments are identical.

 - Class: RELATION : MAPPABLE-OBJECT
     Not documented.

      - Slot of : abstract? : BOOLEAN
          Not documented.

 - Relation: RELATION-COMPUTATION ((?r RELATION)
          (?computation COMPUTED-PROCEDURE))
     Names a `computation' (a function) that evaluates an (atomic)
     relation proposition during query processing.  The function is
     passed a proposition for evaluation for which all arguments are
     bound.  The function returns a BOOLEAN if it represents a
     predicate, or some sort of value if it is a function.

 - Relation: RELATION-CONSTRAINT ((?r RELATION)
          (?computation COMPUTED-PROCEDURE))
     Names a `computation' (a function) that evaluates an (atomic)
     relation proposition during query processing.  The function is
     passed a proposition for evaluation for which at most one argument
     is unbound.  The function returns a BOOLEAN if it represents a
     predicate, or some sort of value if it is a function.  If all
     arguments are bound the function computes whether the constraint
     holds.  If all but one argument is bound and the unbound argument
     is a pattern variable then the missing value is computed.

 - Relation: RELATION-EVALUATOR ((?r RELATION) (?ev COMPUTED-PROCEDURE))
     Names an `evaluator' (a function) that evaluates an (atomic)
     relation proposition during constraint propagation.  This defines
     an extensible means for computing using auxiliary data structures.
     The function is passed a proposition for evaluation which might
     update the proposition, generate additional assertions or trigger
     further evaluations.  Evaluators have to check the truth-value of
     the passed-in proposition and perform their actions accordingly.
     An evaluated proposition might be true, false or even unknown in
     case the propositon was just newly constructed.

 - Relation: RELATION-SPECIALIST ((?r RELATION)
          (?sp COMPUTED-PROCEDURE))
     Names a `specialist' (a function) that evaluates an (atomic)
     relation proposition during query processing.  This defines an
     extensible means for computing with the control stack.  The
     function is passed a CONTROL-FRAME that contains the proposition,
     and returns a keyword :FINAL-SUCCESS, :CONTINUING-SUCCESS,
     :FAILURE, or :TERMINAL-FAILURE that controls the result of the
     computation.

 - Concept: SCALAR ((?x SCALAR))
     The class of scalar quantities.

 - Concept: SCALAR-INTERVAL ((?x SCALAR))
     An interval of scalar quantities.

 - Class: SET : LIST, SET-MIXIN
     Not documented.

      - Class Parameter of : any-value : OBJECT
          Not documented.

 - Function: SETOF ((?m THING)) :-> (?c SET)
     Term-forming function that defines an enumerated set consisting of
     all function arguments.  `setof' is like `listof' except that it
     removes duplicate values.

 - Relation: SINGLE-VALUED ((?c RELATION))
     The relation ?c is single-valued if the value of its last argument
     is a function of all other arguments.  All functions are
     single-valued (see `function').

 - Relation: SQUARE-ROOT ((?x NUMBER) (?y NUMBER))
     Relation that returns the positive and negative square roots: ?y =
     sqrt(?x).  For positive roots only see function SQRT.

 - Relation: STANDARD-DEVIATION ((?l COLLECTION) (?sd NUMBER))
     Binds ?sd to the standard deviation of the numbers in ?l.

 - Function: STRING-CONCATENATE ((?x1 STRING) (?x2 STRING)) :->
          (?x3 STRING)
     Concatenate strings ?x1 and ?x2 and bind ?x3 to the result.

 - Relation: SUBRELATION ((?r RELATION) (?sub RELATION))
     True iff ?sub is a subrelation of ?r; written in set notation,
     ?sub =< ?r.  This relation will generate bindings for at most one
     unbound argument.

 - Relation: SUBSET-OF ((?sub COLLECTION) (?super COLLECTION))
     True if ?sub is a subset of ?super.  For performance reasons, the
     `subset-of' predicate refuses to search for bindings if both of
     its variables are unbound.  Implementation note: `subset-of' is
     treated specially internally to PowerLoom, and hence Powerloom
     does not permit the augmentation of `subset-of' with additional
     inference rules.  In otherwords, `subset-of' behaves semantically
     like an operator instead of a relation.

 - Function: SUBSTRING ((?s STRING) (?start INTEGER) (?end INTEGER))
          :-> (?sub STRING)
     Generate the substring of ?s starting at position ?start
     (zero-based), ending just before position ?end and bind ?sub to
     the result.  This is the PowerLoom equivalent to the STELLA method
     `subsequence'.  In addition, this function can be used to locate
     substrings in strings by supplying values for ?s and ?sub and
     allowing ?start and ?end to be bound by the function specialist.
     In other words,       (retrieve all (?start ?end) (substring "foo"
     ?start ?end "o"))  ==>  ?start = 1, ?end = 2,       ?start = 2,
     ?end = 3.

 - Relation: SUM ((?l COLLECTION) (?sum NUMBER))
     Binds ?sum to the sum of the numbers in the list ?l.

 - Relation: SUPERRELATION ((?r RELATION) (?super RELATION))
     True iff ?super is a superrelation of ?r; written in set notation,
     ?super >= ?r.  This relation will generate bindings for at most
     one unbound argument.

 - Relation: SYMMETRIC ((?r RELATION))
     A binary relation ?r is symmetric if it is commutative.

 - Relation: SYNONYM ((?term THING) (?synonym THING))
     Assert that ?SYNONYM is a synonym of ?TERM.  This causes all
     references to ?SYNONYM to be interpreted as references to ?TERM.
     Retraction eliminates a synonym relation.

 - Class: THING : STANDARD-OBJECT, DYNAMIC-SLOTS-MIXIN
     Defines a class that must be inherited by any class that
     participates in the PowerLoom side of things.

      - Slot of : surrogate-value-inverse : SURROGATE
          Not documented.

 - Relation: TOTAL ((?r FUNCTION))
     True if the function ?R is defined for all combinations of inputs.
     By default, functions are not assumed to be total (unlike Prolog,
     which `does' make such an assumption.  For example, if we define a
     two-argument function `foo' and then retrieve its value applied to
     some random instances `a' and `b', we get nothing back:

             (deffunction foo (?x ?y) :-> ?z)
             (retrieve ?x (= ?x (foo a b)))

     However, if we assert that `foo' is total, then we get a skolem
     back when we execute the same retrieve:

             (assert (total foo))
             (retrieve ?x (= ?x (foo a b)))


 - Relation: TRANSITIVE ((?r RELATION))
     A binary relation ?r is transitive if (?r ?x ?y) and (?r ?y ?z)
     implies that (?r ?x ?z).  Note that functions cannot be
     transitive, since their single-valuedness would not allow multiple
     different values such as (?r ?x ?y) and (?r ?x ?z) due to the
     Unique Names Assumption made by PowerLoom.

 - Relation: TYPE-OF ((?c COLLECTION) (?x THING))
     True if ?x is a member of the concept ?c.

 - Function: VALUE ((?function FUNCTION) (?arguments THING)) :->
          (?value THING)
     True if applying ?FUNCTION to ?ARGUMENTS yields the value
     `?value'.  The `value' predicate is the analog of `holds', except
     that it applies to functions instead of relations.

 - Relation: VARIABLE-ARITY ((?r RELATION))
     Asserts that the relation ?r can take a variable number of
     arguments.

 - Relation: VARIANCE ((?l COLLECTION) (?variance NUMBER))
     Binds ?variance to the variance of the numbers in ?l.


File: manual.info,  Node: Installation,  Next: Miscellaneous,  Prev: Built-In Relations,  Up: Top

Installation
************

* Menu:

* System Requirements::
* Unpacking the Sources::
* Lisp Installation::
* C++ Installation::
* Java Installation::
* Removing Unneeded Files::
* Installing PowerLoom Patches::


File: manual.info,  Node: System Requirements,  Next: Unpacking the Sources,  Prev: Installation,  Up: Installation

System Requirements
===================

   To install and use PowerLoom, you'll approximately need the
following amounts of disk space:

   * 16 MB for the tarred or zipped archive file

   * 70 MB for the untarred sources, tanslations, compiled Java files,
     and documentation

   * 16 MB to compile a Lisp version

   * 16 MB to compile the C++ version (without -g)

   * 5 MB to compile the Java version (already included)


   This means that you will need approximately 100 MB to work with one
Lisp, one C++ and one Java version of PowerLoom in parallel.  If you
also want to experiment with the Lisp translation variant that uses
structures instead of CLOS instances to implement STELLA objects, then
you will need an extra 16 MB to compile that.

   The full PowerLoom development tree is quite large, since for every
STELLA source file there are three to four translated versions and as
many or more compiled versions thereof.  The actual PowerLoom libraries
that you have to ship with an application, however, are quite small.
For example, the Java jar files `powerloom.jar' and `stella.jar' are
only 2.3 MB total (4 MB including Java sources).  The dynamic C++
libraries `libstella.so' and `liblogic.so' compiled on a Linux
platform, are about 8 MB total.  Additionally, if you don't need all
the different translations of PowerLoom, you can delete some of the
versions to keep your development tree smaller *Note Removing Unneeded
Files::.

   To run the Lisp version of PowerLoom, you will need an ANSI
Common-Lisp (or at least one that supports CLOS and logical pathnames).
We have successfully tested PowerLoom with Allegro-CL 4.2, 4.3, 5.0,
6.0 and 7.0, Macintosh MCL 3.0, 4.0 and 5.1, OpenMCL 1.0, SBCL 0.9.4,
CMUCL 19c, LispWorks 4.4.6, CLisp 2.37, Lucid CL 4.1 (plus the
necessary ANSI extensions and Mark Kantrowitz's logical pathnames
implementation), and various others.  Our main development platform is
Allegro CL running under Sun Solaris and Linux.  The closer your
environment is to ours, the higher are the chances that everything will
work right out of the box.  Lisp development under Windows should also
be no problem.

   To run the C++ version of PowerLoom, you will need a C++ compiler
(such as g++) that supports templates and exception handling.  We have
successfully compiled and run PowerLoom with g++ 3.2 and later under
Linux Redhat 8.0 & 9.0, SunOS and MacOS X, and with CygWin 5.0 and MinGW
5.0 under Windows 2000 and XP.  Both CygWin and MinGW provide a GNU Unix
environment, but MinGW can generate Windows executables that are fully
standalone.  We've also managed to compile PowerLoom under MS Visual
C++, however, we never got the Boehm garbage collector to work.  The GC
claims to be very portable, so this should be solvable for somebody with
good knowledge of MS Visual C++.

   For the Java version, you will need Java JDK 1.2 or later. To get
reasonable performance, you should use J2SDK 1.4 or 1.5.  We've run the
Java version of PowerLoom on a variety of platforms without any
problems.

   Any one of the Lisp, C++, or Java implementations of PowerLoom can be
used to develop your own PowerLoom-based applications.  Which one you
choose is primarily a matter of your application and programming
environment.  The Lisp and Java versions are comparable in speed, the
C++ version is usually a factor of 2-3 faster than Lisp or Java.


File: manual.info,  Node: Unpacking the Sources,  Next: Lisp Installation,  Prev: System Requirements,  Up: Installation

Unpacking the Sources
=====================

   Uncompress and untar the file `powerloom-X.Y.Z.tar.gz' (or unzip the
file `powerloom-X.Y.Z.zip') in the parent directory of where you want
to install PowerLoom (`X.Y.Z' are place holders for the actual version
numbers).  This will create the PowerLoom tree in the directory
`powerloom-X.Y.Z/' (we will use Unix syntax for pathnames).  All
pathnames mentioned below will be relative to that directory which we
will usually refer to as the "PowerLoom directory".


File: manual.info,  Node: Lisp Installation,  Next: C++ Installation,  Prev: Unpacking the Sources,  Up: Installation

Lisp Installation
=================

   To install the Lisp version of PowerLoom, startup Lisp and load the
file `load-powerloom.lisp' with:

     (CL:load "load-powerloom.lisp")

   The first time around, this will compile all Lisp-translated STELLA
files before they are loaded.  During subsequent sessions, the compiled
files will be loaded right away.

   By default, PowerLoom now uses the version that uses Lisp structs
instead of CLOS objects to implement STELLA objects.  If you do want to
use the CLOS-based version instead do the following:

     (CL:setq cl-user::*load-cl-struct-stella?* CL:nil)
     (CL:load "load-powerloom.lisp")

   Alternatively, you can edit the initial value of the variable
`*load-cl-struct-stella?*' in the file `load-powerloom.lisp'.  Using
structs instead of CLOS objects greatly improves slot access speed,
however, it may cause problems with incremental re-definition of STELLA
classes (this is only an issue if you are developing your application
code in the STELLA language.  In that case, it is recommended to only
use the struct option for systems that are in or near the production
stage).

   Once all the files are loaded, you should see a message similar to
this:

     PowerLoom 3.2.0 loaded.
     Type `(powerloom)' to get started.
     Type `(in-package "STELLA")' to run PowerLoom commands directly
        from the Lisp top level.
     USER(2):

   To reduce startup time, you might want to create a Lisp image that
has all of PowerLoom preloaded.

   Now type
     (in-package "STELLA")

   to enter the `STELLA' Lisp package where all the PowerLoom code
resides.  Alternatively, you can type

     (powerloom)

   which will bring up a PowerLoom listener that will allow you to
execute PowerLoom commands.

   *IMPORTANT*: All unqualified Lisp symbols in this document are
assumed to be in the `STELLA' Lisp package.  Moreover, the `STELLA'
package does *NOT* inherit anything from the `COMMON-LISP' package (see
the file `sources/stella/cl-lib/cl-setup.lisp' for the few exceptions).
Hence, you have to explicitly qualify every Lisp symbol you want to use
with `CL:'.  For example, to get the result of the previous evaluation,
you have to type `CL:*' instead of `*'.


File: manual.info,  Node: C++ Installation,  Next: Java Installation,  Prev: Lisp Installation,  Up: Installation

C++ Installation
================

   To compile the C++ version of PowerLoom, change to the native C++
directory of PowerLoom and run `make' like this:

     % cd native/cpp/powerloom
     % make

   This will compile all PowerLoom and STELLA files as well as the C++
garbage collector.  It will then generate static or dynamic
`libstella', `liblogic' and other library files in the directory
`native/cpp/lib' which can be linked with your own C++-translated
PowerLoom (or other) code.  To test whether the compilation was
successful, you can run PowerLoom from the top-level PowerLoom
directory using the `powerloom' script (or `powerloom.bat' under a
Windows command prompt):

     % powerloom c++
     Running C++ version of PowerLoom...
     Initializing STELLA...
     Initializing PowerLoom...
     
         Welcome to PowerLoom 3.2.0
     
     Copyright (C) USC Information Sciences Institute, 1997-2006.
     PowerLoom comes with ABSOLUTELY NO WARRANTY!
     Type `(copyright)' for detailed copyright information.
     Type `(help)' for a list of available commands.
     Type `(demo)' for a list of example applications.
     Type `bye', `exit', `halt', `quit', or `stop', to exit.
     
     
     PL-USER |=

   This will run various PowerLoom startup code and then bring up a
PowerLoom command loop where you can execute commands.  The `c++'
argument tells the script to run the C++ version of PowerLoom (which is
also run by default as long as the C++ version was compiled).  If the
C++ version was not compiled or the `java' argument was given instead,
the Java version of PowerLoom will be run.

   Type

     (demo)

   to bring up a menu of available demos, type

     (run-powerloom-tests)

   to run the PowerLoom test suite, or type

     exit

   to exit PowerLoom.


File: manual.info,  Node: Java Installation,  Next: Removing Unneeded Files,  Prev: C++ Installation,  Up: Installation

Java Installation
=================

   Nothing needs to be done to install the Java version.  Because Java
class files are platform independent, they are already shipped with the
PowerLoom distribution and can be found in the directory `native/java'
and its subdirectories.  Additionally, they have been collected into
the file `native/java/lib/powerloom.jar' in the PowerLoom directory.
To try out the Java version of PowerLoom, you can run PowerLoom from
the top-level PowerLoom directory using the `powerloom' script (or
`powerloom.bat' under a Windows command prompt):

     % powerloom java
     Running Java version of PowerLoom...
     Initializing STELLA...
     Initializing PowerLoom...
     
         Welcome to PowerLoom 3.2.0
     
     Copyright (C) USC Information Sciences Institute, 1997-2006.
     PowerLoom comes with ABSOLUTELY NO WARRANTY!
     Type `(copyright)' for detailed copyright information.
     Type `(help)' for a list of available commands.
     Type `(demo)' for a list of example applications.
     Type `bye', `exit', `halt', `quit', or `stop', to exit.
     
     
     PL-USER |=

   Similar to the C++ executable, this will run various PowerLoom
startup code and then bring up a PowerLoom command loop where you can
execute commands.  Type

     (demo)

   to bring up a menu of available demos, type

     (run-powerloom-tests)

   to run the PowerLoom test suite, or type

     exit

   to exit PowerLoom.


File: manual.info,  Node: Removing Unneeded Files,  Next: Installing PowerLoom Patches,  Prev: Java Installation,  Up: Installation

Removing Unneeded Files
=======================

   To save disk space, you can remove files that you don't need.  For
example, if you are not interested in the C++ version of PowerLoom, you
can delete the directory `native/cpp'.  Similarly, you can remove
`native/java' to eliminate all Java-related files.  You could do the
same thing for the Lisp directory `native/lisp', but (in our opinion)
that would make it less convenient for you to develop new PowerLoom
code that is written in STELLA.  Finally, if you don't need any of the
STELLA sources, you can delete the directory `sources/stella'.  If you
don't need local copies of the STELLA and PowerLoom documentation, you
can delete parts or all of the directories `sources/stella/doc' and
`sources/logic/doc'.


File: manual.info,  Node: Installing PowerLoom Patches,  Prev: Removing Unneeded Files,  Up: Installation

Installing PowerLoom Patches
============================

   If you already have an older version of PowerLoom installed, you can
upgrade to the latest patch level by downloading incremental sets of
patches instead of downloading the complete release.  Patch files are
usually significantly smaller than the complete release and patching an
existing installation can also preserve local additions, deletions, or
modifications.  PowerLoom patch files are available from the same
location as the full PowerLoom release.

   Patches are currently only available in Unix `diff' format which
requires the Unix `patch' utility to install them (the `patch' program
should be readily available on most Unix systems, otherwise, you can
get it for free from the Free Software Foundation).

   Patch files follow the following naming convention: Suppose the
current version of PowerLoom is 3.0.0.  Then the patch file to update
to the next patch level is called `powerloom-3.0.0-3.0.1.diff.gz'.

   *Important:* Patch files are strictly incremental.  Thus, to upgrade
from version 3.0.0 to 3.0.2, you will need two patch files: one to go
to version 3.0.1 and one to go from that to version 3.0.2; you will
have to apply them in that sequence.

   To find out the current version of your PowerLoom installation, look
at the version string displayed when the `powerloom' function is called
in Lisp, or when the C++ or Java program starts up.

   *Important:* Before you apply any patches, you should always make a
backup copy of your current PowerLoom installation to preserve any
local modifications you made, in case something goes wrong.

   To apply patches, copy the appropriate patch file to the top level of
your PowerLoom installation directory.  Suppose the patch file is called
`powerloom-3.0.0-3.0.1.diff.gz'.  You can apply the patches using the
following command:

     gunzip -qc powerloom-3.0.0-3.0.1.diff.gz | patch -p1

   If you deleted some native PowerLoom files to save space, you can
use the `-f' option to force `patch' to proceed even if files it needs
to patch do not exist anymore (this is somewhat dangerous in case
`patch' encounters some more serious problems).  For example:

     gunzip -qc powerloom-3.0.0-3.0.1.diff.gz | patch -p1 -f

   To keep patch files small, PowerLoom patch files do not contain
updated binary files that ship with the full release (such as Java
class files, jar files and PDF documents).  Those have to be
regenerated either manually or with help of available `Makefile's.  The
Lisp version of PowerLoom will automatically recompile the first time
the updated system is loaded.  To recompile the C++ installation follow
the installation instructions given above.  The Java version will need
to be recompiled manually (better patch recompilation support might
become available in the future).

