\input texinfo.tex @c -*-texinfo-*-

@c DO NOT MODIFY THIS FILE, IT WAS GENERATED AUTOMATICALLY FROM A TEMPLATE!


@c Version: manual.texi.in,v 1.40 2006/05/25 18:42:38 hans Exp

@setfilename manual.info


@c TexInfo formatting notes:
@c
@c - After updates do the following to update the node & menu structure:
@c   - insert node lines with titles taken from section headings via
@c         C-x h C-u M-x texinfo-insert-node-lines
@c   - link all nodes via
@c         M-x texinfo-every-node-update
@c   - create or update menus via
@c         M-x texinfo-all-menus-update
@c
@c - Don't fiddle with nodes and menus before the overall structure isn't
@c   pretty much determined (one can run `makeinfo' even without nodes)
@c - Node names have to be unique
@c - Node names should be short, keep details in their explanations -
@c   this makes the menus look better


@c Define a macro for use with constants like TRUE, FALSE, etc:

@macro constant{CONST}
@sc{\CONST\}
@end macro

@macro trademarksymbol
@math{^{@r{TM}}}
@end macro


@settitle PowerLoom Manual

@iftex
@finalout
@end iftex

@ifinfo
This file documents the
@html
PowerLoom&#8482;
@end html
knowledge representation and reasoning system.
@end ifinfo

@copying
Copyright @copyright{} 2006
University of Southern California, Information Sciences Institute,
4676 Admiralty Way,
Marina Del Rey, CA 90292, USA

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

PowerLoom is a trademark of the University of Southern California.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission notice
identical to this one except for the removal of this paragraph (this
paragraph not being relevant to the printed manual).

@end ignore
@end copying

@titlepage
@sp 6
@center @titlefont{PowerLoom@trademarksymbol{} Manual}
@sp 1
@center Powerful knowledge representation and reasoning with
@center delivery in Common-Lisp, Java, and C++
@sp 3
@center Version: 1.40
@center @today{}
@sp 1
@center This manual describes
@center PowerLoom 3.2 or later.
@sp 3
@center @strong{The PowerLoom development team}
@ifhtml
<br>
<blockquote>
@end ifhtml
@center Hans Chalupsky
@ifhtml
<br>
@end ifhtml
@center Robert M. MacGregor
@ifhtml
<br>
@end ifhtml
@center Thomas Russ
@ifhtml
<br>
@end ifhtml
@center @{hans,tar@}@@isi.edu
@ifhtml
</blockquote>
@end ifhtml
@page

@vskip 0pt plus 1fill
@insertcopying
@end titlepage

@c ===========================================================================

@contents

@c===========================================================================

@ifinfo
@node Top, Introduction, (dir), (dir)
@chapter PowerLoom Manual

This document describes the PowerLoom knowledge representation and
reasoning system.  PowerLoom is the successor to the Loom knowledge
representation system. It provides a language and environment for
constructing intelligent applications.

@end ifinfo

@c ===========================================================================

@menu
* Introduction::                
* Conceptual Framework::        
* Annotated Example::           
* Communicating with PowerLoom::  
* Commands::                    
* PowerLoom API::               
* Built-In Relations::          
* Installation::                
* Miscellaneous::               
* Glossary::                    
* PowerLoom Grammar::           
* Function Index::              
* Variable Index::              
* Concept Index::               
@end menu

@node Introduction, Conceptual Framework, Top, Top
@chapter Introduction

This document describes the PowerLoom knowledge representation and
reasoning system. PowerLoom is the successor to the Loom knowledge
representation system. It provides a language and environment for
constructing intelligent, knowledge-based applications. PowerLoom uses a
fully expressive, logic-based representation language (a variant of
KIF). It uses a natural deduction inference engine that combines forward
and backward chaining to derive what logically follows from the facts
and rules asserted in the knowledge base.  While PowerLoom is not a
description logic, it does have a description classifier which uses
technology derived from the Loom classifier to classify descriptions
expressed in full first order predicate calculus. PowerLoom uses modules
as a structuring device for knowledge bases, and ultra-lightweight
worlds to support hypothetical reasoning.

To implement PowerLoom we developed a new programming language called
STELLA, which is a Strongly Typed, Lisp-like LAnguage that can be
translated into Lisp, Java, and C++. STELLA tries to preserve those
features of Lisp that facilitate symbolic programming and rapid
prototyping, while still allowing translation into readable as well as
efficient Java and C++ code. Because PowerLoom in written STELLA, we are
able to deliver it in all three languages.

@c ---------------------------------------------------------------------------

@menu
* Powerloom Features::          
* Powerloom History::           
* Running PowerLoom::           
@end menu

@node Powerloom Features, Powerloom History, Introduction, Introduction
@section Powerloom Features

PowerLoom is a full-function, logic-based knowledge representation and
reasoning system, that supports all aspects of knowledge-based
applications.  It allows the representation of complex knowledge in a
declarative, logic-based language, supports a variety of reasoning mechanisms
to make implicit knowledge explicit, has a powerful query engine to retrieve
what has been asserted and logically follows from the KB, provides file-based
and RDBMS-based storage of knowledge bases, has a context and module system to
effectively partition and organize large knowledge bases, and has an extensive
API in multiple language to allow easy and effective integration into
knowledge-based applications.

PowerLoom's focus is on expressivity of its representation language while
still providing good scalability to large ontologies and knowledge bases.  In
general, PowerLoom takes a @emph{pragmatic stance} where usability is more
important than theoretical "neatness" and expressivity is more important than
inferential completeness.  From our point of view, there is nothing magical
about logic, it is just another programming language (with difficult to
understand semantics), so it should help you to solve the task at hand as best
as possible and not hinder you by forcing you to work around restrictions of
the logic.  Of course, PowerLoom cannot completely escape the straight-jacket
of logic, but it tries to push the boundaries as much as possible.

@itemize @bullet
@item
@strong{Representation language}: PowerLoom uses the language of
predicate logic to represent knowledge.  The syntax is KIF (the
Knowledge Interchange Format) which is one of the supported syntaxes of
the upcoming Common Logic standard.  PowerLoom adds a variety of
convenient definitional constructs as well as extensions beyond
traditional first-order logic such as type-level predicates, relation
variables in @code{holds} sentences, modal assertions (sentences about
sentences), cross-context assertions via @code{ist} to represent lifting
axioms, defaults (still experimental), and others.  The goal is to
provide a highly expressive representation language, since KR failures
or awkward models are often due to "we could not express X in language
L".  The theoretical undecidability and intractability of such an
expressive language is counteracted by providing limited, "pragmatic"
reasoning services that cover commonly encountered situations.  For
example, reasoning with second-order sentences that quantify over
relations is undecidable and leads to very unfocused search; however,
such sentences are very useful to describe axiom schemata that can be
cheaply run in forward direction to create regular first-order rules (in
a process not unlike macro expansion).

@item
@strong{Reasoning}: The primary reasoning mechanism is logical deduction
which infers statements that logically follow from the asserted
statements and rules.  Such statements can be asked about using
PowerLoom's query commands @code{ask} (for true/false questions) and
@code{retrieve} (for Wh-questions).  PowerLoom uses a natural deduction
system to answer queries but also has a large number of specialized
reasoning procedures to efficiently handle concept and relation
hierarchies, sets, frame predicates, search control, etc.  The
specialist architecture is extensible to allow users to plug-in their
own reasoners or computed predicates.  PowerLoom also supports
hypothetical reasoning, equality reasoning, arithmetic and reasoning
with inequalities.  While @strong{PowerLoom is not a description logic},
it does have a classifier that can classify concept and relation
hierarchies and instances defined using the full expressive power of
first-order logic.  The classifier does not provide any additional
inferences, but allows PowerLoom to eagerly pre-compute and cache
subsumption relationships which can then be utilized over and over
without having to re-derive them.  PowerLoom also provides some
experimental abductive and partial-match reasoning to handle incomplete
knowledge bases.

@item
@strong{Meta-representation and reasoning}: Concepts, relations,
contexts, rules, queries, etc. are all first-class citizens in the
domain of discourse.  Therefore, they can have assertions made about
them as well as reasoned about.  This mechanism is commonly used by the
system itself, e.g., to assert that a relation is single valued or
transitive, that a concept is closed, etc.

@item
@strong{Explanation}: PowerLoom can explain its reasoning by recording
inference trees and then rendering those into human-understandable
explanations.  PowerLoom also has an experimental "WhyNot" facility to
explain inference failures where no successful proof tree was found.

@item
@strong{Contexts and modules}: Contexts and modules provide separate
name and assertion spaces with inheritance which implement a powerful
structuring mechanism for KBs.  Contexts allow encapsulation and
organization of knowledge, efficient inference (by separating irrelevant
knowledge or by separating ontologies and assertion spaces from volatile
inference worlds), truth maintenance (via inference cache contexts),
scenarios and hypothetical reasoning, non-monotonic overrides in
sub-contexts, etc.  PowerLoom's context mechanism is built-in at a very
low level using a very efficient and light-weight implementation for
maximum performance.

@item
@strong{Open and closed-world}: By default, PowerLoom makes an
open-world assumption and returns @code{unknown} if it cannot prove or
disprove a question.  However, concepts and relations can be selectively
marked as closed to support selective closed-world reasoning.  PowerLoom
also has a @code{fail} predicate (in addition to true negation via
@code{not}) to implement closed-world negation-as-failure which can be
useful in certain situations.

@item
@strong{Knowledge base management}: PowerLoom supports incremental
monotonic and non-monotonic updates that extend or non-monotonically
change the assertion base.  In PowerLoom one can effectively interleave
definitions, re-definitions, assertions and retractions with retrieval
and inference without having to reload large knowledge bases from
scratch after every change.  Truth maintenance of cached inference
results that might have been invalidated by updates is done via
inference cache contexts.  After a knowledge base has been loaded and
changed by some updates, the changed state can be saved out to a file or
an (experimental) persistent store built on top of a relational
database.

@item
@strong{Scalability}: Despite its emphasis on expressive representation
which usually has to be paid for with intractable and expensive
reasoning procedures, PowerLoom is very scalable and comes with a
variety of mechanisms to control search and handle large ontologies and
knowledge bases.  For example, PowerLoom's reasoning specialists handle
a wide variety of inferencing very effectively without having to go
through any rule chaining.  Search control annotations can be used to
help the inference engine use rules more effectively.  For example,
depending on fan-out, certain rules are run more effectively forwards
than backwards (or vice versa), and a KB developer can tell the system
when that's the case.  PowerLoom has resource-bounded depth-first or
iterative deepening search which provides an any-time inference scheme
for situations where resources are limited.  A "just-in-time" forward
inference engine elaborates the assertion neighborhood of objects
touched upon by inference.  This allows focused forward inference
relevant to current inference goals, without having to run forward
inference over a potentially very large KB to completion.  PowerLoom has
a static and dynamic query optimizer, that, similar to optimizers used
in database systems, orders conjunctive goals based on relation
extension sizes and rule fan-out to minimize intermediate result sets
and chaining.  The dynamic optimizer does this for each conjunctive
subgoal based on actual bindings.  Given this mechanism it is possible
to run PowerLoom queries that return 100,000's of solutions.  PowerLoom
also has a powerful relational database interface that allows it to
utilize the power of databases for handling large assertion bases (soon
to be released).  One application of this PowerLoom/RDBMS integration is
used with ISI's Omega ontology.  It is also a crucial part of our KOJAK
Link Discovery System.

@item
@strong{Tools and APIs}: PowerLoom has a host of associated tools and
APIs (not all of which have been released yet).  It comes with an
interactive command-line interface which is useful for developing
ontologies and knowledge bases, an extensive programmatic interface
called PLI with Lisp, C++ and Java bindings, and a Lisp-based Loom API
to load legacy Loom KBs.  Ontosaurus is a Web-based KB browser that
dynamically generates HTML pages viewable in a standard Web browser.
Ontosaurus has been released in an experimental pre-release.  A
soon-to-be-released Prot&eacute;g&eacute; plug-in allows export of
Prot&eacute;g&eacute; ontologies into PowerLoom format.  A not yet
released Java-based GUI provides a browse/edit/query environment for
developing KBs.  The GUI uses a client/server architecture and is
deployable via Java WebStart in standard browser. OntoMorph is a
translation system that supports writing of KB translators and
importers, e.g., to import ontologies written in other languages (for
example, Flogic).

@item
@strong{Initial Semantic Web support}: Given PowerLoom's emphasis on
expressive representation, we have not yet focused much on Semantic Web
languages such as OWL, which restricts expressivity to gain
decidability.  OWL also has other limitations such as restriction to
binary relations and lack of support for arithmetic and inequalities
which limits its usefulness for practical applications.  Nevertheless,
given that people are starting to use these languages more and more,
we've developed some initial import translators for RDF/RDFS and OWL
which once they mature we will release as part of PowerLoom.

@item
@strong{Portability and integration}: Since PowerLoom is implemented in
STELLA, it is available in Lisp, C++ and Java implementations and highly
portable.  PowerLoom can be run in each of these languages under Unix
(such as Linux, SunOS or MacOS X) as well as Windows 2000 and XP.  Due
to the availability in three main-stream languages, it can easily be
integrated programmatically with most application software without
having to use some complex integration framework.  The C++ and Java
libraries for PowerLoom are also quite small and light-weight, for
example, the necessary STELLA and PowerLoom jar files of the Java
implementation are less than 2.5 Meg in size.
@end itemize

@c ---------------------------------------------------------------------------

@node Powerloom History, Running PowerLoom, Powerloom Features, Introduction
@section Powerloom History

<to be written>

@c ---------------------------------------------------------------------------

@node Running PowerLoom,  , Powerloom History, Introduction
@section Running PowerLoom

The easiest way to run PowerLoom on a variety of platforms is to use the
@file{powerloom} or @file{powerloom.bat} scripts in the top-level
PowerLoom directory.  If you have Java installed on your system, these
scripts should run out of the box without any further installation
requirements.  If you want to use the Lisp version of PowerLoom, simply
load the file @code{load-powerloom.lisp} into your Common Lisp.  If you
want to use the C++ version, you have to compile it first.  See the
Installation section in this manual for more details on how to install
the Lisp, C++ or Java version of PowerLoom @xref{Installation}.

Under Unix or MacOS X, open a shell window somewhere to run PowerLoom.
For example,

@example
% powerloom
Running Java version of PowerLoom...
Initializing STELLA...
Initializing PowerLoom...

    Welcome to PowerLoom 3.2.0

Copyright (C) USC Information Sciences Institute, 1997-2006.
PowerLoom comes with ABSOLUTELY NO WARRANTY!
Type `(copyright)' for detailed copyright information.
Type `(help)' for a list of available commands.
Type `(demo)' for a list of example applications.
Type `bye', `exit', `halt', `quit', or `stop', to exit.

PL-USER |= 
@end example

Under Windows, you can do something similar by running a Command Prompt
window and executing the @file{powerloom.bat} script.  You can also
simply double click on the script which will run PowerLoom and bring up
a Command Prompt window for you.

Once the @code{|=} prompt has come up you can type in PowerLoom commands
and see their results.  The string preceding the prompt indicates the
"current module" relative to which commands are interpreted.  For
example, type the @code{demo} command to see a menu of available demos.
Step through one or more of them to get familiar with PowerLoom.

PowerLoom is a reasoning engine that is intended to be integrated into
some host application software somewhat similar to a database system.
This is the main reason why it currently only ships with a command-line
interface; however, we do have an experimental PowerLoom GUI which might
also be released at some point.

@c ---------------------------------------------------------------------------

@menu
* Command-Line Options::        
@end menu

@node Command-Line Options,  , Running PowerLoom, Running PowerLoom
@subsection Command-Line Options

There are a few command-line options that can be supplied to the
@file{powerloom} script.

@example
powerloom [c++|java]
          [@{-e|--eval@} STELLA-EXPRESSION]
          [--batch]
@end example

The first optional argument determines what version to run if both C++
and Java versions are installed.  If no specific version is specified,
the C++ version will be run if it is installed, otherwise, the Java
version will be run.

@table @samp
@item --eval @var{STELLA-EXPRESSION}
@itemx -e @var{STELLA-EXPRESSION}
Specifies a STELLA expression that should be run just before the
PowerLoom command loop gets initialized.  This expression has to be a
known command (such as the various PowerLoom commands), since the STELLA
evaluator cannot (yet) evaluate arbitrary STELLA code.  For example,
@code{powerloom -e '(demo "equations" FALSE)'} will run a particular
demo before anything else.  You will need to appropriately quote
special characters interpreted by the shell or the Command Prompt window.

@item --batch
Runs PowerLoom in batch mode without running an interactive command
loop.  This can be useful in conjunction with the @code{--eval} option
to execute a single command or load a PowerLoom script via the
@code{load} command.
@end table

@c ===========================================================================

@node Conceptual Framework, Annotated Example, Introduction, Top
@chapter Conceptual Framework

This chapter presents the fundamental conceptual building blocks that are used
to construct PowerLoom knowledge bases. The PowerLoom language is based on KIF,
which provides a syntax and a declarative semantics for first-order predicate
calculus expressions. KIF is a proposed ANSII standard language used by a
variety of knowledge representation systems. Practical knowledge representation
systems necessarily add a procedural semantics that defines the interpretation
of knowledge structures when definitions and facts are retracted or modified.
This chapter assumes that the reader has some familiarity with the semantics of
the predicate calculus, and instead focuses on aspects of the semantics that go
beyond the traditional (KIF) semantics.

A PowerLoom knowledge base is constructed by first defining the
terminology (concepts and relations) for a domain, and then asserting
additional rules and facts about that domain. Facts can be asserted and
later retracted, so the answers returned by queries may change over
time. The knowledge structures are organized into logical containers
called ``modules''. The division into modules means that in general,
facts are not asserted globally, but instead hold only within a specific
context. For example, a logical proposition may evaluate as true within
one module, and evaluate as false within a different one.

The discussion below uses some examples of actual PowerLoom syntax
to illustrate certain points.  However, we gloss over the fine
points of syntax, and instead focus on semantic issues.  The next
chapter reverses that emphasis, and presents a series of examples
that illustrate the breadth of syntactic constructs implemented for
the PowerLoom language.

@c ---------------------------------------------------------------------------

@menu
* Terms and Propositions::      
* Relation Definitions::        
* Truth Values::                
* Modules::                     
@end menu

@node Terms and Propositions, Relation Definitions, Conceptual Framework, Conceptual Framework
@section Terms and Propositions

A knowledge base attempts to capture in abstract (machine interpretable)
form a useful representation of a physical or virtual world. The entities
in that world are modeled in the knowledge base by objects we call @emph{
terms}. Examples of terms are ``Georgia'' (denoting the U.S., state),
``BenjaminFranklin'' (denoting the historical person by that name), the
number three, the string "abc", and the concept ``Person''. Unlike
objects in an object-oriented programming language, the terms in a
PowerLoom knowledge base usually have distinct names (unless there are
sufficiently many that naming them all becomes impractical).

Terms are categorized or related to one another by objects called
@emph{relations}.  Examples of relations are ``has age'', ``greater than'',
``is married to'', ``plus''.  Concepts such as ``Person'', ``State'',
``Company'', and ``Number'' are considered a subcategory of relations.

A @emph{proposition} is a logical sentence that has an associated truth
value. Examples are ``Ben Franklin is a person'', ``Bill is married to
Hillary'', ``Two plus three equals six'' (which is false). PowerLoom
follows KIF in adopting a prefix notation for the predicate calculus to
represent propositions. Possible representations of the three
propositions just mentioned are @code{(person ben-franklin)},
@code{(married-to Bill Hillary)}, and @code{(= (+ 2 3) 6)}. These three
propositions make reference to relations named @code{person},
@code{married-to}, @code{ plus}, and @code{=}.

The predicate calculus constructs complex sentences out of simpler ones
using the logical connectives @code{and}, @code{or}, @code{not}, @code{<=},
@code{=>}, and @code{<=>}, and the
quantifiers @code{exists} and @code{forall}. Some examples are @code{(not
(crook richard))} ``Richard is not a crook'', and @code{(forall ?p
(=> (person ?p) (exists ?m (has-mother ?p ?m))))} ``every person has a
mother''.

@c ---------------------------------------------------------------------------

@node Relation Definitions, Truth Values, Terms and Propositions, Conceptual Framework
@section Definitions

PowerLoom requires that relations are defined before they are
used within assertions and queries.  The commands @code{defconcept},
@code{defrelation}, and @code{deffunction} are used to define
concepts, relations, and functions, respectively.  The definitions

@example
(defconcept person)
(defrelation married-to ((?p1 person) (?p2 person))
(deffunction + ((?n1 number) (?n2 number)) :-> (?sum number))
@end example

declare that @code{person} is a concept, that @code{married-to}
is a binary relation that takes arguments of type @code{person},
and that @code{+} is a function that takes arguments of type
@code{number}@footnote{The function @code{+} and the concept 
@code{number} are predefined in PowerLoom.}.  The requirement
that relations be defined before they are referenced can be
inconvenient at times.  For example, suppose we wish to define
@code{parent} as ``a person who is the parent of another person''
and we also wish to state that the first argument to the 
@code{parent-of} relation has type @code{parent}:

@example
(defconcept parent (?p)
  :<=> (and (person ?p) (exists ?c (parent-of ?p ?c))))
(defrelation parent-of ((?p parent) (?c person)))
@end example

In this example, the first reference to @code{parent-of} occurs before it
is defined. PowerLoom permits circular references such as these as long
as they occur within definitions. It does so by deferring evaluation of
rules that occur within definitions. Here is a specification that is
logically equivalent, but is not legal because the @code{parent-of}
relation appears in an assertion before it is defined:

@example
(defconcept parent (?p))
(assert (forall (?p) (<=> (parent ?p) 
                          (and (person ?p) (exists ?c (parent-of ?p ?c))))))
(defrelation parent-of ((?p parent) (?c person)))
@end example

So when does the rule inside of the first @code{parent} definition get
defined?  All axioms (facts and rules) that appear within the boundaries
of a definition are evaluated just prior to the next occurrence of
a PowerLoom query.  Hence, in the example above where the rule occurred
@emph{within} the definition, there was no error because evaluation of
that rule occured sometime after the second definition (which defines
the otherwise problematic reference to @code{parent-of}).

One will sometimes see the command @code{(process-definitions)} appearing at
intervals within a file containing PowerLoom commands. Each such
appearance forces the definitions that preceed it to be fully-evaluated.
This is done so that the interval between a definition and its evaluation
not be too great; it can get confusing if PowerLoom reports a semantic
violation long after the origin of the conflict.

PowerLoom definitions commands (those prefixed by ``def'') have one other
semantic property that distinguishes them from ordinary assertions. Any
axioms that appear within a definition are tied to that definition.
If a definition is modified and then reevaluated, axioms that don't
survive the modification are retracted.  For example, suppose we
evaluate the following two commands.

@example
(defrelation parent-of ((?p1 person) (?p2 person))
  :=> (relative-of ?p1 ?p2))
(defrelation parent-of ((?p1 person) (?p2 person)))
@end example

The first definition defines @code{person} as a binary relation,
and also states a rule that ``@code{parent-of} implies @code{relative-of}''.
The second definitions erases that rule, i.e., the cumulative
effect is as if the first definition did not appear.  In contrast,
consider the following commands:

@example
(defrelation parent-of ((?p1 person) (?p2 person)))
(assert (=> (parent-of ?p1 ?p2) (relative-of ?p1 ?p2)))
(defrelation parent-of ((?p1 person) (?p2 person)))
@end example

The assertion in this latter sequence is logically equivalent to the
axiom introduced by the @code{:=>} keyword in the former sequence.
However, at the end of this sequence, the ``@code{parent-of} implies
@code{relative-of}'' rule is still in effect, since it appeared on its
own, outside of a definition.

@c ---------------------------------------------------------------------------

@node Truth Values, Modules, Relation Definitions, Conceptual Framework
@section Truth Values

A PowerLoom proposition is tagged with a truth value that has one of
five different settings---@code{true}, @code{false},
@code{default-true}, @code{default-false}, or @code{unknown}. The most
common setting is @code{true}; when we make an assertion as in
@code{(assert (Person Bill))}, the proposition @code{(Person Bill)} is
assigned the truth value @code{true}. To assign the value @code{false}
to a proposition, one asserts that it is not true, e.g., @code{(assert
(not (crook Richard)))}. The command @code{presume} is used to assign a
proposition the value @code{default-true}, as in @code{(presume
(weather-in Los-Angeles Sunny))}. Presuming a negated proposition
assigns it the value @code{default-false}.

The assignment of a truth value to a proposition via @code{assert} or
@code{presume} can upgrade the ``strength'' of a proposition, but it
cannot downgrade it. Hence, if a proposition currently has the value
@code{unknown}, then it may be assigned any of the other four values. If
the value is @code{default-true} or @code{default-false}, an assertion
that assigns the value @code{true} or @code{false} will overwrite the
existing value. However, if the truth value of a proposition is either
@code{true} or @code{false}, assigning it the value @code{default-true}
or @code{default-false} will have no effect.

If a proposition is asserted to be @code{true} and subsequently is
asserted to be @code{false} (or vice-versa), a @emph{clash} (or
contradiction) results. When a clash is detected by PowerLoom, a
@code{clash-exception} is thrown. The system's default behavior is for
the exception to be caught and ignored, with the result that an
assertion that would otherwise cause a clash never takes
effect. Applications that execute commands slightly below the top-level
(i.e., below the clash exception catcher) can catch the exception
themselves and perform a specialized response. PowerLoom's
proof-by-contradiction specialist catches clashes to determine that a
contradiction has occurred.

If a user or application wants to assign a proposition a truth value
that isn't stronger than the current value, it must first @code{retract}
the current value.  The PowerLoom @code{retract} operator has the effect
of undoing a prior assertion.  For example, if we assert that Mary is a
parent of Fred, and then retract that assertion, the value of the
proposition @code{(parent-of Mary Fred)} becomes @code{unknown}.  The
proposition can then be assigned any other truth value.

We should note that executing a retraction does not necessarily cause a
proposition to cease being true.  Consider the following sequence:

@example
(defconcept Person)
(defconcept Employee (?e)
  :=> (Person ?e))
(assert (Person Mary))
(assert (Employee Mary))
(retract (Person Mary))
@end example

If we now ask PowerLoom whether or not Mary is a person, the answer
will be yes (TRUE) because Mary is asserted to be an employee, and
membership in @code{employee} implies membership in @code{person}.
In other words, although the direct assertion that Mary is a person
is not present in the knowledge base, a logical proof exists that
the proposition ``Mary is a person'' is true.

@ignore
Possible additional topics:

QUANTIFIERS

RULES

INFERENCE
@end ignore

@c ---------------------------------------------------------------------------

@node Modules,  , Truth Values, Conceptual Framework
@section Modules

The knowledge loaded into an executing PowerLoom system is
divided into logical partitions called ``modules''.  The modules
are arranged into a hierarchy; knowledge inherits down the
hierarchy from parents to children.  A convenient way to organize
knowledge is to put definitional knowledge higher up in the
module hierarchy, and factual knowledge lower down.  For example,
suppose we want to build a knowledge base that defines a business
domain, and include a substantial number of facts about individual
companies. We might use one or a few modules to define terminology that
relates to the business domain, and then places the set of facts
about each company in its own module.  If we were querying the
knowledge base about one or a few companies, it would not be
necessary to load the modules for the remaining companies into the
system.

Facts asserted within a module are not visible in sibling modules, or in
ancestor modules. Thus, if we enter into PowerLoom an assertion
that``Georgia is a state'', we are not asserting that Georgia is a state
in all possible worlds, but that, from the vantage point of the current
module and those modules below, it is the case that Georgia is a state. If
we want the fact that Georgia is a state to be recognized as true in
many or most other modules, then we should make our assertion in a module
that is relatively high up in the hierarchy, so that is visible to
(inherited by) the other modules.

The inheritance of facts is @emph{not monotonic}---a child module can
retract or override facts inherited from its ancestors. For example,
suppose we have two modules, called @code{above} and @code{below} such
that the @code{below} module is below (inherits from) the @code{above}
module. Next, suppose we make an assertion within the @code{above}
module that ``Joel is a duck'', and then we shift to the @code{below}
module and retract the proposition that ``Joel is a duck''. From the
vantage point of the @code{below} module, if we now ask if Joel is a
duck, we will get back the value @code{unknown}.  However, if we switch
to the @code{above} module and ask the same question, we get back the
answer @code{true} This occurs because the effect of the retraction
operation that was applied to the @code{below} module is not ``visible''
to modules above it (or to any sibling modules). Hence, when module
hierarchies are involved, it is oversimplifying to state that a
retraction has the effect of erasing a prior assertion.

The PowerLoom execution process maintains a pointer to the current module, and
all asserions, queries, etc. are made relative to that module.  Hence, when we
talk about ``switching'' from one module to another, we are speaking
literally---a @code{change-module} command (or one of its equivalents) is
invoked to switch from one module to another.   @footnote{Many of
the Powerloom API procedures take a module argument that causes a temporary
switch to a different module within the scope of that procedure.} 

PowerLoom comes with some modules already built-in. The module named
@code{PL-KERNEL} contains a set of general-purpose concept and relation
definitions that collectively form the foundation for constructing
application-specific knowledge bases. PowerLoom attaches specialized
reasoners to many of the relations in @code{PL-KERNEL}. The command
interpreter starts up in a module named @code{PL-USER}. That module is
initially empty, and is intended as a convenient place to experiment with
PowerLoom.

@c ===========================================================================

@node Annotated Example, Communicating with PowerLoom, Conceptual Framework, Top
@chapter Annotated Example

The section presents a small example of a PowerLoom knowledge
base.  It introduces the fundamental PowerLoom modelling
concepts and illustrates the syntax of basic PowerLoom
declarations, assertions, and commands.  This section can be 
read stand-alone, but readers who intend to use PowerLoom to
create their own models are encouraged to load the demo file
@strong{???}, and run the examples ``live''.

The conceptual terms introduced in this section include modules,
concepts, relations, functions, instances, propositions, assertions, 
queries, retraction, positive and negative facts, clipping, rules,
and contexts.

@c ---------------------------------------------------------------------------

@menu
* Using Modules::               
* Concepts::                    
* Relations::                   
* Relation Hierarchies::        
* Functions::                   
* Defined Concepts::            
* Negation and Open and Closed World Semantics::  
* Retraction::                  
* Clipping of Values::          
* Rule-based Inference::        
* Explanation::                 
* Contexts and Modules::        
* Equality Reasoning::          
* Classification::              
* Truth Maintenance::           
* Inference Control::           
* Keyword Axioms::              
* Cardinality/Type Reasoning with Frame Predicates::  
* Loom-to-PowerLoom::           
* Deviations from KIF::         
* Differences from Loom::       
* Defaults::                    
* Sets::                        
@end menu

@node Using Modules, Concepts, Annotated Example, Annotated Example
@section Using Modules

We begin by creating a PowerLoom ``module'', which is a logical
container that holds the term definitions, rules, facts, etc.
that make up all or a portion of a domain model.  We will call
our module @code{business}.  The @code{defmodule} command defines a new
module.  The @code{:includes} option within the @code{defmodule} tells
PowerLoom that the @code{business} module inherits all definitions
and assertions present in the @code{PL-USER} module, or in ancestor
modules inherited by the @code{PL-USER} module.  In particular, by
inheriting @code{PL-USER}, we indirectly inherit the @code{PL-KERNEL}
module that contains all of the built-in concepts and relations.
The @code{in-module} command tells the PowerLoom system
to make @code{BUSINESS} the current module.  Until the current module
is changed again, all new introductions of terms and facts will
be placed in the @code{business} module.

@example
(defmodule "BUSINESS"
  :includes ("PL-USER"))
(in-module "BUSINESS")
@end example

The basic building blocks of a model are its concepts, relations, and
instances.@footnote{ PowerLoom modules are case-insensitive by default.
This means, for example, that a logical constant named "Foo" may be
referenced by any of the symbols 'FOO', 'foo', 'foO' etc.} A concept
defines classes/categories of entities that populate the domain model. A
relation defines attributes and relationships that allow the declaration of
facts about an entity. Instances are members of concepts. They appear as
arguments to propositional assertions.

@c ---------------------------------------------------------------------------

@node Concepts, Relations, Using Modules, Annotated Example
@section Concepts

Concepts are defined using the @code{defconcept} command.  Here
we define the concepts @code{company} and @code{corporation}:

@example
(defconcept company)
(defconcept corporation (?c company))
@end example

The first definition tells the system that @code{company} is a concept
(in the @code{business} module).  The second definition defines a
concept @code{corporation}.  The type declaration @code{(?c company)}
indicates that @code{corporation} is a subconcept of @code{company}, i.e.,
all instances of @code{corporation} are also instances of @code{company}.
Let us now create a couple of companies:

@example
(assert (company ACME-cleaners))
(assert (corporation megasoft))
@end example

These two assertions create two new entities denoted by the
terms @code{ACME-cleaners} and @code{megasoft}.  Both of these entities
are members of the concept @code{company}.  @code{megasoft} is also a member
of the concept @code{corporation}.  We can test this by executing some
PowerLoom queries:

@example
(retrieve all ?x (company ?x))
@result{}
There are 2 solutions:
  #1: ?X=ACME-CLEANERS
  #2: ?X=MEGASOFT

(retrieve all ?x (corporation ?x))
@result{}
There is 1 solution:
  #1: ?X=MEGASOFT
@end example

@c ---------------------------------------------------------------------------

@node Relations, Relation Hierarchies, Concepts, Annotated Example
@section Relations

So far, our two companies aren't very interesting. In order to say more
about them, we can define some relations and functions using the
declarations @code{defrelation} and @code{deffunction}:

@example
(defrelation company-name ((?c company) (?name STRING)))
@end example

This declaration defines a binary relation @code{company-name}.
The first value in a @code{company-name} tuple must be an instance
of type @code{company}, while the second value must be a string.
We can now give our companies names, using the command @code{assert}:

@example
(assert (company-name ACME-cleaners "ACME Cleaners, LTD"))
(assert (company-name megasoft "MegaSoft, Inc."))
@end example

We can retrieve pairs of companies and their names with the following
query (note that we omitted the optional retrieval variables in which
case they are determined by collecting the free variables in the query
expression): 

@example
(retrieve all (company-name ?x ?y))
@result{}
There are 2 solutions:
  #1: ?X=MEGASOFT, ?Y="MegaSoft, Inc."
  #2: ?X=ACME-CLEANERS, ?Y="ACME Cleaners, LTD"
@end example

Using retrieval variables is useful if we want to order the result
columns in a certain way, for example:

@example
(retrieve all (?y ?x) (company-name ?x ?y))
@result{}
There are 2 solutions:
  #1: ?Y="MegaSoft, Inc.", ?X=MEGASOFT
  #2: ?Y="ACME Cleaners, LTD", ?X=ACME-CLEANERS
@end example

@c ---------------------------------------------------------------------------

@node Relation Hierarchies, Functions, Relations, Annotated Example
@section Relation Hierarchies

PowerLoom permits the specification of hierarchies both for concepts and
relations.  Previously , we defined a small concept hierarchy with
@code{company} on top and @code{corporation} below it.  We now define a
subrelation of the relation @code{company-name} called
@code{fictitious-business-name}:

@example
(defrelation fictitious-business-name ((?c company) (?name STRING))
  :=> (company-name ?c ?name))
@end example

PowerLoom defines a subconcept/subrelation relationship between
a pair of concepts or a pair of relations by asserting an ``implication''
relation between them.
The above implication expands into the assertion
``for all values of ?c and ?name, if the @code{fictitious-business-name}
relation holds for ?c and?name, then the @code{company-name} relation
also holds for ?c and ?name''.  This is equivalent to the assertion

@example
(forall (?c ?name) (=> (fictitious-business-name ?c ?name)
                       (company-name ?c ?name)))
@end example

@noindent Since implication relationships occur very
commonly, PowerLoom provides several syntactic shortcuts for defining
them.  We have seen one such shortcut earlier; our
definition of @code{corporation} included the clause ``@code{(c ?company)}'',
which specified that @code{corporation} is a subconcept of @code{company}.
In our definition of @code{fictitious-business-name}, the keyword 
@code{:=>} introduces a similar shortcut, which tells us that 
@code{fictitious-business-name} is a subrelation of @code{company-name}.
Let us assert a fictious business name for MegaSoft:

@example
(assert (fictitious-business-name megasoft "MegaSoft"))
@end example

If we query for the company names of MegaSoft, we get two names,
one of them asserted directly, and one of them infered by the
subrelation rule:

@example
(retrieve all (company-name megasoft ?x))
@result{}
There are 2 solutions:
  #1: ?X="MegaSoft, Inc."
  #2: ?X="MegaSoft"
@end example

@c ---------------------------------------------------------------------------

@node Functions, Defined Concepts, Relation Hierarchies, Annotated Example
@section Functions

This illustrates another point: A PowerLoom relation is by default
``multi-valued'', which in the case of a binary relation means that a
single first value can be mapped by the relation to more than one second
value. In the present case, our model permits a @code{company} entity to
have more than one @code{company-name}. If a (binary) relation always maps
its first argument to exactly one value (i.e., if it it ``single-valued'')
we can specify it as a @code{function} instead of a @code{relation}.  For
example, we can use a function to indicate the number of employees for a 
company:

@example
(deffunction number-of-employees ((?c company)) :-> (?n INTEGER))
@end example

When defining a function, all arguments but the last appear just as they
do for a relation. The last argument (and its type) appears by itself
following the keyword @code{:->}. Defining a single-valued relation as a
function allows us to refer to it using a functional syntax within a
logical sentence, as in the following:

@example
(assert (= (number-of-employees ACME-cleaners) 8))
(assert (= (number-of-employees megasoft) 10000))
@end example

The functional syntax often results in shorter expressions than
equivalents that use relational syntax.  For example to retrieve all
companies with fewer than 50 employees, we can simply write:

@example
(retrieve all (and (company ?x) (< (number-of-employees ?x) 50)))
@result{}
There is 1 solution:
  #1: ?X=ACME-CLEANERS
@end example

Using the syntax for relations, the same query would require the
introduction of an existential quantifier, as in:

@example
(retrieve all (and (company ?x) 
                   (exists ?n
                     (and (number-of-employees ?x ?n)
                          (< ?n 50)))))
@result{}
There is 1 solution:
  #1: ?X=ACME-CLEANERS
@end example

To repeat ourselves slightly, Powerloom allows users the choice of using
either relational or functional syntax when using a function in predicate
position. For example, if @code{f} is a function, then the expressions
@code{(f ?x ?y)} and @code{(= (f ?x) ?y)}  are equivalent.

@c ---------------------------------------------------------------------------

@node Defined Concepts, Negation and Open and Closed World Semantics, Functions, Annotated Example
@section Defined Concepts

If we find ourselves writing the same query (or subexpression) repeatedly,
we may wish to define a name for the concept embodying that expression.
For example, below we define the term @code{small-company} to represent
the class of all companies with fewer than 50 employees:

@example
(defconcept small-company ((?c company))
  :<=> (and (Company ?c)
            (< (number-of-employees ?c) 50)))
@end example

Notice that we have used a new keyword, @code{:<=>}. This keyword defines a
bidirectional implication called ``if-and-only-if''.  Formally it is
equivalent to the following pair of assertions:

@example
(assert (forall ?c (=> (and (Company ?c)
                            (< (number-of-employees ?c) 50))
                       (small-company ?c))))
(assert (forall ?c (=> (small-company ?c)
                       (and (Company ?c)
                            (< (number-of-employees ?c) 50)))))
@end example

In other words, the @code{:<=>} keyword is a shortcut for an assertion that
uses the @code{<=>} relation, which itself is a shortcut representing the
conjunction of two single arrow implications. For example, @code{(<=> P Q)}
is equivalent to @code{(and (<= P Q) (=> P Q))}, where the @code{<=}
relation is defined to be the inverse of the relation @code{=>}.

Its not necessary that we exactly specify the number of employees in a
company.  Below, all we know about ZZ Productions is that they have
fewer than 20 employees:

@example
(assert (and (company zz-productions)
             (< (number-of-employees zz-productions) 20)))
@end example

@noindent These facts are sufficient to classify ZZ Productions as a small
business:

@example
(retrieve all (small-company ?x))
@result{}
There are 2 solutions:
  #1: ?X=ZZ-PRODUCTIONS
  #2: ?X=ACME-CLEANERS
@end example

@c ---------------------------------------------------------------------------

@node Negation and Open and Closed World Semantics, Retraction, Defined Concepts, Annotated Example
@section Negation and Open and Closed World Semantics

PowerLoom implements a three-valued logic---the truth value of each
proposition entered into a PowerLoom knowledge base is recorded as being
either true, false, or unknown.@footnote{Actually, PowerLoom implements
a @emph{five-valued} logic --- the remaining two values are ``default
true'' and ``default false''. However, the present discussion defers the
subject of default truth values.} Many other systems (e.g., relational
DBMSs) implement a two-valued logic, wherein if a fact is not asserted
to be true, it is assumed to be false.  The PowerLoom command @code{ask}
returns one of three (five) values: @code{true} if it can prove the
truth of a proposition, @code{false} if it can @emph{easily} prove the
falsity of a proposition@footnote{Because proving negations can be very
difficult, PowerLoom will only conduct a very quick and shallow search
for a disproof.  More extensive reasoning is used if a negation is asked
about explicitly, thus it may be the case that PowerLoom will return
@code{unknown} if asked about @code{P}, but true if asked about
@code{(not P)}.} and otherwise it returns @code{unknown}. (The values
@code{default-true} and @code{default-false} are also possible if
defaults are used).

Below, PowerLoom knows nothing about a newly-introduced concept
@code{s-corporation}, so @code{ask} returns @code{unknown} to both a
positive query and its negation:

@example
(defconcept s-corporation (?c corporation))
(ask (s-corporation zz-productions))
@result{}
UNKNOWN
(ask (not (s-corporation zz-productions)))
@result{}
UNKNOWN
@end example

If we assert that ZZ Productions is not an S-corporation, then
PowerLoom knows that the proposition in question is false:

@example
(assert (not (s-corporation zz-productions)))
(ask (s-corporation zz-productions))
@result{}
FALSE
(ask (not (s-corporation zz-productions)))
@result{}
TRUE
@end example


@noindent After asserting that ZZ Productions is not an S-corporation,
a repeat of the query asking if it @emph{is} one will now return @code{false},
because the explicit assertion of the negation allows a quick disproof of
the positive query.

@noindent @strong{Note}: PowerLoom uses all its effort to prove that the
proposition in question is true, and only uses some effort to prove that
it is false.  Therefore, only falsities that are discovered "on the way"
or with shallow inference strategies will be found (which was the case
above).  If you want to check whether a proposition is false with
maximum effort, simply ask the negated proposition by wrapping an
explicit @code{not} arount it.  The reason for this asymmetry is that
checking for truth and falsity really amounts to asking two separate and
possibly expensive queries, and the user or programmer should decide
whether the effort should be expended to ask both queries instead of
just one.

PowerLoom can sometimes infer a negative fact without
the necessity of a direct assertion.  For example:

@example
(ask (= (number-of-employees ACME-cleaners) 8))
@result{}
TRUE
(ask (= (number-of-employees ACME-cleaners) 10))
@result{}
FALSE
(ask (not (= (number-of-employees ACME-cleaners) 10)))
@result{}
TRUE
@end example

PowerLoom can infer the second and third answers because it knows that
the function @code{number-of-employees} can return only one value, and
if that value is the number eight, it cannot also be something else (in
this case, ten).

Many systems, in particular, database systems and Prolog, make the
assumptions that if a proposition cannot be proved true, then it must be
false. This is called the ``closed world assumption''. By default,
PowerLoom makes an open-world assumption, but for specific relations it can
be instructed to assume a closed world if a user wants closed world
semantics. For example, suppose we introduce a relation @code{works-for},
and we assume that all @code{works-for} facts have been entered in our
knowledge base:

@example
(defrelation works-for (?p (?c Company)))
(assert (works-for shirly ACME-cleaners))
(assert (works-for jerome zz-productions))
@end example

If we ask PowerLoom whether Jerome does NOT work for MegaSoft, it will
return @code{unknown}.  But if we assert that the relation
@code{works-for} is @code{closed}, then PowerLoom will assume that
Jerome only works for ZZ Productions:

@example
(ask (not (works-for jerome megasoft)))
@result{}
UNKNOWN

(assert (closed works-for))
(ask (not (works-for jerome megasoft)))
@result{}
TRUE
@end example

The reasoning employed to achieve the above result (that Jerome does not
work for MegaSoft) is called ``negation as failure'', which means that
if a proof of a proposition fails, then one may assume that the
proposition is false. We can achieve a negation-as-failure result a
second way (i.e., other than by using a closed world assumption) by
employing the query operator @code{fail}.  Here we retract the closure
assumption for @code{works-for} and achieve the desired result using
@code{fail}:

@example
(retract (closed works-for))
(ask (not (works-for jerome megasoft)))
@result{}
UNKNOWN

(ask (fail (works-for jerome megasoft)))
@result{}
TRUE
@end example

When you see the operator ``not'' in an SQL query or a Prolog program,
it really stands for ``fail''.

@c ---------------------------------------------------------------------------

@node Retraction, Clipping of Values, Negation and Open and Closed World Semantics, Annotated Example
@section Retraction

Below, we introduce a few new terms for defining geographic information.
We define a relation called @code{contains} to assert that one geographic
location (the second argument to @code{contains}) is located within another:

@example
(defconcept geographic-location)
(defconcept country (?l geographic-location))
(defconcept state (?l geographic-location))
(defconcept city (?l geographic-location))
(defrelation contains ((?l1 geographic-location)
                       (?l2 geographic-location)))
@end example

Now, we can assert some facts about U.S. geography (including one
deliberate mistake):

@example
(assert (and 
         (country united-states)
         (geographic-location eastern-us) 
         (contains united-states eastern-us)
         (state georgia) (contains eastern-us georgia)
         (city atlanta) (contains georgia atlanta)
         (geographic-location southern-us) 
         (contains united-states southern-us)
         (state texas) (contains eastern-us texas)
         (city dallas) (contains texas dallas)
         (city austin) (contains texas austin)))
@end example

We would like to repair the incorrect assertion @code{(contains eastern-us texas)}.
The PowerLoom command @code{retract} allows us to erase assertions that
should not be true:

@example
(ask (contains eastern-us texas))
@result{}
TRUE

(retract (contains eastern-us texas))
(assert (contains southern-us texas))

(ask (contains eastern-us texas))
@result{}
UNKNOWN
@end example

Retraction should not be confused with assertion of negative propositions.
For example, asserting that Texas is not a state would not retract
the assertion that it is (a state).  Instead, an evident logical contradiction
is detected as a ``clash'', and the clashing proposition is disallowed:

@example
(assert (not (state texas)))
@result{}
Derived both TRUE and FALSE for the proposition `|P|(STATE TEXAS)'.
   Clash occurred in module ``|MDL|/PL-KERNEL-KB/business'.

(ask (not (state texas)))
@result{}
UNKNOWN
@end example

@c ---------------------------------------------------------------------------

@node Clipping of Values, Rule-based Inference, Retraction, Annotated Example
@section Clipping of Values

Programmers are accustomed to changing the values of attributes for
program objects just by overwriting previous values.  PowerLoom implements a
similar semantics for the special case of functions and single-valued
relations.  When a second value is asserted for one of these relations
the previous value is automatically retracted.  We call this @emph{clipping}.

To illustrate this behavior for both kinds of relations (a function is
considered a kind of relation), we will define a mapping from a company to
a city that contains its headquarters in two different ways:

@example
(deffunction headquarters ((?c company)) :-> (?city city))
(defrelation headquartered-in ((?c company) (?city city))
  :axioms (single-valued headquartered-in))
@end example

The clause "@code{:axioms (single-valued headquartered-in)}" tells
PowerLoom that the @code{headquartered-in} relation is single-valued,
i.e., that it can map a company to at most one city.  This makes its
behavior similar to that of the function @code{headquarters}.  Here is
an example of clipping for the function @code{headquarters}:

@example
(assert (= (headquarters zz-productions) atlanta))
(retrieve all (= ?x (headquarters zz-productions)))
@result{}
There is 1 solution:
  #1: ?X=ATLANTA

(assert (= (headquarters zz-productions) dallas))
(retrieve all (= ?x (headquarters zz-productions)))
@result{}
There is 1 solution:
  #1: ?X=DALLAS
@end example
 
Here is the same kind of clipping using a single-valued relation:

@example
(assert (headquartered-in megasoft atlanta))
(retrieve all (headquartered-in megasoft ?x))
@result{}
There is 1 solution:
  #1: ?X=ATLANTA

(assert (headquartered-in megasoft dallas))
(retrieve all (headquartered-in megasoft ?x))
@result{}
There is 1 solution:
  #1: ?X=DALLAS
@end example

@c ---------------------------------------------------------------------------

@node Rule-based Inference, Explanation, Clipping of Values, Annotated Example
@section Rule-based Inference

Suppose that we want to retrieve all geographic locations that are
contained in the Southern US, based on the set of assertions about
geography that we entered in earlier. The following query returns only
one of such location:

@example
(retrieve all (contains southern-us ?x))
@result{}
There is 1 solution:
  #1: ?X=TEXAS
@end example

We would like the cities Austin and Dallas to be retrieved as well.
To do this, we can assert a @code{rule} that states that @code{contains}
is a transitive relation:

@example
(defrule transitive-contains
  (=> (and (contains ?l1 ?l2)
           (contains ?l2 ?l3))
      (contains ?l1 ?l3)))
@end example

The @code{defrule} declaration does two things---it asserts a
proposition, and it associates a name with that proposition (in the
above case, the name is @code{transitive-contains}). This name is used by
the system in displaying traces of its inferencing. It also makes
redefinition of the proposition easier. If we wish to retract an unnamed
proposition, it is necessary to explicitly retract that proposition
using a syntax identical to the assertion@footnote{Actually, PowerLoom
isn't quite as strict as just stated--its search for an identical
proposition can accomodate changes in the names of variables.} If on the
other hand, a proposition has a name, then a new @code{defrule}
declaration that uses the same name will automatically retract any
existing proposition having the same name.

Our transitive closure rule failed to include any logical quantifiers
for the variables @code{?l1}, @code{?l2}, and @code{?l3}.  When PowerLoom
parses a top-level proposition, it automatically supplies universal
quantifiers for any unquantified variables.  So, the above rule is
equivalent to the rule:

@example
(defrule transitive-contains
  (forall (?l1 ?l2 ?l3)
    (=> (and (contains ?l1 ?l2)
             (contains ?l2 ?l3))
        (contains ?l1 ?l3))))
@end example

@noindent Note: Instead of defining a @code{transitive-contains} rule,
we could have achieved the same effect by asserting that the @code{contains}
relation is transitive, e.g., by stating @code{(assert (transitive contains))}.

Now that we have told the system that our @code{contains} relation is
transitive, let us rerun our query:

@example
(retrieve all (contains southern-us ?x))
@result{}
There are 3 solutions:
  #1: ?X=TEXAS
  #2: ?X=AUSTIN
  #3: ?X=DALLAS
@end example

@c ---------------------------------------------------------------------------

@node Explanation, Contexts and Modules, Rule-based Inference, Annotated Example
@section Explanation

PowerLoom provides a command called @code{why} that you can use to
get an explanation of the logic behind one of its answers.  The
@code{why} command explains the last query entered into the system,
i.e., it should invoked after one has submitted a @code{retrieve} or
an @code{ask} command.  Before asking a @code{why} command, you must
enable the justifications feature:

@example
(set-feature justifications)
@end example

Queries execute a bit more slowly with jusifications enabled, which is why it is
disabled by default. Having enabled justifications, we must (re)run a query.
Here is how we can ask why Dallas is contained in the Southern US:

@example
(ask (contains southern-us dallas))
@result{}
TRUE
(why)
@result{}
1 (CONTAINS SOUTHERN-US DALLAS)
    follows by Modus Ponens
    and substitution @{?l3/DALLAS, ?l2/TEXAS, ?l1/SOUTHERN-US@}
    since 1.1 ! (forall (?l1 ?l3)
                   (<= (CONTAINS ?l1 ?l3)
                       (exists (?l2)
                          (and (CONTAINS ?l1 ?l2)
                               (CONTAINS ?l2 ?l3)))))
    and   1.2 ! (CONTAINS SOUTHERN-US TEXAS)
    and   1.3 ! (CONTAINS TEXAS DALLAS)
@end example

The above explanation tells us that a rule (our transitivity rule)
was invoked during the proof, and that two ground assertions
@code{(CONTAINS SOUTHERN-US TEXAS)} and @code{(CONTAINS TEXAS DALLAS)} 
were accessed to supply preconditions for the rule.  These combined
assertions lead to the conclusion @code{(CONTAINS SOUTHERN-US DALLAS)}.
Within an explanation, directly asserted propositions are indicated with
the prefix `!'.

We can also ask @code{why} after a @code{retrieve} query. However, if the
query has multiple solutions, each one has a separate explanation. In order
to ask @code{why}, we need to ask for one solution at a time. This can be
done by omitting the word @code{all} from the @code{retrieve} query, and
subsequently calling @code{(retrieve)} to obtain results one-at-a-time.
@footnote {Note: The order of solutions will not necessarily be the same as
shown here.}

@example
(retrieve (contains southern-us ?x))
@result{}
  #1: ?X=DALLAS
(retrieve)
@result{}
There are 2 solutions so far:
  #1: ?X=DALLAS
  #2: ?X=TEXAS
(retrieve)
@result{}
There are 3 solutions so far:
  #1: ?X=DALLAS
  #2: ?X=TEXAS
  #3: ?X=AUSTIN
(why)
@result{}
1 (CONTAINS SOUTHERN-US AUSTIN)
    follows by Modus Ponens
    with substitution @{?l1/SOUTHERN-US, ?l3/AUSTIN, ?l2/TEXAS@}
    since 1.1 ! (FORALL (?l1 ?l3)
                   (<= (CONTAINS ?l1 ?l3)
                       (EXISTS (?l2)
                          (AND (CONTAINS ?l1 ?l2)
                               (CONTAINS ?l2 ?l3)))))
    and   1.2 ! (CONTAINS SOUTHERN-US TEXAS)
    and   1.3 ! (CONTAINS TEXAS AUSTIN)
@end example


@c This illegal query breaks with justifications turned on:
@c (retrieve all ?name (company-name ?company ?name))

The following query combines a variety of relations that have been
entered into the business modules.  It retrieves names of companies
whose headquarters are in the southern US.  Note that query variables
that do not appear in the output (i.e., variables not listed after the
@code{all}

@example
(retrieve ?name (exists (?city ?company)
                  (and (contains southern-us ?city)
                       (headquartered-in ?company ?city)
                       (company-name ?company ?name))))
@result{}
There is 1 solution so far:
  #1: ?NAME="MegaSoft, Inc."

(why)
@result{}
1 (and (COMPANY-NAME MEGASOFT MegaSoft, Inc.)
       (HEADQUARTERED-IN MEGASOFT DALLAS)
       (CONTAINS SOUTHERN-US DALLAS))
    follows by And-Introduction
    since 1.1 ! (COMPANY-NAME MEGASOFT MegaSoft, Inc.)
    and   1.2 ! (HEADQUARTERED-IN MEGASOFT DALLAS)
    and   1.3   (CONTAINS SOUTHERN-US DALLAS)

1.3 (CONTAINS SOUTHERN-US DALLAS)
    follows by Modus Ponens
    and substitution @{?l3/DALLAS, ?l2/TEXAS, ?l1/SOUTHERN-US@}
    since 1.3.1 ! (forall (?l1 ?l3)
                     (<= (CONTAINS ?l1 ?l3)
                         (exists (?l2)
                            (and (CONTAINS ?l1 ?l2)
                                 (CONTAINS ?l2 ?l3)))))
    and   1.3.2 ! (CONTAINS SOUTHERN-US TEXAS)
    and   1.3.3 ! (CONTAINS TEXAS DALLAS)
@end example

@c ---------------------------------------------------------------------------

@node Contexts and Modules, Equality Reasoning, Explanation, Annotated Example
@section Contexts and Modules

The final feature that we will illustrate in this section is the
PowerLoom context mechanism.  PowerLoom organizes its knowledge into a
hierarchy of logical containers called ``contexts''.  A PowerLoom
context is either a ``module'', a somewhat heavyweight object that
includes its own symbol table, or a ``world'', a very lightweight object
designed for fast switching from one world to another.  All contexts
inherit from a single root context.  The most important feature of a
context is that a fact asserted into it is inherited by all contexts
below it.  However, a ``parent'' context is unaware of any knowledge
entered into one of its descendants.

Here we concern ourselves only with modules.  We first define a second
module, called @code{alternate-business}, to be a subcontext of
our @code{business} module, and then we switch into the new module:

@example
(defmodule "ALTERNATE-BUSINESS"
  :includes "BUSINESS")
(in-module "ALTERNATE-BUSINESS")
@end example

Next, within the scope of the @code{alternate-business} module, we will
create a new company.  And just for good measure,
we will change the name of MegaSoft while we are at it:

@example
(assert (and (company web-phantoms)
             (company-name web-phantoms "Web Phantoms, Inc.")))
(retract (company-name megasoft "MegaSoft, Inc."))
(assert (company-name megasoft "MegaZorch, Inc."))
@end example

First, here are pairs of companies and company names from the vantage
point of the @code{Business} module:

@example
(in-module "BUSINESS")
(retrieve all (company-name ?x ?y))
@result{}
There are 3 solutions:
  #1: ?X=ACME-CLEANERS, ?Y="ACME Cleaners, LTD"
  #2: ?X=MEGASOFT, ?Y="MegaSoft, Inc."
  #3: ?X=MEGASOFT, ?Y="MegaSoft"
@end example

Now observe the same query executed from within the alternate @code{Business}
module:

@example
(in-module "ALTERNATE-BUSINESS")
(retrieve all (company-name ?x ?y))
@result{}
There are 4 solutions:
  #1: ?X=ACME-CLEANERS, ?Y="ACME Cleaners, LTD"
  #2: ?X=MEGASOFT, ?Y="MegaZorch, Inc."
  #3: ?X=WEB-PHANTOMS, ?Y="Web Phantoms, Inc."
  #4: ?X=MEGASOFT, ?Y="MegaSoft"
@end example

We see that all facts pertaining to company names have inherited down
from the Business to the Alternate Business module, except for the
name for MegaSoft that we explicitly retracted.  Also, the new
facts asserted within the Alternate Business module appear mixed in
with the inherited facts.

@ignore
<ADD AN ELABORATION OF THE NON-MONOTOMIC MODULE INHERITANCE
EXAMPLE OF SECTION 2.3 HERE>
@end ignore

@c ---------------------------------------------------------------------------

@node Equality Reasoning, Classification, Contexts and Modules, Annotated Example
@section Equality Reasoning

PowerLoom makes the @emph{unique names assumption}, so every two
different named logic constants are assumed to be different.  For
example:

@example
(assert (= Fred Joe))
@result{}
Derived both TRUE and FALSE for the proposition `|P#|FALSE'.
   Clash occurred in module `|MDL|/PL-KERNEL-KB/PL-USER'.

(assert (= Fred Fred))
@result{}
|P|TRUE
@end example

However, one can assert equality between skolems that represent function
terms as well as between a function term skolem and a regular constant.
For example:

@example
(deffunction age (?x ?y))
(assert (= (age Fred) (age Joe)))
(assert (= (age Fred) 10))

(retrieve (age Joe ?x))
@result{}
There is 1 solution so far:
  #1: ?X=10
@end example

So, if one needs to model named individuals where equality might be
asserted (e.g., to model a person with an alias) one has to resort
to using function terms.  For example:

@example
(deffunction individual (?name ?i))
(assert (= (age (individual A)) 12))
(assert (= (individual A) (individual B)))

(retrieve (age (individual B) ?a))
@result{}
There is 1 solution so far:
  #1: ?A=12
@end example

@c ---------------------------------------------------------------------------

@node Classification, Truth Maintenance, Equality Reasoning, Annotated Example
@section Classification, Subsumption

@c ---------------------------------------------------------------------------

@node Truth Maintenance, Inference Control, Classification, Annotated Example
@section Truth Maintenance

@c ---------------------------------------------------------------------------

@node Inference Control, Keyword Axioms, Truth Maintenance, Annotated Example
@section Inference Control

@c ---------------------------------------------------------------------------

@node Keyword Axioms, Cardinality/Type Reasoning with Frame Predicates, Inference Control, Annotated Example
@section Keyword Axioms

@c ---------------------------------------------------------------------------

@node Cardinality/Type Reasoning with Frame Predicates, Loom-to-PowerLoom, Keyword Axioms, Annotated Example
@section Cardinality/Type Reasoning with Frame Predicates

@c ---------------------------------------------------------------------------

@node Loom-to-PowerLoom, Deviations from KIF, Cardinality/Type Reasoning with Frame Predicates, Annotated Example
@section Loom-to-PowerLoom

@c ---------------------------------------------------------------------------

@node Deviations from KIF, Differences from Loom, Loom-to-PowerLoom, Annotated Example
@section Deviations from KIF

@c ---------------------------------------------------------------------------

@node Differences from Loom, Defaults, Deviations from KIF, Annotated Example
@section Differences from Loom

@c ---------------------------------------------------------------------------

@node Defaults, Sets, Differences from Loom, Annotated Example
@section Defaults

@c ---------------------------------------------------------------------------

@node Sets,  , Defaults, Annotated Example
@section Sets, Lists, SETOFALL, KAPPA

@c ===========================================================================

@node Communicating with PowerLoom, Commands, Annotated Example, Top
@chapter Communicating with PowerLoom

There are basically three modes that users can choose from
for interacting with the PowerLoom system.  The simplest is 
to use the PowerLoom command interpreter.  The interpreter
supports a type-in window that allows line-at-a-time entry
of commands.  You can use the interpreter to load files
of PowerLoom declarations, to create and edit knowledge base objects,
to ask queries, and to modify settings in the execution environment.

The second mode of interaction involves writing an application that makes
calls to the PowerLoom API (@pxref{PowerLoom API}). PowerLoom implements an
extensive list of procedures that can be called to control the logic
system. These procedures range from very specific procedures to assert or
query a single fact, to general procedures that interpret arbitrary
queries. The STELLA translator offers users a choice of Common Lisp, Java,
or C++ -based versions of the PowerLoom system; users can choose whichever
is the best match for their language of choice for their applications.

Finally, the Ontosaurus Web Browser offers an ideal way
to view the contents of PowerLoom knowledge bases.  The
Ontosaurus Web server allows one to surf across a knowledge
base, offering several different kinds of views of the
knowledge.

@c ---------------------------------------------------------------------------

@menu
* Command Interpreter ::        
* Persistent Knowledge Bases::  
@end menu

@node Command Interpreter , Persistent Knowledge Bases, Communicating with PowerLoom, Communicating with PowerLoom
@section Command Interpreter 

Currently, the primary means for interacting with PowerLoom is its
command interpreter.  The command interpreter can be used either
interactively, or it can be invoked directly from a program to evaluate
individual commands.  All PowerLoom
commands (@pxref{Commands}) can be evaluated using the command
interpreter.

The interactive command interpreter is invoked by calling the function
@code{powerloom} without any arguments.  In the Java versions of
PowerLoom, the interpreter in called by the @code{main} routine in
the class @code{PowerLoom} within the @code{logic} package.  In the C++
versions of PowerLoom, @code{powerloom} is also called within the
@code{main} routine.  In the Lisp version, @code{(STELLA::powerloom)}
has to be called explicitly.  However, in Lisp it is not really
necessary to use the command interpreter, since all commands can also be
executed directly at the Lisp top level@footnote{If you are executing
within a case sensitive module, then you may see some differences
in behavior between commands evaluated by the command interpreter
and commands invoked from the Lisp Listener.}.

The interactive command interpreter functions as a simple
read/eval/print loop that prompts for input with a @code{|=} prompt,
reads a user command from standard input, evaluates it, and prints the
result to standard output.  To exit the command interpreter, type
@code{quit} or @code{stop}.

To evaluate commands directly from a program, the PowerLoom API provides
the following evaluator functions:

@deffn Function evaluate (@w{(command @sc{object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{object} 
Evaluate the command @var{command} within @var{module} and return
the result. Currently, only the evaluation of (possibly nested) commands and
global variables is supported.  Commands are simple to program in Common Lisp,
since they are built into the language, and relatively awkward in Java and C++.
Users of either of those languages are more likely to want to call @code{s-evaluate}.
@end deffn

@deffn Function evaluate-string (@w{(expression @sc{string})}) : @sc{object} 
Evaluate the expression represented by @var{expression} and return the result.
This is equivalent to @code{(evaluate (unstringify expression))}.
@end deffn


@c ---------------------------------------------------------------------------

@node Persistent Knowledge Bases,  , Command Interpreter , Communicating with PowerLoom
@section Persistent Knowledge Bases

Serious users of PowerLoom will want to construct 
knowledge bases that persist between sessions.
PowerLoom's primary medium of persistence is file-based;
users construct their knowledge bases by entering PowerLoom
statements into ASCII-formatted files, and then using the
@code{load} command to load them into PowerLoom.  There is also
a @code{save-module} command that saves the current assertions
of a module to a file.  Large-scale persistence via a backend 
database is currently under development and will become available
in one of the next releases.

@c ===========================================================================

@node Commands, PowerLoom API, Communicating with PowerLoom, Top
@chapter Commands

This chapter lists all available PowerLoom commands alphabetically.
Each command is documented with its name, a (possibly empty) list of
parameters specified as @code{@w{(<name> <type>)}} pairs, its return
type, and its category (@dfn{Command}).  Almost all of the commands implicitly
quote their arguments, meaning that when calling them, you don't need
to add any quotation yourself.  For example, the command
@code{all-facts-of} is defined as follows:

@quotation
@deffn Command all-facts-of (@w{(instanceRef @sc{name})}) : @sc{(cons of proposition)} 
Return a cons list of all definite (TRUE or FALSE) propositions
that reference the instance @var{instanceRef}.
@end deffn
@end quotation

The @code{all-facts-of} command has one parameter called
@var{instanceRef} of type @emph{@sc{name}}, and returns a STELLA
@emph{@sc{list}} containing zero or more objects of type
@emph{@sc{proposition}} as its result.  The type @sc{name} subsumes the
types @sc{symbol}, @sc{surrogate}, @sc{string}, and @sc{keyword}.
Unless you are in a case-sensitive module, the following four commands
are equivalent:

@example
@ @ @ @ (all-facts-of Merryweather)
@ @ @ @ (all-facts-of :MERRYWEATHER)
@ @ @ @ (all-facts-of "merryweather")
@ @ @ @ (all-facts-of @@MerryWeather)
@end example

Commands can also have @code{&rest} parameters (similar to Lisp
functions).  These are either used to allow a variable number of
arguments, or to handle optional arguments, since STELLA does not
directly support optional arguments.

Here is a list of important parameter types used in the
command specifications below:

@itemize 
@item @emph{@sc{generalized-symbol}}: A generalized symbol is either a plain
symbol (similar to a Lisp symbol) such as @code{Merryweather}, a keyword
(similar to a Lisp keyword) such as @code{:KIF}, or a STELLA surrogate
which is a symbol starting with an at-sign, e.g., @code{@@CONS}.  STELLA
surrogates are used as names for objects of arbitrary types.

@item @emph{@sc{name}}: Names can be either a string, or a
@emph{@sc{generalized-symbol}} (i.e., a symbol, a keyword, or a
surrogate).  If a symbol is supplied, only its symbol-name is used.
Commands that take names as arguments usually coerce whatever argument
is entered into a string, but by allowing a @sc{name} they make it a
little bit more convenient to type a name in an interactive
invocation.@footnote{Lisp programmers are typically spoiled, and find it
inconvenient to wrap double-quotes around their arguments.}
@item @emph{@sc{parse-tree}}: A parse tree is similar to a Lisp s-expression,
i.e., it can either be an atom such as a symbol, number, or a string, or
a list of zero or more parse trees.  For example, the expression
@code{(happy Fred)} is a parse tree, and so are its components
@code{happy} and @code{Fred}.
@end itemize

Here is the list of all available PowerLoom commands:

@ignore
<HANS COMMENT.  POTENTIALLY, THESE SHOULD BE GROUPED FUNCTIONALLY>
@end ignore

@deffn Command add-load-path (@w{(path @sc{string})}) : @sc{(cons of string-wrapper)} 
Append the directories listed in the |-separated
@var{path} to the end of the PowerLoom load path.  Return the
resulting load path.
@end deffn

@c # $(util/texinfo-insert-doc /LOGIC/ADD-TRACE)
@deffn N-Command all-facts-of (@w{(instanceRef @sc{name})}) : @sc{(cons of proposition)} 
Return a cons list of all definite (TRUE or FALSE) propositions
that reference the instance @var{instanceRef}.  This includes propositions
asserted to be true by default, but it does not include propositions
that are found to be TRUE only by running the query engine.  Facts
inferred to be TRUE by the forward chainer will be included.
Hence, the returned list of facts may be longer in a context where the
forward chainer has been run then in one where it has not (see
@code{run-forward-rules}).
@end deffn

@c # $(util/texinfo-insert-doc /LOGIC/ALL-FACTS-OF-OBJECT)
@deffn N-Command ask (@w{&rest (proposition&options @sc{parse-tree})}) : @sc{truth-value} 
Perform inference to determine whether the proposition specified in
@var{proposition&options} is true.  Return the truth-value found.  @code{ask}
will spend most of its effort to determine whether the proposition
is true and only a little effort via shallow inference strategies to
determine whether it is false.  To find out whether a proposition is
false with full inference effort @code{ask} its negation.

KIF example: @code{(ask (happy Fred))} will return TRUE if Fred was indeed
found to be happy.  Note, that for this query to run, the logic
constant @code{Fred} and the relation @code{happy} must already be defined (see
@code{assert}).  Use @code{(set/unset-feature goal-trace)} to en/disable goal
tracing of the inference engine.

The @code{ask} command supports the following options: @code{:TIMEOUT} is an
integer or floating point time limit, specified in seconds.  For
example, the command @code{(ask (nervous Fred) :timeout 2.0)} will cease
inference after two seconds if a proof has not been found by then.
If the @code{:DONT-OPTIMIZE?} is given as TRUE, it tells PowerLoom to
not optimize the order of clauses in the query before evaluating it.
This is useful for cases where a specific evaluation order of the
clauses is required (or the optimizer doesn't do the right thing).
If @code{:THREE-VALUED?} is given as TRUE, PowerLoom will try to prove
the negation of the query with full effort in case the given query
returned UNKNOWN.  By default, PowerLoom uses full effort to prove
the query as stated and only a little opportunistic effort to see
whether it is actually false.
@end deffn

@deffn N-Command assert (@w{(proposition @sc{parse-tree})}) : @sc{object} 
Assert the truth of @var{proposition}.  Return the asserted proposition object.
KIF example:  "(assert (happy Fred))" asserts that Fred is indeed happy.
Note that for this assertion to succeed, the relation @code{happy} must already
be defined.  If the constant @code{Fred} has not yet been created, it is
automatically created as a side-effect of calling @code{assert}.
@end deffn

@deffn N-Command assert-from-query (@w{(query @sc{cons})} @w{&rest (options @sc{object})}) : @sc{(cons of proposition)} 
Evaluate @var{query}, instantiate the query proposition for each generated
solution and assert the resulting propositions.  The accepted syntax
is as follows:

@example 
 (assert-from-query <query-command>
                    [:relation <relation-name>]
                    [:pattern <description-term>]
                    [:module <module-name>])
@end example

<query-command> has to be a strict or partial retrieval command. If a
:relation option is supplied, <relation-name> is used as the relation
of the resulting propositions.  In this case the bindings of each
solution will become arguments to the specified relation in the order
of @var{query}s output variables (the arities have to match).  The
:pattern option is a generalization of this mechanism that specifies
an arbitrary proposition pattern to be instantiated by the query's
solution.  In this case <description-term> has to be a SETOFALL or
KAPPA expression whose IO-variables will be bound in sequence to the
bindings of a query solution to generate the resulting proposition.
Finally, if a :module option is specified, the assertions will be
generated in that module.  Note that for this to work the relations
referenced in the query proposition or pattern have to be visible in
the module.  Also, instances will not be copied to the target module,
therefore, the resulting propositions might reference external
out-of-module objects in case they are not visible there.
Here are some examples:

@example 
 (assert-from-query (retrieve all (foo ?x ?y)))
 (assert-from-query (retrieve all (?y ?x)
                             (exists ?z
                               (and (foo ?x ?z)
                                    (foo ?z ?y))))
                    :relation bar :module other)
 (assert-from-query
   (retrieve all (and (relation ?x) (symmetric ?x)))
   :pattern (kappa (?pred)
              (forall (?x ?y)
                (=> (holds ?pred ?x ?y)
                    (holds ?pred ?y ?x))))))
@end example


@end deffn

@deffn N-Command assert-rule (@w{(ruleName @sc{name})}) : @sc{proposition} 
Set the truth value of the rule named @var{ruleName} to 
TRUE.  The proposition having the name @var{ruleName} may be
any arbitrary proposition, although we expect that it is probably
a material implication.  (See @code{retract-rule}).
@end deffn

@c # $(util/texinfo-insert-doc /LOGIC/CALL-ALL-FACTS-OF)
@c # $(util/texinfo-insert-doc /LOGIC/CALL-CLEAR-MODULE)
@deffn N-Command cc (@w{&rest (name @sc{name})}) : @sc{context} 
Change the current context to the one named @var{name}.  Return the
value of the new current context.  If no @var{name} is supplied, return
the pre-existing value of the current context.  @code{cc} is a no-op if the
context reference cannot be successfully evaluated.
@end deffn

@deffn N-Command classify-relations (@w{(module @sc{name})} @w{(local? @sc{boolean})}) : 
Classify named relations visible in @var{module}.
If @var{local?}, only classify descriptions defined within @var{module}, i.e.,
don't classify descriptions inherited from ancestor modules.
If @var{module} is NULL, classify relations in all modules.

Conceptually, the classifier operates by comparing each concept or relation
with all other concepts/relations, searching for a proof that a
subsumption relation exists between each pair. Whenever a new subsumption
relation is discovered, the classifier adds an @code{implication} link between
members of the pair, thereby augmenting the structure of the
concept or relation hierarchy. The implemented classification algorithm is
relatively efficient -- it works hard at limiting the number of concepts
or relations that need to be checked for possible subsumption
relationships.

@end deffn

@deffn N-Command classify-instances (@w{(module @sc{name})} @w{(local? @sc{boolean})}) : 
Classify instances visible in @var{module}.
If @var{local?}, only classify instances that belong to @var{module},
i.e., don't classify instances inherited from ancestor modules.
If @var{module} is NULL, classify instances in all modules.

Conceptually, the classifier operates by comparing each instance
with all concepts in the hierarchy, searching for a
proof for each pairing indicating that the instance belongs to the concept.
Whenever a new @code{is-a} relation is discovered, the classifier
adds an @code{is-a} link between the instance and the concept, thereby
recording an additional fact about the instance.  The implemented
classification algorithm is relatively efficient -- it works hard
at limiting the number of concepts or relations that need to
be checked for possible is-a relationships.

@end deffn

@deffn Command clear-caches () : 
Clear all query and memoization caches.
@end deffn

@deffn N-Command clear-instances (@w{&rest (name @sc{name})}) : 
Destroy all instances belonging to module @var{name} or any of its children.
Leave meta-objects, e.g., concepts and relations, alone.
If no @var{name} is supplied, the current module will be cleared after
confirming with the user.
@end deffn

@deffn N-Command clear-module (@w{&rest (name @sc{name})}) : 
Destroy all objects belonging to module @var{name} or any of its children.
If no @var{name} is supplied, the current module will be cleared after
confirming with the user.  Important modules such as STELLA are protected
against accidental clearing.
@end deffn

@c # $(util/texinfo-insert-doc /LOGIC/CLEAR-TRACE)
@deffn N-Command conceive (@w{(formula @sc{parse-tree})}) : @sc{object} 
Guess whether @var{formula} represents a term or a sentence/proposition.
If we are not sure, assume its a proposition.
If its, a term, return its internal representation.  If a proposition,
construct a proposition for @var{formula} without asserting its truth value.
Return the conceived proposition object.  KIF example: "(conceive (happy Fred))"
builds the proposition expressing that Fred is happy without explictly asserting
or denying it.  Note, that for this to succeed, the relation @code{happy} must already
be defined (see @code{assert}).  If the logic constant @code{Fred} has not yet been
created, it is automatically created as a side-effect of calling @code{conceive}.
@end deffn

@c # $(util/texinfo-insert-doc /LOGIC/CONCEIVE-TERM)
@deffn Command copyright () : 
Print detailed PowerLoom copyright information.
@end deffn

@c # $(util/texinfo-insert-doc /LOGIC/CREATE)
@c # $(util/texinfo-insert-doc /LOGIC/DEFCLASS)
@deffn N-Command defconcept (@w{&rest (args @sc{parse-tree})}) : @sc{named-description} 
Define (or redefine) a concept.  The accepted syntax is:

@example 
 (defconcept <conceptconst> [(<var> <parent>*)]
    [:documentation <string>]
    [:<= <sentence>] | [:=> <sentence>] |
    [:<<= <sentence>] | [:=>> <sentence>] | 
    [:<=> <sentence>] | [:<=>> <sentence>] | [:<<=> <sentence>] |
    [:<<=>> <sentence>] |
    [:axioms @{<sentence> | (<sentence>+)@}] |
    <keyword-option>*)
@end example

Declaration of a concept variable @code{<var>} is optional, unless any
implication (arrow) options are supplied that need to reference it.  A
possibly empty list of concept names following @code{<var>} is taken as the list
of parents of @code{<conceptconst>}.  Alternatively, parents can be specified
via the @code{:=>} option.  If no parents are specified, the parent of
@code{<conceptconst>} is taken to be THING.  @code{<keyword-option>} represents a
keyword followed by a value that states an assertion about @code{<conceptconst>}.
See @code{defrelation} for a description of @code{<keyword-option>}s.

@end deffn

@deffn N-Command deffunction (@w{&rest (args @sc{parse-tree})}) : @sc{named-description} 
Define (or redefine) a logic function.  The accepted syntax is:

@example 
 (deffunction <funconst> (<vardecl>+) [:-> <vardecl>]
    [:documentation <string>]
    [:<= <sentence>] | [:=> <sentence>] |
    [:<<= <sentence>] | [:=>> <sentence>] | 
    [:<=> <sentence>] | [:<=>> <sentence>] |
    [:<<=> <sentence>] | [:<<=>> <sentence>] |
    [:axioms @{<sentence> | (<sentence>+)@}]
    [<keyword-option>*])
@end example

Function parameters can be typed or untyped.  If the @code{:->} option is
supplied, it specifies the output variable of the function.  Otherwise,
the last variable in the parameter list is used as the output variable.
See @code{defrelation} for a description of @code{<keyword-option>}s.

@end deffn

@deffn N-Command definstance (@w{&rest (args @sc{parse-tree})}) : @sc{logic-object} 
Define (or redefine) a logic instance (@code{definstance} is an alias
for @code{defobject} which see).
@end deffn

@deffn N-Command defmodule (@w{(name @sc{name})} @w{&rest (options @sc{object})}) : 
Define (or redefine) a module named @var{name}.
The accepted syntax is:

@example 
  (defmodule <module-name>
     [:documentation <docstring>]
     [:includes @{<module-name> | (<module-name>*)@}]
     [:uses @{<module-name> | (<module-name>*)@}]
     [:lisp-package <package-name-string>]
     [:java-package <package-specification-string>]
     [:cpp-namespace <namespace-name-string>]
     [:java-catchall-class
     [:api? @{TRUE | FALSE@}]
     [:case-sensitive? @{TRUE | FALSE@}]
     [:shadow (<symbol>*)]
     [:java-catchall-class <class-name-string>]
     [<other-options>*])
@end example

@var{name} can be a string or a symbol.

Modules include objects from other modules via two separate mechanisms:
(1) they inherit from their parents specified via the @code{:includes} option
and/or a fully qualified module name, and (2) they inherit from used
modules specified via the @code{:uses} option.  The main difference between
the two mechanisms is that inheritance from parents is transitive, while
uses-links are only followed one level deep.  I.e., a module A that uses
B will see all objects of B (and any of B's parents) but not see anything
from modules used by B.  Another difference is that only objects declared
as public can be inherited via uses-links (this is not yet enforced).
Note that - contrary to Lisp - there are separate name spaces for classes,
functions, and variables.  For example, a module could inherit the class
@code{CONS} from the @code{STELLA} module, but shadow the function of the same name.

The above discussion of @code{:includes} and @code{:uses} semantics keyed on the
inheritance/visibility of symbols. The PowerLoom system makes another
very important distinction: If a module @code{A} is inherited directly or
indirectly via @code{:includes} specification(s) by a submodule @code{B}, then all
definitions and facts asserted in @code{A} are visible in @code{B}. This is not the
cases for @code{:uses}; the @code{:uses} options does not impact inheritance of
propositions at all.

The list of modules specified in the
@code{:includes} option plus (if supplied) the parent in the path used for
@var{name} become the new module's parents. If no @code{:uses} option was
supplied, the new module will use the @code{STELLA} module by default,
otherwise, it will use the set of specified modules.
If @code{:case-sensitive?} is supplied as TRUE, symbols in the module will be
interned case-sensitively, otherwise (the default), they will be
converted to uppercase before they get interned. Modules can shadow
definitions of functions and classes inherited from parents or used
modules. Shadowing is done automatically, but generates a warning unless
the shadowed type or function name is listed in the @code{:shadow} option of
the module definition .

Examples:

@example 
  (defmodule "PL-KERNEL/PL-USER"
    :uses ("LOGIC" "STELLA")
    :package "PL-USER")

  (defmodule PL-USER/GENEALOGY)
@end example

The remaining options are relevant only for modules that contain STELLA
code.  Modules used only to contain knowledge base definitions and assertions
have no use for them:

The keywords @code{:lisp-package}, @code{:java-package}, and @code{:cpp-package} specify
the name of a native package or name space in which symbols of the module
should be allocated when they get translated into one of Lisp, Java, or
C++. By default, Lisp symbols are allocated in the @code{STELLA} package, and
C++ names are translated without any prefixes. The rules that the STELLA
translator uses to attach translated Java objects to classes and packages
are somewhat complex. Use :java-package option to specify a list of
package names (separated by periods) that prefix the Java object in this
module.  Use :java-catchall-class to specify the name of the Java class to
contain all global & special variables, parameter-less functions and functions 
defined on arguments that are not classes in the current module.
The default value will be the name of the module.

When set to TRUE, the :api? option tells the PowerLoom User Manual
generator that all functions defined in this module should be included in
the API section. Additionally, the Java translator makes all API
functions @code{synchronized}.

@end deffn

@deffn N-Command defobject (@w{&rest (args @sc{parse-tree})}) : @sc{logic-object} 
Define (or redefine) a logic instance.  The accepted syntax is:

@example 
 (defobject <constant>
    [:documentation <string>]
    [<keyword-option>*])
@end example

@code{<keyword-option>} represents a keyword followed by a value
that states an assertion about <constant>.  See @code{defrelation} for a
description of @code{<keyword-option>}s.

@code{defobject} provides a sugar-coated way to assert a collection of facts
about a logic constant, but otherwise adds nothing in terms of functionality.

@end deffn

@deffn N-Command defproposition (@w{&rest (args @sc{parse-tree})}) : @sc{proposition} 
Define (or redefine) a named proposition.  The accepted syntax is:

@example 
 (defproposition <name> <sentence>
    [:documentation <string>]
    [:forward-only? @{true | false@}]
    [:backward-only? @{true | false@}]
    [:dont-optimize? @{true | false@}]
    [:confidence-level @{:strict | :default@}]
    [<keyword-option>*])
@end example

<sentence> can be any sentence that is legal as a top-level assertion.
<name> can be a string or symbol and will be bound to the asserted
proposition represented by <sentence>.  After this definition every
occurrence of <name> will be replaced by the associated proposition.

The options :forward-only? and :backward-only? can be used to tell the
inference engine to only use the rule in forward or backward direction
(this can also be achieved by using the @code{<<=} or @code{=>>} implication
arrows).  :dont-optimize?  tells the inference engine to not rearrange
the order of clauses in the antecedent of a rule and instead evaluate
them in their original order.  :confidence-level can be used to mark a
proposition as default only.

@code{<keyword-option>} represents a keyword followed by a value
that states an assertion about the proposition <name>.  See @code{defrelation}
for a description of @code{<keyword-option>}s.

@end deffn

@deffn N-Command defrelation (@w{&rest (args @sc{parse-tree})}) : @sc{named-description} 
Define (or redefine) a logic relation.  The accepted syntax is:

@example 
 (defrelation <relconst> (<vardecl>+)
    [:documentation <string>]
    [:<= <sentence>] | [:=> <sentence>] |
    [:<<= <sentence>] | [:=>> <sentence>] | 
    [:<=> <sentence>] | [:<=>> <sentence>] |
    [:<<=> <sentence>] | [:<<=>> <sentence>] |
    [:axioms @{<sentence> | (<sentence>+)@}]
    [<keyword-option>*])
@end example

Relation parameters can be typed or untyped.
@code{<keyword-option>} represents a keyword followed by a value that states an
assertion about @code{<relconst>}.  For example, including the option @code{:foo bar}
states that the proposition @code{(foo <relconst> bar)} is true.  @code{:foo (bar fum)}
states that both @code{(foo <relconst> bar)} and @code{(foo <relconst> fum)} are true.
@code{:foo true} states that @code{(foo <relconst>)} is true, @code{:foo false} states that
@code{(not (foo <relconst>))} is true.

@end deffn

@deffn N-Command defrule (@w{&rest (args @sc{parse-tree})}) : @sc{proposition} 
Define (or redefine) a named rule (@code{defrule} is an alias
for @code{defproposition} which see).
@end deffn

@deffn N-Command delete-rules (@w{(relation @sc{name})}) : 
Delete the list of rules associated with @var{relation}.
This function is included mainly for debugging purposes, when
a user wants to verify the behavior of different sets of rules.
@end deffn

@deffn N-Command demo (@w{&rest (fileandpause @sc{object})}) : 
Read logic commands from a file, echo them verbatimly to standard output,
and evaluate them just as if they had been typed in interactively.
When called with no arguments, present a menu of example demos, otherwise,
use the first argument as the name of the file to demo.
Pause for user confirmation after each expression has been read but
before it is evaluated.  Pausing can be turned off by suppling FALSE
as the optional second argument, or by typing @code{c} at the pause prompt.
Typing @code{?} at the pause prompt prints a list of available commands.
@end deffn

@deffn N-Command deny (@w{(proposition @sc{parse-tree})}) : @sc{object} 
Assert the falsity of @var{proposition}.  Return the asserted proposition
object.  KIF example:  "(deny (happy Fred))" asserts that Fred is not happy,
which could have been done equivalently by "(assert (not (happy Fred)))".
Note, that for this to succeed, the relation @code{happy} must already be defined
(see @code{assert}).
@end deffn

@deffn N-Command describe (@w{(name @sc{object})} @w{&rest (mode @sc{object})}) : 
Print a description of an object in :verbose, :terse,
or :source modes.
@end deffn

@deffn N-Command destroy (@w{(objectSpec @sc{parse-tree})}) : @sc{object} 
Find an object or proposition as specified by @var{objectSpec}, and destroy all
propositions and indices that reference it.  @var{objectSpec} must be a name or
a parse tree that evaluates to a proposition.  Return the deleted object, or
NULL if no matching object was found.
@end deffn

@deffn Command drop-load-path (@w{(path @sc{string})}) : @sc{(cons of string-wrapper)} 
Remove the directories listed in the |-separated
@var{path} from the PowerLoom load path.
@end deffn

@c # $(util/texinfo-insert-doc /LOGIC/DROP-TRACE)
@c # $(util/texinfo-insert-doc /LOGIC/FIND-INSTANCE)
@c # $(util/texinfo-insert-doc /LOGIC/FIND-RULE)
@c # $(util/texinfo-insert-doc /LOGIC/GET)
@c # $(util/texinfo-insert-doc /LOGIC/GET-INSTANCE)
@deffn Command get-load-path () : @sc{(cons of string-wrapper)} 
Return the current PowerLoom load path.
@end deffn

@c # $(util/texinfo-insert-doc /LOGIC/GET-RULE)
@deffn N-Command get-rules (@w{(relation @sc{name})}) : @sc{(cons of proposition)} 
Return the list of rules associated with @var{relation}.
@end deffn

@deffn N-Command help (@w{&rest (commands @sc{symbol})}) : 
Describe specific commands, or print a list of available commands.
@end deffn

@c # $(util/texinfo-insert-doc /LOGIC/IN-DIALECT)
@deffn N-Command in-module (@w{(name @sc{name})}) : @sc{module} 
Change the current module to the module named @var{name}.
@end deffn

@c # $(util/texinfo-insert-doc /LOGIC/LIST-FEATURES)
@deffn Command list-modules (@w{(kb-only? @sc{boolean})}) : @sc{(cons of module)} 
Returns a cons of all modules defined in PowerLoom.  If @var{kb-only?}
is @code{true}, then any modules which are code only or just namespaces are not returned.
@end deffn

@deffn Command load (@w{(file @sc{string})} @w{&rest (options @sc{object})}) : 
Read logic commands from @var{file} and evaluate them.
By default, this will check for each asserted proposition whether an
equivalent proposition already exists and, if so, not assert the
duplicate.  These duplicate checks are somewhat expensive though and
can be skipped by setting the option :check-duplicates? to false.
This can save time when loading large KBs where it is known that no
duplicate assertions exist in a file.
@end deffn

@deffn Command load-file (@w{(file @sc{string})}) : 
Read STELLA commands from @var{file} and evaluate them.
The file should begin with an @code{in-module} declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
@code{evaluate} to each of them.
@end deffn

@deffn Command pop-load-path () : @sc{string} 
Remove the first element from the PowerLoom load path
and return the removed element.
@end deffn

@deffn N-Command presume (@w{(proposition @sc{parse-tree})}) : @sc{object} 
Presume the default truth of @var{proposition}.  Return the presumed
proposition object.  KIF example:  "(presume (happy Fred))" states that Fred
is most probably happy.  Note, that for this to succeed, the relation
@code{happy} must already be defined (see @code{assert}).
@end deffn

@deffn Command print-features () : 
Print the currently enabled and available PowerLoom environment features.
@end deffn

@deffn N-Command print-rules (@w{(relation @sc{object})}) : 
Print the list of true rules associated with @var{relation}.
@end deffn

@deffn Command process-definitions () : 
Finish processing all definitions and assertions that have
been evaluated/loaded since that last call to @code{process-definitions}.
PowerLoom defers complete processing of definitions to make it easier
to support cyclic definitions.  Following finalization of definitions,
this call performs semantic validation of any assertions evaluated since
the last call to @code{process-definitions}.  PowerLoom calls this function
internally before each query; the primary reason to call it explicitly
is to force the production of any diagnostic information that results from
the processing and validation.
@end deffn

@deffn N-Command propagate-constraints (@w{&rest (name @sc{name})}) : 
Trigger constraint propagation over all propositions of module @var{name}.
If no @var{name} is supplied, the current module will be used.  This also
enables incremental constraint propagation for future monotonic updates to
the module.  Once a non-monotonic update is performed, i.e., a retraction
or clipping of a function value, all cached inferences will be discarded
and constraint propagation will be turned off until this function is
called again.
@end deffn

@deffn Command push-load-path (@w{(path @sc{string})}) : @sc{(cons of string-wrapper)} 
Add the directories listed in the |-separated
@var{path} to the front of the PowerLoom load path.  Return the
resulting load path.
@end deffn

@deffn N-Command repropagate-constraints (@w{&rest (name @sc{name})}) : 
Force non-incremental constraint propagation over all propositions of
module @var{name}.  If no @var{name} is supplied, the current module will be used.
This also enables incremental constraint propagation for future monotonic
updates to the module similar to @code{propagate-constraints}.
@end deffn

@deffn Command reset-features () : @sc{(list of keyword)} 
Reset the PowerLoom environment features to their default settings.
@end deffn

@deffn Command reset-powerloom () : 
Reset PowerLoom to its initial state.
CAUTION: This will destroy all loaded knowledge bases and might break other
loaded STELLA systems if they do reference PowerLoom symbols in their code.
@end deffn

@deffn N-Command retract (@w{(proposition @sc{parse-tree})}) : @sc{object} 
Retract the truth of @var{proposition}.  Return the retracted proposition
object.  KIF example:  "(retract (happy Fred))" retracts that Fred is
happy.  Note that for this assertion to succeed, the relation @code{happy} must already
be defined.  If the constant @code{Fred} has not yet been created, it is
automatically created as a side-effect of calling @code{retract}.
@end deffn

@deffn N-Command retract-facts-of (@w{(instanceRef @sc{object})}) : 
Retract all definite (TRUE or FALSE) propositions
that reference the instance @var{instanceRef}.
@end deffn

@c # $(util/texinfo-insert-doc /LOGIC/RETRACT-FACTS-OF-INSTANCE)
@deffn N-Command retract-from-query (@w{(query @sc{cons})} @w{&rest (options @sc{object})}) : @sc{(cons of proposition)} 
Evaluate @var{query} which has to be a strict or partial retrieval
command, instantiate the query proposition for each generated solution
and retract the resulting propositions.  See @code{assert-from-query} for
available command options.
@end deffn

@deffn N-Command retract-rule (@w{(ruleName @sc{name})}) : @sc{proposition} 
If it is currently TRUE, set the truth value 
of the rule named @var{ruleName} to UNKNOWN  This
command may be used alternately with @code{assert-rule} to
observe the effects of querying with or without a particular (named) rule
being asserted within the current context. The proposition having the name
@var{ruleName} may be any arbitrary proposition, although we expect that it is
probably a material implication.
@end deffn

@deffn N-Command retrieve (@w{&rest (query @sc{parse-tree})}) : @sc{query-iterator} 
Retrieve elements of a relation (tuples) that satisfy a proposition.
The accepted syntax is:

@example 
  (retrieve [<integer> | all]
            [[@{<vardecl> | (<vardecl>+)@}]
            <proposition>])
@end example

The variables and proposition are similar to an @code{exists} sentence or
@code{kappa} term without the explicit quantifier.  If variables are declared,
they must match the free variables referenced by <proposition>.  Otherwise,
the free variables referenced in <proposition> will be used as the query
variables.  If <proposition> is omitted, the most recently asked query
will be continued.

A solution is a set of bindings for the listed variables for which
<proposition> is true.  The optional first argument controls how many
solutions should be generated before control is returned.  The keyword
@code{all} indicates that all solutions should be generated.  By default,
@code{retrieve} returns after it has found one new solution or if it cannot
find any more solutions.

@code{retrieve} returns an iterator which saves all the necessary state of
a query and stores all generated solutions.  When used interactively,
the returned iterator will print out with the set of solutions collected
so far.  Calling @code{retrieve} without any arguments (or only with the first
argument) will generate one (or more) solutions to the most recently
asked query.

KIF examples:

@example 
  (retrieve (happy ?x))
@end example

will try to find one happy entity and store it in the returned 
query iterator.

@example 
  (retrieve 10 (happy ?x))
@end example

will try to find 10 happy entities.

@example 
  (retrieve 10)
@end example

will try to find the next 10 happy entities..

@example 
  (retrieve all (happy ?x))
@end example

will find all happy entities.

@example 
  (retrieve all (?x Person) (happy ?x))
@end example

will to find all happy people.  Here we used the optional retrieve variable
syntax to restrict the acceptable solutions.  The above is equivalent to
the following query:

@example 
  (retrieve all (and (Person ?x) (happy ?x)))
@end example

Similarly,

@example 
  (retrieve all (?x Person))
  (retrieve all (Person ?x))
  (retrieve all ?x (Person ?x))
@end example

will find all people.  Note that in the first case we only specify a query
variable and its type but omit the logic sentence which defaults to TRUE.  This
somewhat impoverished looking query can be paraphrased as "retrieve all ?x of
type Person such that TRUE."

@example 
  (retrieve ?x (or (happy ?x) (parent-of Fred ?x)))
@end example

will try to find a person that is happy or has Fred as a parent.

@example 
  (retrieve (?y ?x) (parent-of ?x ?y))
@end example

will try to find the one pair of parent/child and return it in the order
of child/parent.

@example 
  (retrieve all (?x Person)
            (exists (?y Person) (parent-of ?x ?y)))
@end example

will generate the set of all parents.  Note, that for these queries to run,
the class @code{Person}, the relations @code{happy} and @code{parent-of}, and the logic
constant @code{Fred} must already be defined (see @code{assert}).

Use @code{(set/unset-feature trace-subgoals)} to en/disable goal tracing of the
inference engine.
@end deffn

@c # $(util/texinfo-insert-doc /LOGIC/RUN-POWERLOOM-TESTS)
@c # $(util/texinfo-insert-doc /LOGIC/SATISFIES?)
@deffn N-Command save-module (@w{(name @sc{name})} @w{(file @sc{string})}) : 
Save all definitions and assertions of module @var{name} to @var{file}.
@end deffn

@deffn N-Command set-feature (@w{&rest (features @sc{name})}) : @sc{(list of keyword)} 
Enable the PowerLoom environment feature(s) named by @var{features}.
Return the list of enabled features.  Calling @code{set-feature} without any
arguments can be used to display the currently enabled features.
The following features are supported:

@code{just-in-time-inference}: Enables interleaving of forward chaining inference
within backward chaining queries.

@code{iterative-deepening}: Tells the query processor to use iterative deepening
instead of a depth-first search to find answers.  This is less efficient
but necessary for some kinds of highly recursive queries.

@code{trace-subgoals}: Enables the generation of subgoaling trace information during
backchaining inference.

@code{trace-solutions}: Prints newly found solutions during retrieval right when they
are generated as opposed to when the query terminates.

@code{trace-classifier}: Tells the classifier to describe the inferences it draws.

@code{justifications}: Enables the generation of justifications during inference,
which is a prerequiste for the generation of explanations with @code{(why)}.

@code{emit-thinking-dots}: Tells PowerLoom to annotate its inference progress by
outputting characters indicating the completion of individual reasoning steps.

By default, the features @code{emit-thinking-dots} and @code{just-in-time-inference}
are enabled, and the others are disabled.

@end deffn

@deffn Command set-load-path (@w{(path @sc{string})}) : @sc{(cons of string-wrapper)} 
Set the PowerLoom load path to the |-separated
directories listed in @var{path}.  Return the resulting load path.
@end deffn

@c # $(util/texinfo-insert-doc /LOGIC/SPECIALIZES?)
@deffn N-Command time-command (@w{(command @sc{cons})}) : @sc{object} 
Execute @var{command}, measure and report its CPU and elapsed time
needed for its execution, and then return its result.
@end deffn

@c # $(util/texinfo-insert-doc /LOGIC/UNASSERT)
@deffn N-Command unset-feature (@w{&rest (features @sc{name})}) : @sc{(list of keyword)} 
Disable the PowerLoom environment feature(s) named by @var{features}.
Return the list of enabled features.  Calling @code{unset-feature} without any
arguments can be used to display the currently enabled features.
See @code{set-feature} for a description of supported features.
@end deffn

@deffn N-Command why (@w{&rest (args @sc{object})}) : 
Print an explanation for the result of the most recent query.
Without any arguments, @code{why} prints an explanation of the top level
query proposition down to a maximum depth of 3.  @code{(why all)} prints
an explanation to unlimited depth.  Alternatively, a particular depth
can be specified, for example, @code{(why 5)} explains down to a depth of 5.
A proof step that was not explained explicitly (e.g., due to a depth
cutoff) can be explained by supplying the label of the step as the
first argument to @code{why}, for example, @code{(why 1.2.3 5)} prints an explanation
starting at 1.2.3 down to a depth of 5 (which is counted relative to the
depth of the starting point).  The keywords @code{brief} and @code{verbose} can be
used to select a particular explanation style.  In brief mode, explicitly
asserted propositions are not further explained and indicated with a
@code{!} assertion marker.  Additionally, relatively uninteresting proof steps
such as AND-introductions are skipped.  This explanation style option is
sticky and will affect future calls to @code{why} until it gets changed again.
The various options can be combined in any way, for example,
@code{(why 1.2.3 brief 3)} explains starting from step 1.2.3 down to a depth
of 3 in brief explanation mode.
@end deffn

@c # $(util/texinfo-insert-doc /LOGIC/WHYNOT)

@c ===========================================================================

@node PowerLoom API, Built-In Relations, Commands, Top
@chapter PowerLoom API

This chapter lists functions that collectively define the PowerLoom
API.  The first section describes the API functions themselves.  The
signature is the basic Stella signature.  Information on how to
translate the names of the functions and their arguments into the
programming languages Common Lisp, C++ or Java is given in the Language
Specific Interface section.

@menu
* API Functions::               
* Language Specific Interface::  
@end menu

@node API Functions, Language Specific Interface, PowerLoom API, PowerLoom API
@section API Functions

Many of the functions take a `module' argument that causes the function to be
evaluated in the context of that module. Passing in a NULL value for the module
argument means that evaluation takes place in the current module. The module
argument is frequently followed by an `environment' argument that specifies
which inference environment should be assumed during evaluation. Values for
`environment' are `ASSERTION-ENV', `TAXONOMIC-ENV', and `INFERENCE-ENV'.
`ASSERTION-ENV' specifies that a knowledge base query or lookup should take
into account only explicitly asserted propositions. `TAXONOMIC-ENV' 
specifies that a knowledge base query should take into account
explicitly-asserted propositions plus any rules that specify subsumption
relationships.   `INFERENCE-ENV' specifies that a knowledge base query
should take all relevant propositions into account, including those
generated during forward inferencing.  A NULL value for the `environment'
argument defaults to `TAXONOMIC-ENV'.

Many of the functions that take PowerLoom or Stella objects as inputs
also have an analog version whose name starts with the prefix "s-" that
take strings as inputs.  This is provided as a convenience so that
programmers will not necessarily need to manipulate PowerLoom objects
directly.

@c these are listed alphabetically:
@deffn Function ask (@w{(query @sc{cons})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{truth-value} 
Returns a truth value for @var{query} in @var{module} and @var{environment}.
@var{query} has the same syntax as the PowerLoom @code{ask} command (which see)
but with the @code{ask} operator omitted.  For example, here are some legal
@var{query} arguments:

@example 
    ((happy Fred))
    ((happy Fred) :inference-level :assertion)
    ((happy Fred) :inference-level :assertion :timeout 1.0)
@end example

As a convenience, a @var{query} argument whose first element is a symbol is
interpreted as a sentence that is queried without any options.  For example:

@example 
    (happy Fred)
@end example

is a legal @var{query} argument.  Note that for a setence whose relation is a list
itself, e.g., @code{((FruitFn BananaTree) MyBanana)} this shortcut is not available,
that is, in that case an extra level of list nesting is always necessary.
The returned truth value represents the logical truth of the queried sentence
as determined by PowerLoom.  It can be be tested via the functions @code{is-true},
@code{is-false} and @code{is-unknown} (which see).
@end deffn

@deffn Function assert-binary-proposition (@w{(relation @sc{logic-object})} @w{(arg @sc{object})} @w{(value @sc{object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{proposition} 
Assert that the proposition (@var{relation} @var{arg} @var{value}) is TRUE
in @var{module}.  Return the asserted proposition.
@end deffn

@deffn Function assert-nary-proposition (@w{(relation-and-arguments @sc{object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{proposition} 
Assert that the proposition represented by the list @code{ relation-and-arguments} satisfies
the relation @code{relation}.
@end deffn

@deffn Function assert-proposition (@w{(proposition @sc{proposition})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{proposition} 
Assert that the proposition @var{proposition} is true in @var{module}.
Return the asserted proposition.
@end deffn

@deffn Function assert-unary-proposition (@w{(relation @sc{logic-object})} @w{(arg @sc{object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{proposition} 
Assert that the proposition (@var{relation} @var{arg}) is TRUE in @var{module}.  Return the asserted proposition.
@end deffn

@deffn Function change-module (@w{(module @sc{module})}) : @sc{module} 
Set the current module to @var{module} and return it.
If @var{module} is @code{null}, then no switch is performed and the current
module is returned.
@end deffn

@deffn Function clear-caches () : 
Clear all query and memoization caches.
@end deffn

@deffn Function clear-module (@w{(module @sc{module})}) : @sc{module} 
Destroy the contents of the module @var{module} as well as
the contents of all of its children, recursively.
@end deffn

@deffn Function conceive (@w{(sentence @sc{object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{(pl-iterator of proposition)} 
Create one or more proposition objects from the sentence @var{sentence}
in the  module @var{module}.  Return an iterator of the propositions.
If any of the new propositions has the same structure as an already existing
proposition, an automatic check for duplicates will return the pre-existing
proposition.  Multiple propositions may be returned for a single sentence
because of normalization of equivalences, conjunctions, etc.

Signals a @code{Proposition-Error} if PowerLoom could not conceive @var{sentence}.
@end deffn

@deffn Function cons-to-pl-iterator (@w{(self @sc{cons})}) : @sc{pl-iterator} 
Convert a Stella cons list into an API iterator.
@end deffn

@deffn Function create-concept (@w{(name @sc{string})} @w{(parent @sc{logic-object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{logic-object} 
Create a concept named @var{name} in the designated @var{module}, with the
designated @var{parent} superconcept (which can be left undefined).  Additional
superconcepts can be added via assertions of the @code{subset-of} relation.  Note
that a specified @var{parent} concept needs to be created separately.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match @var{name} exactly.
@end deffn

@deffn Function create-enumerated-list (@w{(members @sc{cons})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{logic-object} 
Create a logical term that denotes a list containing @var{members} in
@var{module} using @var{environment}.  Useful for passing lists as arguments
to parameterized queries.
@end deffn

@deffn Function create-enumerated-set (@w{(members @sc{cons})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{logic-object} 
Create a logical term that denotes the enumerated set containing @var{members}
in @var{module} using @var{environment}.
@end deffn

@deffn Function create-function (@w{(name @sc{string})} @w{(arity @sc{integer})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{logic-object} 
Create a function named @var{name} with arity @var{arity}  in the designated 
@var{module}.  Domain and range information can be added via assertions of
@code{nth-domain} (or @code{domain} and @code{range}) relations.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match @var{name} exactly.
@end deffn

@deffn Function create-module (@w{(name @sc{string})} @w{(parent @sc{module})} @w{(case-sensitive? @sc{boolean})}) : @sc{module} 
Creates a new module @var{name} as a child of @var{parent}.  The flag
@var{case-sensitive?} controls whether names read in this module will be
case sensitive or not.
@end deffn

@deffn Function create-object (@w{(name @sc{string})} @w{(concept @sc{logic-object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{logic-object} 
Create an object named @var{name} of type @var{concept} in the designated
module.  Both @var{name} and @var{concept} can be @code{null}.  If @var{name} is @code{null} then an
object will be created with a new, non-conflicting name based on the name of
@var{concept}, or system-generated if no concept is specified.  If @var{concept} is
@code{null}, then the object will be of type THING.  It is an error to create an
object with the same name as an existing object.

Note that the string can be a qualified name, in which case the object
will be created in the module specified, but with a name as determined
by the qualified name.  Vertical bars in the name string are interpreted
as Stella escape characters.

Note that because names in modules that are not case-sensitive are
canonicalized, the name of the returned object may not match @var{name}
exactly.

Return the object.
@end deffn

@deffn Function create-relation (@w{(name @sc{string})} @w{(arity @sc{integer})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{logic-object} 
Create a relation named @var{name} with arity @var{arity} in the
designated module.  Domain and range information can be added via assertions
of @code{nth-domain} (or @code{domain} and @code{range}) relations.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match @var{name} exactly.
@end deffn

@deffn Function destroy-object (@w{(object @sc{logic-object})}) : 
Delete the object @var{object}, retracting all facts attached to it.
@end deffn

@defmethod @sc{pl-iterator} empty? (self) : @sc{boolean} 
Return TRUE if the iterator @var{self} has no more elements.
@end defmethod

@deffn Function evaluate (@w{(command @sc{object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{object} 
Evaluate the command @var{command} within @var{module} and return
the result. Currently, only the evaluation of (possibly nested) commands and
global variables is supported.  Commands are simple to program in Common Lisp,
since they are built into the language, and relatively awkward in Java and C++.
Users of either of those languages are more likely to want to call @code{s-evaluate}.
@end deffn

@deffn Function generate-unique-name (@w{(prefix @sc{string})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{string} 
Generates a name based on @var{prefix} with a number appended that
is not currently in use in @code{module.}  In a non-case-sensitive module, the returned
name will be all upper case (This latter feature may change!)
@end deffn

@deffn Function get-arity (@w{(relation @sc{logic-object})}) : @sc{integer} 
Return the arity of the relation @var{relation}.
@end deffn

@deffn Function get-binary-proposition (@w{(relation @sc{logic-object})} @w{(arg1 @sc{object})} @w{(arg2 @sc{object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{proposition} 
Return a proposition such that (@var{relation} @var{arg1} @var{arg2})
is true.  The @var{relation} argument must be bound to a relation.  One or both
of the @var{arg1} and @var{arg2} arguments may be set to NULL, which is interpreted
as a wildcard. If more than one proposition matches the input criteria,
the selection is arbitrary.  This procedure is normally applied to single-valued
relations or functions.
@end deffn

@deffn Function get-binary-propositions (@w{(relation @sc{logic-object})} @w{(arg1 @sc{object})} @w{(arg2 @sc{object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{(pl-iterator of proposition)} 
Return propositions such that (@var{relation} @var{arg1} @var{arg2})
is true.  The @var{relation} argument
must be bound to a relation.  One or both of the @var{arg1} and @var{arg2} arguments
may be set to NULL, which is interpreted as a wildcard.
@end deffn

@deffn Function get-child-modules (@w{(module @sc{module})}) : @sc{(pl-iterator of module)} 
Return the modules that are immediate children of @var{module}.
@end deffn

@deffn Function get-column-count (@w{(obj @sc{object})}) : @sc{integer} 
Return the number of columns in @var{obj}, which must
be of type proposition, cons, vector or PL-iterator.  For a proposition,
the number includes both the predidate and arguments. For the PL-iterator
case,the number of columns is for the current value of the iterator.

For non sequence objects, the column count is zero.
@end deffn

@deffn Function get-concept (@w{(name @sc{string})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{logic-object} 
Return a class/concept named @var{name} that is local to
or visible from the module @var{module}.
@end deffn

@deffn Function get-concept-instance-matching-value (@w{(concept @sc{logic-object})} @w{(relation @sc{logic-object})} @w{(value @sc{object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{object} 
Return a member of concept @var{concept} that
has an attribute matching @var{value} for the binary relation @var{relation}, i.e.,
@code{(relation <result> value)} holds.
@end deffn

@deffn Function get-concept-instances (@w{(concept @sc{logic-object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{pl-iterator} 
Return instances of the concept @var{concept}.
Include instances of subconcepts of @var{concept}.  Depending on @var{concept},
the return values could be (wrapped) literals.
@end deffn

@deffn Function get-concept-instances-matching-value (@w{(concept @sc{logic-object})} @w{(relation @sc{logic-object})} @w{(value @sc{object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{pl-iterator} 
Return members of concept @var{concept} that
have an attribute matching @var{value} for the binary relation @var{relation}, i.e.,
@code{(relation <result> value)} holds.
@end deffn

@deffn Function get-current-module (@w{(environment @sc{environment})}) : @sc{module} 
Return the currently set module
@end deffn

@deffn Function get-direct-concept-instances (@w{(concept @sc{logic-object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{pl-iterator} 
Return instances of concept @var{concept}.
Exclude instances of subconcepts of @var{concept}.  Depending on @var{concept},
the return values could be (wrapped) literals.
@end deffn

@deffn Function get-direct-subrelations (@w{(relation @sc{logic-object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{(pl-iterator of logic-object)} 
Return relations that directly specialize @var{relation}.
Non-reflexive.
@end deffn

@deffn Function get-direct-superrelations (@w{(relation @sc{logic-object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{(pl-iterator of logic-object)} 
Return relations that directly generalize @var{relation}.
Non-reflexive.
@end deffn

@deffn Function get-direct-types (@w{(object @sc{logic-object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{(pl-iterator of logic-object)} 
Return most specific concepts that @var{object} belongs to.
@end deffn

@deffn Function get-domain (@w{(relation @sc{logic-object})}) : @sc{logic-object} 
Return the type (a concept) for the first argument to the binary
relation @var{relation}.
@end deffn

@deffn Function get-enumerated-collection-members (@w{(collection @sc{object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{cons} 
Returns the members of an enumerated collection.  This works on all types
of collection, i.e., sets and lists
@end deffn

@deffn Function get-home-module (@w{(object @sc{logic-object})}) : @sc{module} 
Return the module in which @var{object} was created.
@end deffn

@deffn Function get-inferred-binary-proposition-values (@w{(relation @sc{logic-object})} @w{(arg @sc{object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{pl-iterator} 
Return all values @code{v} such that (@var{relation} @var{arg} @code{v})
has been asserted or can be inferred.
@end deffn

@deffn Function get-module (@w{(name @sc{string})} @w{(environment @sc{environment})}) : @sc{module} 
Return a module named @var{name}.
@end deffn

@deffn Function get-modules (@w{(kb-modules-only? @sc{boolean})}) : @sc{(pl-iterator of module)} 
Return all modules currently loaded into PowerLoom.  If @var{kb-modules-only?}
is @code{true}, then Stella modules that are used only for program code are
not included in the list.
@end deffn

@deffn Function get-name (@w{(obj @sc{object})}) : @sc{string} 
Return the fully qualified name of @var{obj}, if it has one.  Otherwise return @code{null}.
@end deffn

@deffn Function get-nth-domain (@w{(relation @sc{logic-object})} @w{(n @sc{integer})}) : @sc{logic-object} 
Return the type (a concept) for the the nth argument of the
relation @var{relation}.  Counting starts at zero.
@end deffn

@deffn Function get-nth-float (@w{(sequence @sc{object})} @w{(n @sc{integer})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{float} 
Return the floating point value in the @code{nth} column of
@var{sequence}. Counting starts at zero.  @var{sequence} must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  If this is not
a floating point value, then an exception will be thrown.


As a special case, a column number of zero will also return the floating
point value of @var{sequence} itself if it is not one of the types enumerated
above.  This allows the use of @code{get-nth-float} on PL-iterators with only
a single return variable.    If  @var{sequence} cannot be turned into a floating
point value, an exception will be thrown.
@end deffn

@deffn Function get-nth-integer (@w{(sequence @sc{object})} @w{(n @sc{integer})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{integer} 
Return an integer representation of the value in the @code{nth} column of
@var{sequence}. Counting starts at zero.   Unless @var{n} is zero, @var{sequence} must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  If this is not
an integer value, then an exception will be thrown.


As a special case, a column number of zero will also return the integer
value of @var{sequence} itself if it is not one of the types enumerated
above.   This allows the use of @code{get-nth-integer} on PL-iterators with
only a single return variable.  If  @var{sequence} cannot be turned into an
integer, an exception will be thrown.
@end deffn

@deffn Function get-nth-logic-object (@w{(sequence @sc{object})} @w{(n @sc{integer})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{logic-object} 
Return a logic object representation of the value in the @code{nth} column
of @var{sequence}.  Counting starts at zero.   Unless @var{n} is zero, @var{sequence} must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  A zero column number
returns the proposition's relational predicate.  If the return value is
not a LOGIC-OBJECT, an exception is thrown.

As a special case, a column number of zero will also return @var{sequence} itself
if it is not one of the types enumerated above.  This is done to allow the
use of @code{get-nth-value} on PL-iterators with only a single return variable.
If @var{sequence} is not a LOGIC-OBJECT, an exception is thrown.
@end deffn

@deffn Function get-nth-string (@w{(sequence @sc{object})} @w{(n @sc{integer})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{string} 
Return a string representation of the value in the @code{nth} column of
@var{sequence}. Counting starts at zero.   Unless @var{n} is zero, @var{sequence} must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  This will always
succeed, even if the @code{nth} value is not a string object.  In that case, a
string reprensentation will be returned.


As a special case, a column number of zero will also return @var{sequence} itself
as a string if it is not one of the types enumerated above.  This is done to 
allow the use of @code{get-nth-string} on PL-iterators with only a single return variable.
@end deffn

@deffn Function get-nth-value (@w{(sequence @sc{object})} @w{(n @sc{integer})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{object} 
Return the value in the @code{nth} column of @var{sequence}.
Counting starts at zero.  Unless @var{n} is zero, @var{sequence} must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the number
of columns is for the current value of the iterator.

As a special case, a column number of zero will also return @var{sequence} itself
if it is not one of the types enumerated above.  This is done to allow the
use of @code{get-nth-value} on PL-iterators with only a single return variable.
@end deffn

@deffn Function get-operator (@w{(name @sc{string})}) : @sc{symbol} 
Returns the logical operator object (a Stella SYMBOL) for @var{name}.
If no such operator exists then a @code{no-such-object} exception is thrown.
@end deffn

@deffn Function get-object (@w{(name @sc{string})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{object} 
Look for an object named @var{name} that is local to
or visible from the module @var{module}.
@end deffn

@deffn Function get-parent-modules (@w{(module @sc{module})}) : @sc{(pl-iterator of module)} 
Return the modules that are immediate parents of @var{module}.
@end deffn

@deffn Function get-predicate (@w{(prop @sc{proposition})}) : @sc{logic-object} 
Return the concept or relation predicate for
the proposition @var{prop}.
@end deffn

@deffn Function get-proper-subrelations (@w{(relation @sc{logic-object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{(pl-iterator of logic-object)} 
Return relations that specialize @var{relation}.
Non-reflexive.
@end deffn

@deffn Function get-proper-superrelations (@w{(relation @sc{logic-object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{(pl-iterator of logic-object)} 
Return relations that generalize @var{relation}.
Non-reflexive.
@end deffn

@deffn Function get-proposition (@w{(relation-and-arguments @sc{object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{proposition} 
Return a proposition matching @var{relation-and-arguments} that
has been asserted (or inferred by forward chaining).  @var{relation-and-arguments}
is a sequence containing objects and nulls.  The first argument must be the
name of a relation.  A null value acts like a wild card.  If more than one 
proposition matches the input criteria, the selection among satisficing
propositions is arbitrary.  This procedure is normally applied to single-valued
relations or functions.
@end deffn

@deffn Function get-propositions (@w{(relation-and-arguments @sc{object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{(pl-iterator of proposition)} 
Return propositions matching @var{relation-and-arguments} that
have been asserted (or inferred by forward chaining).  @var{relation-and-arguments}
is a sequence containing objects and nulls.  The first argument must be the
name of a relation.  A null value acts like a wild card.
@end deffn

@deffn Function get-propositions-in-module (@w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{(pl-iterator of proposition)} 
Return propositions that have been conceived in
the module @var{module}.
@end deffn

@deffn Function get-propositions-of (@w{(object @sc{logic-object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{(pl-iterator of proposition)} 
Return all propositions that have @var{object} among their arguments,
and that are TRUE in the scope of the module @var{module}.
@end deffn

@deffn Function get-range (@w{(relation @sc{logic-object})}) : @sc{logic-object} 
Return the type (a concept) for fillers of the binary relation
@var{relation}.
@end deffn

@deffn Function get-relation (@w{(name @sc{string})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{logic-object} 
Return a concept or relation named @var{name} that is local to
or visible from the module @var{module}.
@end deffn

@deffn Function get-relation-extension (@w{(relation @sc{logic-object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{(pl-iterator of proposition)} 
Return propositions that satisfy @var{relation}.
Include propositions that satisfy subrelations of @var{relation}.
@end deffn

@deffn Function get-rules (@w{(relation @sc{logic-object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{(pl-iterator of proposition)} 
Return rules attached to the concept/relation @var{relation}
in either antecedent or consequent position.
@end deffn

@deffn Function get-types (@w{(object @sc{logic-object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{(pl-iterator of logic-object)} 
Return all named concepts that @var{object} belongs to.
@end deffn

@deffn Function initialize () : 
Initialize the PowerLoom logic system.  This function
needs to be called by all applications before using PowerLoom.  If it
is called more than once, every call after the first one is a no-op.
@end deffn

@deffn Function is-a (@w{(object @sc{object})} @w{(concept @sc{logic-object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{boolean} 
Return TRUE if @var{object} is a member of the concept @var{concept}.
@end deffn

@deffn Function is-default (@w{(tv @sc{truth-value})}) : @sc{boolean} 
Tests whether @var{tv} is a default truth value.
@end deffn

@deffn Function is-enumerated-collection (@w{(obj @sc{object})}) : @sc{boolean} 
Test whether @var{obj} is an enumerated collection.  This
subsumes both sets and lists.
@end deffn

@deffn Function is-enumerated-list (@w{(obj @sc{object})}) : @sc{boolean} 
Test whether @var{obj} is an enumerated list
@end deffn

@deffn Function is-enumerated-set (@w{(obj @sc{object})}) : @sc{boolean} 
Test whether @var{obj} is an enumerated set.
@end deffn

@deffn Function is-false (@w{(tv @sc{truth-value})}) : @sc{boolean} 
Tests whether @var{tv} is a false truth value.  It can be false
either absolutely or by default.
@end deffn

@deffn Function is-float (@w{(obj @sc{object})}) : @sc{boolean} 
Test whether @var{obj} is of type FLOAT (double)
@end deffn

@deffn Function is-inconsistent (@w{(tv @sc{truth-value})}) : @sc{boolean} 
Tests whether @var{tv} is an inconsistent truth value.
@end deffn

@deffn Function is-integer (@w{(obj @sc{object})}) : @sc{boolean} 
Test whether @var{obj} is of type INTEGER
@end deffn

@deffn Function is-logic-object (@w{(obj @sc{object})}) : @sc{boolean} 
Test whether @var{obj} is of type LOGIC-OBJECT
@end deffn

@deffn Function is-number (@w{(obj @sc{object})}) : @sc{boolean} 
Test whether @var{obj} is of type NUMBER.  This can
be either an integer or a floating point number.  One key characteristic
is that @code{object-to-integer} and @code{object-to-float} will both work on it.
@end deffn

@deffn Function is-strict (@w{(tv @sc{truth-value})}) : @sc{boolean} 
Tests whether @var{tv} is a strict (non-default) truth value.
@end deffn

@deffn Function is-string (@w{(obj @sc{object})}) : @sc{boolean} 
Test whether @var{obj} is of type STRING
@end deffn

@deffn Function is-subrelation (@w{(sub @sc{logic-object})} @w{(super @sc{logic-object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{boolean} 
Return TRUE if @var{sub} is a subconcept/subrelation of @var{super}.
@end deffn

@deffn Function is-true (@w{(tv @sc{truth-value})}) : @sc{boolean} 
Tests whether @var{tv} is a true truth value.  It can be true
either absolutely or by default.
@end deffn

@deffn Function is-true-binary-proposition (@w{(relation @sc{logic-object})} @w{(arg @sc{object})} @w{(value @sc{object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{boolean} 
Return TRUE if the proposition (@var{relation} @var{arg} @var{value}) has
been asserted (or inferred by forward chaining).
@end deffn

@deffn Function is-true-proposition (@w{(proposition @sc{proposition})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{boolean} 
Return TRUE if @var{proposition} is  TRUE in the module @var{module}.
@end deffn

@deffn Function is-true-unary-proposition (@w{(relation @sc{logic-object})} @w{(arg @sc{object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{boolean} 
Return TRUE if the proposition (@var{relation} @var{arg}) has
been asserted (or inferred by forward chaining).
@end deffn

@deffn Function is-unknown (@w{(tv @sc{truth-value})}) : @sc{boolean} 
Tests whether @var{tv} is an unknown truth value.
@end deffn

@deffn Function iterator-to-pl-iterator (@w{(self @sc{iterator})}) : @sc{pl-iterator} 
Convert an arbitrary Stella iterator into an API iterator.
@end deffn

@defmethod @sc{pl-iterator} length (self) : @sc{integer} 
Number of items remaining in @var{self}.  Non destructive.
@end defmethod

@deffn Function list-to-pl-iterator (@w{(self @sc{list})}) : @sc{pl-iterator} 
Convert a Stella list into an API iterator.
@end deffn

@deffn Function load (@w{(filename @sc{string})} @w{(environment @sc{environment})}) : 
Read logic commands from the file named @var{filename} and evaluate them.
The file should begin with an @code{in-module} declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
@code{evaluate} to each of them.
@end deffn

@deffn Function load-stream (@w{(stream @sc{input-stream})} @w{(environment @sc{environment})}) : 
Read logic commands from the STELLA stream @var{stream} and evaluate them.
The stream should begin with an @code{in-module} declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
@code{evaluate} to each of them.
@end deffn

@deffn Function load-native-stream (@w{(stream @sc{native-input-stream})} @w{(environment @sc{environment})}) : 
Read logic commands from the native input stream @var{stream} and evaluate them.
Assumes @var{stream} is a line-buffered stream which is a safe compromise but does
not generate the best efficiency for block-buffered streams such as files.
The stream should begin with an @code{in-module} declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
@code{evaluate} to each of them.
@end deffn

@defmethod @sc{pl-iterator} next? (self) : @sc{boolean} 
Advance the PL-Iterator @var{self} and return @code{true} if more
elements are available, @code{false} otherwise.
@end defmethod

@deffn Function object-to-float (@w{(self @sc{object})}) : @sc{float} 
Coerce @var{self} to a float, or throw a Stella Exception if the coersion is not feasible.
@end deffn

@deffn Function object-to-integer (@w{(self @sc{object})}) : @sc{integer} 
Coerce @var{self} to an integer, or throw a Stella Exception if the coersion is not feasible.
Floating point values will be coerced by rounding.
@end deffn

@deffn Function object-to-parsable-string (@w{(self @sc{object})}) : @sc{string} 
Return a string representing a printed
representation of the object @var{self}.  Like @code{object-to-string}, but puts
escaped double quotes around strings.
@end deffn

@deffn Function object-to-string (@w{(self @sc{object})}) : @sc{string} 
Return a printed representation of the term @var{self} as a string.
@end deffn

@deffn N-Command print-rules (@w{(relation @sc{object})}) : 
Print the list of true rules associated with @var{relation}.
@end deffn

@deffn Function reset-powerloom () : 
Reset PowerLoom to its initial state.
CAUTION: This will destroy all loaded knowledge bases and might break other
loaded STELLA systems if they do reference PowerLoom symbols in their code.
@end deffn

@deffn N-Command retract (@w{(proposition @sc{parse-tree})}) : @sc{object} 
Retract the truth of @var{proposition}.  Return the retracted proposition
object.  KIF example:  "(retract (happy Fred))" retracts that Fred is
happy.  Note that for this assertion to succeed, the relation @code{happy} must already
be defined.  If the constant @code{Fred} has not yet been created, it is
automatically created as a side-effect of calling @code{retract}.
@end deffn

@deffn Function retract-binary-proposition (@w{(relation @sc{logic-object})} @w{(arg @sc{object})} @w{(value @sc{object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{proposition} 
Retract that the proposition (@var{relation} @var{arg} @var{value}) is TRUE
in @var{module}.  Return the asserted proposition.
@end deffn

@deffn Function retract-nary-proposition (@w{(relation-and-arguments @sc{object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{proposition} 
Retract the proposition that @code{arguments} satisfies
the relation @code{relation}.
@end deffn

@deffn Function retract-proposition (@w{(proposition @sc{proposition})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{proposition} 
Retract the truth of the proposition @var{proposition} in @var{module}.
Return the retracted proposition.
@end deffn

@deffn Function retract-unary-proposition (@w{(relation @sc{logic-object})} @w{(arg @sc{object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{proposition} 
Retract that the proposition (@var{relation} @var{arg}) is TRUE in @var{module}.  Return the asserted proposition.
@end deffn

@deffn Function retrieve (@w{(query @sc{cons})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{pl-iterator} 
Returns an iterator of variable bindings that when substituted for the
open variables in @var{query} satisfy the query proposition.  The query is
run in @var{module} and relative to @var{environment}.  @var{query} has the same syntax
as the PowerLoom @code{retrieve} command (which see) but with the @code{retrieve}
operator omitted.    For example, here are some legal @var{query} arguments:

@example 
    ((happy ?x))
    (10 (happy ?x))
    (all (happy ?x))
    (all ?x (happy ?x))
    (10 (happy ?x) :inference-level :assertion)
    (10 (happy ?x) :inference-level :assertion :timeout 1.0)
@end example

If there is only a single output variable (as in all the examples above)
each element generated by the returned iterator will be a binding for
that variable - unless, the output variable was declared with a surrounding
pair of parentheses.  For example:

@example 
    (all (?x) (happy ?x))
@end example

In that case, the generated elements will be one-element lists.  If there
are multiple output variables, each element generated by the returned
iterator will be a list of variable bindings that can be accessed using
the various @code{get-nth-...} functions.  The list of output variables does
not need to be declared in which case they are taken to be the open variables
in the query proposition in the order in which they were encountered.  If
order does matter or should be different from its default, it can be forced
by declaring the set of output variables.
@end deffn

@deffn Function run-forward-rules (@w{(module @sc{object})} @w{(force? @sc{boolean})}) : 
Run forward inference rules in module @var{module}.
If @var{module} is NULL, the
current module will be used.  If forward inferencing is already up-to-date
in the designated module, no additional inferencing will occur, unless @code{force}
is set to TRUE, in which case all forward rules are run or rerun.

Calling @code{run-forward-rules} temporarily puts the module into a mode where
future assertional (monotonic) updates will trigger additional forward
inference.  Once a non-monotonic update is performed, i.e., a retraction
or clipping of relation value, all cached forward inferences will be discarded
and forward inferencing will be disabled until this function is
called again.
@end deffn

@deffn Function s-ask (@w{(query @sc{string})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{truth-value} 
Returns a truth value for @var{query} in module @var{module-name} and @var{environment}.
@var{query} has the same syntax as the PowerLoom @code{ask} command (which see) but
with the @code{ask} operator omitted.  Different from the PLI @code{ask} function, @code{s-ask}
does not expect a top-level pair of parentheses.  For example, here are some legal
@var{query} arguments:

@example 
    "(happy Fred)"
    "(happy Fred) :inference-level :assertion"
    "(happy Fred) :inference-level :assertion :timeout 1.0"
@end example

Names in @var{query} will be interpreted relative to module @var{module-name}.
A null @var{module-name} or the empty string refers to the current module.
If no module can be found with the name @var{module-name}, then a STELLA
@code{no-such-context-exception} is thrown.
The returned truth value represents the logical truth of the queried sentence
as determined by PowerLoom.  It can be be tested via the functions @code{is-true},
@code{is-false} and @code{is-unknown} (which see).
@end deffn

@deffn Function s-assert-proposition (@w{(sentence @sc{string})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{(pl-iterator of proposition)} 
Assert that the logical sentence @var{sentence} is true in the module
named @var{module-name}.  A module name of @code{null} or the empty string refers to the
current module.  If no module can be found with the name @var{module-name},
then a Stella @code{no-such-context-exception} is thrown.

Return an iterator of the propositions resulting from sentence.
@end deffn

@deffn Function s-change-module (@w{(name @sc{string})} @w{(environment @sc{environment})}) : @sc{module} 
Set the current module to the module named @var{name}.
The return value is the module named @var{name} unless @var{name} is null or
the empty string.  In that case, the current module is returned.
If no module named @var{name} exists, a Stella @code{no-such-context-exception}
is thrown.
@end deffn

@deffn Function s-clear-module (@w{(name @sc{string})} @w{(environment @sc{environment})}) : @sc{module} 
Destroy the contents of the module named @var{name}, as
well as the contents of all of its children, recursively.  If no module
named @var{name} exists, a Stella @code{no-such-context-exception} is thrown.
@end deffn

@deffn Function s-conceive (@w{(sentence @sc{string})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{(pl-iterator of proposition)} 
Create one or more proposition objects from the sentence @var{sentence}
in the  module named @var{module-name}.  Return an iterator of the propositions.
If any of the new propositions has the same structure as an already existing
proposition, an automatic check for duplicates will return the pre-existing
proposition.  Multiple propositions may be returned for a single sentence
because of normalization of equivalences, conjunctions, etc.

A module name of @code{null} or the empty string refers to the current module.
If no module can be found with the name @var{module-name}, then a Stella
@code{No-Such-Context-Exception} is thrown.

Signals a @code{Proposition-Error} if PowerLoom could not conceive @var{sentence}.
@end deffn

@deffn Function s-create-concept (@w{(name @sc{string})} @w{(parent-name @sc{string})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{logic-object} 
Create a concept named @var{name} in the designated module, with
with the concept named @var{parent-name} as superconcept (which can be left
undefined).  Additional superconcepts can be added via assertions of the
@code{subset-of} relation.  Note that a specified parent concept needs to be
created separately.

A module name of @code{null} or the empty string refers to the current module. 
If no module can be found with the name @var{module-name}, then a Stella 
@code{no-such-context-exception} is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match @var{name} exactly.
@end deffn

@deffn Function s-create-function (@w{(name @sc{string})} @w{(arity @sc{integer})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{logic-object} 
Create a function named @var{name} with arity @var{arity} in the designated 
module.  Domain and range information can be added via assertions of
@code{domain}, @code{nth-domain} and @code{range} relations.

A module name of @code{null} or the empty string refers to the current module. 
If no module can be found with the name @var{module-name}, then a Stella 
@code{no-such-context-exception} is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match @var{name} exactly.
@end deffn

@deffn Function s-create-object (@w{(name @sc{string})} @w{(concept-name @sc{string})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{logic-object} 
Create an object named @var{name} of type @var{concept-name} in the designated
module.  Both @var{name} and @var{concept-name} can be null strings.  If @var{name} is a null string
then an object will be created with a new, non-conflicting name based on @var{concept-name}, or
system-generated if no concept nameis specified.  If @var{concept-name} is the null string, then
the object will be of type THING.

A module name of @code{null} or the empty string refers to the current module. 
If no module can be found with the name @var{module-name}, then a Stella 
@code{no-such-context-exception} is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match @var{name} exactly.

Return the object.
@end deffn

@deffn Function s-create-module (@w{(name @sc{string})} @w{(parent-name @sc{string})} @w{(case-sensitive? @sc{boolean})} @w{(environment @sc{environment})}) : @sc{module} 
Creates a new module @var{name} as a child of @var{parent-name}.  The flag
@var{case-sensitive?} controls whether names read in this module will be
case sensitive or not.
@end deffn

@deffn Function s-create-relation (@w{(name @sc{string})} @w{(arity @sc{integer})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{logic-object} 
Create a relation named @var{name} with arity @var{arity} in the
designated module.  Domain and range information can be added via assertions
of @code{nth-domain} (or @code{domain} and @code{range}) relations.

A module name of @code{null} or the empty string refers to the current module. 
If no module can be found with the name @var{module-name}, then a Stella 
@code{no-such-context-exception} is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match @var{name} exactly.
@end deffn

@deffn Function s-destroy-object (@w{(object-name @sc{string})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : 
Delete the object named @var{object-name}, retracting all facts
attached to it.

A module name of @code{null} or the empty string refers to the current module. 
If no module can be found with the name @var{module-name}, then a Stella 
@code{no-such-context-exception} is thrown.
@end deffn

@deffn Function s-evaluate (@w{(command @sc{string})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{object} 
Evaluate the command represented by the string @var{command} within @code{module} and
return the result.  Currently, only the evaluation of (possibly nested) commands and
global variables is supported.

 A module name of @code{null} or the empty string refers to the
current module.  If no module can be found with the name @var{module-name},
then a Stella @code{no-such-context-exception} is thrown.
@end deffn

@deffn Function s-get-arity (@w{(relation-name @sc{string})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{integer} 
Return the arity of the relation named @var{relation-name}.

 A module name of @code{null} or the empty string refers to the
current module.  If no module can be found with the name @var{module-name},
then a Stella @code{no-such-context-exception} is thrown.
@end deffn

@deffn Function s-get-child-modules (@w{(name @sc{string})} @w{(environment @sc{environment})}) : @sc{(pl-iterator of module)} 
Return the modules that are immediate children of module @var{name}.
If no module named @var{name} exists, a Stella @code{no-such-context-exception}
is thrown.
@end deffn

@deffn Function s-get-concept (@w{(name @sc{string})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{logic-object} 
Return a class/concept named @var{name} that is local to
or visible from the module @var{module-name}.  A module name of @code{null} or the
empty string refers to the current module.  If no module can be found
with the name @var{module-name}, then a Stella @code{no-such-context-exception} is thrown.
@end deffn

@deffn Function s-get-concept-instances (@w{(concept-name @sc{string})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{pl-iterator} 
Return instances of concept @var{concept-name}.
Include instances of subconcepts of @var{concept-name}.  Depending on @var{concept-name},
the return values could be (wrapped) literals.

A module name of @code{null} or the empty string refers to the current module. 
If no module can be found with the name @var{module-name}, then a Stella 
@code{no-such-context-exception} is thrown.
@end deffn

@deffn Function s-get-direct-concept-instances (@w{(concept-name @sc{string})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{pl-iterator} 
Return instances of concept @var{concept-name}.
Exclude instances of subconcepts of @var{concept-name}.  Depending on @var{concept-name},
the return values could be (wrapped) literals.

A module name of @code{null} or the empty string refers to the current module. 
If no module can be found with the name @var{module-name}, then a Stella 
@code{no-such-context-exception} is thrown.
@end deffn

@deffn Function s-get-domain (@w{(relation-name @sc{string})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{logic-object} 
Return the type (concept) for the first argument to the binary
relation @var{relation-name}.

A module name of @code{null} or the empty string refers to the
current module.  If no module can be found with the name @var{module-name},
then a Stella @code{no-such-context-exception} is thrown.
@end deffn

@deffn Function s-get-inferred-binary-proposition-values (@w{(relation-name @sc{string})} @w{(arg-name @sc{string})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{pl-iterator} 
Return all values @code{v} such that (@var{relation-name} @var{arg-name} @code{v})
has been asserted or can be inferred.

A module name of @code{null} or the empty string refers to the current module. 
If no module can be found with the name @var{module-name}, then a Stella 
@code{no-such-context-exception} is thrown.
@end deffn

@deffn Function s-get-nth-domain (@w{(relation-name @sc{string})} @w{(n @sc{integer})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{logic-object} 
Return the type (a concept) for the nth argument of the relation
named @var{relation-name}.  Counting starts at zero.

A module name of @code{null} or the empty string refers to the
current module.  If no module can be found with the name @var{module-name},
then a Stella @code{no-such-context-exception} is thrown.
@end deffn

@deffn Function s-get-object (@w{(name @sc{string})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{object} 
Look for an object named @var{name} that is local to
or visible from the module @var{module-name}.  A module name of @code{null} or the
empty string refers to the current module.  If no module can be found
with the name @var{module-name}, then a Stella @code{no-such-context-exception} is thrown.
@end deffn

@deffn Function s-get-parent-modules (@w{(name @sc{string})} @w{(environment @sc{environment})}) : @sc{(pl-iterator of module)} 
Return the modules that are immediate parents of module @var{name}.
If no module named @var{name} exists, a Stella @code{no-such-context-exception}
is thrown.
@end deffn

@deffn Function s-get-parent-modules (@w{(name @sc{string})} @w{(environment @sc{environment})}) : @sc{(pl-iterator of module)} 
Return the modules that are immediate parents of module @var{name}.
If no module named @var{name} exists, a Stella @code{no-such-context-exception}
is thrown.
@end deffn

@deffn Function s-get-proposition (@w{(relation-and-arguments @sc{string})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{proposition} 
Return a proposition matching @var{relation-and-arguments} that
has been asserted (or inferred by forward chaining).  @var{relation-and-arguments}
is a string that begins with a left parenthesis, followed by a relation name, 
one or more argument identifiers, and terminated by a right parenthesis.  Each
argument identifier can be the name of a logical constant, a literal
reference (e.g., a number), the null identifier, or a variable (an identifier that begins
with a question mark). Each occurrence of a null or a variable acts like a wild card.
If more than one proposition matches the input criteria, the selection among
satisficing propositions is arbitrary.  This procedure is normally applied to
single-valued relations or functions.

A module name of @code{null} or the
empty string refers to the current module.  If no module can be found
with the name @var{module-name}, then a Stella @code{no-such-context-exception} is thrown.
@end deffn

@deffn Function s-get-propositions (@w{(relation-and-arguments @sc{string})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{(pl-iterator of proposition)} 
Return propositions matching @var{relation-and-arguments} that
have been asserted (or inferred by forward chaining).  @var{relation-and-arguments}
is a string that begins with a left parenthesis, followed by a relation name, 
one or more argument identifiers, and terminated by a right parenthesis.  Each
argument identifier can be the name of a logical constant, a literal 
reference (e.g., a number), the null identifier, or a variable (an identifier that begins
with a question mark). Each occurrence of a null or a variable acts like a wild card.

A module name of @code{null} or the
empty string refers to the current module.  If no module can be found
with the name @var{module-name}, then a Stella @code{no-such-context-exception} is thrown.
@end deffn

@deffn Function s-get-propositions-of (@w{(object-name @sc{string})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{(pl-iterator of proposition)} 
Return all propositions that have the object named @var{object-name} among
their arguments, and that are TRUE in the scope of the module @var{module-name}.
A module name of @code{null} or the empty string refers to the current module. 
If no module can be found with the name @var{module-name}, then a Stella 
@code{no-such-context-exception} is thrown.
@end deffn

@deffn Function s-get-range (@w{(relation-name @sc{string})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{logic-object} 
Return the type (a concept) for fillers of the binary relation
@var{relation-name}.

A module name of @code{null} or the empty string refers to the
current module.  If no module can be found with the name @var{module-name},
then a Stella @code{no-such-context-exception} is thrown.
@end deffn

@deffn Function s-get-relation (@w{(name @sc{string})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{logic-object} 
Return a concept or relation named @var{name} that is local to
or visible from the module @var{module-name}.  A module name of @code{null} or the
empty string refers to the current module.  If no module can be found
with the name @var{module-name}, then a Stella @code{no-such-context-exception} is thrown.
@end deffn

@deffn Function s-get-relation-extension (@w{(relation-name @sc{string})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{(pl-iterator of proposition)} 
Return propositions that satisfy the relation named
@var{relation-name}.  Include propositions that satisfy subrelations of the relation.
@end deffn

@deffn Function s-get-rules (@w{(relation-name @sc{string})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{(pl-iterator of proposition)} 
Return rules attached to the concept/relation named
@var{relation-name} found in the module named @var{module-name}.

A module name of @code{null} or the empty string refers to the current module.
If no module can be found with the name @var{module-name}, then a Stella
@code{No-Such-Context-Exception} is thrown.
@end deffn

@deffn Function s-is-true-proposition (@w{(relation-and-arguments @sc{string})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{boolean} 
Return TRUE if a proposition that prints as the string
@var{relation-and-arguments} is true in the module named @var{module-name}.
A module name of @code{null} or the empty string refers to the current module. 
If no module can be found with the name @var{module-name}, then a Stella 
@code{no-such-context-exception} is thrown.
@end deffn

@deffn Function s-print-rules (@w{(name @sc{string})} @w{(stream @sc{output-stream})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : 
Print rules attached to the concept/relation named @var{name}.

A module name of @code{null} or the empty string refers to the
current module.  If no module can be found with the name @var{module-name},
then a Stella @code{no-such-context-exception} is thrown.
@end deffn

@deffn Function s-retract-proposition (@w{(sentence @sc{string})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{(pl-iterator of proposition)} 
Retract the truth of the logical sentence @var{sentence} in the module named
@var{module-name}.  A module name of @code{null} or the empty string refers to the
current module.  If no module can be found with the name @var{module-name},
then a Stella @code{no-such-context-exception} is thrown.

Return an iterator of the retracted propositions resulting from sentence.
@end deffn

@deffn Function s-retrieve (@w{(query @sc{string})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : @sc{pl-iterator} 
Returns an iterator of variable bindings that when substituted for the
open variables in @var{query} satisfy the query proposition.  The query is
run in @code{module} and relative to @var{environment}.  @var{query} has the same syntax
as the PowerLoom @code{retrieve} command (which see) but with the @code{retrieve}
operator omitted.  Different from the PLI @code{retrieve} function, @code{s-retrieve}
does not expect a top-level pair of parentheses.  For example, here are some
legal @var{query} arguments:

@example 
    "(happy ?x)"
    "10 (happy ?x)"
    "all (happy ?x)"
    "all ?x (happy ?x)"
    "10 (happy ?x) :inference-level :assertion"
    "10 (happy ?x) :inference-level :assertion :timeout 1.0"
@end example

If there is only a single output variable (as in all the examples above)
each element generated by the returned iterator will be a binding for
that variable - unless, the output variable was declared with a surrounding
pair of parentheses.  For example:

@example 
    "all (?x) (happy ?x)"
@end example

In that case, the generated elements will be one-element lists.  If there
are multiple output variables, each element generated by the returned
iterator will be a list of variable bindings that can be accessed using
the various @code{get-nth-...} functions.  The list of output variables does
not need to be declared in which case they are taken to be the open variables
in the query proposition in the order in which they were encountered.  If
order does matter or should be different from its default, it can be forced
by declaring the set of output variables.

Names in @var{query} will be interpreted relative to module @var{module-name}.
A null @var{module-name} or the empty string refers to the current module.
If no module can be found with the name @var{module-name}, then a STELLA
@code{no-such-context-exception} is thrown.
@end deffn

@deffn Function s-save-module (@w{(module-name @sc{string})} @w{(filename @sc{string})} @w{(ifexists @sc{string})} @w{(environment @sc{environment})}) : 
Save the contents of the module @var{module-name} into a file named @var{filename}.
If a file named @var{filename} already exists, then the action taken depends on the
value of @var{ifexists}.  Possible values are "ASK", "REPLACE", "WARN" and "ERROR":

  REPLACE => Means overwrite without warning.
  WARN    => Means overwrite with a warning.
  ERROR   => Means don't overwrite, signal an error instead.
  ASK     => Ask the user whether to overwrite or not.  If not overwritten, an
             exception is thrown.

A module name of @code{null} or the empty string refers to the
current module.  If no module can be found with the name @var{module-name},
then a Stella @code{no-such-context-exception} is thrown.
@end deffn

@deffn Function save-module (@w{(module @sc{module})} @w{(filename @sc{string})} @w{(ifexists @sc{string})} @w{(environment @sc{environment})}) : 
Save the contents of the module @code{mod} into a file named @var{filename}.
If a file named @var{filename} already exists, then the action taken depends on the
value of @var{ifexists}.  Possible values are "ASK", "REPLACE", "WARN" and "ERROR":

  REPLACE => Means overwrite without warning.
  WARN    => Means overwrite with a warning.
  ERROR   => Means don't overwrite, signal an error instead.
  ASK     => Ask the user whether to overwrite or not.  If not overwritten, an 
             exception is thrown.
@end deffn

@deffn Function string-to-object (@w{(string @sc{string})} @w{(type @sc{logic-object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{object} 
Evaluate @var{string} with respect to @var{module} and @var{environment}
and return the corresponding logical term.  @var{type} is a concept used to assist the
correct interpretation of @var{string}.

Currently @var{type} only has an effect on the interpretation of literal types.
@end deffn



@node Language Specific Interface,  , API Functions, PowerLoom API
@section Language Specific Interface

This section contains the description of the programming language
specific aspects of using the PowerLoom API.  Each section describes the 
naming conventions and namespace issues related to calling the API
functions from that programming language.

@menu
* Lisp API::                    
* C++ API::                     
* Java API::                    
@end menu

@node Lisp API, C++ API, Language Specific Interface, Language Specific Interface
@subsection Lisp API

This section tells how to call the API functions in PowerLoom's Common
Lisp implementation from a Lisp program.  The function names are
identical to the Stella names in the PowerLoom API description
@xref{PowerLoom API}.  They are exported from the @code{PLI} package.
Other Stella symbols and names are in the @code{STELLA} package, but
@strong{currently none of the Stella symbols are exported!}.

PowerLoom can be used from Allegro Common Lisp, CMU Common Lisp,
LispWorks Common Lisp and Macintosh Common Lisp.  It may be possible to
use the system from other Common Lisp systems, but they have not been
tested.

@menu
* Initialization::              
* Type Declarations::           
* NULL Values::                 
* Wrapped Literal Values::      
* Special Variables::           
* CLOS Objects versus Structs::  
@end menu

@node Initialization, Type Declarations, Lisp API, Lisp API
@subsubsection Common Lisp Initialization

Loading the Common Lisp version of PowerLoom will normally initialize
the system as part of the loading process.  The Common Lisp version can
be loaded by loading the file @file{load-powerloom.lisp} from the
top-level @file{powerloom} directory.  This will make the system
available for use.

@node Type Declarations, NULL Values, Initialization, Lisp API
@subsubsection Type Declarations

Stella is a typed language, and the Common Lisp translation uses the
type information for Common Lisp type declarations.  That means that
values specified as being of type INTEGER, STRING and FLOAT must have
the correct type.  In particular, integer values will not be coerced to
floating point values by the code.  The following native type
assignments are made:

@example
    Stella      Common Lisp
    =======     ===========
    INTEGER     FIXNUM
    FLOAT       DOUBLE-FLOAT
    STRING      SIMPLE-STRING
@end example

@strong{For convenience, loading PowerLoom will set the default format for
reading floating point numbers in Common Lisp to be @code{double-float}.}

Stella @code{CONS} objects are implmented as native Lisp conses.
Boolean values can take on the values @code{stella::true} or
@code{stella::false}.

@node NULL Values, Wrapped Literal Values, Type Declarations, Lisp API
@subsubsection NULL values

One additional consequence of the strong typing of the language is that
there are specialized @code{NULL} values for numeric and string parameters.

@example
  Stella Type   Null Value
  ===========   ===========
    INTEGER     stella::null-integer
    FLOAT       stella::null-float
    STRING      stella::null-string
@end example

@node Wrapped Literal Values, Special Variables, NULL Values, Lisp API
@subsubsection Wrapped Literal Values

Literal values (integers, floats, strings, etc.) that are used in
PowerLoom appear as wrapped values.  The PowerLoom API functions
@code{object-to-...} can be used to coerce the values into the
appropriate return type.

<to be written:  wrapping values>

@node Special Variables, CLOS Objects versus Structs, Wrapped Literal Values, Lisp API
@subsubsection Special Variables

All Stella special variables are implemented as Common Lisp special
variables.  Binding of the values can be used normally.

@node CLOS Objects versus Structs,  , Special Variables, Lisp API
@subsubsection CLOS Objects versus Structs

PowerLoom can be translated in one of two ways for Common Lisp.  One
method uses CLOS objects as the basis for all Stella and PowerLoom
objects.  For faster execution, it is also possible to use a version in
which Stella and PowerLoom objects are implemented using Common Lisp
structs instead.  This is controlled by the special variable 
@code{cl-user::*load-cl-struct-stella?*}.  If this is set to
@code{cl:t}, then the struct version will be loaded.  This needs to be
set before loading the @file{load-powerloom.lisp} file.

@node C++ API, Java API, Lisp API, Language Specific Interface
@subsection C++ API

<to be written>


@node Java API,  , C++ API, Language Specific Interface
@subsection Java API

This section tells how to call the API functions in PowerLoom's Java
implementation from a Java program.  The Java translation is written for
Java version 1.2.  All of the PowerLoom Interface functions appear as
static methods of the class @code{edu.isi.powerloom.PLI}.

@menu
* Initializing PowerLoom::      
* PowerLoom Java Conventions::  
* Using the PLI Class::         
* Using Stella Objects::        
* PowerLoom and Threads::       
* Setting and Restoring Global Variable Values::  
* Java Character Mapping::      
* Stella Exceptions in Java::   
* Iteration in Java::           
* Utility Classes for Java::    
@end menu

@node Initializing PowerLoom, PowerLoom Java Conventions, Java API, Java API
@subsubsection Initializing PowerLoom

PowerLoom needs to run initialization functions to set up its
environment for proper operation when it starts up.  The simplest method 
for initializing PowerLoom is to use the static method call:

@example
        PLI.initialize()
@end example

This must be called before using any PowerLoom features and before
loading any PowerLoom knowledge bases.  It may be called more than once
without ill effect.

@node PowerLoom Java Conventions, Using the PLI Class, Initializing PowerLoom, Java API
@subsubsection PowerLoom Java Conventions

PowerLoom's Java code is automatically generated by a translator from
underlying Stella code.  The character set for legal Stella names is larger
than the character set for legal Java identifiers, so there is some mapping
involved.

PowerLoom names are words separated by hyphen (-) characters.  For Java,
we have attempted to closely follow the Java conventions:

@itemize
@item
Class names begin with a capital letter and each word is capitalized.
The hyphens from the PowerLoom names are removed.  Example:
@example
        string-wrapper   =>  StringWrapper
@end example
   Exceptions are made for class names that would otherwise conflict with
   normal Java Classes.  In that case, the prefix "Stella_" is added to each
   class name.  At the moment this applies only to the following exceptions:
@example
        object    =>  Stella_Object
        class     =>  Stella_Class
@end example

@item
Method and Function names begin with a lower case letter but each
subsequent word is capitalized.  The hyphens from PowerLoom names are
removed.  Example:
@example
        wrapper-value    =>  wrapperValue
@end example

@item
Storage slots are implemented as Java fields.  The names begin with a
lower case letter but each subsequent word is capitalized.  The hyphens
from PowerLoom names are removed.  Example:
@example
        dynamic-slots    =>  dynamicSlots
@end example

@item
Global and Special variable names are written in all uppercase.  The
hyphens from PowerLoom are replaced by underscore (_) characters.  By
convention, special variables are written in PowerLoom with surrounding
asterisk (*) characters.  The asterisks are replaced by dollar signs ($).
Example:
@example
        *html-quoted-characters*  =>  $HTML_QUOTED_CHARACTERS$
@end example
@end itemize

The most common non-alphanumeric characters are mapped as follows.  A
full set of mappings is in section @ref{Java Character Mapping}.
@example
   ?  =>  P      (for Predicate)
   !  =>  X      (eXclamation)
   $  =>  B      (Buck)
   %  =>  R      (peRcent)
   &  =>  A      (Ampersand)
   *  =>  $      Special variable marker.
@end example

The character mappings use uppercase characters if the basic identifier
uses mixed or lower case.  The mappings use lowercase characters if the
basic identifier uses upper case.

Stella modules are mapped to Java packages.  The basic system
distribution includes the following package hierarchy:

@example
  edu
     isi
        stella
            javalib
        powerloom
            logic
            pl_kernel_kb
                loom_api
@end example

Basic system functionality and data structures such as Cons and List
objects are defined in stella.  PowerLoom's logic (concepts,
relations, rules, etc.) are defined in the logic package.  There is a
set of interface functions in the PLI class in the powerloom package.
They are described in their own section below.

We recommend the following import statements in Java files that use
PowerLoom:
@example
        import edu.isi.stella.*;
        import edu.isi.stella.javalib.*;
        import edu.isi.powerloom.PLI;
        import edu.isi.powerloom.logic.*;
@end example

Functions (in Java terms, static Methods) are translated as static methods
on the class of their first argument (as long as that argument is not a
primitive type and is in the same Stella module).  Functions which take no
arguments, those whose first argument is a primitive type, and those whose
first argument is a class not defined in the same module are all placed
into a class with the same name as the Stella module in which it appers.
It will be in the package corresponding to that Stella module.  Java
constructors should not be called directly.  Instead, there will be a
static method @code{new<ClassName>} (with the class name in mixed case!) that
should be used instead.

Most of the functions of interest will be in the edu.isi.stella.Stella, 
edu.isi.powerloom.PLI or edu.isi.powerloom.logic.Logic classes.

Methods typically refer to their first argument as "self".

Methods which return more than one return value will take a final
argument which is an array of @code{Stella_Object}, which will be used to
return the additional arguments.

Primitive types in Stella have the following mapping in Java:
@example
        Stella          Java
        ======          ====
        INTEGER         int
        FLOAT           double
        NUMBER          double
        CHARACTER       char
        BOOLEAN         boolean
        STRING          String
        MUTABLE-STRING  StringBuffer

  NATIVE-OUTPUT-STREAM  java.io.PrintStream
  NATIVE-INPUT-STREAM   java.io.PushbackInputStream  (May change!!!)
@end example

Inside Stella/PowerLoom objects and collections, primitive types are
wrapped using Stella wrappers instead of Java's primitive classes.  So
integers will be wrapped as edu.isi.stella.IntegerWrapper rather than
java.lang.Integer.  Wrappers have a field called wrapperValue which
accesses the internal value.  Example of use:

@example
    import edu.isi.stella.*;
    import edu.isi.stella.javalib.*;
    ...
    IntegerWrapper iWrap = IntegerWrapper.wrapInteger(42);
    ...
    int answer = iWrap.wrapperValue;
    ...
@end example

@node Using the PLI Class, Using Stella Objects, PowerLoom Java Conventions, Java API
@subsubsection Using the PLI Class

To make interoperability between PowerLoom and Java a little simpler, we
are providing a (PowerLoom Interface class named @code{PLI} which
handles synchronization issues, setting and restoring the reasoning
context, and the a more convenient use of some Java-native objects
rather than Stella objects.  Generally that means that strings are used
for PowerLoom expressions and return values rather than Stella
@code{Cons} objects.

Details about the methods can be found in the section @ref{PowerLoom
API}.  The names of functions in that section will need to be converted
to their Java equivalents using the conventions described in
@ref{PowerLoom Java Conventions}.  We also provide javadoc
documentation for the @code{edu.isi.powerloom.PLI} class.  We recommend
using this method for accessing PowerLoom functionality.  We expect to
expand the range of PowerLoom interface functions that have an analog in
the @code{PLI} class over time.

@node Using Stella Objects, PowerLoom and Threads, Using the PLI Class, Java API
@subsubsection Using Stella Objects

Stella objects can also be used directly.  The most common ones used by
PowerLoom users are @code{Module} and @code{LogicObject}.  Other
potentially useful Stella objects are @code{Cons}, @code{Symbol},
@code{Keyword} and @code{List}.  Except for @code{LogicObject}, these are in
the @code{edu.isi.stella} package.  @code{LogicObject} is in the
@code{edu.isi.powerloom.logic} package.

If one wishes to construct @code{Cons} objects (for example to create
objects to pass to interface functions, one would begin by building
items up using @code{Stella_Object.cons} static method, which takes a
stella object and a cons.  The empty cons is kept in the
@code{edu.isi.stella.Stella.NIL} static variable.  Another way to create
stella objects is to use @code{edu.isi.stella.Stella.unstringify} static
method.  This method takes a string representation of a stella object
and returns the object.  If passed a list, an object of type @code{Cons}
will be returned.

As an alternative, one can also convert one and two dimensional arrays
of @code{Stella_Object} into @code{Cons} objects using the overloaded
function @code{edu.isi.stella.javalib.arrayToCons}.  These functions
will return @code{Cons} objects constructed from the input arrays.

Keywords and symbols are objects that are stored in global static
variables.  The variable names are all in upper case and are constructed
by concatenating the tag SYM with the module name and the name of the
symbol or concatenating the tag KWD with the name of the keyword.  For
example, the symbol BACKWARD in the logic module would be stored in

@example
        edu.isi.powerloom.logic.Logic.SYM_LOGIC_BACKWARD
@end example

whereas the keyword :ERROR in the stella module would be in

@example
        edu.isi.stella.Stella.KWD_ERROR
@end example


@node PowerLoom and Threads, Setting and Restoring Global Variable Values, Using Stella Objects, Java API
@subsubsection PowerLoom and Threads

The most important consideration when using PowerLoom in a threaded
environment is that the core of PowerLoom must not execute in
concurrently running threads.  The PLI class takes care of this for
interface functions that run through that class.  Other PowerLoom
functions that are called need to synchronize on a lock object

@example
        edu.isi.powerloom.logic.Logic.$POWERLOOM_LOCK$
@end example

for proper operation.  This is not needed for setting Special Variables,
since they are implemented on a per-thread basis.  The most important
special variable is the reasoning context.  @xref{Setting and
Restoring Global Variable Values}.


@node Setting and Restoring Global Variable Values, Java Character Mapping, PowerLoom and Threads, Java API
@subsubsection Setting and Restoring Global Variable Values

As noted above, special variables in Stella are implemented as static
fields in a catchall class named the same as the Stella module.  It will
be in the java package corresponding to that Stella module.  The values
of Special variables are stored in Java objects of the type
@code{StellaSpecialVariable}, a subclass of Java's @code{InheritableThreadLocal}.  Any
changes made to the values will not affect any other running threads.
This means that the changes don't need to be synchronized.  Note that
global (as opposed to special) variables don't use these objects.

Numbers and boolean values are stored in special variables using the
corresponding Java classes @code{Integer}, @code{Double},
@code{Boolean}, etc.  The naming convention is to have all upper case
letters with a dollar sign ($) at the beginning and end of the name.

To temporarily change the value of one of these variables, users will
need to be responsible for saving and restoring the old values.  Use of
the "@code{try ... finally ...}" construct is very useful for this, since it
guarantees that the restore of values will be done.  An example follows
of how to safely change modules.  Contexts should be changed using the
functions, although other global variables can be changed by using the
set method.  Note that we use variables of type Object to hold the
values, since that avoids the need to cast when extracting the current
value, since the only operation we do with the current value is save it
to restore it later.

@example
   import edu.isi.stella.*;

   // CONTEXT CHANGE.
   Object savedModule = Stella.$MODULE$.get();
   Module newModule
      = Stella.getStellaModule(contextName, true);
   if (newModule == null) @{ // Handle missing module
   @}
   try @{
     Module.changeCurrentModule(newModule)
     // Code that uses the newModule

   @} finally @{
     Module.changeCurrentModule(savedModule);
   @}


   // INTEGER VALUE CHANGE:
   Object savedValue = Stella.$SAFETY$.get();
   try @{
     Stella.$SAFETY$.set(new Integer(3));
     // Code that uses the newModule

   @} finally @{
     Stella.$SAFETY$.set(savedValue);
   @}


   // BOOLEAN VALUE CHANGE:
   Object savedValue = Stella.$PRINTREADABLY$.get();
   try @{
     Stella.$PRINTREADABLY$.set(Boolean.TRUE);
     // Code that uses the newModule

   @} finally @{
     Stella.$PRINTREADABLY$.set(savedValue);
   @}
@end example

The need to change the module using this type of code can be largely
avoided by using the functions in the PLI interface package.  They take
a module argument and can handle the binding and restoration of the
module value themselves.

@node Java Character Mapping, Stella Exceptions in Java, Setting and Restoring Global Variable Values, Java API
@subsubsection Java Character Mapping

The full Stella to Java character mapping is the following. The
character mappings use uppercase characters if the basic identifier uses
mixed or lower case.  The mappings use lowercase characters if the basic
identifier uses upper case.

@example
   Stella  Java     Mnemonic
   ======  ====     ========
     !   =>  X      (eXclamation)
     "   =>  _
     #   =>  H      (Hash)
     $   =>  B      (Buck)
     %   =>  R      (peRcent)
     &   =>  A      (Ampersand)
     '   =>  Q      (Quote)
     (   =>  _
     )   =>  _
     *   =>  $
     +   =>  I      (Increase)
     ,   =>  _
     -   =>  _
     .   =>  D      (Dot)
     /   =>  S      (Slash)
     :   =>  C      (Colon)
     ;   =>  _
     <   =>  L      (Less than)
     =   =>  E      (Equal)
     >   =>  G      (Greater than)
     ?   =>  P      (Predicate)
     @@   =>  M      (Monkey tail)
     [   =>  J      (Arbitrary (array index?))
     \   =>  _
     ]   =>  K      (Arbitrary (array index?)
     ^   =>  U      (Up arrow)
     `   =>  _
     @{   =>  Y      (Arbitrary (adjacent free letter))
     |   =>  V      (Vertical bar)
     @}   =>  Z      (Arbitrary (adjacent free letter))
     ~   =>  T      (Tilde)
<space>  => _
@end example

@node Stella Exceptions in Java, Iteration in Java, Java Character Mapping, Java API
@subsubsection Stella Exceptions in Java 

Stella exceptions are implemented as a subtype of @code{java.lang.Exception}
(actually @code{RunTimeException}) and may be caught normally.  All Stella
Exceptions belong to the @code{edu.isi.stella.StellaException} class or one of
its subclasses.  The more specfic PowerLoom exceptions belong to the
@code{edu.isi.powerloom.logic.LogicException} class or one of its subclasses.

Exceptions thrown during I/O operations will not use the standard Java
exceptions.  Instead, they will descend from
@code{edu.isi.stella.InputOutputException}.  The most useful
descendents are @code{edu.isi.stella.NoSuchFileException} and
@code{edu.isi.stella.EndOfFileException}.

@node Iteration in Java, Utility Classes for Java, Stella Exceptions in Java, Java API
@subsubsection Iteration in Java

Iteration in Stella (and by extension) PowerLoom is organized a little
bit differently than in Java.  You can either use the Stella iterators
directly, or else use one of the wrapper classes described in the
section @ref{Utility Classes for Java}.  It will present a more
familiar Java interface.  Since the iteration models are a bit
different, it would be unwise to mix accesses between the iteration
models.

Stella iterators do not compute any values until the next? method (in
Java: @code{nextP}) is called.  This method will try to compute the next
value of the iterator and it will return a boolean value which is true
if more values are present.  Each time it is called, the iteration
advances.  Values can be read out of the value field of the iterator,
which will have type @code{Stella_Object}.  Some iterators will also
have a key field which can be read.

The way one would normally use a Stella iterator is as follows, with
possible casting of the value field:

@example
    Stella.Iterator iter = ...;

    while (iter.nextP()) @{
        processValue(iter.value);
    @}
@end example

The PLI class also contains a number of functions for simplifying the
interaction with @code{PlIterator} objects that are returned by various
API functions.  These are the @code{getNth...} functions.  They work
on sequences and sequence-like objects such as @code{Proposition} and
and the value slot of @code{PlIterator} objects.  Note that they do
not return sequential elements of the iterator, but rather elements
of the implicit sequence that is the value of iterators that have
more than one return variable.  For convenience, they also work (with
index = 0) on the value of @code{PlIterator} objects that have only a
single return variable.  For example:

@example
    // Get values of (object name age) in the iterator and then
    // print out a message with the name and age (position 1 & 2).
    // This skips the PowerLoom object bound to ?X in position 0.
    PlIterator iter = 
        PLI.sRetrieve("all (and (name ?x ?name) (age ?x ?age))",
                      null,
                      null);

    while (iter.nextP()) @{
        System.out.println(PLI.getNthString(iter, 1, null, null) + " is " +
                           PLI.getNthInteger(iter, 2, null, null ) + " years old.");
    @}
@end example

@node Utility Classes for Java,  , Iteration in Java, Java API
@subsubsection Utility Classes for Java

To make interoperation of Stella and Java easier, there are several
convenience classes for wrapping Stella iterators and having them behave
like Java enumerations or iterators.  These convenience classes are in the
@code{edu.isi.stella.javalib} package:

@example  
  ConsEnumeration.java      Enumeration class for Cons objects
  ConsIterator.java         Iterator class for Cons objects
  StellaEnumeration.java    Enumeration interface to Stella's Iterator
  StellaIterator.java       Iterator interface to Stella's Iterator
@end example

All of the iterators and enumerators return objects that are actually of
type @code{Stella_Object}, but the signature specifies
@code{java.lang.Object} as required for compatibility with the standard
Java signature.  The @code{Cons...} classes take a @code{Cons} in their
constructor.  The @code{Stella...} classes take a
@code{edu.isi.stella.Iterator} object in their constructor.



@c ===========================================================================
 
@node Built-In Relations, Installation, PowerLoom API, Top
@chapter Built-In Relations

This chapter lists all of the relations that come predefined in PowerLoom. They
are defined in the module @code{PL-KERNEL}; users can access them by
including or using the @code{PL-KERNEL} module within the declarations of their
own modules.

@deffn Function * (@w{(?x @sc{number})} @w{(?y @sc{number})}) :-> @w{(?z @sc{number})}
Function that multiplies two numbers.
@end deffn

@deffn Function + (@w{(?x @sc{number})} @w{(?y @sc{number})}) :-> @w{(?z @sc{number})}
Function that adds two numbers.
@end deffn

@deffn Function - (@w{(?x @sc{number})} @w{(?y @sc{number})}) :-> @w{(?z @sc{number})}
Function that subtracts two numbers.
@end deffn

@deffn Function / (@w{(?x @sc{number})} @w{(?y @sc{number})}) :-> @w{(?z @sc{number})}
Function that divides two numbers.
@end deffn

@deffn Relation < (@w{(?x @sc{thing})} @w{(?y @sc{thing})})
True if ?x < ?y.
@end deffn

@deffn Relation =< (@w{(?x @sc{thing})} @w{(?y @sc{thing})})
True if ?x <= ?y.
@end deffn

@deffn Relation > (@w{(?x @sc{thing})} @w{(?y @sc{thing})})
True if ?x > ?y.
@end deffn

@deffn Relation >= (@w{(?x @sc{thing})} @w{(?y @sc{thing})})
True if ?x >= ?y.
@end deffn

@deffn Relation ABSTRACT (@w{(?r @sc{relation})})
True if there are no direct assertions made
to the relation ?r.
@end deffn

@deffn Concept AGGREGATE (@w{(?a @sc{aggregate})})
?a is an aggregate
@end deffn

@deffn Relation ANTISYMMETRIC (@w{(?r @sc{relation})})
A binary relation ?r is antisymmetric if whenever (?r ?x ?y)
is true (?r ?y ?x) is false unless ?x equals ?y.
@end deffn

@deffn Function ARITY (@w{(?r @sc{relation})}) :-> @w{(?arity @sc{integer})}
The number of arguments/domains of the relation @var{?r}.
@end deffn

@deffn Concept BINARY-RELATION (@w{(?r @sc{relation})})
The class of binary relations.
@end deffn

@deffn Relation BOUND-VARIABLES (@w{(?arguments @sc{thing})})
True if all arguments are bound.  The @code{bound-variables}
predicate is used as a performance enhancer, to prevent other predicates
from backchaining excessively while searching for bindings of certain of
their arguments. Purists will shun the use of this predicate, but some rules
are inherently inefficient without the addition of some kind of control logic.
Because evaluation of the @code{bound-variables} predicate evaluation of
predicates being @code{guarded}, using this predicate has the side-effect
of locally disabling query optimization.  (See @code{collect-into-set} for
an example that uses @code{bound-variables}.
@end deffn

@deffn Function CARDINALITY (@w{(?c @sc{set})}) :-> @w{(?card @sc{integer})}
Function that returns the cardinality of a set.
@end deffn

@c # $(util/texinfo-insert-doc /PL-KERNEL/case-match)
@c # $(util/texinfo-insert-doc /PL-KERNEL/cheap-disjoint)
@deffn Relation CLOSED (@w{(?c @sc{collection})})
The collection ?c is closed if all of its members are known.
Asserting that a relation is closed makes certain computations easier.
For example, suppose that the relation @code{happy} is closed,
implying that all things that are happy will be asserted as such.
To prove @code{(not (happy Fred))}, PowerLoom can use a negation-as-failure 
proof strategy which returns TRUE if @code{Fred} cannot be proved to be happy.
Also, if the relation @code{children} is closed, then a value for the expression
@code{(range-max-cardinality children Fred)} can be inferred merely by
counting the number of fillers of the @code{children} role on @code{Fred}.
@end deffn

@deffn Function COLLECT-INTO-SET (@w{(?c @sc{collection})}) :-> @w{(?l @sc{set})}
Infer as many members of ?c as possible and
collect them into a set ?l.  For example, here is a rule
used to compute bindings for the @code{fillers} predicate:

@example 
  (<= (fillers ?r ?i ?v)
      (and (bound-variables ?r ?i)
           (collect-into-set (setofall ?v (holds ?r ?i ?v)) ?members)))
@end example

When @code{?r} and @code{?i} are bound, the term @code{(setofall ?v (holds ?r ?i ?v))}
evaluates to a unary relation satisfied for each filler of the relation
in @code{?r} applied to the instance in @code{?i}.  @code{collect-into-set} causes
the extension of this (dynamically-defined) unary relation to be
computed.  Note the use of @code{bound-variables} to screen out unbound
variables before they are passed to the @code{setofall} predicate.
@end deffn

@deftp Class @sc{collection} : @sc{abstract-collection}
Not documented.
@defcv @w{Class Parameter} {} any-value : @sc{object}
Not documented.
@end defcv
@end deftp

@deffn Function COLLECTIONOF (@w{(?m @sc{thing})}) :-> @w{(?c @sc{collection})}
Abstract function existing to subsume @code{SETOF}
and @code{LISTOF}.
@end deffn

@deffn Relation COMMENT (@w{(?x @sc{thing})} @w{(?s @sc{string})})
?s is a comment attached to ?x.  Comments are
a generalization of other annotations such as @code{documentation} and
@code{issue} strings.
@end deffn

@deffn Relation COMMUTATIVE (@w{(?r @sc{relation})})
A relation ?r is commutative if its truth value is
invariant with any permutation of its arguments.
@end deffn

@c # $(util/texinfo-insert-doc /PL-KERNEL/computed)
@c # $(util/texinfo-insert-doc /PL-KERNEL/computed-procedure)
@deffn Concept CONCEPT (@w{(?x @sc{relation})})
The class of reified unary relations.  The Powerloom
notion of @code{concept} corresponds to the object-oriented notion of @code{class}.
From a logic standpoint, the notion of a concept is hard to distinguish
from the notion of @code{unary relation}.  The conceptual distinction is
best illustrated in the domain of linguistics, where concepts are
identified with collective nouns while unary relations are identified
with adjectives.  For example, @code{Rock} is a concept, while @code{rocky} is a
unary relation.
@end deffn

@deffn Function CONCEPT-PROTOTYPE (@w{(?c @sc{concept})}) :-> @w{(?i @sc{thing})}
Function that, given a concept, returns a prototypical
instance that inherits all constraints that apply to any concept member,
and has no additional constraints.
@end deffn

@deftp Class @sc{context} : @sc{thing}
Not documented.
@defcv Slot {} child-contexts : @sc{(list of context)}
Not documented.
@end defcv
@defcv Slot {} base-module : @sc{module}
Not documented.
@end defcv
@defcv Slot {} all-super-contexts : @sc{(cons of context)}
Not documented.
@end defcv
@defcv Slot {} context-number : @sc{integer}
Not documented.
@end defcv
@end deftp

@c # $(util/texinfo-insert-doc /PL-KERNEL/context-of)
@deffn Relation COVERING (@w{(?c @sc{collection})} @w{(?cover @sc{set})})
True if ?c is a subset of the union of all
collections in the set ?cover (see @code{disjoint-covering}).
@end deffn

@deffn Relation CUT (@w{(?arguments @sc{thing})})
Prolog-like CUT.  Succeeds the first time and
then fails.  Side-effect:  Locally disables query optimization.
@end deffn

@deffn Relation DIRECT-SUBRELATION (@w{(?r @sc{relation})} @w{(?sub @sc{relation})})
True iff ?sub is a direct subrelation of ?r; written
in set notation, ?sub < ?r, and there is no ?s such that ?sub < ?s < ?r.
This relation will generate bindings for at most one unbound argument.
@end deffn

@deffn Relation DIRECT-SUPERRELATION (@w{(?r @sc{relation})} @w{(?super @sc{relation})})
True iff ?super is a direct superrelation of ?r;
in set notation, ?super > ?r, and there is no ?s such that ?super > ?s > ?r.
This relation will generate bindings for at most one unbound argument.
@end deffn

@deffn Relation DISJOINT (@w{(?c1 @sc{collection})} @w{(?c2 @sc{collection})})
True if the intersection of ?c1 and ?c2 is empty.
@end deffn

@deffn Relation DISJOINT-COVERING (@w{(?c @sc{collection})} @w{(?disjointcover @sc{set})})
True if ?c is covered by the collections in ?disjointCover
and if the member sets in ?disjointCover are mutually-disjoint.  For
example the concepts @code{Igneous-Rock}, @code{Metamorphic-Rock}, and
@code{Sedimentary-Rock} together form a disjoint covering of the concept @code{Rock}.
@end deffn

@deffn Relation DOCUMENTATION (@w{(?x @sc{thing})} @w{(?s @sc{string})})
?s is a documentation string attached to ?x.  Some
of the PowerLoom text processing tools look for documentation strings and 
import them into documents.
@end deffn

@deffn Relation DOMAIN (@w{(?r @sc{relation})} @w{(?d @sc{collection})})
True if for any tuple @code{T} that satifies ?r, the first
argument of @code{T} necessarily belongs to the concept ?d.  @code{domain} exists
for convenience only and is defined in terms of @code{nth-domain}.  @code{domain}
assertions should be avoided, since they create redundant @code{nth-domain}
propositions (use @code{nth-domain} directly).
@end deffn

@deffn Relation DUPLICATE-FREE (@w{(?c @sc{collection})})
?c is duplicate-free if no two members
denote the same object.
@end deffn

@deffn Concept DUPLICATE-FREE-COLLECTION (@w{(?c @sc{collection})})
?c is free of duplicates
@end deffn

@deffn Relation EMPTY (@w{(?c @sc{collection})})
The collection ?c is empty if it has no members.  Note
that for collections possessing open-world semantics, (e.g., most concepts)
the fact that the collection has no known members does not necessarily
imply that it is empty.
@end deffn

@deffn Relation EQUIVALENT-RELATION (@w{(?r @sc{relation})} @w{(?equiv @sc{relation})})
True if ?r is equivalent to ?equiv; written in set notation,
?r = ?equiv.  This relation will generate bindings for at most one unbound
argument.
@end deffn

@deffn Relation EXAMPLE (@w{(?r @sc{relation})} @w{(?e @sc{thing})})
?e is an example of (the use of) ?r.
@end deffn

@deffn Function FILLERS (@w{(?r @sc{relation})} @w{(?i @sc{thing})}) :-> @w{(?members @sc{set})}
Given a relation ?r and instance ?i, returns
a set of known fillers of ?r applied to ?i.  IMPORTANT: this also collects
intensional fillers such as skolems that might be identical extensionally.
@end deffn

@c # $(util/texinfo-insert-doc /PL-KERNEL/float)
@c # $(util/texinfo-insert-doc /PL-KERNEL/float-interval-cache)
@c # $(util/texinfo-insert-doc /PL-KERNEL/fork)
@deffn Concept FRAME-PREDICATE (@w{(?c @sc{relation})})
A frame predicate is a second-order relation that
is used to describe constraints on the set of fillers for a binary
relation applied to an instance.  Examples of frame predicates are
@code{range-cardinality}, @code{range-type}, and @code{numeric-minimum}.  Frame predicates
are typically used to capture the kinds of relations manipulated
by description logic systems such as USC/ISI's Loom system.
@end deffn

@deftp Class @sc{method-slot} : @sc{slot}
Not documented.
@defcv Slot {} method-setter? : @sc{boolean}
Not documented.
@end defcv
@defcv Slot {} method-parameter-names : @sc{(list of symbol)}
Not documented.
@end defcv
@defcv Slot {} method-parameter-type-specifiers : @sc{(list of type-spec)}
Not documented.
@end defcv
@defcv Slot {} method-return-type-specifiers : @sc{(list of type-spec)}
Not documented.
@end defcv
@defcv Slot {} method-stringified-source : @sc{string}
Not documented.
@end defcv
@defcv Slot {} method-code : @sc{method-code}
Not documented.
@end defcv
@defcv Slot {} function-code : @sc{function-code}
Not documented.
@end defcv
@defcv Slot {} method-function? : @sc{boolean}
Not documented.
@end defcv
@end deftp

@deffn Relation GOES-FALSE-DEMON (@w{(?r @sc{relation})} @w{(?computation @sc{computed-procedure})})
Names a @code{computation} (a function) that is attached (logically)
to ?r  Each time a proposition with predicate ?r becomes
false, the function is applied to that proposition.
@end deffn

@deffn Relation GOES-TRUE-DEMON (@w{(?r @sc{relation})} @w{(?computation @sc{computed-procedure})})
Names a @code{computation} (a function) that is attached (logically)
to ?r  Each time a proposition with predicate ?r becomes
true, the function is applied to that proposition.
@end deffn

@deffn Relation GOES-UNKNOWN-DEMON (@w{(?r @sc{relation})} @w{(?computation @sc{computed-procedure})})
Names a @code{computation} (a function) that is attached (logically)
to ?r  Each time a proposition with predicate ?r becomes
unknown, the function is applied to that proposition.
@end deffn

@c # $(util/texinfo-insert-doc /PL-KERNEL/group)
@c # $(util/texinfo-insert-doc /PL-KERNEL/handles-reverse-polarity)
@c # $(util/texinfo-insert-doc /PL-KERNEL/has-partition-membership)
@c # $(util/texinfo-insert-doc /PL-KERNEL/hidden-relation)
@deffn Relation HOLDS (@w{(?relation @sc{relation})} @w{(?arguments @sc{thing})})
True if the tuple @var{?arguments} is a member of the
relation @var{?relation}.  @code{holds} is a variable arity predicate that takes
a relation as its first argument, and zero or more additional arguments.
It returns values equivalent to a subgoal that has the first argument
as a predicate and the remaining arguments shifted one place to the left.
For @code{holds} to succeed, the (first) relation argument must be bound --
PowerLoom will NOT cycle through all relations searching for ones that
permit the proof to succeed.  However, users can obtain the same effect
if they choose by using other second-order predicates to generate
relation bindings.  For example, the query

@example 
   (retrieve all ?x (and (Relation ?r)
                         (holds ?r Fred ?x)))
@end example

retrieves all constants for which there is some binary relation that
relates @code{Fred} to that relation.
@end deffn

@deffn Relation IMAGE-URL (@w{(?x @sc{thing})} @w{(?url @sc{string})})
?url is a URL pointing to an image illustrating ?x.
The Ontosaurus browser looks for @code{image-url} values attached to
objects it is presenting, and displays them prominently, thereby spiffing
up its displays.
@end deffn

@deffn Relation INEQUALITY (@w{(?x @sc{thing})} @w{(?y @sc{thing})})
Abstract superrelation of inequality relations.
@end deffn

@deffn Relation INSTANCE-OF (@w{(?x @sc{thing})} @w{(?c @sc{collection})})
True if ?x is an instance of ?c.  Can
be used to generate concept values of ?c, given an instance ?x.
@end deffn

@c # $(util/texinfo-insert-doc /PL-KERNEL/integer)
@c # $(util/texinfo-insert-doc /PL-KERNEL/integer-interval)
@c # $(util/texinfo-insert-doc /PL-KERNEL/integer-interval-cache)
@c # $(util/texinfo-insert-doc /PL-KERNEL/interval-cache)
@c # $(util/texinfo-insert-doc /PL-KERNEL/interval-cache-of)
@deffn Function INVERSE (@w{(?r @sc{binary-relation})}) :-> @w{(?inverserelation @sc{thing})}
Function that returns the inverse relation for ?r.
PERFORMANCE NOTE: for best results there should be only one @code{(inverse R I)}
assertion per relation pair @code{R} and @code{I}.  In that case @code{R} is viewed as the
canonical relation and @code{I} simply provides a different access mechanism to
the canonical relation.  In a logic-based KR paradigm inverse relations are
redundant and do not add anything that couldn't be represented or queried
without them, however, sometimes they can provide some extra convenience for
users.  Asserting @code{(inverse I R)} also will not cause an error but can degrade
backward inference performance due to the extra redundant rule that gets
generated.  If domain rules will be written in terms of both @code{R} and @code{I} (as
opposed to only @code{R}), @code{(inverse I R)} should be asserted also to get full
inferential connectivity between the two relations.
@end deffn

@deffn Relation IRREFLEXIVE (@w{(?r @sc{relation})})
A binary relation ?r is irreflexive if it is false when both
of its arguments are identical.
@end deffn

@deffn Relation ISSUE (@w{(?x @sc{thing})} @w{(?s @sc{string})})
?s is an issue attached to ?x.  An issue string 
normally comments on a topic that has not been resolved to everyone's
satisfaction.
@end deffn

@deffn Relation IST (@w{(?context @sc{context})} @w{(?p @sc{proposition})})
True if proposition @var{?p} is true in context @var{?context}.
The @code{IST} (is true) relation allows one to evaluate a query or rule in more
than one context.  A common use of @code{IST} is in defining @code{lifting axioms}
that import knowledge from one context to another.  For example, below is
a rule that accesses a @code{patient-record} relation in a module called
@code{Medical-Kb}, @code{lifts-out} the @code{age} column, and imports it into a
@code{has-age} relation in the current context.

@example 
  (<= (has-age ?person ?age)
      (and (has-ssn ?person ?ssn)
           (exists (?1 ?2 ?3 ?4)
              (ist Medical-Kb (patient-record ?ssn ?1 ?2 ?age ?3 ?4)))))
@end example


@end deffn

@deffn Function LENGTH (@w{(?x @sc{thing})}) :-> @w{(?z @sc{integer})}
Function that returns the length of a string or a logical list.
NOT YET IMPLEMENTED FOR LISTS.
@end deffn

@deffn Relation LENGTH-OF-LIST (@w{(?l @sc{collection})} @w{(?length @sc{integer})})
Computes the length of the list or set ?l.
@end deffn

@deffn Relation LEXEME (@w{(?r @sc{thing})} @w{(?s @sc{string})})
?s is a lexeme for the relation or individual ?r.
A relation or individual ?r can have zero or more lexemes, words that are
natural langage equivalents of a logical constant.  The same lexeme may be
attached to more than one constant.
@end deffn

@deftp Class @sc{list} : @sc{sequence}
Not documented.
@defcv @w{Class Parameter} {} any-value : @sc{object}
Not documented.
@end defcv
@defcv Slot {} the-cons-list : @sc{(cons of (like (any-value self)))}
Not documented.
@end defcv
@end deftp

@deffn Function LISTOF (@w{(?m @sc{thing})}) :-> @w{(?c @sc{list})}
Term-forming function that defines an ordered list
consisting of all function arguments.  Within logical expressions
@code{listof} is most commonly used in conjunction with the @code{member-of}
predicate.  For example the query

@example 
  (retrieve ?x (member-of ?x (listof a b c)))
@end example

returns the constants @code{a}, @code{b}, and @code{c} on successive iterations.
@end deffn

@c # $(util/texinfo-insert-doc /PL-KERNEL/literal)
@deffn Relation MAXIMUM-VALUE (@w{(?l @sc{collection})} @w{(?max @sc{number})})
Binds ?max to the maximum of the numbers in the list ?l.
@end deffn

@deffn Relation MEAN-VALUE (@w{(?l @sc{collection})} @w{(?mean @sc{number})})
Binds ?mean to the mean of the numbers in ?l.
@end deffn

@deffn Relation MEDIAN-VALUE (@w{(?l @sc{collection})} @w{(?median @sc{number})})
Binds ?median to the median of the numbers in ?l.
@end deffn

@deffn Relation MEMBER-OF (@w{(?x @sc{thing})} @w{(?c @sc{collection})})
TRUE if ?x is a member of collection ?c.  A common use
of @code{member-of} is for binding a variable to successive members in a list
or set (see @code{listof} and @code{setof}).
@end deffn

@deffn Relation MINIMUM-VALUE (@w{(?l @sc{collection})} @w{(?min @sc{number})})
Binds ?min to the minimum of the numbers in the list ?l.
@end deffn

@c # $(util/texinfo-insert-doc /PL-KERNEL/module)
@deffn Relation MUTUALLY-DISJOINT-COLLECTION (@w{(?s @sc{set})})
True if the members of ?s are pair-wise disjoint.  Used
most often to expresse disjointness constraints between concepts.  For
example

@example 
   (mutually-disjoint-collection (setof MAN WOMAN))
@end example

states that the concepts MAN and WOMAN are disjoint.

@end deffn

@deffn Relation NTH-DOMAIN (@w{(?r @sc{relation})} @w{(?i @sc{integer})} @w{(?d @sc{collection})})
True if the nth value for a tuple T satisfying
?r must belong to the concept ?d.  Argument counting starts at zero.
@end deffn

@c # $(util/texinfo-insert-doc /PL-KERNEL/number)
@c # $(util/texinfo-insert-doc /PL-KERNEL/numeric-interval)
@deffn Relation NUMERIC-MAXIMUM (@w{(?r @sc{relation})} @w{(?i @sc{thing})} @w{(?n @sc{number})})
Relation that specifies an upper bound @var{?n} on any numeric
value that can belong to the set of fillers of the relation ?r applied to ?i.
@end deffn

@deffn Relation NUMERIC-MINIMUM (@w{(?r @sc{relation})} @w{(?i @sc{thing})} @w{(?n @sc{number})})
Relation that specifies a lower bound @var{?n} on any numeric
value that can belong to the set of fillers of the relation ?r applied to ?i.
@end deffn

@deffn Concept NUMERIC-SET (@w{(?s @sc{collection})})
?s is a set of numbers
@end deffn

@c # $(util/texinfo-insert-doc /PL-KERNEL/observed-cardinality-of)
@deffn Relation ORDERED (@w{(?c @sc{collection})})
?c is ordered if the ordering of its
members is significant.  Lists are ordered, while sets are not.
@end deffn

@c # $(util/texinfo-insert-doc /PL-KERNEL/partition-membership)
@deffn Relation PHRASE (@w{(?r @sc{thing})} @w{(?s @sc{string})})
A phrase is a variablized sentence, a template, that
is used to express individual axiomatic facts as natural language
sentences.  By convention, a phrase contains one or more occurrences
of each variable in a relation or concept definition, it does not
begin with a capital letter, and it has no concluding period.
Systematic attachment of phrases to relations can be leveraged by
tools that generate natural language paraphrases of logic sentences.
@end deffn

@c # $(util/texinfo-insert-doc /PL-KERNEL/polymorphic)
@c # $(util/texinfo-insert-doc /PL-KERNEL/portion-of)
@deffn Function PROJECT-COLUMN (@w{(?i @sc{integer})} @w{(?c @sc{collection})}) :-> @w{(?l @sc{list})}
Project elements in column ?i (zero-based) of the tuples
of ?c and collect them into a list ?l. 
@end deffn

@deffn Relation PROPER-SUBRELATION (@w{(?r @sc{relation})} @w{(?sub @sc{relation})})
True iff ?sub is a proper subrelation of ?r; written in
set notation, ?sub < ?r.  This relation will generate bindings for at most
one unbound argument.
@end deffn

@deffn Relation PROPER-SUPERRELATION (@w{(?r @sc{relation})} @w{(?super @sc{relation})})
True iff ?super is a proper superrelation of ?r; written in
set notation, ?super > ?r.  This relation will generate bindings for at most
one unbound argument.
@end deffn

@deftp Class @sc{proposition} : @sc{context-sensitive-object}, @sc{dynamic-slots-mixin}, @sc{backlinks-mixin}

@defcv Slot {} home-context : @sc{context}
Not documented.
@end defcv
@defcv Slot {} kind : @sc{keyword}
Not documented.
@end defcv
@defcv Slot {} truth-value : @sc{truth-value}
Not documented.
@end defcv
@defcv Slot {} arguments : @sc{vector}
Not documented.
@end defcv
@defcv Slot {} operator : @sc{generalized-symbol}
Not documented.
@end defcv
@defcv Slot {} dependent-propositions : @sc{(non-paging-index of proposition)}
Not documented.
@end defcv
@end deftp

@c # $(util/texinfo-insert-doc /PL-KERNEL/qualified-range-cardinality)
@deffn Relation RANGE (@w{(?r @sc{relation})} @w{(?rng @sc{collection})})
True if for any tuple @code{T} that satifies ?r, the last
argument of @code{T} necessarily belongs to the concept ?rng.  @code{range} exists
for convenience only and is defined in terms of @code{nth-domain}.  @code{range}
assertions should be avoided, since they create redundant @code{nth-domain}
propositions (use @code{nth-domain} directly).
@end deffn

@deffn Function RANGE-CARDINALITY (@w{(?r @sc{relation})} @w{(?i @sc{thing})}) :-> @w{(?card @sc{integer})}
Function that returns the cardinality of the set
of fillers of the relation ?r applied to ?i.  The cardinality function
returns a value only when the relations @code{range-min-cardinality} and
@code{range-max-cardinality} compute identical values, i.e., when the
best lower and upper bounds on the cardinality are equal.  Each of
these bounding functions employs a variety of rules to try and
compute a tight bound.
@end deffn

@deffn Relation RANGE-CARDINALITY-LOWER-BOUND (@w{(?r @sc{relation})} @w{(?i @sc{thing})} @w{(?lb @sc{integer})})
Relation that specifies a lower bound on the cardinality 
of the set of fillers of the relation ?r applied to ?i.  The difference
between @code{range-cardinality-lower-bound} and @code{range-min-cardinality} is
subtle but significant.   Suppose we state that nine is a lower bound
on the number of planets in the solar system, and then ask if eight is
(also) a lower bound:

@example 
   (assert (range-cardinality-lower-bound hasPlanets SolarSystem 9))
   (ask (range-cardinality-lower-bound hasPlanets SolarSystem 8))  ==> TRUE
@end example

PowerLoom will return TRUE.  However if we ask if the minimum cardinality
of the solar system's planets is eight, we get back UNKNOWN

@example 
   (ask (range-min-cardinality hasPlanets SolarSystem 8)) ==> UNKNOWN
@end example

because eight is not the tightest lower bound.
@end deffn

@deffn Relation RANGE-CARDINALITY-UPPER-BOUND (@w{(?r @sc{relation})} @w{(?i @sc{thing})} @w{(?ub @sc{integer})})
Relation that specifies an upper bound on the cardinality 
of the set of fillers of the relation ?r applied to ?i. (see the discussion
for @code{range-cardinality-lower-bound}).
@end deffn

@deffn Function RANGE-MAX-CARDINALITY (@w{(?r @sc{relation})} @w{(?i @sc{thing})}) :-> @w{(?maxcard @sc{integer})}
Returns the strictest computable upper bound on the
cardinality of the set of fillers of the relation ?r applied to ?i.
(see the discussion for @code{range-cardinality-lower-bound}).
@end deffn

@deffn Function RANGE-MIN-CARDINALITY (@w{(?r @sc{relation})} @w{(?i @sc{thing})}) :-> @w{(?mincard @sc{integer})}
Returns the strictest computable lower bound on the
cardinality of the set of fillers of the relation ?r applied to ?i.
(see the discussion for @code{range-cardinality-lower-bound}).
@end deffn

@deffn Relation RANGE-TYPE (@w{(?r @sc{relation})} @w{(?i @sc{thing})} @w{(?type @sc{collection})})
Relation that specifies a type/range of the relation ?r applied to ?i.
Multiple range types may be asserted for a single pair <?r,?i>.  Technically,
a retrieval of types for a given pair should include all supertypes
(superconcepts) of any type that is produced, but for utility's sake,
only asserted or directly inferrable types are returned.
@end deffn

@deffn Relation REFLEXIVE (@w{(?r @sc{relation})})
A binary relation ?r is reflexive if it is always true when
both of its arguments are identical.
@end deffn

@c # $(util/texinfo-insert-doc /PL-KERNEL/refutation-disjoint)
@deftp Class @sc{relation} : @sc{mappable-object}
Not documented.
@defcv Slot {} abstract? : @sc{boolean}
Not documented.
@end defcv
@end deftp

@deffn Relation RELATION-COMPUTATION (@w{(?r @sc{relation})} @w{(?computation @sc{computed-procedure})})
Names a @code{computation} (a function) that evaluates an (atomic) relation
proposition during query processing.  The function is passed a proposition
for evaluation for which all arguments are bound.  The function
returns a BOOLEAN if it represents a predicate, or some sort of value
if it is a function.
@end deffn

@deffn Relation RELATION-CONSTRAINT (@w{(?r @sc{relation})} @w{(?computation @sc{computed-procedure})})
Names a @code{computation} (a function) that evaluates an (atomic) relation
proposition during query processing.  The function is passed a proposition
for evaluation for which at most one argument is unbound.  The function
returns a BOOLEAN if it represents a predicate, or some sort of value
if it is a function.  If all arguments are bound the function computes whether
the constraint holds.  If all but one argument is bound and the unbound
argument is a pattern variable then the missing value is computed.
@end deffn

@deffn Relation RELATION-EVALUATOR (@w{(?r @sc{relation})} @w{(?ev @sc{computed-procedure})})
Names an @code{evaluator} (a function) that evaluates an (atomic) relation
proposition during constraint propagation.  This defines an extensible
means for computing using auxiliary data structures.  The function is passed
a proposition for evaluation which might update the proposition, generate
additional assertions or trigger further evaluations.  Evaluators have to
check the truth-value of the passed-in proposition and perform their actions
accordingly.  An evaluated proposition might be true, false or even unknown
in case the propositon was just newly constructed.
@end deffn

@deffn Relation RELATION-SPECIALIST (@w{(?r @sc{relation})} @w{(?sp @sc{computed-procedure})})
Names a @code{specialist} (a function) that evaluates an (atomic) relation
proposition during query processing.  This defines an extensible
means for computing with the control stack.  The function is passed
a CONTROL-FRAME that contains the proposition, and returns a keyword
:FINAL-SUCCESS, :CONTINUING-SUCCESS, :FAILURE, or :TERMINAL-FAILURE
that controls the result of the computation.
@end deffn

@deffn Concept SCALAR (@w{(?x @sc{scalar})})
The class of scalar quantities.
@end deffn

@deffn Concept SCALAR-INTERVAL (@w{(?x @sc{scalar})})
An interval of scalar quantities. 
@end deffn

@deftp Class @sc{set} : @sc{list}, @sc{set-mixin}
Not documented.
@defcv @w{Class Parameter} {} any-value : @sc{object}
Not documented.
@end defcv
@end deftp

@deffn Function SETOF (@w{(?m @sc{thing})}) :-> @w{(?c @sc{set})}
Term-forming function that defines an enumerated set
consisting of all function arguments.  @code{setof} is like @code{listof} except
that it removes duplicate values.
@end deffn

@deffn Relation SINGLE-VALUED (@w{(?c @sc{relation})})
The relation ?c is single-valued if the value of its
last argument is a function of all other arguments.  All functions
are single-valued (see @code{function}).
@end deffn

@c # $(util/texinfo-insert-doc /PL-KERNEL/soft-eq)
@deffn Relation SQUARE-ROOT (@w{(?x @sc{number})} @w{(?y @sc{number})})
Relation that returns the positive and negative square roots:
?y = sqrt(?x).  For positive roots only see function SQRT.
@end deffn

@deffn Relation STANDARD-DEVIATION (@w{(?l @sc{collection})} @w{(?sd @sc{number})})
Binds ?sd to the standard deviation of the numbers in ?l.
@end deffn

@c # $(util/texinfo-insert-doc /PL-KERNEL/string)
@deffn Function STRING-CONCATENATE (@w{(?x1 @sc{string})} @w{(?x2 @sc{string})}) :-> @w{(?x3 @sc{string})}
Concatenate strings ?x1 and ?x2 and bind ?x3 to the result.
@end deffn

@c # $(util/texinfo-insert-doc /PL-KERNEL/stuff)
@deffn Relation SUBRELATION (@w{(?r @sc{relation})} @w{(?sub @sc{relation})})
True iff ?sub is a subrelation of ?r; written in set
notation, ?sub =< ?r.  This relation will generate bindings for at most
one unbound argument.
@end deffn

@deffn Relation SUBSET-OF (@w{(?sub @sc{collection})} @w{(?super @sc{collection})})
True if ?sub is a subset of ?super.  For performance
reasons, the @code{subset-of} predicate refuses to search for bindings if
both of its variables are unbound.  Implementation note: @code{subset-of} 
is treated specially internally to PowerLoom, and hence Powerloom does not
permit the augmentation of @code{subset-of} with additional inference rules.
In otherwords, @code{subset-of} behaves semantically like an operator instead
of a relation.
@end deffn

@deffn Function SUBSTRING (@w{(?s @sc{string})} @w{(?start @sc{integer})} @w{(?end @sc{integer})}) :-> @w{(?sub @sc{string})}
Generate the substring of ?s starting at position ?start
(zero-based), ending just before position ?end and bind ?sub to the result.
This is the PowerLoom equivalent to the STELLA method @code{subsequence}.  In
addition, this function can be used to locate substrings in strings by
supplying values for ?s and ?sub and allowing ?start and ?end to be
bound by the function specialist.  In other words,
      (retrieve all (?start ?end) (substring "foo" ?start ?end "o"))
 ==>  ?start = 1, ?end = 2,
      ?start = 2, ?end = 3.
@end deffn

@deffn Relation SUM (@w{(?l @sc{collection})} @w{(?sum @sc{number})})
Binds ?sum to the sum of the numbers in the list ?l.
@end deffn

@deffn Relation SUPERRELATION (@w{(?r @sc{relation})} @w{(?super @sc{relation})})
True iff ?super is a superrelation of ?r; written in set
notation, ?super >= ?r.  This relation will generate bindings for at most
one unbound argument.
@end deffn

@deffn Relation SYMMETRIC (@w{(?r @sc{relation})})
A binary relation ?r is symmetric if it is commutative.
@end deffn

@deffn Relation SYNONYM (@w{(?term @sc{thing})} @w{(?synonym @sc{thing})})
Assert that @var{?synonym} is a synonym of @var{?term}.  This
causes all references to @var{?synonym} to be interpreted as references
to @var{?term}.  Retraction eliminates a synonym relation.
@end deffn

@c # $(util/texinfo-insert-doc /PL-KERNEL/the-roleset)
@deftp Class @sc{thing} : @sc{standard-object}, @sc{dynamic-slots-mixin}
Defines a class that must be inherited by any
class that participates in the PowerLoom side of things.
@defcv Slot {} surrogate-value-inverse : @sc{surrogate}
Not documented.
@end defcv
@end deftp

@deffn Relation TOTAL (@w{(?r @sc{function})})
True if the function @var{?r} is defined for all
combinations of inputs.  By default, functions are not assumed to
be total (unlike Prolog, which @code{does} make such an assumption.
For example, if we define a two-argument function @code{foo} and then retrieve
its value applied to some random instances @code{a} and @code{b}, we get nothing
back:

@example 
   (deffunction foo (?x ?y) :-> ?z)
   (retrieve ?x (= ?x (foo a b)))
@end example

However, if we assert that @code{foo} is total, then we get a skolem back
when we execute the same retrieve:

@example 
   (assert (total foo))
   (retrieve ?x (= ?x (foo a b)))
@end example


@end deffn

@deffn Relation TRANSITIVE (@w{(?r @sc{relation})})
A binary relation ?r is transitive if (?r ?x ?y)
and (?r ?y ?z) implies that (?r ?x ?z).  Note that functions cannot
be transitive, since their single-valuedness would not allow multiple
different values such as (?r ?x ?y) and (?r ?x ?z) due to the Unique
Names Assumption made by PowerLoom.
@end deffn

@deffn Relation TYPE-OF (@w{(?c @sc{collection})} @w{(?x @sc{thing})})
True if ?x is a member of the concept ?c.
@end deffn

@c # $(util/texinfo-insert-doc /PL-KERNEL/union-of)
@c # $(util/texinfo-insert-doc /PL-KERNEL/user-thing)
@deffn Function VALUE (@w{(?function @sc{function})} @w{(?arguments @sc{thing})}) :-> @w{(?value @sc{thing})}
True if applying @var{?function} to @var{?arguments}
yields the value @code{?value}.  The @code{value} predicate is the analog
of @code{holds}, except that it applies to functions instead of relations.
@end deffn

@deffn Relation VARIABLE-ARITY (@w{(?r @sc{relation})})
Asserts that the relation ?r can take a variable
number of arguments.
@end deffn

@deffn Relation VARIANCE (@w{(?l @sc{collection})} @w{(?variance @sc{number})})
Binds ?variance to the variance of the numbers in ?l.
@end deffn


@c ===========================================================================

@node Installation, Miscellaneous, Built-In Relations, Top
@chapter Installation

@c ---------------------------------------------------------------------------

@menu
* System Requirements::         
* Unpacking the Sources::       
* Lisp Installation::           
* C++ Installation::            
* Java Installation::           
* Removing Unneeded Files::     
* Installing PowerLoom Patches::  
@end menu

@node System Requirements, Unpacking the Sources, Installation, Installation
@section System Requirements

To install and use PowerLoom, you'll approximately need the following amounts of
disk space:

@itemize
@item 
16 MB for the tarred or zipped archive file

@item 
70 MB for the untarred sources, tanslations, compiled Java files, and
documentation

@item 
16 MB to compile a Lisp version

@item 
16 MB to compile the C++ version (without -g)

@item 
5 MB to compile the Java version (already included)

@end itemize

This means that you will need approximately 100 MB to work with one Lisp,
one C++ and one Java version of PowerLoom in parallel.  If you also want to
experiment with the Lisp translation variant that uses structures
instead of CLOS instances to implement STELLA objects, then you will
need an extra 16 MB to compile that.

The full PowerLoom development tree is quite large, since for every
STELLA source file there are three to four translated versions and as
many or more compiled versions thereof.  The actual PowerLoom libraries
that you have to ship with an application, however, are quite small.
For example, the Java jar files @file{powerloom.jar} and
@file{stella.jar} are only 2.3 MB total (4 MB including Java sources).
The dynamic C++ libraries @file{libstella.so} and @file{liblogic.so}
compiled on a Linux platform, are about 8 MB total.  Additionally, if you
don't need all the different translations of PowerLoom, you can delete
some of the versions to keep your development tree smaller
@xref{Removing Unneeded Files}.

To run the Lisp version of PowerLoom, you will need an ANSI Common-Lisp
(or at least one that supports CLOS and logical pathnames).  We have
successfully tested PowerLoom with Allegro-CL 4.2, 4.3, 5.0, 6.0 and
7.0, Macintosh MCL 3.0, 4.0 and 5.1, OpenMCL 1.0, SBCL 0.9.4, CMUCL 19c,
LispWorks 4.4.6, CLisp 2.37, Lucid CL 4.1 (plus the necessary ANSI
extensions and Mark Kantrowitz's logical pathnames implementation), and
various others.  Our main development platform is Allegro CL running
under Sun Solaris and Linux.  The closer your environment is to ours,
the higher are the chances that everything will work right out of the
box.  Lisp development under Windows should also be no problem.

To run the C++ version of PowerLoom, you will need a C++ compiler (such
as g++) that supports templates and exception handling.  We have
successfully compiled and run PowerLoom with g++ 3.2 and later under
Linux Redhat 8.0 & 9.0, SunOS and MacOS X, and with CygWin 5.0 and MinGW
5.0 under Windows 2000 and XP.  Both CygWin and MinGW provide a GNU Unix
environment, but MinGW can generate Windows executables that are fully
standalone.  We've also managed to compile PowerLoom under MS Visual
C++, however, we never got the Boehm garbage collector to work.  The GC
claims to be very portable, so this should be solvable for somebody with
good knowledge of MS Visual C++.

For the Java version, you will need Java JDK 1.2 or later. To get
reasonable performance, you should use J2SDK 1.4 or 1.5.  We've run the
Java version of PowerLoom on a variety of platforms without any
problems.

Any one of the Lisp, C++, or Java implementations of PowerLoom can be
used to develop your own PowerLoom-based applications.  Which one you
choose is primarily a matter of your application and programming
environment.  The Lisp and Java versions are comparable in speed, the
C++ version is usually a factor of 2-3 faster than Lisp or Java.

@c ---------------------------------------------------------------------------

@node Unpacking the Sources, Lisp Installation, System Requirements, Installation
@section Unpacking the Sources

Uncompress and untar the file @file{powerloom-X.Y.Z.tar.gz} (or unzip
the file @file{powerloom-X.Y.Z.zip}) in the parent directory of where
you want to install PowerLoom (`X.Y.Z' are place holders for the actual
version numbers).  This will create the PowerLoom tree in the directory
@file{powerloom-X.Y.Z/} (we will use Unix syntax for pathnames).  All
pathnames mentioned below will be relative to that directory which we
will usually refer to as the "PowerLoom directory".

@c ---------------------------------------------------------------------------

@node Lisp Installation, C++ Installation, Unpacking the Sources, Installation
@section Lisp Installation

To install the Lisp version of PowerLoom, startup Lisp and load the file
@file{load-powerloom.lisp} with:

@example
(CL:load "load-powerloom.lisp")
@end example

The first time around, this will compile all Lisp-translated STELLA files
before they are loaded.  During subsequent sessions, the compiled files
will be loaded right away.

By default, PowerLoom now uses the version that uses Lisp structs
instead of CLOS objects to implement STELLA objects.  If you do want to
use the CLOS-based version instead do the following:

@example
(CL:setq cl-user::*load-cl-struct-stella?* CL:nil)
(CL:load "load-powerloom.lisp")
@end example

Alternatively, you can edit the initial value of the variable
@code{*load-cl-struct-stella?*} in the file @file{load-powerloom.lisp}.
Using structs instead of CLOS objects greatly improves slot access
speed, however, it may cause problems with incremental re-definition of
STELLA classes (this is only an issue if you are developing your
application code in the STELLA language.  In that case, it is recommended
to only use the struct option for systems that are in or near the
production stage).

Once all the files are loaded, you should see a message similar to this:

@example
PowerLoom 3.2.0 loaded.
Type `(powerloom)' to get started.
Type `(in-package "STELLA")' to run PowerLoom commands directly
   from the Lisp top level.
USER(2): 
@end example

To reduce startup time, you might want to create a Lisp image that has
all of PowerLoom preloaded.

Now type
@example
(in-package "STELLA")
@end example

to enter the @code{STELLA} Lisp package where all the PowerLoom code
resides.  Alternatively, you can type

@example
(powerloom)
@end example

which will bring up a PowerLoom listener that will allow you to execute
PowerLoom commands.

@strong{IMPORTANT}: All unqualified Lisp symbols in this document are
assumed to be in the @code{STELLA} Lisp package.  Moreover, the
@code{STELLA} package does @strong{NOT} inherit anything from the
@code{COMMON-LISP} package (see the file
@file{sources/stella/cl-lib/cl-setup.lisp} for the few exceptions).
Hence, you have to explicitly qualify every Lisp symbol you want to use
with @code{CL:}.  For example, to get the result of the previous
evaluation, you have to type @code{CL:*} instead of @code{*}.

@c ---------------------------------------------------------------------------

@node C++ Installation, Java Installation, Lisp Installation, Installation
@section C++ Installation

To compile the C++ version of PowerLoom, change to the native C++ directory
of PowerLoom and run @code{make} like this:

@example
% cd native/cpp/powerloom
% make
@end example

This will compile all PowerLoom and STELLA files as well as the C++
garbage collector.  It will then generate static or dynamic
@file{libstella}, @file{liblogic} and other library files in the
directory @file{native/cpp/lib} which can be linked with your own
C++-translated PowerLoom (or other) code.  To test whether the
compilation was successful, you can run PowerLoom from the top-level
PowerLoom directory using the @file{powerloom} script (or
@code{powerloom.bat} under a Windows command prompt):

@example
% powerloom c++
Running C++ version of PowerLoom...
Initializing STELLA...
Initializing PowerLoom...

    Welcome to PowerLoom 3.2.0

Copyright (C) USC Information Sciences Institute, 1997-2006.
PowerLoom comes with ABSOLUTELY NO WARRANTY!
Type `(copyright)' for detailed copyright information.
Type `(help)' for a list of available commands.
Type `(demo)' for a list of example applications.
Type `bye', `exit', `halt', `quit', or `stop', to exit.


PL-USER |= 
@end example

This will run various PowerLoom startup code and then bring up a
PowerLoom command loop where you can execute commands.  The @code{c++}
argument tells the script to run the C++ version of PowerLoom (which is
also run by default as long as the C++ version was compiled).  If the
C++ version was not compiled or the @code{java} argument was given
instead, the Java version of PowerLoom will be run.

Type

@example
(demo)
@end example

to bring up a menu of available demos, type

@example
(run-powerloom-tests)
@end example

to run the PowerLoom test suite, or type

@example
exit
@end example

to exit PowerLoom.

@c ---------------------------------------------------------------------------

@node Java Installation, Removing Unneeded Files, C++ Installation, Installation
@section Java Installation

Nothing needs to be done to install the Java version.  Because Java class
files are platform independent, they are already shipped with the
PowerLoom distribution and can be found in the directory
@file{native/java} and its subdirectories.  Additionally, they have been
collected into the file @file{native/java/lib/powerloom.jar} in the
PowerLoom directory.  To try out the Java version of PowerLoom, you can
run PowerLoom from the top-level PowerLoom directory using the
@file{powerloom} script (or @code{powerloom.bat} under a Windows 
command prompt):

@example
% powerloom java
Running Java version of PowerLoom...
Initializing STELLA...
Initializing PowerLoom...

    Welcome to PowerLoom 3.2.0

Copyright (C) USC Information Sciences Institute, 1997-2006.
PowerLoom comes with ABSOLUTELY NO WARRANTY!
Type `(copyright)' for detailed copyright information.
Type `(help)' for a list of available commands.
Type `(demo)' for a list of example applications.
Type `bye', `exit', `halt', `quit', or `stop', to exit.


PL-USER |= 
@end example

Similar to the C++ executable, this will run various PowerLoom startup
code and then bring up a PowerLoom command loop where you can execute
commands.  Type

@example
(demo)
@end example

to bring up a menu of available demos, type

@example
(run-powerloom-tests)
@end example

to run the PowerLoom test suite, or type

@example
exit
@end example

to exit PowerLoom.

@c ---------------------------------------------------------------------------

@node Removing Unneeded Files, Installing PowerLoom Patches, Java Installation, Installation
@section Removing Unneeded Files

To save disk space, you can remove files that you don't need.  For
example, if you are not interested in the C++ version of PowerLoom, you
can delete the directory @file{native/cpp}.  Similarly, you can remove
@file{native/java} to eliminate all Java-related files.  You could do
the same thing for the Lisp directory @file{native/lisp}, but (in our
opinion) that would make it less convenient for you to develop new
PowerLoom code that is written in STELLA.  Finally, if you don't need
any of the STELLA sources, you can delete the directory
@file{sources/stella}.  If you don't need local copies of the STELLA and
PowerLoom documentation, you can delete parts or all of the
directories @file{sources/stella/doc} and @file{sources/logic/doc}.

@c ---------------------------------------------------------------------------

@node Installing PowerLoom Patches,  , Removing Unneeded Files, Installation
@section Installing PowerLoom Patches

If you already have an older version of PowerLoom installed, you can
upgrade to the latest patch level by downloading incremental sets of
patches instead of downloading the complete release.  Patch files are
usually significantly smaller than the complete release and patching
an existing installation can also preserve local additions, deletions,
or modifications.  PowerLoom patch files are available from the same
location as the full PowerLoom release.

Patches are currently only available in Unix @code{diff} format which
requires the Unix @code{patch} utility to install them (the
@code{patch} program should be readily available on most Unix
systems, otherwise, you can get it for free from the Free Software
Foundation).

Patch files follow the following naming convention: Suppose the current
version of PowerLoom is 3.0.0.  Then the patch file to update to the
next patch level is called @file{powerloom-3.0.0-3.0.1.diff.gz}.

@strong{Important:} Patch files are strictly incremental.  Thus, to
upgrade from version 3.0.0 to 3.0.2, you will need two patch files: one
to go to version 3.0.1 and one to go from that to version 3.0.2; you
will have to apply them in that sequence.

To find out the current version of your PowerLoom installation, look
at the version string displayed when the @code{powerloom} function
is called in Lisp, or when the C++ or Java program starts up.

@strong{Important:} Before you apply any patches, you should always make
a backup copy of your current PowerLoom installation to preserve any
local modifications you made, in case something goes wrong.

To apply patches, copy the appropriate patch file to the top level of
your PowerLoom installation directory.  Suppose the patch file is called
@file{powerloom-3.0.0-3.0.1.diff.gz}.  You can apply the patches using
the following command:

@example
gunzip -qc powerloom-3.0.0-3.0.1.diff.gz | patch -p1
@end example

If you deleted some native PowerLoom files to save space, you can use the
@code{-f} option to force @code{patch} to proceed even if files it needs
to patch do not exist anymore (this is somewhat dangerous in case @code{patch}
encounters some more serious problems).  For example:

@example
gunzip -qc powerloom-3.0.0-3.0.1.diff.gz | patch -p1 -f
@end example

To keep patch files small, PowerLoom patch files do not contain updated
binary files that ship with the full release (such as Java class files,
jar files and PDF documents).  Those have to be regenerated either
manually or with help of available @file{Makefile}s.  The Lisp version
of PowerLoom will automatically recompile the first time the updated
system is loaded.  To recompile the C++ installation follow the
installation instructions given above.  The Java version will need to be
recompiled manually (better patch recompilation support might become
available in the future).

@c ===========================================================================

@node Miscellaneous, Glossary, Installation, Top
@chapter Miscellaneous

This is a catch-all section for documented functions, methods and
relations that haven't been categorized yet into any of the previous
sections.  They are in random order and many of them will never be part
of the official PowerLoom interface.  So beware!

@defmethod @sc{2-d-array} 2-d-element (array @w{(row @sc{integer})} @w{(column @sc{integer})}) : @sc{(like (any-value self))} 
Return the element of @var{array} at position [@var{row}, @var{column}].
@end defmethod

@defmethod @sc{2-d-float-array} 2-d-element (array @w{(row @sc{integer})} @w{(column @sc{integer})}) : @sc{float} 
Return the element of @var{array} at position [@var{row}, @var{column}].
@end defmethod

@defmethod @sc{2-d-array} 2-d-element-setter (array @w{(value @sc{object})} @w{(row @sc{integer})} @w{(column @sc{integer})}) : @sc{(like (any-value self))} 
Set the element of @var{array} at position [@var{row}, @var{column}]
to @var{value} and return the result.
@end defmethod

@defmethod @sc{2-d-float-array} 2-d-element-setter (array @w{(value @sc{float})} @w{(row @sc{integer})} @w{(column @sc{integer})}) : @sc{(like (any-value self))} 
Set the element of @var{array} at position [@var{row}, @var{column}]
to @var{value} and return the result.
@end defmethod

@deffn N-Command add-testing-example (@w{(form @sc{cons})} @w{(score @sc{partial-match-score})}) : 
Add a query and score pair to the master list of 
  testing examples
@end deffn

@deffn N-Command add-training-example (@w{(form @sc{cons})} @w{(score @sc{partial-match-score})}) : 
Add a query and score pair to the master list of 
  training examples
@end deffn

@deffn Function all-asserted-types (@w{(self @sc{object})}) : @sc{(cons of named-description)} 
Return a set of all of the types that are
asserted to be satisfied by @var{self}.
@end deffn

@deffn Function all-class-instances (@w{(type @sc{surrogate})}) : @sc{cons} 
Return a set of instances that belong to the class @var{type}.
@end deffn

@deffn Function all-cycles (@w{(module @sc{module})} @w{(local? @sc{boolean})}) : @sc{(cons of cons)} 
Return a list of lists of descriptions that are
provably co-extensional.
@end deffn

@deffn Function all-direct-subrelations (@w{(relation @sc{named-description})} @w{(removeEquivalents? @sc{boolean})}) : @sc{(cons of named-description)} 
Return a set of relations that immediately specialize
@var{relation}.  If @var{removeEquivalents?} (recommended), don't include any
relations equivalent to @var{relation}.
@end deffn

@deffn Function all-direct-superrelations (@w{(relation @sc{named-description})} @w{(removeEquivalents? @sc{boolean})}) : @sc{(cons of named-description)} 
Return a set of relations that immediately subsume
@var{relation}.  If @var{removeEquivalents?} (recommended), don't include any
relations equivalent to @var{relation}.
@end deffn

@deffn Function all-direct-types (@w{(self @sc{object})}) : @sc{(cons of logic-object)} 
Return a set of most specific types that are
satisfied by @var{self}.
@end deffn

@deffn Function all-equivalent-relations (@w{(relation @sc{named-description})} @w{(reflexive? @sc{boolean})}) : @sc{(cons of named-description)} 
Return a list of all relations equivalent to @var{relation}.
If @var{reflexive?}, include @var{relation} in the list.
@end deffn

@deffn Function all-facts-of-instance (@w{(self @sc{object})} @w{(includeunknownfacts? @sc{boolean})} @w{(elaborate? @sc{boolean})}) : @sc{(list of proposition)} 
Return a list of all definite (TRUE or FALSE) propositions
attached to @var{self}.
@end deffn

@deffn N-Command all-facts-of-n (@w{(n @sc{integer})} @w{&rest (instanceRefs @sc{name})}) : @sc{(cons of proposition)} 
This is a generalization of @code{all-facts-of} (which see).  With @var{n} = 0
and only one instance this command behaves just like @code{all-facts-of}.
Otherwise, returns a cons list of all definite (TRUE or FALSE) propositions
that reference any of the instances listed in @var{instanceRefs}, plus if @var{n} >= 1
all propositions that reference any instances that are arguments of
propositions collected in the previous step, plus if @var{n} >= 2... and so on.
That is, if we only consider binary propositions, this can be viewed as
growing a graph with instances as its nodes and predicates as its arcs
starting from the set of seed @var{instanceRefs} to depth @var{n}-1.
Caution: with a fully connected KB and large enough @var{n} this could return
the whole knowledge base.

The returned propositions include those asserted to be true or false by
default, but it does not include propositions that are found to be
true only by running the query engine.  Facts inferred to be true by
the forward chainer will be included.  Hence, the returned list of
facts may be longer in a context where the forward chainer has been
run then in one where it has not (see @code{run-forward-rules}).
@end deffn

@deffn Function all-instances (@w{(module @sc{module})} @w{(local? @sc{boolean})}) : @sc{(iterator of logic-object)} 
Iterate over all instances (or individuals) visible from @var{module}.
Only instances that haven't been deleted will be considered.  If @var{local?},
only return instances created locally in @var{module}.
@end deffn

@deffn Function all-named-descriptions (@w{(module @sc{module})} @w{(local? @sc{boolean})}) : @sc{(iterator of named-description)} 
Iterate over all named descriptions visible from @var{module}.
If @var{local?}, return only named descriptions interned in @var{module}.
If @var{module} is null, return all named descriptions interned everywhere.
@end deffn

@deffn Function all-named-instances (@w{(module @sc{module})} @w{(local? @sc{boolean})}) : @sc{(iterator of logic-object)} 
Iterate over all named instances (or individuals) visible from @var{module}.
Only instances that haven't been deleted will be considered.  If @var{local?},
only return instances created locally in @var{module}.
@end deffn

@deffn Function all-named-terms (@w{(module @sc{module})} @w{(local? @sc{boolean})}) : @sc{(iterator of object)} 
Iterate over all named terms visible from @var{module}.  A term can be an
instance (or individual) as well as a description.  Only terms that
haven't been deleted will be considered.  If @var{local?}, only return 
terms created locally in @var{module}.
@end deffn

@deffn Function all-propositions (@w{(module @sc{module})} @w{(local? @sc{boolean})}) : @sc{(iterator of proposition)} 
Iterate over all conceived propositions visible from @var{module}.
Only propositions that haven't been deleted will be considered.
If @var{local?}, only return propositions conceived locally in @var{module}.
@end deffn

@deffn Function all-relation-values (@w{(relation @sc{surrogate})} @w{(nMinusOneArguments @sc{cons})}) : @sc{cons} 
Return a set of values that satisfy the relation
@var{relation} (a surrogate) applied to @var{nMinusOneArguments} plus that last value.
@end deffn

@deffn Command all-sentences-of (@w{(instanceRef @sc{object})}) : @sc{(cons of string-wrapper)} 
Return a list of sentences describing facts about @var{instanceRef}.
@end deffn

@deffn Function all-slot-value-types (@w{(self @sc{logic-object})} @w{(relation @sc{surrogate})}) : @sc{(cons of named-description)} 
Return a set of the most specific types for fillers
of the slot @var{relation} applied to @var{self}.
@end deffn

@deffn Function all-slot-values (@w{(self @sc{logic-object})} @w{(relation @sc{surrogate})}) : @sc{cons} 
Return a set of values for the slot @var{relation} (a surrogate)
applied to @var{self} (an object).
@end deffn

@deffn Function all-subrelations (@w{(relation @sc{named-description})} @w{(removeequivalents? @sc{boolean})}) : @sc{(cons of named-description)} 
Return a set of all (named) relations that specialize
relation.
@end deffn

@deffn Function all-superrelations (@w{(relation @sc{named-description})} @w{(removeequivalents? @sc{boolean})}) : @sc{(cons of named-description)} 
Return a set of all relations that subsume relation.
@end deffn

@deffn Function all-terms (@w{(module @sc{module})} @w{(local? @sc{boolean})}) : @sc{(iterator of object)} 
Return a list of all terms visible from @var{module}.  A term can be an
instance (or individual) as well as a description.  Only terms that
haven't been deleted will be considered.  If @var{local?}, only return 
terms created locally in @var{module}.
@end deffn

@deffn Function all-types (@w{(self @sc{object})}) : @sc{(cons of named-description)} 
Return a set of all of the types that are
satisfied by @var{self}.
@end deffn

@deffn Function all-unnamed-terms (@w{(module @sc{module})} @w{(local? @sc{boolean})}) : @sc{iterator} 
Iterate over all unnamed terms visible from @var{module}.  A term can be
an instance (or individual) as well as a description.  Only terms that
haven't been deleted will be considered.  If @var{local?}, only return
terms created locally in @var{module}.
@end deffn

@deffn Function allocate-supported-closure-iterator (@w{(startnode @sc{cons})} @w{(allocateadjacencyiterator @sc{function-code})} @w{(filterfunction @sc{function-code})}) : @sc{supported-closure-iterator} 
Similar to @code{allocate-transitive-closure-iterator} (which see),
but return a SUPPORTED-CLOSURE-ITERATOR instead.
@end deffn

@deffn Function allocate-transitive-closure-iterator (@w{(startNode @sc{object})} @w{(allocateAdjacencyIterator @sc{function-code})} @w{(filterFunction @sc{function-code})}) : @sc{iterator} 
Return an iterator that generates the transitive
closure of applying iterators generated by @var{allocateAdjacencyIterator}
to @var{startNode}.  If @var{filterFunction} is non-null, that function is applied
as a filter to each node generated (nodes filtered out still generate
descendants, but they don't get returned).
@end deffn

@deffn Macro apply-ask (@w{&body (body @sc{cons})}) : @sc{object} 
Execute a yes/no query composed of input-variables
@code{inputVariables} and body @code{queryBody}.  Before executing, bind variables
to @code{inputBindings} (in sequence).
  @code{(apply-ask inputVariables queryBody inputBindings)}
@end deffn

@deffn Function apply-kappa? (@w{(description @sc{description})} @w{(vector @sc{vector})}) : @sc{boolean} 
Apply (inherit) the description @var{description}
to members of the vector @var{vector}.  Return TRUE if no clash was detected.
Constraint propagation happens only if it is enabled prior to calling
@code{apply-kappa?}.
@end deffn

@deffn Macro apply-retrieve (@w{&body (body @sc{cons})}) : @sc{object} 
Execute a query composed of io-variables @code{variables}
and body @code{queryBody}.  Before executing, bind variables to @code{inputBindings}
(in sequence). If one variable is left unbound, returns a cons list of
bindings of that variable.  If two or more are unbound, returns
a cons list of cons lists of bindings:
  @code{(apply-retrieve variables queryBody inputBindings)}
@end deffn

@deffn N-Command ask-partial (@w{&rest (proposition&options @sc{parse-tree})}) : @sc{float} 
Similar to @code{ask} (which see), but return the highest partial match score
for the supplied proposition instead of a truth value.  If the option
:MAXIMIZE-SCORE? is set to FALSE, return after the first partial match score
has been generated.
@end deffn

@deffn Function bottom? (@w{(self @sc{object})}) : @sc{boolean} 
Return TRUE if @var{self} is the undefined individual BOTTOM.
@end deffn

@deffn Command call-all-facts-of (@w{(instanceRef @sc{object})}) : @sc{(list of proposition)} 
Return a list of all definite (TRUE or FALSE) propositions
that reference the instance @var{instanceRef}.
@end deffn

@deffn Function call-ask (@w{(query @sc{object})}) : @sc{truth-value} 
Callable version of @code{ask} (which see).  Accepts queries
specified by a query iterator, or specified as a CONS-list of arguments as they
would be supplied to @code{ask}.  Raises LOGIC-EXCEPTIONs in case of illegal
queries and logical expressions.
@end deffn

@deffn Function call-defconcept (@w{(arguments @sc{cons})}) : @sc{named-description} 
Callable version of the @code{defconcept} command (which see).
Expects the same arguments as @code{defconcept} but supplied as a list.
@end deffn

@deffn Function call-deffunction (@w{(arguments @sc{cons})}) : @sc{named-description} 
Callable version of the @code{deffunction} command (which see).
Expects the same arguments as @code{deffunction} but supplied as a list.
@end deffn

@deffn Function call-defobject (@w{(arguments @sc{cons})}) : @sc{logic-object} 
Callable version of the @code{defobject} command (which see).
Expects the same arguments as @code{defobject} but supplied as a list.
@end deffn

@deffn Function call-defproposition (@w{(arguments @sc{cons})}) : @sc{proposition} 
Callable version of the @code{defproposition} command (which see).
Expects the same arguments as @code{defproposition} but supplied as a list.
@end deffn

@deffn Function call-defrelation (@w{(arguments @sc{cons})}) : @sc{named-description} 
Callable version of the @code{defrelation} command (which see).
Expects the same arguments as @code{defrelation} but supplied as a list.
@end deffn

@deffn Function call-list-undefined-relations (@w{(module @sc{module})} @w{(local? @sc{boolean})}) : @sc{cons} 
Callable version of @code{list-undefined-relations} (which see).
@end deffn

@deffn Function call-propagate-constraints (@w{(context @sc{context})}) : 
Trigger constraint propagation over all propositions
in the module or world @var{context}.
@end deffn

@deffn Function call-retrieve (@w{(query @sc{object})}) : @sc{query-iterator} 
Callable version of @code{retrieve} (which see).  Accepts queries
specified by a query iterator, or specified as a CONS-list of arguments as they
would be supplied to @code{retrieve}.  Raises LOGIC-EXCEPTIONs in case of illegal
queries and logical expressions.
@end deffn

@deffn Function call-retrieve-partial (@w{(query @sc{object})}) : @sc{query-iterator} 
Callable version of @code{retrieve-partial} (which see).  Accepts queries
specified by a query iterator, or specified as a CONS-list of arguments as they
would be supplied to @code{retrieve-partial}.  Raises LOGIC-EXCEPTIONs in case of
illegal queries and logical expressions.
@end deffn

@deffn Function call-run-forward-rules (@w{(module @sc{module})} @w{(force? @sc{boolean})}) : 
Run forward inference rules in module @var{module}. If @var{module}
is NULL, the current module will be used.  If forward inferencing is already
up-to-date in the designated module, no additional inferencing will occur,
unless @var{force?} is set to TRUE, in which case all forward rules are run or rerun.
@end deffn

@deffn Function call-set-inference-level (@w{(levelKeyword @sc{keyword})} @w{(module @sc{module})}) : @sc{keyword} 
Set the inference level of @var{module} to the level specified
by @var{levelKeyword}.  If @var{module} is NULL and we are inside a query, set the
level of the current query iterator.  Otherwise, set the level globally.
@end deffn

@deffn Function class? (@w{(objectRef @sc{object})}) : @sc{boolean} 
Return TRUE if @var{objectRef} denotes a class.
@end deffn

@deffn Function coerce-to-instance (@w{(self @sc{object})} @w{(original @sc{object})}) : @sc{logic-object} 
Return the logic instance referred to by @var{self}.
@end deffn

@deffn Function coerce-to-instance-or-literal (@w{(self @sc{object})} @w{(original @sc{object})}) : @sc{object} 
Return the logic instance referred to by @var{self}, or @var{self} if it is a
literal (e.g., string or number) that can't be coerced.
@end deffn

@deffn Function coerce-to-vector (@w{(self @sc{object})}) : @sc{vector} 
Return a vector containing the elements in @var{self}.
Coerce each element of @var{self} to be a logic object or literal.
@end deffn

@deffn Function collection? (@w{(objectRef @sc{object})}) : @sc{boolean} 
Return TRUE if @var{objectRef} denotes a relation or a class.
@end deffn

@deffn Command conceive-term (@w{(tree @sc{object})}) : @sc{object} 
@var{tree} is a term expression (a string or an s-expression),
or is a class reference (a symbol or surrogate).  Return a (possibly 
newly-conceived) term representing the internalized representation of that term.
@end deffn

@deffn Function conjoin-truth-values (@w{(tv1 @sc{truth-value})} @w{(tv2 @sc{truth-value})}) : @sc{truth-value} 
Return the logical conjunction of truth values @var{tv1} and @var{tv2}.
@end deffn

@defmethod @sc{query-iterator} consify (self) : @sc{cons} 
Generate all solutions for the query self, and collect them into a cons list
of result tuples.  If @code{:SINGLETONS? TRUE}, collect a list of atoms rather than a
list of lists for tuples of arity=1.
@end defmethod

@defmethod @sc{query-solution-table} consify (self) : @sc{cons} 
Collect all solutions of @var{self} into a cons list and return the result.
@end defmethod

@defmethod @sc{justification} consify (self) : @sc{cons} 
Return a CONS tree representation of the proof @var{self}.
Each proof step is represented as a CONS tree of the form
  (<proposition> (<key> <value>...) <antecedent>...)
where each <antecedent> is a CONS tree representing a subproof.  The
consification follows the original proof structure literally, i.e., no
uninteresting nodes such as patterns or AND-introductions are suppressed.
@end defmethod

@defmethod @sc{query-iterator} consify-current-solutions (self) : @sc{cons} 
Collect the current solutions of @var{self} into a cons list
of result tuples.  If @code{:SINGLETONS? TRUE}, collect a list of atoms rather than a
list of lists for tuples of arity=1.
@end defmethod

@deffn Function consify-justification (@w{(self @sc{justification})} @w{(style @sc{keyword})}) : @sc{cons} 
Return a CONS tree representation of the proof @var{self}.
Each proof step is represented as a CONS tree of the form
  (<proposition> (<key> <value>...) <antecedent>...)
where each <antecedent> is a CONS tree representing a subproof.
@var{style} indicates what nodes in the proof tree should be suppressed.
:RAW preserves the original structure literally, :VERBOSE keeps AND-
introductions but suppresses all auxiliary (non-logical) nodes such as
pattern nodes, and :BRIEF additionally suppresses AND-introduction nodes.
@end deffn

@deffn Function constant? (@w{(objectRef @sc{object})}) : @sc{boolean} 
Return TRUE if @var{objectRef} denotes a literal or scalar.
@end deffn

@defmethod @sc{justification} copy (self) : @sc{(like self)} 
Return a copy of the proof starting at @var{self}.  Allocates
all new justification objects, but structure-shares other information such
as propositions and substitutions.
@end defmethod

@deffn N-Command create (@w{(name @sc{generalized-symbol})} @w{&rest (type @sc{generalized-symbol})}) : @sc{object} 
Create a logic object with name @var{name} and return it.
If @var{type} is also supplied, assert that the object belongs to that type.
@end deffn

@deffn Function create-2-d-array (@w{(nof-rows @sc{integer})} @w{(nof-columns @sc{integer})} @w{&rest (values @sc{object})}) : @sc{2-d-array} 
Create a two-dimensional array with @var{nof-rows} rows and
@var{nof-columns} columns, and initialize it in row-major-order from @var{values}.
Missing values will be padded with NULL, extraneous values will be ignored.
@end deffn

@deffn Function create-2-d-float-array (@w{(nof-rows @sc{integer})} @w{(nof-columns @sc{integer})} @w{&rest (values @sc{float})}) : @sc{2-d-float-array} 
Create a two-dimensional array with @var{nof-rows} rows and
@var{nof-columns} columns, and initialize it in row-major-order from @var{values}.
Missing values will be padded with NULL, extraneous values will be ignored.
@end deffn

@deffn Function create-float-vector (@w{&rest (values @sc{float})}) : @sc{float-vector} 
Return a vector containing @var{values}, in order.
@end deffn

@deffn Function create-marker-storage (@w{(supportRecall? @sc{boolean})}) : @sc{marker-table} 
Return a new marker storage object, used to
remember with objects have been @code{marked}.  If @var{supportRecall?}
is set, then the iterator @code{recall-marked-objects} can be invoked
on the new marker storage object.
@end deffn

@deffn Function create-vector (@w{&rest (values @sc{object})}) : @sc{vector} 
Return a vector containing @var{values}, in order.
@end deffn

@deffn Command current-inference-level () : @sc{normal-inference-level} 
Return the current inference level that is active in the
current query, the current module, or, otherwise, globally.
@end deffn

@deffn Function default-false? (@w{(self @sc{proposition})}) : @sc{boolean} 
Return true if @var{self} is default false.
@end deffn

@deffn Function default-true? (@w{(self @sc{proposition})}) : @sc{boolean} 
Return true if @var{self} is default true.
@end deffn

@deffn Function default-truth-value? (@w{(self @sc{truth-value})}) : @sc{boolean} 
Return TRUE if @var{self} is a default truth value.
@end deffn

@deffn Macro define-arithmetic-operation-on-wrappers (@w{(name @sc{symbol})} @w{(operation-name @sc{symbol})}) : @sc{object} 
Defines @var{name} as an arithmetic comparision operation using the
test @code{test-name}.  It will take two wrapped number parameters and
return a wrapped number.  The code will use the appropriate test
for the specific subtype of wrapped number actually passed in,
and return the appropriate subtype of wrapped number based on the
normal arithmetic contagion rules.
  
For example, if both input parameters are wrapped integers then
the output will be a wrapped integer.  If the inputs are a
wrapped integer and a wrapped float then the output will be a
wrapped float, etc.
@end deffn

@deffn Macro define-arithmetic-test-on-wrappers (@w{(name @sc{symbol})} @w{(test-name @sc{symbol})}) : @sc{object} 
Defines @var{name} as an arithmetic comparision operation using the
test @var{test-name}.  It will take two wrapped number parameters and
return a @code{boolean}.  The code will use the appropriate test for
the specific subtype of wrapped number actually passed in.
@end deffn

@deffn Macro define-computed-constraint (@w{(name @sc{symbol})} @w{(var-list @sc{cons})} @w{(constraint-test @sc{cons})} @w{&body (position-computations @sc{cons})}) : @sc{object} 
Defines @var{name} to be a constraint computation which uses
@var{constraint-test} to determine if a fully bound set of variables
satisfies the constraint.  The forms in @var{position-computations}
are used to compute the value for each of the positions. All such
computations must set the variable @code{value} to be the result
computed for the missing position.  Setting @code{value} to @code{null} for
any such computation means that that particular argument cannot
be computed from the others.  The input variables in @var{var-list}
will be bound to the N arguments to the constraint.
  The generated function will return a Stella Object and take as 
inputs the values of the N arguments to the constraint.  A value
of @code{null} means that the value is not available.  If all
arguments are not @code{null}, then the return value will be a Stella
wrapped boolean indicating whether the constraint is satisified
or not.
  If more than one input value is @code{null}, then this constraint
code will not be called.
@end deffn

@deffn Function deobjectify-tree (@w{(self @sc{object})}) : @sc{object} 
Return a copy of @var{self} where all logic objects are
replaced by their @code{generated} parse-tree version.  This is useful to
convert the result of a retrieval query into a regular parse tree.
@end deffn

@defmethod @sc{named-description} describe-object (self @w{(stream @sc{output-stream})} @w{(mode @sc{keyword})}) : 
Prints a description of @var{self} to stream @var{stream}.  @var{mode}
can be :terse, :verbose, or :source.  Used by @code{describe}.
@end defmethod

@defmethod @sc{named-description} description-name (self) : @sc{symbol} 
Return the name of the description @var{self}.
@end defmethod

@defmethod @sc{description} description-name (self) : @sc{symbol} 
Return the name of the description @var{self}, if it has one.
@end defmethod

@deffn Function destroy-instance (@w{(self @sc{object})}) : 
Destroy all propositions that reference @var{self},
and mark it as @code{deleted?}, thereby making it invisible within class
extensions.
@end deffn

@deffn Function destroy-object (@w{(self @sc{object})}) : 
Destroy @var{self} which can be a term or a proposition.  Destroy all
propositions that reference @var{self} and mark it as @code{deleted?} (thereby
making it invisible within class extensions).
@end deffn

@deffn Function destroy-proposition (@w{(proposition @sc{proposition})}) : @sc{proposition} 
Retract and destroy the proposition @var{proposition}.
Recursively destroy all propositions that reference @var{proposition}.
Also, destroy all satellite propositions of @var{proposition}.
@end deffn

@deffn Function destroy-term (@w{(self @sc{logic-object})}) : 
Destroy all propositions that reference @var{self},
and mark it as @code{deleted?}, thereby making it invisible within class
extensions.  Unlink descriptions from native relations.
@end deffn

@deffn Function direct-superrelations (@w{(self @sc{relation})}) : @sc{(iterator of (like self))} 
Return direct super classes/slots of @var{self}.
@end deffn

@deffn Function disabled-powerloom-feature? (@w{(feature @sc{keyword})}) : @sc{boolean} 
Return true if the STELLA @var{feature} is currently disabled.
@end deffn

@deffn Function disjoin-truth-values (@w{(tv1 @sc{truth-value})} @w{(tv2 @sc{truth-value})}) : @sc{truth-value} 
Return the logical disjunction of truth values @var{tv1} and @var{tv2}.
@end deffn

@deffn Function disjoint-terms? (@w{(d1 @sc{description})} @w{(d2 @sc{description})}) : @sc{boolean} 
Return TRUE if @var{d1} and @var{d2} belong to disjoint partitions.
@end deffn

@deffn Function do-clear-instances (@w{(module @sc{module})}) : 
Function version of @code{clear-instances} that evaluates its argument.
@end deffn

@deffn Function do-save-module (@w{(module @sc{module})} @w{(store @sc{object})}) : 
Save @var{module} to the persistent store @var{store} which can
either be an output stream or a persistent OBJECT-STORE.
@end deffn

@defmethod @sc{query-solution-table} empty? (self) : @sc{boolean} 
Return TRUE if @var{self} has zero entries.
@end defmethod

@defmethod @sc{float-vector} empty? (self) : @sc{boolean} 
Return TRUE if @var{self} has length 0.
@end defmethod

@deffn Function enabled-powerloom-feature? (@w{(feature @sc{keyword})}) : @sc{boolean} 
Return true if the STELLA @var{feature} is currently enabled.
@end deffn

@defmethod @sc{paging-index} estimated-length (self) : @sc{integer} 
Return the estimated length of the sequences in @var{self},
which could be too large if some of the members have been deleted.
@end defmethod

@deffn Function explain-why (@w{(label @sc{string})} @w{(style @sc{keyword})} @w{(maxdepth @sc{integer})} @w{(stream @sc{output-stream})}) : 
Programmer's interface to WHY function.
@end deffn

@deffn Function explain-whynot (@w{(label @sc{string})} @w{(style @sc{keyword})} @w{(maxdepth @sc{integer})} @w{(summary? @sc{boolean})} @w{(stream @sc{output-stream})}) : 
Programmer's interface to the WHYNOT function.
@end deffn

@deffn Function false-truth-value? (@w{(self @sc{truth-value})}) : @sc{boolean} 
Return TRUE if @var{self} represents some form of falsehood.
@end deffn

@deffn Function false? (@w{(self @sc{proposition})}) : @sc{boolean} 
Return true if @var{self} is false (or default-false if we are
considering default assertions).
@end deffn

@defmethod @sc{object-store} fetch-instance (store @w{(name @sc{object})}) : @sc{object} 
Fetch the instance identified by @var{name} (a string or symbol) from @var{store}
and return it as an appropriate logic object.  This needs to be appropriately
specialized on actual OBJECT-STORE implementations.
@end defmethod

@defmethod @sc{object-store} fetch-relation (store @w{(name @sc{object})}) : @sc{named-description} 
Fetch the relation identified by @var{name} (a string or symbol) from @var{store}
and return it as a named description.  This needs to be appropriately 
specialized on actual OBJECT-STORE implementations.
@end defmethod

@defmethod @sc{2-d-array} fill-array (self @w{&rest (values @sc{object})}) : 
Fill the two-dimensional array @var{self} in row-major-order
from @var{values}.  Missing values will retain their old values, extraneous values
will be ignored.
@end defmethod

@defmethod @sc{2-d-float-array} fill-array (self @w{&rest (values @sc{float})}) : 
Fill the two-dimensional array @var{self} in row-major-order
from @var{values}.  Missing values will retain their old values, extraneous values
will be ignored.
@end defmethod

@deffn Function finalize-objects () : 
Finalize all currently unfinalized objects.
The user-level entry point for this is @code{(process-definitions)}.
@end deffn

@deffn Function find-direct-supers-and-subs (@w{(self @sc{description})} @w{(onlysupers? @sc{boolean})}) : @sc{(cons of description)} @sc{(cons of description)} @sc{(cons of description)} 
Classify @var{self} and return three values, its direct
supers, direct subs, and a list of equivalent descriptions.
Setting @code{supersOnly?} may speed up the computation (perhaps by a lot).
If @code{description} is nameless and has no dependent propositions, then
it is automatically removed from the hierarchy after classification.
@end deffn

@deffn Function find-direct-supers-of-instance (@w{(self @sc{object})}) : @sc{(cons of logic-object)} 
Classify @var{self} and return a list of most specific 
named descriptions among all descriptions that it satisfies.
@end deffn

@deffn Function find-file-in-load-path (@w{(file @sc{string})} @w{(extensions @sc{(cons of string-wrapper)})}) : @sc{string} 
Try to find @var{file} in the current load path and, if found,
return its full name.  If @var{file} doesn't have its own extension try to find
it with any of the listed @var{extensions}.  If @var{extensions} is NULL it defaults
to @code{*powerloom-kb-file-extensions*}, therefore, to not default to any extensions
the value has to be supplied as NIL.
@end deffn

@deffn N-Command find-instance (@w{(instanceRef @sc{object})}) : @sc{object} 
Return the nearest instance with name @var{instanceRef}
visible from the current module.  @var{instanceRef} can be a string, symbol,
or surrogate.  If @var{instanceRef} is a surrogate, the search originates
in the module the surrogate was interned in.
@end deffn

@deffn N-Command find-rule (@w{(ruleName @sc{name})}) : @sc{proposition} 
Search for a rule named @var{ruleName}.  Like @code{get-rule},
but @code{find-rule} implicity quotes its input argument.
@end deffn

@deffn Function function? (@w{(relationRef @sc{object})}) : @sc{boolean} 
Return TRUE if @var{relationRef} references a function.
@end deffn

@deffn Function generate-expression (@w{(self @sc{logic-object})} @w{(canonicalizevariablenames? @sc{boolean})}) : @sc{object} 
Return an s-expression representing the source expression for @var{self}.
@end deffn

@defmethod @sc{logic-thing} generate-specialized-term (self) : @sc{object} 
Method to generate a specialized term for @var{self}.  This is designed
to allow for extension of the term generation code to cover other
types of objects for the logic.  This particular method will signal
an error unless there is a surrogate-value-inverse link set.
@end defmethod

@deffn Function get-class (@w{(instanceRef @sc{object})}) : @sc{logic-object} 
Return the nearest class with name @var{instanceRef}
visible from the current module.  @var{instanceRef} can be a string, symbol,
or surrogate.  If @var{instanceRef} is a surrogate, the search originates
in the module the surrogate was interned in.
@end deffn

@deffn Function get-instance (@w{(instanceRef @sc{object})}) : @sc{object} 
Return the nearest instance with name @var{instanceRef}
visible from the current module.  @var{instanceRef} can be a string, symbol,
or surrogate.  If @var{instanceRef} is a surrogate, the search originates
in the module the surrogate was interned in.
@end deffn

@deffn Function get-module (@w{(moduleRef @sc{object})}) : @sc{module} 
Return a module named @var{moduleRef}.
@end deffn

@deffn Function get-relation (@w{(instanceRef @sc{object})}) : @sc{logic-object} 
Return the nearest relation with name @var{instanceRef}
visible from the current module.  @var{instanceRef} can be a string, symbol,
or surrogate.  If @var{instanceRef} is a surrogate, the search originates
in the module the surrogate was interned in.
@end deffn

@deffn Function get-self-or-prototype (@w{(instanceRef @sc{object})}) : @sc{logic-object} 
Used to convert a computation to reference so-called
@code{template} slots rather than @code{own} slots:  If @var{instanceRef} denotes a class,
return a prototype of that class.  Otherwise, return @var{instanceRef}.
@end deffn

@deffn Function get-slot-maximum-cardinality (@w{(self @sc{logic-object})} @w{(relation @sc{surrogate})}) : @sc{integer} 
Return a maximum value for the number of fillers of relation
@var{relation} (a surrogate) applied to the instance @var{self} (an object).
@end deffn

@deffn Function get-slot-minimum-cardinality (@w{(self @sc{logic-object})} @w{(relation @sc{surrogate})}) : @sc{integer} 
Return a minimum value for the number of fillers of relation
@var{relation} (a surrogate) applied to the instance @var{self} (an object).
@end deffn

@deffn Function get-slot-value (@w{(self @sc{logic-object})} @w{(relation @sc{surrogate})}) : @sc{object} 
Return a single value for the slot @var{relation} (a surrogate)
applied to @var{self} (an object).
@end deffn

@deffn Function get-slot-value-type (@w{(self @sc{logic-object})} @w{(relation @sc{surrogate})}) : @sc{named-description} 
Return a most specific type for fillers of the slot @var{relation}
(a surrogate) applied to @var{self}. If there is more than one, pick one.
@end deffn

@deffn Function get-why-justification (@w{(label @sc{string})}) : @sc{justification} 
Returns the current WHY justification.  May also throw one of the
following subtypes of EXPLAIN-EXCEPTION:
   EXPLAIN-NO-QUERY-EXCEPTION
   EXPLAIN-NO-SOLUTION-EXCEPTION
   EXPLAIN-NO-MORE-SOLUTIONS-EXCEPTION
   EXPLAIN-NOT-ENABLED-EXCEPTION
   EXPLAIN-NO-SUCH-LABEL-EXCEPTION
   EXPLAIN-QUERY-TRUE-EXCEPTION
@end deffn

@deffn Function get-whynot-justifications (@w{(query @sc{query-iterator})} @w{(label @sc{string})} @w{(mapping @sc{explanation-mapping})}) : @sc{(list of justification)} 
Programmer's interface to WHYNOT function.  Derive
justifications why @var{query} failed, or, if @var{label} was supplied as non-NULL,
lookup its justification relative to @var{mapping} and return the result.
@end deffn

@defmethod @sc{named-description} help-print-outline (top @w{(stream @sc{output-stream})} @w{(current-depth @sc{integer})} @w{(depth @sc{integer})} @w{(named? @sc{boolean})}) : 
Helper function for @code{print-concept-outline}
@end defmethod

@defmethod @sc{description} help-print-outline (top @w{(stream @sc{output-stream})} @w{(current-depth @sc{integer})} @w{(depth @sc{integer})} @w{(named? @sc{boolean})}) : 
Helper function for @code{print-concept-outline}
@end defmethod

@deffn N-Command in-dialect (@w{(dialect @sc{name})}) : @sc{keyword} 
Change the current logic dialect to @var{dialect}.
Currently supported dialects are @code{KIF}, @code{STELLA}, and @code{PREFIX-STELLA}.
The STELLA dialects are not recommended for the construction of knowledge
bases, they are mainly used internally by PowerLoom.
@end deffn

@deffn Function inconsistent-truth-value? (@w{(self @sc{truth-value})}) : @sc{boolean} 
Return TRUE if @var{self} represents INCONSISTENT.
@end deffn

@deffn Function inconsistent? (@w{(self @sc{proposition})}) : @sc{boolean} 
Return true if @var{self} is inconsistent (true and false).
@end deffn

@defmethod @sc{query-solution-table} insert-at (self @w{(key @sc{(like (any-key self))})} @w{(value @sc{(like (any-value self))})}) : 
Insert @var{value} identified by @var{key} into @var{self}.  If a solution
with that key already exists, destructively modify it with the slot values of
@var{value}.  This is necessary to preserve the order of solutions in @var{self}.
@end defmethod

@deffn Function invert-truth-value (@w{(self @sc{truth-value})}) : @sc{truth-value} 
Return the logical negation of @var{self}.
@end deffn

@defmethod @sc{query-solution-table} length (self) : @sc{integer} 
Return the number of entries in @var{self}.
@end defmethod

@deffn Command list-features () : @sc{list} 
Return a list containing two lists, a list of currently enabled PowerLoom
features, and a list of all available PowerLoom features.
@end deffn

@deffn N-Command list-unclassified-instances (@w{(module @sc{name})} @w{(local? @sc{boolean})}) : @sc{(cons of logic-object)} 
Collect all instances in @var{module} (or in any module if @var{module}
is NULL) that were not (or will not be) classified due to their lack of
non-inferable/primitive type assertions.
@end deffn

@deffn N-Command list-unclassified-relations (@w{(module @sc{name})} @w{(local? @sc{boolean})}) : @sc{(cons of named-description)} 
Collect all named description in @var{module} (or in any module if @var{module}
is NULL) that were not (or will not be) classified due to their lack of
non-inferable/primitive ancestor relations.
@end deffn

@deffn N-Command list-undefined-relations (@w{(module @sc{name})} @w{(local? @sc{boolean})}) : @sc{(cons of named-description)} 
Return a list of as yet undefined concepts and relations in @var{module}.
These relations were defined by the system, since they were referenced
but have not yet been defined by the user.  If @var{module} is NULL look in
the current module.  If @var{local?} only look in @var{module} but not in any
modules it inherits.
@end deffn

@defmethod @sc{query-iterator} listify (self) : @sc{list} 
Just like @code{QUERY-ITERATOR.consify} but return a LIST instead.
@end defmethod

@deffn Function load-stream (@w{(stream @sc{input-stream})}) : 
Read logic commands from @var{stream} and evaluate them.
@end deffn

@deffn Function logic-class? (@w{(self @sc{class})}) : @sc{boolean} 
Return TRUE if the class @var{self} or one of its
supers supports indices that record extensions referenced by
the logic system. Also return true for literal classes.
@end deffn

@deffn Function logic-form-less? (@w{(o1 @sc{object})} @w{(o2 @sc{object})}) : @sc{boolean} 
A sorting predicate for objects @var{o1} and @var{o2} that can appear in logical
forms.  Performs a combined numeric and lexocographic sort that accounts
for lists, collections and propositions.  Numbers precede all other values,
@code{null} follows all other values.
@end deffn

@deffn Function logic-module? (@w{(self @sc{module})}) : @sc{boolean} 
Return TRUE if @var{self} is a logic module, implying
that relations defined within it define a knowledge base.  A module
is a logic module iff it inherits the module @code{PL-KERNEL}.
@end deffn

@defmethod @sc{query-solution-table} lookup (self @w{(key @sc{(like (any-key self))})}) : @sc{(like (any-value self))} 
Lookup the solution identified by @var{key} in @var{self} and
return its value, or NULL if no such solution exists.
@end defmethod

@deffn Function lookup-native-specialist (@w{(native-name @sc{string})}) : @sc{function-code} 
Returns the native funtion code for @var{native-name} if it exists
and the underlying programming languages supports such lookups.
@end deffn

@deffn Function named-description? (@w{(self @sc{description})}) : @sc{boolean} 
Return TRUE if @var{self} is the description of a named class or relation.
@end deffn

@deffn Function natural-deduction-mode? () : @sc{boolean} 
True if normalization is governed by natural
deduction semantics.
@end deffn

@defmethod @sc{query-solution-table} non-empty? (self) : @sc{boolean} 
Return TRUE if @var{self} has at least 1 entry.
@end defmethod

@defmethod @sc{float-vector} non-empty? (self) : @sc{boolean} 
Return TRUE if @var{self} has length > 0.
@end defmethod

@defmethod @sc{query-solution-table} nth (self @w{(position @sc{integer})}) : @sc{(like (any-value self))} 
Return the nth solution in @var{self}, or NULL if it is empty.
@end defmethod

@deffn Function object-name (@w{(self @sc{object})}) : @sc{symbol} 
Return the name symbol for the logic object @var{self}.
@end deffn

@deffn Function object-name-string (@w{(self @sc{object})}) : @sc{string} 
Return the name string for the logic object @var{self}.
@end deffn

@deffn Function object-surrogate (@w{(self @sc{object})}) : @sc{surrogate} 
Return the surrogate naming the object @var{self}, which
may be a Stella class that is used in PowerLoom as well as
a more normal powerloom object.
@end deffn

@deffn Function object-surrogate-setter (@w{(self @sc{object})} @w{(name @sc{surrogate})}) : @sc{surrogate} 
Return the name of the logic object @var{self} to @var{name}.
@end deffn

@defmethod @sc{query-solution-table} pop (self) : @sc{(like (any-value self))} 
Remove and return the first solution of @var{self} or NULL
if the table is empty.
@end defmethod

@deffn Function powerloom () : 
Run the PowerLoom listener.  Read logic commands from the
standard input, evaluate them, and print their results.  Exit if the user
entered @code{bye}, @code{exit}, @code{halt}, @code{quit}, or @code{stop}.
@end deffn

@deffn Command powerloom-information () : @sc{string} 
Returns information about the current PowerLoom implementation.
Useful when reporting problems.
@end deffn

@deffn Function pretty-print-logical-form (@w{(form @sc{object})} @w{(stream @sc{output-stream})}) : 
Pretty-print the logical form @var{form} to @var{stream} according
to the current setting of @code{*logic-dialect*}.
@end deffn

@defmethod @sc{2-d-array} print-array (self @w{(stream @sc{native-output-stream})}) : 
Print the array @var{self} to @var{stream}.
@end defmethod

@defmethod @sc{2-d-float-array} print-array (self @w{(stream @sc{native-output-stream})}) : 
Print the array @var{self} to @var{stream}.
@end defmethod

@deffn Function print-extension-sizes (@w{(module @sc{module})} @w{(sizeCutoff @sc{integer})}) : 
Print the extension sizes of concepts visible in @var{module}.
If @var{module} is NULL the current module is used.  Do not report extensions
with size less than @var{sizeCutoff} (default is 10).
@end deffn

@deffn Function print-goal-stack (@w{(frame @sc{control-frame})} @w{(verbose? @sc{boolean})}) : 
Print stack of goals.  Assumes that query has been interrupted
with a full stack of control frames.
@end deffn

@deffn Function print-logical-form (@w{(form @sc{object})} @w{(stream @sc{output-stream})}) : 
Print the logical form @var{form} to @var{stream} according to
the current setting of @code{*logic-dialect*}.  Pretty-printing is controlled
by the current setting of @code{*prettyPrintLogicalForms?*}.
@end deffn

@deffn Function print-logical-form-in-dialect (@w{(self @sc{object})} @w{(dialect @sc{keyword})} @w{(stream @sc{output-stream})}) : 
Produce a stringified version of a logical representation
of @var{self} and write it to the stream @var{stream}.  Use the dialect @var{dialect},
or use the current dialect if @var{dialect} is NULL.
@end deffn

@deffn Function print-unformatted-logical-form (@w{(form @sc{object})} @w{(stream @sc{output-stream})}) : 
Print the logical form @var{form} to @var{stream} according to
the current setting of @code{*logic-dialect*}.  Pretty-printing is explicitly
forced to be turned off.
@end deffn

@deffn Function print-whynot-justification (@w{(justification @sc{justification})} @w{(stream @sc{output-stream})} @w{(maxDepth @sc{integer})} @w{(style @sc{keyword})} @w{(summary? @sc{boolean})}) : 
Print a WHYNOT @var{justification} to @var{stream} according to
@var{maxDepth} and @var{style}.  Print a summary only if @var{summary?} is TRUE.
@end deffn

@deffn Function random-float (@w{(n @sc{float})}) : @sc{float} 
Generate a random integer in the interval [0..n-1].
@var{n} must be <= 2^15.
@end deffn

@defmethod @sc{marker-table} recall-marked-objects (self) : @sc{list-iterator} 
Return an iterator that generates all marked objects
recorded in @var{self}.
@end defmethod

@deffn Function record-justifications? () : @sc{boolean} 
Return TRUE if every query records justifications to enable
the explanation of concluded results.
@end deffn

@deffn Function register-logic-dialect-print-function (@w{(dialect @sc{keyword})} @w{(fn @sc{function-code-wrapper})}) : 
Register @var{fn} as a logic-object print function for @var{dialect}.
Each function should have the signature @code{((self OBJECT) (stream OUTPUT-STREAM))}.
Any return values will be ignored.
@end deffn

@deffn Function register-specialist-function (@w{(name @sc{string})} @w{(code @sc{function-code})}) : 
Creates a registration entry for @var{name} as a specialist which
executes @var{code}.  Essentially just builds the Stella meta-information
tructure needed to funcall @var{name} as a specialist.  The function definition
in @var{code} needs to accept a CONTROL-FRAME and KEYWORD as arguments and
return a KEYWORD.  Side effects on elements of the proposition in the
control frame can be used to bind and thus return values.
@end deffn

@deffn Command register-specialist-function-name (@w{(stella-name @sc{string})} @w{(native-name @sc{string})}) : 
registers a specialist function @var{stella-name} based on the @var{native-name}
for the particular programming language in question.  Use of this command makes
the resulting code or knowledge bases non-portable to other target languages.
@end deffn

@deffn Function relation-name (@w{(self @sc{named-description})}) : @sc{string} 
Given a relation object, return it's name.
@end deffn

@deffn Function relation? (@w{(objectRef @sc{object})}) : @sc{boolean} 
Return TRUE if @var{objectRef} denotes a relation or a class.
@end deffn

@defmethod @sc{query-solution-table} remove-at (self @w{(key @sc{(like (any-key self))})}) : 
Remove the solution identified by @var{key} from @var{self}.
To preserve the solution ordering chain, the solution is marked as deleted
and will be completely removed upon the next iteration through @var{self}.
@end defmethod

@defmethod @sc{paging-index} remove-deleted-members (self) : @sc{(like self)} 
Destructively remove all deleted members of @var{self}.
@end defmethod

@deffn Function reset-query-caches () : 
Zero out all caches managed by the query optimizer,
so that it will reoptimize subgoal queries upon next invocation.
@end deffn

@deffn Function retract-facts-of-instance (@w{(self @sc{logic-object})}) : 
Retract all definite (TRUE or FALSE) propositions attached to @var{self}.
@end deffn

@deffn N-Command retrieve-partial (@w{&rest (tree @sc{parse-tree})}) : @sc{query-iterator} 
Partial-match version of @code{retrieve} (which see) that generates scored
partial solutions based on the current partial match strategy.  By supplying
@code{BEST} instead of @code{ALL}, or by adding the option @code{:SORT-BY :SCORE}, the generated
solutions will be sorted so that solutions with higher scores come first.
Use the @code{:MATCH-MODE} option to override the global default setting established
by @code{set-partial-match-mode}, e.g., use @code{:MATCH-MODE :NN} to use the neural
net partial match mode.  The @code{:MINIMUM-SCORE} option can be used to only
retrieve solutions that have at least the specified minimum match score.
By default, @code{retrieve-partial} does not maximize the match scores of its returned
bindings.  To only get maximal scores use @code{:MAXIMIZE-SCORE? TRUE} (this is not
yet implemented - you can use @code{ask-partial} to maximize scores for individual
solutions by hand).
@end deffn

@deffn N-Command run-forward-rules (@w{(moduleRef @sc{name})} @w{&rest (force @sc{keyword})}) : 
Run forward inference rules in module @var{moduleRef}. If @var{moduleRef} is NULL, the
current module will be used.  If forward inferencing is already up-to-date
in the designated module, no additional inferencing will occur, unless the
optional keyword @code{:force} is included, in which case all
forward rules are run or rerun.

Calling @code{run-forward-rules} temporarily puts the module into a mode where
future assertional (monotonic) updates will trigger additional forward
inference.  Once a non-monotonic update is performed, i.e., a retraction
or clipping of relation value, all cached forward inferences will be discarded
and forward inferencing will be disabled until this function is
called again.
@end deffn

@deffn Command run-powerloom-tests () : 
Run the PowerLoom test suite.  Currently this simply runs all demos and
echos commands and their results to standard output.  The output can then
be diffed with previously validated runs to find deviations.
@end deffn

@deffn Function satisfies? (@w{(instanceOrTuple @sc{object})} @w{(relationRef @sc{object})}) : @sc{truth-value} 
Try to prove whether @var{instanceOrTuple} satisfies the
definition of the relation @var{relationRef} and return the result truth value
of the query.  @var{instanceOrTuple} can be a single object, the name or surrogate
of an object, or a collection (a list or vector) of objects.  @var{relationRef}
can be a relation, description, surrogate or relation name.
@end deffn

@deffn Command save-all-neural-networks (@w{(file @sc{string})}) : 
Save all neural networks to @var{file} (if @var{file} is non-NULL).
If networks are saved periodically (see @code{set-save-network-cycle}) this file
name will be used to perform periodic saves.
@end deffn

@deffn Function select-proof-result (@w{(success? @sc{boolean})} @w{(continuing? @sc{boolean})} @w{(terminal? @sc{boolean})}) : @sc{keyword} 
Helping function for specialists.   Return the appropriate
keyword indicating success or failure of a proof.
@end deffn

@deffn Function select-test-result (@w{(success? @sc{boolean})} @w{(terminal? @sc{boolean})} @w{(frame @sc{control-frame})}) : @sc{keyword} 
Helping function for specialists testing the validity of a
fully bound inference frame.  Based on the test result @var{success?}
and @code{reversePolarity?*}, set the truth value of @var{frame} and return
an appropriate keyword.  The keyword will be either @code{:final-success}
@code{:terminal-failure} if @var{terminal?} is true.  Otherwise it will be
@code{:final-success} or @code{:failure}.
@end deffn

@deffn Command set-error-print-cycle (@w{(i @sc{integer})}) : 
Set number of cycles between which error rates are saved to
the file established by the last call to @code{save-all-neural-networks} appended
with extension @code{.err}.  A number <= 0 (or NULL) turns off periodic saving.
@end deffn

@deffn N-Command set-inference-level (@w{(level @sc{name})} @w{(module @sc{name})}) : @sc{keyword} 
Set the inference level of @var{module} to the level specified
by @code{levelKeyword}.  If @var{module} is NULL, set the level globally.
@end deffn

@defmethod @sc{marker-table} set-marker (self @w{(object @sc{object})}) : 
Record membership of @var{object} in the marker
storage object @var{self}.
@end defmethod

@deffn Command set-num-neighbors (@w{(d @sc{integer})}) : 
Sets the number of nearest neighbors to predict from.
@end deffn

@deffn Command set-num-training-per-case (@w{(d @sc{integer})}) : 
Sets the number of training examples for each case in the training set.
@end deffn

@deffn Function set-powerloom-feature (@w{(feature @sc{keyword})}) : 
Enable the PowerLoom environment feature @var{feature}.
@end deffn

@deffn Command set-save-network-cycle (@w{(i @sc{integer})}) : 
Set number of cycles between which networks are saved to the
file established by the last call to @code{save-all-neural-networks}.  A number <= 0
or a NULL number turns off periodic saving.
@end deffn

@defmethod @sc{query-solution-table} sort (self @w{(predicate @sc{function-code})}) : @sc{(like self)} 
Perform a stable, destructive sort of @var{self} according to
@var{predicate}, and return the result.  If @var{predicate} has a @code{<} semantics, the
result will be in ascending order.
@end defmethod

@deffn Function specializes? (@w{(subObject @sc{object})} @w{(superObject @sc{object})}) : @sc{truth-value} 
Try to prove if the description associated with @var{subObject}
specializes the description for @var{superObject} and return the result truth
value of the query.
@end deffn

@deffn Function strengthen-truth-value (@w{(tv1 @sc{truth-value})} @w{(tv2 @sc{truth-value})}) : @sc{truth-value} 
If @var{tv2} has greater strength than @var{tv1}, adapt the strength of @var{tv1} (not
its value!) and return the result.  Otherwise, return @var{tv1} unmodified.
@end deffn

@deffn Function strict-truth-value? (@w{(self @sc{truth-value})}) : @sc{boolean} 
Return TRUE if @var{self} is a strict truth value.
@end deffn

@deffn Function termify (@w{(self @sc{object})}) : @sc{object} 
Convert @var{self} into an equivalent PowerLoom object
that can be passed as an argument wherever an instance is expected.
@end deffn

@deffn Function test-closed-slot? (@w{(relation @sc{surrogate})}) : @sc{boolean} 
Return TRUE if @var{relation} (a surrogate) is asserted to 
be closed or if the current module closes all relations.
@end deffn

@deffn Function test-function-slot? (@w{(relation @sc{surrogate})}) : @sc{boolean} 
Return TRUE if @var{relation} (a surrogate) is a function.
@end deffn

@defmethod @sc{marker-table} test-marker? (self @w{(object @sc{object})}) : @sc{boolean} 
Return TRUE if @var{object} is stored (marked) in @var{self}.
@end defmethod

@deffn Function test-relation-on-arguments? (@w{(relation @sc{surrogate})} @w{(arguments @sc{cons})}) : @sc{boolean} 
Return TRUE if @var{relation} (a surrogate) is TRUE when
applied to @var{arguments}.
@end deffn

@deffn Function test-slot-value? (@w{(self @sc{logic-object})} @w{(relation @sc{surrogate})} @w{(filler @sc{object})}) : @sc{boolean} 
Return TRUE if the proposition @code{(<relation> <self> <filler>)}
is true.
@end deffn

@deffn Function test-special-marker-table? (@w{(self @sc{object})}) : @sc{boolean} 
Return TRUE if the object @var{self} is stored (marked)
in the table pointed at by the special variable *specialMarkerTable*.
Designed for use by @code{remove-if}.
@end deffn

@deffn Function test-subrelation? (@w{(subrelation @sc{surrogate})} @w{(superrelation @sc{surrogate})}) : @sc{boolean} 
Return TRUE if @var{subrelation} specializes @var{superrelation}.
@end deffn

@deffn Function test-type-on-instance? (@w{(self @sc{object})} @w{(type @sc{surrogate})}) : @sc{boolean} 
Return TRUE if @var{self} satisfies @var{type}.
@end deffn

@deffn Command translate-loom-file (@w{(input @sc{file-name})} @w{(output @sc{file-name})}) : 
Translate the Loom file @var{input} to PowerLoom and write the
translation to the file @var{output}.  Note that this will only
work for fairly vanilla Loom files that do not contain any
Lisp-isms.  It might require to clean the Loom file manually
before this translation will work.
@end deffn

@deffn Function true-truth-value? (@w{(self @sc{truth-value})}) : @sc{boolean} 
Return TRUE if @var{self} represents some form of truth.
@end deffn

@deffn Function true? (@w{(self @sc{proposition})}) : @sc{boolean} 
Return true if @var{self} is true (or default-true if we are
considering default assertions).
@end deffn

@deffn N-Command unassert (@w{(proposition @sc{parse-tree})}) : @sc{object} 
Retract the truth, falsity or inconsistency of @var{proposition}.  This is a
more general version of @code{retract} that also handles falsity.  For example, if
we assert the proposition "(not (sad Fred))", and then execute the statement
"(unassert (sad Fred))", the truth value of the proposition "(sad Fred)"
will be set to UNKNOWN.  If we had called @code{retract} in place of @code{unassert},
the proposition "(sad Fred)" would remain set to FALSE.   Note that for this
unassertion to succeed, the logic constant @code{Fred} and the relation @code{sad} must
already be defined.
@end deffn

@deffn Function unassert-proposition (@w{(self @sc{proposition})}) : 
Retract the truth, falsity or inconsistency of the proposition @var{self}.
@end deffn

@deffn Function unknown-truth-value? (@w{(self @sc{truth-value})}) : @sc{boolean} 
Return TRUE if @var{self} represents UNKNOWN.
@end deffn

@deffn Function unknown? (@w{(self @sc{proposition})}) : @sc{boolean} 
Return true if the truth of @var{self} is unknown.
@end deffn

@deffn Function unset-powerloom-feature (@w{(feature @sc{keyword})}) : 
Disable the PowerLoom environment feature @var{feature}.
@end deffn

@deffn Function upclassify-all-descriptions () : 
Classify all named descriptions.
@end deffn

@deffn Function upclassify-all-instances () : 
Classify all named instances.
@end deffn

@deffn Function upclassify-instances (@w{(module @sc{module})} @w{(local? @sc{boolean})}) : 
Classify instances local to @var{module} and inherited
by @var{module}.  If @var{local?}, don't classify inherited descriptions.  If
@var{module} is NULL, classify descriptions in all modules.
@end deffn

@deffn Function upclassify-named-descriptions (@w{(module @sc{module})} @w{(local? @sc{boolean})}) : 
Classify named descriptions local to @var{module} and inherited
by @var{module}.  If @var{local?}, don't classify inherited descriptions.  If
@var{module} is NULL, classify descriptions in all modules.
@end deffn

@defmethod @sc{object-store} update-proposition-in-store (store @w{(proposition @sc{proposition})} @w{(update-mode @sc{keyword})}) : 
A module with @var{store} has had the truth value of @var{proposition}
change according to @var{update-mode}.  The default method does nothing.
@end defmethod

@deffn Function weaken-truth-value (@w{(tv1 @sc{truth-value})} @w{(tv2 @sc{truth-value})}) : @sc{truth-value} 
If @var{tv2} has lesser strength than @var{tv1}, adapt the strength of @var{tv1} (not
its value!) and return the result.  Otherwise, return @var{tv1} unmodified.
@end deffn

@deffn Macro with-logic-environment (@w{(moduleForm @sc{object})} @w{(environment @sc{object})} @w{&body (body @sc{cons})}) : @sc{object} 
Execute @var{body} within the module resulting from @var{moduleForm}.
@code{*module*} is an acceptable @var{moduleForm}.  It will locally rebind 
@code{*module*} and @code{*context*} and shield the outer bindings from changes.
@end deffn

@deffn Macro within-classification-session (@w{(descriptionorinstance @sc{keyword})} @w{&body (body @sc{cons})}) : @sc{object} 
Used during classification.  Execute @var{body} within the indicated
classification session and inference world.
@end deffn

@deffn Macro within-meta-cache (@w{&body (body @sc{cons})}) : @sc{object} 
Execute @var{body} within the meta cache of the current module.
Set appropriate special variables.
@end deffn


@deffn Function create-keyword (@w{(name @sc{string})}) : @sc{keyword} 
Returns the Stella keyword @var{name}, creating it if
necessary.  @var{name} is treated case-sensitively.  This should
generally not be necessary to do.
@end deffn

@deffn Function create-symbol (@w{(name @sc{string})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{symbol} 
Returns the Stella symbol @var{name} visible in @var{module},
creating it if necessary.  @var{name} is ALWAYS treated case-sensitively,
even if @var{module} is case insensitive. This should generally not be
necessary to do.
@end deffn

@deffn Function get-keyword (@w{(name @sc{string})}) : @sc{keyword} 
Returns the Stella KEYWORD @var{name} if it exists.  Case sensitive.
@end deffn

@deffn Function get-name-in-module (@w{(obj @sc{object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{string} 
Return the name, qualified as necessary, so that @var{obj} can be found from
@var{module}.  If there is no name for the object return @code{null}.
@end deffn

@deffn Function get-short-name (@w{(obj @sc{object})}) : @sc{string} 
Return the short name of @var{obj}, if it has one.  Otherwise return @code{null}.
@end deffn

@deffn Function get-symbol (@w{(name @sc{string})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{symbol} 
Returns the Stella SYMBOL @var{name} visible in @var{module} if it
exists.  @var{name} is ALWAYS treated case sensitively.
@end deffn

@deffn Function is-true-proposition1 (@w{(relation-and-arguments @sc{object})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : @sc{boolean} 
Return TRUE if a proposition (@code{relation} @code{args}) has
been asserted (or inferred by forward chaining).
@end deffn

@deffn Function main () : 
Main PowerLoom entry point for your code in C++ and Java.
@end deffn

@deffn Function register-specialist-function (@w{(name @sc{string})} @w{(function-reference @sc{function-code})} @w{(module @sc{module})} @w{(environment @sc{environment})}) : 
Register @var{name} as a function name in @var{module} which will invoke the
native code procedure described by @code{function-reference.}  The @var{name}
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The function must conform
to the signature for specialist functions.

The exact form of @var{function-reference} depends on the underlying
programming language.  The following type mappings are used:
          C++:  
  Common Lisp:  FUNCTION   (result of #' or (FUNCTION ...))
         Java:  java.lang.reflect.Method
@end deffn

@deffn Function s-register-specialist-function (@w{(name @sc{string})} @w{(native-name @sc{string})} @w{(module-name @sc{string})} @w{(environment @sc{environment})}) : 
Register @var{name} as a function name in the module named @var{module-name}.
This function will the native code named @var{native-name}.  The @var{name}
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The @var{native-name} will be
processed in a manner that depends on the underlying programming
language.  The following type mappings are used:
          C++:  Not available.  Error signaled.
  Common Lisp:  The native-name is read by READ-FROM-STRING and then
                the SYMBOL-FUNCTION is taken.
         Java:  A fully package-qualified name is required.  It is
                looked up using the Reflection tools.
The function found must conform to the signature for specialist functions.
@end deffn

@defmethod @sc{pl-iterator} consify (self) : @sc{cons} 
Convert @var{self} into a Stella CONS.
@end defmethod

@defmethod @sc{pl-iterator} listify (self) : @sc{list} 
Convert @var{self} into a Stella LIST.
@end defmethod


@deffn Command initialize-kernel-kb () : 
Bootstrap the PowerLoom built-in kernel KB.
@end deffn



@c ===========================================================================

@node Glossary, PowerLoom Grammar, Miscellaneous, Top
@chapter Glossary

This glossary contains brief definitions for terms used in the PowerLoom
User's Manual and/or used by the knowledge representation community.  It 
is impractical to give a logically precise definition for many of these
terms, because their interpretation varies quite a bit.
In this case, the glossary attempts to indicate a range of interpretations
consistent with their use in PowerLoom.

@c @display 

@noindent @strong{Assertion:} An assertion states that a particular
proposition is @code{True} or @code{False}.

@noindent @strong{Backward and Forward Inference:} @strong{???}

@noindent @strong{@sc{Backward Rule:}} @strong{???}

@noindent @strong{Binary Relation:} A relation having two arguments
(arity equals two), often as a mapping from one concept domain to
another.  This is by far the most common form of relation.

@noindent @strong{Classifier:} A classifier is a type of an inference
engine that implements efficient strategies for computing subsumption
relations between pairs of concepts, or for computing instance-of
relations between a concept an a set of instances.  PowerLoom implements
a classifier that can be explicitly invoked by an application program.

@noindent @strong{Clipping:} If a function or single-valued binary
relation maps an instance to two or more other instances, a logical
contradiction (a clash) exists.  If clipping is enabled, PowerLoom will
automatically retract all assertions but the last that lead to a clash.
Clipping can be toggled on or off; it is enabled by default.

@noindent @strong{Closed-World Semantics:} Under closed-world semantics
it is assumed that ``if proposition @code{P} cannot be proved
@code{True}, then assume that @code{P} is @code{False}.''  PowerLoom
gives programmers the option to explicitly declare that concept or a
relation operates under the assumption of closed-world semantics (See
also Open-World Semantics).

@noindent @strong{Concept:} A concept defines a category or class of
individuals.  PowerLoom categorizes a concept as a special kind of
relation.  The distinction between a concept and a unary relation is
subtle (some logicians do not believe that there is any
distinction@footnote{but they are mistaken :).}).  In linguistics, the
distinction is that between a noun and an adjective.  In logic, the test
we favor is whether or not the relation has a domain --- a unary
relation has a domain, while a concept does not.  For example, the
relation `married' has domain `person', while the concept
`married-person' does not have a domain (or is its own domain).

@noindent @strong{Constraint:} ``Constraint'' at its most general is a
synonym for ``rule''.  Often a constraint is conceptualized as a rule
that restricts the types of the arguments that can appear within a
tuple.
    
@noindent @strong{Context:} @strong{???}

@noindent @strong{Default Rule:} A default rule expresses an conditional
implication that applies only when its consequent is consistent with
current state of the knowledge base.  In other words, the rule applies
only when it will not lead to a contradition.

@noindent @strong{Definition:} A definition binds a name to a logical
expression.  PowerLoom syntax defines several operators with names of the
form @code{defxxx} (e.g., @code{defconcept} and @code{defrule}) that
declare definitions for various types of entities.

@noindent @strong{Description:} A ``description'' is an expression that
defines a particular logical relation (e.g., the class of all
three-legged black cats).  In PowerLoom, the terms ``concept'' and
``relation'' generally refer to @code{named} relations, while a
description may or may not have a name.  The KIF operators @code{kappa}
and @code{setofall} are used to define unnamed descriptions.

@noindent @strong{Description Logic:} The term ``description logic''
refers to a logic that focuses on descriptions as its principal means
for expressing logical expressions.  A description logic system
emphasises the use of classification and subsumption reasoning as its
primary mode of inference.  Loom and Classic were two early examples of
knowledge representation systems that implement description logics.

@noindent @strong{Domain Model:} A collection of definitions, rules, and
facts that characterizes the possible states of some real or imagined
world.  The domain model specifies a terminology (of concepts and
relations) that is useful for describing objects in that world.  Often
``domain model'' refers to that portion of a world's representation that
does not change over time.

@noindent @strong{Extension:} Given a relation @code{R} with arity
@code{N}, the extension of @code{R} is the set of ground propositions of
the form @code{(R x1 ... xN)} whose truth value is true.  If R is a
concept, then its extension of often considered to be, not a set of
unary tuples, but the set of argument fillers of those tuples, i.e., the
set of instances that belong to the concept.

@noindent @strong{Fact:} A fact is a proposition that has been asserted
to be either @code{True} or @code{False}.  The term ``fact'' usually
refers to a ``ground proposition'', i.e., a proposition that can be
represented as a predicate applied to a sequence of instances or
literals.

@noindent @strong{Filler:} The second argument to a binary tuple is often
refered to as its ``filler''.  When a multiple-valued binary relation
maps an instance to a set of values, these values are also called
``fillers''.

@noindent @strong{Forward Rule:} @strong{???}

@noindent @strong{Function:} Formally, a function is a relation such that the
  value of the last (nth) argument of a relational tuple is a function
of the values of the first n-1 arguments.  This definition coincides
with the notion of a ``single-valued relation''.  PowerLoom (and KIF)
support specialized syntax that allows functions that have been defined
using the operator @code{deffunction} to appear in term expressions
(e.g., @code{(= (f ?x) 42))}).

@noindent @strong{Instance:} An instance denotes an entity within a
domain model, a member of the concept @emph{Thing}.  Depending on ones
interpretation, this could include almost everything.  Often the term
``instance'' is used more narrowly, to exclude literals and other
objects whose properties do not change over time.  PowerLoom assumes
that concepts and relations are instances.

@noindent @strong{KIF:} Short for ``Knowledge Interchange Format'',  KIF
is a language that defines a Lisp-like syntax for the predicate
calculus.  There is an ANSII-standard that defines the KIF syntax and
semantics.  PowerLoom adopts KIF as its representation language, and
adds a few extensions.

@noindent @strong{Knowledge Base:} A knowledge base attempts to capture
in abstract (machine interpretable) form a useful representation of a
physical or virtual world. The entities in that world are modeled in the
knowledge base by objects we call @emph{ terms}. Examples of terms are
``Georgia'' (denoting the U.S., state), ``BenjaminFranklin'' (denoting
the historical person by that name), the number three, the string "abc",
and the concept ``Person''.

@noindent @strong{Literal:} A logically static constant.  Examples are numbers,
strings, quantities, and truth values.

@noindent @strong{Module:} @strong{???}

@noindent @strong{Open-World Semantics:} PowerLoom assumes an open-world
semantics, unless a user explicitly specifies that it use closed-world
semantics.  Under this assumption, if PowerLoom cannot prove or disprove
a proposition, then it assigns that proposition the value @code{Unknown}
(See also Closed-World Semantics).

@noindent @strong{Predicate:}.  The term @emph{predicate} is a syntactic
notion that refers to the zeroth arguments of a proposition.  Predicates
denote relations and properties, i.e., sets.

@noindent @strong{Proposition:}.  A logical sentence whose truth value
can be evaluated with respect to some context.  Each PowerLoom assertion
assigns the value @code{True} or @code{False} to some proposition.

@noindent @strong{Primitive Relation:} @code{P} is a primitive concept
or relation if and only if a proof that @code{(P x1 ... xn)} is true
exists only for the case that there exists an explicit assertion of a
proposition @code{(Q x1 ... xn)} and either @code{Q} equals @code{P} or
@code{Q} is a proper subrelation of @code{P}.  In otherwords, the only
rules that imply membership in @code{P} are those that relate @code{P}
to one of its (proper) subconcepts or subrelations.
  
@noindent @strong{Query:} A query probes the informational state of a
knowledge base.  An @code{ask} query test the truth of its propositional
argument.  A @code{retrieve} asks for sets of constants (bindings) that
make its propositional argument true when the constants are substituted
in place of its variables.  The propositional argument to @code{ask} and
@code{retrieve} arbitrary expression in the first-order predicate
calculus.  Because of constraints imposed either by resource limitations
or inherent undecidability, PowerLoom cannot guarantee the completeness
of its inferences.

@noindent @strong{Relation:} @strong{???}

@noindent @strong{Retraction:} A retraction changes the truth value of a
proposition from either @code{True} or @code{False} to the value
@code{Unknown}.  Retraction is a procedural (non-declarative) operation.

@noindent @strong{Rule:} A ``rule'' is any universally-quantified
proposition, i.e., a proposition of the form @code{(forall (?x1 ... ?xn)
<logical sentence with free variables ?x1 ... ?xn)}.  PowerLoom supports
several different syntactic constructs for defining rules.  (See also
Forward Rule and Backward Rule).

@noindent @strong{Subsumption:} A subsumption relation specifies the
relative generality of two concepts.  A concept @code{A} subsumes a
concept @code{B} if the definitions of @code{A} and @code{B} logically
imply that members of @code{B} must also be members of @code{A}.

@noindent @strong{Truth-Maintenance:} @strong{???}
@c PowerLoom does not currently implement a truth maintenance capability.

@ignore 
<THIS DEFINITION IS WRONG, SINCE A TUPLE IS NOT A PROPOSITION.  RATHER THAN
FIXING IT, WE MAY WISH TO SKIP THE NOTION ENTIRELY?  -RMM
@noindent @strong{Tuple}.  A tuple is a proposition of the form 
@code{(R x_1 ... x_N)} for some relation @code{R}, where the {x_i} are
instances.  The propositions that form the extension of a relation are
often called ``tuples''.  A ground fact.
@end ignore

@noindent @strong{Type:} Often used a synonym for the term
@emph{concept}.  The phrase ``a type of an instance'' generally refers
to (one of) the concepts that the instance belongs to.  The phrase ``nth
domain type'' refers to a concept that contains all instances of the nth
column of a relation.

@noindent @strong{World:}
@strong{???}

@c @end display

@c===========================================================================

@node PowerLoom Grammar, Function Index, Glossary, Top
@chapter PowerLoom Grammar

The syntax of PowerLoom is described below using a modified BNF notation
adapted from the KIF specification.

@c ---------------------------------------------------------------------------

@menu
* Alphabet::                    
* Grammar::                     
@end menu

@node Alphabet, Grammar, PowerLoom Grammar, PowerLoom Grammar
@section Alphabet

We distinguish between terminals, which are part of the language, and
nonterminals. All nonterminals are bracketed as follows
@code{<nonterminal>}. Squared brackets means zero or one instances of
the enclosed expression; @code{<nonterminal>*} means zero or more
occurrences and @code{<nonterminal>+} means one or more occurrences of
@code{<nonterminal>}. The notation @code{<nonterminal1> - <nonterminal2>}
refers to all of the members of @code{<nonterminal1>} except for those
in @code{<nonterminal2>}.

A word is a contiguous sequence of characters, which include all upper
case letters, lower case letters, digits and alpha characters (ASCII
character set from 93 to 128) excluding some special characters like
white spaces, single and double quotes and brackets. 

@code{<word> ::=} @var{a primitive syntactic object}

Special words are those who refer to a variable. All variables are
preceded by a question mark.

@code{<indvar> ::=} @var{a word beginning with the character} @code{?}

A string @code{<string>} is a character sequence including words plus
all special charcters (except double quotes) enclosed in double quotes.
A double quote can be included in a string if it is preceeded by the
escape character '@code{\}'.

@c ---------------------------------------------------------------------------

@node Grammar,  , Alphabet, PowerLoom Grammar
@section Grammar

Legal expressions in PowerLoom are forms, which are either a statement or
a definition, described in more detail below.

@code{<form> ::= <statement> | <definition>}

@c ---------------------------------------------------------------------------

@menu
* Constants and Typed Variables::  
* Terms::                       
* Sentences::                   
* Definitions::                 
@end menu

@node Constants and Typed Variables, Terms, Grammar, Grammar
@subsection Constants and Typed Variables

The language consists of several groups of operators, defined as follows:

@code{<termop> ::= listof | setof | the | setofall | kappa}
@ignore
<HANS ELIMINATED 'lambda' FROM THIS LIST.  WHERE SHOULD IT GO? -rmm>
@end ignore

@code{
<sentop> ::= = | /= | not | and | or | forall | exists @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ | <= | => | <=> |<<= | =>> | <~ | ~> | <<~ | ~>> }

@code{
<defop> ::= defconcept | deffunction | defrelation | defrule | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ :documentation | :-> | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ :<= | :=> | :<<= | :=>> | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ :<=> | :<=>> :<<=> | :<<=>> | := | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ :axioms }

@code{<operator> ::= <termop> | <sentop> | <defop>}

All other words are constants (words which are not operators or variables):

@code{<constant> ::= <word> - <indvar> - <operator>}

Semantically, there are different categories of constants --- @emph{Concept}
constants @code{<conceptconst>}, @emph{Function} constants
@code{<funconst>}, @emph{Relation} constants @code{<relconst>},
@emph{Rule} constants @code{<ruleconst>} and @emph{Logical} constants
@code{<logconst>}. The differences between these categories are entirely
semantic. However, some operators will only accept specific constants.

In contrast to the specification of KIF3.0, PowerLoom supports a typed
syntax. Therefore, variables in quantified terms and sentences can appear
either typed or untyped, as follows:

@code{<vardecl> ::= (<indvar> <constant>) | <indvar>}

@c ---------------------------------------------------------------------------

@node Terms, Sentences, Constants and Typed Variables, Grammar
@subsection Terms

Terms are used to denote objects in the world being described:

@code{
<term> ::= <indvar> | <constant> | <funterm> | <listterm> | <setterm> | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ <quanterm>}

@code{<listterm> ::= (listof <term>*)}

@code{<setterm> ::= (setof <term>*)}

@code{<funterm> ::= (<funconst> <term>+)}

Note: Zero arguments are allowed for @code{<funterm>} in KIF3.0:
@code{<term>*}

@code{
<quanterm> ::= (the <vardecl> <sentence>) | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ (setofall <vardecl> <sentence>) | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ (kappa @{<vardecl> | (<vardecl>+)@} <sentence>) | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ (lambda @{<vardecl> | (<vardecl>+)@} <term>)
}

Note: KIF3.0 allows @code{<term>} instead of @code{<vardecl>} for
@code{setofall}. No @code{<quanterm>} as well as no @code{<setterm>} in
core of KIF as a result of descision 95-3 (March 1995).

@c ---------------------------------------------------------------------------

@node Sentences, Definitions, Terms, Grammar
@subsection Sentences

Sentences are used to express propositions about the world:

@code{
<sentence> ::= <constant> | <equation> | <inequality> | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ <relsent> | <logsent> | <quantsent>
}

@code{<equation> ::= (= <term> <term>)}

@code{<inequality> ::= (/= <term> <term>)}

@code{<relsent> ::= (<constant> <term>+)}

Note: Zero arguments allowed in KIF3.0 for @code{<relsent>}
(@code{<term>*}). @code{<funconst>} is currently not allowed in
PowerLoom (use @code{(= <funterm> <term>)} instead). 

@code{
<logsent> ::= (not <sentence>) | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ (and <sentence>*) | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ (or <sentence>*) | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ (=> <sentence>* <sentence>) | (=>> <sentence>* <sentence>) | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ (<= <sentence> <sentence>*) | (<<= <sentence> <sentence>*) | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ (~> <sentence>* <sentence>) | (~>> <sentence>* <sentence>) | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ (<~ <sentence> <sentence>*) | (<<~ <sentence> <sentence>*)
}

@code{
<quantsent> ::= (forall @{<vardecl> | (<vardecl>+)@} <sentence>) | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ (forall @{<vardecl> | (<vardecl>+)@} <sentence> <sentence>) | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ (exists @{<vardecl> | (<vardecl>+)@} <sentence>)
}

@c ---------------------------------------------------------------------------

@node Definitions,  , Sentences, Grammar
@subsection Definitions

PowerLoom supports two distinct categories of definitions --- relation
definitions (including concept and function definitions) and rule
definitions.  A relation definition introduces a new logical constant,
and states some facts about that constant (e.g., who its parents are in
a subsumption taxonomy).  A rule definitions binds a new constant to a
proposition (so that the constant @emph{denotes} the proposition) and
asserts the truth of that proposition.  Usually, the proposition
asserted by a @code{defrule} is an implication.  The assertional truth
of a proposition defined by a rule can be altered by asserting or
retracting the constant that denotes the proposition.

@example
<keyword-option> ::= <keyword> <word>
<definition> ::= <reldefinition> | <objdefinition> | <ruledefinition>

<reldefinition> ::= 
 (defconcept <conceptconst> <vardecl>
    [:documentation <string>]
    [:<= <sentence>] | [:=> <sentence>] |
    [:<<= <sentence>] | [:=>> <sentence>] | 
    [:<=> <sentence>] | [:<=>> <sentence>] | [:<<=> <sentence>] |
    [:<<=>> <sentence>] |
    [:axioms @{<sentence> | (<sentence>+)@}] |
    [<keyword-option>*])
 |
 (deffunction <funconst> (<vardecl>+)
    [:documentation <string>]
    [:-> <vardecl>]
    [:<= <sentence>] | [:=> <sentence>] |
    [:<<= <sentence>] | [:=>> <sentence>] | 
    [:<=> <sentence>] | [:<=>> <sentence>] | [:<<=> <sentence>] |
    [:<<=>> <sentence>] |
    [:axioms @{<sentence> | (<sentence>+)@}]
    [<keyword-option>*])
 |
 (defrelation <relconst> (<vardecl>+)
    [:documentation <string>]
    [:<= <sentence>] | [:=> <sentence>] |
    [:<<= <sentence>] | [:=>> <sentence>] | 
    [:<=> <sentence>] | [:<=>> <sentence>] | [:<<=> <sentence>] |
    [:<<=>> <sentence>] |
    [:axioms @{<sentence> | (<sentence>+)@}]
    [<keyword-option>*])

<objdefinition> ::= (defobject <constant>
                       [:documentation <string>]
                       [<keyword-option>*])

<ruledefinition> ::= (defrule <constant> <sentence>
                       [:documentation <string>]
                       [<keyword-option>*])
@end example

@code{<ruledefinition> ::= (defrule <ruleconst> <sentence>)}

@c ===========================================================================

@node Function Index, Variable Index, PowerLoom Grammar, Top
@unnumbered Function Index

@printindex fn

@c ---------------------------------------------------------------------------

@node Variable Index, Concept Index, Function Index, Top
@unnumbered Variable Index

@printindex vr

@c ---------------------------------------------------------------------------

@node Concept Index,  , Variable Index, Top
@unnumbered Concept Index

@printindex cp

@c ===========================================================================

@bye
