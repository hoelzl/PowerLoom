<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<!-- Created on May, 25  2006 by texi2html 1.65 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>PowerLoom Manual: Conceptual Framework</TITLE>

<META NAME="description" CONTENT="PowerLoom Manual: Conceptual Framework">
<META NAME="keywords" CONTENT="PowerLoom Manual: Conceptual Framework">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.65">

</HEAD>

<BODY LANG="en" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC7"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_2.html#SEC6"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC8"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_2.html#SEC2"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC12"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 3. Conceptual Framework </H1>
<!--docid::SEC7::-->
<P>

This chapter presents the fundamental conceptual building blocks that are used
to construct PowerLoom knowledge bases. The PowerLoom language is based on KIF,
which provides a syntax and a declarative semantics for first-order predicate
calculus expressions. KIF is a proposed ANSII standard language used by a
variety of knowledge representation systems. Practical knowledge representation
systems necessarily add a procedural semantics that defines the interpretation
of knowledge structures when definitions and facts are retracted or modified.
This chapter assumes that the reader has some familiarity with the semantics of
the predicate calculus, and instead focuses on aspects of the semantics that go
beyond the traditional (KIF) semantics.
</P><P>

A PowerLoom knowledge base is constructed by first defining the
terminology (concepts and relations) for a domain, and then asserting
additional rules and facts about that domain. Facts can be asserted and
later retracted, so the answers returned by queries may change over
time. The knowledge structures are organized into logical containers
called "modules". The division into modules means that in general,
facts are not asserted globally, but instead hold only within a specific
context. For example, a logical proposition may evaluate as true within
one module, and evaluate as false within a different one.
</P><P>

The discussion below uses some examples of actual PowerLoom syntax
to illustrate certain points.  However, we gloss over the fine
points of syntax, and instead focus on semantic issues.  The next
chapter reverses that emphasis, and presents a series of examples
that illustrate the breadth of syntactic constructs implemented for
the PowerLoom language.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_3.html#SEC8">3.1 Terms and Propositions</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_3.html#SEC9">3.2 Definitions</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_3.html#SEC10">3.3 Truth Values</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_3.html#SEC11">3.4 Modules</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Terms and Propositions"></A>
<HR SIZE="6">
<A NAME="SEC8"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC7"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC9"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC7"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC7"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC12"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 3.1 Terms and Propositions </H2>
<!--docid::SEC8::-->
<P>

A knowledge base attempts to capture in abstract (machine interpretable)
form a useful representation of a physical or virtual world. The entities
in that world are modeled in the knowledge base by objects we call <EM>
terms</EM>. Examples of terms are "Georgia" (denoting the U.S., state),
"BenjaminFranklin" (denoting the historical person by that name), the
number three, the string "abc", and the concept "Person". Unlike
objects in an object-oriented programming language, the terms in a
PowerLoom knowledge base usually have distinct names (unless there are
sufficiently many that naming them all becomes impractical).
</P><P>

Terms are categorized or related to one another by objects called
<EM>relations</EM>.  Examples of relations are "has age", "greater than",
"is married to", "plus".  Concepts such as "Person", "State",
"Company", and "Number" are considered a subcategory of relations.
</P><P>

A <EM>proposition</EM> is a logical sentence that has an associated truth
value. Examples are "Ben Franklin is a person", "Bill is married to
Hillary", "Two plus three equals six" (which is false). PowerLoom
follows KIF in adopting a prefix notation for the predicate calculus to
represent propositions. Possible representations of the three
propositions just mentioned are <CODE>(person ben-franklin)</CODE>,
<CODE>(married-to Bill Hillary)</CODE>, and <CODE>(= (+ 2 3) 6)</CODE>. These three
propositions make reference to relations named <CODE>person</CODE>,
<CODE>married-to</CODE>, <CODE> plus</CODE>, and <CODE>=</CODE>.
</P><P>

The predicate calculus constructs complex sentences out of simpler ones
using the logical connectives <CODE>and</CODE>, <CODE>or</CODE>, <CODE>not</CODE>, <CODE>&#60;=</CODE>,
<CODE>=&#62;</CODE>, and <CODE>&#60;=&#62;</CODE>, and the
quantifiers <CODE>exists</CODE> and <CODE>forall</CODE>. Some examples are <CODE>(not
(crook richard))</CODE> "Richard is not a crook", and <CODE>(forall ?p
(=&#62; (person ?p) (exists ?m (has-mother ?p ?m))))</CODE> "every person has a
mother".
</P><P>

<A NAME="Relation Definitions"></A>
<HR SIZE="6">
<A NAME="SEC9"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC8"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC10"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC7"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC7"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC12"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 3.2 Definitions </H2>
<!--docid::SEC9::-->
<P>

PowerLoom requires that relations are defined before they are
used within assertions and queries.  The commands <CODE>defconcept</CODE>,
<CODE>defrelation</CODE>, and <CODE>deffunction</CODE> are used to define
concepts, relations, and functions, respectively.  The definitions
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defconcept person)
(defrelation married-to ((?p1 person) (?p2 person))
(deffunction + ((?n1 number) (?n2 number)) :-&#62; (?sum number))
</pre></td></tr></table></P><P>

declare that <CODE>person</CODE> is a concept, that <CODE>married-to</CODE>
is a binary relation that takes arguments of type <CODE>person</CODE>,
and that <CODE>+</CODE> is a function that takes arguments of type
<CODE>number</CODE><A NAME="DOCF1" HREF="manual_fot.html#FOOT1">(1)</A>.  The requirement
that relations be defined before they are referenced can be
inconvenient at times.  For example, suppose we wish to define
<CODE>parent</CODE> as "a person who is the parent of another person"
and we also wish to state that the first argument to the 
<CODE>parent-of</CODE> relation has type <CODE>parent</CODE>:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defconcept parent (?p)
  :&#60;=&#62; (and (person ?p) (exists ?c (parent-of ?p ?c))))
(defrelation parent-of ((?p parent) (?c person)))
</pre></td></tr></table></P><P>

In this example, the first reference to <CODE>parent-of</CODE> occurs before it
is defined. PowerLoom permits circular references such as these as long
as they occur within definitions. It does so by deferring evaluation of
rules that occur within definitions. Here is a specification that is
logically equivalent, but is not legal because the <CODE>parent-of</CODE>
relation appears in an assertion before it is defined:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defconcept parent (?p))
(assert (forall (?p) (&#60;=&#62; (parent ?p) 
                          (and (person ?p) (exists ?c (parent-of ?p ?c))))))
(defrelation parent-of ((?p parent) (?c person)))
</pre></td></tr></table></P><P>

So when does the rule inside of the first <CODE>parent</CODE> definition get
defined?  All axioms (facts and rules) that appear within the boundaries
of a definition are evaluated just prior to the next occurrence of
a PowerLoom query.  Hence, in the example above where the rule occurred
<EM>within</EM> the definition, there was no error because evaluation of
that rule occured sometime after the second definition (which defines
the otherwise problematic reference to <CODE>parent-of</CODE>).
</P><P>

One will sometimes see the command <CODE>(process-definitions)</CODE> appearing at
intervals within a file containing PowerLoom commands. Each such
appearance forces the definitions that preceed it to be fully-evaluated.
This is done so that the interval between a definition and its evaluation
not be too great; it can get confusing if PowerLoom reports a semantic
violation long after the origin of the conflict.
</P><P>

PowerLoom definitions commands (those prefixed by "def") have one other
semantic property that distinguishes them from ordinary assertions. Any
axioms that appear within a definition are tied to that definition.
If a definition is modified and then reevaluated, axioms that don't
survive the modification are retracted.  For example, suppose we
evaluate the following two commands.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defrelation parent-of ((?p1 person) (?p2 person))
  :=&#62; (relative-of ?p1 ?p2))
(defrelation parent-of ((?p1 person) (?p2 person)))
</pre></td></tr></table></P><P>

The first definition defines <CODE>person</CODE> as a binary relation,
and also states a rule that "<CODE>parent-of</CODE> implies <CODE>relative-of</CODE>".
The second definitions erases that rule, i.e., the cumulative
effect is as if the first definition did not appear.  In contrast,
consider the following commands:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defrelation parent-of ((?p1 person) (?p2 person)))
(assert (=&#62; (parent-of ?p1 ?p2) (relative-of ?p1 ?p2)))
(defrelation parent-of ((?p1 person) (?p2 person)))
</pre></td></tr></table></P><P>

The assertion in this latter sequence is logically equivalent to the
axiom introduced by the <CODE>:=&#62;</CODE> keyword in the former sequence.
However, at the end of this sequence, the "<CODE>parent-of</CODE> implies
<CODE>relative-of</CODE>" rule is still in effect, since it appeared on its
own, outside of a definition.
</P><P>

<A NAME="Truth Values"></A>
<HR SIZE="6">
<A NAME="SEC10"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC9"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC11"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC7"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC7"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC12"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 3.3 Truth Values </H2>
<!--docid::SEC10::-->
<P>

A PowerLoom proposition is tagged with a truth value that has one of
five different settings---<CODE>true</CODE>, <CODE>false</CODE>,
<CODE>default-true</CODE>, <CODE>default-false</CODE>, or <CODE>unknown</CODE>. The most
common setting is <CODE>true</CODE>; when we make an assertion as in
<CODE>(assert (Person Bill))</CODE>, the proposition <CODE>(Person Bill)</CODE> is
assigned the truth value <CODE>true</CODE>. To assign the value <CODE>false</CODE>
to a proposition, one asserts that it is not true, e.g., <CODE>(assert
(not (crook Richard)))</CODE>. The command <CODE>presume</CODE> is used to assign a
proposition the value <CODE>default-true</CODE>, as in <CODE>(presume
(weather-in Los-Angeles Sunny))</CODE>. Presuming a negated proposition
assigns it the value <CODE>default-false</CODE>.
</P><P>

The assignment of a truth value to a proposition via <CODE>assert</CODE> or
<CODE>presume</CODE> can upgrade the "strength" of a proposition, but it
cannot downgrade it. Hence, if a proposition currently has the value
<CODE>unknown</CODE>, then it may be assigned any of the other four values. If
the value is <CODE>default-true</CODE> or <CODE>default-false</CODE>, an assertion
that assigns the value <CODE>true</CODE> or <CODE>false</CODE> will overwrite the
existing value. However, if the truth value of a proposition is either
<CODE>true</CODE> or <CODE>false</CODE>, assigning it the value <CODE>default-true</CODE>
or <CODE>default-false</CODE> will have no effect.
</P><P>

If a proposition is asserted to be <CODE>true</CODE> and subsequently is
asserted to be <CODE>false</CODE> (or vice-versa), a <EM>clash</EM> (or
contradiction) results. When a clash is detected by PowerLoom, a
<CODE>clash-exception</CODE> is thrown. The system's default behavior is for
the exception to be caught and ignored, with the result that an
assertion that would otherwise cause a clash never takes
effect. Applications that execute commands slightly below the top-level
(i.e., below the clash exception catcher) can catch the exception
themselves and perform a specialized response. PowerLoom's
proof-by-contradiction specialist catches clashes to determine that a
contradiction has occurred.
</P><P>

If a user or application wants to assign a proposition a truth value
that isn't stronger than the current value, it must first <CODE>retract</CODE>
the current value.  The PowerLoom <CODE>retract</CODE> operator has the effect
of undoing a prior assertion.  For example, if we assert that Mary is a
parent of Fred, and then retract that assertion, the value of the
proposition <CODE>(parent-of Mary Fred)</CODE> becomes <CODE>unknown</CODE>.  The
proposition can then be assigned any other truth value.
</P><P>

We should note that executing a retraction does not necessarily cause a
proposition to cease being true.  Consider the following sequence:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defconcept Person)
(defconcept Employee (?e)
  :=&#62; (Person ?e))
(assert (Person Mary))
(assert (Employee Mary))
(retract (Person Mary))
</pre></td></tr></table></P><P>

If we now ask PowerLoom whether or not Mary is a person, the answer
will be yes (TRUE) because Mary is asserted to be an employee, and
membership in <CODE>employee</CODE> implies membership in <CODE>person</CODE>.
In other words, although the direct assertion that Mary is a person
is not present in the knowledge base, a logical proof exists that
the proposition "Mary is a person" is true.
</P><P>

<A NAME="Modules"></A>
<HR SIZE="6">
<A NAME="SEC11"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC10"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC12"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC7"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC7"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC12"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 3.4 Modules </H2>
<!--docid::SEC11::-->
<P>

The knowledge loaded into an executing PowerLoom system is
divided into logical partitions called "modules".  The modules
are arranged into a hierarchy; knowledge inherits down the
hierarchy from parents to children.  A convenient way to organize
knowledge is to put definitional knowledge higher up in the
module hierarchy, and factual knowledge lower down.  For example,
suppose we want to build a knowledge base that defines a business
domain, and include a substantial number of facts about individual
companies. We might use one or a few modules to define terminology that
relates to the business domain, and then places the set of facts
about each company in its own module.  If we were querying the
knowledge base about one or a few companies, it would not be
necessary to load the modules for the remaining companies into the
system.
</P><P>

Facts asserted within a module are not visible in sibling modules, or in
ancestor modules. Thus, if we enter into PowerLoom an assertion
that"Georgia is a state", we are not asserting that Georgia is a state
in all possible worlds, but that, from the vantage point of the current
module and those modules below, it is the case that Georgia is a state. If
we want the fact that Georgia is a state to be recognized as true in
many or most other modules, then we should make our assertion in a module
that is relatively high up in the hierarchy, so that is visible to
(inherited by) the other modules.
</P><P>

The inheritance of facts is <EM>not monotonic</EM>---a child module can
retract or override facts inherited from its ancestors. For example,
suppose we have two modules, called <CODE>above</CODE> and <CODE>below</CODE> such
that the <CODE>below</CODE> module is below (inherits from) the <CODE>above</CODE>
module. Next, suppose we make an assertion within the <CODE>above</CODE>
module that "Joel is a duck", and then we shift to the <CODE>below</CODE>
module and retract the proposition that "Joel is a duck". From the
vantage point of the <CODE>below</CODE> module, if we now ask if Joel is a
duck, we will get back the value <CODE>unknown</CODE>.  However, if we switch
to the <CODE>above</CODE> module and ask the same question, we get back the
answer <CODE>true</CODE> This occurs because the effect of the retraction
operation that was applied to the <CODE>below</CODE> module is not "visible"
to modules above it (or to any sibling modules). Hence, when module
hierarchies are involved, it is oversimplifying to state that a
retraction has the effect of erasing a prior assertion.
</P><P>

The PowerLoom execution process maintains a pointer to the current module, and
all asserions, queries, etc. are made relative to that module.  Hence, when we
talk about "switching" from one module to another, we are speaking
literally--a <CODE>change-module</CODE> command (or one of its equivalents) is
invoked to switch from one module to another.   <A NAME="DOCF2" HREF="manual_fot.html#FOOT2">(2)</A> 
</P><P>

PowerLoom comes with some modules already built-in. The module named
<CODE>PL-KERNEL</CODE> contains a set of general-purpose concept and relation
definitions that collectively form the foundation for constructing
application-specific knowledge bases. PowerLoom attaches specialized
reasoners to many of the relations in <CODE>PL-KERNEL</CODE>. The command
interpreter starts up in a module named <CODE>PL-USER</CODE>. That module is
initially empty, and is intended as a convenient place to experiment with
PowerLoom.
</P><P>

<A NAME="Annotated Example"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC7"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC12"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Hans Chalupsky</I> on <I>May, 25  2006</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>
</FONT>

</BODY>
</HTML>
