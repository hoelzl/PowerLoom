\input texinfo.tex @c -*-texinfo-*-

#$(util/texinfo-insert-preamble)


@c Version: manual.texi.in,v 1.40 2006/05/25 18:42:38 hans Exp

@setfilename manual.info


@c TexInfo formatting notes:
@c
@c - After updates do the following to update the node & menu structure:
@c   - insert node lines with titles taken from section headings via
@c         C-x h C-u M-x texinfo-insert-node-lines
@c   - link all nodes via
@c         M-x texinfo-every-node-update
@c   - create or update menus via
@c         M-x texinfo-all-menus-update
@c
@c - Don't fiddle with nodes and menus before the overall structure isn't
@c   pretty much determined (one can run `makeinfo' even without nodes)
@c - Node names have to be unique
@c - Node names should be short, keep details in their explanations -
@c   this makes the menus look better


@c Define a macro for use with constants like TRUE, FALSE, etc:

@macro constant{CONST}
@sc{\CONST\}
@end macro

@macro trademarksymbol
@math{^{@r{TM}}}
@end macro


@settitle PowerLoom Manual

@iftex
@finalout
@end iftex

@ifinfo
This file documents the
@html
PowerLoom&#8482;
@end html
knowledge representation and reasoning system.
@end ifinfo

@copying
Copyright @copyright{} 2006
University of Southern California, Information Sciences Institute,
4676 Admiralty Way,
Marina Del Rey, CA 90292, USA

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

PowerLoom is a trademark of the University of Southern California.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission notice
identical to this one except for the removal of this paragraph (this
paragraph not being relevant to the printed manual).

@end ignore
@end copying

@titlepage
@sp 6
@center @titlefont{PowerLoom@trademarksymbol{} Manual}
@sp 1
@center Powerful knowledge representation and reasoning with
@center delivery in Common-Lisp, Java, and C++
@sp 3
@center Version: 1.40
@center @today{}
@sp 1
@center This manual describes
@center PowerLoom 3.2 or later.
@sp 3
@center @strong{The PowerLoom development team}
@ifhtml
<br>
<blockquote>
@end ifhtml
@center Hans Chalupsky
@ifhtml
<br>
@end ifhtml
@center Robert M. MacGregor
@ifhtml
<br>
@end ifhtml
@center Thomas Russ
@ifhtml
<br>
@end ifhtml
@center @{hans,tar@}@@isi.edu
@ifhtml
</blockquote>
@end ifhtml
@page

@vskip 0pt plus 1fill
@insertcopying
@end titlepage

@c ===========================================================================

@contents

@c===========================================================================

@ifinfo
@node Top, Introduction, (dir), (dir)
@chapter PowerLoom Manual

This document describes the PowerLoom knowledge representation and
reasoning system.  PowerLoom is the successor to the Loom knowledge
representation system. It provides a language and environment for
constructing intelligent applications.

@end ifinfo

@c ===========================================================================

@menu
* Introduction::                
* Conceptual Framework::        
* Annotated Example::           
* Communicating with PowerLoom::  
* Commands::                    
* PowerLoom API::               
* Built-In Relations::          
* Installation::                
* Miscellaneous::               
* Glossary::                    
* PowerLoom Grammar::           
* Function Index::              
* Variable Index::              
* Concept Index::               
@end menu

@node Introduction, Conceptual Framework, Top, Top
@chapter Introduction

This document describes the PowerLoom knowledge representation and
reasoning system. PowerLoom is the successor to the Loom knowledge
representation system. It provides a language and environment for
constructing intelligent, knowledge-based applications. PowerLoom uses a
fully expressive, logic-based representation language (a variant of
KIF). It uses a natural deduction inference engine that combines forward
and backward chaining to derive what logically follows from the facts
and rules asserted in the knowledge base.  While PowerLoom is not a
description logic, it does have a description classifier which uses
technology derived from the Loom classifier to classify descriptions
expressed in full first order predicate calculus. PowerLoom uses modules
as a structuring device for knowledge bases, and ultra-lightweight
worlds to support hypothetical reasoning.

To implement PowerLoom we developed a new programming language called
STELLA, which is a Strongly Typed, Lisp-like LAnguage that can be
translated into Lisp, Java, and C++. STELLA tries to preserve those
features of Lisp that facilitate symbolic programming and rapid
prototyping, while still allowing translation into readable as well as
efficient Java and C++ code. Because PowerLoom in written STELLA, we are
able to deliver it in all three languages.

@c ---------------------------------------------------------------------------

@menu
* Powerloom Features::          
* Powerloom History::           
* Running PowerLoom::           
@end menu

@node Powerloom Features, Powerloom History, Introduction, Introduction
@section Powerloom Features

PowerLoom is a full-function, logic-based knowledge representation and
reasoning system, that supports all aspects of knowledge-based
applications.  It allows the representation of complex knowledge in a
declarative, logic-based language, supports a variety of reasoning mechanisms
to make implicit knowledge explicit, has a powerful query engine to retrieve
what has been asserted and logically follows from the KB, provides file-based
and RDBMS-based storage of knowledge bases, has a context and module system to
effectively partition and organize large knowledge bases, and has an extensive
API in multiple language to allow easy and effective integration into
knowledge-based applications.

PowerLoom's focus is on expressivity of its representation language while
still providing good scalability to large ontologies and knowledge bases.  In
general, PowerLoom takes a @emph{pragmatic stance} where usability is more
important than theoretical "neatness" and expressivity is more important than
inferential completeness.  From our point of view, there is nothing magical
about logic, it is just another programming language (with difficult to
understand semantics), so it should help you to solve the task at hand as best
as possible and not hinder you by forcing you to work around restrictions of
the logic.  Of course, PowerLoom cannot completely escape the straight-jacket
of logic, but it tries to push the boundaries as much as possible.

@itemize @bullet
@item
@strong{Representation language}: PowerLoom uses the language of
predicate logic to represent knowledge.  The syntax is KIF (the
Knowledge Interchange Format) which is one of the supported syntaxes of
the upcoming Common Logic standard.  PowerLoom adds a variety of
convenient definitional constructs as well as extensions beyond
traditional first-order logic such as type-level predicates, relation
variables in @code{holds} sentences, modal assertions (sentences about
sentences), cross-context assertions via @code{ist} to represent lifting
axioms, defaults (still experimental), and others.  The goal is to
provide a highly expressive representation language, since KR failures
or awkward models are often due to "we could not express X in language
L".  The theoretical undecidability and intractability of such an
expressive language is counteracted by providing limited, "pragmatic"
reasoning services that cover commonly encountered situations.  For
example, reasoning with second-order sentences that quantify over
relations is undecidable and leads to very unfocused search; however,
such sentences are very useful to describe axiom schemata that can be
cheaply run in forward direction to create regular first-order rules (in
a process not unlike macro expansion).

@item
@strong{Reasoning}: The primary reasoning mechanism is logical deduction
which infers statements that logically follow from the asserted
statements and rules.  Such statements can be asked about using
PowerLoom's query commands @code{ask} (for true/false questions) and
@code{retrieve} (for Wh-questions).  PowerLoom uses a natural deduction
system to answer queries but also has a large number of specialized
reasoning procedures to efficiently handle concept and relation
hierarchies, sets, frame predicates, search control, etc.  The
specialist architecture is extensible to allow users to plug-in their
own reasoners or computed predicates.  PowerLoom also supports
hypothetical reasoning, equality reasoning, arithmetic and reasoning
with inequalities.  While @strong{PowerLoom is not a description logic},
it does have a classifier that can classify concept and relation
hierarchies and instances defined using the full expressive power of
first-order logic.  The classifier does not provide any additional
inferences, but allows PowerLoom to eagerly pre-compute and cache
subsumption relationships which can then be utilized over and over
without having to re-derive them.  PowerLoom also provides some
experimental abductive and partial-match reasoning to handle incomplete
knowledge bases.

@item
@strong{Meta-representation and reasoning}: Concepts, relations,
contexts, rules, queries, etc. are all first-class citizens in the
domain of discourse.  Therefore, they can have assertions made about
them as well as reasoned about.  This mechanism is commonly used by the
system itself, e.g., to assert that a relation is single valued or
transitive, that a concept is closed, etc.

@item
@strong{Explanation}: PowerLoom can explain its reasoning by recording
inference trees and then rendering those into human-understandable
explanations.  PowerLoom also has an experimental "WhyNot" facility to
explain inference failures where no successful proof tree was found.

@item
@strong{Contexts and modules}: Contexts and modules provide separate
name and assertion spaces with inheritance which implement a powerful
structuring mechanism for KBs.  Contexts allow encapsulation and
organization of knowledge, efficient inference (by separating irrelevant
knowledge or by separating ontologies and assertion spaces from volatile
inference worlds), truth maintenance (via inference cache contexts),
scenarios and hypothetical reasoning, non-monotonic overrides in
sub-contexts, etc.  PowerLoom's context mechanism is built-in at a very
low level using a very efficient and light-weight implementation for
maximum performance.

@item
@strong{Open and closed-world}: By default, PowerLoom makes an
open-world assumption and returns @code{unknown} if it cannot prove or
disprove a question.  However, concepts and relations can be selectively
marked as closed to support selective closed-world reasoning.  PowerLoom
also has a @code{fail} predicate (in addition to true negation via
@code{not}) to implement closed-world negation-as-failure which can be
useful in certain situations.

@item
@strong{Knowledge base management}: PowerLoom supports incremental
monotonic and non-monotonic updates that extend or non-monotonically
change the assertion base.  In PowerLoom one can effectively interleave
definitions, re-definitions, assertions and retractions with retrieval
and inference without having to reload large knowledge bases from
scratch after every change.  Truth maintenance of cached inference
results that might have been invalidated by updates is done via
inference cache contexts.  After a knowledge base has been loaded and
changed by some updates, the changed state can be saved out to a file or
an (experimental) persistent store built on top of a relational
database.

@item
@strong{Scalability}: Despite its emphasis on expressive representation
which usually has to be paid for with intractable and expensive
reasoning procedures, PowerLoom is very scalable and comes with a
variety of mechanisms to control search and handle large ontologies and
knowledge bases.  For example, PowerLoom's reasoning specialists handle
a wide variety of inferencing very effectively without having to go
through any rule chaining.  Search control annotations can be used to
help the inference engine use rules more effectively.  For example,
depending on fan-out, certain rules are run more effectively forwards
than backwards (or vice versa), and a KB developer can tell the system
when that's the case.  PowerLoom has resource-bounded depth-first or
iterative deepening search which provides an any-time inference scheme
for situations where resources are limited.  A "just-in-time" forward
inference engine elaborates the assertion neighborhood of objects
touched upon by inference.  This allows focused forward inference
relevant to current inference goals, without having to run forward
inference over a potentially very large KB to completion.  PowerLoom has
a static and dynamic query optimizer, that, similar to optimizers used
in database systems, orders conjunctive goals based on relation
extension sizes and rule fan-out to minimize intermediate result sets
and chaining.  The dynamic optimizer does this for each conjunctive
subgoal based on actual bindings.  Given this mechanism it is possible
to run PowerLoom queries that return 100,000's of solutions.  PowerLoom
also has a powerful relational database interface that allows it to
utilize the power of databases for handling large assertion bases (soon
to be released).  One application of this PowerLoom/RDBMS integration is
used with ISI's Omega ontology.  It is also a crucial part of our KOJAK
Link Discovery System.

@item
@strong{Tools and APIs}: PowerLoom has a host of associated tools and
APIs (not all of which have been released yet).  It comes with an
interactive command-line interface which is useful for developing
ontologies and knowledge bases, an extensive programmatic interface
called PLI with Lisp, C++ and Java bindings, and a Lisp-based Loom API
to load legacy Loom KBs.  Ontosaurus is a Web-based KB browser that
dynamically generates HTML pages viewable in a standard Web browser.
Ontosaurus has been released in an experimental pre-release.  A
soon-to-be-released Prot&eacute;g&eacute; plug-in allows export of
Prot&eacute;g&eacute; ontologies into PowerLoom format.  A not yet
released Java-based GUI provides a browse/edit/query environment for
developing KBs.  The GUI uses a client/server architecture and is
deployable via Java WebStart in standard browser. OntoMorph is a
translation system that supports writing of KB translators and
importers, e.g., to import ontologies written in other languages (for
example, Flogic).

@item
@strong{Initial Semantic Web support}: Given PowerLoom's emphasis on
expressive representation, we have not yet focused much on Semantic Web
languages such as OWL, which restricts expressivity to gain
decidability.  OWL also has other limitations such as restriction to
binary relations and lack of support for arithmetic and inequalities
which limits its usefulness for practical applications.  Nevertheless,
given that people are starting to use these languages more and more,
we've developed some initial import translators for RDF/RDFS and OWL
which once they mature we will release as part of PowerLoom.

@item
@strong{Portability and integration}: Since PowerLoom is implemented in
STELLA, it is available in Lisp, C++ and Java implementations and highly
portable.  PowerLoom can be run in each of these languages under Unix
(such as Linux, SunOS or MacOS X) as well as Windows 2000 and XP.  Due
to the availability in three main-stream languages, it can easily be
integrated programmatically with most application software without
having to use some complex integration framework.  The C++ and Java
libraries for PowerLoom are also quite small and light-weight, for
example, the necessary STELLA and PowerLoom jar files of the Java
implementation are less than 2.5 Meg in size.
@end itemize

@c ---------------------------------------------------------------------------

@node Powerloom History, Running PowerLoom, Powerloom Features, Introduction
@section Powerloom History

<to be written>

@c ---------------------------------------------------------------------------

@node Running PowerLoom,  , Powerloom History, Introduction
@section Running PowerLoom

The easiest way to run PowerLoom on a variety of platforms is to use the
@file{powerloom} or @file{powerloom.bat} scripts in the top-level
PowerLoom directory.  If you have Java installed on your system, these
scripts should run out of the box without any further installation
requirements.  If you want to use the Lisp version of PowerLoom, simply
load the file @code{load-powerloom.lisp} into your Common Lisp.  If you
want to use the C++ version, you have to compile it first.  See the
Installation section in this manual for more details on how to install
the Lisp, C++ or Java version of PowerLoom @xref{Installation}.

Under Unix or MacOS X, open a shell window somewhere to run PowerLoom.
For example,

@example
% powerloom
Running Java version of PowerLoom...
Initializing STELLA...
Initializing PowerLoom...

    Welcome to PowerLoom 3.2.0

Copyright (C) USC Information Sciences Institute, 1997-2006.
PowerLoom comes with ABSOLUTELY NO WARRANTY!
Type `(copyright)' for detailed copyright information.
Type `(help)' for a list of available commands.
Type `(demo)' for a list of example applications.
Type `bye', `exit', `halt', `quit', or `stop', to exit.

PL-USER |= 
@end example

Under Windows, you can do something similar by running a Command Prompt
window and executing the @file{powerloom.bat} script.  You can also
simply double click on the script which will run PowerLoom and bring up
a Command Prompt window for you.

Once the @code{|=} prompt has come up you can type in PowerLoom commands
and see their results.  The string preceding the prompt indicates the
"current module" relative to which commands are interpreted.  For
example, type the @code{demo} command to see a menu of available demos.
Step through one or more of them to get familiar with PowerLoom.

PowerLoom is a reasoning engine that is intended to be integrated into
some host application software somewhat similar to a database system.
This is the main reason why it currently only ships with a command-line
interface; however, we do have an experimental PowerLoom GUI which might
also be released at some point.

@c ---------------------------------------------------------------------------

@menu
* Command-Line Options::        
@end menu

@node Command-Line Options,  , Running PowerLoom, Running PowerLoom
@subsection Command-Line Options

There are a few command-line options that can be supplied to the
@file{powerloom} script.

@example
powerloom [c++|java]
          [@{-e|--eval@} STELLA-EXPRESSION]
          [--batch]
@end example

The first optional argument determines what version to run if both C++
and Java versions are installed.  If no specific version is specified,
the C++ version will be run if it is installed, otherwise, the Java
version will be run.

@table @samp
@item --eval @var{STELLA-EXPRESSION}
@itemx -e @var{STELLA-EXPRESSION}
Specifies a STELLA expression that should be run just before the
PowerLoom command loop gets initialized.  This expression has to be a
known command (such as the various PowerLoom commands), since the STELLA
evaluator cannot (yet) evaluate arbitrary STELLA code.  For example,
@code{powerloom -e '(demo "equations" FALSE)'} will run a particular
demo before anything else.  You will need to appropriately quote
special characters interpreted by the shell or the Command Prompt window.

@item --batch
Runs PowerLoom in batch mode without running an interactive command
loop.  This can be useful in conjunction with the @code{--eval} option
to execute a single command or load a PowerLoom script via the
@code{load} command.
@end table

@c ===========================================================================

@node Conceptual Framework, Annotated Example, Introduction, Top
@chapter Conceptual Framework

This chapter presents the fundamental conceptual building blocks that are used
to construct PowerLoom knowledge bases. The PowerLoom language is based on KIF,
which provides a syntax and a declarative semantics for first-order predicate
calculus expressions. KIF is a proposed ANSII standard language used by a
variety of knowledge representation systems. Practical knowledge representation
systems necessarily add a procedural semantics that defines the interpretation
of knowledge structures when definitions and facts are retracted or modified.
This chapter assumes that the reader has some familiarity with the semantics of
the predicate calculus, and instead focuses on aspects of the semantics that go
beyond the traditional (KIF) semantics.

A PowerLoom knowledge base is constructed by first defining the
terminology (concepts and relations) for a domain, and then asserting
additional rules and facts about that domain. Facts can be asserted and
later retracted, so the answers returned by queries may change over
time. The knowledge structures are organized into logical containers
called ``modules''. The division into modules means that in general,
facts are not asserted globally, but instead hold only within a specific
context. For example, a logical proposition may evaluate as true within
one module, and evaluate as false within a different one.

The discussion below uses some examples of actual PowerLoom syntax
to illustrate certain points.  However, we gloss over the fine
points of syntax, and instead focus on semantic issues.  The next
chapter reverses that emphasis, and presents a series of examples
that illustrate the breadth of syntactic constructs implemented for
the PowerLoom language.

@c ---------------------------------------------------------------------------

@menu
* Terms and Propositions::      
* Relation Definitions::        
* Truth Values::                
* Modules::                     
@end menu

@node Terms and Propositions, Relation Definitions, Conceptual Framework, Conceptual Framework
@section Terms and Propositions

A knowledge base attempts to capture in abstract (machine interpretable)
form a useful representation of a physical or virtual world. The entities
in that world are modeled in the knowledge base by objects we call @emph{
terms}. Examples of terms are ``Georgia'' (denoting the U.S., state),
``BenjaminFranklin'' (denoting the historical person by that name), the
number three, the string "abc", and the concept ``Person''. Unlike
objects in an object-oriented programming language, the terms in a
PowerLoom knowledge base usually have distinct names (unless there are
sufficiently many that naming them all becomes impractical).

Terms are categorized or related to one another by objects called
@emph{relations}.  Examples of relations are ``has age'', ``greater than'',
``is married to'', ``plus''.  Concepts such as ``Person'', ``State'',
``Company'', and ``Number'' are considered a subcategory of relations.

A @emph{proposition} is a logical sentence that has an associated truth
value. Examples are ``Ben Franklin is a person'', ``Bill is married to
Hillary'', ``Two plus three equals six'' (which is false). PowerLoom
follows KIF in adopting a prefix notation for the predicate calculus to
represent propositions. Possible representations of the three
propositions just mentioned are @code{(person ben-franklin)},
@code{(married-to Bill Hillary)}, and @code{(= (+ 2 3) 6)}. These three
propositions make reference to relations named @code{person},
@code{married-to}, @code{ plus}, and @code{=}.

The predicate calculus constructs complex sentences out of simpler ones
using the logical connectives @code{and}, @code{or}, @code{not}, @code{<=},
@code{=>}, and @code{<=>}, and the
quantifiers @code{exists} and @code{forall}. Some examples are @code{(not
(crook richard))} ``Richard is not a crook'', and @code{(forall ?p
(=> (person ?p) (exists ?m (has-mother ?p ?m))))} ``every person has a
mother''.

@c ---------------------------------------------------------------------------

@node Relation Definitions, Truth Values, Terms and Propositions, Conceptual Framework
@section Definitions

PowerLoom requires that relations are defined before they are
used within assertions and queries.  The commands @code{defconcept},
@code{defrelation}, and @code{deffunction} are used to define
concepts, relations, and functions, respectively.  The definitions

@example
(defconcept person)
(defrelation married-to ((?p1 person) (?p2 person))
(deffunction + ((?n1 number) (?n2 number)) :-> (?sum number))
@end example

declare that @code{person} is a concept, that @code{married-to}
is a binary relation that takes arguments of type @code{person},
and that @code{+} is a function that takes arguments of type
@code{number}@footnote{The function @code{+} and the concept 
@code{number} are predefined in PowerLoom.}.  The requirement
that relations be defined before they are referenced can be
inconvenient at times.  For example, suppose we wish to define
@code{parent} as ``a person who is the parent of another person''
and we also wish to state that the first argument to the 
@code{parent-of} relation has type @code{parent}:

@example
(defconcept parent (?p)
  :<=> (and (person ?p) (exists ?c (parent-of ?p ?c))))
(defrelation parent-of ((?p parent) (?c person)))
@end example

In this example, the first reference to @code{parent-of} occurs before it
is defined. PowerLoom permits circular references such as these as long
as they occur within definitions. It does so by deferring evaluation of
rules that occur within definitions. Here is a specification that is
logically equivalent, but is not legal because the @code{parent-of}
relation appears in an assertion before it is defined:

@example
(defconcept parent (?p))
(assert (forall (?p) (<=> (parent ?p) 
                          (and (person ?p) (exists ?c (parent-of ?p ?c))))))
(defrelation parent-of ((?p parent) (?c person)))
@end example

So when does the rule inside of the first @code{parent} definition get
defined?  All axioms (facts and rules) that appear within the boundaries
of a definition are evaluated just prior to the next occurrence of
a PowerLoom query.  Hence, in the example above where the rule occurred
@emph{within} the definition, there was no error because evaluation of
that rule occured sometime after the second definition (which defines
the otherwise problematic reference to @code{parent-of}).

One will sometimes see the command @code{(process-definitions)} appearing at
intervals within a file containing PowerLoom commands. Each such
appearance forces the definitions that preceed it to be fully-evaluated.
This is done so that the interval between a definition and its evaluation
not be too great; it can get confusing if PowerLoom reports a semantic
violation long after the origin of the conflict.

PowerLoom definitions commands (those prefixed by ``def'') have one other
semantic property that distinguishes them from ordinary assertions. Any
axioms that appear within a definition are tied to that definition.
If a definition is modified and then reevaluated, axioms that don't
survive the modification are retracted.  For example, suppose we
evaluate the following two commands.

@example
(defrelation parent-of ((?p1 person) (?p2 person))
  :=> (relative-of ?p1 ?p2))
(defrelation parent-of ((?p1 person) (?p2 person)))
@end example

The first definition defines @code{person} as a binary relation,
and also states a rule that ``@code{parent-of} implies @code{relative-of}''.
The second definitions erases that rule, i.e., the cumulative
effect is as if the first definition did not appear.  In contrast,
consider the following commands:

@example
(defrelation parent-of ((?p1 person) (?p2 person)))
(assert (=> (parent-of ?p1 ?p2) (relative-of ?p1 ?p2)))
(defrelation parent-of ((?p1 person) (?p2 person)))
@end example

The assertion in this latter sequence is logically equivalent to the
axiom introduced by the @code{:=>} keyword in the former sequence.
However, at the end of this sequence, the ``@code{parent-of} implies
@code{relative-of}'' rule is still in effect, since it appeared on its
own, outside of a definition.

@c ---------------------------------------------------------------------------

@node Truth Values, Modules, Relation Definitions, Conceptual Framework
@section Truth Values

A PowerLoom proposition is tagged with a truth value that has one of
five different settings---@code{true}, @code{false},
@code{default-true}, @code{default-false}, or @code{unknown}. The most
common setting is @code{true}; when we make an assertion as in
@code{(assert (Person Bill))}, the proposition @code{(Person Bill)} is
assigned the truth value @code{true}. To assign the value @code{false}
to a proposition, one asserts that it is not true, e.g., @code{(assert
(not (crook Richard)))}. The command @code{presume} is used to assign a
proposition the value @code{default-true}, as in @code{(presume
(weather-in Los-Angeles Sunny))}. Presuming a negated proposition
assigns it the value @code{default-false}.

The assignment of a truth value to a proposition via @code{assert} or
@code{presume} can upgrade the ``strength'' of a proposition, but it
cannot downgrade it. Hence, if a proposition currently has the value
@code{unknown}, then it may be assigned any of the other four values. If
the value is @code{default-true} or @code{default-false}, an assertion
that assigns the value @code{true} or @code{false} will overwrite the
existing value. However, if the truth value of a proposition is either
@code{true} or @code{false}, assigning it the value @code{default-true}
or @code{default-false} will have no effect.

If a proposition is asserted to be @code{true} and subsequently is
asserted to be @code{false} (or vice-versa), a @emph{clash} (or
contradiction) results. When a clash is detected by PowerLoom, a
@code{clash-exception} is thrown. The system's default behavior is for
the exception to be caught and ignored, with the result that an
assertion that would otherwise cause a clash never takes
effect. Applications that execute commands slightly below the top-level
(i.e., below the clash exception catcher) can catch the exception
themselves and perform a specialized response. PowerLoom's
proof-by-contradiction specialist catches clashes to determine that a
contradiction has occurred.

If a user or application wants to assign a proposition a truth value
that isn't stronger than the current value, it must first @code{retract}
the current value.  The PowerLoom @code{retract} operator has the effect
of undoing a prior assertion.  For example, if we assert that Mary is a
parent of Fred, and then retract that assertion, the value of the
proposition @code{(parent-of Mary Fred)} becomes @code{unknown}.  The
proposition can then be assigned any other truth value.

We should note that executing a retraction does not necessarily cause a
proposition to cease being true.  Consider the following sequence:

@example
(defconcept Person)
(defconcept Employee (?e)
  :=> (Person ?e))
(assert (Person Mary))
(assert (Employee Mary))
(retract (Person Mary))
@end example

If we now ask PowerLoom whether or not Mary is a person, the answer
will be yes (TRUE) because Mary is asserted to be an employee, and
membership in @code{employee} implies membership in @code{person}.
In other words, although the direct assertion that Mary is a person
is not present in the knowledge base, a logical proof exists that
the proposition ``Mary is a person'' is true.

@ignore
Possible additional topics:

QUANTIFIERS

RULES

INFERENCE
@end ignore

@c ---------------------------------------------------------------------------

@node Modules,  , Truth Values, Conceptual Framework
@section Modules

The knowledge loaded into an executing PowerLoom system is
divided into logical partitions called ``modules''.  The modules
are arranged into a hierarchy; knowledge inherits down the
hierarchy from parents to children.  A convenient way to organize
knowledge is to put definitional knowledge higher up in the
module hierarchy, and factual knowledge lower down.  For example,
suppose we want to build a knowledge base that defines a business
domain, and include a substantial number of facts about individual
companies. We might use one or a few modules to define terminology that
relates to the business domain, and then places the set of facts
about each company in its own module.  If we were querying the
knowledge base about one or a few companies, it would not be
necessary to load the modules for the remaining companies into the
system.

Facts asserted within a module are not visible in sibling modules, or in
ancestor modules. Thus, if we enter into PowerLoom an assertion
that``Georgia is a state'', we are not asserting that Georgia is a state
in all possible worlds, but that, from the vantage point of the current
module and those modules below, it is the case that Georgia is a state. If
we want the fact that Georgia is a state to be recognized as true in
many or most other modules, then we should make our assertion in a module
that is relatively high up in the hierarchy, so that is visible to
(inherited by) the other modules.

The inheritance of facts is @emph{not monotonic}---a child module can
retract or override facts inherited from its ancestors. For example,
suppose we have two modules, called @code{above} and @code{below} such
that the @code{below} module is below (inherits from) the @code{above}
module. Next, suppose we make an assertion within the @code{above}
module that ``Joel is a duck'', and then we shift to the @code{below}
module and retract the proposition that ``Joel is a duck''. From the
vantage point of the @code{below} module, if we now ask if Joel is a
duck, we will get back the value @code{unknown}.  However, if we switch
to the @code{above} module and ask the same question, we get back the
answer @code{true} This occurs because the effect of the retraction
operation that was applied to the @code{below} module is not ``visible''
to modules above it (or to any sibling modules). Hence, when module
hierarchies are involved, it is oversimplifying to state that a
retraction has the effect of erasing a prior assertion.

The PowerLoom execution process maintains a pointer to the current module, and
all asserions, queries, etc. are made relative to that module.  Hence, when we
talk about ``switching'' from one module to another, we are speaking
literally---a @code{change-module} command (or one of its equivalents) is
invoked to switch from one module to another.   @footnote{Many of
the Powerloom API procedures take a module argument that causes a temporary
switch to a different module within the scope of that procedure.} 

PowerLoom comes with some modules already built-in. The module named
@code{PL-KERNEL} contains a set of general-purpose concept and relation
definitions that collectively form the foundation for constructing
application-specific knowledge bases. PowerLoom attaches specialized
reasoners to many of the relations in @code{PL-KERNEL}. The command
interpreter starts up in a module named @code{PL-USER}. That module is
initially empty, and is intended as a convenient place to experiment with
PowerLoom.

@c ===========================================================================

@node Annotated Example, Communicating with PowerLoom, Conceptual Framework, Top
@chapter Annotated Example

The section presents a small example of a PowerLoom knowledge
base.  It introduces the fundamental PowerLoom modelling
concepts and illustrates the syntax of basic PowerLoom
declarations, assertions, and commands.  This section can be 
read stand-alone, but readers who intend to use PowerLoom to
create their own models are encouraged to load the demo file
@strong{???}, and run the examples ``live''.

The conceptual terms introduced in this section include modules,
concepts, relations, functions, instances, propositions, assertions, 
queries, retraction, positive and negative facts, clipping, rules,
and contexts.

@c ---------------------------------------------------------------------------

@menu
* Using Modules::               
* Concepts::                    
* Relations::                   
* Relation Hierarchies::        
* Functions::                   
* Defined Concepts::            
* Negation and Open and Closed World Semantics::  
* Retraction::                  
* Clipping of Values::          
* Rule-based Inference::        
* Explanation::                 
* Contexts and Modules::        
* Equality Reasoning::          
* Classification::              
* Truth Maintenance::           
* Inference Control::           
* Keyword Axioms::              
* Cardinality/Type Reasoning with Frame Predicates::  
* Loom-to-PowerLoom::           
* Deviations from KIF::         
* Differences from Loom::       
* Defaults::                    
* Sets::                        
@end menu

@node Using Modules, Concepts, Annotated Example, Annotated Example
@section Using Modules

We begin by creating a PowerLoom ``module'', which is a logical
container that holds the term definitions, rules, facts, etc.
that make up all or a portion of a domain model.  We will call
our module @code{business}.  The @code{defmodule} command defines a new
module.  The @code{:includes} option within the @code{defmodule} tells
PowerLoom that the @code{business} module inherits all definitions
and assertions present in the @code{PL-USER} module, or in ancestor
modules inherited by the @code{PL-USER} module.  In particular, by
inheriting @code{PL-USER}, we indirectly inherit the @code{PL-KERNEL}
module that contains all of the built-in concepts and relations.
The @code{in-module} command tells the PowerLoom system
to make @code{BUSINESS} the current module.  Until the current module
is changed again, all new introductions of terms and facts will
be placed in the @code{business} module.

@example
(defmodule "BUSINESS"
  :includes ("PL-USER"))
(in-module "BUSINESS")
@end example

The basic building blocks of a model are its concepts, relations, and
instances.@footnote{ PowerLoom modules are case-insensitive by default.
This means, for example, that a logical constant named "Foo" may be
referenced by any of the symbols 'FOO', 'foo', 'foO' etc.} A concept
defines classes/categories of entities that populate the domain model. A
relation defines attributes and relationships that allow the declaration of
facts about an entity. Instances are members of concepts. They appear as
arguments to propositional assertions.

@c ---------------------------------------------------------------------------

@node Concepts, Relations, Using Modules, Annotated Example
@section Concepts

Concepts are defined using the @code{defconcept} command.  Here
we define the concepts @code{company} and @code{corporation}:

@example
(defconcept company)
(defconcept corporation (?c company))
@end example

The first definition tells the system that @code{company} is a concept
(in the @code{business} module).  The second definition defines a
concept @code{corporation}.  The type declaration @code{(?c company)}
indicates that @code{corporation} is a subconcept of @code{company}, i.e.,
all instances of @code{corporation} are also instances of @code{company}.
Let us now create a couple of companies:

@example
(assert (company ACME-cleaners))
(assert (corporation megasoft))
@end example

These two assertions create two new entities denoted by the
terms @code{ACME-cleaners} and @code{megasoft}.  Both of these entities
are members of the concept @code{company}.  @code{megasoft} is also a member
of the concept @code{corporation}.  We can test this by executing some
PowerLoom queries:

@example
(retrieve all ?x (company ?x))
@result{}
There are 2 solutions:
  #1: ?X=ACME-CLEANERS
  #2: ?X=MEGASOFT

(retrieve all ?x (corporation ?x))
@result{}
There is 1 solution:
  #1: ?X=MEGASOFT
@end example

@c ---------------------------------------------------------------------------

@node Relations, Relation Hierarchies, Concepts, Annotated Example
@section Relations

So far, our two companies aren't very interesting. In order to say more
about them, we can define some relations and functions using the
declarations @code{defrelation} and @code{deffunction}:

@example
(defrelation company-name ((?c company) (?name STRING)))
@end example

This declaration defines a binary relation @code{company-name}.
The first value in a @code{company-name} tuple must be an instance
of type @code{company}, while the second value must be a string.
We can now give our companies names, using the command @code{assert}:

@example
(assert (company-name ACME-cleaners "ACME Cleaners, LTD"))
(assert (company-name megasoft "MegaSoft, Inc."))
@end example

We can retrieve pairs of companies and their names with the following
query (note that we omitted the optional retrieval variables in which
case they are determined by collecting the free variables in the query
expression): 

@example
(retrieve all (company-name ?x ?y))
@result{}
There are 2 solutions:
  #1: ?X=MEGASOFT, ?Y="MegaSoft, Inc."
  #2: ?X=ACME-CLEANERS, ?Y="ACME Cleaners, LTD"
@end example

Using retrieval variables is useful if we want to order the result
columns in a certain way, for example:

@example
(retrieve all (?y ?x) (company-name ?x ?y))
@result{}
There are 2 solutions:
  #1: ?Y="MegaSoft, Inc.", ?X=MEGASOFT
  #2: ?Y="ACME Cleaners, LTD", ?X=ACME-CLEANERS
@end example

@c ---------------------------------------------------------------------------

@node Relation Hierarchies, Functions, Relations, Annotated Example
@section Relation Hierarchies

PowerLoom permits the specification of hierarchies both for concepts and
relations.  Previously , we defined a small concept hierarchy with
@code{company} on top and @code{corporation} below it.  We now define a
subrelation of the relation @code{company-name} called
@code{fictitious-business-name}:

@example
(defrelation fictitious-business-name ((?c company) (?name STRING))
  :=> (company-name ?c ?name))
@end example

PowerLoom defines a subconcept/subrelation relationship between
a pair of concepts or a pair of relations by asserting an ``implication''
relation between them.
The above implication expands into the assertion
``for all values of ?c and ?name, if the @code{fictitious-business-name}
relation holds for ?c and?name, then the @code{company-name} relation
also holds for ?c and ?name''.  This is equivalent to the assertion

@example
(forall (?c ?name) (=> (fictitious-business-name ?c ?name)
                       (company-name ?c ?name)))
@end example

@noindent Since implication relationships occur very
commonly, PowerLoom provides several syntactic shortcuts for defining
them.  We have seen one such shortcut earlier; our
definition of @code{corporation} included the clause ``@code{(c ?company)}'',
which specified that @code{corporation} is a subconcept of @code{company}.
In our definition of @code{fictitious-business-name}, the keyword 
@code{:=>} introduces a similar shortcut, which tells us that 
@code{fictitious-business-name} is a subrelation of @code{company-name}.
Let us assert a fictious business name for MegaSoft:

@example
(assert (fictitious-business-name megasoft "MegaSoft"))
@end example

If we query for the company names of MegaSoft, we get two names,
one of them asserted directly, and one of them infered by the
subrelation rule:

@example
(retrieve all (company-name megasoft ?x))
@result{}
There are 2 solutions:
  #1: ?X="MegaSoft, Inc."
  #2: ?X="MegaSoft"
@end example

@c ---------------------------------------------------------------------------

@node Functions, Defined Concepts, Relation Hierarchies, Annotated Example
@section Functions

This illustrates another point: A PowerLoom relation is by default
``multi-valued'', which in the case of a binary relation means that a
single first value can be mapped by the relation to more than one second
value. In the present case, our model permits a @code{company} entity to
have more than one @code{company-name}. If a (binary) relation always maps
its first argument to exactly one value (i.e., if it it ``single-valued'')
we can specify it as a @code{function} instead of a @code{relation}.  For
example, we can use a function to indicate the number of employees for a 
company:

@example
(deffunction number-of-employees ((?c company)) :-> (?n INTEGER))
@end example

When defining a function, all arguments but the last appear just as they
do for a relation. The last argument (and its type) appears by itself
following the keyword @code{:->}. Defining a single-valued relation as a
function allows us to refer to it using a functional syntax within a
logical sentence, as in the following:

@example
(assert (= (number-of-employees ACME-cleaners) 8))
(assert (= (number-of-employees megasoft) 10000))
@end example

The functional syntax often results in shorter expressions than
equivalents that use relational syntax.  For example to retrieve all
companies with fewer than 50 employees, we can simply write:

@example
(retrieve all (and (company ?x) (< (number-of-employees ?x) 50)))
@result{}
There is 1 solution:
  #1: ?X=ACME-CLEANERS
@end example

Using the syntax for relations, the same query would require the
introduction of an existential quantifier, as in:

@example
(retrieve all (and (company ?x) 
                   (exists ?n
                     (and (number-of-employees ?x ?n)
                          (< ?n 50)))))
@result{}
There is 1 solution:
  #1: ?X=ACME-CLEANERS
@end example

To repeat ourselves slightly, Powerloom allows users the choice of using
either relational or functional syntax when using a function in predicate
position. For example, if @code{f} is a function, then the expressions
@code{(f ?x ?y)} and @code{(= (f ?x) ?y)}  are equivalent.

@c ---------------------------------------------------------------------------

@node Defined Concepts, Negation and Open and Closed World Semantics, Functions, Annotated Example
@section Defined Concepts

If we find ourselves writing the same query (or subexpression) repeatedly,
we may wish to define a name for the concept embodying that expression.
For example, below we define the term @code{small-company} to represent
the class of all companies with fewer than 50 employees:

@example
(defconcept small-company ((?c company))
  :<=> (and (Company ?c)
            (< (number-of-employees ?c) 50)))
@end example

Notice that we have used a new keyword, @code{:<=>}. This keyword defines a
bidirectional implication called ``if-and-only-if''.  Formally it is
equivalent to the following pair of assertions:

@example
(assert (forall ?c (=> (and (Company ?c)
                            (< (number-of-employees ?c) 50))
                       (small-company ?c))))
(assert (forall ?c (=> (small-company ?c)
                       (and (Company ?c)
                            (< (number-of-employees ?c) 50)))))
@end example

In other words, the @code{:<=>} keyword is a shortcut for an assertion that
uses the @code{<=>} relation, which itself is a shortcut representing the
conjunction of two single arrow implications. For example, @code{(<=> P Q)}
is equivalent to @code{(and (<= P Q) (=> P Q))}, where the @code{<=}
relation is defined to be the inverse of the relation @code{=>}.

Its not necessary that we exactly specify the number of employees in a
company.  Below, all we know about ZZ Productions is that they have
fewer than 20 employees:

@example
(assert (and (company zz-productions)
             (< (number-of-employees zz-productions) 20)))
@end example

@noindent These facts are sufficient to classify ZZ Productions as a small
business:

@example
(retrieve all (small-company ?x))
@result{}
There are 2 solutions:
  #1: ?X=ZZ-PRODUCTIONS
  #2: ?X=ACME-CLEANERS
@end example

@c ---------------------------------------------------------------------------

@node Negation and Open and Closed World Semantics, Retraction, Defined Concepts, Annotated Example
@section Negation and Open and Closed World Semantics

PowerLoom implements a three-valued logic---the truth value of each
proposition entered into a PowerLoom knowledge base is recorded as being
either true, false, or unknown.@footnote{Actually, PowerLoom implements
a @emph{five-valued} logic --- the remaining two values are ``default
true'' and ``default false''. However, the present discussion defers the
subject of default truth values.} Many other systems (e.g., relational
DBMSs) implement a two-valued logic, wherein if a fact is not asserted
to be true, it is assumed to be false.  The PowerLoom command @code{ask}
returns one of three (five) values: @code{true} if it can prove the
truth of a proposition, @code{false} if it can @emph{easily} prove the
falsity of a proposition@footnote{Because proving negations can be very
difficult, PowerLoom will only conduct a very quick and shallow search
for a disproof.  More extensive reasoning is used if a negation is asked
about explicitly, thus it may be the case that PowerLoom will return
@code{unknown} if asked about @code{P}, but true if asked about
@code{(not P)}.} and otherwise it returns @code{unknown}. (The values
@code{default-true} and @code{default-false} are also possible if
defaults are used).

Below, PowerLoom knows nothing about a newly-introduced concept
@code{s-corporation}, so @code{ask} returns @code{unknown} to both a
positive query and its negation:

@example
(defconcept s-corporation (?c corporation))
(ask (s-corporation zz-productions))
@result{}
UNKNOWN
(ask (not (s-corporation zz-productions)))
@result{}
UNKNOWN
@end example

If we assert that ZZ Productions is not an S-corporation, then
PowerLoom knows that the proposition in question is false:

@example
(assert (not (s-corporation zz-productions)))
(ask (s-corporation zz-productions))
@result{}
FALSE
(ask (not (s-corporation zz-productions)))
@result{}
TRUE
@end example


@noindent After asserting that ZZ Productions is not an S-corporation,
a repeat of the query asking if it @emph{is} one will now return @code{false},
because the explicit assertion of the negation allows a quick disproof of
the positive query.

@noindent @strong{Note}: PowerLoom uses all its effort to prove that the
proposition in question is true, and only uses some effort to prove that
it is false.  Therefore, only falsities that are discovered "on the way"
or with shallow inference strategies will be found (which was the case
above).  If you want to check whether a proposition is false with
maximum effort, simply ask the negated proposition by wrapping an
explicit @code{not} arount it.  The reason for this asymmetry is that
checking for truth and falsity really amounts to asking two separate and
possibly expensive queries, and the user or programmer should decide
whether the effort should be expended to ask both queries instead of
just one.

PowerLoom can sometimes infer a negative fact without
the necessity of a direct assertion.  For example:

@example
(ask (= (number-of-employees ACME-cleaners) 8))
@result{}
TRUE
(ask (= (number-of-employees ACME-cleaners) 10))
@result{}
FALSE
(ask (not (= (number-of-employees ACME-cleaners) 10)))
@result{}
TRUE
@end example

PowerLoom can infer the second and third answers because it knows that
the function @code{number-of-employees} can return only one value, and
if that value is the number eight, it cannot also be something else (in
this case, ten).

Many systems, in particular, database systems and Prolog, make the
assumptions that if a proposition cannot be proved true, then it must be
false. This is called the ``closed world assumption''. By default,
PowerLoom makes an open-world assumption, but for specific relations it can
be instructed to assume a closed world if a user wants closed world
semantics. For example, suppose we introduce a relation @code{works-for},
and we assume that all @code{works-for} facts have been entered in our
knowledge base:

@example
(defrelation works-for (?p (?c Company)))
(assert (works-for shirly ACME-cleaners))
(assert (works-for jerome zz-productions))
@end example

If we ask PowerLoom whether Jerome does NOT work for MegaSoft, it will
return @code{unknown}.  But if we assert that the relation
@code{works-for} is @code{closed}, then PowerLoom will assume that
Jerome only works for ZZ Productions:

@example
(ask (not (works-for jerome megasoft)))
@result{}
UNKNOWN

(assert (closed works-for))
(ask (not (works-for jerome megasoft)))
@result{}
TRUE
@end example

The reasoning employed to achieve the above result (that Jerome does not
work for MegaSoft) is called ``negation as failure'', which means that
if a proof of a proposition fails, then one may assume that the
proposition is false. We can achieve a negation-as-failure result a
second way (i.e., other than by using a closed world assumption) by
employing the query operator @code{fail}.  Here we retract the closure
assumption for @code{works-for} and achieve the desired result using
@code{fail}:

@example
(retract (closed works-for))
(ask (not (works-for jerome megasoft)))
@result{}
UNKNOWN

(ask (fail (works-for jerome megasoft)))
@result{}
TRUE
@end example

When you see the operator ``not'' in an SQL query or a Prolog program,
it really stands for ``fail''.

@c ---------------------------------------------------------------------------

@node Retraction, Clipping of Values, Negation and Open and Closed World Semantics, Annotated Example
@section Retraction

Below, we introduce a few new terms for defining geographic information.
We define a relation called @code{contains} to assert that one geographic
location (the second argument to @code{contains}) is located within another:

@example
(defconcept geographic-location)
(defconcept country (?l geographic-location))
(defconcept state (?l geographic-location))
(defconcept city (?l geographic-location))
(defrelation contains ((?l1 geographic-location)
                       (?l2 geographic-location)))
@end example

Now, we can assert some facts about U.S. geography (including one
deliberate mistake):

@example
(assert (and 
         (country united-states)
         (geographic-location eastern-us) 
         (contains united-states eastern-us)
         (state georgia) (contains eastern-us georgia)
         (city atlanta) (contains georgia atlanta)
         (geographic-location southern-us) 
         (contains united-states southern-us)
         (state texas) (contains eastern-us texas)
         (city dallas) (contains texas dallas)
         (city austin) (contains texas austin)))
@end example

We would like to repair the incorrect assertion @code{(contains eastern-us texas)}.
The PowerLoom command @code{retract} allows us to erase assertions that
should not be true:

@example
(ask (contains eastern-us texas))
@result{}
TRUE

(retract (contains eastern-us texas))
(assert (contains southern-us texas))

(ask (contains eastern-us texas))
@result{}
UNKNOWN
@end example

Retraction should not be confused with assertion of negative propositions.
For example, asserting that Texas is not a state would not retract
the assertion that it is (a state).  Instead, an evident logical contradiction
is detected as a ``clash'', and the clashing proposition is disallowed:

@example
(assert (not (state texas)))
@result{}
Derived both TRUE and FALSE for the proposition `|P|(STATE TEXAS)'.
   Clash occurred in module ``|MDL|/PL-KERNEL-KB/business'.

(ask (not (state texas)))
@result{}
UNKNOWN
@end example

@c ---------------------------------------------------------------------------

@node Clipping of Values, Rule-based Inference, Retraction, Annotated Example
@section Clipping of Values

Programmers are accustomed to changing the values of attributes for
program objects just by overwriting previous values.  PowerLoom implements a
similar semantics for the special case of functions and single-valued
relations.  When a second value is asserted for one of these relations
the previous value is automatically retracted.  We call this @emph{clipping}.

To illustrate this behavior for both kinds of relations (a function is
considered a kind of relation), we will define a mapping from a company to
a city that contains its headquarters in two different ways:

@example
(deffunction headquarters ((?c company)) :-> (?city city))
(defrelation headquartered-in ((?c company) (?city city))
  :axioms (single-valued headquartered-in))
@end example

The clause "@code{:axioms (single-valued headquartered-in)}" tells
PowerLoom that the @code{headquartered-in} relation is single-valued,
i.e., that it can map a company to at most one city.  This makes its
behavior similar to that of the function @code{headquarters}.  Here is
an example of clipping for the function @code{headquarters}:

@example
(assert (= (headquarters zz-productions) atlanta))
(retrieve all (= ?x (headquarters zz-productions)))
@result{}
There is 1 solution:
  #1: ?X=ATLANTA

(assert (= (headquarters zz-productions) dallas))
(retrieve all (= ?x (headquarters zz-productions)))
@result{}
There is 1 solution:
  #1: ?X=DALLAS
@end example
 
Here is the same kind of clipping using a single-valued relation:

@example
(assert (headquartered-in megasoft atlanta))
(retrieve all (headquartered-in megasoft ?x))
@result{}
There is 1 solution:
  #1: ?X=ATLANTA

(assert (headquartered-in megasoft dallas))
(retrieve all (headquartered-in megasoft ?x))
@result{}
There is 1 solution:
  #1: ?X=DALLAS
@end example

@c ---------------------------------------------------------------------------

@node Rule-based Inference, Explanation, Clipping of Values, Annotated Example
@section Rule-based Inference

Suppose that we want to retrieve all geographic locations that are
contained in the Southern US, based on the set of assertions about
geography that we entered in earlier. The following query returns only
one of such location:

@example
(retrieve all (contains southern-us ?x))
@result{}
There is 1 solution:
  #1: ?X=TEXAS
@end example

We would like the cities Austin and Dallas to be retrieved as well.
To do this, we can assert a @code{rule} that states that @code{contains}
is a transitive relation:

@example
(defrule transitive-contains
  (=> (and (contains ?l1 ?l2)
           (contains ?l2 ?l3))
      (contains ?l1 ?l3)))
@end example

The @code{defrule} declaration does two things---it asserts a
proposition, and it associates a name with that proposition (in the
above case, the name is @code{transitive-contains}). This name is used by
the system in displaying traces of its inferencing. It also makes
redefinition of the proposition easier. If we wish to retract an unnamed
proposition, it is necessary to explicitly retract that proposition
using a syntax identical to the assertion@footnote{Actually, PowerLoom
isn't quite as strict as just stated--its search for an identical
proposition can accomodate changes in the names of variables.} If on the
other hand, a proposition has a name, then a new @code{defrule}
declaration that uses the same name will automatically retract any
existing proposition having the same name.

Our transitive closure rule failed to include any logical quantifiers
for the variables @code{?l1}, @code{?l2}, and @code{?l3}.  When PowerLoom
parses a top-level proposition, it automatically supplies universal
quantifiers for any unquantified variables.  So, the above rule is
equivalent to the rule:

@example
(defrule transitive-contains
  (forall (?l1 ?l2 ?l3)
    (=> (and (contains ?l1 ?l2)
             (contains ?l2 ?l3))
        (contains ?l1 ?l3))))
@end example

@noindent Note: Instead of defining a @code{transitive-contains} rule,
we could have achieved the same effect by asserting that the @code{contains}
relation is transitive, e.g., by stating @code{(assert (transitive contains))}.

Now that we have told the system that our @code{contains} relation is
transitive, let us rerun our query:

@example
(retrieve all (contains southern-us ?x))
@result{}
There are 3 solutions:
  #1: ?X=TEXAS
  #2: ?X=AUSTIN
  #3: ?X=DALLAS
@end example

@c ---------------------------------------------------------------------------

@node Explanation, Contexts and Modules, Rule-based Inference, Annotated Example
@section Explanation

PowerLoom provides a command called @code{why} that you can use to
get an explanation of the logic behind one of its answers.  The
@code{why} command explains the last query entered into the system,
i.e., it should invoked after one has submitted a @code{retrieve} or
an @code{ask} command.  Before asking a @code{why} command, you must
enable the justifications feature:

@example
(set-feature justifications)
@end example

Queries execute a bit more slowly with jusifications enabled, which is why it is
disabled by default. Having enabled justifications, we must (re)run a query.
Here is how we can ask why Dallas is contained in the Southern US:

@example
(ask (contains southern-us dallas))
@result{}
TRUE
(why)
@result{}
1 (CONTAINS SOUTHERN-US DALLAS)
    follows by Modus Ponens
    and substitution @{?l3/DALLAS, ?l2/TEXAS, ?l1/SOUTHERN-US@}
    since 1.1 ! (forall (?l1 ?l3)
                   (<= (CONTAINS ?l1 ?l3)
                       (exists (?l2)
                          (and (CONTAINS ?l1 ?l2)
                               (CONTAINS ?l2 ?l3)))))
    and   1.2 ! (CONTAINS SOUTHERN-US TEXAS)
    and   1.3 ! (CONTAINS TEXAS DALLAS)
@end example

The above explanation tells us that a rule (our transitivity rule)
was invoked during the proof, and that two ground assertions
@code{(CONTAINS SOUTHERN-US TEXAS)} and @code{(CONTAINS TEXAS DALLAS)} 
were accessed to supply preconditions for the rule.  These combined
assertions lead to the conclusion @code{(CONTAINS SOUTHERN-US DALLAS)}.
Within an explanation, directly asserted propositions are indicated with
the prefix `!'.

We can also ask @code{why} after a @code{retrieve} query. However, if the
query has multiple solutions, each one has a separate explanation. In order
to ask @code{why}, we need to ask for one solution at a time. This can be
done by omitting the word @code{all} from the @code{retrieve} query, and
subsequently calling @code{(retrieve)} to obtain results one-at-a-time.
@footnote {Note: The order of solutions will not necessarily be the same as
shown here.}

@example
(retrieve (contains southern-us ?x))
@result{}
  #1: ?X=DALLAS
(retrieve)
@result{}
There are 2 solutions so far:
  #1: ?X=DALLAS
  #2: ?X=TEXAS
(retrieve)
@result{}
There are 3 solutions so far:
  #1: ?X=DALLAS
  #2: ?X=TEXAS
  #3: ?X=AUSTIN
(why)
@result{}
1 (CONTAINS SOUTHERN-US AUSTIN)
    follows by Modus Ponens
    with substitution @{?l1/SOUTHERN-US, ?l3/AUSTIN, ?l2/TEXAS@}
    since 1.1 ! (FORALL (?l1 ?l3)
                   (<= (CONTAINS ?l1 ?l3)
                       (EXISTS (?l2)
                          (AND (CONTAINS ?l1 ?l2)
                               (CONTAINS ?l2 ?l3)))))
    and   1.2 ! (CONTAINS SOUTHERN-US TEXAS)
    and   1.3 ! (CONTAINS TEXAS AUSTIN)
@end example


@c This illegal query breaks with justifications turned on:
@c (retrieve all ?name (company-name ?company ?name))

The following query combines a variety of relations that have been
entered into the business modules.  It retrieves names of companies
whose headquarters are in the southern US.  Note that query variables
that do not appear in the output (i.e., variables not listed after the
@code{all}

@example
(retrieve ?name (exists (?city ?company)
                  (and (contains southern-us ?city)
                       (headquartered-in ?company ?city)
                       (company-name ?company ?name))))
@result{}
There is 1 solution so far:
  #1: ?NAME="MegaSoft, Inc."

(why)
@result{}
1 (and (COMPANY-NAME MEGASOFT MegaSoft, Inc.)
       (HEADQUARTERED-IN MEGASOFT DALLAS)
       (CONTAINS SOUTHERN-US DALLAS))
    follows by And-Introduction
    since 1.1 ! (COMPANY-NAME MEGASOFT MegaSoft, Inc.)
    and   1.2 ! (HEADQUARTERED-IN MEGASOFT DALLAS)
    and   1.3   (CONTAINS SOUTHERN-US DALLAS)

1.3 (CONTAINS SOUTHERN-US DALLAS)
    follows by Modus Ponens
    and substitution @{?l3/DALLAS, ?l2/TEXAS, ?l1/SOUTHERN-US@}
    since 1.3.1 ! (forall (?l1 ?l3)
                     (<= (CONTAINS ?l1 ?l3)
                         (exists (?l2)
                            (and (CONTAINS ?l1 ?l2)
                                 (CONTAINS ?l2 ?l3)))))
    and   1.3.2 ! (CONTAINS SOUTHERN-US TEXAS)
    and   1.3.3 ! (CONTAINS TEXAS DALLAS)
@end example

@c ---------------------------------------------------------------------------

@node Contexts and Modules, Equality Reasoning, Explanation, Annotated Example
@section Contexts and Modules

The final feature that we will illustrate in this section is the
PowerLoom context mechanism.  PowerLoom organizes its knowledge into a
hierarchy of logical containers called ``contexts''.  A PowerLoom
context is either a ``module'', a somewhat heavyweight object that
includes its own symbol table, or a ``world'', a very lightweight object
designed for fast switching from one world to another.  All contexts
inherit from a single root context.  The most important feature of a
context is that a fact asserted into it is inherited by all contexts
below it.  However, a ``parent'' context is unaware of any knowledge
entered into one of its descendants.

Here we concern ourselves only with modules.  We first define a second
module, called @code{alternate-business}, to be a subcontext of
our @code{business} module, and then we switch into the new module:

@example
(defmodule "ALTERNATE-BUSINESS"
  :includes "BUSINESS")
(in-module "ALTERNATE-BUSINESS")
@end example

Next, within the scope of the @code{alternate-business} module, we will
create a new company.  And just for good measure,
we will change the name of MegaSoft while we are at it:

@example
(assert (and (company web-phantoms)
             (company-name web-phantoms "Web Phantoms, Inc.")))
(retract (company-name megasoft "MegaSoft, Inc."))
(assert (company-name megasoft "MegaZorch, Inc."))
@end example

First, here are pairs of companies and company names from the vantage
point of the @code{Business} module:

@example
(in-module "BUSINESS")
(retrieve all (company-name ?x ?y))
@result{}
There are 3 solutions:
  #1: ?X=ACME-CLEANERS, ?Y="ACME Cleaners, LTD"
  #2: ?X=MEGASOFT, ?Y="MegaSoft, Inc."
  #3: ?X=MEGASOFT, ?Y="MegaSoft"
@end example

Now observe the same query executed from within the alternate @code{Business}
module:

@example
(in-module "ALTERNATE-BUSINESS")
(retrieve all (company-name ?x ?y))
@result{}
There are 4 solutions:
  #1: ?X=ACME-CLEANERS, ?Y="ACME Cleaners, LTD"
  #2: ?X=MEGASOFT, ?Y="MegaZorch, Inc."
  #3: ?X=WEB-PHANTOMS, ?Y="Web Phantoms, Inc."
  #4: ?X=MEGASOFT, ?Y="MegaSoft"
@end example

We see that all facts pertaining to company names have inherited down
from the Business to the Alternate Business module, except for the
name for MegaSoft that we explicitly retracted.  Also, the new
facts asserted within the Alternate Business module appear mixed in
with the inherited facts.

@ignore
<ADD AN ELABORATION OF THE NON-MONOTOMIC MODULE INHERITANCE
EXAMPLE OF SECTION 2.3 HERE>
@end ignore

@c ---------------------------------------------------------------------------

@node Equality Reasoning, Classification, Contexts and Modules, Annotated Example
@section Equality Reasoning

PowerLoom makes the @emph{unique names assumption}, so every two
different named logic constants are assumed to be different.  For
example:

@example
(assert (= Fred Joe))
@result{}
Derived both TRUE and FALSE for the proposition `|P#|FALSE'.
   Clash occurred in module `|MDL|/PL-KERNEL-KB/PL-USER'.

(assert (= Fred Fred))
@result{}
|P|TRUE
@end example

However, one can assert equality between skolems that represent function
terms as well as between a function term skolem and a regular constant.
For example:

@example
(deffunction age (?x ?y))
(assert (= (age Fred) (age Joe)))
(assert (= (age Fred) 10))

(retrieve (age Joe ?x))
@result{}
There is 1 solution so far:
  #1: ?X=10
@end example

So, if one needs to model named individuals where equality might be
asserted (e.g., to model a person with an alias) one has to resort
to using function terms.  For example:

@example
(deffunction individual (?name ?i))
(assert (= (age (individual A)) 12))
(assert (= (individual A) (individual B)))

(retrieve (age (individual B) ?a))
@result{}
There is 1 solution so far:
  #1: ?A=12
@end example

@c ---------------------------------------------------------------------------

@node Classification, Truth Maintenance, Equality Reasoning, Annotated Example
@section Classification, Subsumption

@c ---------------------------------------------------------------------------

@node Truth Maintenance, Inference Control, Classification, Annotated Example
@section Truth Maintenance

@c ---------------------------------------------------------------------------

@node Inference Control, Keyword Axioms, Truth Maintenance, Annotated Example
@section Inference Control

@c ---------------------------------------------------------------------------

@node Keyword Axioms, Cardinality/Type Reasoning with Frame Predicates, Inference Control, Annotated Example
@section Keyword Axioms

@c ---------------------------------------------------------------------------

@node Cardinality/Type Reasoning with Frame Predicates, Loom-to-PowerLoom, Keyword Axioms, Annotated Example
@section Cardinality/Type Reasoning with Frame Predicates

@c ---------------------------------------------------------------------------

@node Loom-to-PowerLoom, Deviations from KIF, Cardinality/Type Reasoning with Frame Predicates, Annotated Example
@section Loom-to-PowerLoom

@c ---------------------------------------------------------------------------

@node Deviations from KIF, Differences from Loom, Loom-to-PowerLoom, Annotated Example
@section Deviations from KIF

@c ---------------------------------------------------------------------------

@node Differences from Loom, Defaults, Deviations from KIF, Annotated Example
@section Differences from Loom

@c ---------------------------------------------------------------------------

@node Defaults, Sets, Differences from Loom, Annotated Example
@section Defaults

@c ---------------------------------------------------------------------------

@node Sets,  , Defaults, Annotated Example
@section Sets, Lists, SETOFALL, KAPPA

@c ===========================================================================

@node Communicating with PowerLoom, Commands, Annotated Example, Top
@chapter Communicating with PowerLoom

There are basically three modes that users can choose from
for interacting with the PowerLoom system.  The simplest is 
to use the PowerLoom command interpreter.  The interpreter
supports a type-in window that allows line-at-a-time entry
of commands.  You can use the interpreter to load files
of PowerLoom declarations, to create and edit knowledge base objects,
to ask queries, and to modify settings in the execution environment.

The second mode of interaction involves writing an application that makes
calls to the PowerLoom API (@pxref{PowerLoom API}). PowerLoom implements an
extensive list of procedures that can be called to control the logic
system. These procedures range from very specific procedures to assert or
query a single fact, to general procedures that interpret arbitrary
queries. The STELLA translator offers users a choice of Common Lisp, Java,
or C++ -based versions of the PowerLoom system; users can choose whichever
is the best match for their language of choice for their applications.

Finally, the Ontosaurus Web Browser offers an ideal way
to view the contents of PowerLoom knowledge bases.  The
Ontosaurus Web server allows one to surf across a knowledge
base, offering several different kinds of views of the
knowledge.

@c ---------------------------------------------------------------------------

@menu
* Command Interpreter ::        
* Persistent Knowledge Bases::  
@end menu

@node Command Interpreter , Persistent Knowledge Bases, Communicating with PowerLoom, Communicating with PowerLoom
@section Command Interpreter 

Currently, the primary means for interacting with PowerLoom is its
command interpreter.  The command interpreter can be used either
interactively, or it can be invoked directly from a program to evaluate
individual commands.  All PowerLoom
commands (@pxref{Commands}) can be evaluated using the command
interpreter.

The interactive command interpreter is invoked by calling the function
@code{powerloom} without any arguments.  In the Java versions of
PowerLoom, the interpreter in called by the @code{main} routine in
the class @code{PowerLoom} within the @code{logic} package.  In the C++
versions of PowerLoom, @code{powerloom} is also called within the
@code{main} routine.  In the Lisp version, @code{(STELLA::powerloom)}
has to be called explicitly.  However, in Lisp it is not really
necessary to use the command interpreter, since all commands can also be
executed directly at the Lisp top level@footnote{If you are executing
within a case sensitive module, then you may see some differences
in behavior between commands evaluated by the command interpreter
and commands invoked from the Lisp Listener.}.

The interactive command interpreter functions as a simple
read/eval/print loop that prompts for input with a @code{|=} prompt,
reads a user command from standard input, evaluates it, and prints the
result to standard output.  To exit the command interpreter, type
@code{quit} or @code{stop}.

To evaluate commands directly from a program, the PowerLoom API provides
the following evaluator functions:

#$(util/texinfo-insert-doc /PLI/EVALUATE)
#$(util/texinfo-insert-doc /PLI/EVALUATE-STRING)

@c ---------------------------------------------------------------------------

@node Persistent Knowledge Bases,  , Command Interpreter , Communicating with PowerLoom
@section Persistent Knowledge Bases

Serious users of PowerLoom will want to construct 
knowledge bases that persist between sessions.
PowerLoom's primary medium of persistence is file-based;
users construct their knowledge bases by entering PowerLoom
statements into ASCII-formatted files, and then using the
@code{load} command to load them into PowerLoom.  There is also
a @code{save-module} command that saves the current assertions
of a module to a file.  Large-scale persistence via a backend 
database is currently under development and will become available
in one of the next releases.

@c ===========================================================================

@node Commands, PowerLoom API, Communicating with PowerLoom, Top
@chapter Commands

This chapter lists all available PowerLoom commands alphabetically.
Each command is documented with its name, a (possibly empty) list of
parameters specified as @code{@w{(<name> <type>)}} pairs, its return
type, and its category (@dfn{Command}).  Almost all of the commands implicitly
quote their arguments, meaning that when calling them, you don't need
to add any quotation yourself.  For example, the command
@code{all-facts-of} is defined as follows:

@quotation
@deffn Command all-facts-of (@w{(instanceRef @sc{name})}) : @sc{(cons of proposition)} 
Return a cons list of all definite (TRUE or FALSE) propositions
that reference the instance @var{instanceRef}.
@end deffn
@end quotation

The @code{all-facts-of} command has one parameter called
@var{instanceRef} of type @emph{@sc{name}}, and returns a STELLA
@emph{@sc{list}} containing zero or more objects of type
@emph{@sc{proposition}} as its result.  The type @sc{name} subsumes the
types @sc{symbol}, @sc{surrogate}, @sc{string}, and @sc{keyword}.
Unless you are in a case-sensitive module, the following four commands
are equivalent:

@example
@ @ @ @ (all-facts-of Merryweather)
@ @ @ @ (all-facts-of :MERRYWEATHER)
@ @ @ @ (all-facts-of "merryweather")
@ @ @ @ (all-facts-of @@MerryWeather)
@end example

Commands can also have @code{&rest} parameters (similar to Lisp
functions).  These are either used to allow a variable number of
arguments, or to handle optional arguments, since STELLA does not
directly support optional arguments.

Here is a list of important parameter types used in the
command specifications below:

@itemize 
@item @emph{@sc{generalized-symbol}}: A generalized symbol is either a plain
symbol (similar to a Lisp symbol) such as @code{Merryweather}, a keyword
(similar to a Lisp keyword) such as @code{:KIF}, or a STELLA surrogate
which is a symbol starting with an at-sign, e.g., @code{@@CONS}.  STELLA
surrogates are used as names for objects of arbitrary types.

@item @emph{@sc{name}}: Names can be either a string, or a
@emph{@sc{generalized-symbol}} (i.e., a symbol, a keyword, or a
surrogate).  If a symbol is supplied, only its symbol-name is used.
Commands that take names as arguments usually coerce whatever argument
is entered into a string, but by allowing a @sc{name} they make it a
little bit more convenient to type a name in an interactive
invocation.@footnote{Lisp programmers are typically spoiled, and find it
inconvenient to wrap double-quotes around their arguments.}
@item @emph{@sc{parse-tree}}: A parse tree is similar to a Lisp s-expression,
i.e., it can either be an atom such as a symbol, number, or a string, or
a list of zero or more parse trees.  For example, the expression
@code{(happy Fred)} is a parse tree, and so are its components
@code{happy} and @code{Fred}.
@end itemize

Here is the list of all available PowerLoom commands:

@ignore
<HANS COMMENT.  POTENTIALLY, THESE SHOULD BE GROUPED FUNCTIONALLY>
@end ignore

#$(util/texinfo-insert-doc /LOGIC/ADD-LOAD-PATH)
@c # $(util/texinfo-insert-doc /LOGIC/ADD-TRACE)
#$(util/texinfo-insert-doc /LOGIC/ALL-FACTS-OF)
@c # $(util/texinfo-insert-doc /LOGIC/ALL-FACTS-OF-OBJECT)
#$(util/texinfo-insert-doc /LOGIC/ASK)
#$(util/texinfo-insert-doc /LOGIC/ASSERT)
#$(util/texinfo-insert-doc /LOGIC/ASSERT-FROM-QUERY)
#$(util/texinfo-insert-doc /LOGIC/ASSERT-RULE)
@c # $(util/texinfo-insert-doc /LOGIC/CALL-ALL-FACTS-OF)
@c # $(util/texinfo-insert-doc /LOGIC/CALL-CLEAR-MODULE)
#$(util/texinfo-insert-doc /LOGIC/CC)
#$(util/texinfo-insert-doc /LOGIC/CLASSIFY-RELATIONS)
#$(util/texinfo-insert-doc /LOGIC/CLASSIFY-INSTANCES)
#$(util/texinfo-insert-doc /LOGIC/CLEAR-CACHES)
#$(util/texinfo-insert-doc /LOGIC/CLEAR-INSTANCES)
#$(util/texinfo-insert-doc /LOGIC/CLEAR-MODULE)
@c # $(util/texinfo-insert-doc /LOGIC/CLEAR-TRACE)
#$(util/texinfo-insert-doc /LOGIC/CONCEIVE)
@c # $(util/texinfo-insert-doc /LOGIC/CONCEIVE-TERM)
#$(util/texinfo-insert-doc /LOGIC/COPYRIGHT)
@c # $(util/texinfo-insert-doc /LOGIC/CREATE)
@c # $(util/texinfo-insert-doc /LOGIC/DEFCLASS)
#$(util/texinfo-insert-doc /LOGIC/DEFCONCEPT)
#$(util/texinfo-insert-doc /LOGIC/DEFFUNCTION)
#$(util/texinfo-insert-doc /LOGIC/DEFINSTANCE)
#$(util/texinfo-insert-doc /LOGIC/DEFMODULE)
#$(util/texinfo-insert-doc /LOGIC/DEFOBJECT)
#$(util/texinfo-insert-doc /LOGIC/DEFPROPOSITION)
#$(util/texinfo-insert-doc /LOGIC/DEFRELATION)
#$(util/texinfo-insert-doc /LOGIC/DEFRULE)
#$(util/texinfo-insert-doc /LOGIC/DELETE-RULES)
#$(util/texinfo-insert-doc /LOGIC/DEMO)
#$(util/texinfo-insert-doc /LOGIC/DENY)
#$(util/texinfo-insert-doc /LOGIC/DESCRIBE)
#$(util/texinfo-insert-doc /LOGIC/DESTROY)
#$(util/texinfo-insert-doc /LOGIC/DROP-LOAD-PATH)
@c # $(util/texinfo-insert-doc /LOGIC/DROP-TRACE)
@c # $(util/texinfo-insert-doc /LOGIC/FIND-INSTANCE)
@c # $(util/texinfo-insert-doc /LOGIC/FIND-RULE)
@c # $(util/texinfo-insert-doc /LOGIC/GET)
@c # $(util/texinfo-insert-doc /LOGIC/GET-INSTANCE)
#$(util/texinfo-insert-doc /LOGIC/GET-LOAD-PATH)
@c # $(util/texinfo-insert-doc /LOGIC/GET-RULE)
#$(util/texinfo-insert-doc /LOGIC/GET-RULES)
#$(util/texinfo-insert-doc /LOGIC/HELP)
@c # $(util/texinfo-insert-doc /LOGIC/IN-DIALECT)
#$(util/texinfo-insert-doc /LOGIC/IN-MODULE)
@c # $(util/texinfo-insert-doc /LOGIC/LIST-FEATURES)
#$(util/texinfo-insert-doc /LOGIC/LIST-MODULES)
#$(util/texinfo-insert-doc /LOGIC/LOAD)
#$(util/texinfo-insert-doc /LOGIC/LOAD-FILE)
#$(util/texinfo-insert-doc /LOGIC/POP-LOAD-PATH)
#$(util/texinfo-insert-doc /LOGIC/PRESUME)
#$(util/texinfo-insert-doc /LOGIC/PRINT-FEATURES)
#$(util/texinfo-insert-doc /LOGIC/PRINT-RULES)
#$(util/texinfo-insert-doc /LOGIC/PROCESS-DEFINITIONS)
#$(util/texinfo-insert-doc /LOGIC/PROPAGATE-CONSTRAINTS)
#$(util/texinfo-insert-doc /LOGIC/PUSH-LOAD-PATH)
#$(util/texinfo-insert-doc /LOGIC/REPROPAGATE-CONSTRAINTS)
#$(util/texinfo-insert-doc /LOGIC/RESET-FEATURES)
#$(util/texinfo-insert-doc /LOGIC/RESET-POWERLOOM)
#$(util/texinfo-insert-doc /LOGIC/RETRACT)
#$(util/texinfo-insert-doc /LOGIC/RETRACT-FACTS-OF)
@c # $(util/texinfo-insert-doc /LOGIC/RETRACT-FACTS-OF-INSTANCE)
#$(util/texinfo-insert-doc /LOGIC/RETRACT-FROM-QUERY)
#$(util/texinfo-insert-doc /LOGIC/RETRACT-RULE)
#$(util/texinfo-insert-doc /LOGIC/RETRIEVE)
@c # $(util/texinfo-insert-doc /LOGIC/RUN-POWERLOOM-TESTS)
@c # $(util/texinfo-insert-doc /LOGIC/SATISFIES?)
#$(util/texinfo-insert-doc /LOGIC/SAVE-MODULE)
#$(util/texinfo-insert-doc /LOGIC/SET-FEATURE)
#$(util/texinfo-insert-doc /LOGIC/SET-LOAD-PATH)
@c # $(util/texinfo-insert-doc /LOGIC/SPECIALIZES?)
#$(util/texinfo-insert-doc /LOGIC/TIME-COMMAND)
@c # $(util/texinfo-insert-doc /LOGIC/UNASSERT)
#$(util/texinfo-insert-doc /LOGIC/UNSET-FEATURE)
#$(util/texinfo-insert-doc /LOGIC/WHY)
@c # $(util/texinfo-insert-doc /LOGIC/WHYNOT)

@c ===========================================================================

@node PowerLoom API, Built-In Relations, Commands, Top
@chapter PowerLoom API

This chapter lists functions that collectively define the PowerLoom
API.  The first section describes the API functions themselves.  The
signature is the basic Stella signature.  Information on how to
translate the names of the functions and their arguments into the
programming languages Common Lisp, C++ or Java is given in the Language
Specific Interface section.

@menu
* API Functions::               
* Language Specific Interface::  
@end menu

@node API Functions, Language Specific Interface, PowerLoom API, PowerLoom API
@section API Functions

Many of the functions take a `module' argument that causes the function to be
evaluated in the context of that module. Passing in a NULL value for the module
argument means that evaluation takes place in the current module. The module
argument is frequently followed by an `environment' argument that specifies
which inference environment should be assumed during evaluation. Values for
`environment' are `ASSERTION-ENV', `TAXONOMIC-ENV', and `INFERENCE-ENV'.
`ASSERTION-ENV' specifies that a knowledge base query or lookup should take
into account only explicitly asserted propositions. `TAXONOMIC-ENV' 
specifies that a knowledge base query should take into account
explicitly-asserted propositions plus any rules that specify subsumption
relationships.   `INFERENCE-ENV' specifies that a knowledge base query
should take all relevant propositions into account, including those
generated during forward inferencing.  A NULL value for the `environment'
argument defaults to `TAXONOMIC-ENV'.

Many of the functions that take PowerLoom or Stella objects as inputs
also have an analog version whose name starts with the prefix "s-" that
take strings as inputs.  This is provided as a convenience so that
programmers will not necessarily need to manipulate PowerLoom objects
directly.

@c these are listed alphabetically:
#$(util/texinfo-insert-doc /PLI/ask)
#$(util/texinfo-insert-doc /PLI/assert-binary-proposition)
#$(util/texinfo-insert-doc /PLI/assert-nary-proposition)
#$(util/texinfo-insert-doc /PLI/assert-proposition)
#$(util/texinfo-insert-doc /PLI/assert-unary-proposition)
#$(util/texinfo-insert-doc /PLI/change-module)
#$(util/texinfo-insert-doc /PLI/clear-caches)
#$(util/texinfo-insert-doc /PLI/clear-module)
#$(util/texinfo-insert-doc /PLI/conceive)
#$(util/texinfo-insert-doc /PLI/cons-to-pl-iterator)
#$(util/texinfo-insert-doc /PLI/create-concept)
#$(util/texinfo-insert-doc /PLI/create-enumerated-list)
#$(util/texinfo-insert-doc /PLI/create-enumerated-set)
#$(util/texinfo-insert-doc /PLI/create-function)
#$(util/texinfo-insert-doc /PLI/create-module)
#$(util/texinfo-insert-doc /PLI/create-object)
#$(util/texinfo-insert-doc /PLI/create-relation)
#$(util/texinfo-insert-doc /PLI/destroy-object)
#$(util/texinfo-insert-doc (/PLI/empty? /PLI/pl-iterator))
#$(util/texinfo-insert-doc /PLI/evaluate)
#$(util/texinfo-insert-doc /PLI/generate-unique-name)
#$(util/texinfo-insert-doc /PLI/get-arity)
#$(util/texinfo-insert-doc /PLI/get-binary-proposition)
#$(util/texinfo-insert-doc /PLI/get-binary-propositions)
#$(util/texinfo-insert-doc /PLI/get-child-modules)
#$(util/texinfo-insert-doc /PLI/get-column-count)
#$(util/texinfo-insert-doc /PLI/get-concept)
#$(util/texinfo-insert-doc /PLI/get-concept-instance-matching-value)
#$(util/texinfo-insert-doc /PLI/get-concept-instances)
#$(util/texinfo-insert-doc /PLI/get-concept-instances-matching-value)
#$(util/texinfo-insert-doc /PLI/get-current-module)
#$(util/texinfo-insert-doc /PLI/get-direct-concept-instances)
#$(util/texinfo-insert-doc /PLI/get-direct-subrelations)
#$(util/texinfo-insert-doc /PLI/get-direct-superrelations)
#$(util/texinfo-insert-doc /PLI/get-direct-types)
#$(util/texinfo-insert-doc /PLI/get-domain)
#$(util/texinfo-insert-doc /PLI/get-enumerated-collection-members)
#$(util/texinfo-insert-doc /PLI/get-home-module)
#$(util/texinfo-insert-doc /PLI/get-inferred-binary-proposition-values)
#$(util/texinfo-insert-doc /PLI/get-module)
#$(util/texinfo-insert-doc /PLI/get-modules)
#$(util/texinfo-insert-doc /PLI/get-name)
#$(util/texinfo-insert-doc /PLI/get-nth-domain)
#$(util/texinfo-insert-doc /PLI/get-nth-float)
#$(util/texinfo-insert-doc /PLI/get-nth-integer)
#$(util/texinfo-insert-doc /PLI/get-nth-logic-object)
#$(util/texinfo-insert-doc /PLI/get-nth-string)
#$(util/texinfo-insert-doc /PLI/get-nth-value)
#$(util/texinfo-insert-doc /PLI/get-operator)
#$(util/texinfo-insert-doc /PLI/get-object)
#$(util/texinfo-insert-doc /PLI/get-parent-modules)
#$(util/texinfo-insert-doc /PLI/get-predicate)
#$(util/texinfo-insert-doc /PLI/get-proper-subrelations)
#$(util/texinfo-insert-doc /PLI/get-proper-superrelations)
#$(util/texinfo-insert-doc /PLI/get-proposition)
#$(util/texinfo-insert-doc /PLI/get-propositions)
#$(util/texinfo-insert-doc /PLI/get-propositions-in-module)
#$(util/texinfo-insert-doc /PLI/get-propositions-of)
#$(util/texinfo-insert-doc /PLI/get-range)
#$(util/texinfo-insert-doc /PLI/get-relation)
#$(util/texinfo-insert-doc /PLI/get-relation-extension)
#$(util/texinfo-insert-doc /PLI/get-rules)
#$(util/texinfo-insert-doc /PLI/get-types)
#$(util/texinfo-insert-doc /PLI/initialize)
#$(util/texinfo-insert-doc /PLI/is-a)
#$(util/texinfo-insert-doc /PLI/is-default)
#$(util/texinfo-insert-doc /PLI/is-enumerated-collection)
#$(util/texinfo-insert-doc /PLI/is-enumerated-list)
#$(util/texinfo-insert-doc /PLI/is-enumerated-set)
#$(util/texinfo-insert-doc /PLI/is-false)
#$(util/texinfo-insert-doc /PLI/is-float)
#$(util/texinfo-insert-doc /PLI/is-inconsistent)
#$(util/texinfo-insert-doc /PLI/is-integer)
#$(util/texinfo-insert-doc /PLI/is-logic-object)
#$(util/texinfo-insert-doc /PLI/is-number)
#$(util/texinfo-insert-doc /PLI/is-strict)
#$(util/texinfo-insert-doc /PLI/is-string)
#$(util/texinfo-insert-doc /PLI/is-subrelation)
#$(util/texinfo-insert-doc /PLI/is-true)
#$(util/texinfo-insert-doc /PLI/is-true-binary-proposition)
#$(util/texinfo-insert-doc /PLI/is-true-proposition)
#$(util/texinfo-insert-doc /PLI/is-true-unary-proposition)
#$(util/texinfo-insert-doc /PLI/is-unknown)
#$(util/texinfo-insert-doc /PLI/iterator-to-pl-iterator)
#$(util/texinfo-insert-doc (/PLI/length /PLI/pl-iterator))
#$(util/texinfo-insert-doc /PLI/list-to-pl-iterator)
#$(util/texinfo-insert-doc /PLI/load)
#$(util/texinfo-insert-doc /PLI/load-stream)
#$(util/texinfo-insert-doc /PLI/load-native-stream)
#$(util/texinfo-insert-doc (/PLI/next? /PLI/pl-iterator))
#$(util/texinfo-insert-doc /PLI/object-to-float)
#$(util/texinfo-insert-doc /PLI/object-to-integer)
#$(util/texinfo-insert-doc /PLI/object-to-parsable-string)
#$(util/texinfo-insert-doc /PLI/object-to-string)
#$(util/texinfo-insert-doc /PLI/print-rules)
#$(util/texinfo-insert-doc /PLI/reset-powerloom)
#$(util/texinfo-insert-doc /PLI/retract)
#$(util/texinfo-insert-doc /PLI/retract-binary-proposition)
#$(util/texinfo-insert-doc /PLI/retract-nary-proposition)
#$(util/texinfo-insert-doc /PLI/retract-proposition)
#$(util/texinfo-insert-doc /PLI/retract-unary-proposition)
#$(util/texinfo-insert-doc /PLI/retrieve)
#$(util/texinfo-insert-doc /PLI/run-forward-rules)
#$(util/texinfo-insert-doc /PLI/s-ask)
#$(util/texinfo-insert-doc /PLI/s-assert-proposition)
#$(util/texinfo-insert-doc /PLI/s-change-module)
#$(util/texinfo-insert-doc /PLI/s-clear-module)
#$(util/texinfo-insert-doc /PLI/s-conceive)
#$(util/texinfo-insert-doc /PLI/s-create-concept)
#$(util/texinfo-insert-doc /PLI/s-create-function)
#$(util/texinfo-insert-doc /PLI/s-create-object)
#$(util/texinfo-insert-doc /PLI/s-create-module)
#$(util/texinfo-insert-doc /PLI/s-create-relation)
#$(util/texinfo-insert-doc /PLI/s-destroy-object)
#$(util/texinfo-insert-doc /PLI/s-evaluate)
#$(util/texinfo-insert-doc /PLI/s-get-arity)
#$(util/texinfo-insert-doc /PLI/s-get-child-modules)
#$(util/texinfo-insert-doc /PLI/s-get-concept)
#$(util/texinfo-insert-doc /PLI/s-get-concept-instances)
#$(util/texinfo-insert-doc /PLI/s-get-direct-concept-instances)
#$(util/texinfo-insert-doc /PLI/s-get-domain)
#$(util/texinfo-insert-doc /PLI/s-get-inferred-binary-proposition-values)
#$(util/texinfo-insert-doc /PLI/s-get-nth-domain)
#$(util/texinfo-insert-doc /PLI/s-get-object)
#$(util/texinfo-insert-doc /PLI/s-get-parent-modules)
#$(util/texinfo-insert-doc /PLI/s-get-parent-modules)
#$(util/texinfo-insert-doc /PLI/s-get-proposition)
#$(util/texinfo-insert-doc /PLI/s-get-propositions)
#$(util/texinfo-insert-doc /PLI/s-get-propositions-of)
#$(util/texinfo-insert-doc /PLI/s-get-range)
#$(util/texinfo-insert-doc /PLI/s-get-relation)
#$(util/texinfo-insert-doc /PLI/s-get-relation-extension)
#$(util/texinfo-insert-doc /PLI/s-get-rules)
#$(util/texinfo-insert-doc /PLI/s-is-true-proposition)
#$(util/texinfo-insert-doc /PLI/s-print-rules)
#$(util/texinfo-insert-doc /PLI/s-retract-proposition)
#$(util/texinfo-insert-doc /PLI/s-retrieve)
#$(util/texinfo-insert-doc /PLI/s-save-module)
#$(util/texinfo-insert-doc /PLI/save-module)
#$(util/texinfo-insert-doc /PLI/string-to-object)


@node Language Specific Interface,  , API Functions, PowerLoom API
@section Language Specific Interface

This section contains the description of the programming language
specific aspects of using the PowerLoom API.  Each section describes the 
naming conventions and namespace issues related to calling the API
functions from that programming language.

@menu
* Lisp API::                    
* C++ API::                     
* Java API::                    
@end menu

@node Lisp API, C++ API, Language Specific Interface, Language Specific Interface
@subsection Lisp API

This section tells how to call the API functions in PowerLoom's Common
Lisp implementation from a Lisp program.  The function names are
identical to the Stella names in the PowerLoom API description
@xref{PowerLoom API}.  They are exported from the @code{PLI} package.
Other Stella symbols and names are in the @code{STELLA} package, but
@strong{currently none of the Stella symbols are exported!}.

PowerLoom can be used from Allegro Common Lisp, CMU Common Lisp,
LispWorks Common Lisp and Macintosh Common Lisp.  It may be possible to
use the system from other Common Lisp systems, but they have not been
tested.

@menu
* Initialization::              
* Type Declarations::           
* NULL Values::                 
* Wrapped Literal Values::      
* Special Variables::           
* CLOS Objects versus Structs::  
@end menu

@node Initialization, Type Declarations, Lisp API, Lisp API
@subsubsection Common Lisp Initialization

Loading the Common Lisp version of PowerLoom will normally initialize
the system as part of the loading process.  The Common Lisp version can
be loaded by loading the file @file{load-powerloom.lisp} from the
top-level @file{powerloom} directory.  This will make the system
available for use.

@node Type Declarations, NULL Values, Initialization, Lisp API
@subsubsection Type Declarations

Stella is a typed language, and the Common Lisp translation uses the
type information for Common Lisp type declarations.  That means that
values specified as being of type INTEGER, STRING and FLOAT must have
the correct type.  In particular, integer values will not be coerced to
floating point values by the code.  The following native type
assignments are made:

@example
    Stella      Common Lisp
    =======     ===========
    INTEGER     FIXNUM
    FLOAT       DOUBLE-FLOAT
    STRING      SIMPLE-STRING
@end example

@strong{For convenience, loading PowerLoom will set the default format for
reading floating point numbers in Common Lisp to be @code{double-float}.}

Stella @code{CONS} objects are implmented as native Lisp conses.
Boolean values can take on the values @code{stella::true} or
@code{stella::false}.

@node NULL Values, Wrapped Literal Values, Type Declarations, Lisp API
@subsubsection NULL values

One additional consequence of the strong typing of the language is that
there are specialized @code{NULL} values for numeric and string parameters.

@example
  Stella Type   Null Value
  ===========   ===========
    INTEGER     stella::null-integer
    FLOAT       stella::null-float
    STRING      stella::null-string
@end example

@node Wrapped Literal Values, Special Variables, NULL Values, Lisp API
@subsubsection Wrapped Literal Values

Literal values (integers, floats, strings, etc.) that are used in
PowerLoom appear as wrapped values.  The PowerLoom API functions
@code{object-to-...} can be used to coerce the values into the
appropriate return type.

<to be written:  wrapping values>

@node Special Variables, CLOS Objects versus Structs, Wrapped Literal Values, Lisp API
@subsubsection Special Variables

All Stella special variables are implemented as Common Lisp special
variables.  Binding of the values can be used normally.

@node CLOS Objects versus Structs,  , Special Variables, Lisp API
@subsubsection CLOS Objects versus Structs

PowerLoom can be translated in one of two ways for Common Lisp.  One
method uses CLOS objects as the basis for all Stella and PowerLoom
objects.  For faster execution, it is also possible to use a version in
which Stella and PowerLoom objects are implemented using Common Lisp
structs instead.  This is controlled by the special variable 
@code{cl-user::*load-cl-struct-stella?*}.  If this is set to
@code{cl:t}, then the struct version will be loaded.  This needs to be
set before loading the @file{load-powerloom.lisp} file.

@node C++ API, Java API, Lisp API, Language Specific Interface
@subsection C++ API

<to be written>


@node Java API,  , C++ API, Language Specific Interface
@subsection Java API

This section tells how to call the API functions in PowerLoom's Java
implementation from a Java program.  The Java translation is written for
Java version 1.2.  All of the PowerLoom Interface functions appear as
static methods of the class @code{edu.isi.powerloom.PLI}.

@menu
* Initializing PowerLoom::      
* PowerLoom Java Conventions::  
* Using the PLI Class::         
* Using Stella Objects::        
* PowerLoom and Threads::       
* Setting and Restoring Global Variable Values::  
* Java Character Mapping::      
* Stella Exceptions in Java::   
* Iteration in Java::           
* Utility Classes for Java::    
@end menu

@node Initializing PowerLoom, PowerLoom Java Conventions, Java API, Java API
@subsubsection Initializing PowerLoom

PowerLoom needs to run initialization functions to set up its
environment for proper operation when it starts up.  The simplest method 
for initializing PowerLoom is to use the static method call:

@example
        PLI.initialize()
@end example

This must be called before using any PowerLoom features and before
loading any PowerLoom knowledge bases.  It may be called more than once
without ill effect.

@node PowerLoom Java Conventions, Using the PLI Class, Initializing PowerLoom, Java API
@subsubsection PowerLoom Java Conventions

PowerLoom's Java code is automatically generated by a translator from
underlying Stella code.  The character set for legal Stella names is larger
than the character set for legal Java identifiers, so there is some mapping
involved.

PowerLoom names are words separated by hyphen (-) characters.  For Java,
we have attempted to closely follow the Java conventions:

@itemize
@item
Class names begin with a capital letter and each word is capitalized.
The hyphens from the PowerLoom names are removed.  Example:
@example
        string-wrapper   =>  StringWrapper
@end example
   Exceptions are made for class names that would otherwise conflict with
   normal Java Classes.  In that case, the prefix "Stella_" is added to each
   class name.  At the moment this applies only to the following exceptions:
@example
        object    =>  Stella_Object
        class     =>  Stella_Class
@end example

@item
Method and Function names begin with a lower case letter but each
subsequent word is capitalized.  The hyphens from PowerLoom names are
removed.  Example:
@example
        wrapper-value    =>  wrapperValue
@end example

@item
Storage slots are implemented as Java fields.  The names begin with a
lower case letter but each subsequent word is capitalized.  The hyphens
from PowerLoom names are removed.  Example:
@example
        dynamic-slots    =>  dynamicSlots
@end example

@item
Global and Special variable names are written in all uppercase.  The
hyphens from PowerLoom are replaced by underscore (_) characters.  By
convention, special variables are written in PowerLoom with surrounding
asterisk (*) characters.  The asterisks are replaced by dollar signs ($).
Example:
@example
        *html-quoted-characters*  =>  $HTML_QUOTED_CHARACTERS$
@end example
@end itemize

The most common non-alphanumeric characters are mapped as follows.  A
full set of mappings is in section @ref{Java Character Mapping}.
@example
   ?  =>  P      (for Predicate)
   !  =>  X      (eXclamation)
   $  =>  B      (Buck)
   %  =>  R      (peRcent)
   &  =>  A      (Ampersand)
   *  =>  $      Special variable marker.
@end example

The character mappings use uppercase characters if the basic identifier
uses mixed or lower case.  The mappings use lowercase characters if the
basic identifier uses upper case.

Stella modules are mapped to Java packages.  The basic system
distribution includes the following package hierarchy:

@example
  edu
     isi
        stella
            javalib
        powerloom
            logic
            pl_kernel_kb
                loom_api
@end example

Basic system functionality and data structures such as Cons and List
objects are defined in stella.  PowerLoom's logic (concepts,
relations, rules, etc.) are defined in the logic package.  There is a
set of interface functions in the PLI class in the powerloom package.
They are described in their own section below.

We recommend the following import statements in Java files that use
PowerLoom:
@example
        import edu.isi.stella.*;
        import edu.isi.stella.javalib.*;
        import edu.isi.powerloom.PLI;
        import edu.isi.powerloom.logic.*;
@end example

Functions (in Java terms, static Methods) are translated as static methods
on the class of their first argument (as long as that argument is not a
primitive type and is in the same Stella module).  Functions which take no
arguments, those whose first argument is a primitive type, and those whose
first argument is a class not defined in the same module are all placed
into a class with the same name as the Stella module in which it appers.
It will be in the package corresponding to that Stella module.  Java
constructors should not be called directly.  Instead, there will be a
static method @code{new<ClassName>} (with the class name in mixed case!) that
should be used instead.

Most of the functions of interest will be in the edu.isi.stella.Stella, 
edu.isi.powerloom.PLI or edu.isi.powerloom.logic.Logic classes.

Methods typically refer to their first argument as "self".

Methods which return more than one return value will take a final
argument which is an array of @code{Stella_Object}, which will be used to
return the additional arguments.

Primitive types in Stella have the following mapping in Java:
@example
        Stella          Java
        ======          ====
        INTEGER         int
        FLOAT           double
        NUMBER          double
        CHARACTER       char
        BOOLEAN         boolean
        STRING          String
        MUTABLE-STRING  StringBuffer

  NATIVE-OUTPUT-STREAM  java.io.PrintStream
  NATIVE-INPUT-STREAM   java.io.PushbackInputStream  (May change!!!)
@end example

Inside Stella/PowerLoom objects and collections, primitive types are
wrapped using Stella wrappers instead of Java's primitive classes.  So
integers will be wrapped as edu.isi.stella.IntegerWrapper rather than
java.lang.Integer.  Wrappers have a field called wrapperValue which
accesses the internal value.  Example of use:

@example
    import edu.isi.stella.*;
    import edu.isi.stella.javalib.*;
    ...
    IntegerWrapper iWrap = IntegerWrapper.wrapInteger(42);
    ...
    int answer = iWrap.wrapperValue;
    ...
@end example

@node Using the PLI Class, Using Stella Objects, PowerLoom Java Conventions, Java API
@subsubsection Using the PLI Class

To make interoperability between PowerLoom and Java a little simpler, we
are providing a (PowerLoom Interface class named @code{PLI} which
handles synchronization issues, setting and restoring the reasoning
context, and the a more convenient use of some Java-native objects
rather than Stella objects.  Generally that means that strings are used
for PowerLoom expressions and return values rather than Stella
@code{Cons} objects.

Details about the methods can be found in the section @ref{PowerLoom
API}.  The names of functions in that section will need to be converted
to their Java equivalents using the conventions described in
@ref{PowerLoom Java Conventions}.  We also provide javadoc
documentation for the @code{edu.isi.powerloom.PLI} class.  We recommend
using this method for accessing PowerLoom functionality.  We expect to
expand the range of PowerLoom interface functions that have an analog in
the @code{PLI} class over time.

@node Using Stella Objects, PowerLoom and Threads, Using the PLI Class, Java API
@subsubsection Using Stella Objects

Stella objects can also be used directly.  The most common ones used by
PowerLoom users are @code{Module} and @code{LogicObject}.  Other
potentially useful Stella objects are @code{Cons}, @code{Symbol},
@code{Keyword} and @code{List}.  Except for @code{LogicObject}, these are in
the @code{edu.isi.stella} package.  @code{LogicObject} is in the
@code{edu.isi.powerloom.logic} package.

If one wishes to construct @code{Cons} objects (for example to create
objects to pass to interface functions, one would begin by building
items up using @code{Stella_Object.cons} static method, which takes a
stella object and a cons.  The empty cons is kept in the
@code{edu.isi.stella.Stella.NIL} static variable.  Another way to create
stella objects is to use @code{edu.isi.stella.Stella.unstringify} static
method.  This method takes a string representation of a stella object
and returns the object.  If passed a list, an object of type @code{Cons}
will be returned.

As an alternative, one can also convert one and two dimensional arrays
of @code{Stella_Object} into @code{Cons} objects using the overloaded
function @code{edu.isi.stella.javalib.arrayToCons}.  These functions
will return @code{Cons} objects constructed from the input arrays.

Keywords and symbols are objects that are stored in global static
variables.  The variable names are all in upper case and are constructed
by concatenating the tag SYM with the module name and the name of the
symbol or concatenating the tag KWD with the name of the keyword.  For
example, the symbol BACKWARD in the logic module would be stored in

@example
        edu.isi.powerloom.logic.Logic.SYM_LOGIC_BACKWARD
@end example

whereas the keyword :ERROR in the stella module would be in

@example
        edu.isi.stella.Stella.KWD_ERROR
@end example


@node PowerLoom and Threads, Setting and Restoring Global Variable Values, Using Stella Objects, Java API
@subsubsection PowerLoom and Threads

The most important consideration when using PowerLoom in a threaded
environment is that the core of PowerLoom must not execute in
concurrently running threads.  The PLI class takes care of this for
interface functions that run through that class.  Other PowerLoom
functions that are called need to synchronize on a lock object

@example
        edu.isi.powerloom.logic.Logic.$POWERLOOM_LOCK$
@end example

for proper operation.  This is not needed for setting Special Variables,
since they are implemented on a per-thread basis.  The most important
special variable is the reasoning context.  @xref{Setting and
Restoring Global Variable Values}.


@node Setting and Restoring Global Variable Values, Java Character Mapping, PowerLoom and Threads, Java API
@subsubsection Setting and Restoring Global Variable Values

As noted above, special variables in Stella are implemented as static
fields in a catchall class named the same as the Stella module.  It will
be in the java package corresponding to that Stella module.  The values
of Special variables are stored in Java objects of the type
@code{StellaSpecialVariable}, a subclass of Java's @code{InheritableThreadLocal}.  Any
changes made to the values will not affect any other running threads.
This means that the changes don't need to be synchronized.  Note that
global (as opposed to special) variables don't use these objects.

Numbers and boolean values are stored in special variables using the
corresponding Java classes @code{Integer}, @code{Double},
@code{Boolean}, etc.  The naming convention is to have all upper case
letters with a dollar sign ($) at the beginning and end of the name.

To temporarily change the value of one of these variables, users will
need to be responsible for saving and restoring the old values.  Use of
the "@code{try ... finally ...}" construct is very useful for this, since it
guarantees that the restore of values will be done.  An example follows
of how to safely change modules.  Contexts should be changed using the
functions, although other global variables can be changed by using the
set method.  Note that we use variables of type Object to hold the
values, since that avoids the need to cast when extracting the current
value, since the only operation we do with the current value is save it
to restore it later.

@example
   import edu.isi.stella.*;

   // CONTEXT CHANGE.
   Object savedModule = Stella.$MODULE$.get();
   Module newModule
      = Stella.getStellaModule(contextName, true);
   if (newModule == null) @{ // Handle missing module
   @}
   try @{
     Module.changeCurrentModule(newModule)
     // Code that uses the newModule

   @} finally @{
     Module.changeCurrentModule(savedModule);
   @}


   // INTEGER VALUE CHANGE:
   Object savedValue = Stella.$SAFETY$.get();
   try @{
     Stella.$SAFETY$.set(new Integer(3));
     // Code that uses the newModule

   @} finally @{
     Stella.$SAFETY$.set(savedValue);
   @}


   // BOOLEAN VALUE CHANGE:
   Object savedValue = Stella.$PRINTREADABLY$.get();
   try @{
     Stella.$PRINTREADABLY$.set(Boolean.TRUE);
     // Code that uses the newModule

   @} finally @{
     Stella.$PRINTREADABLY$.set(savedValue);
   @}
@end example

The need to change the module using this type of code can be largely
avoided by using the functions in the PLI interface package.  They take
a module argument and can handle the binding and restoration of the
module value themselves.

@node Java Character Mapping, Stella Exceptions in Java, Setting and Restoring Global Variable Values, Java API
@subsubsection Java Character Mapping

The full Stella to Java character mapping is the following. The
character mappings use uppercase characters if the basic identifier uses
mixed or lower case.  The mappings use lowercase characters if the basic
identifier uses upper case.

@example
   Stella  Java     Mnemonic
   ======  ====     ========
     !   =>  X      (eXclamation)
     "   =>  _
     #   =>  H      (Hash)
     $   =>  B      (Buck)
     %   =>  R      (peRcent)
     &   =>  A      (Ampersand)
     '   =>  Q      (Quote)
     (   =>  _
     )   =>  _
     *   =>  $
     +   =>  I      (Increase)
     ,   =>  _
     -   =>  _
     .   =>  D      (Dot)
     /   =>  S      (Slash)
     :   =>  C      (Colon)
     ;   =>  _
     <   =>  L      (Less than)
     =   =>  E      (Equal)
     >   =>  G      (Greater than)
     ?   =>  P      (Predicate)
     @@   =>  M      (Monkey tail)
     [   =>  J      (Arbitrary (array index?))
     \   =>  _
     ]   =>  K      (Arbitrary (array index?)
     ^   =>  U      (Up arrow)
     `   =>  _
     @{   =>  Y      (Arbitrary (adjacent free letter))
     |   =>  V      (Vertical bar)
     @}   =>  Z      (Arbitrary (adjacent free letter))
     ~   =>  T      (Tilde)
<space>  => _
@end example

@node Stella Exceptions in Java, Iteration in Java, Java Character Mapping, Java API
@subsubsection Stella Exceptions in Java 

Stella exceptions are implemented as a subtype of @code{java.lang.Exception}
(actually @code{RunTimeException}) and may be caught normally.  All Stella
Exceptions belong to the @code{edu.isi.stella.StellaException} class or one of
its subclasses.  The more specfic PowerLoom exceptions belong to the
@code{edu.isi.powerloom.logic.LogicException} class or one of its subclasses.

Exceptions thrown during I/O operations will not use the standard Java
exceptions.  Instead, they will descend from
@code{edu.isi.stella.InputOutputException}.  The most useful
descendents are @code{edu.isi.stella.NoSuchFileException} and
@code{edu.isi.stella.EndOfFileException}.

@node Iteration in Java, Utility Classes for Java, Stella Exceptions in Java, Java API
@subsubsection Iteration in Java

Iteration in Stella (and by extension) PowerLoom is organized a little
bit differently than in Java.  You can either use the Stella iterators
directly, or else use one of the wrapper classes described in the
section @ref{Utility Classes for Java}.  It will present a more
familiar Java interface.  Since the iteration models are a bit
different, it would be unwise to mix accesses between the iteration
models.

Stella iterators do not compute any values until the next? method (in
Java: @code{nextP}) is called.  This method will try to compute the next
value of the iterator and it will return a boolean value which is true
if more values are present.  Each time it is called, the iteration
advances.  Values can be read out of the value field of the iterator,
which will have type @code{Stella_Object}.  Some iterators will also
have a key field which can be read.

The way one would normally use a Stella iterator is as follows, with
possible casting of the value field:

@example
    Stella.Iterator iter = ...;

    while (iter.nextP()) @{
        processValue(iter.value);
    @}
@end example

The PLI class also contains a number of functions for simplifying the
interaction with @code{PlIterator} objects that are returned by various
API functions.  These are the @code{getNth...} functions.  They work
on sequences and sequence-like objects such as @code{Proposition} and
and the value slot of @code{PlIterator} objects.  Note that they do
not return sequential elements of the iterator, but rather elements
of the implicit sequence that is the value of iterators that have
more than one return variable.  For convenience, they also work (with
index = 0) on the value of @code{PlIterator} objects that have only a
single return variable.  For example:

@example
    // Get values of (object name age) in the iterator and then
    // print out a message with the name and age (position 1 & 2).
    // This skips the PowerLoom object bound to ?X in position 0.
    PlIterator iter = 
        PLI.sRetrieve("all (and (name ?x ?name) (age ?x ?age))",
                      null,
                      null);

    while (iter.nextP()) @{
        System.out.println(PLI.getNthString(iter, 1, null, null) + " is " +
                           PLI.getNthInteger(iter, 2, null, null ) + " years old.");
    @}
@end example

@node Utility Classes for Java,  , Iteration in Java, Java API
@subsubsection Utility Classes for Java

To make interoperation of Stella and Java easier, there are several
convenience classes for wrapping Stella iterators and having them behave
like Java enumerations or iterators.  These convenience classes are in the
@code{edu.isi.stella.javalib} package:

@example  
  ConsEnumeration.java      Enumeration class for Cons objects
  ConsIterator.java         Iterator class for Cons objects
  StellaEnumeration.java    Enumeration interface to Stella's Iterator
  StellaIterator.java       Iterator interface to Stella's Iterator
@end example

All of the iterators and enumerators return objects that are actually of
type @code{Stella_Object}, but the signature specifies
@code{java.lang.Object} as required for compatibility with the standard
Java signature.  The @code{Cons...} classes take a @code{Cons} in their
constructor.  The @code{Stella...} classes take a
@code{edu.isi.stella.Iterator} object in their constructor.



@c ===========================================================================
 
@node Built-In Relations, Installation, PowerLoom API, Top
@chapter Built-In Relations

This chapter lists all of the relations that come predefined in PowerLoom. They
are defined in the module @code{PL-KERNEL}; users can access them by
including or using the @code{PL-KERNEL} module within the declarations of their
own modules.

#$(util/texinfo-insert-doc /PL-KERNEL/*)
#$(util/texinfo-insert-doc /PL-KERNEL/+)
#$(util/texinfo-insert-doc /PL-KERNEL/-)
#$(util/texinfo-insert-doc /PL-KERNEL//)
#$(util/texinfo-insert-doc /PL-KERNEL/<)
#$(util/texinfo-insert-doc /PL-KERNEL/=<)
#$(util/texinfo-insert-doc /PL-KERNEL/>)
#$(util/texinfo-insert-doc /PL-KERNEL/>=)
#$(util/texinfo-insert-doc /PL-KERNEL/abstract)
#$(util/texinfo-insert-doc /PL-KERNEL/aggregate)
#$(util/texinfo-insert-doc /PL-KERNEL/antisymmetric)
#$(util/texinfo-insert-doc /PL-KERNEL/arity)
#$(util/texinfo-insert-doc /PL-KERNEL/binary-relation)
#$(util/texinfo-insert-doc /PL-KERNEL/bound-variables)
#$(util/texinfo-insert-doc /PL-KERNEL/cardinality)
@c # $(util/texinfo-insert-doc /PL-KERNEL/case-match)
@c # $(util/texinfo-insert-doc /PL-KERNEL/cheap-disjoint)
#$(util/texinfo-insert-doc /PL-KERNEL/closed)
#$(util/texinfo-insert-doc /PL-KERNEL/collect-into-set)
#$(util/texinfo-insert-doc /PL-KERNEL/collection)
#$(util/texinfo-insert-doc /PL-KERNEL/collectionof)
#$(util/texinfo-insert-doc /PL-KERNEL/comment)
#$(util/texinfo-insert-doc /PL-KERNEL/commutative)
@c # $(util/texinfo-insert-doc /PL-KERNEL/computed)
@c # $(util/texinfo-insert-doc /PL-KERNEL/computed-procedure)
#$(util/texinfo-insert-doc /PL-KERNEL/concept)
#$(util/texinfo-insert-doc /PL-KERNEL/concept-prototype)
#$(util/texinfo-insert-doc /PL-KERNEL/context)
@c # $(util/texinfo-insert-doc /PL-KERNEL/context-of)
#$(util/texinfo-insert-doc /PL-KERNEL/covering)
#$(util/texinfo-insert-doc /PL-KERNEL/cut)
#$(util/texinfo-insert-doc /PL-KERNEL/direct-subrelation)
#$(util/texinfo-insert-doc /PL-KERNEL/direct-superrelation)
#$(util/texinfo-insert-doc /PL-KERNEL/disjoint)
#$(util/texinfo-insert-doc /PL-KERNEL/disjoint-covering)
#$(util/texinfo-insert-doc /PL-KERNEL/documentation)
#$(util/texinfo-insert-doc /PL-KERNEL/domain)
#$(util/texinfo-insert-doc /PL-KERNEL/duplicate-free)
#$(util/texinfo-insert-doc /PL-KERNEL/duplicate-free-collection)
#$(util/texinfo-insert-doc /PL-KERNEL/empty)
#$(util/texinfo-insert-doc /PL-KERNEL/equivalent-relation)
#$(util/texinfo-insert-doc /PL-KERNEL/example)
#$(util/texinfo-insert-doc /PL-KERNEL/fillers)
@c # $(util/texinfo-insert-doc /PL-KERNEL/float)
@c # $(util/texinfo-insert-doc /PL-KERNEL/float-interval-cache)
@c # $(util/texinfo-insert-doc /PL-KERNEL/fork)
#$(util/texinfo-insert-doc /PL-KERNEL/frame-predicate)
#$(util/texinfo-insert-doc /PL-KERNEL/function)
#$(util/texinfo-insert-doc /PL-KERNEL/goes-false-demon)
#$(util/texinfo-insert-doc /PL-KERNEL/goes-true-demon)
#$(util/texinfo-insert-doc /PL-KERNEL/goes-unknown-demon)
@c # $(util/texinfo-insert-doc /PL-KERNEL/group)
@c # $(util/texinfo-insert-doc /PL-KERNEL/handles-reverse-polarity)
@c # $(util/texinfo-insert-doc /PL-KERNEL/has-partition-membership)
@c # $(util/texinfo-insert-doc /PL-KERNEL/hidden-relation)
#$(util/texinfo-insert-doc /PL-KERNEL/holds)
#$(util/texinfo-insert-doc /PL-KERNEL/image-url)
#$(util/texinfo-insert-doc /PL-KERNEL/inequality)
#$(util/texinfo-insert-doc /PL-KERNEL/instance-of)
@c # $(util/texinfo-insert-doc /PL-KERNEL/integer)
@c # $(util/texinfo-insert-doc /PL-KERNEL/integer-interval)
@c # $(util/texinfo-insert-doc /PL-KERNEL/integer-interval-cache)
@c # $(util/texinfo-insert-doc /PL-KERNEL/interval-cache)
@c # $(util/texinfo-insert-doc /PL-KERNEL/interval-cache-of)
#$(util/texinfo-insert-doc /PL-KERNEL/inverse)
#$(util/texinfo-insert-doc /PL-KERNEL/irreflexive)
#$(util/texinfo-insert-doc /PL-KERNEL/issue)
#$(util/texinfo-insert-doc /PL-KERNEL/ist)
#$(util/texinfo-insert-doc /PL-KERNEL/length)
#$(util/texinfo-insert-doc /PL-KERNEL/length-of-list)
#$(util/texinfo-insert-doc /PL-KERNEL/lexeme)
#$(util/texinfo-insert-doc /PL-KERNEL/list)
#$(util/texinfo-insert-doc /PL-KERNEL/listof)
@c # $(util/texinfo-insert-doc /PL-KERNEL/literal)
#$(util/texinfo-insert-doc /PL-KERNEL/maximum-value)
#$(util/texinfo-insert-doc /PL-KERNEL/mean-value)
#$(util/texinfo-insert-doc /PL-KERNEL/median-value)
#$(util/texinfo-insert-doc /PL-KERNEL/member-of)
#$(util/texinfo-insert-doc /PL-KERNEL/minimum-value)
@c # $(util/texinfo-insert-doc /PL-KERNEL/module)
#$(util/texinfo-insert-doc /PL-KERNEL/mutually-disjoint-collection)
#$(util/texinfo-insert-doc /PL-KERNEL/nth-domain)
@c # $(util/texinfo-insert-doc /PL-KERNEL/number)
@c # $(util/texinfo-insert-doc /PL-KERNEL/numeric-interval)
#$(util/texinfo-insert-doc /PL-KERNEL/numeric-maximum)
#$(util/texinfo-insert-doc /PL-KERNEL/numeric-minimum)
#$(util/texinfo-insert-doc /PL-KERNEL/numeric-set)
@c # $(util/texinfo-insert-doc /PL-KERNEL/observed-cardinality-of)
#$(util/texinfo-insert-doc /PL-KERNEL/ordered)
@c # $(util/texinfo-insert-doc /PL-KERNEL/partition-membership)
#$(util/texinfo-insert-doc /PL-KERNEL/phrase)
@c # $(util/texinfo-insert-doc /PL-KERNEL/polymorphic)
@c # $(util/texinfo-insert-doc /PL-KERNEL/portion-of)
#$(util/texinfo-insert-doc /PL-KERNEL/project-column)
#$(util/texinfo-insert-doc /PL-KERNEL/proper-subrelation)
#$(util/texinfo-insert-doc /PL-KERNEL/proper-superrelation)
#$(util/texinfo-insert-doc /PL-KERNEL/proposition)
@c # $(util/texinfo-insert-doc /PL-KERNEL/qualified-range-cardinality)
#$(util/texinfo-insert-doc /PL-KERNEL/range)
#$(util/texinfo-insert-doc /PL-KERNEL/range-cardinality)
#$(util/texinfo-insert-doc /PL-KERNEL/range-cardinality-lower-bound)
#$(util/texinfo-insert-doc /PL-KERNEL/range-cardinality-upper-bound)
#$(util/texinfo-insert-doc /PL-KERNEL/range-max-cardinality)
#$(util/texinfo-insert-doc /PL-KERNEL/range-min-cardinality)
#$(util/texinfo-insert-doc /PL-KERNEL/range-type)
#$(util/texinfo-insert-doc /PL-KERNEL/reflexive)
@c # $(util/texinfo-insert-doc /PL-KERNEL/refutation-disjoint)
#$(util/texinfo-insert-doc /PL-KERNEL/relation)
#$(util/texinfo-insert-doc /PL-KERNEL/relation-computation)
#$(util/texinfo-insert-doc /PL-KERNEL/relation-constraint)
#$(util/texinfo-insert-doc /PL-KERNEL/relation-evaluator)
#$(util/texinfo-insert-doc /PL-KERNEL/relation-specialist)
#$(util/texinfo-insert-doc /PL-KERNEL/scalar)
#$(util/texinfo-insert-doc /PL-KERNEL/scalar-interval)
#$(util/texinfo-insert-doc /PL-KERNEL/set)
#$(util/texinfo-insert-doc /PL-KERNEL/setof)
#$(util/texinfo-insert-doc /PL-KERNEL/single-valued)
@c # $(util/texinfo-insert-doc /PL-KERNEL/soft-eq)
#$(util/texinfo-insert-doc /PL-KERNEL/square-root)
#$(util/texinfo-insert-doc /PL-KERNEL/standard-deviation)
@c # $(util/texinfo-insert-doc /PL-KERNEL/string)
#$(util/texinfo-insert-doc /PL-KERNEL/string-concatenate)
@c # $(util/texinfo-insert-doc /PL-KERNEL/stuff)
#$(util/texinfo-insert-doc /PL-KERNEL/subrelation)
#$(util/texinfo-insert-doc /PL-KERNEL/subset-of)
#$(util/texinfo-insert-doc /PL-KERNEL/substring)
#$(util/texinfo-insert-doc /PL-KERNEL/sum)
#$(util/texinfo-insert-doc /PL-KERNEL/superrelation)
#$(util/texinfo-insert-doc /PL-KERNEL/symmetric)
#$(util/texinfo-insert-doc /PL-KERNEL/synonym)
@c # $(util/texinfo-insert-doc /PL-KERNEL/the-roleset)
#$(util/texinfo-insert-doc /PL-KERNEL/thing)
#$(util/texinfo-insert-doc /PL-KERNEL/total)
#$(util/texinfo-insert-doc /PL-KERNEL/transitive)
#$(util/texinfo-insert-doc /PL-KERNEL/type-of)
@c # $(util/texinfo-insert-doc /PL-KERNEL/union-of)
@c # $(util/texinfo-insert-doc /PL-KERNEL/user-thing)
#$(util/texinfo-insert-doc /PL-KERNEL/value)
#$(util/texinfo-insert-doc /PL-KERNEL/variable-arity)
#$(util/texinfo-insert-doc /PL-KERNEL/variance)

@c ===========================================================================

@node Installation, Miscellaneous, Built-In Relations, Top
@chapter Installation

@c ---------------------------------------------------------------------------

@menu
* System Requirements::         
* Unpacking the Sources::       
* Lisp Installation::           
* C++ Installation::            
* Java Installation::           
* Removing Unneeded Files::     
* Installing PowerLoom Patches::  
@end menu

@node System Requirements, Unpacking the Sources, Installation, Installation
@section System Requirements

To install and use PowerLoom, you'll approximately need the following amounts of
disk space:

@itemize
@item 
16 MB for the tarred or zipped archive file

@item 
70 MB for the untarred sources, tanslations, compiled Java files, and
documentation

@item 
16 MB to compile a Lisp version

@item 
16 MB to compile the C++ version (without -g)

@item 
5 MB to compile the Java version (already included)

@end itemize

This means that you will need approximately 100 MB to work with one Lisp,
one C++ and one Java version of PowerLoom in parallel.  If you also want to
experiment with the Lisp translation variant that uses structures
instead of CLOS instances to implement STELLA objects, then you will
need an extra 16 MB to compile that.

The full PowerLoom development tree is quite large, since for every
STELLA source file there are three to four translated versions and as
many or more compiled versions thereof.  The actual PowerLoom libraries
that you have to ship with an application, however, are quite small.
For example, the Java jar files @file{powerloom.jar} and
@file{stella.jar} are only 2.3 MB total (4 MB including Java sources).
The dynamic C++ libraries @file{libstella.so} and @file{liblogic.so}
compiled on a Linux platform, are about 8 MB total.  Additionally, if you
don't need all the different translations of PowerLoom, you can delete
some of the versions to keep your development tree smaller
@xref{Removing Unneeded Files}.

To run the Lisp version of PowerLoom, you will need an ANSI Common-Lisp
(or at least one that supports CLOS and logical pathnames).  We have
successfully tested PowerLoom with Allegro-CL 4.2, 4.3, 5.0, 6.0 and
7.0, Macintosh MCL 3.0, 4.0 and 5.1, OpenMCL 1.0, SBCL 0.9.4, CMUCL 19c,
LispWorks 4.4.6, CLisp 2.37, Lucid CL 4.1 (plus the necessary ANSI
extensions and Mark Kantrowitz's logical pathnames implementation), and
various others.  Our main development platform is Allegro CL running
under Sun Solaris and Linux.  The closer your environment is to ours,
the higher are the chances that everything will work right out of the
box.  Lisp development under Windows should also be no problem.

To run the C++ version of PowerLoom, you will need a C++ compiler (such
as g++) that supports templates and exception handling.  We have
successfully compiled and run PowerLoom with g++ 3.2 and later under
Linux Redhat 8.0 & 9.0, SunOS and MacOS X, and with CygWin 5.0 and MinGW
5.0 under Windows 2000 and XP.  Both CygWin and MinGW provide a GNU Unix
environment, but MinGW can generate Windows executables that are fully
standalone.  We've also managed to compile PowerLoom under MS Visual
C++, however, we never got the Boehm garbage collector to work.  The GC
claims to be very portable, so this should be solvable for somebody with
good knowledge of MS Visual C++.

For the Java version, you will need Java JDK 1.2 or later. To get
reasonable performance, you should use J2SDK 1.4 or 1.5.  We've run the
Java version of PowerLoom on a variety of platforms without any
problems.

Any one of the Lisp, C++, or Java implementations of PowerLoom can be
used to develop your own PowerLoom-based applications.  Which one you
choose is primarily a matter of your application and programming
environment.  The Lisp and Java versions are comparable in speed, the
C++ version is usually a factor of 2-3 faster than Lisp or Java.

@c ---------------------------------------------------------------------------

@node Unpacking the Sources, Lisp Installation, System Requirements, Installation
@section Unpacking the Sources

Uncompress and untar the file @file{powerloom-X.Y.Z.tar.gz} (or unzip
the file @file{powerloom-X.Y.Z.zip}) in the parent directory of where
you want to install PowerLoom (`X.Y.Z' are place holders for the actual
version numbers).  This will create the PowerLoom tree in the directory
@file{powerloom-X.Y.Z/} (we will use Unix syntax for pathnames).  All
pathnames mentioned below will be relative to that directory which we
will usually refer to as the "PowerLoom directory".

@c ---------------------------------------------------------------------------

@node Lisp Installation, C++ Installation, Unpacking the Sources, Installation
@section Lisp Installation

To install the Lisp version of PowerLoom, startup Lisp and load the file
@file{load-powerloom.lisp} with:

@example
(CL:load "load-powerloom.lisp")
@end example

The first time around, this will compile all Lisp-translated STELLA files
before they are loaded.  During subsequent sessions, the compiled files
will be loaded right away.

By default, PowerLoom now uses the version that uses Lisp structs
instead of CLOS objects to implement STELLA objects.  If you do want to
use the CLOS-based version instead do the following:

@example
(CL:setq cl-user::*load-cl-struct-stella?* CL:nil)
(CL:load "load-powerloom.lisp")
@end example

Alternatively, you can edit the initial value of the variable
@code{*load-cl-struct-stella?*} in the file @file{load-powerloom.lisp}.
Using structs instead of CLOS objects greatly improves slot access
speed, however, it may cause problems with incremental re-definition of
STELLA classes (this is only an issue if you are developing your
application code in the STELLA language.  In that case, it is recommended
to only use the struct option for systems that are in or near the
production stage).

Once all the files are loaded, you should see a message similar to this:

@example
PowerLoom 3.2.0 loaded.
Type `(powerloom)' to get started.
Type `(in-package "STELLA")' to run PowerLoom commands directly
   from the Lisp top level.
USER(2): 
@end example

To reduce startup time, you might want to create a Lisp image that has
all of PowerLoom preloaded.

Now type
@example
(in-package "STELLA")
@end example

to enter the @code{STELLA} Lisp package where all the PowerLoom code
resides.  Alternatively, you can type

@example
(powerloom)
@end example

which will bring up a PowerLoom listener that will allow you to execute
PowerLoom commands.

@strong{IMPORTANT}: All unqualified Lisp symbols in this document are
assumed to be in the @code{STELLA} Lisp package.  Moreover, the
@code{STELLA} package does @strong{NOT} inherit anything from the
@code{COMMON-LISP} package (see the file
@file{sources/stella/cl-lib/cl-setup.lisp} for the few exceptions).
Hence, you have to explicitly qualify every Lisp symbol you want to use
with @code{CL:}.  For example, to get the result of the previous
evaluation, you have to type @code{CL:*} instead of @code{*}.

@c ---------------------------------------------------------------------------

@node C++ Installation, Java Installation, Lisp Installation, Installation
@section C++ Installation

To compile the C++ version of PowerLoom, change to the native C++ directory
of PowerLoom and run @code{make} like this:

@example
% cd native/cpp/powerloom
% make
@end example

This will compile all PowerLoom and STELLA files as well as the C++
garbage collector.  It will then generate static or dynamic
@file{libstella}, @file{liblogic} and other library files in the
directory @file{native/cpp/lib} which can be linked with your own
C++-translated PowerLoom (or other) code.  To test whether the
compilation was successful, you can run PowerLoom from the top-level
PowerLoom directory using the @file{powerloom} script (or
@code{powerloom.bat} under a Windows command prompt):

@example
% powerloom c++
Running C++ version of PowerLoom...
Initializing STELLA...
Initializing PowerLoom...

    Welcome to PowerLoom 3.2.0

Copyright (C) USC Information Sciences Institute, 1997-2006.
PowerLoom comes with ABSOLUTELY NO WARRANTY!
Type `(copyright)' for detailed copyright information.
Type `(help)' for a list of available commands.
Type `(demo)' for a list of example applications.
Type `bye', `exit', `halt', `quit', or `stop', to exit.


PL-USER |= 
@end example

This will run various PowerLoom startup code and then bring up a
PowerLoom command loop where you can execute commands.  The @code{c++}
argument tells the script to run the C++ version of PowerLoom (which is
also run by default as long as the C++ version was compiled).  If the
C++ version was not compiled or the @code{java} argument was given
instead, the Java version of PowerLoom will be run.

Type

@example
(demo)
@end example

to bring up a menu of available demos, type

@example
(run-powerloom-tests)
@end example

to run the PowerLoom test suite, or type

@example
exit
@end example

to exit PowerLoom.

@c ---------------------------------------------------------------------------

@node Java Installation, Removing Unneeded Files, C++ Installation, Installation
@section Java Installation

Nothing needs to be done to install the Java version.  Because Java class
files are platform independent, they are already shipped with the
PowerLoom distribution and can be found in the directory
@file{native/java} and its subdirectories.  Additionally, they have been
collected into the file @file{native/java/lib/powerloom.jar} in the
PowerLoom directory.  To try out the Java version of PowerLoom, you can
run PowerLoom from the top-level PowerLoom directory using the
@file{powerloom} script (or @code{powerloom.bat} under a Windows 
command prompt):

@example
% powerloom java
Running Java version of PowerLoom...
Initializing STELLA...
Initializing PowerLoom...

    Welcome to PowerLoom 3.2.0

Copyright (C) USC Information Sciences Institute, 1997-2006.
PowerLoom comes with ABSOLUTELY NO WARRANTY!
Type `(copyright)' for detailed copyright information.
Type `(help)' for a list of available commands.
Type `(demo)' for a list of example applications.
Type `bye', `exit', `halt', `quit', or `stop', to exit.


PL-USER |= 
@end example

Similar to the C++ executable, this will run various PowerLoom startup
code and then bring up a PowerLoom command loop where you can execute
commands.  Type

@example
(demo)
@end example

to bring up a menu of available demos, type

@example
(run-powerloom-tests)
@end example

to run the PowerLoom test suite, or type

@example
exit
@end example

to exit PowerLoom.

@c ---------------------------------------------------------------------------

@node Removing Unneeded Files, Installing PowerLoom Patches, Java Installation, Installation
@section Removing Unneeded Files

To save disk space, you can remove files that you don't need.  For
example, if you are not interested in the C++ version of PowerLoom, you
can delete the directory @file{native/cpp}.  Similarly, you can remove
@file{native/java} to eliminate all Java-related files.  You could do
the same thing for the Lisp directory @file{native/lisp}, but (in our
opinion) that would make it less convenient for you to develop new
PowerLoom code that is written in STELLA.  Finally, if you don't need
any of the STELLA sources, you can delete the directory
@file{sources/stella}.  If you don't need local copies of the STELLA and
PowerLoom documentation, you can delete parts or all of the
directories @file{sources/stella/doc} and @file{sources/logic/doc}.

@c ---------------------------------------------------------------------------

@node Installing PowerLoom Patches,  , Removing Unneeded Files, Installation
@section Installing PowerLoom Patches

If you already have an older version of PowerLoom installed, you can
upgrade to the latest patch level by downloading incremental sets of
patches instead of downloading the complete release.  Patch files are
usually significantly smaller than the complete release and patching
an existing installation can also preserve local additions, deletions,
or modifications.  PowerLoom patch files are available from the same
location as the full PowerLoom release.

Patches are currently only available in Unix @code{diff} format which
requires the Unix @code{patch} utility to install them (the
@code{patch} program should be readily available on most Unix
systems, otherwise, you can get it for free from the Free Software
Foundation).

Patch files follow the following naming convention: Suppose the current
version of PowerLoom is 3.0.0.  Then the patch file to update to the
next patch level is called @file{powerloom-3.0.0-3.0.1.diff.gz}.

@strong{Important:} Patch files are strictly incremental.  Thus, to
upgrade from version 3.0.0 to 3.0.2, you will need two patch files: one
to go to version 3.0.1 and one to go from that to version 3.0.2; you
will have to apply them in that sequence.

To find out the current version of your PowerLoom installation, look
at the version string displayed when the @code{powerloom} function
is called in Lisp, or when the C++ or Java program starts up.

@strong{Important:} Before you apply any patches, you should always make
a backup copy of your current PowerLoom installation to preserve any
local modifications you made, in case something goes wrong.

To apply patches, copy the appropriate patch file to the top level of
your PowerLoom installation directory.  Suppose the patch file is called
@file{powerloom-3.0.0-3.0.1.diff.gz}.  You can apply the patches using
the following command:

@example
gunzip -qc powerloom-3.0.0-3.0.1.diff.gz | patch -p1
@end example

If you deleted some native PowerLoom files to save space, you can use the
@code{-f} option to force @code{patch} to proceed even if files it needs
to patch do not exist anymore (this is somewhat dangerous in case @code{patch}
encounters some more serious problems).  For example:

@example
gunzip -qc powerloom-3.0.0-3.0.1.diff.gz | patch -p1 -f
@end example

To keep patch files small, PowerLoom patch files do not contain updated
binary files that ship with the full release (such as Java class files,
jar files and PDF documents).  Those have to be regenerated either
manually or with help of available @file{Makefile}s.  The Lisp version
of PowerLoom will automatically recompile the first time the updated
system is loaded.  To recompile the C++ installation follow the
installation instructions given above.  The Java version will need to be
recompiled manually (better patch recompilation support might become
available in the future).

@c ===========================================================================

@node Miscellaneous, Glossary, Installation, Top
@chapter Miscellaneous

This is a catch-all section for documented functions, methods and
relations that haven't been categorized yet into any of the previous
sections.  They are in random order and many of them will never be part
of the official PowerLoom interface.  So beware!

#$(util/texinfo-insert-doc "/LOGIC")
#$(util/texinfo-insert-doc "/PLI")
#$(util/texinfo-insert-doc "/PL-KERNEL-KB")

@c ===========================================================================

@node Glossary, PowerLoom Grammar, Miscellaneous, Top
@chapter Glossary

This glossary contains brief definitions for terms used in the PowerLoom
User's Manual and/or used by the knowledge representation community.  It 
is impractical to give a logically precise definition for many of these
terms, because their interpretation varies quite a bit.
In this case, the glossary attempts to indicate a range of interpretations
consistent with their use in PowerLoom.

@c @display 

@noindent @strong{Assertion:} An assertion states that a particular
proposition is @code{True} or @code{False}.

@noindent @strong{Backward and Forward Inference:} @strong{???}

@noindent @strong{@sc{Backward Rule:}} @strong{???}

@noindent @strong{Binary Relation:} A relation having two arguments
(arity equals two), often as a mapping from one concept domain to
another.  This is by far the most common form of relation.

@noindent @strong{Classifier:} A classifier is a type of an inference
engine that implements efficient strategies for computing subsumption
relations between pairs of concepts, or for computing instance-of
relations between a concept an a set of instances.  PowerLoom implements
a classifier that can be explicitly invoked by an application program.

@noindent @strong{Clipping:} If a function or single-valued binary
relation maps an instance to two or more other instances, a logical
contradiction (a clash) exists.  If clipping is enabled, PowerLoom will
automatically retract all assertions but the last that lead to a clash.
Clipping can be toggled on or off; it is enabled by default.

@noindent @strong{Closed-World Semantics:} Under closed-world semantics
it is assumed that ``if proposition @code{P} cannot be proved
@code{True}, then assume that @code{P} is @code{False}.''  PowerLoom
gives programmers the option to explicitly declare that concept or a
relation operates under the assumption of closed-world semantics (See
also Open-World Semantics).

@noindent @strong{Concept:} A concept defines a category or class of
individuals.  PowerLoom categorizes a concept as a special kind of
relation.  The distinction between a concept and a unary relation is
subtle (some logicians do not believe that there is any
distinction@footnote{but they are mistaken :).}).  In linguistics, the
distinction is that between a noun and an adjective.  In logic, the test
we favor is whether or not the relation has a domain --- a unary
relation has a domain, while a concept does not.  For example, the
relation `married' has domain `person', while the concept
`married-person' does not have a domain (or is its own domain).

@noindent @strong{Constraint:} ``Constraint'' at its most general is a
synonym for ``rule''.  Often a constraint is conceptualized as a rule
that restricts the types of the arguments that can appear within a
tuple.
    
@noindent @strong{Context:} @strong{???}

@noindent @strong{Default Rule:} A default rule expresses an conditional
implication that applies only when its consequent is consistent with
current state of the knowledge base.  In other words, the rule applies
only when it will not lead to a contradition.

@noindent @strong{Definition:} A definition binds a name to a logical
expression.  PowerLoom syntax defines several operators with names of the
form @code{defxxx} (e.g., @code{defconcept} and @code{defrule}) that
declare definitions for various types of entities.

@noindent @strong{Description:} A ``description'' is an expression that
defines a particular logical relation (e.g., the class of all
three-legged black cats).  In PowerLoom, the terms ``concept'' and
``relation'' generally refer to @code{named} relations, while a
description may or may not have a name.  The KIF operators @code{kappa}
and @code{setofall} are used to define unnamed descriptions.

@noindent @strong{Description Logic:} The term ``description logic''
refers to a logic that focuses on descriptions as its principal means
for expressing logical expressions.  A description logic system
emphasises the use of classification and subsumption reasoning as its
primary mode of inference.  Loom and Classic were two early examples of
knowledge representation systems that implement description logics.

@noindent @strong{Domain Model:} A collection of definitions, rules, and
facts that characterizes the possible states of some real or imagined
world.  The domain model specifies a terminology (of concepts and
relations) that is useful for describing objects in that world.  Often
``domain model'' refers to that portion of a world's representation that
does not change over time.

@noindent @strong{Extension:} Given a relation @code{R} with arity
@code{N}, the extension of @code{R} is the set of ground propositions of
the form @code{(R x1 ... xN)} whose truth value is true.  If R is a
concept, then its extension of often considered to be, not a set of
unary tuples, but the set of argument fillers of those tuples, i.e., the
set of instances that belong to the concept.

@noindent @strong{Fact:} A fact is a proposition that has been asserted
to be either @code{True} or @code{False}.  The term ``fact'' usually
refers to a ``ground proposition'', i.e., a proposition that can be
represented as a predicate applied to a sequence of instances or
literals.

@noindent @strong{Filler:} The second argument to a binary tuple is often
refered to as its ``filler''.  When a multiple-valued binary relation
maps an instance to a set of values, these values are also called
``fillers''.

@noindent @strong{Forward Rule:} @strong{???}

@noindent @strong{Function:} Formally, a function is a relation such that the
  value of the last (nth) argument of a relational tuple is a function
of the values of the first n-1 arguments.  This definition coincides
with the notion of a ``single-valued relation''.  PowerLoom (and KIF)
support specialized syntax that allows functions that have been defined
using the operator @code{deffunction} to appear in term expressions
(e.g., @code{(= (f ?x) 42))}).

@noindent @strong{Instance:} An instance denotes an entity within a
domain model, a member of the concept @emph{Thing}.  Depending on ones
interpretation, this could include almost everything.  Often the term
``instance'' is used more narrowly, to exclude literals and other
objects whose properties do not change over time.  PowerLoom assumes
that concepts and relations are instances.

@noindent @strong{KIF:} Short for ``Knowledge Interchange Format'',  KIF
is a language that defines a Lisp-like syntax for the predicate
calculus.  There is an ANSII-standard that defines the KIF syntax and
semantics.  PowerLoom adopts KIF as its representation language, and
adds a few extensions.

@noindent @strong{Knowledge Base:} A knowledge base attempts to capture
in abstract (machine interpretable) form a useful representation of a
physical or virtual world. The entities in that world are modeled in the
knowledge base by objects we call @emph{ terms}. Examples of terms are
``Georgia'' (denoting the U.S., state), ``BenjaminFranklin'' (denoting
the historical person by that name), the number three, the string "abc",
and the concept ``Person''.

@noindent @strong{Literal:} A logically static constant.  Examples are numbers,
strings, quantities, and truth values.

@noindent @strong{Module:} @strong{???}

@noindent @strong{Open-World Semantics:} PowerLoom assumes an open-world
semantics, unless a user explicitly specifies that it use closed-world
semantics.  Under this assumption, if PowerLoom cannot prove or disprove
a proposition, then it assigns that proposition the value @code{Unknown}
(See also Closed-World Semantics).

@noindent @strong{Predicate:}.  The term @emph{predicate} is a syntactic
notion that refers to the zeroth arguments of a proposition.  Predicates
denote relations and properties, i.e., sets.

@noindent @strong{Proposition:}.  A logical sentence whose truth value
can be evaluated with respect to some context.  Each PowerLoom assertion
assigns the value @code{True} or @code{False} to some proposition.

@noindent @strong{Primitive Relation:} @code{P} is a primitive concept
or relation if and only if a proof that @code{(P x1 ... xn)} is true
exists only for the case that there exists an explicit assertion of a
proposition @code{(Q x1 ... xn)} and either @code{Q} equals @code{P} or
@code{Q} is a proper subrelation of @code{P}.  In otherwords, the only
rules that imply membership in @code{P} are those that relate @code{P}
to one of its (proper) subconcepts or subrelations.
  
@noindent @strong{Query:} A query probes the informational state of a
knowledge base.  An @code{ask} query test the truth of its propositional
argument.  A @code{retrieve} asks for sets of constants (bindings) that
make its propositional argument true when the constants are substituted
in place of its variables.  The propositional argument to @code{ask} and
@code{retrieve} arbitrary expression in the first-order predicate
calculus.  Because of constraints imposed either by resource limitations
or inherent undecidability, PowerLoom cannot guarantee the completeness
of its inferences.

@noindent @strong{Relation:} @strong{???}

@noindent @strong{Retraction:} A retraction changes the truth value of a
proposition from either @code{True} or @code{False} to the value
@code{Unknown}.  Retraction is a procedural (non-declarative) operation.

@noindent @strong{Rule:} A ``rule'' is any universally-quantified
proposition, i.e., a proposition of the form @code{(forall (?x1 ... ?xn)
<logical sentence with free variables ?x1 ... ?xn)}.  PowerLoom supports
several different syntactic constructs for defining rules.  (See also
Forward Rule and Backward Rule).

@noindent @strong{Subsumption:} A subsumption relation specifies the
relative generality of two concepts.  A concept @code{A} subsumes a
concept @code{B} if the definitions of @code{A} and @code{B} logically
imply that members of @code{B} must also be members of @code{A}.

@noindent @strong{Truth-Maintenance:} @strong{???}
@c PowerLoom does not currently implement a truth maintenance capability.

@ignore 
<THIS DEFINITION IS WRONG, SINCE A TUPLE IS NOT A PROPOSITION.  RATHER THAN
FIXING IT, WE MAY WISH TO SKIP THE NOTION ENTIRELY?  -RMM
@noindent @strong{Tuple}.  A tuple is a proposition of the form 
@code{(R x_1 ... x_N)} for some relation @code{R}, where the {x_i} are
instances.  The propositions that form the extension of a relation are
often called ``tuples''.  A ground fact.
@end ignore

@noindent @strong{Type:} Often used a synonym for the term
@emph{concept}.  The phrase ``a type of an instance'' generally refers
to (one of) the concepts that the instance belongs to.  The phrase ``nth
domain type'' refers to a concept that contains all instances of the nth
column of a relation.

@noindent @strong{World:}
@strong{???}

@c @end display

@c===========================================================================

@node PowerLoom Grammar, Function Index, Glossary, Top
@chapter PowerLoom Grammar

The syntax of PowerLoom is described below using a modified BNF notation
adapted from the KIF specification.

@c ---------------------------------------------------------------------------

@menu
* Alphabet::                    
* Grammar::                     
@end menu

@node Alphabet, Grammar, PowerLoom Grammar, PowerLoom Grammar
@section Alphabet

We distinguish between terminals, which are part of the language, and
nonterminals. All nonterminals are bracketed as follows
@code{<nonterminal>}. Squared brackets means zero or one instances of
the enclosed expression; @code{<nonterminal>*} means zero or more
occurrences and @code{<nonterminal>+} means one or more occurrences of
@code{<nonterminal>}. The notation @code{<nonterminal1> - <nonterminal2>}
refers to all of the members of @code{<nonterminal1>} except for those
in @code{<nonterminal2>}.

A word is a contiguous sequence of characters, which include all upper
case letters, lower case letters, digits and alpha characters (ASCII
character set from 93 to 128) excluding some special characters like
white spaces, single and double quotes and brackets. 

@code{<word> ::=} @var{a primitive syntactic object}

Special words are those who refer to a variable. All variables are
preceded by a question mark.

@code{<indvar> ::=} @var{a word beginning with the character} @code{?}

A string @code{<string>} is a character sequence including words plus
all special charcters (except double quotes) enclosed in double quotes.
A double quote can be included in a string if it is preceeded by the
escape character '@code{\}'.

@c ---------------------------------------------------------------------------

@node Grammar,  , Alphabet, PowerLoom Grammar
@section Grammar

Legal expressions in PowerLoom are forms, which are either a statement or
a definition, described in more detail below.

@code{<form> ::= <statement> | <definition>}

@c ---------------------------------------------------------------------------

@menu
* Constants and Typed Variables::  
* Terms::                       
* Sentences::                   
* Definitions::                 
@end menu

@node Constants and Typed Variables, Terms, Grammar, Grammar
@subsection Constants and Typed Variables

The language consists of several groups of operators, defined as follows:

@code{<termop> ::= listof | setof | the | setofall | kappa}
@ignore
<HANS ELIMINATED 'lambda' FROM THIS LIST.  WHERE SHOULD IT GO? -rmm>
@end ignore

@code{
<sentop> ::= = | /= | not | and | or | forall | exists @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ | <= | => | <=> |<<= | =>> | <~ | ~> | <<~ | ~>> }

@code{
<defop> ::= defconcept | deffunction | defrelation | defrule | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ :documentation | :-> | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ :<= | :=> | :<<= | :=>> | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ :<=> | :<=>> :<<=> | :<<=>> | := | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ :axioms }

@code{<operator> ::= <termop> | <sentop> | <defop>}

All other words are constants (words which are not operators or variables):

@code{<constant> ::= <word> - <indvar> - <operator>}

Semantically, there are different categories of constants --- @emph{Concept}
constants @code{<conceptconst>}, @emph{Function} constants
@code{<funconst>}, @emph{Relation} constants @code{<relconst>},
@emph{Rule} constants @code{<ruleconst>} and @emph{Logical} constants
@code{<logconst>}. The differences between these categories are entirely
semantic. However, some operators will only accept specific constants.

In contrast to the specification of KIF3.0, PowerLoom supports a typed
syntax. Therefore, variables in quantified terms and sentences can appear
either typed or untyped, as follows:

@code{<vardecl> ::= (<indvar> <constant>) | <indvar>}

@c ---------------------------------------------------------------------------

@node Terms, Sentences, Constants and Typed Variables, Grammar
@subsection Terms

Terms are used to denote objects in the world being described:

@code{
<term> ::= <indvar> | <constant> | <funterm> | <listterm> | <setterm> | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ <quanterm>}

@code{<listterm> ::= (listof <term>*)}

@code{<setterm> ::= (setof <term>*)}

@code{<funterm> ::= (<funconst> <term>+)}

Note: Zero arguments are allowed for @code{<funterm>} in KIF3.0:
@code{<term>*}

@code{
<quanterm> ::= (the <vardecl> <sentence>) | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ (setofall <vardecl> <sentence>) | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ (kappa @{<vardecl> | (<vardecl>+)@} <sentence>) | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ (lambda @{<vardecl> | (<vardecl>+)@} <term>)
}

Note: KIF3.0 allows @code{<term>} instead of @code{<vardecl>} for
@code{setofall}. No @code{<quanterm>} as well as no @code{<setterm>} in
core of KIF as a result of descision 95-3 (March 1995).

@c ---------------------------------------------------------------------------

@node Sentences, Definitions, Terms, Grammar
@subsection Sentences

Sentences are used to express propositions about the world:

@code{
<sentence> ::= <constant> | <equation> | <inequality> | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ <relsent> | <logsent> | <quantsent>
}

@code{<equation> ::= (= <term> <term>)}

@code{<inequality> ::= (/= <term> <term>)}

@code{<relsent> ::= (<constant> <term>+)}

Note: Zero arguments allowed in KIF3.0 for @code{<relsent>}
(@code{<term>*}). @code{<funconst>} is currently not allowed in
PowerLoom (use @code{(= <funterm> <term>)} instead). 

@code{
<logsent> ::= (not <sentence>) | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ (and <sentence>*) | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ (or <sentence>*) | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ (=> <sentence>* <sentence>) | (=>> <sentence>* <sentence>) | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ (<= <sentence> <sentence>*) | (<<= <sentence> <sentence>*) | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ (~> <sentence>* <sentence>) | (~>> <sentence>* <sentence>) | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ (<~ <sentence> <sentence>*) | (<<~ <sentence> <sentence>*)
}

@code{
<quantsent> ::= (forall @{<vardecl> | (<vardecl>+)@} <sentence>) | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ (forall @{<vardecl> | (<vardecl>+)@} <sentence> <sentence>) | @*
@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ (exists @{<vardecl> | (<vardecl>+)@} <sentence>)
}

@c ---------------------------------------------------------------------------

@node Definitions,  , Sentences, Grammar
@subsection Definitions

PowerLoom supports two distinct categories of definitions --- relation
definitions (including concept and function definitions) and rule
definitions.  A relation definition introduces a new logical constant,
and states some facts about that constant (e.g., who its parents are in
a subsumption taxonomy).  A rule definitions binds a new constant to a
proposition (so that the constant @emph{denotes} the proposition) and
asserts the truth of that proposition.  Usually, the proposition
asserted by a @code{defrule} is an implication.  The assertional truth
of a proposition defined by a rule can be altered by asserting or
retracting the constant that denotes the proposition.

@example
<keyword-option> ::= <keyword> <word>
<definition> ::= <reldefinition> | <objdefinition> | <ruledefinition>

<reldefinition> ::= 
 (defconcept <conceptconst> <vardecl>
    [:documentation <string>]
    [:<= <sentence>] | [:=> <sentence>] |
    [:<<= <sentence>] | [:=>> <sentence>] | 
    [:<=> <sentence>] | [:<=>> <sentence>] | [:<<=> <sentence>] |
    [:<<=>> <sentence>] |
    [:axioms @{<sentence> | (<sentence>+)@}] |
    [<keyword-option>*])
 |
 (deffunction <funconst> (<vardecl>+)
    [:documentation <string>]
    [:-> <vardecl>]
    [:<= <sentence>] | [:=> <sentence>] |
    [:<<= <sentence>] | [:=>> <sentence>] | 
    [:<=> <sentence>] | [:<=>> <sentence>] | [:<<=> <sentence>] |
    [:<<=>> <sentence>] |
    [:axioms @{<sentence> | (<sentence>+)@}]
    [<keyword-option>*])
 |
 (defrelation <relconst> (<vardecl>+)
    [:documentation <string>]
    [:<= <sentence>] | [:=> <sentence>] |
    [:<<= <sentence>] | [:=>> <sentence>] | 
    [:<=> <sentence>] | [:<=>> <sentence>] | [:<<=> <sentence>] |
    [:<<=>> <sentence>] |
    [:axioms @{<sentence> | (<sentence>+)@}]
    [<keyword-option>*])

<objdefinition> ::= (defobject <constant>
                       [:documentation <string>]
                       [<keyword-option>*])

<ruledefinition> ::= (defrule <constant> <sentence>
                       [:documentation <string>]
                       [<keyword-option>*])
@end example

@code{<ruledefinition> ::= (defrule <ruleconst> <sentence>)}

@c ===========================================================================

@node Function Index, Variable Index, PowerLoom Grammar, Top
@unnumbered Function Index

@printindex fn

@c ---------------------------------------------------------------------------

@node Variable Index, Concept Index, Function Index, Top
@unnumbered Variable Index

@printindex vr

@c ---------------------------------------------------------------------------

@node Concept Index,  , Variable Index, Top
@unnumbered Concept Index

@printindex cp

@c ===========================================================================

@bye
