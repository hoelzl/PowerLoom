This is manual.info, produced by makeinfo version 4.2 from manual.texi.

   This file documents the knowledge representation and reasoning
system.


File: manual.info,  Node: Using the PLI Class,  Next: Using Stella Objects,  Prev: PowerLoom Java Conventions,  Up: Java API

Using the PLI Class
...................

   To make interoperability between PowerLoom and Java a little
simpler, we are providing a (PowerLoom Interface class named `PLI' which
handles synchronization issues, setting and restoring the reasoning
context, and the a more convenient use of some Java-native objects
rather than Stella objects.  Generally that means that strings are used
for PowerLoom expressions and return values rather than Stella `Cons'
objects.

   Details about the methods can be found in the section *Note
PowerLoom API::.  The names of functions in that section will need to
be converted to their Java equivalents using the conventions described
in *Note PowerLoom Java Conventions::.  We also provide javadoc
documentation for the `edu.isi.powerloom.PLI' class.  We recommend
using this method for accessing PowerLoom functionality.  We expect to
expand the range of PowerLoom interface functions that have an analog in
the `PLI' class over time.


File: manual.info,  Node: Using Stella Objects,  Next: PowerLoom and Threads,  Prev: Using the PLI Class,  Up: Java API

Using Stella Objects
....................

   Stella objects can also be used directly.  The most common ones used
by PowerLoom users are `Module' and `LogicObject'.  Other potentially
useful Stella objects are `Cons', `Symbol', `Keyword' and `List'.
Except for `LogicObject', these are in the `edu.isi.stella package'.
`LogicObject' is in the `edu.isi.powerloom.logic' package.

   If one wishes to construct `Cons' objects (for example to create
objects to pass to interface functions, one would begin by building
items up using `Stella_Object.cons' static method, which takes a stella
object and a cons.  The empty cons is kept in the
`edu.isi.stella.Stella.NIL' static variable.  Another way to create
stella objects is to use `edu.isi.stella.Stella.unstringify' static
method.  This method takes a string representation of a stella object
and returns the object.  If passed a list, an object of type `Cons'
will be returned.

   As an alternative, one can also convert one and two dimensional
arrays of `Stella_Object' into `Cons' objects using the overloaded
function `edu.isi.stella.javalib.arrayToCons'.  These functions will
return `Cons' objects constructed from the input arrays.

   Keywords and symbols are objects that are stored in global static
variables.  The variable names are all in upper case and are constructed
by concatenating the tag SYM with the module name and the name of the
symbol or concatenating the tag KWD with the name of the keyword.  For
example, the symbol BACKWARD in the logic module would be stored in

             edu.isi.powerloom.logic.Logic.SYM_LOGIC_BACKWARD

   whereas the keyword :ERROR in the stella module would be in

             edu.isi.stella.Stella.KWD_ERROR


File: manual.info,  Node: PowerLoom and Threads,  Next: Setting and Restoring Global Variable Values,  Prev: Using Stella Objects,  Up: Java API

PowerLoom and Threads
.....................

   The most important consideration when using PowerLoom in a threaded
environment is that the core of PowerLoom must not execute in
concurrently running threads.  The PLI class takes care of this for
interface functions that run through that class.  Other PowerLoom
functions that are called need to synchronize on a lock object

             edu.isi.powerloom.logic.Logic.$POWERLOOM_LOCK$

   for proper operation.  This is not needed for setting Special
Variables, since they are implemented on a per-thread basis.  The most
important special variable is the reasoning context.  See *Note Setting
and Restoring Global Variable Values::.


File: manual.info,  Node: Setting and Restoring Global Variable Values,  Next: Java Character Mapping,  Prev: PowerLoom and Threads,  Up: Java API

Setting and Restoring Global Variable Values
............................................

   As noted above, special variables in Stella are implemented as static
fields in a catchall class named the same as the Stella module.  It will
be in the java package corresponding to that Stella module.  The values
of Special variables are stored in Java objects of the type
`StellaSpecialVariable', a subclass of Java's `InheritableThreadLocal'.
Any changes made to the values will not affect any other running
threads.  This means that the changes don't need to be synchronized.
Note that global (as opposed to special) variables don't use these
objects.

   Numbers and boolean values are stored in special variables using the
corresponding Java classes `Integer', `Double', `Boolean', etc.  The
naming convention is to have all upper case letters with a dollar sign
($) at the beginning and end of the name.

   To temporarily change the value of one of these variables, users will
need to be responsible for saving and restoring the old values.  Use of
the "`try ... finally ...'" construct is very useful for this, since it
guarantees that the restore of values will be done.  An example follows
of how to safely change modules.  Contexts should be changed using the
functions, although other global variables can be changed by using the
set method.  Note that we use variables of type Object to hold the
values, since that avoids the need to cast when extracting the current
value, since the only operation we do with the current value is save it
to restore it later.

        import edu.isi.stella.*;
     
        // CONTEXT CHANGE.
        Object savedModule = Stella.$MODULE$.get();
        Module newModule
           = Stella.getStellaModule(contextName, true);
        if (newModule == null) { // Handle missing module
        }
        try {
          Module.changeCurrentModule(newModule)
          // Code that uses the newModule
     
        } finally {
          Module.changeCurrentModule(savedModule);
        }
     
     
        // INTEGER VALUE CHANGE:
        Object savedValue = Stella.$SAFETY$.get();
        try {
          Stella.$SAFETY$.set(new Integer(3));
          // Code that uses the newModule
     
        } finally {
          Stella.$SAFETY$.set(savedValue);
        }
     
     
        // BOOLEAN VALUE CHANGE:
        Object savedValue = Stella.$PRINTREADABLY$.get();
        try {
          Stella.$PRINTREADABLY$.set(Boolean.TRUE);
          // Code that uses the newModule
     
        } finally {
          Stella.$PRINTREADABLY$.set(savedValue);
        }

   The need to change the module using this type of code can be largely
avoided by using the functions in the PLI interface package.  They take
a module argument and can handle the binding and restoration of the
module value themselves.


File: manual.info,  Node: Java Character Mapping,  Next: Stella Exceptions in Java,  Prev: Setting and Restoring Global Variable Values,  Up: Java API

Java Character Mapping
......................

   The full Stella to Java character mapping is the following. The
character mappings use uppercase characters if the basic identifier uses
mixed or lower case.  The mappings use lowercase characters if the basic
identifier uses upper case.

        Stella  Java     Mnemonic
        ======  ====     ========
          !   =>  X      (eXclamation)
          "   =>  _
          #   =>  H      (Hash)
          $   =>  B      (Buck)
          %   =>  R      (peRcent)
          &   =>  A      (Ampersand)
          '   =>  Q      (Quote)
          (   =>  _
          )   =>  _
          *   =>  $
          +   =>  I      (Increase)
          ,   =>  _
          -   =>  _
          .   =>  D      (Dot)
          /   =>  S      (Slash)
          :   =>  C      (Colon)
          ;   =>  _
          <   =>  L      (Less than)
          =   =>  E      (Equal)
          >   =>  G      (Greater than)
          ?   =>  P      (Predicate)
          @   =>  M      (Monkey tail)
          [   =>  J      (Arbitrary (array index?))
          \   =>  _
          ]   =>  K      (Arbitrary (array index?)
          ^   =>  U      (Up arrow)
          `   =>  _
          {   =>  Y      (Arbitrary (adjacent free letter))
          |   =>  V      (Vertical bar)
          }   =>  Z      (Arbitrary (adjacent free letter))
          ~   =>  T      (Tilde)
     <space>  => _


File: manual.info,  Node: Stella Exceptions in Java,  Next: Iteration in Java,  Prev: Java Character Mapping,  Up: Java API

Stella Exceptions in Java
.........................

   Stella exceptions are implemented as a subtype of
`java.lang.Exception' (actually `RunTimeException') and may be caught
normally.  All Stella Exceptions belong to the
`edu.isi.stella.StellaException' class or one of its subclasses.  The
more specfic PowerLoom exceptions belong to the
`edu.isi.powerloom.logic.LogicException' class or one of its subclasses.


File: manual.info,  Node: Iteration in Java,  Next: Utility Classes for Java,  Prev: Stella Exceptions in Java,  Up: Java API

Iteration in Java
.................

   Iteration in Stella (and by extension) PowerLoom is organized a
little bit differently than in Java.  You can either use the Stella
iterators directly, or else use one of the wrapper classes described in
the section *Note Utility Classes for Java::.  It will present a more
familiar Java interface.  Since the iteration models are a bit
different, it would be unwise to mix accesses between the iteration
models.

   Stella iterators do not compute any values until the next? method (in
Java: `nextP') is called.  This method will try to compute the next
value of the iterator and it will return a boolean value which is true
if more values are present.  Each time it is called, the iteration
advances.  Values can be read out of the value field of the iterator,
which will have type `Stella_Object'.  Some iterators will also have a
key field which can be read.

   The way one would normally use a Stella iterator is as follows, with
possible casting of the value field:

         Iterator iter = ...;
     
         while (iter.nextP()) {
             processValue(iter.value);
         }


File: manual.info,  Node: Utility Classes for Java,  Prev: Iteration in Java,  Up: Java API

Utility Classes for Java
........................

   To make interoperation of Stella and Java easier, there are several
convenience classes for wrapping Stella iterators and having them behave
like Java enumerations or iterators.  These convenience classes are in
the `edu.isi.stella.javalib' package:

           ConsEnumeration.java      Enumeration class for Cons objects
           ConsIterator.java         Iterator class for Cons objects
           StellaEnumeration.java    Enumeration interface to Stella's Iterator
           StellaIterator.java       Iterator interface to Stella's Iterator

   All of the iterators and enumerators return objects that are
actually of type `Stella_Object', but the signature specifies
`java.lang.Object' as required for compatibility with the standard Java
signature.  The `Cons...' classes take a `Cons' in their constructor.
The `Stella...' classes take a `edu.isi.stella.Iterator' object in
their constructor.


File: manual.info,  Node: Built-In Relations,  Next: Miscellaneous,  Prev: PowerLoom API,  Up: Top

Built-In Relations
******************

   This chapter lists all of the relations that come predefined in
PowerLoom. They are defined in the module `PL-KERNEL'; users can access
them by including or using the `PL-KERNEL' module within the
declarations of their own modules.

 - Function: * ((?x NUMBER) (?y NUMBER)) :-> (?z NUMBER)
     Function that multiplies two numbers.

 - Function: + ((?x NUMBER) (?y NUMBER)) :-> (?z NUMBER)
     Function that adds two numbers.

 - Function: - ((?x NUMBER) (?y NUMBER)) :-> (?z NUMBER)
     Function that subtracts two numbers.

 - Function: / ((?x NUMBER) (?y NUMBER)) :-> (?z NUMBER)
     Function that divides two numbers.

 - Relation: < ((?x NUMBER) (?y NUMBER))
     True if ?x < ?y.

 - Relation: =< ((?x NUMBER) (?y NUMBER))
     True if ?x <= ?y.

 - Relation: > ((?x NUMBER) (?y NUMBER))
     True if ?x > ?y.

 - Relation: >= ((?x NUMBER) (?y NUMBER))
     True if ?x >= ?y.

 - Relation: ABSTRACT ((?r RELATION))
     True if there are no direct assertions made to the relation ?r.

 - Concept: AGGREGATE ((?a AGGREGATE))
     ?a is an aggregate

 - Relation: ANTISYMMETRIC ((?r RELATION))
     A binary relation ?r is antisymmetric if whenever (?r ?x ?y) is
     true (?r ?y ?x) is false unless ?x equals ?y.

 - Function: ARITY ((?r RELATION)) :-> (?arity INTEGER)
     The number of arguments/domains of the relation ?R.

 - Concept: BINARY-RELATION ((?r RELATION))
     The class of binary relations.

 - Relation: BOUND-VARIABLES ((?arguments THING))
     True if all arguments are bound.  The `bound-variables' predicate
     is used as a performance enhancer, to prevent other predicates
     from backchaining excessively while searching for bindings of
     certain of their arguments. Purists will shun the use of this
     predicate, but some rules are inherently inefficient without the
     addition of some kind of control logic.  Because evaluation of the
     `bound-variables' predicate evaluation of predicates being
     `guarded', using this predicate has the side-effect of locally
     disabling query optimization.  (See `collect-into-set' for an
     example that uses `bound-variables'.

 - Function: CARDINALITY ((?c SET)) :-> (?card INTEGER)
     Function that returns the cardinality of a set.

 - Relation: CLOSED ((?c COLLECTION))
     The collection ?c is closed if all of its members are known.
     Asserting that a relation is closed makes certain computations
     easier.  For example, suppose that the relation `happy' is closed,
     implying that all things that are happy will be asserted as such.
     To prove `(not (happy Fred))', PowerLoom can use a
     negation-as-failure proof strategy which returns TRUE if `Fred'
     cannot be proved to be happy.  Also, if the relation `children' is
     closed, then a value for the expression `(range-max-cardinality
     children Fred)' can be inferred merely by counting the number of
     fillers of the `children' role on `Fred'.

 - Function: COLLECT-INTO-SET ((?c COLLECTION)) :-> (?l SET)
     Infer as many members of ?c as possible and collect them into a
     set ?l.  For example, here is a rule used to compute bindings for
     the `fillers' predicate:

            (<= (fillers ?r ?i ?v)
                (and (bound-variables ?r ?i)
                     (collect-into-set (setofall ?v (holds ?r ?i ?v)) ?members)))

     When `?r' and `?i' are bound, the term `(setofall ?v (holds ?r ?i
     ?v))' evaluates to a unary relation satisfied for each filler of
     the relation in `?r' applied to the instance in `?i'.
     `collect-into-set' causes the extension of this
     (dynamically-defined) unary relation to be computed.  Note the use
     of `bound-variables' to screen out unbound variables before they
     are passed to the `setofall' predicate.

 - Concept: COLLECTION ((?c AGGREGATE))
     The class of all collections.  This includes all sets, lists,
     concepts, and relations.

 - Function: COLLECTIONOF ((?m THING)) :-> (?c COLLECTION)
     Abstract function existing to subsume `SETOF' and `LISTOF'.

 - Relation: COMMENT ((?x THING) (?s STRING))
     ?s is a comment attached to ?x.  Comments are a generalization of
     other annotations such as `documentation' and `issue' strings.

 - Relation: COMMUTATIVE ((?r RELATION))
     A relation ?r is commutative if its truth value is invariant with
     any permutation of its arguments.

 - Concept: CONCEPT ((?x RELATION))
     The class of reified unary relations.  The Powerloom notion of
     `concept' corresponds to the object-oriented notion of `class'.
     From a logic standpoint, the notion of a concept is hard to
     distinguish from the notion of `unary relation'.  The conceptual
     distinction is best illustrated in the domain of linguistics,
     where concepts are identified with collective nouns while unary
     relations are identified with adjectives.  For example, `Rock' is
     a concept, while `rocky' is a unary relation.

 - Function: CONCEPT-PROTOTYPE ((?c CONCEPT)) :-> (?i THING)
     Function that, given a concept, returns a prototypical instance
     that inherits all constraints that apply to any concept member,
     and has no additional constraints.

 - Relation: COVERING ((?c COLLECTION) (?cover SET))
     True if ?c is a subset of the union of all collections in the set
     ?cover (see `disjoint-covering').

 - Relation: CUT ((?arguments THING))
     Prolog-like CUT.  Succeeds the first time and then fails.
     Side-effect:  Locally disables query optimization.

 - Relation: DIRECT-SUBRELATION ((?r RELATION) (?sub RELATION))
     True iff ?sub is a direct subrelation of ?r; written in set
     notation, ?sub < ?r, and there is no ?s such that ?sub < ?s < ?r.
     This relation will generate bindings for at most one unbound
     argument.

 - Relation: DIRECT-SUPERRELATION ((?r RELATION) (?super RELATION))
     True iff ?super is a direct superrelation of ?r; in set notation,
     ?super > ?r, and there is no ?s such that ?super > ?s > ?r.  This
     relation will generate bindings for at most one unbound argument.

 - Relation: DISJOINT ((?c1 COLLECTION) (?c2 COLLECTION))
     True if the intersection of ?c1 and ?c2 is empty.

 - Relation: DISJOINT-COVERING ((?c COLLECTION) (?disjointcover SET))
     True if ?c is covered by the collections in ?disjointCover and if
     the member sets in ?disjointCover are mutually-disjoint.  For
     example the concepts `Igneous-Rock', `Metamorphic-Rock', and
     `Sedimentary-Rock' together form a disjoint covering of the
     concept `Rock'.

 - Relation: DOCUMENTATION ((?x THING) (?s STRING))
     ?s is a documentation string attached to ?x.  Some of the
     PowerLoom text processing tools look for documentation strings and
     import them into documents.

 - Relation: DOMAIN ((?r RELATION) (?d CONCEPT))
     True if for any tuple `T' that satifies ?r, the first argument of
     `T' necessarily belongs to the concept ?d.  `domain' exists for
     convenience only and is defined in terms of `nth-domain'.  `domain'
     assertions should be avoided, since they create redundant
     `nth-domain' propositions (use `nth-domain' directly).

 - Relation: DUPLICATE-FREE ((?c COLLECTION))
     ?c is duplicate-free if no two members denote the same object.

 - Concept: DUPLICATE-FREE-COLLECTION ((?c DUPLICATE-FREE))
     ?c is free of duplicates

 - Relation: EMPTY ((?c COLLECTION))
     The collection ?c is empty if it has no members.  Note that for
     collections possessing open-world semantics, (e.g., most concepts)
     the fact that the collection has no known members does not
     necessarily imply that it is empty.

 - Relation: EQUIVALENT-RELATION ((?r RELATION) (?equiv RELATION))
     True if ?r is equivalent to ?equiv; written in set notation, ?r =
     ?equiv.  This relation will generate bindings for at most one
     unbound argument.

 - Relation: EXAMPLE ((?r RELATION) (?e THING))
     ?e is an example of (the use of) ?r.

 - Function: FILLERS ((?r RELATION) (?i THING)) :-> (?members SET)
     Given a relation ?r and instance ?i, returns a set of known
     fillers of ?r applied to ?i.  IMPORTANT: this also collects
     intensional fillers such as skolems that might be identical
     extensionally.

 - Concept: FRAME-PREDICATE ((?c RELATION))
     A frame predicate is a second-order relation that is used to
     describe constraints on the set of fillers for a binary relation
     applied to an instance.  Examples of frame predicates are
     `range-cardinality', `range-type', and `numeric-minimum'.  Frame
     predicates are typically used to capture the kinds of relations
     manipulated by description logic systems such as USC/ISI's Loom
     system.

 - Concept: FUNCTION ((?r RELATION))
     A relation is a function if its last argument is a function of its
     first n-1 arguments, i.e., if it is a single-valued relation.
     Functions explicitly declared as such differ from relations in
     that they may appear syntactically as a term applied to n-1
     arguments.  For example, to express the sentence "two plus two
     equals four", because `+' is a function we can write `(= (+ 2 2)
     4)'.  The same sentence written in relational syntax would look
     like `(+ 2 2 4)'.  If a relation is introduced using the
     `defrelation' syntax and also declared to be single-valued, the
     functional syntax does not apply; only the explicit use of
     `deffunction' sanctions the use of that syntax.

 - Relation: GOES-FALSE-DEMON ((?r RELATION)
          (?computation COMPUTED-PROCEDURE))
     Names a `computation' (a function) that is attached (logically) to
     ?r  Each time a proposition with predicate ?r becomes false, the
     function is applied to that proposition.

 - Relation: GOES-TRUE-DEMON ((?r RELATION)
          (?computation COMPUTED-PROCEDURE))
     Names a `computation' (a function) that is attached (logically) to
     ?r  Each time a proposition with predicate ?r becomes true, the
     function is applied to that proposition.

 - Relation: GOES-UNKNOWN-DEMON ((?r RELATION)
          (?computation COMPUTED-PROCEDURE))
     Names a `computation' (a function) that is attached (logically) to
     ?r  Each time a proposition with predicate ?r becomes unknown, the
     function is applied to that proposition.

 - Relation: HOLDS ((?relation RELATION) (?arguments THING))
     True if the tuple ?ARGUMENTS is a member of the relation
     ?RELATION.  `holds' is a variable arity predicate that takes a
     relation as its first argument, and zero or more additional
     arguments.  It returns values equivalent to a subgoal that has the
     first argument as a predicate and the remaining arguments shifted
     one place to the left.  For `holds' to succeed, the (first)
     relation argument must be bound - PowerLoom will NOT cycle through
     all relations searching for ones that permit the proof to succeed.
     However, users can obtain the same effect if they choose by using
     other second-order predicates to generate relation bindings.  For
     example, the query

             (retrieve all ?x (and (Relation ?r)
                                   (holds ?r Fred ?x)))

     retrieves all constants for which there is some binary relation
     that relates `Fred' to that relation.

 - Relation: IMAGE-URL ((?x THING) (?url STRING))
     ?url is a URL pointing to an image illustrating ?x.  The
     Ontosaurus browser looks for `image-url' values attached to
     objects it is presenting, and displays them prominently, thereby
     spiffing up its displays.

 - Relation: INEQUALITY ((?x NUMBER) (?y NUMBER))
     Abstract superrelation of inequality relations.

 - Relation: INSTANCE-OF ((?x THING) (?c CONCEPT))
     True if ?x is an instance of ?c.  Can be used to generate concept
     values of ?c, given an instance ?x.

 - Function: INVERSE ((?r BINARY-RELATION)) :-> (?inverserelation THING)
     Function that returns the inverse relation for ?r.  PERFORMANCE
     NOTE: for best results there should be only one `(inverse R I)'
     assertion per relation pair `R' and `I'.  In that case `R' is
     viewed as the canonical relation and `I' simply provides a
     different access mechanism to the canonical relation.  In a
     logic-based KR paradigm inverse relations are redundant and do not
     add anything that couldn't be represented or queried without them,
     however, sometimes they can provide some extra convenience for
     users.  Asserting `(inverse I R)' also will not cause an error but
     can degrade backward inference performance due to the extra
     redundant rule that gets generated.  If domain rules will be
     written in terms of both `R' and `I' (as opposed to only `R'),
     `(inverse I R)' should be asserted also to get full inferential
     connectivity between the two relations.

 - Relation: IRREFLEXIVE ((?r RELATION))
     A binary relation ?r is irreflexive if it is false when both of
     its arguments are identical.

 - Relation: ISSUE ((?x THING) (?s STRING))
     ?s is an issue attached to ?x.  An issue string normally comments
     on a topic that has not been resolved to everyone's satisfaction.

 - Relation: IST ((?context CONTEXT) (?p PROPOSITION))
     True if proposition ?P is true in context ?CONTEXT.  The `IST' (is
     true) relation allows one to evaluate a query or rule in more than
     one context.  A common use of `IST' is in defining `lifting axioms'
     that import knowledge from one context to another.  For example,
     below is a rule that accesses a `patient-record' relation in a
     module called `Medical-Kb', `lifts-out' the `age' column, and
     imports it into a `has-age' relation in the current context.

            (<= (has-age ?person ?age)
                (and (has-ssn ?person ?ssn)
                     (exists (?1 ?2 ?3 ?4)
                        (ist Medical-Kb (patient-record ?ssn ?1 ?2 ?age ?3 ?4)))))


 - Function: LENGTH ((?x THING)) :-> (?z INTEGER)
     Function that returns the length of a string or a logical list.
     NOT YET IMPLEMENTED FOR LISTS.

 - Relation: LENGTH-OF-LIST ((?l COLLECTION) (?length INTEGER))
     Computes the length of the list or set ?l.

 - Relation: LEXEME ((?r THING) (?s STRING))
     ?s is a lexeme for the relation or individual ?r.  A relation or
     individual ?r can have zero or more lexemes, words that are
     natural langage equivalents of a logical constant.  The same
     lexeme may be attached to more than one constant.

 - Concept: LIST ((?l ORDERED))
     A list is an ordered collection of elements.  The range of the
     function `listof' consists of elements of type `List'.

 - Function: LISTOF ((?m THING)) :-> (?c LIST)
     Term-forming function that defines an ordered list consisting of
     all function arguments.  Within logical expressions `listof' is
     most commonly used in conjunction with the `member-of' predicate.
     For example the query

            (retrieve ?x (member-of ?x (listof a b c)))

     returns the constants `a', `b', and `c' on successive iterations.

 - Relation: MAXIMUM-VALUE ((?l COLLECTION) (?max NUMBER))
     Binds ?max to the maximum of the numbers in the list ?l.

 - Relation: MEAN-VALUE ((?l COLLECTION) (?mean NUMBER))
     Binds ?mean to the mean of the numbers in ?l.

 - Relation: MEDIAN-VALUE ((?l COLLECTION) (?median NUMBER))
     Binds ?median to the median of the numbers in ?l.

 - Relation: MEMBER-OF ((?x THING) (?c COLLECTION))
     TRUE if ?x is a member of collection ?c.  A common use of
     `member-of' is for binding a variable to successive members in a
     list or set (see `listof' and `setof').

 - Relation: MINIMUM-VALUE ((?l COLLECTION) (?min NUMBER))
     Binds ?min to the minimum of the numbers in the list ?l.

 - Relation: MUTUALLY-DISJOINT-COLLECTION ((?s SET))
     True if the members of ?s are pair-wise disjoint.  Used most often
     to expresse disjointness constraints between concepts.  For example

             (mutually-disjoint-collection (setof MAN WOMAN))

     states that the concepts MAN and WOMAN are disjoint.


 - Relation: NTH-DOMAIN ((?r RELATION) (?i INTEGER) (?d CONCEPT))
     True if the nth value for a tuple T satisfying ?r must belong to
     the concept ?d.  Argument counting starts at zero.

 - Relation: NUMERIC-MAXIMUM ((?r RELATION) (?i THING) (?n NUMBER))
     Relation that specifies an upper bound ?N on any numeric value
     that can belong to the set of fillers of the relation ?r applied
     to ?i.

 - Relation: NUMERIC-MINIMUM ((?r RELATION) (?i THING) (?n NUMBER))
     Relation that specifies a lower bound ?N on any numeric value that
     can belong to the set of fillers of the relation ?r applied to ?i.

 - Concept: NUMERIC-SET ((?s COLLECTION))
     ?s is a set of numbers

 - Relation: ORDERED ((?c COLLECTION))
     ?c is ordered if the ordering of its members is significant.
     Lists are ordered, while sets are not.

 - Relation: PHRASE ((?r THING) (?s STRING))
     A phrase is a variablized sentence, a template, that is used to
     express individual axiomatic facts as natural language sentences.
     By convention, a phrase contains one or more occurrences of each
     variable in a relation or concept definition, it does not begin
     with a capital letter, and it has no concluding period.
     Systematic attachment of phrases to relations can be leveraged by
     tools that generate natural language paraphrases of logic
     sentences.

 - Function: PROJECT-COLUMN ((?i INTEGER) (?c COLLECTION)) :-> (?l LIST)
     Project elements in column ?i (zero-based) of the tuples of ?c and
     collect them into a list ?l.

 - Relation: PROPER-SUBRELATION ((?r RELATION) (?sub RELATION))
     True iff ?sub is a proper subrelation of ?r; written in set
     notation, ?sub < ?r.  This relation will generate bindings for at
     most one unbound argument.

 - Relation: PROPER-SUPERRELATION ((?r RELATION) (?super RELATION))
     True iff ?super is a proper superrelation of ?r; written in set
     notation, ?super > ?r.  This relation will generate bindings for
     at most one unbound argument.

 - Relation: RANGE ((?r RELATION) (?rng CONCEPT))
     True if for any tuple `T' that satifies ?r, the last argument of
     `T' necessarily belongs to the concept ?rng.  `range' exists for
     convenience only and is defined in terms of `nth-domain'.  `range'
     assertions should be avoided, since they create redundant
     `nth-domain' propositions (use `nth-domain' directly).

 - Function: RANGE-CARDINALITY ((?r RELATION) (?i THING)) :->
          (?card INTEGER)
     Function that returns the cardinality of the set of fillers of the
     relation ?r applied to ?i.  The cardinality function returns a
     value only when the relations `range-min-cardinality' and
     `range-max-cardinality' compute identical values, i.e., when the
     best lower and upper bounds on the cardinality are equal.  Each of
     these bounding functions employs a variety of rules to try and
     compute a tight bound.

 - Relation: RANGE-CARDINALITY-LOWER-BOUND ((?r RELATION) (?i THING)
          (?lb INTEGER))
     Relation that specifies a lower bound on the cardinality of the
     set of fillers of the relation ?r applied to ?i.  The difference
     between `range-cardinality-lower-bound' and
     `range-min-cardinality' is subtle but significant.   Suppose we
     state that nine is a lower bound on the number of planets in the
     solar system, and then ask if eight is (also) a lower bound:

             (assert (range-cardinality-lower-bound hasPlanets SolarSystem 9))
             (ask (range-cardinality-lower-bound hasPlanets SolarSystem 8))  ==> TRUE

     PowerLoom will return TRUE.  However if we ask if the minimum
     cardinality of the solar system's planets is eight, we get back
     UNKNOWN

             (ask (range-min-cardinality hasPlanets SolarSystem 8)) ==> UNKNOWN

     because eight is not the tightest lower bound.

 - Relation: RANGE-CARDINALITY-UPPER-BOUND ((?r RELATION) (?i THING)
          (?ub INTEGER))
     Relation that specifies an upper bound on the cardinality of the
     set of fillers of the relation ?r applied to ?i. (see the
     discussion for `range-cardinality-lower-bound').

 - Function: RANGE-MAX-CARDINALITY ((?r RELATION) (?i THING)) :->
          (?maxcard INTEGER)
     Returns the strictest computable upper bound on the cardinality of
     the set of fillers of the relation ?r applied to ?i.  (see the
     discussion for `range-cardinality-lower-bound').

 - Function: RANGE-MIN-CARDINALITY ((?r RELATION) (?i THING)) :->
          (?mincard INTEGER)
     Returns the strictest computable lower bound on the cardinality of
     the set of fillers of the relation ?r applied to ?i.  (see the
     discussion for `range-cardinality-lower-bound').

 - Relation: RANGE-TYPE ((?r RELATION) (?i THING) (?type CONCEPT))
     Relation that specifies a type/range of the relation ?r applied to
     ?i.  Multiple range types may be asserted for a single pair
     <?r,?i>.  Technically, a retrieval of types for a given pair
     should include all supertypes (superconcepts) of any type that is
     produced, but for utility's sake, only asserted or directly
     inferrable types are returned.

 - Relation: REFLEXIVE ((?r RELATION))
     A binary relation ?r is reflexive if it is always true when both
     of its arguments are identical.

 - Concept: RELATION ((?x SET))
     The class of relations.  This includes all concepts and all
     functions.

 - Relation: RELATION-COMPUTATION ((?r RELATION)
          (?computation COMPUTED-PROCEDURE))
     Names a `computation' (a function) that evaluates an (atomic)
     relation proposition during query processing.  The function is
     passed a proposition for evaluation for which all arguments are
     bound.  The function returns a BOOLEAN if it represents a
     predicate, or some sort of value if it is a function.

 - Relation: RELATION-CONSTRAINT ((?r RELATION)
          (?computation COMPUTED-PROCEDURE))
     Names a `computation' (a function) that evaluates an (atomic)
     relation proposition during query processing.  The function is
     passed a proposition for evaluation for which at most one argument
     is unbound.  The function returns a BOOLEAN if it represents a
     predicate, or some sort of value if it is a function.  If all
     arguments are bound the function computes whether the constraint
     holds.  If all but one argument is bound and the unbound argument
     is a pattern variable then the missing value is computed.

 - Relation: RELATION-EVALUATOR ((?r RELATION) (?ev COMPUTED-PROCEDURE))
     Names an `evaluator' (a function) that evaluates an (atomic)
     relation proposition during constraint propagation.  This defines
     an extensible means for computing using auxiliary data structures.
     The function is passed a proposition for evaluation.  All
     side-effects are made by updates to the proposition, or by
     generating other assertions.

 - Relation: RELATION-SPECIALIST ((?r RELATION)
          (?sp COMPUTED-PROCEDURE))
     Names a `specialist' (a function) that evaluates an (atomic)
     relation proposition during query processing.  This defines an
     extensible means for computing with the control stack.  The
     function is passed a CONTROL-FRAME that contains the proposition,
     and returns a keyword :FINAL-SUCCESS, :CONTINUING-SUCCESS,
     :FAILURE, or :TERMINAL-FAILURE that controls the result of the
     computation.

 - Concept: SCALAR ((?x SCALAR))
     The class of scalar quantities.

 - Concept: SCALAR-INTERVAL ((?x SCALAR))
     An interval of scalar quantities.

 - Concept: SET ((?s DUPLICATE-FREE-COLLECTION))
     This class denotes the mathematical notion of a `set'; a
     collection that has no duplicates.

 - Function: SETOF ((?m THING)) :-> (?c SET)
     Term-forming function that defines an enumerated set consisting of
     all function arguments.  `setof' is like `listof' except that it
     removes duplicate values.

 - Relation: SINGLE-VALUED ((?c RELATION))
     The relation ?c is single-valued if the value of its last argument
     is a function of all other arguments.  All functions are
     single-valued (see `function').

 - Relation: SQUARE-ROOT ((?x NUMBER) (?y NUMBER))
     Relation that returns the positive and negative square roots: ?y =
     sqrt(?x).  For positive roots only see function SQRT.

 - Relation: STANDARD-DEVIATION ((?l COLLECTION) (?sd NUMBER))
     Binds ?sd to the standard deviation of the numbers in ?l.

 - Function: STRING-CONCATENATE ((?x1 STRING) (?x2 STRING)) :->
          (?x3 STRING)
     Concatenate strings ?x1 and ?x2 and bind ?x3 to the result.

 - Relation: SUBRELATION ((?r RELATION) (?sub RELATION))
     True iff ?sub is a subrelation of ?r; written in set notation,
     ?sub =< ?r.  This relation will generate bindings for at most one
     unbound argument.

 - Relation: SUBSET-OF ((?sub COLLECTION) (?super COLLECTION))
     True if ?sub is a subset of ?super.  For performance reasons, the
     `subset-of' predicate refuses to search for bindings if both of
     its variables are unbound.  Implementation note: `subset-of' is
     treated specially internally to PowerLoom, and hence Powerloom
     does not permit the augmentation of `subset-of' with additional
     inference rules.  In otherwords, `subset-of' behaves semantically
     like an operator instead of a relation.

 - Function: SUBSTRING ((?s STRING) (?start INTEGER) (?end INTEGER))
          :-> (?sub STRING)
     Generate the substring of ?s starting at position ?start
     (zero-based), ending just before position ?end and bind ?sub to
     the result.  This is the PowerLoom equivalent to the STELLA method
     `subsequence'.  In addition, this function can be used to locate
     substrings in strings by supplying values for ?s and ?sub and
     allowing ?start and ?end to be bound by the function specialist.
     In other words,       (retrieve all (?start ?end) (substring "foo"
     ?start ?end "o"))  ==>  ?start = 1, ?end = 2,       ?start = 2,
     ?end = 3.

 - Relation: SUM ((?l COLLECTION) (?sum NUMBER))
     Binds ?sum to the sum of the numbers in the list ?l.

 - Relation: SUPERRELATION ((?r RELATION) (?super RELATION))
     True iff ?super is a superrelation of ?r; written in set notation,
     ?super >= ?r.  This relation will generate bindings for at most
     one unbound argument.

 - Relation: SYMMETRIC ((?r RELATION))
     A binary relation ?r is symmetric if it is commutative.

 - Relation: SYNONYM ((?term THING) (?synonym THING))
     Assert that ?SYNONYM is a synonym of ?TERM.  This causes all
     references to ?SYNONYM to be interpreted as references to ?TERM.
     Retraction eliminates a synonym relation.

 - Relation: TOTAL ((?r FUNCTION))
     True if the function ?R is defined for all combinations of inputs.
     By default, functions are not assumed to be total (unlike Prolog,
     which `does' make such an assumption.  For example, if we define a
     two-argument function `foo' and then retrieve its value applied to
     some random instances `a' and `b', we get nothing back:

             (deffunction foo (?x ?y) :-> ?z)
             (retrieve ?x (= ?x (foo a b)))

     However, if we assert that `foo' is total, then we get a skolem
     back when we execute the same retrieve:

             (assert (total foo))
             (retrieve ?x (= ?x (foo a b)))


 - Relation: TRANSITIVE ((?r RELATION))
     A binary relation ?r is transitive if (?r ?x ?y) and (?r ?y ?z)
     implies that (?r ?x ?z).  Note that functions cannot be
     transitive, since their single-valuedness would not allow multiple
     different values such as (?r ?x ?y) and (?r ?x ?z) due to the
     Unique Names Assumption made by PowerLoom.

 - Relation: TYPE-OF ((?c CONCEPT) (?x THING))
     True if ?x is a member of the concept ?c.

 - Function: VALUE ((?function FUNCTION) (?arguments THING)) :->
          (?value THING)
     True if applying ?FUNCTION to ?ARGUMENTS yields the value
     `?value'.  The `value' predicate is the analog of `holds', except
     that it applies to functions instead of relations.

 - Relation: VARIABLE-ARITY ((?r RELATION))
     Asserts that the relation ?r can take a variable number of
     arguments.

 - Relation: VARIANCE ((?l COLLECTION) (?variance NUMBER))
     Binds ?variance to the variance of the numbers in ?l.

* Menu:

* Miscellaneous::

