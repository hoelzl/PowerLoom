This is manual.info, produced by makeinfo version 4.2 from manual.texi.

   This file documents the knowledge representation and reasoning
system.


File: manual.info,  Node: API Functions,  Next: Language Specific Interface,  Prev: PowerLoom API,  Up: PowerLoom API

API Functions
=============

   Many of the functions take a `module' argument that causes the
function to be evaluated in the context of that module. Passing in a
NULL value for the module argument means that evaluation takes place in
the current module. The module argument is frequently followed by an
`environment' argument that specifies which inference environment
should be assumed during evaluation. Values for `environment' are
`ASSERTION-ENV', `TAXONOMIC-ENV', and `INFERENCE-ENV'.  `ASSERTION-ENV'
specifies that a knowledge base query or lookup should take into
account only explicitly asserted propositions. `TAXONOMIC-ENV'
specifies that a knowledge base query should take into account
explicitly-asserted propositions plus any rules that specify subsumption
relationships.   `INFERENCE-ENV' specifies that a knowledge base query
should take all relevant propositions into account, including those
generated during forward inferencing.  A NULL value for the the
`environment' argument defaults to `TAXONOMIC-ENV'.

   Many of the functions that take PowerLoom or Stella objects as inputs
also have an analog version whose name starts with the prefix "s-" that
take strings as inputs.  This is provided as a convenience so that
programmers will not necessarily need to manipulate PowerLoom objects
directly.

 - Function: ask ((query CONS) (module MODULE)
          (environment ENVIRONMENT)) : TRUTH-VALUE
     Returns a truth value for QUERY in MODULE and ENVIRONMENT.  QUERY
     has the same syntax as the PowerLoom `ask' command (which see) but
     with the `ask' operator omitted.  For example, here are some legal
     QUERY arguments:

              ((happy Fred))
              ((happy Fred) :inference-level :assertion)
              ((happy Fred) :inference-level :assertion :timeout 1.0)

     As a convenience, a QUERY argument whose first element is a symbol
     is interpreted as a sentence that is queried without any options.
     For example:

              (happy Fred)

     is a legal QUERY argument.  Note that for a setence whose relation
     is a list itself, e.g., `((FruitFn BananaTree) MyBanana)' this
     shortcut is not available, that is, in that case an extra level of
     list nesting is always necessary.  The returned truth value
     represents the logical truth of the queried sentence as determined
     by PowerLoom.  It can be be tested via the functions `is-true',
     `is-false' and `is-unknown' (which see).

 - Function: assert-binary-proposition ((relation LOGIC-OBJECT)
          (arg OBJECT) (value OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : PROPOSITION
     Assert that the proposition (RELATION ARG VALUE) is TRUE in
     MODULE.  Return the asserted proposition.

 - Function: assert-nary-proposition ((relation-and-arguments OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : PROPOSITION
     Assert that the proposition represented by the list `
     relation-and-arguments' satisfies the relation `relation'.

 - Function: assert-proposition ((proposition PROPOSITION)
          (module MODULE) (environment ENVIRONMENT)) : PROPOSITION
     Assert that the proposition PROPOSITION is true in MODULE.  Return
     the asserted proposition.

 - Function: assert-unary-proposition ((relation LOGIC-OBJECT)
          (arg OBJECT) (module MODULE) (environment ENVIRONMENT)) :
          PROPOSITION
     Assert that the proposition (RELATION ARG) is TRUE in MODULE.
     Return the asserted proposition.

 - Function: change-module ((module MODULE)) : MODULE
     Set the current module to MODULE and return it.  If MODULE is
     `null', then no switch is performed and the current module is
     returned.

 - Function: clear-module ((module MODULE)) : MODULE
     Destroy the contents of the module MODULE as well as the contents
     of all of its children, recursively.

 - Function: conceive ((sentence OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)
     Create one or more proposition objects from the sentence SENTENCE
     in the  module MODULE.  Return an iterator of the propositions.
     If any of the new propositions has the same structure as an
     already existing proposition, an automatic check for duplicates
     will return the pre-existing proposition.  Multiple propositions
     may be returned for a single sentence because of normalization of
     equivalences, conjunctions, etc.

     Signals a `Proposition-Error' if PowerLoom could not conceive
     SENTENCE.

 - Function: cons-to-pl-iterator ((self CONS)) : PL-ITERATOR
     Convert a Stella cons list into an API iterator.

 - Function: create-concept ((name STRING) (parent LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : LOGIC-OBJECT
     Create a concept named NAME in the designated MODULE, with the
     designated PARENT superconcept (which can be left undefined).
     Additional superconcepts can be added via assertions of the
     `subset-of' relation.  Note that a specified PARENT concept needs
     to be created separately.

     Note that because names in modules that are not case-sensitive are
     canonicalized, the name of the returned object may not match NAME
     exactly.

 - Function: create-enumerated-list ((members CONS)) : LOGIC-OBJECT
     Create a logical term that denotes a list containing MEMBERS.
     Useful for passing lists as arguments to parameterized queries.

 - Function: create-enumerated-set ((members CONS)) : LOGIC-OBJECT
     Create a logical term that denotes the enumerated set containing
     MEMBERS.

 - Function: create-function ((name STRING) (arity INTEGER)
          (module MODULE) (environment ENVIRONMENT)) : LOGIC-OBJECT
     Create a function named NAME with arity ARITY  in the designated
     MODULE.  Domain and range information can be added via assertions
     of `nth-domain' (or `domain' and `range') relations.

     Note that because names in modules that are not case-sensitive are
     canonicalized, the name of the returned object may not match NAME
     exactly.

 - Function: create-module ((name STRING) (parent MODULE)
          (case-sensitive? BOOLEAN)) : MODULE
     Creates a new module NAME as a child of PARENT.  The flag
     CASE-SENSITIVE? controls whether names read in this module will be
     case sensitive or not.

 - Function: create-object ((name STRING) (concept LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : LOGIC-OBJECT
     Create an object named NAME of type CONCEPT in the designated
     module.  Both NAME and CONCEPT can be `null'.  If NAME is `null'
     then an object will be created with a new, non-conflicting name
     based on the name of CONCEPT, or system-generated if no concept is
     specified.  If CONCEPT is `null', then the object will be of type
     THING.

     Note that because names in modules that are not case-sensitive are
     canonicalized, the name of the returned object may not match NAME
     exactly.

     Return the object.

 - Function: create-relation ((name STRING) (arity INTEGER)
          (module MODULE) (environment ENVIRONMENT)) : LOGIC-OBJECT
     Create a relation named NAME with arity ARITY in the designated
     module.  Domain and range information can be added via assertions
     of `nth-domain' (or `domain' and `range') relations.

     Note that because names in modules that are not case-sensitive are
     canonicalized, the name of the returned object may not match NAME
     exactly.

 - Function: destroy-object ((object LOGIC-OBJECT)) :
     Delete the object OBJECT, retracting all facts attached to it.

 - Method: empty? ((self PL-ITERATOR)) : BOOLEAN
     Return TRUE if the iterator SELF has no more elements.

 - Function: evaluate ((command OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : OBJECT
     Evaluate the command COMMAND within MODULE and return the result.
     Currently, only the evaluation of (possibly nested) commands and
     global variables is supported.  Commands are simple to program in
     Common Lisp, since they are built into the language, and
     relatively awkward in Java and C++.  Users of either of those
     languages are more likely to want to call `s-evaluate'.

 - Function: generate-unique-name ((prefix STRING) (module MODULE)
          (environment ENVIRONMENT)) : STRING
     Generates a name based on PREFIX with a number appended that is
     not currently in use in `module.'  In a non-case-sensitive module,
     the returned name will be all upper case (This latter feature may
     change!)

 - Function: get-arity ((relation LOGIC-OBJECT)) : INTEGER
     Return the arity of the relation RELATION.

 - Function: get-binary-proposition ((relation LOGIC-OBJECT)
          (arg1 OBJECT) (arg2 OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : PROPOSITION
     Return a proposition such that (RELATION ARG1 ARG2) is true.  The
     RELATION argument must be bound to a relation.  One or both of the
     ARG1 and ARG2 arguments may be set to NULL, which is interpreted
     as a wildcard. If more than one proposition matches the input
     criteria, the selection is arbitrary.  This procedure is normally
     applied to single-valued relations or functions.

 - Function: get-binary-propositions ((relation LOGIC-OBJECT)
          (arg1 OBJECT) (arg2 OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)
     Return propositions such that (RELATION ARG1 ARG2) is true.  The
     RELATION argument must be bound to a relation.  One or both of the
     ARG1 and ARG2 arguments may be set to NULL, which is interpreted
     as a wildcard.

 - Function: get-child-modules ((module MODULE)) : (PL-ITERATOR OF
          MODULE)
     Return the modules that are immediate children of MODULE.

 - Function: get-column-count ((obj OBJECT)) : INTEGER
     Return the number of columns in OBJ, which must be of type
     proposition, cons, vector or PL-iterator.  For a proposition, the
     number includes both the predidate and arguments. For the
     PL-iterator case,the number of columns is for the current value of
     the iterator.

 - Function: get-concept ((name STRING) (module MODULE)
          (environment ENVIRONMENT)) : LOGIC-OBJECT
     Return a class/concept named NAME that is local to or visible from
     the module MODULE.

 - Function: get-concept-instance-matching-value
          ((concept LOGIC-OBJECT) (relation LOGIC-OBJECT)
          (value OBJECT) (module MODULE) (environment ENVIRONMENT)) :
          OBJECT
     Return a member of concept CONCEPT that has an attribute matching
     VALUE for the binary relation RELATION, i.e., `(relation <result>
     value)' holds.

 - Function: get-concept-instances ((concept LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : PL-ITERATOR
     Return instances of the concept CONCEPT.  Include instances of
     subconcepts of CONCEPT.  Depending on CONCEPT, the return values
     could be (wrapped) literals.

 - Function: get-concept-instances-matching-value
          ((concept LOGIC-OBJECT) (relation LOGIC-OBJECT)
          (value OBJECT) (module MODULE) (environment ENVIRONMENT)) :
          PL-ITERATOR
     Return members of concept CONCEPT that have an attribute matching
     VALUE for the binary relation RELATION, i.e., `(relation <result>
     value)' holds.

 - Function: get-current-module ((environment ENVIRONMENT)) : MODULE
     Return the currently set module

 - Function: get-direct-concept-instances ((concept LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : PL-ITERATOR
     Return instances of concept CONCEPT.  Exclude instances of
     subconcepts of CONCEPT.  Depending on CONCEPT, the return values
     could be (wrapped) literals.

 - Function: get-direct-subrelations ((relation LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF
          LOGIC-OBJECT)
     Return relations that directly specialize RELATION.  Non-reflexive.

 - Function: get-direct-superrelations ((relation LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF
          LOGIC-OBJECT)
     Return relations that directly generalize RELATION.  Non-reflexive.

 - Function: get-direct-types ((object LOGIC-OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : (PL-ITERATOR OF LOGIC-OBJECT)
     Return most specific concepts that OBJECT belongs to.

 - Function: get-domain ((relation LOGIC-OBJECT)) : LOGIC-OBJECT
     Return the type (a concept) for the first argument to the binary
     relation RELATION.

 - Function: get-enumerated-collection-members ((collection OBJECT)) :
          CONS
     Returns the members of an enumerated collection.  This works on
     all types of collection, i.e., sets and lists

 - Function: get-home-module ((object LOGIC-OBJECT)) : MODULE
     Return the module in which OBJECT was created.

 - Function: get-inferred-binary-proposition-values
          ((relation LOGIC-OBJECT) (arg OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : PL-ITERATOR
     Return all values `v' such that (RELATION ARG `v') has been
     asserted or can be inferred.

 - Function: get-module ((name STRING) (environment ENVIRONMENT)) :
          MODULE
     Return a module named NAME.

 - Function: get-modules () : (PL-ITERATOR OF MODULE)
     Return all modules currently loaded into PowerLoom.

 - Function: get-name ((obj OBJECT)) : STRING
     Return the name of OBJ, if it has one.  Otherwise return `null'.

 - Function: get-nth-domain ((relation LOGIC-OBJECT) (n INTEGER)) :
          LOGIC-OBJECT
     Return the type (a concept) for the the nth argument of the
     relation RELATION.  Counting starts at zero.

 - Function: get-nth-float ((sequence OBJECT) (n INTEGER)) : FLOAT
     Return the floating point value in the `nth' column of SEQUENCE.
     Counting starts at zero.  SEQUENCE must be of type proposition,
     cons, vector or PL-iterator.  A zero column number returns a
     proposition's relational predicate.  For the PL-iterator case, the
     the current value pointed to by the iterator is used.  If this is
     not a floating point value, then NULL-FLOAT will be returned.

 - Function: get-nth-integer ((sequence OBJECT) (n INTEGER)) : INTEGER
     Return an integer representation of the value in the `nth' column
     of SEQUENCE. Counting starts at zero.  SEQUENCE must be of type
     proposition, cons, vector or PL-iterator.  A zero column number
     returns a proposition's relational predicate.  For the PL-iterator
     case, the the current value pointed to by the iterator is used.
     If this is not an integer value, then NULL-INTEGER will be
     returned.

 - Function: get-nth-logic-object ((sequence OBJECT) (n INTEGER)) :
          LOGIC-OBJECT
     Return a logic object representation of the value in the `nth'
     column of SEQUENCE.  Counting starts at zero.  SEQUENCE must be of
     type proposition, cons, vector or PL-iterator.  A zero column
     number returns a proposition's relational predicate.  For the
     PL-iterator case, the the current value pointed to by the iterator
     is used.  A zero column number returns the proposition's
     relational predicate.

 - Function: get-nth-string ((sequence OBJECT) (n INTEGER)) : STRING
     Return a string representation of the value in the `nth' column of
     SEQUENCE. Counting starts at zero.  SEQUENCE must be of type
     proposition, cons, vector or PL-iterator.  A zero column number
     returns a proposition's relational predicate.  For the PL-iterator
     case, the the current value pointed to by the iterator is used.
     This will always succeed, even if the `nth' value is not a string
     object.  In that case, a string reprensentation will be returned.

 - Function: get-nth-value ((sequence OBJECT) (n INTEGER)) : OBJECT
     Return the value in the `nth' column of SEQUENCE.  Counting starts
     at zero.  SEQUENCE must be of type proposition, cons, vector or
     PL-iterator.  A zero column number returns a proposition's
     relational predicate.  For the PL-iterator case, the number of
     columns is for the current value of the iterator.

 - Function: get-object ((name STRING) (module MODULE)
          (environment ENVIRONMENT)) : OBJECT
     Look for an object named NAME that is local to or visible from the
     module MODULE.

 - Function: get-parent-modules ((module MODULE)) : (PL-ITERATOR OF
          MODULE)
     Return the modules that are immediate parents of MODULE.

 - Function: get-predicate ((prop PROPOSITION)) : LOGIC-OBJECT
     Return the concept or relation predicate for the proposition PROP.

 - Function: get-proper-subrelations ((relation LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF
          LOGIC-OBJECT)
     Return relations that specialize RELATION.  Non-reflexive.

 - Function: get-proper-superrelations ((relation LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF
          LOGIC-OBJECT)
     Return relations that generalize RELATION.  Non-reflexive.

 - Function: get-proposition ((relation-and-arguments OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : PROPOSITION
     Return a proposition matching RELATION-AND-ARGUMENTS that has been
     asserted (or inferred by forward chaining).  RELATION-AND-ARGUMENTS
     is a sequence containing objects and nulls.  The first argument
     must be the name of a relation.  A null value acts like a wild
     card.  If more than one proposition matches the input criteria,
     the selection among satisficing propositions is arbitrary.  This
     procedure is normally applied to single-valued relations or
     functions.

 - Function: get-propositions ((relation-and-arguments OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF
          PROPOSITION)
     Return propositions matching RELATION-AND-ARGUMENTS that have been
     asserted (or inferred by forward chaining).  RELATION-AND-ARGUMENTS
     is a sequence containing objects and nulls.  The first argument
     must be the name of a relation.  A null value acts like a wild
     card.

 - Function: get-propositions-in-module ((module MODULE)
          (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)
     Return propositions that have been conceived in the module MODULE.

 - Function: get-propositions-of ((object LOGIC-OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)
     Return all propositions that have OBJECT among their arguments,
     and that are TRUE in the scope of the module MODULE.

 - Function: get-range ((relation LOGIC-OBJECT)) : LOGIC-OBJECT
     Return the type (a concept) for fillers of the binary relation
     RELATION.

 - Function: get-relation ((name STRING) (module MODULE)
          (environment ENVIRONMENT)) : LOGIC-OBJECT
     Return a concept or relation named NAME that is local to or
     visible from the module MODULE.

 - Function: get-relation-extension ((relation LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF
          PROPOSITION)
     Return propositions that satisfy RELATION.  Include propositions
     that satisfy subrelations of RELATION.

 - Function: get-rules ((relation LOGIC-OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)
     Return rules attached to the concept/relation RELATION in either
     antecedent or consequent position.

 - Function: get-types ((object LOGIC-OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : (PL-ITERATOR OF LOGIC-OBJECT)
     Return all named concepts that OBJECT belongs to.

 - Function: initialize () :
     Initialize the PowerLoom logic system.  This function needs to be
     called by all applications before using PowerLoom.  If it is
     called more than once, every call after the first one is a no-op.

 - Function: is-a ((object OBJECT) (concept LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : BOOLEAN
     Return TRUE if OBJECT is a member of the concept CONCEPT.

 - Function: is-default ((tv TRUTH-VALUE)) : BOOLEAN
     Tests whether TV is a default truth value.

 - Function: is-enumerated-collection ((obj OBJECT)) : BOOLEAN
     Test whether OBJ is an enumerated collection.  This subsumes both
     sets and lists.

 - Function: is-enumerated-list ((obj OBJECT)) : BOOLEAN
     Test whether OBJ is an enumerated list

 - Function: is-enumerated-set ((obj OBJECT)) : BOOLEAN
     Test whether OBJ is an enumerated set.

 - Function: is-false ((tv TRUTH-VALUE)) : BOOLEAN
     Tests whether TV is a false truth value.  It can be false either
     absolutely or by default.

 - Function: is-float ((obj OBJECT)) : BOOLEAN
     Test whether OBJ is of type FLOAT (double)

 - Function: is-integer ((obj OBJECT)) : BOOLEAN
     Test whether OBJ is of type INTEGER

 - Function: is-logic-object ((obj OBJECT)) : BOOLEAN
     Test whether OBJ is of type LOGIC-OBJECT

 - Function: is-number ((obj OBJECT)) : BOOLEAN
     Test whether OBJ is of type NUMBER.  This can be either an integer
     or a floating point number.  One key characteristic is that
     `object-to-integer' and `object-to-float' will both work on it.

 - Function: is-strict ((tv TRUTH-VALUE)) : BOOLEAN
     Tests whether TV is a strict (non-default) truth value.

 - Function: is-string ((obj OBJECT)) : BOOLEAN
     Test whether OBJ is of type STRING

 - Function: is-subrelation ((sub LOGIC-OBJECT) (super LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : BOOLEAN
     Return TRUE if SUB is a subconcept/subrelation of SUPER.

 - Function: is-true ((tv TRUTH-VALUE)) : BOOLEAN
     Tests whether TV is a true truth value.  It can be true either
     absolutely or by default.

 - Function: is-true-binary-proposition ((relation LOGIC-OBJECT)
          (arg OBJECT) (value OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : BOOLEAN
     Return TRUE if the proposition (RELATION ARG VALUE) has been
     asserted (or inferred by forward chaining).

 - Function: is-true-proposition ((proposition PROPOSITION)
          (module MODULE) (environment ENVIRONMENT)) : BOOLEAN
     Return TRUE if PROPOSITION is  TRUE in the module MODULE.

 - Function: is-true-unary-proposition ((relation LOGIC-OBJECT)
          (arg OBJECT) (module MODULE) (environment ENVIRONMENT)) :
          BOOLEAN
     Return TRUE if the proposition (RELATION ARG) has been asserted
     (or inferred by forward chaining).

 - Function: is-unknown ((tv TRUTH-VALUE)) : BOOLEAN
     Tests whether TV is an unknown truth value.

 - Function: iterator-to-pl-iterator ((self ITERATOR)) : PL-ITERATOR
     Convert an arbitrary Stella iterator into an API iterator.

 - Method: length ((self PL-ITERATOR)) : INTEGER
     Number of items in SELF.

 - Function: list-to-pl-iterator ((self LIST)) : PL-ITERATOR
     Convert a Stella list into an API iterator.

 - Function: load ((filename STRING) (environment ENVIRONMENT)) :
     Read logic commands from the file named FILENAME and evaluate them.
     The file should begin with an `in-module' declaration that
     specifies the module within which all remaining commands are to be
     evaluated The remaining commands are evaluated one-by-one,
     applying the function `evaluate' to each of them.

 - Function: load-stream ((stream INPUT-STREAM)
          (environment ENVIRONMENT)) :
     Read logic commands from the STELLA stream STREAM and evaluate
     them.  The stream should begin with an `in-module' declaration
     that specifies the module within which all remaining commands are
     to be evaluated The remaining commands are evaluated one-by-one,
     applying the function `evaluate' to each of them.

 - Function: load-native-stream ((stream NATIVE-INPUT-STREAM)
          (environment ENVIRONMENT)) :
     Read logic commands from the native input stream STREAM and
     evaluate them.  Assumes STREAM is a line-buffered stream which is
     a safe compromise but does not generate the best efficiency for
     block-buffered streams such as files.  The stream should begin
     with an `in-module' declaration that specifies the module within
     which all remaining commands are to be evaluated The remaining
     commands are evaluated one-by-one, applying the function
     `evaluate' to each of them.

 - Method: next? ((self PL-ITERATOR)) : BOOLEAN
     Advance the PL-Iterator SELF and return `true' if more elements
     are available, `false' otherwise.

 - Function: object-to-float ((self OBJECT)) : FLOAT
     Coerce SELF to a float, or throw a Stella Exception if the
     coersion is not feasible.

 - Function: object-to-integer ((self OBJECT)) : INTEGER
     Coerce SELF to an integer, or throw a Stella Exception if the
     coersion is not feasible.

 - Function: object-to-parsable-string ((self OBJECT)) : STRING
     Return a string representing a printed representation of the
     object SELF.  Like `object-to-string', but puts escaped double
     quotes around strings.

 - Function: object-to-string ((self OBJECT)) : STRING
     Return a printed representation of the term SELF as a string.

 - Command: print-rules ((relation OBJECT)) :
     Print the list of rules associated with RELATION.

 - Command: retract ((proposition PARSE-TREE)) : OBJECT
     Retract the truth of PROPOSITION.  Return the retracted proposition
     object.  KIF example:  "(retract (happy Fred))" retracts that Fred
     is happy.  Note that for this assertion to succeed, the relation
     `happy' must already be defined.  If the constant `Fred' has not
     yet been created, it is automatically created as a side-effect of
     calling `retract'.

 - Function: retract-binary-proposition ((relation LOGIC-OBJECT)
          (arg OBJECT) (value OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : PROPOSITION
     Retract that the proposition (RELATION ARG VALUE) is TRUE in
     MODULE.  Return the asserted proposition.

 - Function: retract-nary-proposition ((relation-and-arguments OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : PROPOSITION
     Retract the proposition that `arguments' satisfies the relation
     `relation'.

 - Function: retract-proposition ((proposition PROPOSITION)
          (module MODULE) (environment ENVIRONMENT)) : PROPOSITION
     Retract the truth of the proposition PROPOSITION in MODULE.
     Return the retracted proposition.

 - Function: retract-unary-proposition ((relation LOGIC-OBJECT)
          (arg OBJECT) (module MODULE) (environment ENVIRONMENT)) :
          PROPOSITION
     Retract that the proposition (RELATION ARG) is TRUE in MODULE.
     Return the asserted proposition.

 - Function: retrieve ((query CONS) (module MODULE)
          (environment ENVIRONMENT)) : PL-ITERATOR
     Returns an iterator of variable bindings that when substituted for
     the open variables in QUERY satisfy the query proposition.  The
     query is run in MODULE and relative to ENVIRONMENT.  QUERY has the
     same syntax as the PowerLoom `retrieve' command (which see) but
     with the `retrieve' operator omitted.    For example, here are
     some legal QUERY arguments:

              ((happy ?x))
              (10 (happy ?x))
              (all (happy ?x))
              (all ?x (happy ?x))
              (10 (happy ?x) :inference-level :assertion)
              (10 (happy ?x) :inference-level :assertion :timeout 1.0)

     If there is only a single output variable (as in all the examples
     above) each element generated by the returned iterator will be a
     binding for that variable - unless, the output variable was
     declared with a surrounding pair of parentheses.  For example:

              (all (?x) (happy ?x))

     In that case, the generated elements will be one-element lists.
     If there are multiple output variables, each element generated by
     the returned iterator will be a list of variable bindings that can
     be accessed using the various `get-nth-...' functions.  The list
     of output variables does not need to be declared in which case
     they are taken to be the open variables in the query proposition
     in the order in which they were encountered.  If order does matter
     or should be different from its default, it can be forced by
     declaring the set of output variables.

 - Function: run-forward-rules ((module OBJECT) (force? BOOLEAN)) :
     Run forward inference rules in module MODULE.  If MODULE is NULL,
     the current module will be used.  If forward inferencing is
     already up-to-date in the designated module, no additional
     inferencing will occur, unless `force' is set to TRUE, in which
     case all forward rules are run or rerun.

     Calling `run-forward-rules' temporarily puts the module into a
     mode where future assertional (monotonic) updates will trigger
     additional forward inference.  Once a non-monotonic update is
     performed, i.e., a retraction or clipping of relation value, all
     cached forward inferences will be discarded and forward
     inferencing will be disabled until this function is called again.

 - Function: s-ask ((query STRING) (module-name STRING)
          (environment ENVIRONMENT)) : TRUTH-VALUE
     Returns a truth value for QUERY in module MODULE-NAME and
     ENVIRONMENT.  QUERY has the same syntax as the PowerLoom `ask'
     command (which see) but with the `ask' operator omitted.
     Different from the PLI `ask' function, `s-ask' does not expect a
     top-level pair of parentheses.  For example, here are some legal
     QUERY arguments:

              "(happy Fred)"
              "(happy Fred) :inference-level :assertion"
              "(happy Fred) :inference-level :assertion :timeout 1.0"

     Names in QUERY will be interpreted relative to module MODULE-NAME.
     A null MODULE-NAME or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a STELLA `no-such-context-exception' is thrown.  The returned
     truth value represents the logical truth of the queried sentence
     as determined by PowerLoom.  It can be be tested via the functions
     `is-true', `is-false' and `is-unknown' (which see).

 - Function: s-assert-proposition ((sentence STRING)
          (module-name STRING) (environment ENVIRONMENT)) :
          (PL-ITERATOR OF PROPOSITION)
     Assert that the logical sentence SENTENCE is true in the module
     named MODULE-NAME.  A module name of `null' or the empty string
     refers to the current module.  If no module can be found with the
     name MODULE-NAME, then a Stella `no-such-context-exception' is
     thrown.

     Return an iterator of the propositions resulting from sentence.

 - Function: s-change-module ((name STRING) (environment ENVIRONMENT))
          : MODULE
     Set the current module to the module named NAME.  The return value
     is the module named NAME unless NAME is null or the empty string.
     In that case, the current module is returned.  If no module named
     NAME exists, a Stella `no-such-context-exception' is thrown.

 - Function: s-clear-module ((name STRING) (environment ENVIRONMENT)) :
          MODULE
     Destroy the contents of the module named NAME, as well as the
     contents of all of its children, recursively.  If no module named
     NAME exists, a Stella `no-such-context-exception' is thrown.

 - Function: s-conceive ((sentence STRING) (module-name STRING)
          (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)
     Create one or more proposition objects from the sentence SENTENCE
     in the  module named MODULE-NAME.  Return an iterator of the
     propositions.  If any of the new propositions has the same
     structure as an already existing proposition, an automatic check
     for duplicates will return the pre-existing proposition.  Multiple
     propositions may be returned for a single sentence because of
     normalization of equivalences, conjunctions, etc.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `No-Such-Context-Exception' is thrown.

     Signals a `Proposition-Error' if PowerLoom could not conceive
     SENTENCE.

 - Function: s-create-concept ((name STRING) (parent-name STRING)
          (module-name STRING) (environment ENVIRONMENT)) : LOGIC-OBJECT
     Create a concept named NAME in the designated module, with with
     the concept named PARENT-NAME as superconcept (which can be left
     undefined).  Additional superconcepts can be added via assertions
     of the `subset-of' relation.  Note that a specified parent concept
     needs to be created separately.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

     Note that because names in modules that are not case-sensitive are
     canonicalized, the name of the returned object may not match NAME
     exactly.

 - Function: s-create-function ((name STRING) (arity INTEGER)
          (module-name STRING) (environment ENVIRONMENT)) : LOGIC-OBJECT
     Create a function named NAME with arity ARITY in the designated
     module.  Domain and range information can be added via assertions
     of `domain', `nth-domain' and `range' relations.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

     Note that because names in modules that are not case-sensitive are
     canonicalized, the name of the returned object may not match NAME
     exactly.

 - Function: s-create-object ((name STRING) (concept-name STRING)
          (module-name STRING) (environment ENVIRONMENT)) : LOGIC-OBJECT
     Create an object named NAME of type CONCEPT-NAME in the designated
     module.  Both NAME and CONCEPT-NAME can be null strings.  If NAME
     is a null string then an object will be created with a new,
     non-conflicting name based on CONCEPT-NAME, or system-generated if
     no concept nameis specified.  If CONCEPT-NAME is the null string,
     then the object will be of type THING.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

     Note that because names in modules that are not case-sensitive are
     canonicalized, the name of the returned object may not match NAME
     exactly.

     Return the object.

 - Function: s-create-module ((name STRING) (parent-name STRING)
          (case-sensitive? BOOLEAN) (environment ENVIRONMENT)) : MODULE
     Creates a new module NAME as a child of PARENT-NAME.  The flag
     CASE-SENSITIVE? controls whether names read in this module will be
     case sensitive or not.

 - Function: s-create-relation ((name STRING) (arity INTEGER)
          (module-name STRING) (environment ENVIRONMENT)) : LOGIC-OBJECT
     Create a relation named NAME with arity ARITY in the designated
     module.  Domain and range information can be added via assertions
     of `nth-domain' (or `domain' and `range') relations.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

     Note that because names in modules that are not case-sensitive are
     canonicalized, the name of the returned object may not match NAME
     exactly.

 - Function: s-destroy-object ((object-name STRING)
          (module-name STRING) (environment ENVIRONMENT)) :
     Delete the object named OBJECT-NAME, retracting all facts attached
     to it.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 - Function: s-evaluate ((command STRING) (module-name STRING)
          (environment ENVIRONMENT)) : OBJECT
     Evaluate the command represented by the string COMMAND within
     `module' and return the result.  Currently, only the evaluation of
     (possibly nested) commands and global variables is supported.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 - Function: s-get-arity ((relation-name STRING) (module-name STRING)
          (environment ENVIRONMENT)) : INTEGER
     Return the arity of the relation named RELATION-NAME.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 - Function: s-get-child-modules ((name STRING)
          (environment ENVIRONMENT)) : (PL-ITERATOR OF MODULE)
     Return the modules that are immediate children of module NAME.  If
     no module named NAME exists, a Stella `no-such-context-exception'
     is thrown.

 - Function: s-get-concept ((name STRING) (module-name STRING)
          (environment ENVIRONMENT)) : LOGIC-OBJECT
     Return a class/concept named NAME that is local to or visible from
     the module MODULE-NAME.  A module name of `null' or the empty
     string refers to the current module.  If no module can be found
     with the name MODULE-NAME, then a Stella
     `no-such-context-exception' is thrown.

 - Function: s-get-concept-instances ((concept-name STRING)
          (module-name STRING) (environment ENVIRONMENT)) : PL-ITERATOR
     Return instances of concept CONCEPT-NAME.  Include instances of
     subconcepts of CONCEPT-NAME.  Depending on CONCEPT-NAME, the
     return values could be (wrapped) literals.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 - Function: s-get-direct-concept-instances ((concept-name STRING)
          (module-name STRING) (environment ENVIRONMENT)) : PL-ITERATOR
     Return instances of concept CONCEPT-NAME.  Exclude instances of
     subconcepts of CONCEPT-NAME.  Depending on CONCEPT-NAME, the
     return values could be (wrapped) literals.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 - Function: s-get-domain ((relation-name STRING) (module-name STRING)
          (environment ENVIRONMENT)) : LOGIC-OBJECT
     Return the type (concept) for the first argument to the binary
     relation RELATION-NAME.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 - Function: s-get-inferred-binary-proposition-values
          ((relation-name STRING) (arg-name STRING)
          (module-name STRING) (environment ENVIRONMENT)) : PL-ITERATOR
     Return all values `v' such that (RELATION-NAME ARG-NAME `v') has
     been asserted or can be inferred.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 - Function: s-get-nth-domain ((relation-name STRING) (n INTEGER)
          (module-name STRING) (environment ENVIRONMENT)) : LOGIC-OBJECT
     Return the type (a concept) for the nth argument of the relation
     named RELATION-NAME.  Counting starts at zero.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 - Function: s-get-object ((name STRING) (module-name STRING)
          (environment ENVIRONMENT)) : OBJECT
     Look for an object named NAME that is local to or visible from the
     module MODULE-NAME.  A module name of `null' or the empty string
     refers to the current module.  If no module can be found with the
     name MODULE-NAME, then a Stella `no-such-context-exception' is
     thrown.

 - Function: s-get-parent-modules ((name STRING)
          (environment ENVIRONMENT)) : (PL-ITERATOR OF MODULE)
     Return the modules that are immediate parents of module NAME.  If
     no module named NAME exists, a Stella `no-such-context-exception'
     is thrown.

 - Function: s-get-parent-modules ((name STRING)
          (environment ENVIRONMENT)) : (PL-ITERATOR OF MODULE)
     Return the modules that are immediate parents of module NAME.  If
     no module named NAME exists, a Stella `no-such-context-exception'
     is thrown.

 - Function: s-get-proposition ((relation-and-arguments STRING)
          (module-name STRING) (environment ENVIRONMENT)) : PROPOSITION
     Return a proposition matching RELATION-AND-ARGUMENTS that has been
     asserted (or inferred by forward chaining).  RELATION-AND-ARGUMENTS
     is a string that begins with a left parenthesis, followed by a
     relation name, one or more argument identifiers, and terminated by
     a right parenthesis.  Each argument identifier can be the name of
     a logical constant, a literal reference (e.g., a number), the null
     identifier, or a variable (an identifier that begins with a
     question mark). Each occurrence of a null or a variable acts like
     a wild card.  If more than one proposition matches the input
     criteria, the selection among satisficing propositions is
     arbitrary.  This procedure is normally applied to single-valued
     relations or functions.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 - Function: s-get-propositions ((relation-and-arguments STRING)
          (module-name STRING) (environment ENVIRONMENT)) :
          (PL-ITERATOR OF PROPOSITION)
     Return propositions matching RELATION-AND-ARGUMENTS that have been
     asserted (or inferred by forward chaining).  RELATION-AND-ARGUMENTS
     is a string that begins with a left parenthesis, followed by a
     relation name, one or more argument identifiers, and terminated by
     a right parenthesis.  Each argument identifier can be the name of
     a logical constant, a literal reference (e.g., a number), the null
     identifier, or a variable (an identifier that begins with a
     question mark). Each occurrence of a null or a variable acts like
     a wild card.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 - Function: s-get-propositions-of ((object-name STRING)
          (module-name STRING) (environment ENVIRONMENT)) :
          (PL-ITERATOR OF PROPOSITION)
     Return all propositions that have the object named OBJECT-NAME
     among their arguments, and that are TRUE in the scope of the
     module MODULE-NAME.  A module name of `null' or the empty string
     refers to the current module.  If no module can be found with the
     name MODULE-NAME, then a Stella `no-such-context-exception' is
     thrown.

 - Function: s-get-range ((relation-name STRING) (module-name STRING)
          (environment ENVIRONMENT)) : LOGIC-OBJECT
     Return the type (a concept) for fillers of the binary relation
     RELATION-NAME.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 - Function: s-get-relation ((name STRING) (module-name STRING)
          (environment ENVIRONMENT)) : LOGIC-OBJECT
     Return a concept or relation named NAME that is local to or
     visible from the module MODULE-NAME.  A module name of `null' or
     the empty string refers to the current module.  If no module can
     be found with the name MODULE-NAME, then a Stella
     `no-such-context-exception' is thrown.

 - Function: s-get-relation-extension ((relation-name STRING)
          (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF
          PROPOSITION)
     Return propositions that satisfy the relation named RELATION-NAME.
     Include propositions that satisfy subrelations of the relation.

 - Function: s-get-rules ((relation-name STRING) (module-name STRING)
          (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)
     Return rules attached to the concept/relation named RELATION-NAME
     found in the module named MODULE-NAME.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `No-Such-Context-Exception' is thrown.

 - Function: s-is-true-proposition ((relation-and-arguments STRING)
          (module-name STRING) (environment ENVIRONMENT)) : BOOLEAN
     Return TRUE if a proposition that prints as the string
     RELATION-AND-ARGUMENTS is true in the module named MODULE-NAME.  A
     module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 - Function: s-print-rules ((name STRING) (stream OUTPUT-STREAM)
          (module-name STRING) (environment ENVIRONMENT)) :
     Print rules attached to the concept/relation named NAME.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 - Function: s-retract-proposition ((sentence STRING)
          (module-name STRING) (environment ENVIRONMENT)) :
          (PL-ITERATOR OF PROPOSITION)
     Retract the truth of the logical sentence SENTENCE in the module
     named MODULE-NAME.  A module name of `null' or the empty string
     refers to the current module.  If no module can be found with the
     name MODULE-NAME, then a Stella `no-such-context-exception' is
     thrown.

     Return an iterator of the retracted propositions resulting from
     sentence.

 - Function: s-retrieve ((query STRING) (module-name STRING)
          (environment ENVIRONMENT)) : PL-ITERATOR
     Returns an iterator of variable bindings that when substituted for
     the open variables in QUERY satisfy the query proposition.  The
     query is run in `module' and relative to ENVIRONMENT.  QUERY has
     the same syntax as the PowerLoom `retrieve' command (which see)
     but with the `retrieve' operator omitted.  Different from the PLI
     `retrieve' function, `s-retrieve' does not expect a top-level pair
     of parentheses.  For example, here are some legal QUERY arguments:

              "(happy ?x)"
              "10 (happy ?x)"
              "all (happy ?x)"
              "all ?x (happy ?x)"
              "10 (happy ?x) :inference-level :assertion"
              "10 (happy ?x) :inference-level :assertion :timeout 1.0"

     If there is only a single output variable (as in all the examples
     above) each element generated by the returned iterator will be a
     binding for that variable - unless, the output variable was
     declared with a surrounding pair of parentheses.  For example:

              "all (?x) (happy ?x)"

     In that case, the generated elements will be one-element lists.
     If there are multiple output variables, each element generated by
     the returned iterator will be a list of variable bindings that can
     be accessed using the various `get-nth-...' functions.  The list
     of output variables does not need to be declared in which case
     they are taken to be the open variables in the query proposition
     in the order in which they were encountered.  If order does matter
     or should be different from its default, it can be forced by
     declaring the set of output variables.

     Names in QUERY will be interpreted relative to module MODULE-NAME.
     A null MODULE-NAME or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a STELLA `no-such-context-exception' is thrown.

 - Function: s-save-module ((module-name STRING) (filename STRING)
          (ifexists STRING) (environment ENVIRONMENT)) :
     Save the contents of the module MODULE-NAME into a file named
     FILENAME.  If a file named FILENAME already exists, then the
     action taken depends on the value of IFEXISTS.  Possible values
     are "ASK", "REPLACE", "WARN" and "ERROR":

     REPLACE => Means overwrite without warning.    WARN    => Means
     overwrite with a warning.    ERROR   => Means don't overwrite,
     signal an error instead.    ASK     => Ask the user whether to
     overwrite or not.  If not overwritten, an              exception
     is thrown.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 - Function: save-module ((module MODULE) (filename STRING)
          (ifexists STRING) (environment ENVIRONMENT)) :
     Save the contents of the module `mod' into a file named FILENAME.
     If a file named FILENAME already exists, then the action taken
     depends on the value of IFEXISTS.  Possible values are "ASK",
     "REPLACE", "WARN" and "ERROR":

     REPLACE => Means overwrite without warning.    WARN    => Means
     overwrite with a warning.    ERROR   => Means don't overwrite,
     signal an error instead.    ASK     => Ask the user whether to
     overwrite or not.  If not overwritten, an              exception
     is thrown.

 - Function: string-to-object ((string STRING) (type LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : OBJECT
     Evaluate STRING with respect to MODULE and ENVIRONMENT and return
     the corresponding logical term.  TYPE is a concept used to assist
     the correct interpretation of STRING.

     Currently TYPE only has an effect on the interpretation of literal
     types.

