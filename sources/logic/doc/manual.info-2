This is manual.info, produced by makeinfo version 4.2 from manual.texi.

   This file documents the knowledge representation and reasoning
system.


File: manual.info,  Node: Clipping of Values,  Next: Rule-based Inference,  Prev: Retraction,  Up: Annotated Example

Clipping of Values
==================

   Programmers are accustomed to changing the values of attributes for
program objects just by overwriting previous values.  PowerLoom
implements a similar semantics for the special case of functions and
single-valued relations.  When a second value is asserted for one of
these relations the previous value is automatically retracted.  We call
this _clipping_.

   To illustrate this behavior for both kinds of relations (a function
is considered a kind of relation), we will define a mapping from a
company to a city that contains its headquarters in two different ways:

     (deffunction headquarters ((?c company)) :-> (?city city))
     (defrelation headquartered-in ((?c company) (?city city))
       :axioms (single-valued headquartered-in))

   The clause "`:axioms (single-valued headquartered-in)'" tells
PowerLoom that the `headquartered-in' relation is single-valued, i.e.,
that it can map a company to at most one city.  This makes its behavior
similar to that of the function `headquarters'.  Here is an example of
clipping for the function `headquarters':

     (assert (= (headquarters zz-productions) atlanta))
     (retrieve all ?x (= ?x (headquarters zz-productions)))
     =>
     There is 1 solution:
       #1: ?X=ATLANTA
     
     (assert (= (headquarters zz-productions) dallas))
     (retrieve all ?x (= ?x (headquarters zz-productions)))
     =>
     There is 1 solution:
       #1: ?X=DALLAS

   Here is the same kind of clipping using a single-valued relation:

     (assert (headquartered-in megasoft atlanta))
     (retrieve all ?x (headquartered-in megasoft ?x))
     =>
     There is 1 solution:
       #1: ?X=ATLANTA
     
     (assert (headquartered-in megasoft dallas))
     (retrieve all ?x (headquartered-in megasoft ?x))
     =>
     There is 1 solution:
       #1: ?X=DALLAS


File: manual.info,  Node: Rule-based Inference,  Next: Explanation,  Prev: Clipping of Values,  Up: Annotated Example

Rule-based Inference
====================

   Suppose that we want to retrieve all geographic locations that are
contained in the Southern US, based on the set of assertions about
geography that we entered in earlier. The following query returns only
one of such location:

     (retrieve all ?x (contains southern-us ?x))
     =>
     There is 1 solution:
       #1: ?X=TEXAS

   We would like the cities Austin and Dallas to be retrieved as well.
To do this, we can assert a `rule' that states that `contains' is a
transitive relation:

     (defrule transitive-contains
       (<= (contains ?l1 ?l3)
           (and (contains ?l1 ?l2)
                (contains ?l2 ?l3))))

   The `defrule' declaration does two things--it asserts a proposition,
and it associates a name with that proposition (in the above case, the
name is `transitive-contains'). This name is used by the system in
displaying traces of its inferencing. It also makes redefinition of the
proposition easier. If we wish to retract an unnamed proposition, it is
necessary to explicitly retract that proposition using a syntax
identical to the assertion(1) If on the other hand, a proposition has a
name, then a new `defrule' declaration that uses the same name will
automatically retract any existing proposition having the same name.

   Our transitive closure rule failed to include any logical quantifiers
for the variables `?l1', `?l2', and `?l3'.  When PowerLoom parses a
top-level proposition, it automatically supplies universal quantifiers
for any unquantified variables.  So, the above rule is equivalent to
the rule:

     (defrule transitive-contains
       (forall (?l1 ?l2 ?l3)
               (<= (contains ?l1 ?l3)
                   (and (contains ?l1 ?l2)
                        (contains ?l2 ?l3)))))

Note: Instead of defining a `transitive-contains' rule, we could have
achieved the same effect by asserting that the `contains' relation is
transitive, e.g., by stating `(assert (transitive contains))'.

   Now that we have told the system that our `contains' relation is
transitive, let us rerun our query:

     (retrieve all ?x (contains southern-us ?x))
     =>
     There are 3 solutions:
       #1: ?X=TEXAS
       #2: ?X=AUSTIN
       #3: ?X=DALLAS

   ---------- Footnotes ----------

   (1) Actually, PowerLoom isn't quite as strict as just stated-its
search for an identical proposition can accomodate changes in the names
of variables.


File: manual.info,  Node: Explanation,  Next: Contexts and Modules,  Prev: Rule-based Inference,  Up: Annotated Example

Explanation
===========

   PowerLoom provides a command called `why' that you can use to get an
explanation of the logic behind one of its answers.  The `why' command
explains the last query entered into the system, i.e., it should
invoked after one has submitted a `retrieve' or an `ask' command.
Before asking a `why' command, you must enable the justifications
feature:

     (set-feature justifications)

   Queries execute a bit more slowly with jusifications enabled, which
is why it is disabled by default. Having enabled justifications, we
must (re)run a query.  Here is how we can ask why Dallas is contained
in the Southern US:

     (ask (contains southern-us dallas))
     =>
     TRUE
     (why)
     =>
     1 (CONTAINS SOUTHERN-US DALLAS)
         follows by Modus Ponens
         and substitution {?l3/DALLAS, ?l2/TEXAS, ?l1/SOUTHERN-US}
         since 1.1 ! (forall (?l1 ?l3)
                        (<= (CONTAINS ?l1 ?l3)
                            (exists (?l2)
                               (and (CONTAINS ?l1 ?l2)
                                    (CONTAINS ?l2 ?l3)))))
         and   1.2 ! (CONTAINS SOUTHERN-US TEXAS)
         and   1.3 ! (CONTAINS TEXAS DALLAS)

   The above explanation tells us that a rule (our transitivity rule)
was invoked during the proof, and that two ground assertions `(CONTAINS
SOUTHERN-US TEXAS)' and `(CONTAINS TEXAS DALLAS)' were accessed to
supply preconditions for the rule.  These combined assertions lead to
the conclusion `(CONTAINS SOUTHERN-US DALLAS)'.  Within an explanation,
directly asserted propositions are indicated with the prefix `!'.

   We can also ask `why' after a `retrieve' query. However, if the
query has multiple solutions, each one has a separate explanation. In
order to ask `why', we need to ask for one solution at a time. This can
be done by omitting the word `all' from the `retrieve' query, and
subsequently calling `(retrieve)' to obtain results one-at-a-time.  (1)

     (retrieve ?x (contains southern-us ?x))
     =>
       #1: ?X=DALLAS
     (retrieve)
     =>
     There are 2 solutions so far:
       #1: ?X=DALLAS
       #2: ?X=TEXAS
     (retrieve)
     =>
     There are 3 solutions so far:
       #1: ?X=DALLAS
       #2: ?X=TEXAS
       #3: ?X=AUSTIN
     (why)
     =>
     1 (CONTAINS SOUTHERN-US AUSTIN)
         follows by Modus Ponens
         with substitution {?l1/SOUTHERN-US, ?l3/AUSTIN, ?l2/TEXAS}
         since 1.1 ! (FORALL (?l1 ?l3)
                        (<= (CONTAINS ?l1 ?l3)
                            (EXISTS (?l2)
                               (AND (CONTAINS ?l1 ?l2)
                                    (CONTAINS ?l2 ?l3)))))
         and   1.2 ! (CONTAINS SOUTHERN-US TEXAS)
         and   1.3 ! (CONTAINS TEXAS AUSTIN)

   The following query combines a variety of relations that have been
entered into the business modules.  It retrieves names of companies
whose headquarters are in the southern US.  Note that query variables
that do not appear in the output (i.e., variables not listed after the
`all'

     (retrieve ?name (exists (?city ?company)
                                 (and (contains southern-us ?city)
                                      (headquartered-in ?company ?city)
                                      (company-name ?company ?name))))
     =>
     There is 1 solution so far:
       #1: ?NAME="MegaSoft, Inc."
     
     (why)
     =>
     1 (and (COMPANY-NAME MEGASOFT MegaSoft, Inc.)
            (HEADQUARTERED-IN MEGASOFT DALLAS)
            (CONTAINS SOUTHERN-US DALLAS))
         follows by And-Introduction
         since 1.1 ! (COMPANY-NAME MEGASOFT MegaSoft, Inc.)
         and   1.2 ! (HEADQUARTERED-IN MEGASOFT DALLAS)
         and   1.3   (CONTAINS SOUTHERN-US DALLAS)
     
     1.3 (CONTAINS SOUTHERN-US DALLAS)
         follows by Modus Ponens
         and substitution {?l3/DALLAS, ?l2/TEXAS, ?l1/SOUTHERN-US}
         since 1.3.1 ! (forall (?l1 ?l3)
                          (<= (CONTAINS ?l1 ?l3)
                              (exists (?l2)
                                 (and (CONTAINS ?l1 ?l2)
                                      (CONTAINS ?l2 ?l3)))))
         and   1.3.2 ! (CONTAINS SOUTHERN-US TEXAS)
         and   1.3.3 ! (CONTAINS TEXAS DALLAS)

   ---------- Footnotes ----------

   (1) Note: The order of solutions will not necessarily be the same as
shown here.


File: manual.info,  Node: Contexts and Modules,  Next: Classification,  Prev: Explanation,  Up: Annotated Example

Contexts and Modules
====================

   The final feature that we will illustrate in this section is the
PowerLoom context mechanism.  PowerLoom organizes its knowledge into a
hierarchy of logical containers called "contexts".  A PowerLoom context
is either a "module", a somewhat heavyweight object that includes its
own symbol table, or a "world", a very lightweight object designed for
fast switching from one world to another.  All contexts inherit from a
single root context.  The most important feature of a context is that a
fact asserted into it is inherited by all contexts below it.  However,
a "parent" context is unaware of any knowledge entered into one of its
descendants.

   Here we concern ourselves only with modules.  We first define a
second module, called `alternate-business', to be a subcontext of our
`business' module, and then we switch into the new module:

     (defmodule "alternate-business"
       :includes ("business"))
     (in-module "alternate-business")

   Next, within the scope of the `alternate-business' module, we will
create a new company.  And just for good measure, we will change the
name of MegaSoft while we are at it:

     (assert (and (Company web-phantoms)
                  (company-name web-phantoms "Web Phantoms, Inc.")))
     (retract (company-name megasoft "MegaSoft, Inc."))
     (assert (company-name megasoft "MegaZorch, Inc."))

   First, here are pairs of companies and company names from the vantage
point of the `Business' module:

     (in-module "business")
     (retrieve all (?x ?y) (company-name ?x ?y))
     =>
     There are 3 solutions:
       #1: ?X=ACME-CLEANERS, ?Y="ACME Cleaners, LTD"
       #2: ?X=MEGASOFT, ?Y="MegaSoft, Inc."
       #3: ?X=MEGASOFT, ?Y="MegaSoft"

   Now observe the same query executed from within the alternate
`Business' module:

     (in-module "alternate-business")
     (retrieve all (?x ?y) (company-name ?x ?y))
     =>
     There are 4 solutions:
       #1: ?X=ACME-CLEANERS, ?Y="ACME Cleaners, LTD"
       #2: ?X=MEGASOFT, ?Y="MegaZorch, Inc."
       #3: ?X=WEB-PHANTOMS, ?Y="Web Phantoms, Inc."
       #4: ?X=MEGASOFT, ?Y="MegaSoft"

   We see that all facts pertaining to company names have inherited down
from the Business to the Alternate Business module, except for the name
for MegaSoft that we explicitly retracted.  Also, the new facts
asserted within the Alternate Business module appear mixed in with the
inherited facts.


File: manual.info,  Node: Classification,  Next: Truth Maintenance,  Prev: Contexts and Modules,  Up: Annotated Example

Classification, Subsumption
===========================


File: manual.info,  Node: Truth Maintenance,  Next: Inference Control,  Prev: Classification,  Up: Annotated Example

Truth Maintenance
=================


File: manual.info,  Node: Inference Control,  Next: Keyword Axioms,  Prev: Truth Maintenance,  Up: Annotated Example

Inference Control
=================


File: manual.info,  Node: Keyword Axioms,  Next: Cardinality/Type Reasoning with Frame Predicates,  Prev: Inference Control,  Up: Annotated Example

Keyword Axioms
==============


File: manual.info,  Node: Cardinality/Type Reasoning with Frame Predicates,  Next: Loom-to-PowerLoom,  Prev: Keyword Axioms,  Up: Annotated Example

Cardinality/Type Reasoning with Frame Predicates
================================================


File: manual.info,  Node: Loom-to-PowerLoom,  Next: Deviations from KIF,  Prev: Cardinality/Type Reasoning with Frame Predicates,  Up: Annotated Example

Loom-to-PowerLoom
=================


File: manual.info,  Node: Deviations from KIF,  Next: Differences from Loom,  Prev: Loom-to-PowerLoom,  Up: Annotated Example

Deviations from KIF
===================


File: manual.info,  Node: Differences from Loom,  Next: Defaults,  Prev: Deviations from KIF,  Up: Annotated Example

Differences from Loom
=====================


File: manual.info,  Node: Defaults,  Next: Sets,  Prev: Differences from Loom,  Up: Annotated Example

Defaults
========


File: manual.info,  Node: Sets,  Prev: Defaults,  Up: Annotated Example

Sets, Lists, SETOFALL, KAPPA
============================


File: manual.info,  Node: Communicating with PowerLoom,  Next: Commands,  Prev: Annotated Example,  Up: Top

Communicating with PowerLoom
****************************

   There are basically three modes that users can choose from for
interacting with the PowerLoom system.  The simplest is to use the
PowerLoom command interpreter.  The interpreter supports a type-in
window that allows line-at-a-time entry of commands.  You can use the
interpreter to load files of PowerLoom declarations, to create and edit
knowledge base objects, to ask queries, and to modify settings in the
execution environment.

   The second mode of interaction involves writing an application that
makes calls to the PowerLoom API (*note PowerLoom API::). PowerLoom
implements an extensive list of procedures that can be called to
control the logic system. These procedures range from very specific
procedures to assert or query a single fact, to general procedures that
interpret arbitrary queries. The STELLA translator offers users a
choice of Common Lisp, Java, or C++ -based versions of the PowerLoom
system; users can choose whichever is the best match for their language
of choice for their applications.

   Finally, the Ontosaurus Web Browser offers an ideal way to view the
contents of PowerLoom knowledge bases.  The Ontosaurus Web server
allows one to surf across a knowledge base, offering several different
kinds of views of the knowledge.

* Menu:

* Command Interpreter ::
* Persistent Knowledge Bases::


File: manual.info,  Node: Command Interpreter,  Next: Persistent Knowledge Bases,  Prev: Communicating with PowerLoom,  Up: Communicating with PowerLoom

Command Interpreter
===================

   Currently, the primary means for interacting with PowerLoom is its
command interpreter.  The command interpreter can be used either
interactively, or it can be invoked directly from a program to evaluate
individual commands.  All PowerLoom commands (*note Commands::) can be
evaluated using the command interpreter.

   The interactive command interpreter is invoked by calling the
function `powerloom' without any arguments.  In the Java versions of
PowerLoom, the interpreter in called by the `main' routine in the class
`PowerLoom' within the `logic' package.  In the C++ versions of
PowerLoom, `powerloom' is also called within the `main' routine.  In
the Lisp version, `(STELLA::powerloom)' has to be called explicitly.
However, in Lisp it is not really necessary to use the command
interpreter, since all commands can also be executed directly at the
Lisp top level(1).

   The interactive command interpreter functions as a simple
read/eval/print loop that prompts for input with a `|=' prompt, reads a
user command from standard input, evaluates it, and prints the result
to standard output.  To exit the command interpreter, type `quit' or
`stop'.

   To evaluate commands directly from a program, the PowerLoom API
provides the following evaluator functions:

 - Function: evaluate ((command OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : OBJECT
     Evaluate the command COMMAND within MODULE and return the result.
     Currently, only the evaluation of (possibly nested) commands and
     global variables is supported.  Commands are simple to program in
     Common Lisp, since they are built into the language, and
     relatively awkward in Java and C++.  Users of either of those
     languages are more likely to want to call `s-evaluate'.

 - Function: evaluate-string ((expression STRING)) : OBJECT
     Evaluate the expression represented by EXPRESSION and return the
     result.  This is equivalent to `(evaluate (unstringify
     expression))'.

   ---------- Footnotes ----------

   (1) If you are executing within a case sensitive module, then you
may see some differences in behavior between commands evaluated by the
command interpreter and commands invoked from the Lisp Listener.


File: manual.info,  Node: Persistent Knowledge Bases,  Prev: Command Interpreter,  Up: Communicating with PowerLoom

Persistent Knowledge Bases
==========================

   Serious users of PowerLoom will want to construct knowledge bases
that persist between sessions.  PowerLoom's primary medium of
persistence is file-based; users construct their knowledge bases by
entering PowerLoom statements into ASCII-formatted files, and then
using the `load' command to load them into PowerLoom.  There is also a
`save-module' command that saves the current assertions of a module to
a file.  Large-scale persistence via a backend database is currently
under development and will become available in one of the next releases.

