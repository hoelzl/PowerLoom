This is manual.info, produced by makeinfo version 4.2 from manual.texi.

   This file documents the knowledge representation and reasoning
system.


File: manual.info,  Node: Rule-based Inference,  Next: Explanation,  Prev: Clipping of Values,  Up: Annotated Example

Rule-based Inference
====================

   Suppose that we want to retrieve all geographic locations that are
contained in the Southern US, based on the set of assertions about
geography that we entered in earlier. The following query returns only
one of such location:

     (retrieve all ?x (contains southern-us ?x))
     =>
     There is 1 solution:
       #1: ?X=TEXAS

   We would like the cities Austin and Dallas to be retrieved as well.
To do this, we can assert a `rule' that states that `contains' is a
transitive relation:

     (defrule transitive-contains
       (<= (contains ?l1 ?l3)
           (and (contains ?l1 ?l2)
                (contains ?l2 ?l3))))

   The `defrule' declaration does two things--it asserts a proposition,
and it associates a name with that proposition (in the above case, the
name is `transitive-contains'). This name is used by the system in
displaying traces of its inferencing. It also makes redefinition of the
proposition easier. If we wish to retract an unnamed proposition, it is
necessary to explicitly retract that proposition using a syntax
identical to the assertion(1) If on the other hand, a proposition has a
name, then a new `defrule' declaration that uses the same name will
automatically retract any existing proposition having the same name.

   Our transitive closure rule failed to include any logical quantifiers
for the variables `?l1', `?l2', and `?l3'.  When PowerLoom parses a
top-level proposition, it automatically supplies universal quantifiers
for any unquantified variables.  So, the above rule is equivalent to
the rule:

     (defrule transitive-contains
       (forall (?l1 ?l2 ?l3)
               (<= (contains ?l1 ?l3)
                   (and (contains ?l1 ?l2)
                        (contains ?l2 ?l3)))))

Note: Instead of defining a `transitive-contains' rule, we could have
achieved the same effect by asserting that the `contains' relation is
transitive, e.g., by stating `(assert (transitive contains))'.

   Now that we have told the system that our `contains' relation is
transitive, let us rerun our query:

     (retrieve all ?x (contains southern-us ?x))
     =>
     There are 3 solutions:
       #1: ?X=TEXAS
       #2: ?X=AUSTIN
       #3: ?X=DALLAS

   ---------- Footnotes ----------

   (1) Actually, PowerLoom isn't quite as strict as just stated-its
search for an identical proposition can accomodate changes in the names
of variables.


File: manual.info,  Node: Explanation,  Next: Contexts and Modules,  Prev: Rule-based Inference,  Up: Annotated Example

Explanation
===========

   PowerLoom provides a command called `why' that you can use to get an
explanation of the logic behind one of its answers.  The `why' command
explains the last query entered into the system, i.e., it should
invoked after one has submitted a `retrieve' or an `ask' command.
Before asking a `why' command, you must enable the justifications
feature:

     (set-feature justifications)

   Queries execute a bit more slowly with jusifications enabled, which
is why it is disabled by default. Having enabled justifications, we
must (re)run a query.  Here is how we can ask why Dallas is contained
in the Southern US:

     (ask (contains southern-us dallas))
     =>
     TRUE
     (why)
     =>
     1 (CONTAINS SOUTHERN-US DALLAS)
         follows by Modus Ponens
         and substitution {?l3/DALLAS, ?l2/TEXAS, ?l1/SOUTHERN-US}
         since 1.1 ! (forall (?l1 ?l3)
                        (<= (CONTAINS ?l1 ?l3)
                            (exists (?l2)
                               (and (CONTAINS ?l1 ?l2)
                                    (CONTAINS ?l2 ?l3)))))
         and   1.2 ! (CONTAINS SOUTHERN-US TEXAS)
         and   1.3 ! (CONTAINS TEXAS DALLAS)

   The above explanation tells us that a rule (our transitivity rule)
was invoked during the proof, and that two ground assertions `(CONTAINS
SOUTHERN-US TEXAS)' and `(CONTAINS TEXAS DALLAS)' were accessed to
supply preconditions for the rule.  These combined assertions lead to
the conclusion `(CONTAINS SOUTHERN-US DALLAS)'.  Within an explanation,
directly asserted propositions are indicated with the prefix `!'.

   We can also ask `why' after a `retrieve' query. However, if the
query has multiple solutions, each one has a separate explanation. In
order to ask `why', we need to ask for one solution at a time. This can
be done by omitting the word `all' from the `retrieve' query, and
subsequently calling `(retrieve)' to obtain results one-at-a-time.  (1)

     (retrieve ?x (contains southern-us ?x))
     =>
       #1: ?X=DALLAS
     (retrieve)
     =>
     There are 2 solutions so far:
       #1: ?X=DALLAS
       #2: ?X=TEXAS
     (retrieve)
     =>
     There are 3 solutions so far:
       #1: ?X=DALLAS
       #2: ?X=TEXAS
       #3: ?X=AUSTIN
     (why)
     =>
     1 (CONTAINS SOUTHERN-US AUSTIN)
         follows by Modus Ponens
         with substitution {?l1/SOUTHERN-US, ?l3/AUSTIN, ?l2/TEXAS}
         since 1.1 ! (FORALL (?l1 ?l3)
                        (<= (CONTAINS ?l1 ?l3)
                            (EXISTS (?l2)
                               (AND (CONTAINS ?l1 ?l2)
                                    (CONTAINS ?l2 ?l3)))))
         and   1.2 ! (CONTAINS SOUTHERN-US TEXAS)
         and   1.3 ! (CONTAINS TEXAS AUSTIN)

   The following query combines a variety of relations that have been
entered into the business modules.  It retrieves names of companies
whose headquarters are in the southern US.  Note that query variables
that do not appear in the output (i.e., variables not listed after the
`all'

     (retrieve ?name (exists (?city ?company)
                                 (and (contains southern-us ?city)
                                      (headquartered-in ?company ?city)
                                      (company-name ?company ?name))))
     =>
     There is 1 solution so far:
       #1: ?NAME="MegaSoft, Inc."
     
     (why)
     =>
     1 (and (COMPANY-NAME MEGASOFT MegaSoft, Inc.)
            (HEADQUARTERED-IN MEGASOFT DALLAS)
            (CONTAINS SOUTHERN-US DALLAS))
         follows by And-Introduction
         since 1.1 ! (COMPANY-NAME MEGASOFT MegaSoft, Inc.)
         and   1.2 ! (HEADQUARTERED-IN MEGASOFT DALLAS)
         and   1.3   (CONTAINS SOUTHERN-US DALLAS)
     
     1.3 (CONTAINS SOUTHERN-US DALLAS)
         follows by Modus Ponens
         and substitution {?l3/DALLAS, ?l2/TEXAS, ?l1/SOUTHERN-US}
         since 1.3.1 ! (forall (?l1 ?l3)
                          (<= (CONTAINS ?l1 ?l3)
                              (exists (?l2)
                                 (and (CONTAINS ?l1 ?l2)
                                      (CONTAINS ?l2 ?l3)))))
         and   1.3.2 ! (CONTAINS SOUTHERN-US TEXAS)
         and   1.3.3 ! (CONTAINS TEXAS DALLAS)

   ---------- Footnotes ----------

   (1) Note: The order of solutions will not necessarily be the same as
shown here.


File: manual.info,  Node: Contexts and Modules,  Next: Classification,  Prev: Explanation,  Up: Annotated Example

Contexts and Modules
====================

   The final feature that we will illustrate in this section is the
PowerLoom context mechanism.  PowerLoom organizes its knowledge into a
hierarchy of logical containers called "contexts".  A PowerLoom context
is either a "module", a somewhat heavyweight object that includes its
own symbol table, or a "world", a very lightweight object designed for
fast switching from one world to another.  All contexts inherit from a
single root context.  The most important feature of a context is that a
fact asserted into it is inherited by all contexts below it.  However,
a "parent" context is unaware of any knowledge entered into one of its
descendants.

   Here we concern ourselves only with modules.  We first define a
second module, called `alternate-business', to be a subcontext of our
`business' module, and then we switch into the new module:

     (defmodule "alternate-business"
       :includes ("business"))
     (in-module "alternate-business")

   Next, within the scope of the `alternate-business' module, we will
create a new company.  And just for good measure, we will change the
name of MegaSoft while we are at it:

     (assert (and (Company web-phantoms)
                  (company-name web-phantoms "Web Phantoms, Inc.")))
     (retract (company-name megasoft "MegaSoft, Inc."))
     (assert (company-name megasoft "MegaZorch, Inc."))

   First, here are pairs of companies and company names from the vantage
point of the `Business' module:

     (in-module "business")
     (retrieve all (?x ?y) (company-name ?x ?y))
     =>
     There are 3 solutions:
       #1: ?X=ACME-CLEANERS, ?Y="ACME Cleaners, LTD"
       #2: ?X=MEGASOFT, ?Y="MegaSoft, Inc."
       #3: ?X=MEGASOFT, ?Y="MegaSoft"

   Now observe the same query executed from within the alternate
`Business' module:

     (in-module "alternate-business")
     (retrieve all (?x ?y) (company-name ?x ?y))
     =>
     There are 4 solutions:
       #1: ?X=ACME-CLEANERS, ?Y="ACME Cleaners, LTD"
       #2: ?X=MEGASOFT, ?Y="MegaZorch, Inc."
       #3: ?X=WEB-PHANTOMS, ?Y="Web Phantoms, Inc."
       #4: ?X=MEGASOFT, ?Y="MegaSoft"

   We see that all facts pertaining to company names have inherited down
from the Business to the Alternate Business module, except for the name
for MegaSoft that we explicitly retracted.  Also, the new facts
asserted within the Alternate Business module appear mixed in with the
inherited facts.


File: manual.info,  Node: Classification,  Next: Truth Maintenance,  Prev: Contexts and Modules,  Up: Annotated Example

Classification, Subsumption
===========================


File: manual.info,  Node: Truth Maintenance,  Next: Inference Control,  Prev: Classification,  Up: Annotated Example

Truth Maintenance
=================


File: manual.info,  Node: Inference Control,  Next: Keyword Axioms,  Prev: Truth Maintenance,  Up: Annotated Example

Inference Control
=================


File: manual.info,  Node: Keyword Axioms,  Next: Cardinality/Type Reasoning with Frame Predicates,  Prev: Inference Control,  Up: Annotated Example

Keyword Axioms
==============


File: manual.info,  Node: Cardinality/Type Reasoning with Frame Predicates,  Next: Loom-to-PowerLoom,  Prev: Keyword Axioms,  Up: Annotated Example

Cardinality/Type Reasoning with Frame Predicates
================================================


File: manual.info,  Node: Loom-to-PowerLoom,  Next: Deviations from KIF,  Prev: Cardinality/Type Reasoning with Frame Predicates,  Up: Annotated Example

Loom-to-PowerLoom
=================


File: manual.info,  Node: Deviations from KIF,  Next: Differences from Loom,  Prev: Loom-to-PowerLoom,  Up: Annotated Example

Deviations from KIF
===================


File: manual.info,  Node: Differences from Loom,  Next: Defaults,  Prev: Deviations from KIF,  Up: Annotated Example

Differences from Loom
=====================


File: manual.info,  Node: Defaults,  Next: Sets,  Prev: Differences from Loom,  Up: Annotated Example

Defaults
========


File: manual.info,  Node: Sets,  Prev: Defaults,  Up: Annotated Example

Sets, Lists, SETOFALL, KAPPA
============================


File: manual.info,  Node: Communicating with PowerLoom,  Next: Commands,  Prev: Annotated Example,  Up: Top

Communicating with PowerLoom
****************************

   There are basically three modes that users can choose from for
interacting with the PowerLoom system.  The simplest is to use the
PowerLoom command interpreter.  The interpreter supports a type-in
window that allows line-at-a-time entry of commands.  You can use the
interpreter to load files of PowerLoom declarations, to create and edit
knowledge base objects, to ask queries, and to modify settings in the
execution environment.

   The second mode of interaction involves writing an application that
makes calls to the PowerLoom API (*note PowerLoom API::). PowerLoom
implements an extensive list of procedures that can be called to
control the logic system. These procedures range from very specific
procedures to assert or query a single fact, to general procedures that
interpret arbitrary queries. The STELLA translator offers users a
choice of Common Lisp, Java, or C++ -based versions of the PowerLoom
system; users can choose whichever is the best match for their language
of choice for their applications.

   Finally, the Ontosaurus Web Browser offers an ideal way to view the
contents of PowerLoom knowledge bases.  The Ontosaurus Web server
allows one to surf across a knowledge base, offering several different
kinds of views of the knowledge.

* Menu:

* Command Interpreter ::
* Persistent Knowledge Bases::


File: manual.info,  Node: Command Interpreter,  Next: Persistent Knowledge Bases,  Prev: Communicating with PowerLoom,  Up: Communicating with PowerLoom

Command Interpreter
===================

   Currently, the primary means for interacting with PowerLoom is its
command interpreter.  The command interpreter can be used either
interactively, or it can be invoked directly from a program to evaluate
individual commands.  All PowerLoom commands (*note Commands::) can be
evaluated using the command interpreter.

   The interactive command interpreter is invoked by calling the
function `powerloom' without any arguments.  In the Java versions of
PowerLoom, the interpreter in called by the `main' routine in the class
`PowerLoom' within the `logic' package.  In the C++ versions of
PowerLoom, `powerloom' is also called within the `main' routine.  In
the Lisp version, `(STELLA::powerloom)' has to be called explicitly.
However, in Lisp it is not really necessary to use the command
interpreter, since all commands can also be executed directly at the
Lisp top level(1).

   The interactive command interpreter functions as a simple
read/eval/print loop that prompts for input with a `|=' prompt, reads a
user command from standard input, evaluates it, and prints the result
to standard output.  To exit the command interpreter, type `quit' or
`stop'.

   To evaluate commands directly from a program, the PowerLoom API
provides the following evaluator functions:

 - Function: evaluate ((command OBJECT) (module MODULE)
          (environment OBJECT)) : OBJECT
     Evaluate the command COMMAND within MODULE and return the result.
     Currently, only the evaluation of (possibly nested) commands and
     global variables is supported.  Commands are simple to program in
     Common Lisp, since they are built into the language, and
     relatively awkward in Java and C++.  Users of either of those
     languages are more likely to want to call `s-evaluate'.

 - Function: evaluate-string ((expression STRING)) : OBJECT
     Evaluate the expression represented by EXPRESSION and return the
     result.  This is equivalent to `(evaluate (unstringify
     expression))'.

   ---------- Footnotes ----------

   (1) If you are executing within a case sensitive module, then you
may see some differences in behavior between commands evaluated by the
command interpreter and commands invoked from the Lisp Listener.


File: manual.info,  Node: Persistent Knowledge Bases,  Prev: Command Interpreter,  Up: Communicating with PowerLoom

Persistent Knowledge Bases
==========================

   Serious users of PowerLoom will want to construct knowledge bases
that persist between sessions.  PowerLoom's primary medium of
persistence is file-based; users construct their knowledge bases by
entering PowerLoom statements into ASCII-formatted files, and then
using the `load' command to load them into PowerLoom.  There is also a
`save-module' command that saves the current assertions of a module to
a file.  Large-scale persistence via a backend database is currently
under development and will become available in one of the next releases.


File: manual.info,  Node: Commands,  Next: PowerLoom API,  Prev: Communicating with PowerLoom,  Up: Top

Commands
********

   This chapter lists all available PowerLoom commands alphabetically.
Each command is documented with its name, a (possibly empty) list of
parameters specified as `(<name> <type>)' pairs, its return type, and
its category ("Command").  Almost all of the commands implicitly quote
their arguments, meaning that when calling them, you don't need to add
any quotation yourself.  For example, the command `all-facts-of' is
defined as follows:

      - Command: all-facts-of ((instanceRef NAME)) : (CONS OF
               PROPOSITION)
          Return a cons list of all definite (TRUE or FALSE)
          propositions that reference the instance INSTANCEREF.

   The `all-facts-of' command has one parameter called INSTANCEREF of
type _NAME_, and returns a STELLA _LIST_ containing zero or more
objects of type _PROPOSITION_ as its result.  The type NAME subsumes the
types SYMBOL, SURROGATE, STRING, and KEYWORD.  Unless you are in a
case-sensitive module, the following four commands are equivalent:

         (all-facts-of Merryweather)
         (all-facts-of :MERRYWEATHER)
         (all-facts-of "merryweather")
         (all-facts-of @MerryWeather)

   Commands can also have `&rest' parameters (similar to Lisp
functions).  These are either used to allow a variable number of
arguments, or to handle optional arguments, since STELLA does not
directly support optional arguments.

   Here is a list of important parameter types used in the command
specifications below:

   * _GENERALIZED-SYMBOL_: A generalized symbol is either a plain
     symbol (similar to a Lisp symbol) such as `Merryweather', a keyword
     (similar to a Lisp keyword) such as `:KIF', or a STELLA surrogate
     which is a symbol starting with an at-sign, e.g., `@CONS'.  STELLA
     surrogates are used as names for objects of arbitrary types.

   * _NAME_: Names can be either a string, or a _GENERALIZED-SYMBOL_
     (i.e., a symbol, a keyword, or a surrogate).  If a symbol is
     supplied, only its symbol-name is used.  Commands that take names
     as arguments usually coerce whatever argument is entered into a
     string, but by allowing a NAME they make it a little bit more
     convenient to type a name in an interactive invocation.(1)

   * _PARSE-TREE_: A parse tree is similar to a Lisp s-expression,
     i.e., it can either be an atom such as a symbol, number, or a
     string, or a list of zero or more parse trees.  For example, the
     expression `(happy Fred)' is a parse tree, and so are its
     components `happy' and `Fred'.

   Here is the list of all available PowerLoom commands:

 - Command: all-facts-of ((instanceRef NAME)) : (CONS OF PROPOSITION)
     Return a cons list of all definite (TRUE or FALSE) propositions
     that reference the instance INSTANCEREF.  This includes
     propositions asserted to be true by default, but it does not
     include propositions that are found to be TRUE only by running the
     query engine.  Facts inferred to be TRUE by the forward chainer
     will be included.  Hence, the returned list of facts may be longer
     in a context where the forward chainer has been run then in one
     where it has not (see `run-forward-rules').

 - Command: ask (&rest (proposition&options PARSE-TREE)) : TRUTH-VALUE
     Perform inference to determine whether the proposition specified in
     PROPOSITION&OPTIONS is true.  Return the truth-value found.  `ask'
     will spend most of its effort to determine whether the proposition
     is true and only a little effort via shallow inference strategies
     to determine whether it is false.  To find out whether a
     proposition is false with full inference effort `ask' its negation.

     KIF example: `(ask (happy Fred))' will return TRUE if Fred was
     indeed found to be happy.  Note, that for this query to run, the
     logic constant `Fred' and the relation `happy' must already be
     defined (see `assert').  Use `(set/unset-feature goal-trace)' to
     en/disable goal tracing of the inference engine.

     The `ask' command supports two options, declared with the keywords
     `:TIMEOUT' and `:DONT-OPTIMIZE'.  The argument to `:TIMEOUT' is an
     integer or floating point time limit, specified in seconds.  For
     example, the command `(ask (nervous Fred) :timeout 2.0)' will cease
     inference after two seconds if a proof has not been found by then.
     The argument to `:DONT-OPTIMIZE?' is the constant TRUE, which tells
     PowerLoom not to optimize the query before evaluating it.

 - Command: assert ((proposition PARSE-TREE)) : OBJECT
     Assert the truth of PROPOSITION.  Return the asserted proposition
     object.  KIF example:  "(assert (happy Fred))" asserts that Fred
     is indeed happy.  Note that for this assertion to succeed, the
     relation `happy' must already be defined.  If the constant `Fred'
     has not yet been created, it is automatically created as a
     side-effect of calling `assert'.

 - Command: assert-from-query ((query CONS) &rest (options OBJECT)) :
          (CONS OF PROPOSITION)
     Evaluate QUERY, instantiate the query proposition for each
     generated solution and assert the resulting propositions.  The
     accepted syntax is as follows:

           (assert-from-query <query-command>
                              [:relation <relation-name>]
                              [:pattern <description-term>]
                              [:module <module-name>])

     <query-command> has to be a strict or partial retrieval command.
     If a :relation option is supplied, <relation-name> is used as the
     relation of the resulting propositions.  In this case the bindings
     of each solution will become arguments to the specified relation
     in the order of QUERYs output variables (the arities have to
     match).  The :pattern option is a generalization of this mechanism
     that specifies an arbitrary proposition pattern to be instantiated
     by the query's solution.  In this case <description-term> has to
     be a SETOFALL or KAPPA expression whose IO-variables will be bound
     in sequence to the bindings of a query solution to generate the
     resulting proposition.  Finally, if a :module option is specified,
     the assertions will be generated in that module.  Note that for
     this to work the relations referenced in the query proposition or
     pattern have to be visible in the module.  Also, instances will
     not be copied to the target module, therefore, the resulting
     propositions might reference external out-of-module objects in
     case they are not visible there.  Here are some examples:

           (assert-from-query (retrieve all (foo ?x ?y)))
           (assert-from-query (retrieve all (?y ?x)
                                       (exists ?z (and (foo ?x ?z) (foo ?z ?y))))
                              :relation bar :module other)
           (assert-from-query
             (retrieve all (and (relation ?x) (symmetric ?x)))
             :pattern (kappa (?pred)
                        (forall (?x ?y)
                          (=> (holds ?pred ?x ?y)
                              (holds ?pred ?y ?x))))))


 - Command: assert-rule ((ruleName NAME)) : PROPOSITION
     Set the truth value of the rule named RULENAME to TRUE.  The
     proposition having the name RULENAME may be any arbitrary
     proposition, although we expect that it is probably a material
     implication.  (See `retract-rule').

 - Command: cc (&rest (name NAME)) : CONTEXT
     Change the current context to the one named NAME.  Return the
     value of the new current context.  If no NAME is supplied, return
     the pre-existing value of the current context.  `cc' is a no-op if
     the context reference cannot be successfully evaluated.

 - Command: classify-relations ((module NAME) (local? BOOLEAN)) :
     Classify named relations visible in MODULE.  If LOCAL?, only
     classify descriptions defined within MODULE, i.e., don't classify
     descriptions inherited from ancestor modules.  If MODULE is NULL,
     classify relations in all modules.

     Conceptually, the classifier operates by comparing each concept or
     relation with all other concepts/relations, searching for a proof
     that a subsumption relation exists between each pair. Whenever a
     new subsumption relation is discovered, the classifier adds an
     `implication' link between members of the pair, thereby augmenting
     the structure of the concept or relation hierarchy. The
     implemented classification algorithm is relatively efficient - it
     works hard at limiting the number of concepts or relations that
     need to be checked for possible subsumption relationships.


 - Command: classify-instances ((module NAME) (local? BOOLEAN)) :
     Classify instances visible in MODULE.  If LOCAL?, only classify
     instances that belong to MODULE, i.e., don't classify instances
     inherited from ancestor modules.  If MODULE is NULL, classify
     instances in all modules.

     Conceptually, the classifier operates by comparing each instance
     with all concepts in the hierarchy, searching for a proof for each
     pairing indicating that the instance belongs to the concept.
     Whenever a new `is-a' relation is discovered, the classifier adds
     an `is-a' link between the instance and the concept, thereby
     recording an additional fact about the instance.  The implemented
     classification algorithm is relatively efficient - it works hard
     at limiting the number of concepts or relations that need to be
     checked for possible is-a relationships.


 - Command: clear-instances (&rest (name NAME)) :
     Destroy all instances belonging to module NAME or any of its
     children.  Leave meta-objects, e.g., concepts and relations, alone.
     If no NAME is supplied, the current module will be cleared after
     confirming with the user.

 - Command: clear-module (&rest (name NAME)) :
     Destroy all objects belonging to module NAME or any of its
     children.  If no NAME is supplied, the current module will be
     cleared after confirming with the user.  Important modules such as
     STELLA are protected against accidental clearing.

 - Command: conceive ((formula PARSE-TREE)) : OBJECT
     Guess whether FORMULA represents a term or a sentence/proposition.
     If we are not sure, assume its a proposition.  If its, a term,
     return its internal representation.  If a proposition, construct a
     proposition for FORMULA without asserting its truth value.  Return
     the conceived proposition object.  KIF example: "(conceive (happy
     Fred))" builds the proposition expressing that Fred is happy
     without explictly asserting or denying it.  Note, that for this to
     succeed, the relation `happy' must already be defined (see
     `assert').  If the logic constant `Fred' has not yet been created,
     it is automatically created as a side-effect of calling `conceive'.

 - Command: copyright () :
     Print detailed PowerLoom copyright information.

 - Command: defconcept (&rest (args PARSE-TREE)) : NAMED-DESCRIPTION
     Define (or redefine) a concept.  The accepted syntax is:

           (defconcept <conceptconst> [(<var> <parent>*)]
              [:documentation <string>]
              [:<= <sentence>] | [:=> <sentence>] |
              [:<<= <sentence>] | [:=>> <sentence>] |
              [:<=> <sentence>] | [:<=>> <sentence>] | [:<<=> <sentence>] |
              [:<<=>> <sentence>] |
              [:axioms {<sentence> | (<sentence>+)}] |
              <keyword-option>*)

     Declaration of a concept variable `<var>' is optional, unless any
     implication (arrow) options are supplied that need to reference
     it.  A possibly empty list of concept names following `<var>' is
     taken as the list of parents of `<conceptconst>'.  Alternatively,
     parents can be specified via the `:=>' option.  If no parents are
     specified, the parent of `<conceptconst>' is taken to be THING.
     `<keyword-option>' represents a keyword followed by a value that
     states an assertion about `<conceptconst>'.  See `defrelation' for
     a description of `<keyword-option>'s.


 - Command: deffunction (&rest (args PARSE-TREE)) : NAMED-DESCRIPTION
     Define (or redefine) a logic function.  The accepted syntax is:

           (deffunction <funconst> (<vardecl>+) [:-> <vardecl>]
              [:documentation <string>]
              [:<= <sentence>] | [:=> <sentence>] |
              [:<<= <sentence>] | [:=>> <sentence>] |
              [:<=> <sentence>] | [:<=>> <sentence>] |
              [:<<=> <sentence>] | [:<<=>> <sentence>] |
              [:axioms {<sentence> | (<sentence>+)}]
              [<keyword-option>*])

     Function parameters can be typed or untyped.  If the `:->' option
     is supplied, it specifies the output variable of the function.
     Otherwise, the last variable in the parameter list is used as the
     output variable.  See `defrelation' for a description of
     `<keyword-option>'s.


 - Command: definstance (&rest (args PARSE-TREE)) : LOGIC-OBJECT
     Define (or redefine) a logic instance (`definstance' is an alias
     for `defobject' which see).

 - Command: defmodule ((name NAME) &rest (options OBJECT)) :
     Define (or redefine) a module named NAME.  The accepted syntax is:

            (defmodule <module-name>
               [:documentation <docstring>]
               [:includes {<module-name> | (<module-name>*)}]
               [:uses {<module-name> | (<module-name>*)}]
               [:lisp-package <package-name-string>]
               [:java-package <package-specification-string>]
               [:cpp-namespace <namespace-name-string>]
               [:java-catchall-class
               [:api? {TRUE | FALSE}]
               [:case-sensitive? {TRUE | FALSE}]
               [:shadow (<symbol>*)]
               [:java-catchall-class <class-name-string>]
               [<other-options>*])

     NAME can be a string or a symbol.

     Modules include objects from other modules via two separate
     mechanisms: (1) they inherit from their parents specified via the
     `:includes' option and/or a fully qualified module name, and (2)
     they inherit from used modules specified via the `:uses' option.
     The main difference between the two mechanisms is that inheritance
     from parents is transitive, while uses-links are only followed one
     level deep.  I.e., a module A that uses B will see all objects of
     B (and any of B's parents) but not see anything from modules used
     by B.  Another difference is that only objects declared as public
     can be inherited via uses-links (this is not yet enforced).  Note
     that - contrary to Lisp - there are separate name spaces for
     classes, functions, and variables.  For example, a module could
     inherit the class `CONS' from the `STELLA' module, but shadow the
     function of the same name.

     The above discussion of `:includes' and `:uses' semantics keyed on
     the inheritance/visibility of symbols. The PowerLoom system makes
     another very important distinction: If a module `A' is inherited
     directly or indirectly via `:includes' specification(s) by a
     submodule `B', then all definitions and facts asserted in `A' are
     visible in `B'. This is not the cases for `:uses'; the `:uses'
     options does not impact inheritance of propositions at all.

     The list of modules specified in the `:includes' option plus (if
     supplied) the parent in the path used for NAME become the new
     module's parents. If no `:uses' option was supplied, the new
     module will use the `STELLA' module by default, otherwise, it will
     use the set of specified modules.  If `:case-sensitive?' is
     supplied as TRUE, symbols in the module will be interned
     case-sensitively, otherwise (the default), they will be converted
     to uppercase before they get interned. Modules can shadow
     definitions of functions and classes inherited from parents or used
     modules. Shadowing is done automatically, but generates a warning
     unless the shadowed type or function name is listed in the
     `:shadow' option of the module definition .

     Examples:

            (defmodule "PL-KERNEL/PL-USER"
              :uses ("LOGIC" "STELLA")
              :package "PL-USER")
          
            (defmodule PL-USER/GENEALOGY)

     The remaining options are relevant only for modules that contain
     STELLA code.  Modules used only to contain knowledge base
     definitions and assertions have no use for them:

     The keywords `:lisp-package', `:java-package', and `:cpp-package'
     specify the name of a native package or name space in which
     symbols of the module should be allocated when they get translated
     into one of Lisp, Java, or C++. By default, Lisp symbols are
     allocated in the `STELLA' package, and C++ names are translated
     without any prefixes. The rules that the STELLA translator uses to
     attach translated Java objects to classes and packages are
     somewhat complex. Use :java-package option to specify a list of
     package names (separated by periods) that prefix the Java object
     in this module.  Use :java-catchall-class to specify the name of
     the Java class to contain all global & special variables,
     parameter-less functions and functions defined on arguments that
     are not classes in the current module.  The default value will be
     the name of the module.

     When set to TRUE, the :api? option tells the PowerLoom User Manual
     generator that all functions defined in this module should be
     included in the API section. Additionally, the Java translator
     makes all API functions `synchronized'.


 - Command: defobject (&rest (args PARSE-TREE)) : LOGIC-OBJECT
     Define (or redefine) a logic instance.  The accepted syntax is:

           (defobject <constant>
              [:documentation <string>]
              [<keyword-option>*])

     `<keyword-option>' represents a keyword followed by a value that
     states an assertion about <constant>.  See `defrelation' for a
     description of `<keyword-option>'s.

     `defobject' provides a sugar-coated way to assert a collection of
     facts about a logic constant, but otherwise adds nothing in terms
     of functionality.


 - Command: defproposition (&rest (args PARSE-TREE)) : PROPOSITION
     Define (or redefine) a named proposition.  The accepted syntax is:

           (defproposition <name> <sentence>
              [:documentation <string>]
              [:forward-only? {true | false}]
              [:backward-only? {true | false}]
              [:dont-optimize? {true | false}]
              [:confidence-level {:strict | :default}]
              [<keyword-option>*])

     <sentence> can be any sentence that is legal as a top-level
     assertion.  <name> can be a string or symbol and will be bound to
     the asserted proposition represented by <sentence>.  After this
     definition every occurrence of <name> will be replaced by the
     associated proposition.

     The options :forward-only? and :backward-only? can be used to tell
     the inference engine to only use the rule in forward or backward
     direction (this can also be achieved by using the `<<=' or `=>>'
     implication arrows).  :dont-optimize?  tells the inference engine
     to not rearrange the order of clauses in the antecedent of a rule
     and instead evaluate them in their original order.
     :confidence-level can be used to mark a proposition as default
     only.

     `<keyword-option>' represents a keyword followed by a value that
     states an assertion about the proposition <name>.  See
     `defrelation' for a description of `<keyword-option>'s.


 - Command: defrelation (&rest (args PARSE-TREE)) : NAMED-DESCRIPTION
     Define (or redefine) a logic relation.  The accepted syntax is:

           (defrelation <relconst> (<vardecl>+)
              [:documentation <string>]
              [:<= <sentence>] | [:=> <sentence>] |
              [:<<= <sentence>] | [:=>> <sentence>] |
              [:<=> <sentence>] | [:<=>> <sentence>] |
              [:<<=> <sentence>] | [:<<=>> <sentence>] |
              [:axioms {<sentence> | (<sentence>+)}]
              [<keyword-option>*])

     Relation parameters can be typed or untyped.  `<keyword-option>'
     represents a keyword followed by a value that states an assertion
     about `<relconst>'.  For example, including the option `:foo bar'
     states that the proposition `(foo <relconst> bar)' is true.  `:foo
     (bar fum)' states that both `(foo <relconst> bar)' and `(foo
     <relconst> fum)' are true.  `:foo true' states that `(foo
     <relconst>)' is true, `:foo false' states that `(not (foo
     <relconst>))' is true.


 - Command: defrule (&rest (args PARSE-TREE)) : PROPOSITION
     Define (or redefine) a named rule (`defrule' is an alias for
     `defproposition' which see).

 - Command: delete-rules ((relation NAME)) :
     Delete the list of rules associated with RELATION.  This function
     is included mainly for debugging purposes, when a user wants to
     verify the behavior of different sets of rules.

 - Command: demo (&rest (fileandpause OBJECT)) :
     Read logic commands from a file, echo them verbatimly to standard
     output, and evaluate them just as if they had been typed in
     interactively.  When called with no arguments, present a menu of
     example demos, otherwise, use the first argument as the name of
     the file to demo.  Pause for user confirmation after each
     expression has been read but before it is evaluated.  Pausing can
     be turned off by suppling FALSE as the optional second argument,
     or by typing `c' at the pause prompt.  Typing `?' at the pause
     prompt prints a list of available commands.

 - Command: deny ((proposition PARSE-TREE)) : OBJECT
     Assert the falsity of PROPOSITION.  Return the asserted proposition
     object.  KIF example:  "(deny (happy Fred))" asserts that Fred is
     not happy, which could have been done equivalently by "(assert
     (not (happy Fred)))".  Note, that for this to succeed, the
     relation `happy' must already be defined (see `assert').

 - Command: describe ((name OBJECT) &rest (mode OBJECT)) :
     Print a description of an object in :verbose, :terse, or :source
     modes.

 - Command: destroy ((objectSpec PARSE-TREE)) : OBJECT
     Find an object or proposition as specified by OBJECTSPEC, and
     destroy all propositions and indices that reference it.
     OBJECTSPEC must be a name or a parse tree that evaluates to a
     proposition.  Return the deleted object, or NULL if no matching
     object was found.

 - Command: get-rules ((relation NAME)) : (CONS OF PROPOSITION)
     Return the list of rules associated with RELATION.

 - Command: help (&rest (commands SYMBOL)) :
     Describe specific commands, or print a list of available commands.

 - Command: in-module ((name NAME)) : MODULE
     Change the current module to the module named NAME.

 - Command: load ((file STRING)) :
     Read logic commands from FILE and evaluate them.

 - Command: load-file ((file STRING)) :
     Read STELLA commands from FILE and evaluate them.  The file should
     begin with an `in-module' declaration that specifies the module
     within which all remaining commands are to be evaluated The
     remaining commands are evaluated one-by-one, applying the function
     `evaluate' to each of them.

 - Command: presume ((proposition PARSE-TREE)) : OBJECT
     Presume the default truth of PROPOSITION.  Return the presumed
     proposition object.  KIF example:  "(presume (happy Fred))" states
     that Fred is most probably happy.  Note, that for this to succeed,
     the relation `happy' must already be defined (see `assert').

 - Command: print-features () :
     Print the currently enabled and available PowerLoom environment
     features.

 - Command: print-rules ((relation OBJECT)) :
     Print the list of rules associated with RELATION.

 - Command: process-definitions () :
     Finish processing all definitions and assertions that have been
     evaluated/loaded since that last call to `process-definitions'.
     PowerLoom defers complete processing of definitions to make it
     easier to support cyclic definitions.  Following finalization of
     definitions, this call performs semantic validation of any
     assertions evaluated since the last call to `process-definitions'.
     PowerLoom calls this function internally before each query; the
     primary reason to call it explicitly is to force the production of
     any diagnostic information that results from the processing and
     validation.

 - Command: propagate-constraints (&rest (name NAME)) :
     Trigger constraint propagation over all propositions of module
     NAME.  If no NAME is supplied, the current module will be used.
     This also enables incremental constraint propagation for future
     monotonic updates to the module.  Once a non-monotonic update is
     performed, i.e., a retraction or clipping of a function value, all
     cached inferences will be discarded and constraint propagation
     will be turned off until this function is called again.

 - Command: repropagate-constraints (&rest (name NAME)) :
     Force non-incremental constraint propagation over all propositions
     of module NAME.  If no NAME is supplied, the current module will
     be used.  This also enables incremental constraint propagation for
     future monotonic updates to the module similar to
     `propagate-constraints'.

 - Command: reset-features () : (LIST OF KEYWORD)
     Reset the PowerLoom environment features to their default settings.

 - Command: retract ((proposition PARSE-TREE)) : OBJECT
     Retract the truth of PROPOSITION.  Return the retracted proposition
     object.  KIF example:  "(retract (happy Fred))" retracts that Fred
     is happy.  Note that for this assertion to succeed, the relation
     `happy' must already be defined.  If the constant `Fred' has not
     yet been created, it is automatically created as a side-effect of
     calling `retract'.

 - Command: retract-facts-of ((instanceRef OBJECT)) :
     Retract all definite (TRUE or FALSE) propositions that reference
     the instance INSTANCEREF.

 - Command: retract-from-query ((query CONS) &rest (options OBJECT)) :
          (CONS OF PROPOSITION)
     Evaluate QUERY which has to be a strict or partial retrieval
     command, instantiate the query proposition for each generated
     solution and retract the resulting propositions.  See
     `assert-from-query' for available command options.

 - Command: retract-rule ((ruleName NAME)) : PROPOSITION
     If it is currently TRUE, set the truth value of the rule named
     RULENAME to UNKNOWN  This command may be used alternately with
     `assert-rule' to observe the effects of querying with or without a
     particular (named) rule being asserted within the current context.
     The proposition having the name RULENAME may be any arbitrary
     proposition, although we expect that it is probably a material
     implication.

 - Command: retrieve (&rest (query PARSE-TREE)) : QUERY-ITERATOR
     Retrieve elements of a relation (tuples) that satisfy a
     proposition.  The accepted syntax is:

            (retrieve [<integer> | all]
                      [[{<vardecl> | (<vardecl>+)}]
                      <proposition>])

     The variables and proposition are similar to an `exists' sentence
     or `kappa' term without the explicit quantifier.  If variables are
     declared, they must match the free variables referenced by
     <proposition>.  Otherwise, the free variables referenced in
     <proposition> will be used as the query variables.  If
     <proposition> is omitted, the most recently asked query will be
     continued.

     A solution is a set of bindings for the listed variables for which
     <proposition> is true.  The optional first argument controls how
     many solutions should be generated before control is returned.
     The keyword `all' indicates that all solutions should be
     generated.  By default, `retrieve' returns after it has found one
     new solution or if it cannot find any more solutions.

     `retrieve' returns an iterator which saves all the necessary state
     of a query and stores all generated solutions.  When used
     interactively, the returned iterator will print out with the set
     of solutions collected so far.  Calling `retrieve' without any
     arguments (or only with the first argument) will generate one (or
     more) solutions to the most recently asked query.

     KIF examples:

            (retrieve (?x Person) (happy ?x))

     will try to find the next happy person and store it in the returned
     query iterator.

            (retrieve 10 (?x Person) (happy ?x))

     will try to find 10 happy people.

            (retrieve 10)

     will try to find the next 10 happy people.

            (retrieve all (?x Person) (happy ?x))

     will find all happy people.

            (retrieve all (?x Person))

     will find all people.

            (retrieve (?x Person) (or (happy ?x) (parent-of Fred ?x)))

     will try to find a person that is happy or has Fred as a parent.

            (retrieve (or (happy ?x) (parent-of Fred ?x)))

     will do the same in a more concise syntax by omitting the query
     variable declaration.

            (retrieve ((?x Person) (?y Person)) (parent-of ?x ?y))

     will try to find the next pair of parent/child.

            (retrieve all (?x Person)
                      (exists (?y Person) (parent-of ?x ?y)))

     will generate the set of all parents.  Note, that for these
     queries to run, the class `Person', the relations `happy' and
     `parent-of', and the logic constant `Fred' must already be defined
     (see `assert').

     Use `(set/unset-feature trace-subgoals)' to en/disable goal
     tracing of the inference engine.

 - Command: save-module ((name NAME) (file STRING)) :
     Save all definitions and assertions of module NAME to FILE.

 - Command: set-feature (&rest (features NAME)) : (LIST OF KEYWORD)
     Enable the PowerLoom environment feature(s) named by FEATURES.
     Return the list of enabled features.  Calling `set-feature'
     without any arguments can be used to display the currently enabled
     features.  The following features are supported:

     `just-in-time-inference': Enables interleaving of forward chaining
     inference within backward chaining queries.

     `iterative-deepening': Tells the query processor to use iterative
     deepening instead of a depth-first search to find answers.  This
     is less efficient but necessary for some kinds of highly recursive
     queries.

     `trace-subgoals': Enables the generation of subgoaling trace
     information during backchaining inference.

     `trace-solutions': Prints newly found solutions during retrieval
     right when they are generated as opposed to when the query
     terminates.

     `trace-classifier': Tells the classifier to describe the
     inferences it draws.

     `justifications': Enables the generation of justifications during
     inference, which is a prerequiste for the generation of
     explanations with `(why)'.

     `emit-thinking-dots': Tells PowerLoom to annotate its inference
     progress by outputting characters indicating the completion of
     individual reasoning steps.

     By default, the features `emit-thinking-dots' and
     `just-in-time-inference' are enabled, and the others are disabled.


 - Command: unset-feature (&rest (features NAME)) : (LIST OF KEYWORD)
     Disable the PowerLoom environment feature(s) named by FEATURES.
     Return the list of enabled features.  Calling `unset-feature'
     without any arguments can be used to display the currently enabled
     features.  See `set-feature' for a description of supported
     features.

 - Command: why (&rest (args OBJECT)) :
     Print an explanation for the result of the most recent query.
     Without any arguments, `why' prints an explanation of the top level
     query proposition down to a maximum depth of 3.  `(why all)' prints
     an explanation to unlimited depth.  Alternatively, a particular
     depth can be specified, for example, `(why 5)' explains down to a
     depth of 5.  A proof step that was not explained explicitly (e.g.,
     due to a depth cutoff) can be explained by supplying the label of
     the step as the first argument to `why', for example, `(why 1.2.3
     5)' prints an explanation starting at 1.2.3 down to a depth of 5
     (which is counted relative to the depth of the starting point).
     The keywords `brief' and `verbose' can be used to select a
     particular explanation style.  In brief mode, explicitly asserted
     propositions are not further explained and indicated with a `!'
     assertion marker.  Additionally, relatively uninteresting proof
     steps such as AND-introductions are skipped.  This explanation
     style option is sticky and will affect future calls to `why' until
     it gets changed again.  The various options can be combined in any
     way, for example, `(why 1.2.3 brief 3)' explains starting from
     step 1.2.3 down to a depth of 3 in brief explanation mode.

   ---------- Footnotes ----------

   (1) Lisp programmers are typically spoiled, and find it inconvenient
to wrap double-quotes around their arguments.

