<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<!-- Created on May, 25  2006 by texi2html 1.65 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>PowerLoom Manual: Introduction</TITLE>

<META NAME="description" CONTENT="PowerLoom Manual: Introduction">
<META NAME="keywords" CONTENT="PowerLoom Manual: Introduction">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.65">

</HEAD>

<BODY LANG="en" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC2"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_1.html#SEC1"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_2.html#SEC3"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC7"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 2. Introduction </H1>
<!--docid::SEC2::-->
<P>

This document describes the PowerLoom knowledge representation and
reasoning system. PowerLoom is the successor to the Loom knowledge
representation system. It provides a language and environment for
constructing intelligent, knowledge-based applications. PowerLoom uses a
fully expressive, logic-based representation language (a variant of
KIF). It uses a natural deduction inference engine that combines forward
and backward chaining to derive what logically follows from the facts
and rules asserted in the knowledge base.  While PowerLoom is not a
description logic, it does have a description classifier which uses
technology derived from the Loom classifier to classify descriptions
expressed in full first order predicate calculus. PowerLoom uses modules
as a structuring device for knowledge bases, and ultra-lightweight
worlds to support hypothetical reasoning.
</P><P>

To implement PowerLoom we developed a new programming language called
STELLA, which is a Strongly Typed, Lisp-like LAnguage that can be
translated into Lisp, Java, and C++. STELLA tries to preserve those
features of Lisp that facilitate symbolic programming and rapid
prototyping, while still allowing translation into readable as well as
efficient Java and C++ code. Because PowerLoom in written STELLA, we are
able to deliver it in all three languages.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_2.html#SEC3">2.1 Powerloom Features</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_2.html#SEC4">2.2 Powerloom History</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_2.html#SEC5">2.3 Running PowerLoom</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Powerloom Features"></A>
<HR SIZE="6">
<A NAME="SEC3"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_2.html#SEC2"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_2.html#SEC4"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_2.html#SEC2"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_2.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC7"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 2.1 Powerloom Features </H2>
<!--docid::SEC3::-->
<P>

PowerLoom is a full-function, logic-based knowledge representation and
reasoning system, that supports all aspects of knowledge-based
applications.  It allows the representation of complex knowledge in a
declarative, logic-based language, supports a variety of reasoning mechanisms
to make implicit knowledge explicit, has a powerful query engine to retrieve
what has been asserted and logically follows from the KB, provides file-based
and RDBMS-based storage of knowledge bases, has a context and module system to
effectively partition and organize large knowledge bases, and has an extensive
API in multiple language to allow easy and effective integration into
knowledge-based applications.
</P><P>

PowerLoom's focus is on expressivity of its representation language while
still providing good scalability to large ontologies and knowledge bases.  In
general, PowerLoom takes a <EM>pragmatic stance</EM> where usability is more
important than theoretical "neatness" and expressivity is more important than
inferential completeness.  From our point of view, there is nothing magical
about logic, it is just another programming language (with difficult to
understand semantics), so it should help you to solve the task at hand as best
as possible and not hinder you by forcing you to work around restrictions of
the logic.  Of course, PowerLoom cannot completely escape the straight-jacket
of logic, but it tries to push the boundaries as much as possible.
</P><P>

<UL>
<LI>
<STRONG>Representation language</STRONG>: PowerLoom uses the language of
predicate logic to represent knowledge.  The syntax is KIF (the
Knowledge Interchange Format) which is one of the supported syntaxes of
the upcoming Common Logic standard.  PowerLoom adds a variety of
convenient definitional constructs as well as extensions beyond
traditional first-order logic such as type-level predicates, relation
variables in <CODE>holds</CODE> sentences, modal assertions (sentences about
sentences), cross-context assertions via <CODE>ist</CODE> to represent lifting
axioms, defaults (still experimental), and others.  The goal is to
provide a highly expressive representation language, since KR failures
or awkward models are often due to "we could not express X in language
L".  The theoretical undecidability and intractability of such an
expressive language is counteracted by providing limited, "pragmatic"
reasoning services that cover commonly encountered situations.  For
example, reasoning with second-order sentences that quantify over
relations is undecidable and leads to very unfocused search; however,
such sentences are very useful to describe axiom schemata that can be
cheaply run in forward direction to create regular first-order rules (in
a process not unlike macro expansion).
<P>

<LI>
<STRONG>Reasoning</STRONG>: The primary reasoning mechanism is logical deduction
which infers statements that logically follow from the asserted
statements and rules.  Such statements can be asked about using
PowerLoom's query commands <CODE>ask</CODE> (for true/false questions) and
<CODE>retrieve</CODE> (for Wh-questions).  PowerLoom uses a natural deduction
system to answer queries but also has a large number of specialized
reasoning procedures to efficiently handle concept and relation
hierarchies, sets, frame predicates, search control, etc.  The
specialist architecture is extensible to allow users to plug-in their
own reasoners or computed predicates.  PowerLoom also supports
hypothetical reasoning, equality reasoning, arithmetic and reasoning
with inequalities.  While <STRONG>PowerLoom is not a description logic</STRONG>,
it does have a classifier that can classify concept and relation
hierarchies and instances defined using the full expressive power of
first-order logic.  The classifier does not provide any additional
inferences, but allows PowerLoom to eagerly pre-compute and cache
subsumption relationships which can then be utilized over and over
without having to re-derive them.  PowerLoom also provides some
experimental abductive and partial-match reasoning to handle incomplete
knowledge bases.
<P>

<LI>
<STRONG>Meta-representation and reasoning</STRONG>: Concepts, relations,
contexts, rules, queries, etc. are all first-class citizens in the
domain of discourse.  Therefore, they can have assertions made about
them as well as reasoned about.  This mechanism is commonly used by the
system itself, e.g., to assert that a relation is single valued or
transitive, that a concept is closed, etc.
<P>

<LI>
<STRONG>Explanation</STRONG>: PowerLoom can explain its reasoning by recording
inference trees and then rendering those into human-understandable
explanations.  PowerLoom also has an experimental "WhyNot" facility to
explain inference failures where no successful proof tree was found.
<P>

<LI>
<STRONG>Contexts and modules</STRONG>: Contexts and modules provide separate
name and assertion spaces with inheritance which implement a powerful
structuring mechanism for KBs.  Contexts allow encapsulation and
organization of knowledge, efficient inference (by separating irrelevant
knowledge or by separating ontologies and assertion spaces from volatile
inference worlds), truth maintenance (via inference cache contexts),
scenarios and hypothetical reasoning, non-monotonic overrides in
sub-contexts, etc.  PowerLoom's context mechanism is built-in at a very
low level using a very efficient and light-weight implementation for
maximum performance.
<P>

<LI>
<STRONG>Open and closed-world</STRONG>: By default, PowerLoom makes an
open-world assumption and returns <CODE>unknown</CODE> if it cannot prove or
disprove a question.  However, concepts and relations can be selectively
marked as closed to support selective closed-world reasoning.  PowerLoom
also has a <CODE>fail</CODE> predicate (in addition to true negation via
<CODE>not</CODE>) to implement closed-world negation-as-failure which can be
useful in certain situations.
<P>

<LI>
<STRONG>Knowledge base management</STRONG>: PowerLoom supports incremental
monotonic and non-monotonic updates that extend or non-monotonically
change the assertion base.  In PowerLoom one can effectively interleave
definitions, re-definitions, assertions and retractions with retrieval
and inference without having to reload large knowledge bases from
scratch after every change.  Truth maintenance of cached inference
results that might have been invalidated by updates is done via
inference cache contexts.  After a knowledge base has been loaded and
changed by some updates, the changed state can be saved out to a file or
an (experimental) persistent store built on top of a relational
database.
<P>

<LI>
<STRONG>Scalability</STRONG>: Despite its emphasis on expressive representation
which usually has to be paid for with intractable and expensive
reasoning procedures, PowerLoom is very scalable and comes with a
variety of mechanisms to control search and handle large ontologies and
knowledge bases.  For example, PowerLoom's reasoning specialists handle
a wide variety of inferencing very effectively without having to go
through any rule chaining.  Search control annotations can be used to
help the inference engine use rules more effectively.  For example,
depending on fan-out, certain rules are run more effectively forwards
than backwards (or vice versa), and a KB developer can tell the system
when that's the case.  PowerLoom has resource-bounded depth-first or
iterative deepening search which provides an any-time inference scheme
for situations where resources are limited.  A "just-in-time" forward
inference engine elaborates the assertion neighborhood of objects
touched upon by inference.  This allows focused forward inference
relevant to current inference goals, without having to run forward
inference over a potentially very large KB to completion.  PowerLoom has
a static and dynamic query optimizer, that, similar to optimizers used
in database systems, orders conjunctive goals based on relation
extension sizes and rule fan-out to minimize intermediate result sets
and chaining.  The dynamic optimizer does this for each conjunctive
subgoal based on actual bindings.  Given this mechanism it is possible
to run PowerLoom queries that return 100,000's of solutions.  PowerLoom
also has a powerful relational database interface that allows it to
utilize the power of databases for handling large assertion bases (soon
to be released).  One application of this PowerLoom/RDBMS integration is
used with ISI's Omega ontology.  It is also a crucial part of our KOJAK
Link Discovery System.
<P>

<LI>
<STRONG>Tools and APIs</STRONG>: PowerLoom has a host of associated tools and
APIs (not all of which have been released yet).  It comes with an
interactive command-line interface which is useful for developing
ontologies and knowledge bases, an extensive programmatic interface
called PLI with Lisp, C++ and Java bindings, and a Lisp-based Loom API
to load legacy Loom KBs.  Ontosaurus is a Web-based KB browser that
dynamically generates HTML pages viewable in a standard Web browser.
Ontosaurus has been released in an experimental pre-release.  A
soon-to-be-released Prot&#38;eacute;g&#38;eacute; plug-in allows export of
Prot&#38;eacute;g&#38;eacute; ontologies into PowerLoom format.  A not yet
released Java-based GUI provides a browse/edit/query environment for
developing KBs.  The GUI uses a client/server architecture and is
deployable via Java WebStart in standard browser. OntoMorph is a
translation system that supports writing of KB translators and
importers, e.g., to import ontologies written in other languages (for
example, Flogic).
<P>

<LI>
<STRONG>Initial Semantic Web support</STRONG>: Given PowerLoom's emphasis on
expressive representation, we have not yet focused much on Semantic Web
languages such as OWL, which restricts expressivity to gain
decidability.  OWL also has other limitations such as restriction to
binary relations and lack of support for arithmetic and inequalities
which limits its usefulness for practical applications.  Nevertheless,
given that people are starting to use these languages more and more,
we've developed some initial import translators for RDF/RDFS and OWL
which once they mature we will release as part of PowerLoom.
<P>

<LI>
<STRONG>Portability and integration</STRONG>: Since PowerLoom is implemented in
STELLA, it is available in Lisp, C++ and Java implementations and highly
portable.  PowerLoom can be run in each of these languages under Unix
(such as Linux, SunOS or MacOS X) as well as Windows 2000 and XP.  Due
to the availability in three main-stream languages, it can easily be
integrated programmatically with most application software without
having to use some complex integration framework.  The C++ and Java
libraries for PowerLoom are also quite small and light-weight, for
example, the necessary STELLA and PowerLoom jar files of the Java
implementation are less than 2.5 Meg in size.
</UL>
<P>

<A NAME="Powerloom History"></A>
<HR SIZE="6">
<A NAME="SEC4"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_2.html#SEC3"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_2.html#SEC5"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_2.html#SEC2"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_2.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC7"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 2.2 Powerloom History </H2>
<!--docid::SEC4::-->
<P>

&#60;to be written&#62;
</P><P>

<A NAME="Running PowerLoom"></A>
<HR SIZE="6">
<A NAME="SEC5"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_2.html#SEC4"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_2.html#SEC6"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_2.html#SEC2"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_2.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC7"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 2.3 Running PowerLoom </H2>
<!--docid::SEC5::-->
<P>

The easiest way to run PowerLoom on a variety of platforms is to use the
`<TT>powerloom</TT>' or `<TT>powerloom.bat</TT>' scripts in the top-level
PowerLoom directory.  If you have Java installed on your system, these
scripts should run out of the box without any further installation
requirements.  If you want to use the Lisp version of PowerLoom, simply
load the file <CODE>load-powerloom.lisp</CODE> into your Common Lisp.  If you
want to use the C++ version, you have to compile it first.  See the
Installation section in this manual for more details on how to install
the Lisp, C++ or Java version of PowerLoom See section <A HREF="manual_9.html#SEC63">9. Installation</A>.
</P><P>

Under Unix or MacOS X, open a shell window somewhere to run PowerLoom.
For example,
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>% powerloom
Running Java version of PowerLoom...
Initializing STELLA...
Initializing PowerLoom...

    Welcome to PowerLoom 3.2.0

Copyright (C) USC Information Sciences Institute, 1997-2006.
PowerLoom comes with ABSOLUTELY NO WARRANTY!
Type `(copyright)' for detailed copyright information.
Type `(help)' for a list of available commands.
Type `(demo)' for a list of example applications.
Type `bye', `exit', `halt', `quit', or `stop', to exit.

PL-USER |= 
</pre></td></tr></table></P><P>

Under Windows, you can do something similar by running a Command Prompt
window and executing the `<TT>powerloom.bat</TT>' script.  You can also
simply double click on the script which will run PowerLoom and bring up
a Command Prompt window for you.
</P><P>

Once the <CODE>|=</CODE> prompt has come up you can type in PowerLoom commands
and see their results.  The string preceding the prompt indicates the
"current module" relative to which commands are interpreted.  For
example, type the <CODE>demo</CODE> command to see a menu of available demos.
Step through one or more of them to get familiar with PowerLoom.
</P><P>

PowerLoom is a reasoning engine that is intended to be integrated into
some host application software somewhat similar to a database system.
This is the main reason why it currently only ships with a command-line
interface; however, we do have an experimental PowerLoom GUI which might
also be released at some point.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_2.html#SEC6">2.3.1 Command-Line Options</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Command-Line Options"></A>
<HR SIZE="6">
<A NAME="SEC6"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_2.html#SEC5"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC7"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_2.html#SEC4"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_2.html#SEC5"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC7"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 2.3.1 Command-Line Options </H3>
<!--docid::SEC6::-->
<P>

There are a few command-line options that can be supplied to the
`<TT>powerloom</TT>' script.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>powerloom [c++|java]
          [{-e|--eval} STELLA-EXPRESSION]
          [--batch]
</pre></td></tr></table></P><P>

The first optional argument determines what version to run if both C++
and Java versions are installed.  If no specific version is specified,
the C++ version will be run if it is installed, otherwise, the Java
version will be run.
</P><P>

<DL COMPACT>
<DT>`<SAMP>--eval <VAR>STELLA-EXPRESSION</VAR></SAMP>'
<DD><DT>`<SAMP>-e <VAR>STELLA-EXPRESSION</VAR></SAMP>'
<DD>Specifies a STELLA expression that should be run just before the
PowerLoom command loop gets initialized.  This expression has to be a
known command (such as the various PowerLoom commands), since the STELLA
evaluator cannot (yet) evaluate arbitrary STELLA code.  For example,
<CODE>powerloom -e '(demo "equations" FALSE)'</CODE> will run a particular
demo before anything else.  You will need to appropriately quote
special characters interpreted by the shell or the Command Prompt window.
<P>

<DT>`<SAMP>--batch</SAMP>'
<DD>Runs PowerLoom in batch mode without running an interactive command
loop.  This can be useful in conjunction with the <CODE>--eval</CODE> option
to execute a single command or load a PowerLoom script via the
<CODE>load</CODE> command.
</DL>
<P>

<A NAME="Conceptual Framework"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_2.html#SEC4"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC7"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Hans Chalupsky</I> on <I>May, 25  2006</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>
</FONT>

</BODY>
</HTML>
