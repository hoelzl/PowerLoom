<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on October, 29  2003 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>PowerLoom Manual: Annotated Example</TITLE>

<META NAME="description" CONTENT="PowerLoom Manual: Annotated Example">
<META NAME="keywords" CONTENT="PowerLoom Manual: Annotated Example">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC17"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_5.html#SEC16"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC18"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_5.html#SEC12"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 6. Annotated Example </H1>
<!--docid::SEC17::-->
<P>

The section presents a small example of a PowerLoom knowledge
base.  It introduces the fundamental PowerLoom modelling
concepts and illustrates the syntax of basic PowerLoom
declarations, assertions, and commands.  This section can be 
read stand-alone, but readers who intend to use PowerLoom to
create their own models are encouraged to load the demo file
<STRONG>???</STRONG>, and run the examples "live".
</P><P>

The conceptual terms introduced in this section include modules,
concepts, relations, functions, instances, propositions, assertions, 
queries, retraction, positive and negative facts, clipping, rules,
and contexts.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC18">6.1 Using Modules</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC19">6.2 Concepts</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC20">6.3 Relations</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC21">6.4 Relation Hierarchies</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC22">6.5 Functions</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC23">6.6 Defined Concepts</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC24">6.7 Negation and Open and Closed World Semantics</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC25">6.8 Retraction</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC26">6.9 Clipping of Values</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC27">6.10 Rule-based Inference</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC28">6.11 Explanation</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC29">6.12 Contexts and Modules</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC30">6.13 Classification, Subsumption</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC31">6.14 Truth Maintenance</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC32">6.15 Inference Control</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC33">6.16 Keyword Axioms</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC34">6.17 Cardinality/Type Reasoning with Frame Predicates</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC35">6.18 Loom-to-PowerLoom</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC36">6.19 Deviations from KIF</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC37">6.20 Differences from Loom</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC38">6.21 Defaults</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC39">6.22 Sets, Lists, SETOFALL, KAPPA</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Using Modules"></A>
<HR SIZE="6">
<A NAME="SEC18"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC19"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.1 Using Modules </H2>
<!--docid::SEC18::-->
<P>

We begin by creating a PowerLoom "module", which is a logical
container that holds the term definitions, rules, facts, etc.
that make up all or a portion of a domain model.  We will call
our module <CODE>business</CODE>.  The <CODE>defmodule</CODE> command defines a new
module.  The <CODE>:includes</CODE> option within the <CODE>defmodule</CODE> tells
PowerLoom that the <CODE>business</CODE> module inherits all definitions
and assertions present in the <CODE>PL-USER</CODE> module, or in ancestor
modules inherited by the <CODE>PL-USER</CODE> module.  In particular, by
inheriting <CODE>pl-user</CODE>, we indirectly inherit the <CODE>pl-kernel</CODE>
module that contains all of the built-in concepts and relations.
The <CODE>in-module</CODE> command tells the PowerLoom system
to make <CODE>business</CODE> the current module.  Until the current module
is changed again, all new introductions of terms and facts will
be placed in the <CODE>business</CODE> module.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defmodule "business"
  :includes ("PL-USER"))
(in-module "business")
</pre></td></tr></table></P><P>

The basic building blocks of a model are its concepts, relations, and
instances.<A NAME="DOCF3" HREF="manual_fot.html#FOOT3">(3)</A> A concept
defines classes/categories of entities that populate the domain model. A
relation defines attributes and relationships that allow the declaration of
facts about an entity. Instances are members of concepts. They appear as
arguments to propositional assertions.
</P><P>

<A NAME="Concepts"></A>
<HR SIZE="6">
<A NAME="SEC19"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC18"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC20"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.2 Concepts </H2>
<!--docid::SEC19::-->
<P>

Concepts are defined using the <CODE>defconcept</CODE> command.  Here
we define the concepts <CODE>company</CODE> and <CODE>corporation</CODE>:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defconcept company)
(defconcept corporation (?c company))
</pre></td></tr></table></P><P>

The first definition tells the system that <CODE>company</CODE> is a concept
(in the <CODE>business</CODE> module).  The second definition defines a
concept <CODE>corporation</CODE>.  The type declaration <CODE>(?c company)</CODE>
indicates that <CODE>corporation</CODE> is a subconcept of <CODE>company</CODE>, i.e.,
all instances of <CODE>corporation</CODE> are also instances of <CODE>company</CODE>.
Let us now create a couple of companies:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(assert (company ACME-cleaners))
(assert (corporation megasoft))
</pre></td></tr></table></P><P>

These two assertions create two new entities denoted by the
terms <CODE>ACME-cleaners</CODE> and <CODE>megasoft</CODE>.  Both of these entities
are members of the concept <CODE>company</CODE>.  <CODE>megasoft</CODE> is also a member
of the concept <CODE>corporation</CODE>.  We can test this by executing some
PowerLoom queries:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(retrieve all ?x (company ?x))
=>
There are 2 solutions:
  #1: ?X=ACME-CLEANERS
  #2: ?X=MEGASOFT

(retrieve all ?x (corporation ?x))
=>
There is 1 solution:
  #1: ?X=MEGASOFT
</pre></td></tr></table></P><P>

<A NAME="Relations"></A>
<HR SIZE="6">
<A NAME="SEC20"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC19"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC21"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.3 Relations </H2>
<!--docid::SEC20::-->
<P>

So far, our two companies aren't very interesting. In order to say more
about them, we can define some relations and functions using the
declarations <CODE>defrelation</CODE> and <CODE>deffunction</CODE>:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defrelation company-name ((?c company) (?name STRING)))
</pre></td></tr></table></P><P>

This declaration defines a binary relation <CODE>company-name</CODE>.
The first value in a <CODE>company-name</CODE> tuple must be an instance
of type <CODE>company</CODE>, while the second value must be a string.
We can now give our companies names, using the command <CODE>assert</CODE>:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(assert (company-name ACME-cleaners "ACME Cleaners, LTD"))
(assert (company-name megasoft "MegaSoft, Inc."))
</pre></td></tr></table></P><P>

We can retrieve pairs of companies and their names with the following
query:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(retrieve all (?x ?y) (company-name ?x ?y))
=>
There are 2 solutions:
  #1: ?X=MEGASOFT, ?Y="MegaSoft, Inc."
  #2: ?X=ACME-CLEANERS, ?Y="ACME Cleaners, LTD"
</pre></td></tr></table></P><P>

<A NAME="Relation Hierarchies"></A>
<HR SIZE="6">
<A NAME="SEC21"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC20"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC22"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.4 Relation Hierarchies </H2>
<!--docid::SEC21::-->
<P>

PowerLoom permits the specification of hierarchies both for concepts and
relations.  Previously , we defined a small concept hierarchy with
<CODE>company</CODE> on top and <CODE>corporation</CODE> below it.  We now define a
subrelation of the relation <CODE>company-name</CODE> called
<CODE>fictitious-business-name</CODE>:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defrelation fictitious-business-name ((?c company) (?name STRING))
  :=&#62; (company-name ?c ?name))
</pre></td></tr></table></P><P>

PowerLoom defines a subconcept/subrelation relationship between
a pair of concepts or a pair of relations by asserting an "implication"
relation between them.
The above implication expands into the assertion
"for all values of ?c and ?name, if the <CODE>fictitious-business-name</CODE>
relation holds for ?c and?name, then the <CODE>company-name</CODE> relation
also holds for ?c and ?name".  This is equivalent to the assertion
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(forall (?c ?name) (=&#62; (fictitious-business-name ?c ?name)
                       (company-name ?c ?name)))
</pre></td></tr></table></P><P>

Since implication relationships occur very
commonly, PowerLoom provides several syntactic shortcuts for defining
them.  We have seen one such shortcut earlier; our
definition of <CODE>corporation</CODE> included the clause "<CODE>(company ?c)</CODE>",
which specified that <CODE>corporation</CODE> is a subconcept of <CODE>company</CODE>.
In our definition of <CODE>fictitious-business-name</CODE>, the keyword 
<CODE>:=&#62;</CODE> introduces a similar shortcut, which tells us that 
<CODE>fictitious-business-name</CODE> is a subrelation of <CODE>company-name</CODE>.
Let us assert a fictious business name for MegaSoft:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(assert (fictitious-business-name megasoft "MegaSoft"))
</pre></td></tr></table></P><P>

If we query for the company names of MegaSoft, we get two names,
one of them asserted directly, and one of them infered by the
subrelation rule:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(retrieve all ?x (company-name megasoft ?x))
=>
There are 2 solutions:
  #1: ?X="MegaSoft"
  #2: ?X="MegaSoft, Inc."
</pre></td></tr></table></P><P>

<A NAME="Functions"></A>
<HR SIZE="6">
<A NAME="SEC22"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC21"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC23"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.5 Functions </H2>
<!--docid::SEC22::-->
<P>

This illustrates another point: A PowerLoom relation is by default
"multi-valued", which in the case of a binary relation means that a
single first value can be mapped by the relation to more than one second
value. In the present case, our model permits a <CODE>company</CODE> entity to
have more than one <CODE>company-name</CODE>. If a (binary) relation always maps
its first argument to exactly one value (i.e., if it it "single-valued")
we can specify it as a <CODE>function</CODE> instead of a <CODE>relation</CODE>.  For
example, we can use a function to indicate the number of employees for a 
company:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(deffunction number-of-employees ((?c company)) :-&#62; (?n INTEGER))
</pre></td></tr></table></P><P>

When defining a function, all arguments but the last appear just as they
do for a relation. The last argument (and its type) appears by itself
following the keyword <CODE>:-&#62;</CODE>. Defining a single-valued relation as a
function allows us to refer to it using a functional syntax within a
logical sentence, as in the following:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(assert (= (number-of-employees acme-cleaners) 8))
(assert (= (number-of-employees megasoft) 10000))
</pre></td></tr></table></P><P>

The functional syntax often results in shorter expressions than
equivalents that use relational syntax.  For example to retrieve all
companies with fewer than 50 employees, we can simply write:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(retrieve all ?x (and (company ?x) (&#60; (number-of-employees ?x) 50)))
=>
There is 1 solution:
  #1: ?X=ACME-CLEANERS
</pre></td></tr></table></P><P>

Using the syntax for relations, the same query would require the
introduction of an existential quantifier, as in:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(retrieve ?x (and (company ?x) 
                  (exists ?n (and (number-of-employees ?x ?n)
                                  (&#60; ?n 50)))))
=>
There is 1 solution so far:
  #1: ?X=ACME-CLEANERS
</pre></td></tr></table></P><P>

To repeat ourselves slightly, Powerloom allows users the choice of using
either relational or functional syntax when using a function in predicate
position. For example, if <CODE>f</CODE> is a function, then the expressions
<CODE>(f ?x ?y)</CODE> and <CODE>(= (f ?x) ?y)</CODE>  are equivalent.
</P><P>

<A NAME="Defined Concepts"></A>
<HR SIZE="6">
<A NAME="SEC23"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC22"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC24"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.6 Defined Concepts </H2>
<!--docid::SEC23::-->
<P>

If we find ourselves writing the same query (or subexpression) repeatedly,
we may wish to define a name for the concept embodying that expression.
For example, below we define the term <CODE>small-company</CODE> to represent
the class of all companies with fewer than 50 employees:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defconcept small-company ((?c company))
  :&#60;=&#62; (and (Company ?c)
            (&#60; (number-of-employees ?c) 50)))
</pre></td></tr></table></P><P>

Notice that we have used a new keyword, <CODE>:&#60;=&#62;</CODE>. This keyword defines a
bidirectional implication called "if-and-only-if".  Formally it is
equivalent to the following pair of assertions:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(assert (forall ?c (=&#62; (and (Company ?c)
                            (&#60; (number-of-employees ?c) 50))
                       (small-company ?c))))
(assert (forall ?c (=&#62; (small-company ?c)
                       (and (Company ?c)
                            (&#60; (number-of-employees ?c) 50)))))
</pre></td></tr></table></P><P>

In other words, the <CODE>:&#60;=&#62;</CODE> keyword is a shortcut for an assertion that
uses the <CODE>&#60;=&#62;</CODE> relation, which itself is a shortcut representing the
conjunction of two single arrow implications. For example, <CODE>(&#60;=&#62; P Q)</CODE>
is equivalent to <CODE>(and (&#60;= P Q) (=&#62; P Q))</CODE>, where the <CODE>&#60;=</CODE>
relation is defined to be the inverse of the relation <CODE>=&#62;</CODE>.
</P><P>

Its not necessary that we exactly specify the number of employees in a
company.  Below, all we know about ZZ Productions is that they have
fewer than 20 employees:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(assert (and (company zz-productions)
             (&#60; (number-of-employees zz-productions) 20)))
</pre></td></tr></table></P><P>

These facts are sufficient to classify ZZ Productions as a small
business:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(retrieve all ?x (small-company ?x))
=>
There are 2 solutions:
  #1: ?X=ZZ-PRODUCTIONS
  #2: ?X=ACME-CLEANERS
</pre></td></tr></table></P><P>

<A NAME="Negation and Open and Closed World Semantics"></A>
<HR SIZE="6">
<A NAME="SEC24"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC23"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC25"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.7 Negation and Open and Closed World Semantics </H2>
<!--docid::SEC24::-->
<P>

PowerLoom implements a three-valued logic--the truth value of each
proposition entered into a PowerLoom knowledge base is recorded as being
either true, false, or unknown.<A NAME="DOCF4" HREF="manual_fot.html#FOOT4">(4)</A> Many other systems (e.g., relational
DBMSs) implement a two-valued logic, wherein if a fact is not asserted
to be true, it is assumed to be false.  The PowerLoom command <CODE>ask</CODE>
returns one of three (five) values: <CODE>true</CODE> if it can prove the
truth of a proposition, <CODE>false</CODE> if it can <EM>easily</EM> prove the
falsity of a proposition<A NAME="DOCF5" HREF="manual_fot.html#FOOT5">(5)</A> and otherwise it returns <CODE>unknown</CODE>. (The values
<CODE>default-true</CODE> and <CODE>default-false</CODE> are also possible if
defaults are used).
</P><P>

Below, PowerLoom knows nothing about a newly-introduced concept
<CODE>s-corporation</CODE>, so <CODE>ask</CODE> returns <CODE>unknown</CODE> to both a
positive query and its negation:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defconcept s-corporation (?c corporation))
(ask (s-corporation zz-productions))
=>
UNKNOWN
(ask (not (s-corporation zz-productions)))
=>
UNKNOWN
</pre></td></tr></table></P><P>

If we assert that ZZ Productions is not an S-corporation, then
PowerLoom knows that the proposition in question is false:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(assert (not (s-corporation zz-productions)))
(ask (s-corporation zz-productions))
=>
FALSE
(ask (not (s-corporation zz-productions)))
=>
TRUE
</pre></td></tr></table></P><P>

After asserting that ZZ Productions is not an S-corporation,
a repeat of the query asking if it <EM>is</EM> one will now return <CODE>false</CODE>,
because the explicit assertion of the negation allows a quick disproof of
the positive query.
</P><P>

<STRONG>Note</STRONG>: PowerLoom uses all its effort to prove that the
proposition in question is true, and only uses some effort to prove that
it is false.  Therefore, only falsities that are discovered "on the way"
or with shallow inference strategies will be found (which was the case
above).  If you want to check whether a proposition is false with
maximum effort, simply ask the negated proposition by wrapping an
explicit <CODE>not</CODE> arount it.  The reason for this asymmetry is that
checking for truth and falsity really amounts to asking two separate and
possibly expensive queries, and the user or programmer should decide
whether the effort should be expended to ask both queries instead of
just one.
</P><P>

PowerLoom can sometimes infer a negative fact without
the necessity of a direct assertion.  For example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(ask (= (number-of-employees acme-cleaners) 8))
=>
TRUE
(ask (= (number-of-employees acme-cleaners) 10))
=>
FALSE
(ask (not (= (number-of-employees acme-cleaners) 10)))
=>
TRUE
</pre></td></tr></table></P><P>

PowerLoom can infer the second and third answers because it knows that
the function <CODE>number-of-employees</CODE> can return only one value, and
if that value is the number eight, it cannot also be something else (in
this case, ten).
</P><P>

Many systems, in particular, database systems and Prolog, make the
assumptions that if a proposition cannot be proved true, then it must be
false. This is called the "closed world assumption". By default,
PowerLoom makes an open-world assumption, but for specific relations it can
be instructed to assume a closed world if a user wants closed world
semantics. For example, suppose we introduce a relation <CODE>works-for</CODE>,
and we assume that all <CODE>works-for</CODE> facts have been entered in our
knowledge base:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defrelation works-for (?p (?c Company)))
(assert (works-for shirly ACME-cleaners))
(assert (works-for jerome zz-productions))
</pre></td></tr></table></P><P>

If we ask PowerLoom whether Jerome does NOT work for MegaSoft, it will
return <CODE>unknown</CODE>.  But if we assert that the relation
<CODE>works-for</CODE> is <CODE>closed</CODE>, then PowerLoom will assume that
Jerome only works for ZZ Productions:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(ask (not (works-for jerome megasoft)))
=>
UNKNOWN

(assert (closed works-for))
(ask (not (works-for jerome megasoft)))
=>
TRUE
</pre></td></tr></table></P><P>

The reasoning employed to achieve the above result (that Jerome does not
work for MegaSoft) is called "negation as failure", which means that
if a proof of a proposition fails, then one may assume that the
proposition is false. We can achieve a negation-as-failure result a
second way (i.e., other than by using a closed world assumption) by
employing the query operator <CODE>fail</CODE>.  Here we retract the closure
assumption for <CODE>works-for</CODE> and achieve the desired result using
<CODE>fail</CODE>:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(retract (closed works-for))
(ask (not (works-for jerome megasoft)))
=>
UNKNOWN

(ask (fail (works-for jerome megasoft)))
=>
TRUE
</pre></td></tr></table></P><P>

When you see the operator "not" in an SQL query or a Prolog program,
it really stands for "fail".
</P><P>

<A NAME="Retraction"></A>
<HR SIZE="6">
<A NAME="SEC25"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC24"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC26"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.8 Retraction </H2>
<!--docid::SEC25::-->
<P>

Below, we introduce a few new terms for defining geographic information.
We define a relation called <CODE>contains</CODE> to assert that one geographic
location (the second argument to <CODE>contains</CODE>) is located within another:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defconcept geographic-location)
(defconcept country (?l geographic-location))
(defconcept state (?l geographic-location))
(defconcept city (?l geographic-location))
(defrelation contains ((?l1 geographic-location) (?l2 geographic-location)))
</pre></td></tr></table></P><P>

Now, we can assert some facts about U.S. geography (including one
deliberate mistake):
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(assert (and 
         (country united-states)
         (geographic-location eastern-us) (contains united-states eastern-us)
         (state georgia) (contains eastern-us georgia)
         (city atlanta) (contains georgia atlanta)
         (geographic-location southern-us) (contains united-states southern-us)
         (state texas) (contains eastern-us texas)
         (city dallas) (contains texas dallas)
         (city austin) (contains texas austin)
         ))
</pre></td></tr></table></P><P>

We would like to repair the incorrect assertion <CODE>(contains eastern-us texas)</CODE>.
The PowerLoom command <CODE>retract</CODE> allows us to erase assertions that
should not be true:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(ask (contains eastern-us texas))
=>
TRUE

(retract (contains eastern-us texas))
(assert (contains southern-us texas))

(ask (contains eastern-us texas))
=>
UNKNOWN
</pre></td></tr></table></P><P>

Retraction should not be confused with assertion of negative propositions.
For example, asserting that Texas is not a state would not retract
the assertion that it is (a state).  Instead, an evident logical contradiction
is detected as a "clash", and the clashing proposition is disallowed:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(assert (not (state texas)))
=>
Derived both TRUE and FALSE for the proposition `|P|(STATE TEXAS)'.
   Clash occurred in module ``|MDL|/PL-KERNEL-KB/business'.

(ask (not (state texas)))
=>
FALSE
</pre></td></tr></table></P><P>

<A NAME="Clipping of Values"></A>
<HR SIZE="6">
<A NAME="SEC26"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC25"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC27"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.9 Clipping of Values </H2>
<!--docid::SEC26::-->
<P>

Programmers are accustomed to changing the values of attributes for
program objects just by overwriting previous values.  PowerLoom implements a
similar semantics for the special case of functions and single-valued
relations.  When a second value is asserted for one of these relations
the previous value is automatically retracted.  We call this <EM>clipping</EM>.
</P><P>

To illustrate this behavior for both kinds of relations (a function is
considered a kind of relation), we will define a mapping from a company to
a city that contains its headquarters in two different ways:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(deffunction headquarters ((?c company)) :-&#62; (?city city))
(defrelation headquartered-in ((?c company) (?city city))
  :axioms (single-valued headquartered-in))
</pre></td></tr></table></P><P>

The clause "<CODE>:axioms (single-valued headquartered-in)</CODE>" tells
PowerLoom that the <CODE>headquartered-in</CODE> relation is single-valued,
i.e., that it can map a company to at most one city.  This makes its
behavior similar to that of the function <CODE>headquarters</CODE>.  Here is
an example of clipping for the function <CODE>headquarters</CODE>:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(assert (= (headquarters zz-productions) atlanta))
(retrieve all ?x (= ?x (headquarters zz-productions)))
=>
There is 1 solution:
  #1: ?X=ATLANTA

(assert (= (headquarters zz-productions) dallas))
(retrieve all ?x (= ?x (headquarters zz-productions)))
=>
There is 1 solution:
  #1: ?X=DALLAS
</pre></td></tr></table> 
Here is the same kind of clipping using a single-valued relation:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(assert (headquartered-in megasoft atlanta))
(retrieve all ?x (headquartered-in megasoft ?x))
=>
There is 1 solution:
  #1: ?X=ATLANTA

(assert (headquartered-in megasoft dallas))
(retrieve all ?x (headquartered-in megasoft ?x))
=>
There is 1 solution:
  #1: ?X=DALLAS
</pre></td></tr></table></P><P>

<A NAME="Rule-based Inference"></A>
<HR SIZE="6">
<A NAME="SEC27"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC26"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC28"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.10 Rule-based Inference </H2>
<!--docid::SEC27::-->
<P>

Suppose that we want to retrieve all geographic locations that are
contained in the Southern US, based on the set of assertions about
geography that we entered in earlier. The following query returns only
one of such location:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(retrieve all ?x (contains southern-us ?x))
=>
There is 1 solution:
  #1: ?X=TEXAS
</pre></td></tr></table></P><P>

We would like the cities Austin and Dallas to be retrieved as well.
To do this, we can assert a <CODE>rule</CODE> that states that <CODE>contains</CODE>
is a transitive relation:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defrule transitive-contains
  (&#60;= (contains ?l1 ?l3)
      (and (contains ?l1 ?l2)
           (contains ?l2 ?l3))))
</pre></td></tr></table></P><P>

The <CODE>defrule</CODE> declaration does two things--it asserts a
proposition, and it associates a name with that proposition (in the
above case, the name is <CODE>transitive-contains</CODE>). This name is used by
the system in displaying traces of its inferencing. It also makes
redefinition of the proposition easier. If we wish to retract an unnamed
proposition, it is necessary to explicitly retract that proposition
using a syntax identical to the assertion<A NAME="DOCF6" HREF="manual_fot.html#FOOT6">(6)</A> If on the
other hand, a proposition has a name, then a new <CODE>defrule</CODE>
declaration that uses the same name will automatically retract any
existing proposition having the same name.
</P><P>

Our transitive closure rule failed to include any logical quantifiers
for the variables <CODE>?l1</CODE>, <CODE>?l2</CODE>, and <CODE>?l3</CODE>.  When PowerLoom
parses a top-level proposition, it automatically supplies universal
quantifiers for any unquantified variables.  So, the above rule is
equivalent to the rule:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defrule transitive-contains
  (forall (?l1 ?l2 ?l3)
          (&#60;= (contains ?l1 ?l3)
              (and (contains ?l1 ?l2)
                   (contains ?l2 ?l3)))))
</pre></td></tr></table></P><P>

Note: Instead of defining a <CODE>transitive-contains</CODE> rule,
we could have achieved the same effect by asserting that the <CODE>contains</CODE>
relation is transitive, e.g., by stating <CODE>(assert (transitive contains))</CODE>.
</P><P>

Now that we have told the system that our <CODE>contains</CODE> relation is
transitive, let us rerun our query:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(retrieve all ?x (contains southern-us ?x))
=>
There are 3 solutions:
  #1: ?X=TEXAS
  #2: ?X=AUSTIN
  #3: ?X=DALLAS
</pre></td></tr></table></P><P>

<A NAME="Explanation"></A>
<HR SIZE="6">
<A NAME="SEC28"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC27"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC29"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.11 Explanation </H2>
<!--docid::SEC28::-->
<P>

PowerLoom provides a command called <CODE>why</CODE> that you can use to
get an explanation of the logic behind one of its answers.  The
<CODE>why</CODE> command explains the last query entered into the system,
i.e., it should invoked after one has submitted a <CODE>retrieve</CODE> or
an <CODE>ask</CODE> command.  Before asking a <CODE>why</CODE> command, you must
enable the justifications feature:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(set-feature justifications)
</pre></td></tr></table></P><P>

Queries execute a bit more slowly with jusifications enabled, which is why it is
disabled by default. Having enabled justifications, we must (re)run a query.
Here is how we can ask why Dallas is contained in the Southern US:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(ask (contains southern-us dallas))
=>
TRUE
(why)
=>
1 (CONTAINS SOUTHERN-US DALLAS)
    follows by Modus Ponens
    and substitution {?l3/DALLAS, ?l2/TEXAS, ?l1/SOUTHERN-US}
    since 1.1 ! (forall (?l1 ?l3)
                   (&#60;= (CONTAINS ?l1 ?l3)
                       (exists (?l2)
                          (and (CONTAINS ?l1 ?l2)
                               (CONTAINS ?l2 ?l3)))))
    and   1.2 ! (CONTAINS SOUTHERN-US TEXAS)
    and   1.3 ! (CONTAINS TEXAS DALLAS)
</pre></td></tr></table></P><P>

The above explanation tells us that a rule (our transitivity rule)
was invoked during the proof, and that two ground assertions
<CODE>(CONTAINS SOUTHERN-US TEXAS)</CODE> and <CODE>(CONTAINS TEXAS DALLAS)</CODE> 
were accessed to supply preconditions for the rule.  These combined
assertions lead to the conclusion <CODE>(CONTAINS SOUTHERN-US DALLAS)</CODE>.
Within an explanation, directly asserted propositions are indicated with
the prefix `!'.
</P><P>

We can also ask <CODE>why</CODE> after a <CODE>retrieve</CODE> query. However, if the
query has multiple solutions, each one has a separate explanation. In order
to ask <CODE>why</CODE>, we need to ask for one solution at a time. This can be
done by omitting the word <CODE>all</CODE> from the <CODE>retrieve</CODE> query, and
subsequently calling <CODE>(retrieve)</CODE> to obtain results one-at-a-time.
@footnote {Note: The order of solutions will not necessarily be the same as
shown here.}
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(retrieve ?x (contains southern-us ?x))
=>
  #1: ?X=DALLAS
(retrieve)
=>
There are 2 solutions so far:
  #1: ?X=DALLAS
  #2: ?X=TEXAS
(retrieve)
=>
There are 3 solutions so far:
  #1: ?X=DALLAS
  #2: ?X=TEXAS
  #3: ?X=AUSTIN
(why)
=>
1 (CONTAINS SOUTHERN-US AUSTIN)
    follows by Modus Ponens
    with substitution {?l1/SOUTHERN-US, ?l3/AUSTIN, ?l2/TEXAS}
    since 1.1 ! (FORALL (?l1 ?l3)
                   (&#60;= (CONTAINS ?l1 ?l3)
                       (EXISTS (?l2)
                          (AND (CONTAINS ?l1 ?l2)
                               (CONTAINS ?l2 ?l3)))))
    and   1.2 ! (CONTAINS SOUTHERN-US TEXAS)
    and   1.3 ! (CONTAINS TEXAS AUSTIN)
</pre></td></tr></table></P><P>

The following query combines a variety of relations that have been
entered into the business modules.  It retrieves names of companies
whose headquarters are in the southern US.  Note that query variables
that do not appear in the output (i.e., variables not listed after the
<CODE>all</CODE>
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(retrieve ?name (exists (?city ?company)
                            (and (contains southern-us ?city)
                                 (headquartered-in ?company ?city)
                                 (company-name ?company ?name))))
=>
There is 1 solution so far:
  #1: ?NAME="MegaSoft, Inc."

(why)
=>
1 (and (COMPANY-NAME MEGASOFT MegaSoft, Inc.)
       (HEADQUARTERED-IN MEGASOFT DALLAS)
       (CONTAINS SOUTHERN-US DALLAS))
    follows by And-Introduction
    since 1.1 ! (COMPANY-NAME MEGASOFT MegaSoft, Inc.)
    and   1.2 ! (HEADQUARTERED-IN MEGASOFT DALLAS)
    and   1.3   (CONTAINS SOUTHERN-US DALLAS)

1.3 (CONTAINS SOUTHERN-US DALLAS)
    follows by Modus Ponens
    and substitution {?l3/DALLAS, ?l2/TEXAS, ?l1/SOUTHERN-US}
    since 1.3.1 ! (forall (?l1 ?l3)
                     (&#60;= (CONTAINS ?l1 ?l3)
                         (exists (?l2)
                            (and (CONTAINS ?l1 ?l2)
                                 (CONTAINS ?l2 ?l3)))))
    and   1.3.2 ! (CONTAINS SOUTHERN-US TEXAS)
    and   1.3.3 ! (CONTAINS TEXAS DALLAS)
</pre></td></tr></table></P><P>

<A NAME="Contexts and Modules"></A>
<HR SIZE="6">
<A NAME="SEC29"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC28"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.12 Contexts and Modules </H2>
<!--docid::SEC29::-->
<P>

The final feature that we will illustrate in this section is the
PowerLoom context mechanism.  PowerLoom organizes its knowledge into a
hierarchy of logical containers called "contexts".  A PowerLoom
context is either a "module", a somewhat heavyweight object that
includes its own symbol table, or a "world", a very lightweight object
designed for fast switching from one world to another.  All contexts
inherit from a single root context.  The most important feature of a
context is that a fact asserted into it is inherited by all contexts
below it.  However, a "parent" context is unaware of any knowledge
entered into one of its descendants.
</P><P>

Here we concern ourselves only with modules.  We first define a second
module, called <CODE>alternate-business</CODE>, to be a subcontext of
our <CODE>business</CODE> module, and then we switch into the new module:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defmodule "alternate-business"
  :includes ("business"))
(in-module "alternate-business")
</pre></td></tr></table></P><P>

Next, within the scope of the <CODE>alternate-business</CODE> module, we will
create a new company.  And just for good measure,
we will change the name of MegaSoft while we are at it:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(assert (and (Company web-phantoms)
             (company-name web-phantoms "Web Phantoms, Inc.")))
(retract (company-name megasoft "MegaSoft, Inc."))
(assert (company-name megasoft "MegaZorch, Inc."))
</pre></td></tr></table></P><P>

First, here are pairs of companies and company names from the vantage
point of the <CODE>Business</CODE> module:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(in-module "business")
(retrieve all (?x ?y) (company-name ?x ?y))
=>
There are 3 solutions:
  #1: ?X=ACME-CLEANERS, ?Y="ACME Cleaners, LTD"
  #2: ?X=MEGASOFT, ?Y="MegaSoft, Inc."
  #3: ?X=MEGASOFT, ?Y="MegaSoft"
</pre></td></tr></table></P><P>

Now observe the same query executed from within the alternate <CODE>Business</CODE>
module:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(in-module "alternate-business")
(retrieve all (?x ?y) (company-name ?x ?y))
=>
There are 4 solutions:
  #1: ?X=ACME-CLEANERS, ?Y="ACME Cleaners, LTD"
  #2: ?X=MEGASOFT, ?Y="MegaZorch, Inc."
  #3: ?X=WEB-PHANTOMS, ?Y="Web Phantoms, Inc."
  #4: ?X=MEGASOFT, ?Y="MegaSoft"
</pre></td></tr></table></P><P>

We see that all facts pertaining to company names have inherited down
from the Business to the Alternate Business module, except for the
name for MegaSoft that we explicitly retracted.  Also, the new
facts asserted within the Alternate Business module appear mixed in
with the inherited facts.
</P><P>

<A NAME="Classification"></A>
<HR SIZE="6">
<A NAME="SEC30"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC29"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC31"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.13 Classification, Subsumption </H2>
<!--docid::SEC30::-->
<P>

<A NAME="Truth Maintenance"></A>
<HR SIZE="6">
<A NAME="SEC31"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC32"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.14 Truth Maintenance </H2>
<!--docid::SEC31::-->
<P>

<A NAME="Inference Control"></A>
<HR SIZE="6">
<A NAME="SEC32"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC31"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC33"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.15 Inference Control </H2>
<!--docid::SEC32::-->
<P>

<A NAME="Keyword Axioms"></A>
<HR SIZE="6">
<A NAME="SEC33"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC32"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC34"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.16 Keyword Axioms </H2>
<!--docid::SEC33::-->
<P>

<A NAME="Cardinality/Type Reasoning with Frame Predicates"></A>
<HR SIZE="6">
<A NAME="SEC34"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC33"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC35"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.17 Cardinality/Type Reasoning with Frame Predicates </H2>
<!--docid::SEC34::-->
<P>

<A NAME="Loom-to-PowerLoom"></A>
<HR SIZE="6">
<A NAME="SEC35"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC34"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC36"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.18 Loom-to-PowerLoom </H2>
<!--docid::SEC35::-->
<P>

<A NAME="Deviations from KIF"></A>
<HR SIZE="6">
<A NAME="SEC36"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC35"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC37"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.19 Deviations from KIF </H2>
<!--docid::SEC36::-->
<P>

<A NAME="Differences from Loom"></A>
<HR SIZE="6">
<A NAME="SEC37"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC36"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC38"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.20 Differences from Loom </H2>
<!--docid::SEC37::-->
<P>

<A NAME="Defaults"></A>
<HR SIZE="6">
<A NAME="SEC38"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC37"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC39"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.21 Defaults </H2>
<!--docid::SEC38::-->
<P>

<A NAME="Sets"></A>
<HR SIZE="6">
<A NAME="SEC39"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC38"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.22 Sets, Lists, SETOFALL, KAPPA </H2>
<!--docid::SEC39::-->
<P>

<A NAME="Communicating with PowerLoom"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC17"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Hans Chalupsky</I> on <I>October, 29  2003</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
