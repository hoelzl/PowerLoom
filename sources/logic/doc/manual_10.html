<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<!-- Created on May, 25  2006 by texi2html 1.65 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>PowerLoom Manual: Miscellaneous</TITLE>

<META NAME="description" CONTENT="PowerLoom Manual: Miscellaneous">
<META NAME="keywords" CONTENT="PowerLoom Manual: Miscellaneous">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.65">

</HEAD>

<BODY LANG="en" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC71"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC70"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_11.html#SEC72"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC63"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_11.html#SEC72"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 10. Miscellaneous </H1>
<!--docid::SEC71::-->
<P>

This is a catch-all section for documented functions, methods and
relations that haven't been categorized yet into any of the previous
sections.  They are in random order and many of them will never be part
of the official PowerLoom interface.  So beware!
</P><P>

<A NAME="IDX331"></A>
<DL>
<DT><U>Method:</U> 2-D-ARRAY <B>2-d-element</B> <I>(array (row INTEGER) (column INTEGER)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the element of <VAR>array</VAR> at position [<VAR>row</VAR>, <VAR>column</VAR>].
</DL>
</P><P>

<A NAME="IDX332"></A>
<DL>
<DT><U>Method:</U> 2-D-FLOAT-ARRAY <B>2-d-element</B> <I>(array (row INTEGER) (column INTEGER)) : FLOAT</I>
<DD>Return the element of <VAR>array</VAR> at position [<VAR>row</VAR>, <VAR>column</VAR>].
</DL>
</P><P>

<A NAME="IDX333"></A>
<DL>
<DT><U>Method:</U> 2-D-ARRAY <B>2-d-element-setter</B> <I>(array (value OBJECT) (row INTEGER) (column INTEGER)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Set the element of <VAR>array</VAR> at position [<VAR>row</VAR>, <VAR>column</VAR>]
to <VAR>value</VAR> and return the result.
</DL>
</P><P>

<A NAME="IDX334"></A>
<DL>
<DT><U>Method:</U> 2-D-FLOAT-ARRAY <B>2-d-element-setter</B> <I>(array (value FLOAT) (row INTEGER) (column INTEGER)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Set the element of <VAR>array</VAR> at position [<VAR>row</VAR>, <VAR>column</VAR>]
to <VAR>value</VAR> and return the result.
</DL>
</P><P>

<A NAME="IDX335"></A>
<DL>
<DT><U>N-Command:</U> <B>add-testing-example</B> <I>((form CONS) (score PARTIAL-MATCH-SCORE)) :</I>
<DD>Add a query and score pair to the master list of 
  testing examples
</DL>
</P><P>

<A NAME="IDX336"></A>
<DL>
<DT><U>N-Command:</U> <B>add-training-example</B> <I>((form CONS) (score PARTIAL-MATCH-SCORE)) :</I>
<DD>Add a query and score pair to the master list of 
  training examples
</DL>
</P><P>

<A NAME="IDX337"></A>
<DL>
<DT><U>Function:</U> <B>all-asserted-types</B> <I>((self OBJECT)) : (CONS OF NAMED-DESCRIPTION)</I>
<DD>Return a set of all of the types that are
asserted to be satisfied by <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX338"></A>
<DL>
<DT><U>Function:</U> <B>all-class-instances</B> <I>((type SURROGATE)) : CONS</I>
<DD>Return a set of instances that belong to the class <VAR>type</VAR>.
</DL>
</P><P>

<A NAME="IDX339"></A>
<DL>
<DT><U>Function:</U> <B>all-cycles</B> <I>((module MODULE) (local? BOOLEAN)) : (CONS OF CONS)</I>
<DD>Return a list of lists of descriptions that are
provably co-extensional.
</DL>
</P><P>

<A NAME="IDX340"></A>
<DL>
<DT><U>Function:</U> <B>all-direct-subrelations</B> <I>((relation NAMED-DESCRIPTION) (removeEquivalents? BOOLEAN)) : (CONS OF NAMED-DESCRIPTION)</I>
<DD>Return a set of relations that immediately specialize
<VAR>relation</VAR>.  If <VAR>removeEquivalents?</VAR> (recommended), don't include any
relations equivalent to <VAR>relation</VAR>.
</DL>
</P><P>

<A NAME="IDX341"></A>
<DL>
<DT><U>Function:</U> <B>all-direct-superrelations</B> <I>((relation NAMED-DESCRIPTION) (removeEquivalents? BOOLEAN)) : (CONS OF NAMED-DESCRIPTION)</I>
<DD>Return a set of relations that immediately subsume
<VAR>relation</VAR>.  If <VAR>removeEquivalents?</VAR> (recommended), don't include any
relations equivalent to <VAR>relation</VAR>.
</DL>
</P><P>

<A NAME="IDX342"></A>
<DL>
<DT><U>Function:</U> <B>all-direct-types</B> <I>((self OBJECT)) : (CONS OF LOGIC-OBJECT)</I>
<DD>Return a set of most specific types that are
satisfied by <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX343"></A>
<DL>
<DT><U>Function:</U> <B>all-equivalent-relations</B> <I>((relation NAMED-DESCRIPTION) (reflexive? BOOLEAN)) : (CONS OF NAMED-DESCRIPTION)</I>
<DD>Return a list of all relations equivalent to <VAR>relation</VAR>.
If <VAR>reflexive?</VAR>, include <VAR>relation</VAR> in the list.
</DL>
</P><P>

<A NAME="IDX344"></A>
<DL>
<DT><U>Function:</U> <B>all-facts-of-instance</B> <I>((self OBJECT) (includeunknownfacts? BOOLEAN) (elaborate? BOOLEAN)) : (LIST OF PROPOSITION)</I>
<DD>Return a list of all definite (TRUE or FALSE) propositions
attached to <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX345"></A>
<DL>
<DT><U>N-Command:</U> <B>all-facts-of-n</B> <I>((n INTEGER) &#38;rest (instanceRefs NAME)) : (CONS OF PROPOSITION)</I>
<DD>This is a generalization of <CODE>all-facts-of</CODE> (which see).  With <VAR>n</VAR> = 0
and only one instance this command behaves just like <CODE>all-facts-of</CODE>.
Otherwise, returns a cons list of all definite (TRUE or FALSE) propositions
that reference any of the instances listed in <VAR>instanceRefs</VAR>, plus if <VAR>n</VAR> &#62;= 1
all propositions that reference any instances that are arguments of
propositions collected in the previous step, plus if <VAR>n</VAR> &#62;= 2... and so on.
That is, if we only consider binary propositions, this can be viewed as
growing a graph with instances as its nodes and predicates as its arcs
starting from the set of seed <VAR>instanceRefs</VAR> to depth <VAR>n</VAR>-1.
Caution: with a fully connected KB and large enough <VAR>n</VAR> this could return
the whole knowledge base.
</P><P>

The returned propositions include those asserted to be true or false by
default, but it does not include propositions that are found to be
true only by running the query engine.  Facts inferred to be true by
the forward chainer will be included.  Hence, the returned list of
facts may be longer in a context where the forward chainer has been
run then in one where it has not (see <CODE>run-forward-rules</CODE>).
</DL>
</P><P>

<A NAME="IDX346"></A>
<DL>
<DT><U>Function:</U> <B>all-instances</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF LOGIC-OBJECT)</I>
<DD>Iterate over all instances (or individuals) visible from <VAR>module</VAR>.
Only instances that haven't been deleted will be considered.  If <VAR>local?</VAR>,
only return instances created locally in <VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX347"></A>
<DL>
<DT><U>Function:</U> <B>all-named-descriptions</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF NAMED-DESCRIPTION)</I>
<DD>Iterate over all named descriptions visible from <VAR>module</VAR>.
If <VAR>local?</VAR>, return only named descriptions interned in <VAR>module</VAR>.
If <VAR>module</VAR> is null, return all named descriptions interned everywhere.
</DL>
</P><P>

<A NAME="IDX348"></A>
<DL>
<DT><U>Function:</U> <B>all-named-instances</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF LOGIC-OBJECT)</I>
<DD>Iterate over all named instances (or individuals) visible from <VAR>module</VAR>.
Only instances that haven't been deleted will be considered.  If <VAR>local?</VAR>,
only return instances created locally in <VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX349"></A>
<DL>
<DT><U>Function:</U> <B>all-named-terms</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF OBJECT)</I>
<DD>Iterate over all named terms visible from <VAR>module</VAR>.  A term can be an
instance (or individual) as well as a description.  Only terms that
haven't been deleted will be considered.  If <VAR>local?</VAR>, only return 
terms created locally in <VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX350"></A>
<DL>
<DT><U>Function:</U> <B>all-propositions</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF PROPOSITION)</I>
<DD>Iterate over all conceived propositions visible from <VAR>module</VAR>.
Only propositions that haven't been deleted will be considered.
If <VAR>local?</VAR>, only return propositions conceived locally in <VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX351"></A>
<DL>
<DT><U>Function:</U> <B>all-relation-values</B> <I>((relation SURROGATE) (nMinusOneArguments CONS)) : CONS</I>
<DD>Return a set of values that satisfy the relation
<VAR>relation</VAR> (a surrogate) applied to <VAR>nMinusOneArguments</VAR> plus that last value.
</DL>
</P><P>

<A NAME="IDX352"></A>
<DL>
<DT><U>Command:</U> <B>all-sentences-of</B> <I>((instanceRef OBJECT)) : (CONS OF STRING-WRAPPER)</I>
<DD>Return a list of sentences describing facts about <VAR>instanceRef</VAR>.
</DL>
</P><P>

<A NAME="IDX353"></A>
<DL>
<DT><U>Function:</U> <B>all-slot-value-types</B> <I>((self LOGIC-OBJECT) (relation SURROGATE)) : (CONS OF NAMED-DESCRIPTION)</I>
<DD>Return a set of the most specific types for fillers
of the slot <VAR>relation</VAR> applied to <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX354"></A>
<DL>
<DT><U>Function:</U> <B>all-slot-values</B> <I>((self LOGIC-OBJECT) (relation SURROGATE)) : CONS</I>
<DD>Return a set of values for the slot <VAR>relation</VAR> (a surrogate)
applied to <VAR>self</VAR> (an object).
</DL>
</P><P>

<A NAME="IDX355"></A>
<DL>
<DT><U>Function:</U> <B>all-subrelations</B> <I>((relation NAMED-DESCRIPTION) (removeequivalents? BOOLEAN)) : (CONS OF NAMED-DESCRIPTION)</I>
<DD>Return a set of all (named) relations that specialize
relation.
</DL>
</P><P>

<A NAME="IDX356"></A>
<DL>
<DT><U>Function:</U> <B>all-superrelations</B> <I>((relation NAMED-DESCRIPTION) (removeequivalents? BOOLEAN)) : (CONS OF NAMED-DESCRIPTION)</I>
<DD>Return a set of all relations that subsume relation.
</DL>
</P><P>

<A NAME="IDX357"></A>
<DL>
<DT><U>Function:</U> <B>all-terms</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF OBJECT)</I>
<DD>Return a list of all terms visible from <VAR>module</VAR>.  A term can be an
instance (or individual) as well as a description.  Only terms that
haven't been deleted will be considered.  If <VAR>local?</VAR>, only return 
terms created locally in <VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX358"></A>
<DL>
<DT><U>Function:</U> <B>all-types</B> <I>((self OBJECT)) : (CONS OF NAMED-DESCRIPTION)</I>
<DD>Return a set of all of the types that are
satisfied by <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX359"></A>
<DL>
<DT><U>Function:</U> <B>all-unnamed-terms</B> <I>((module MODULE) (local? BOOLEAN)) : ITERATOR</I>
<DD>Iterate over all unnamed terms visible from <VAR>module</VAR>.  A term can be
an instance (or individual) as well as a description.  Only terms that
haven't been deleted will be considered.  If <VAR>local?</VAR>, only return
terms created locally in <VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX360"></A>
<DL>
<DT><U>Function:</U> <B>allocate-supported-closure-iterator</B> <I>((startnode CONS) (allocateadjacencyiterator FUNCTION-CODE) (filterfunction FUNCTION-CODE)) : SUPPORTED-CLOSURE-ITERATOR</I>
<DD>Similar to <CODE>allocate-transitive-closure-iterator</CODE> (which see),
but return a SUPPORTED-CLOSURE-ITERATOR instead.
</DL>
</P><P>

<A NAME="IDX361"></A>
<DL>
<DT><U>Function:</U> <B>allocate-transitive-closure-iterator</B> <I>((startNode OBJECT) (allocateAdjacencyIterator FUNCTION-CODE) (filterFunction FUNCTION-CODE)) : ITERATOR</I>
<DD>Return an iterator that generates the transitive
closure of applying iterators generated by <VAR>allocateAdjacencyIterator</VAR>
to <VAR>startNode</VAR>.  If <VAR>filterFunction</VAR> is non-null, that function is applied
as a filter to each node generated (nodes filtered out still generate
descendants, but they don't get returned).
</DL>
</P><P>

<A NAME="IDX362"></A>
<DL>
<DT><U>Macro:</U> <B>apply-ask</B> <I>(&#38;body (body CONS)) : OBJECT</I>
<DD>Execute a yes/no query composed of input-variables
<CODE>inputVariables</CODE> and body <CODE>queryBody</CODE>.  Before executing, bind variables
to <CODE>inputBindings</CODE> (in sequence).
  <CODE>(apply-ask inputVariables queryBody inputBindings)</CODE>
</DL>
</P><P>

<A NAME="IDX363"></A>
<DL>
<DT><U>Function:</U> <B>apply-kappa?</B> <I>((description DESCRIPTION) (vector VECTOR)) : BOOLEAN</I>
<DD>Apply (inherit) the description <VAR>description</VAR>
to members of the vector <VAR>vector</VAR>.  Return TRUE if no clash was detected.
Constraint propagation happens only if it is enabled prior to calling
<CODE>apply-kappa?</CODE>.
</DL>
</P><P>

<A NAME="IDX364"></A>
<DL>
<DT><U>Macro:</U> <B>apply-retrieve</B> <I>(&#38;body (body CONS)) : OBJECT</I>
<DD>Execute a query composed of io-variables <CODE>variables</CODE>
and body <CODE>queryBody</CODE>.  Before executing, bind variables to <CODE>inputBindings</CODE>
(in sequence). If one variable is left unbound, returns a cons list of
bindings of that variable.  If two or more are unbound, returns
a cons list of cons lists of bindings:
  <CODE>(apply-retrieve variables queryBody inputBindings)</CODE>
</DL>
</P><P>

<A NAME="IDX365"></A>
<DL>
<DT><U>N-Command:</U> <B>ask-partial</B> <I>(&#38;rest (proposition&#38;options PARSE-TREE)) : FLOAT</I>
<DD>Similar to <CODE>ask</CODE> (which see), but return the highest partial match score
for the supplied proposition instead of a truth value.  If the option
:MAXIMIZE-SCORE? is set to FALSE, return after the first partial match score
has been generated.
</DL>
</P><P>

<A NAME="IDX366"></A>
<DL>
<DT><U>Function:</U> <B>bottom?</B> <I>((self OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>self</VAR> is the undefined individual BOTTOM.
</DL>
</P><P>

<A NAME="IDX367"></A>
<DL>
<DT><U>Command:</U> <B>call-all-facts-of</B> <I>((instanceRef OBJECT)) : (LIST OF PROPOSITION)</I>
<DD>Return a list of all definite (TRUE or FALSE) propositions
that reference the instance <VAR>instanceRef</VAR>.
</DL>
</P><P>

<A NAME="IDX368"></A>
<DL>
<DT><U>Function:</U> <B>call-ask</B> <I>((query OBJECT)) : TRUTH-VALUE</I>
<DD>Callable version of <CODE>ask</CODE> (which see).  Accepts queries
specified by a query iterator, or specified as a CONS-list of arguments as they
would be supplied to <CODE>ask</CODE>.  Raises LOGIC-EXCEPTIONs in case of illegal
queries and logical expressions.
</DL>
</P><P>

<A NAME="IDX369"></A>
<DL>
<DT><U>Function:</U> <B>call-defconcept</B> <I>((arguments CONS)) : NAMED-DESCRIPTION</I>
<DD>Callable version of the <CODE>defconcept</CODE> command (which see).
Expects the same arguments as <CODE>defconcept</CODE> but supplied as a list.
</DL>
</P><P>

<A NAME="IDX370"></A>
<DL>
<DT><U>Function:</U> <B>call-deffunction</B> <I>((arguments CONS)) : NAMED-DESCRIPTION</I>
<DD>Callable version of the <CODE>deffunction</CODE> command (which see).
Expects the same arguments as <CODE>deffunction</CODE> but supplied as a list.
</DL>
</P><P>

<A NAME="IDX371"></A>
<DL>
<DT><U>Function:</U> <B>call-defobject</B> <I>((arguments CONS)) : LOGIC-OBJECT</I>
<DD>Callable version of the <CODE>defobject</CODE> command (which see).
Expects the same arguments as <CODE>defobject</CODE> but supplied as a list.
</DL>
</P><P>

<A NAME="IDX372"></A>
<DL>
<DT><U>Function:</U> <B>call-defproposition</B> <I>((arguments CONS)) : PROPOSITION</I>
<DD>Callable version of the <CODE>defproposition</CODE> command (which see).
Expects the same arguments as <CODE>defproposition</CODE> but supplied as a list.
</DL>
</P><P>

<A NAME="IDX373"></A>
<DL>
<DT><U>Function:</U> <B>call-defrelation</B> <I>((arguments CONS)) : NAMED-DESCRIPTION</I>
<DD>Callable version of the <CODE>defrelation</CODE> command (which see).
Expects the same arguments as <CODE>defrelation</CODE> but supplied as a list.
</DL>
</P><P>

<A NAME="IDX374"></A>
<DL>
<DT><U>Function:</U> <B>call-list-undefined-relations</B> <I>((module MODULE) (local? BOOLEAN)) : CONS</I>
<DD>Callable version of <CODE>list-undefined-relations</CODE> (which see).
</DL>
</P><P>

<A NAME="IDX375"></A>
<DL>
<DT><U>Function:</U> <B>call-propagate-constraints</B> <I>((context CONTEXT)) :</I>
<DD>Trigger constraint propagation over all propositions
in the module or world <VAR>context</VAR>.
</DL>
</P><P>

<A NAME="IDX376"></A>
<DL>
<DT><U>Function:</U> <B>call-retrieve</B> <I>((query OBJECT)) : QUERY-ITERATOR</I>
<DD>Callable version of <CODE>retrieve</CODE> (which see).  Accepts queries
specified by a query iterator, or specified as a CONS-list of arguments as they
would be supplied to <CODE>retrieve</CODE>.  Raises LOGIC-EXCEPTIONs in case of illegal
queries and logical expressions.
</DL>
</P><P>

<A NAME="IDX377"></A>
<DL>
<DT><U>Function:</U> <B>call-retrieve-partial</B> <I>((query OBJECT)) : QUERY-ITERATOR</I>
<DD>Callable version of <CODE>retrieve-partial</CODE> (which see).  Accepts queries
specified by a query iterator, or specified as a CONS-list of arguments as they
would be supplied to <CODE>retrieve-partial</CODE>.  Raises LOGIC-EXCEPTIONs in case of
illegal queries and logical expressions.
</DL>
</P><P>

<A NAME="IDX378"></A>
<DL>
<DT><U>Function:</U> <B>call-run-forward-rules</B> <I>((module MODULE) (force? BOOLEAN)) :</I>
<DD>Run forward inference rules in module <VAR>module</VAR>. If <VAR>module</VAR>
is NULL, the current module will be used.  If forward inferencing is already
up-to-date in the designated module, no additional inferencing will occur,
unless <VAR>force?</VAR> is set to TRUE, in which case all forward rules are run or rerun.
</DL>
</P><P>

<A NAME="IDX379"></A>
<DL>
<DT><U>Function:</U> <B>call-set-inference-level</B> <I>((levelKeyword KEYWORD) (module MODULE)) : KEYWORD</I>
<DD>Set the inference level of <VAR>module</VAR> to the level specified
by <VAR>levelKeyword</VAR>.  If <VAR>module</VAR> is NULL and we are inside a query, set the
level of the current query iterator.  Otherwise, set the level globally.
</DL>
</P><P>

<A NAME="IDX380"></A>
<DL>
<DT><U>Function:</U> <B>class?</B> <I>((objectRef OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>objectRef</VAR> denotes a class.
</DL>
</P><P>

<A NAME="IDX381"></A>
<DL>
<DT><U>Function:</U> <B>coerce-to-instance</B> <I>((self OBJECT) (original OBJECT)) : LOGIC-OBJECT</I>
<DD>Return the logic instance referred to by <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX382"></A>
<DL>
<DT><U>Function:</U> <B>coerce-to-instance-or-literal</B> <I>((self OBJECT) (original OBJECT)) : OBJECT</I>
<DD>Return the logic instance referred to by <VAR>self</VAR>, or <VAR>self</VAR> if it is a
literal (e.g., string or number) that can't be coerced.
</DL>
</P><P>

<A NAME="IDX383"></A>
<DL>
<DT><U>Function:</U> <B>coerce-to-vector</B> <I>((self OBJECT)) : VECTOR</I>
<DD>Return a vector containing the elements in <VAR>self</VAR>.
Coerce each element of <VAR>self</VAR> to be a logic object or literal.
</DL>
</P><P>

<A NAME="IDX384"></A>
<DL>
<DT><U>Function:</U> <B>collection?</B> <I>((objectRef OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>objectRef</VAR> denotes a relation or a class.
</DL>
</P><P>

<A NAME="IDX385"></A>
<DL>
<DT><U>Command:</U> <B>conceive-term</B> <I>((tree OBJECT)) : OBJECT</I>
<DD><VAR>tree</VAR> is a term expression (a string or an s-expression),
or is a class reference (a symbol or surrogate).  Return a (possibly 
newly-conceived) term representing the internalized representation of that term.
</DL>
</P><P>

<A NAME="IDX386"></A>
<DL>
<DT><U>Function:</U> <B>conjoin-truth-values</B> <I>((tv1 TRUTH-VALUE) (tv2 TRUTH-VALUE)) : TRUTH-VALUE</I>
<DD>Return the logical conjunction of truth values <VAR>tv1</VAR> and <VAR>tv2</VAR>.
</DL>
</P><P>

<A NAME="IDX387"></A>
<DL>
<DT><U>Method:</U> QUERY-ITERATOR <B>consify</B> <I>(self) : CONS</I>
<DD>Generate all solutions for the query self, and collect them into a cons list
of result tuples.  If <CODE>:SINGLETONS? TRUE</CODE>, collect a list of atoms rather than a
list of lists for tuples of arity=1.
</DL>
</P><P>

<A NAME="IDX388"></A>
<DL>
<DT><U>Method:</U> QUERY-SOLUTION-TABLE <B>consify</B> <I>(self) : CONS</I>
<DD>Collect all solutions of <VAR>self</VAR> into a cons list and return the result.
</DL>
</P><P>

<A NAME="IDX389"></A>
<DL>
<DT><U>Method:</U> JUSTIFICATION <B>consify</B> <I>(self) : CONS</I>
<DD>Return a CONS tree representation of the proof <VAR>self</VAR>.
Each proof step is represented as a CONS tree of the form
  (&#60;proposition&#62; (&#60;key&#62; &#60;value&#62;...) &#60;antecedent&#62;...)
where each &#60;antecedent&#62; is a CONS tree representing a subproof.  The
consification follows the original proof structure literally, i.e., no
uninteresting nodes such as patterns or AND-introductions are suppressed.
</DL>
</P><P>

<A NAME="IDX390"></A>
<DL>
<DT><U>Method:</U> QUERY-ITERATOR <B>consify-current-solutions</B> <I>(self) : CONS</I>
<DD>Collect the current solutions of <VAR>self</VAR> into a cons list
of result tuples.  If <CODE>:SINGLETONS? TRUE</CODE>, collect a list of atoms rather than a
list of lists for tuples of arity=1.
</DL>
</P><P>

<A NAME="IDX391"></A>
<DL>
<DT><U>Function:</U> <B>consify-justification</B> <I>((self JUSTIFICATION) (style KEYWORD)) : CONS</I>
<DD>Return a CONS tree representation of the proof <VAR>self</VAR>.
Each proof step is represented as a CONS tree of the form
  (&#60;proposition&#62; (&#60;key&#62; &#60;value&#62;...) &#60;antecedent&#62;...)
where each &#60;antecedent&#62; is a CONS tree representing a subproof.
<VAR>style</VAR> indicates what nodes in the proof tree should be suppressed.
:RAW preserves the original structure literally, :VERBOSE keeps AND-
introductions but suppresses all auxiliary (non-logical) nodes such as
pattern nodes, and :BRIEF additionally suppresses AND-introduction nodes.
</DL>
</P><P>

<A NAME="IDX392"></A>
<DL>
<DT><U>Function:</U> <B>constant?</B> <I>((objectRef OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>objectRef</VAR> denotes a literal or scalar.
</DL>
</P><P>

<A NAME="IDX393"></A>
<DL>
<DT><U>Method:</U> JUSTIFICATION <B>copy</B> <I>(self) : (LIKE SELF)</I>
<DD>Return a copy of the proof starting at <VAR>self</VAR>.  Allocates
all new justification objects, but structure-shares other information such
as propositions and substitutions.
</DL>
</P><P>

<A NAME="IDX394"></A>
<DL>
<DT><U>N-Command:</U> <B>create</B> <I>((name GENERALIZED-SYMBOL) &#38;rest (type GENERALIZED-SYMBOL)) : OBJECT</I>
<DD>Create a logic object with name <VAR>name</VAR> and return it.
If <VAR>type</VAR> is also supplied, assert that the object belongs to that type.
</DL>
</P><P>

<A NAME="IDX395"></A>
<DL>
<DT><U>Function:</U> <B>create-2-d-array</B> <I>((nof-rows INTEGER) (nof-columns INTEGER) &#38;rest (values OBJECT)) : 2-D-ARRAY</I>
<DD>Create a two-dimensional array with <VAR>nof-rows</VAR> rows and
<VAR>nof-columns</VAR> columns, and initialize it in row-major-order from <VAR>values</VAR>.
Missing values will be padded with NULL, extraneous values will be ignored.
</DL>
</P><P>

<A NAME="IDX396"></A>
<DL>
<DT><U>Function:</U> <B>create-2-d-float-array</B> <I>((nof-rows INTEGER) (nof-columns INTEGER) &#38;rest (values FLOAT)) : 2-D-FLOAT-ARRAY</I>
<DD>Create a two-dimensional array with <VAR>nof-rows</VAR> rows and
<VAR>nof-columns</VAR> columns, and initialize it in row-major-order from <VAR>values</VAR>.
Missing values will be padded with NULL, extraneous values will be ignored.
</DL>
</P><P>

<A NAME="IDX397"></A>
<DL>
<DT><U>Function:</U> <B>create-float-vector</B> <I>(&#38;rest (values FLOAT)) : FLOAT-VECTOR</I>
<DD>Return a vector containing <VAR>values</VAR>, in order.
</DL>
</P><P>

<A NAME="IDX398"></A>
<DL>
<DT><U>Function:</U> <B>create-marker-storage</B> <I>((supportRecall? BOOLEAN)) : MARKER-TABLE</I>
<DD>Return a new marker storage object, used to
remember with objects have been <CODE>marked</CODE>.  If <VAR>supportRecall?</VAR>
is set, then the iterator <CODE>recall-marked-objects</CODE> can be invoked
on the new marker storage object.
</DL>
</P><P>

<A NAME="IDX399"></A>
<DL>
<DT><U>Function:</U> <B>create-vector</B> <I>(&#38;rest (values OBJECT)) : VECTOR</I>
<DD>Return a vector containing <VAR>values</VAR>, in order.
</DL>
</P><P>

<A NAME="IDX400"></A>
<DL>
<DT><U>Command:</U> <B>current-inference-level</B> <I>() : NORMAL-INFERENCE-LEVEL</I>
<DD>Return the current inference level that is active in the
current query, the current module, or, otherwise, globally.
</DL>
</P><P>

<A NAME="IDX401"></A>
<DL>
<DT><U>Function:</U> <B>default-false?</B> <I>((self PROPOSITION)) : BOOLEAN</I>
<DD>Return true if <VAR>self</VAR> is default false.
</DL>
</P><P>

<A NAME="IDX402"></A>
<DL>
<DT><U>Function:</U> <B>default-true?</B> <I>((self PROPOSITION)) : BOOLEAN</I>
<DD>Return true if <VAR>self</VAR> is default true.
</DL>
</P><P>

<A NAME="IDX403"></A>
<DL>
<DT><U>Function:</U> <B>default-truth-value?</B> <I>((self TRUTH-VALUE)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>self</VAR> is a default truth value.
</DL>
</P><P>

<A NAME="IDX404"></A>
<DL>
<DT><U>Macro:</U> <B>define-arithmetic-operation-on-wrappers</B> <I>((name SYMBOL) (operation-name SYMBOL)) : OBJECT</I>
<DD>Defines <VAR>name</VAR> as an arithmetic comparision operation using the
test <CODE>test-name</CODE>.  It will take two wrapped number parameters and
return a wrapped number.  The code will use the appropriate test
for the specific subtype of wrapped number actually passed in,
and return the appropriate subtype of wrapped number based on the
normal arithmetic contagion rules.
  
For example, if both input parameters are wrapped integers then
the output will be a wrapped integer.  If the inputs are a
wrapped integer and a wrapped float then the output will be a
wrapped float, etc.
</DL>
</P><P>

<A NAME="IDX405"></A>
<DL>
<DT><U>Macro:</U> <B>define-arithmetic-test-on-wrappers</B> <I>((name SYMBOL) (test-name SYMBOL)) : OBJECT</I>
<DD>Defines <VAR>name</VAR> as an arithmetic comparision operation using the
test <VAR>test-name</VAR>.  It will take two wrapped number parameters and
return a <CODE>boolean</CODE>.  The code will use the appropriate test for
the specific subtype of wrapped number actually passed in.
</DL>
</P><P>

<A NAME="IDX406"></A>
<DL>
<DT><U>Macro:</U> <B>define-computed-constraint</B> <I>((name SYMBOL) (var-list CONS) (constraint-test CONS) &#38;body (position-computations CONS)) : OBJECT</I>
<DD>Defines <VAR>name</VAR> to be a constraint computation which uses
<VAR>constraint-test</VAR> to determine if a fully bound set of variables
satisfies the constraint.  The forms in <VAR>position-computations</VAR>
are used to compute the value for each of the positions. All such
computations must set the variable <CODE>value</CODE> to be the result
computed for the missing position.  Setting <CODE>value</CODE> to <CODE>null</CODE> for
any such computation means that that particular argument cannot
be computed from the others.  The input variables in <VAR>var-list</VAR>
will be bound to the N arguments to the constraint.
  The generated function will return a Stella Object and take as 
inputs the values of the N arguments to the constraint.  A value
of <CODE>null</CODE> means that the value is not available.  If all
arguments are not <CODE>null</CODE>, then the return value will be a Stella
wrapped boolean indicating whether the constraint is satisified
or not.
  If more than one input value is <CODE>null</CODE>, then this constraint
code will not be called.
</DL>
</P><P>

<A NAME="IDX407"></A>
<DL>
<DT><U>Function:</U> <B>deobjectify-tree</B> <I>((self OBJECT)) : OBJECT</I>
<DD>Return a copy of <VAR>self</VAR> where all logic objects are
replaced by their <CODE>generated</CODE> parse-tree version.  This is useful to
convert the result of a retrieval query into a regular parse tree.
</DL>
</P><P>

<A NAME="IDX408"></A>
<DL>
<DT><U>Method:</U> NAMED-DESCRIPTION <B>describe-object</B> <I>(self (stream OUTPUT-STREAM) (mode KEYWORD)) :</I>
<DD>Prints a description of <VAR>self</VAR> to stream <VAR>stream</VAR>.  <VAR>mode</VAR>
can be :terse, :verbose, or :source.  Used by <CODE>describe</CODE>.
</DL>
</P><P>

<A NAME="IDX409"></A>
<DL>
<DT><U>Method:</U> NAMED-DESCRIPTION <B>description-name</B> <I>(self) : SYMBOL</I>
<DD>Return the name of the description <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX410"></A>
<DL>
<DT><U>Method:</U> DESCRIPTION <B>description-name</B> <I>(self) : SYMBOL</I>
<DD>Return the name of the description <VAR>self</VAR>, if it has one.
</DL>
</P><P>

<A NAME="IDX411"></A>
<DL>
<DT><U>Function:</U> <B>destroy-instance</B> <I>((self OBJECT)) :</I>
<DD>Destroy all propositions that reference <VAR>self</VAR>,
and mark it as <CODE>deleted?</CODE>, thereby making it invisible within class
extensions.
</DL>
</P><P>

<A NAME="IDX412"></A>
<DL>
<DT><U>Function:</U> <B>destroy-object</B> <I>((self OBJECT)) :</I>
<DD>Destroy <VAR>self</VAR> which can be a term or a proposition.  Destroy all
propositions that reference <VAR>self</VAR> and mark it as <CODE>deleted?</CODE> (thereby
making it invisible within class extensions).
</DL>
</P><P>

<A NAME="IDX413"></A>
<DL>
<DT><U>Function:</U> <B>destroy-proposition</B> <I>((proposition PROPOSITION)) : PROPOSITION</I>
<DD>Retract and destroy the proposition <VAR>proposition</VAR>.
Recursively destroy all propositions that reference <VAR>proposition</VAR>.
Also, destroy all satellite propositions of <VAR>proposition</VAR>.
</DL>
</P><P>

<A NAME="IDX414"></A>
<DL>
<DT><U>Function:</U> <B>destroy-term</B> <I>((self LOGIC-OBJECT)) :</I>
<DD>Destroy all propositions that reference <VAR>self</VAR>,
and mark it as <CODE>deleted?</CODE>, thereby making it invisible within class
extensions.  Unlink descriptions from native relations.
</DL>
</P><P>

<A NAME="IDX415"></A>
<DL>
<DT><U>Function:</U> <B>direct-superrelations</B> <I>((self RELATION)) : (ITERATOR OF (LIKE SELF))</I>
<DD>Return direct super classes/slots of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX416"></A>
<DL>
<DT><U>Function:</U> <B>disabled-powerloom-feature?</B> <I>((feature KEYWORD)) : BOOLEAN</I>
<DD>Return true if the STELLA <VAR>feature</VAR> is currently disabled.
</DL>
</P><P>

<A NAME="IDX417"></A>
<DL>
<DT><U>Function:</U> <B>disjoin-truth-values</B> <I>((tv1 TRUTH-VALUE) (tv2 TRUTH-VALUE)) : TRUTH-VALUE</I>
<DD>Return the logical disjunction of truth values <VAR>tv1</VAR> and <VAR>tv2</VAR>.
</DL>
</P><P>

<A NAME="IDX418"></A>
<DL>
<DT><U>Function:</U> <B>disjoint-terms?</B> <I>((d1 DESCRIPTION) (d2 DESCRIPTION)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>d1</VAR> and <VAR>d2</VAR> belong to disjoint partitions.
</DL>
</P><P>

<A NAME="IDX419"></A>
<DL>
<DT><U>Function:</U> <B>do-clear-instances</B> <I>((module MODULE)) :</I>
<DD>Function version of <CODE>clear-instances</CODE> that evaluates its argument.
</DL>
</P><P>

<A NAME="IDX420"></A>
<DL>
<DT><U>Function:</U> <B>do-save-module</B> <I>((module MODULE) (store OBJECT)) :</I>
<DD>Save <VAR>module</VAR> to the persistent store <VAR>store</VAR> which can
either be an output stream or a persistent OBJECT-STORE.
</DL>
</P><P>

<A NAME="IDX421"></A>
<DL>
<DT><U>Method:</U> QUERY-SOLUTION-TABLE <B>empty?</B> <I>(self) : BOOLEAN</I>
<DD>Return TRUE if <VAR>self</VAR> has zero entries.
</DL>
</P><P>

<A NAME="IDX422"></A>
<DL>
<DT><U>Method:</U> FLOAT-VECTOR <B>empty?</B> <I>(self) : BOOLEAN</I>
<DD>Return TRUE if <VAR>self</VAR> has length 0.
</DL>
</P><P>

<A NAME="IDX423"></A>
<DL>
<DT><U>Function:</U> <B>enabled-powerloom-feature?</B> <I>((feature KEYWORD)) : BOOLEAN</I>
<DD>Return true if the STELLA <VAR>feature</VAR> is currently enabled.
</DL>
</P><P>

<A NAME="IDX424"></A>
<DL>
<DT><U>Method:</U> PAGING-INDEX <B>estimated-length</B> <I>(self) : INTEGER</I>
<DD>Return the estimated length of the sequences in <VAR>self</VAR>,
which could be too large if some of the members have been deleted.
</DL>
</P><P>

<A NAME="IDX425"></A>
<DL>
<DT><U>Function:</U> <B>explain-why</B> <I>((label STRING) (style KEYWORD) (maxdepth INTEGER) (stream OUTPUT-STREAM)) :</I>
<DD>Programmer's interface to WHY function.
</DL>
</P><P>

<A NAME="IDX426"></A>
<DL>
<DT><U>Function:</U> <B>explain-whynot</B> <I>((label STRING) (style KEYWORD) (maxdepth INTEGER) (summary? BOOLEAN) (stream OUTPUT-STREAM)) :</I>
<DD>Programmer's interface to the WHYNOT function.
</DL>
</P><P>

<A NAME="IDX427"></A>
<DL>
<DT><U>Function:</U> <B>false-truth-value?</B> <I>((self TRUTH-VALUE)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>self</VAR> represents some form of falsehood.
</DL>
</P><P>

<A NAME="IDX428"></A>
<DL>
<DT><U>Function:</U> <B>false?</B> <I>((self PROPOSITION)) : BOOLEAN</I>
<DD>Return true if <VAR>self</VAR> is false (or default-false if we are
considering default assertions).
</DL>
</P><P>

<A NAME="IDX429"></A>
<DL>
<DT><U>Method:</U> OBJECT-STORE <B>fetch-instance</B> <I>(store (name OBJECT)) : OBJECT</I>
<DD>Fetch the instance identified by <VAR>name</VAR> (a string or symbol) from <VAR>store</VAR>
and return it as an appropriate logic object.  This needs to be appropriately
specialized on actual OBJECT-STORE implementations.
</DL>
</P><P>

<A NAME="IDX430"></A>
<DL>
<DT><U>Method:</U> OBJECT-STORE <B>fetch-relation</B> <I>(store (name OBJECT)) : NAMED-DESCRIPTION</I>
<DD>Fetch the relation identified by <VAR>name</VAR> (a string or symbol) from <VAR>store</VAR>
and return it as a named description.  This needs to be appropriately 
specialized on actual OBJECT-STORE implementations.
</DL>
</P><P>

<A NAME="IDX431"></A>
<DL>
<DT><U>Method:</U> 2-D-ARRAY <B>fill-array</B> <I>(self &#38;rest (values OBJECT)) :</I>
<DD>Fill the two-dimensional array <VAR>self</VAR> in row-major-order
from <VAR>values</VAR>.  Missing values will retain their old values, extraneous values
will be ignored.
</DL>
</P><P>

<A NAME="IDX432"></A>
<DL>
<DT><U>Method:</U> 2-D-FLOAT-ARRAY <B>fill-array</B> <I>(self &#38;rest (values FLOAT)) :</I>
<DD>Fill the two-dimensional array <VAR>self</VAR> in row-major-order
from <VAR>values</VAR>.  Missing values will retain their old values, extraneous values
will be ignored.
</DL>
</P><P>

<A NAME="IDX433"></A>
<DL>
<DT><U>Function:</U> <B>finalize-objects</B> <I>() :</I>
<DD>Finalize all currently unfinalized objects.
The user-level entry point for this is <CODE>(process-definitions)</CODE>.
</DL>
</P><P>

<A NAME="IDX434"></A>
<DL>
<DT><U>Function:</U> <B>find-direct-supers-and-subs</B> <I>((self DESCRIPTION) (onlysupers? BOOLEAN)) : (CONS OF DESCRIPTION) (CONS OF DESCRIPTION) (CONS OF DESCRIPTION)</I>
<DD>Classify <VAR>self</VAR> and return three values, its direct
supers, direct subs, and a list of equivalent descriptions.
Setting <CODE>supersOnly?</CODE> may speed up the computation (perhaps by a lot).
If <CODE>description</CODE> is nameless and has no dependent propositions, then
it is automatically removed from the hierarchy after classification.
</DL>
</P><P>

<A NAME="IDX435"></A>
<DL>
<DT><U>Function:</U> <B>find-direct-supers-of-instance</B> <I>((self OBJECT)) : (CONS OF LOGIC-OBJECT)</I>
<DD>Classify <VAR>self</VAR> and return a list of most specific 
named descriptions among all descriptions that it satisfies.
</DL>
</P><P>

<A NAME="IDX436"></A>
<DL>
<DT><U>Function:</U> <B>find-file-in-load-path</B> <I>((file STRING) (extensions (CONS OF STRING-WRAPPER))) : STRING</I>
<DD>Try to find <VAR>file</VAR> in the current load path and, if found,
return its full name.  If <VAR>file</VAR> doesn't have its own extension try to find
it with any of the listed <VAR>extensions</VAR>.  If <VAR>extensions</VAR> is NULL it defaults
to <CODE>*powerloom-kb-file-extensions*</CODE>, therefore, to not default to any extensions
the value has to be supplied as NIL.
</DL>
</P><P>

<A NAME="IDX437"></A>
<DL>
<DT><U>N-Command:</U> <B>find-instance</B> <I>((instanceRef OBJECT)) : OBJECT</I>
<DD>Return the nearest instance with name <VAR>instanceRef</VAR>
visible from the current module.  <VAR>instanceRef</VAR> can be a string, symbol,
or surrogate.  If <VAR>instanceRef</VAR> is a surrogate, the search originates
in the module the surrogate was interned in.
</DL>
</P><P>

<A NAME="IDX438"></A>
<DL>
<DT><U>N-Command:</U> <B>find-rule</B> <I>((ruleName NAME)) : PROPOSITION</I>
<DD>Search for a rule named <VAR>ruleName</VAR>.  Like <CODE>get-rule</CODE>,
but <CODE>find-rule</CODE> implicity quotes its input argument.
</DL>
</P><P>

<A NAME="IDX439"></A>
<DL>
<DT><U>Function:</U> <B>function?</B> <I>((relationRef OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>relationRef</VAR> references a function.
</DL>
</P><P>

<A NAME="IDX440"></A>
<DL>
<DT><U>Function:</U> <B>generate-expression</B> <I>((self LOGIC-OBJECT) (canonicalizevariablenames? BOOLEAN)) : OBJECT</I>
<DD>Return an s-expression representing the source expression for <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX441"></A>
<DL>
<DT><U>Method:</U> LOGIC-THING <B>generate-specialized-term</B> <I>(self) : OBJECT</I>
<DD>Method to generate a specialized term for <VAR>self</VAR>.  This is designed
to allow for extension of the term generation code to cover other
types of objects for the logic.  This particular method will signal
an error unless there is a surrogate-value-inverse link set.
</DL>
</P><P>

<A NAME="IDX442"></A>
<DL>
<DT><U>Function:</U> <B>get-class</B> <I>((instanceRef OBJECT)) : LOGIC-OBJECT</I>
<DD>Return the nearest class with name <VAR>instanceRef</VAR>
visible from the current module.  <VAR>instanceRef</VAR> can be a string, symbol,
or surrogate.  If <VAR>instanceRef</VAR> is a surrogate, the search originates
in the module the surrogate was interned in.
</DL>
</P><P>

<A NAME="IDX443"></A>
<DL>
<DT><U>Function:</U> <B>get-instance</B> <I>((instanceRef OBJECT)) : OBJECT</I>
<DD>Return the nearest instance with name <VAR>instanceRef</VAR>
visible from the current module.  <VAR>instanceRef</VAR> can be a string, symbol,
or surrogate.  If <VAR>instanceRef</VAR> is a surrogate, the search originates
in the module the surrogate was interned in.
</DL>
</P><P>

<A NAME="IDX444"></A>
<DL>
<DT><U>Function:</U> <B>get-module</B> <I>((moduleRef OBJECT)) : MODULE</I>
<DD>Return a module named <VAR>moduleRef</VAR>.
</DL>
</P><P>

<A NAME="IDX445"></A>
<DL>
<DT><U>Function:</U> <B>get-relation</B> <I>((instanceRef OBJECT)) : LOGIC-OBJECT</I>
<DD>Return the nearest relation with name <VAR>instanceRef</VAR>
visible from the current module.  <VAR>instanceRef</VAR> can be a string, symbol,
or surrogate.  If <VAR>instanceRef</VAR> is a surrogate, the search originates
in the module the surrogate was interned in.
</DL>
</P><P>

<A NAME="IDX446"></A>
<DL>
<DT><U>Function:</U> <B>get-self-or-prototype</B> <I>((instanceRef OBJECT)) : LOGIC-OBJECT</I>
<DD>Used to convert a computation to reference so-called
<CODE>template</CODE> slots rather than <CODE>own</CODE> slots:  If <VAR>instanceRef</VAR> denotes a class,
return a prototype of that class.  Otherwise, return <VAR>instanceRef</VAR>.
</DL>
</P><P>

<A NAME="IDX447"></A>
<DL>
<DT><U>Function:</U> <B>get-slot-maximum-cardinality</B> <I>((self LOGIC-OBJECT) (relation SURROGATE)) : INTEGER</I>
<DD>Return a maximum value for the number of fillers of relation
<VAR>relation</VAR> (a surrogate) applied to the instance <VAR>self</VAR> (an object).
</DL>
</P><P>

<A NAME="IDX448"></A>
<DL>
<DT><U>Function:</U> <B>get-slot-minimum-cardinality</B> <I>((self LOGIC-OBJECT) (relation SURROGATE)) : INTEGER</I>
<DD>Return a minimum value for the number of fillers of relation
<VAR>relation</VAR> (a surrogate) applied to the instance <VAR>self</VAR> (an object).
</DL>
</P><P>

<A NAME="IDX449"></A>
<DL>
<DT><U>Function:</U> <B>get-slot-value</B> <I>((self LOGIC-OBJECT) (relation SURROGATE)) : OBJECT</I>
<DD>Return a single value for the slot <VAR>relation</VAR> (a surrogate)
applied to <VAR>self</VAR> (an object).
</DL>
</P><P>

<A NAME="IDX450"></A>
<DL>
<DT><U>Function:</U> <B>get-slot-value-type</B> <I>((self LOGIC-OBJECT) (relation SURROGATE)) : NAMED-DESCRIPTION</I>
<DD>Return a most specific type for fillers of the slot <VAR>relation</VAR>
(a surrogate) applied to <VAR>self</VAR>. If there is more than one, pick one.
</DL>
</P><P>

<A NAME="IDX451"></A>
<DL>
<DT><U>Function:</U> <B>get-why-justification</B> <I>((label STRING)) : JUSTIFICATION</I>
<DD>Returns the current WHY justification.  May also throw one of the
following subtypes of EXPLAIN-EXCEPTION:
   EXPLAIN-NO-QUERY-EXCEPTION
   EXPLAIN-NO-SOLUTION-EXCEPTION
   EXPLAIN-NO-MORE-SOLUTIONS-EXCEPTION
   EXPLAIN-NOT-ENABLED-EXCEPTION
   EXPLAIN-NO-SUCH-LABEL-EXCEPTION
   EXPLAIN-QUERY-TRUE-EXCEPTION
</DL>
</P><P>

<A NAME="IDX452"></A>
<DL>
<DT><U>Function:</U> <B>get-whynot-justifications</B> <I>((query QUERY-ITERATOR) (label STRING) (mapping EXPLANATION-MAPPING)) : (LIST OF JUSTIFICATION)</I>
<DD>Programmer's interface to WHYNOT function.  Derive
justifications why <VAR>query</VAR> failed, or, if <VAR>label</VAR> was supplied as non-NULL,
lookup its justification relative to <VAR>mapping</VAR> and return the result.
</DL>
</P><P>

<A NAME="IDX453"></A>
<DL>
<DT><U>Method:</U> NAMED-DESCRIPTION <B>help-print-outline</B> <I>(top (stream OUTPUT-STREAM) (current-depth INTEGER) (depth INTEGER) (named? BOOLEAN)) :</I>
<DD>Helper function for <CODE>print-concept-outline</CODE>
</DL>
</P><P>

<A NAME="IDX454"></A>
<DL>
<DT><U>Method:</U> DESCRIPTION <B>help-print-outline</B> <I>(top (stream OUTPUT-STREAM) (current-depth INTEGER) (depth INTEGER) (named? BOOLEAN)) :</I>
<DD>Helper function for <CODE>print-concept-outline</CODE>
</DL>
</P><P>

<A NAME="IDX455"></A>
<DL>
<DT><U>N-Command:</U> <B>in-dialect</B> <I>((dialect NAME)) : KEYWORD</I>
<DD>Change the current logic dialect to <VAR>dialect</VAR>.
Currently supported dialects are <CODE>KIF</CODE>, <CODE>STELLA</CODE>, and <CODE>PREFIX-STELLA</CODE>.
The STELLA dialects are not recommended for the construction of knowledge
bases, they are mainly used internally by PowerLoom.
</DL>
</P><P>

<A NAME="IDX456"></A>
<DL>
<DT><U>Function:</U> <B>inconsistent-truth-value?</B> <I>((self TRUTH-VALUE)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>self</VAR> represents INCONSISTENT.
</DL>
</P><P>

<A NAME="IDX457"></A>
<DL>
<DT><U>Function:</U> <B>inconsistent?</B> <I>((self PROPOSITION)) : BOOLEAN</I>
<DD>Return true if <VAR>self</VAR> is inconsistent (true and false).
</DL>
</P><P>

<A NAME="IDX458"></A>
<DL>
<DT><U>Method:</U> QUERY-SOLUTION-TABLE <B>insert-at</B> <I>(self (key (LIKE (ANY-KEY SELF))) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Insert <VAR>value</VAR> identified by <VAR>key</VAR> into <VAR>self</VAR>.  If a solution
with that key already exists, destructively modify it with the slot values of
<VAR>value</VAR>.  This is necessary to preserve the order of solutions in <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX459"></A>
<DL>
<DT><U>Function:</U> <B>invert-truth-value</B> <I>((self TRUTH-VALUE)) : TRUTH-VALUE</I>
<DD>Return the logical negation of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX460"></A>
<DL>
<DT><U>Method:</U> QUERY-SOLUTION-TABLE <B>length</B> <I>(self) : INTEGER</I>
<DD>Return the number of entries in <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX461"></A>
<DL>
<DT><U>Command:</U> <B>list-features</B> <I>() : LIST</I>
<DD>Return a list containing two lists, a list of currently enabled PowerLoom
features, and a list of all available PowerLoom features.
</DL>
</P><P>

<A NAME="IDX462"></A>
<DL>
<DT><U>N-Command:</U> <B>list-unclassified-instances</B> <I>((module NAME) (local? BOOLEAN)) : (CONS OF LOGIC-OBJECT)</I>
<DD>Collect all instances in <VAR>module</VAR> (or in any module if <VAR>module</VAR>
is NULL) that were not (or will not be) classified due to their lack of
non-inferable/primitive type assertions.
</DL>
</P><P>

<A NAME="IDX463"></A>
<DL>
<DT><U>N-Command:</U> <B>list-unclassified-relations</B> <I>((module NAME) (local? BOOLEAN)) : (CONS OF NAMED-DESCRIPTION)</I>
<DD>Collect all named description in <VAR>module</VAR> (or in any module if <VAR>module</VAR>
is NULL) that were not (or will not be) classified due to their lack of
non-inferable/primitive ancestor relations.
</DL>
</P><P>

<A NAME="IDX464"></A>
<DL>
<DT><U>N-Command:</U> <B>list-undefined-relations</B> <I>((module NAME) (local? BOOLEAN)) : (CONS OF NAMED-DESCRIPTION)</I>
<DD>Return a list of as yet undefined concepts and relations in <VAR>module</VAR>.
These relations were defined by the system, since they were referenced
but have not yet been defined by the user.  If <VAR>module</VAR> is NULL look in
the current module.  If <VAR>local?</VAR> only look in <VAR>module</VAR> but not in any
modules it inherits.
</DL>
</P><P>

<A NAME="IDX465"></A>
<DL>
<DT><U>Method:</U> QUERY-ITERATOR <B>listify</B> <I>(self) : LIST</I>
<DD>Just like <CODE>QUERY-ITERATOR.consify</CODE> but return a LIST instead.
</DL>
</P><P>

<A NAME="IDX466"></A>
<DL>
<DT><U>Function:</U> <B>load-stream</B> <I>((stream INPUT-STREAM)) :</I>
<DD>Read logic commands from <VAR>stream</VAR> and evaluate them.
</DL>
</P><P>

<A NAME="IDX467"></A>
<DL>
<DT><U>Function:</U> <B>logic-class?</B> <I>((self CLASS)) : BOOLEAN</I>
<DD>Return TRUE if the class <VAR>self</VAR> or one of its
supers supports indices that record extensions referenced by
the logic system. Also return true for literal classes.
</DL>
</P><P>

<A NAME="IDX468"></A>
<DL>
<DT><U>Function:</U> <B>logic-form-less?</B> <I>((o1 OBJECT) (o2 OBJECT)) : BOOLEAN</I>
<DD>A sorting predicate for objects <VAR>o1</VAR> and <VAR>o2</VAR> that can appear in logical
forms.  Performs a combined numeric and lexocographic sort that accounts
for lists, collections and propositions.  Numbers precede all other values,
<CODE>null</CODE> follows all other values.
</DL>
</P><P>

<A NAME="IDX469"></A>
<DL>
<DT><U>Function:</U> <B>logic-module?</B> <I>((self MODULE)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>self</VAR> is a logic module, implying
that relations defined within it define a knowledge base.  A module
is a logic module iff it inherits the module <CODE>PL-KERNEL</CODE>.
</DL>
</P><P>

<A NAME="IDX470"></A>
<DL>
<DT><U>Method:</U> QUERY-SOLUTION-TABLE <B>lookup</B> <I>(self (key (LIKE (ANY-KEY SELF)))) : (LIKE (ANY-VALUE SELF))</I>
<DD>Lookup the solution identified by <VAR>key</VAR> in <VAR>self</VAR> and
return its value, or NULL if no such solution exists.
</DL>
</P><P>

<A NAME="IDX471"></A>
<DL>
<DT><U>Function:</U> <B>lookup-native-specialist</B> <I>((native-name STRING)) : FUNCTION-CODE</I>
<DD>Returns the native funtion code for <VAR>native-name</VAR> if it exists
and the underlying programming languages supports such lookups.
</DL>
</P><P>

<A NAME="IDX472"></A>
<DL>
<DT><U>Function:</U> <B>named-description?</B> <I>((self DESCRIPTION)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>self</VAR> is the description of a named class or relation.
</DL>
</P><P>

<A NAME="IDX473"></A>
<DL>
<DT><U>Function:</U> <B>natural-deduction-mode?</B> <I>() : BOOLEAN</I>
<DD>True if normalization is governed by natural
deduction semantics.
</DL>
</P><P>

<A NAME="IDX474"></A>
<DL>
<DT><U>Method:</U> QUERY-SOLUTION-TABLE <B>non-empty?</B> <I>(self) : BOOLEAN</I>
<DD>Return TRUE if <VAR>self</VAR> has at least 1 entry.
</DL>
</P><P>

<A NAME="IDX475"></A>
<DL>
<DT><U>Method:</U> FLOAT-VECTOR <B>non-empty?</B> <I>(self) : BOOLEAN</I>
<DD>Return TRUE if <VAR>self</VAR> has length &#62; 0.
</DL>
</P><P>

<A NAME="IDX476"></A>
<DL>
<DT><U>Method:</U> QUERY-SOLUTION-TABLE <B>nth</B> <I>(self (position INTEGER)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the nth solution in <VAR>self</VAR>, or NULL if it is empty.
</DL>
</P><P>

<A NAME="IDX477"></A>
<DL>
<DT><U>Function:</U> <B>object-name</B> <I>((self OBJECT)) : SYMBOL</I>
<DD>Return the name symbol for the logic object <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX478"></A>
<DL>
<DT><U>Function:</U> <B>object-name-string</B> <I>((self OBJECT)) : STRING</I>
<DD>Return the name string for the logic object <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX479"></A>
<DL>
<DT><U>Function:</U> <B>object-surrogate</B> <I>((self OBJECT)) : SURROGATE</I>
<DD>Return the surrogate naming the object <VAR>self</VAR>, which
may be a Stella class that is used in PowerLoom as well as
a more normal powerloom object.
</DL>
</P><P>

<A NAME="IDX480"></A>
<DL>
<DT><U>Function:</U> <B>object-surrogate-setter</B> <I>((self OBJECT) (name SURROGATE)) : SURROGATE</I>
<DD>Return the name of the logic object <VAR>self</VAR> to <VAR>name</VAR>.
</DL>
</P><P>

<A NAME="IDX481"></A>
<DL>
<DT><U>Method:</U> QUERY-SOLUTION-TABLE <B>pop</B> <I>(self) : (LIKE (ANY-VALUE SELF))</I>
<DD>Remove and return the first solution of <VAR>self</VAR> or NULL
if the table is empty.
</DL>
</P><P>

<A NAME="IDX482"></A>
<DL>
<DT><U>Function:</U> <B>powerloom</B> <I>() :</I>
<DD>Run the PowerLoom listener.  Read logic commands from the
standard input, evaluate them, and print their results.  Exit if the user
entered <CODE>bye</CODE>, <CODE>exit</CODE>, <CODE>halt</CODE>, <CODE>quit</CODE>, or <CODE>stop</CODE>.
</DL>
</P><P>

<A NAME="IDX483"></A>
<DL>
<DT><U>Command:</U> <B>powerloom-information</B> <I>() : STRING</I>
<DD>Returns information about the current PowerLoom implementation.
Useful when reporting problems.
</DL>
</P><P>

<A NAME="IDX484"></A>
<DL>
<DT><U>Function:</U> <B>pretty-print-logical-form</B> <I>((form OBJECT) (stream OUTPUT-STREAM)) :</I>
<DD>Pretty-print the logical form <VAR>form</VAR> to <VAR>stream</VAR> according
to the current setting of <CODE>*logic-dialect*</CODE>.
</DL>
</P><P>

<A NAME="IDX485"></A>
<DL>
<DT><U>Method:</U> 2-D-ARRAY <B>print-array</B> <I>(self (stream NATIVE-OUTPUT-STREAM)) :</I>
<DD>Print the array <VAR>self</VAR> to <VAR>stream</VAR>.
</DL>
</P><P>

<A NAME="IDX486"></A>
<DL>
<DT><U>Method:</U> 2-D-FLOAT-ARRAY <B>print-array</B> <I>(self (stream NATIVE-OUTPUT-STREAM)) :</I>
<DD>Print the array <VAR>self</VAR> to <VAR>stream</VAR>.
</DL>
</P><P>

<A NAME="IDX487"></A>
<DL>
<DT><U>Function:</U> <B>print-extension-sizes</B> <I>((module MODULE) (sizeCutoff INTEGER)) :</I>
<DD>Print the extension sizes of concepts visible in <VAR>module</VAR>.
If <VAR>module</VAR> is NULL the current module is used.  Do not report extensions
with size less than <VAR>sizeCutoff</VAR> (default is 10).
</DL>
</P><P>

<A NAME="IDX488"></A>
<DL>
<DT><U>Function:</U> <B>print-goal-stack</B> <I>((frame CONTROL-FRAME) (verbose? BOOLEAN)) :</I>
<DD>Print stack of goals.  Assumes that query has been interrupted
with a full stack of control frames.
</DL>
</P><P>

<A NAME="IDX489"></A>
<DL>
<DT><U>Function:</U> <B>print-logical-form</B> <I>((form OBJECT) (stream OUTPUT-STREAM)) :</I>
<DD>Print the logical form <VAR>form</VAR> to <VAR>stream</VAR> according to
the current setting of <CODE>*logic-dialect*</CODE>.  Pretty-printing is controlled
by the current setting of <CODE>*prettyPrintLogicalForms?*</CODE>.
</DL>
</P><P>

<A NAME="IDX490"></A>
<DL>
<DT><U>Function:</U> <B>print-logical-form-in-dialect</B> <I>((self OBJECT) (dialect KEYWORD) (stream OUTPUT-STREAM)) :</I>
<DD>Produce a stringified version of a logical representation
of <VAR>self</VAR> and write it to the stream <VAR>stream</VAR>.  Use the dialect <VAR>dialect</VAR>,
or use the current dialect if <VAR>dialect</VAR> is NULL.
</DL>
</P><P>

<A NAME="IDX491"></A>
<DL>
<DT><U>Function:</U> <B>print-unformatted-logical-form</B> <I>((form OBJECT) (stream OUTPUT-STREAM)) :</I>
<DD>Print the logical form <VAR>form</VAR> to <VAR>stream</VAR> according to
the current setting of <CODE>*logic-dialect*</CODE>.  Pretty-printing is explicitly
forced to be turned off.
</DL>
</P><P>

<A NAME="IDX492"></A>
<DL>
<DT><U>Function:</U> <B>print-whynot-justification</B> <I>((justification JUSTIFICATION) (stream OUTPUT-STREAM) (maxDepth INTEGER) (style KEYWORD) (summary? BOOLEAN)) :</I>
<DD>Print a WHYNOT <VAR>justification</VAR> to <VAR>stream</VAR> according to
<VAR>maxDepth</VAR> and <VAR>style</VAR>.  Print a summary only if <VAR>summary?</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX493"></A>
<DL>
<DT><U>Function:</U> <B>random-float</B> <I>((n FLOAT)) : FLOAT</I>
<DD>Generate a random integer in the interval [0..n-1].
<VAR>n</VAR> must be &#60;= 2^15.
</DL>
</P><P>

<A NAME="IDX494"></A>
<DL>
<DT><U>Method:</U> MARKER-TABLE <B>recall-marked-objects</B> <I>(self) : LIST-ITERATOR</I>
<DD>Return an iterator that generates all marked objects
recorded in <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX495"></A>
<DL>
<DT><U>Function:</U> <B>record-justifications?</B> <I>() : BOOLEAN</I>
<DD>Return TRUE if every query records justifications to enable
the explanation of concluded results.
</DL>
</P><P>

<A NAME="IDX496"></A>
<DL>
<DT><U>Function:</U> <B>register-logic-dialect-print-function</B> <I>((dialect KEYWORD) (fn FUNCTION-CODE-WRAPPER)) :</I>
<DD>Register <VAR>fn</VAR> as a logic-object print function for <VAR>dialect</VAR>.
Each function should have the signature <CODE>((self OBJECT) (stream OUTPUT-STREAM))</CODE>.
Any return values will be ignored.
</DL>
</P><P>

<A NAME="IDX497"></A>
<DL>
<DT><U>Function:</U> <B>register-specialist-function</B> <I>((name STRING) (code FUNCTION-CODE)) :</I>
<DD>Creates a registration entry for <VAR>name</VAR> as a specialist which
executes <VAR>code</VAR>.  Essentially just builds the Stella meta-information
tructure needed to funcall <VAR>name</VAR> as a specialist.  The function definition
in <VAR>code</VAR> needs to accept a CONTROL-FRAME and KEYWORD as arguments and
return a KEYWORD.  Side effects on elements of the proposition in the
control frame can be used to bind and thus return values.
</DL>
</P><P>

<A NAME="IDX498"></A>
<DL>
<DT><U>Command:</U> <B>register-specialist-function-name</B> <I>((stella-name STRING) (native-name STRING)) :</I>
<DD>registers a specialist function <VAR>stella-name</VAR> based on the <VAR>native-name</VAR>
for the particular programming language in question.  Use of this command makes
the resulting code or knowledge bases non-portable to other target languages.
</DL>
</P><P>

<A NAME="IDX499"></A>
<DL>
<DT><U>Function:</U> <B>relation-name</B> <I>((self NAMED-DESCRIPTION)) : STRING</I>
<DD>Given a relation object, return it's name.
</DL>
</P><P>

<A NAME="IDX500"></A>
<DL>
<DT><U>Function:</U> <B>relation?</B> <I>((objectRef OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>objectRef</VAR> denotes a relation or a class.
</DL>
</P><P>

<A NAME="IDX501"></A>
<DL>
<DT><U>Method:</U> QUERY-SOLUTION-TABLE <B>remove-at</B> <I>(self (key (LIKE (ANY-KEY SELF)))) :</I>
<DD>Remove the solution identified by <VAR>key</VAR> from <VAR>self</VAR>.
To preserve the solution ordering chain, the solution is marked as deleted
and will be completely removed upon the next iteration through <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX502"></A>
<DL>
<DT><U>Method:</U> PAGING-INDEX <B>remove-deleted-members</B> <I>(self) : (LIKE SELF)</I>
<DD>Destructively remove all deleted members of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX503"></A>
<DL>
<DT><U>Function:</U> <B>reset-query-caches</B> <I>() :</I>
<DD>Zero out all caches managed by the query optimizer,
so that it will reoptimize subgoal queries upon next invocation.
</DL>
</P><P>

<A NAME="IDX504"></A>
<DL>
<DT><U>Function:</U> <B>retract-facts-of-instance</B> <I>((self LOGIC-OBJECT)) :</I>
<DD>Retract all definite (TRUE or FALSE) propositions attached to <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX505"></A>
<DL>
<DT><U>N-Command:</U> <B>retrieve-partial</B> <I>(&#38;rest (tree PARSE-TREE)) : QUERY-ITERATOR</I>
<DD>Partial-match version of <CODE>retrieve</CODE> (which see) that generates scored
partial solutions based on the current partial match strategy.  By supplying
<CODE>BEST</CODE> instead of <CODE>ALL</CODE>, or by adding the option <CODE>:SORT-BY :SCORE</CODE>, the generated
solutions will be sorted so that solutions with higher scores come first.
Use the <CODE>:MATCH-MODE</CODE> option to override the global default setting established
by <CODE>set-partial-match-mode</CODE>, e.g., use <CODE>:MATCH-MODE :NN</CODE> to use the neural
net partial match mode.  The <CODE>:MINIMUM-SCORE</CODE> option can be used to only
retrieve solutions that have at least the specified minimum match score.
By default, <CODE>retrieve-partial</CODE> does not maximize the match scores of its returned
bindings.  To only get maximal scores use <CODE>:MAXIMIZE-SCORE? TRUE</CODE> (this is not
yet implemented - you can use <CODE>ask-partial</CODE> to maximize scores for individual
solutions by hand).
</DL>
</P><P>

<A NAME="IDX506"></A>
<DL>
<DT><U>N-Command:</U> <B>run-forward-rules</B> <I>((moduleRef NAME) &#38;rest (force KEYWORD)) :</I>
<DD>Run forward inference rules in module <VAR>moduleRef</VAR>. If <VAR>moduleRef</VAR> is NULL, the
current module will be used.  If forward inferencing is already up-to-date
in the designated module, no additional inferencing will occur, unless the
optional keyword <CODE>:force</CODE> is included, in which case all
forward rules are run or rerun.
</P><P>

Calling <CODE>run-forward-rules</CODE> temporarily puts the module into a mode where
future assertional (monotonic) updates will trigger additional forward
inference.  Once a non-monotonic update is performed, i.e., a retraction
or clipping of relation value, all cached forward inferences will be discarded
and forward inferencing will be disabled until this function is
called again.
</DL>
</P><P>

<A NAME="IDX507"></A>
<DL>
<DT><U>Command:</U> <B>run-powerloom-tests</B> <I>() :</I>
<DD>Run the PowerLoom test suite.  Currently this simply runs all demos and
echos commands and their results to standard output.  The output can then
be diffed with previously validated runs to find deviations.
</DL>
</P><P>

<A NAME="IDX508"></A>
<DL>
<DT><U>Function:</U> <B>satisfies?</B> <I>((instanceOrTuple OBJECT) (relationRef OBJECT)) : TRUTH-VALUE</I>
<DD>Try to prove whether <VAR>instanceOrTuple</VAR> satisfies the
definition of the relation <VAR>relationRef</VAR> and return the result truth value
of the query.  <VAR>instanceOrTuple</VAR> can be a single object, the name or surrogate
of an object, or a collection (a list or vector) of objects.  <VAR>relationRef</VAR>
can be a relation, description, surrogate or relation name.
</DL>
</P><P>

<A NAME="IDX509"></A>
<DL>
<DT><U>Command:</U> <B>save-all-neural-networks</B> <I>((file STRING)) :</I>
<DD>Save all neural networks to <VAR>file</VAR> (if <VAR>file</VAR> is non-NULL).
If networks are saved periodically (see <CODE>set-save-network-cycle</CODE>) this file
name will be used to perform periodic saves.
</DL>
</P><P>

<A NAME="IDX510"></A>
<DL>
<DT><U>Function:</U> <B>select-proof-result</B> <I>((success? BOOLEAN) (continuing? BOOLEAN) (terminal? BOOLEAN)) : KEYWORD</I>
<DD>Helping function for specialists.   Return the appropriate
keyword indicating success or failure of a proof.
</DL>
</P><P>

<A NAME="IDX511"></A>
<DL>
<DT><U>Function:</U> <B>select-test-result</B> <I>((success? BOOLEAN) (terminal? BOOLEAN) (frame CONTROL-FRAME)) : KEYWORD</I>
<DD>Helping function for specialists testing the validity of a
fully bound inference frame.  Based on the test result <VAR>success?</VAR>
and <CODE>reversePolarity?*</CODE>, set the truth value of <VAR>frame</VAR> and return
an appropriate keyword.  The keyword will be either <CODE>:final-success</CODE>
<CODE>:terminal-failure</CODE> if <VAR>terminal?</VAR> is true.  Otherwise it will be
<CODE>:final-success</CODE> or <CODE>:failure</CODE>.
</DL>
</P><P>

<A NAME="IDX512"></A>
<DL>
<DT><U>Command:</U> <B>set-error-print-cycle</B> <I>((i INTEGER)) :</I>
<DD>Set number of cycles between which error rates are saved to
the file established by the last call to <CODE>save-all-neural-networks</CODE> appended
with extension <CODE>.err</CODE>.  A number &#60;= 0 (or NULL) turns off periodic saving.
</DL>
</P><P>

<A NAME="IDX513"></A>
<DL>
<DT><U>N-Command:</U> <B>set-inference-level</B> <I>((level NAME) (module NAME)) : KEYWORD</I>
<DD>Set the inference level of <VAR>module</VAR> to the level specified
by <CODE>levelKeyword</CODE>.  If <VAR>module</VAR> is NULL, set the level globally.
</DL>
</P><P>

<A NAME="IDX514"></A>
<DL>
<DT><U>Method:</U> MARKER-TABLE <B>set-marker</B> <I>(self (object OBJECT)) :</I>
<DD>Record membership of <VAR>object</VAR> in the marker
storage object <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX515"></A>
<DL>
<DT><U>Command:</U> <B>set-num-neighbors</B> <I>((d INTEGER)) :</I>
<DD>Sets the number of nearest neighbors to predict from.
</DL>
</P><P>

<A NAME="IDX516"></A>
<DL>
<DT><U>Command:</U> <B>set-num-training-per-case</B> <I>((d INTEGER)) :</I>
<DD>Sets the number of training examples for each case in the training set.
</DL>
</P><P>

<A NAME="IDX517"></A>
<DL>
<DT><U>Function:</U> <B>set-powerloom-feature</B> <I>((feature KEYWORD)) :</I>
<DD>Enable the PowerLoom environment feature <VAR>feature</VAR>.
</DL>
</P><P>

<A NAME="IDX518"></A>
<DL>
<DT><U>Command:</U> <B>set-save-network-cycle</B> <I>((i INTEGER)) :</I>
<DD>Set number of cycles between which networks are saved to the
file established by the last call to <CODE>save-all-neural-networks</CODE>.  A number &#60;= 0
or a NULL number turns off periodic saving.
</DL>
</P><P>

<A NAME="IDX519"></A>
<DL>
<DT><U>Method:</U> QUERY-SOLUTION-TABLE <B>sort</B> <I>(self (predicate FUNCTION-CODE)) : (LIKE SELF)</I>
<DD>Perform a stable, destructive sort of <VAR>self</VAR> according to
<VAR>predicate</VAR>, and return the result.  If <VAR>predicate</VAR> has a <CODE>&#60;</CODE> semantics, the
result will be in ascending order.
</DL>
</P><P>

<A NAME="IDX520"></A>
<DL>
<DT><U>Function:</U> <B>specializes?</B> <I>((subObject OBJECT) (superObject OBJECT)) : TRUTH-VALUE</I>
<DD>Try to prove if the description associated with <VAR>subObject</VAR>
specializes the description for <VAR>superObject</VAR> and return the result truth
value of the query.
</DL>
</P><P>

<A NAME="IDX521"></A>
<DL>
<DT><U>Function:</U> <B>strengthen-truth-value</B> <I>((tv1 TRUTH-VALUE) (tv2 TRUTH-VALUE)) : TRUTH-VALUE</I>
<DD>If <VAR>tv2</VAR> has greater strength than <VAR>tv1</VAR>, adapt the strength of <VAR>tv1</VAR> (not
its value!) and return the result.  Otherwise, return <VAR>tv1</VAR> unmodified.
</DL>
</P><P>

<A NAME="IDX522"></A>
<DL>
<DT><U>Function:</U> <B>strict-truth-value?</B> <I>((self TRUTH-VALUE)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>self</VAR> is a strict truth value.
</DL>
</P><P>

<A NAME="IDX523"></A>
<DL>
<DT><U>Function:</U> <B>termify</B> <I>((self OBJECT)) : OBJECT</I>
<DD>Convert <VAR>self</VAR> into an equivalent PowerLoom object
that can be passed as an argument wherever an instance is expected.
</DL>
</P><P>

<A NAME="IDX524"></A>
<DL>
<DT><U>Function:</U> <B>test-closed-slot?</B> <I>((relation SURROGATE)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>relation</VAR> (a surrogate) is asserted to 
be closed or if the current module closes all relations.
</DL>
</P><P>

<A NAME="IDX525"></A>
<DL>
<DT><U>Function:</U> <B>test-function-slot?</B> <I>((relation SURROGATE)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>relation</VAR> (a surrogate) is a function.
</DL>
</P><P>

<A NAME="IDX526"></A>
<DL>
<DT><U>Method:</U> MARKER-TABLE <B>test-marker?</B> <I>(self (object OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>object</VAR> is stored (marked) in <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX527"></A>
<DL>
<DT><U>Function:</U> <B>test-relation-on-arguments?</B> <I>((relation SURROGATE) (arguments CONS)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>relation</VAR> (a surrogate) is TRUE when
applied to <VAR>arguments</VAR>.
</DL>
</P><P>

<A NAME="IDX528"></A>
<DL>
<DT><U>Function:</U> <B>test-slot-value?</B> <I>((self LOGIC-OBJECT) (relation SURROGATE) (filler OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if the proposition <CODE>(&#60;relation&#62; &#60;self&#62; &#60;filler&#62;)</CODE>
is true.
</DL>
</P><P>

<A NAME="IDX529"></A>
<DL>
<DT><U>Function:</U> <B>test-special-marker-table?</B> <I>((self OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if the object <VAR>self</VAR> is stored (marked)
in the table pointed at by the special variable *specialMarkerTable*.
Designed for use by <CODE>remove-if</CODE>.
</DL>
</P><P>

<A NAME="IDX530"></A>
<DL>
<DT><U>Function:</U> <B>test-subrelation?</B> <I>((subrelation SURROGATE) (superrelation SURROGATE)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>subrelation</VAR> specializes <VAR>superrelation</VAR>.
</DL>
</P><P>

<A NAME="IDX531"></A>
<DL>
<DT><U>Function:</U> <B>test-type-on-instance?</B> <I>((self OBJECT) (type SURROGATE)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>self</VAR> satisfies <VAR>type</VAR>.
</DL>
</P><P>

<A NAME="IDX532"></A>
<DL>
<DT><U>Command:</U> <B>translate-loom-file</B> <I>((input FILE-NAME) (output FILE-NAME)) :</I>
<DD>Translate the Loom file <VAR>input</VAR> to PowerLoom and write the
translation to the file <VAR>output</VAR>.  Note that this will only
work for fairly vanilla Loom files that do not contain any
Lisp-isms.  It might require to clean the Loom file manually
before this translation will work.
</DL>
</P><P>

<A NAME="IDX533"></A>
<DL>
<DT><U>Function:</U> <B>true-truth-value?</B> <I>((self TRUTH-VALUE)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>self</VAR> represents some form of truth.
</DL>
</P><P>

<A NAME="IDX534"></A>
<DL>
<DT><U>Function:</U> <B>true?</B> <I>((self PROPOSITION)) : BOOLEAN</I>
<DD>Return true if <VAR>self</VAR> is true (or default-true if we are
considering default assertions).
</DL>
</P><P>

<A NAME="IDX535"></A>
<DL>
<DT><U>N-Command:</U> <B>unassert</B> <I>((proposition PARSE-TREE)) : OBJECT</I>
<DD>Retract the truth, falsity or inconsistency of <VAR>proposition</VAR>.  This is a
more general version of <CODE>retract</CODE> that also handles falsity.  For example, if
we assert the proposition "(not (sad Fred))", and then execute the statement
"(unassert (sad Fred))", the truth value of the proposition "(sad Fred)"
will be set to UNKNOWN.  If we had called <CODE>retract</CODE> in place of <CODE>unassert</CODE>,
the proposition "(sad Fred)" would remain set to FALSE.   Note that for this
unassertion to succeed, the logic constant <CODE>Fred</CODE> and the relation <CODE>sad</CODE> must
already be defined.
</DL>
</P><P>

<A NAME="IDX536"></A>
<DL>
<DT><U>Function:</U> <B>unassert-proposition</B> <I>((self PROPOSITION)) :</I>
<DD>Retract the truth, falsity or inconsistency of the proposition <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX537"></A>
<DL>
<DT><U>Function:</U> <B>unknown-truth-value?</B> <I>((self TRUTH-VALUE)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>self</VAR> represents UNKNOWN.
</DL>
</P><P>

<A NAME="IDX538"></A>
<DL>
<DT><U>Function:</U> <B>unknown?</B> <I>((self PROPOSITION)) : BOOLEAN</I>
<DD>Return true if the truth of <VAR>self</VAR> is unknown.
</DL>
</P><P>

<A NAME="IDX539"></A>
<DL>
<DT><U>Function:</U> <B>unset-powerloom-feature</B> <I>((feature KEYWORD)) :</I>
<DD>Disable the PowerLoom environment feature <VAR>feature</VAR>.
</DL>
</P><P>

<A NAME="IDX540"></A>
<DL>
<DT><U>Function:</U> <B>upclassify-all-descriptions</B> <I>() :</I>
<DD>Classify all named descriptions.
</DL>
</P><P>

<A NAME="IDX541"></A>
<DL>
<DT><U>Function:</U> <B>upclassify-all-instances</B> <I>() :</I>
<DD>Classify all named instances.
</DL>
</P><P>

<A NAME="IDX542"></A>
<DL>
<DT><U>Function:</U> <B>upclassify-instances</B> <I>((module MODULE) (local? BOOLEAN)) :</I>
<DD>Classify instances local to <VAR>module</VAR> and inherited
by <VAR>module</VAR>.  If <VAR>local?</VAR>, don't classify inherited descriptions.  If
<VAR>module</VAR> is NULL, classify descriptions in all modules.
</DL>
</P><P>

<A NAME="IDX543"></A>
<DL>
<DT><U>Function:</U> <B>upclassify-named-descriptions</B> <I>((module MODULE) (local? BOOLEAN)) :</I>
<DD>Classify named descriptions local to <VAR>module</VAR> and inherited
by <VAR>module</VAR>.  If <VAR>local?</VAR>, don't classify inherited descriptions.  If
<VAR>module</VAR> is NULL, classify descriptions in all modules.
</DL>
</P><P>

<A NAME="IDX544"></A>
<DL>
<DT><U>Method:</U> OBJECT-STORE <B>update-proposition-in-store</B> <I>(store (proposition PROPOSITION) (update-mode KEYWORD)) :</I>
<DD>A module with <VAR>store</VAR> has had the truth value of <VAR>proposition</VAR>
change according to <VAR>update-mode</VAR>.  The default method does nothing.
</DL>
</P><P>

<A NAME="IDX545"></A>
<DL>
<DT><U>Function:</U> <B>weaken-truth-value</B> <I>((tv1 TRUTH-VALUE) (tv2 TRUTH-VALUE)) : TRUTH-VALUE</I>
<DD>If <VAR>tv2</VAR> has lesser strength than <VAR>tv1</VAR>, adapt the strength of <VAR>tv1</VAR> (not
its value!) and return the result.  Otherwise, return <VAR>tv1</VAR> unmodified.
</DL>
</P><P>

<A NAME="IDX546"></A>
<DL>
<DT><U>Macro:</U> <B>with-logic-environment</B> <I>((moduleForm OBJECT) (environment OBJECT) &#38;body (body CONS)) : OBJECT</I>
<DD>Execute <VAR>body</VAR> within the module resulting from <VAR>moduleForm</VAR>.
<CODE>*module*</CODE> is an acceptable <VAR>moduleForm</VAR>.  It will locally rebind 
<CODE>*module*</CODE> and <CODE>*context*</CODE> and shield the outer bindings from changes.
</DL>
</P><P>

<A NAME="IDX547"></A>
<DL>
<DT><U>Macro:</U> <B>within-classification-session</B> <I>((descriptionorinstance KEYWORD) &#38;body (body CONS)) : OBJECT</I>
<DD>Used during classification.  Execute <VAR>body</VAR> within the indicated
classification session and inference world.
</DL>
</P><P>

<A NAME="IDX548"></A>
<DL>
<DT><U>Macro:</U> <B>within-meta-cache</B> <I>(&#38;body (body CONS)) : OBJECT</I>
<DD>Execute <VAR>body</VAR> within the meta cache of the current module.
Set appropriate special variables.
</DL>
</P><P>

<A NAME="IDX549"></A>
<DL>
<DT><U>Function:</U> <B>create-keyword</B> <I>((name STRING)) : KEYWORD</I>
<DD>Returns the Stella keyword <VAR>name</VAR>, creating it if
necessary.  <VAR>name</VAR> is treated case-sensitively.  This should
generally not be necessary to do.
</DL>
</P><P>

<A NAME="IDX550"></A>
<DL>
<DT><U>Function:</U> <B>create-symbol</B> <I>((name STRING) (module MODULE) (environment ENVIRONMENT)) : SYMBOL</I>
<DD>Returns the Stella symbol <VAR>name</VAR> visible in <VAR>module</VAR>,
creating it if necessary.  <VAR>name</VAR> is ALWAYS treated case-sensitively,
even if <VAR>module</VAR> is case insensitive. This should generally not be
necessary to do.
</DL>
</P><P>

<A NAME="IDX551"></A>
<DL>
<DT><U>Function:</U> <B>get-keyword</B> <I>((name STRING)) : KEYWORD</I>
<DD>Returns the Stella KEYWORD <VAR>name</VAR> if it exists.  Case sensitive.
</DL>
</P><P>

<A NAME="IDX552"></A>
<DL>
<DT><U>Function:</U> <B>get-name-in-module</B> <I>((obj OBJECT) (module MODULE) (environment ENVIRONMENT)) : STRING</I>
<DD>Return the name, qualified as necessary, so that <VAR>obj</VAR> can be found from
<VAR>module</VAR>.  If there is no name for the object return <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX553"></A>
<DL>
<DT><U>Function:</U> <B>get-short-name</B> <I>((obj OBJECT)) : STRING</I>
<DD>Return the short name of <VAR>obj</VAR>, if it has one.  Otherwise return <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX554"></A>
<DL>
<DT><U>Function:</U> <B>get-symbol</B> <I>((name STRING) (module MODULE) (environment ENVIRONMENT)) : SYMBOL</I>
<DD>Returns the Stella SYMBOL <VAR>name</VAR> visible in <VAR>module</VAR> if it
exists.  <VAR>name</VAR> is ALWAYS treated case sensitively.
</DL>
</P><P>

<A NAME="IDX555"></A>
<DL>
<DT><U>Function:</U> <B>is-true-proposition1</B> <I>((relation-and-arguments OBJECT) (module MODULE) (environment ENVIRONMENT)) : BOOLEAN</I>
<DD>Return TRUE if a proposition (<CODE>relation</CODE> <CODE>args</CODE>) has
been asserted (or inferred by forward chaining).
</DL>
</P><P>

<A NAME="IDX556"></A>
<DL>
<DT><U>Function:</U> <B>main</B> <I>() :</I>
<DD>Main PowerLoom entry point for your code in C++ and Java.
</DL>
</P><P>

<A NAME="IDX557"></A>
<DL>
<DT><U>Function:</U> <B>register-specialist-function</B> <I>((name STRING) (function-reference FUNCTION-CODE) (module MODULE) (environment ENVIRONMENT)) :</I>
<DD>Register <VAR>name</VAR> as a function name in <VAR>module</VAR> which will invoke the
native code procedure described by <CODE>function-reference.</CODE>  The <VAR>name</VAR>
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The function must conform
to the signature for specialist functions.
</P><P>

The exact form of <VAR>function-reference</VAR> depends on the underlying
programming language.  The following type mappings are used:
          C++:  
  Common Lisp:  FUNCTION   (result of #' or (FUNCTION ...))
         Java:  java.lang.reflect.Method
</DL>
</P><P>

<A NAME="IDX558"></A>
<DL>
<DT><U>Function:</U> <B>s-register-specialist-function</B> <I>((name STRING) (native-name STRING) (module-name STRING) (environment ENVIRONMENT)) :</I>
<DD>Register <VAR>name</VAR> as a function name in the module named <VAR>module-name</VAR>.
This function will the native code named <VAR>native-name</VAR>.  The <VAR>name</VAR>
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The <VAR>native-name</VAR> will be
processed in a manner that depends on the underlying programming
language.  The following type mappings are used:
          C++:  Not available.  Error signaled.
  Common Lisp:  The native-name is read by READ-FROM-STRING and then
                the SYMBOL-FUNCTION is taken.
         Java:  A fully package-qualified name is required.  It is
                looked up using the Reflection tools.
The function found must conform to the signature for specialist functions.
</DL>
</P><P>

<A NAME="IDX559"></A>
<DL>
<DT><U>Method:</U> PL-ITERATOR <B>consify</B> <I>(self) : CONS</I>
<DD>Convert <VAR>self</VAR> into a Stella CONS.
</DL>
</P><P>

<A NAME="IDX560"></A>
<DL>
<DT><U>Method:</U> PL-ITERATOR <B>listify</B> <I>(self) : LIST</I>
<DD>Convert <VAR>self</VAR> into a Stella LIST.
</DL>
</P><P>

<A NAME="IDX561"></A>
<DL>
<DT><U>Command:</U> <B>initialize-kernel-kb</B> <I>() :</I>
<DD>Bootstrap the PowerLoom built-in kernel KB.
</DL>
</P><P>

<A NAME="Glossary"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC63"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_11.html#SEC72"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Hans Chalupsky</I> on <I>May, 25  2006</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>
</FONT>

</BODY>
</HTML>
