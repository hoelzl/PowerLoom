<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<!-- Created on May, 25  2006 by texi2html 1.65 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>PowerLoom Manual: Built-In Relations</TITLE>

<META NAME="description" CONTENT="PowerLoom Manual: Built-In Relations">
<META NAME="keywords" CONTENT="PowerLoom Manual: Built-In Relations">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.65">

</HEAD>

<BODY LANG="en" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC62"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC61"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC63"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC63"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 8. Built-In Relations </H1>
<!--docid::SEC62::-->
<P>

This chapter lists all of the relations that come predefined in PowerLoom. They
are defined in the module <CODE>PL-KERNEL</CODE>; users can access them by
including or using the <CODE>PL-KERNEL</CODE> module within the declarations of their
own modules.
</P><P>

<A NAME="IDX200"></A>
<DL>
<DT><U>Function:</U> <B>*</B> <I>((?x NUMBER) (?y NUMBER)) :-&#62; (?z NUMBER)</I>
<DD>Function that multiplies two numbers.
</DL>
</P><P>

<A NAME="IDX201"></A>
<DL>
<DT><U>Function:</U> <B>+</B> <I>((?x NUMBER) (?y NUMBER)) :-&#62; (?z NUMBER)</I>
<DD>Function that adds two numbers.
</DL>
</P><P>

<A NAME="IDX202"></A>
<DL>
<DT><U>Function:</U> <B>-</B> <I>((?x NUMBER) (?y NUMBER)) :-&#62; (?z NUMBER)</I>
<DD>Function that subtracts two numbers.
</DL>
</P><P>

<A NAME="IDX203"></A>
<DL>
<DT><U>Function:</U> <B>/</B> <I>((?x NUMBER) (?y NUMBER)) :-&#62; (?z NUMBER)</I>
<DD>Function that divides two numbers.
</DL>
</P><P>

<A NAME="IDX204"></A>
<DL>
<DT><U>Relation:</U> <B>&#60;</B> <I>((?x THING) (?y THING))</I>
<DD>True if ?x &#60; ?y.
</DL>
</P><P>

<A NAME="IDX205"></A>
<DL>
<DT><U>Relation:</U> <B>=&#60;</B> <I>((?x THING) (?y THING))</I>
<DD>True if ?x &#60;= ?y.
</DL>
</P><P>

<A NAME="IDX206"></A>
<DL>
<DT><U>Relation:</U> <B>&#62;</B> <I>((?x THING) (?y THING))</I>
<DD>True if ?x &#62; ?y.
</DL>
</P><P>

<A NAME="IDX207"></A>
<DL>
<DT><U>Relation:</U> <B>&#62;=</B> <I>((?x THING) (?y THING))</I>
<DD>True if ?x &#62;= ?y.
</DL>
</P><P>

<A NAME="IDX208"></A>
<DL>
<DT><U>Relation:</U> <B>ABSTRACT</B> <I>((?r RELATION))</I>
<DD>True if there are no direct assertions made
to the relation ?r.
</DL>
</P><P>

<A NAME="IDX209"></A>
<DL>
<DT><U>Concept:</U> <B>AGGREGATE</B> <I>((?a AGGREGATE))</I>
<DD>?a is an aggregate
</DL>
</P><P>

<A NAME="IDX210"></A>
<DL>
<DT><U>Relation:</U> <B>ANTISYMMETRIC</B> <I>((?r RELATION))</I>
<DD>A binary relation ?r is antisymmetric if whenever (?r ?x ?y)
is true (?r ?y ?x) is false unless ?x equals ?y.
</DL>
</P><P>

<A NAME="IDX211"></A>
<DL>
<DT><U>Function:</U> <B>ARITY</B> <I>((?r RELATION)) :-&#62; (?arity INTEGER)</I>
<DD>The number of arguments/domains of the relation <VAR>?r</VAR>.
</DL>
</P><P>

<A NAME="IDX212"></A>
<DL>
<DT><U>Concept:</U> <B>BINARY-RELATION</B> <I>((?r RELATION))</I>
<DD>The class of binary relations.
</DL>
</P><P>

<A NAME="IDX213"></A>
<DL>
<DT><U>Relation:</U> <B>BOUND-VARIABLES</B> <I>((?arguments THING))</I>
<DD>True if all arguments are bound.  The <CODE>bound-variables</CODE>
predicate is used as a performance enhancer, to prevent other predicates
from backchaining excessively while searching for bindings of certain of
their arguments. Purists will shun the use of this predicate, but some rules
are inherently inefficient without the addition of some kind of control logic.
Because evaluation of the <CODE>bound-variables</CODE> predicate evaluation of
predicates being <CODE>guarded</CODE>, using this predicate has the side-effect
of locally disabling query optimization.  (See <CODE>collect-into-set</CODE> for
an example that uses <CODE>bound-variables</CODE>.
</DL>
</P><P>

<A NAME="IDX214"></A>
<DL>
<DT><U>Function:</U> <B>CARDINALITY</B> <I>((?c SET)) :-&#62; (?card INTEGER)</I>
<DD>Function that returns the cardinality of a set.
</DL>
</P><P>

<A NAME="IDX215"></A>
<DL>
<DT><U>Relation:</U> <B>CLOSED</B> <I>((?c COLLECTION))</I>
<DD>The collection ?c is closed if all of its members are known.
Asserting that a relation is closed makes certain computations easier.
For example, suppose that the relation <CODE>happy</CODE> is closed,
implying that all things that are happy will be asserted as such.
To prove <CODE>(not (happy Fred))</CODE>, PowerLoom can use a negation-as-failure 
proof strategy which returns TRUE if <CODE>Fred</CODE> cannot be proved to be happy.
Also, if the relation <CODE>children</CODE> is closed, then a value for the expression
<CODE>(range-max-cardinality children Fred)</CODE> can be inferred merely by
counting the number of fillers of the <CODE>children</CODE> role on <CODE>Fred</CODE>.
</DL>
</P><P>

<A NAME="IDX216"></A>
<DL>
<DT><U>Function:</U> <B>COLLECT-INTO-SET</B> <I>((?c COLLECTION)) :-&#62; (?l SET)</I>
<DD>Infer as many members of ?c as possible and
collect them into a set ?l.  For example, here is a rule
used to compute bindings for the <CODE>fillers</CODE> predicate:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  (&#60;= (fillers ?r ?i ?v)
      (and (bound-variables ?r ?i)
           (collect-into-set (setofall ?v (holds ?r ?i ?v)) ?members)))
</pre></td></tr></table></P><P>

When <CODE>?r</CODE> and <CODE>?i</CODE> are bound, the term <CODE>(setofall ?v (holds ?r ?i ?v))</CODE>
evaluates to a unary relation satisfied for each filler of the relation
in <CODE>?r</CODE> applied to the instance in <CODE>?i</CODE>.  <CODE>collect-into-set</CODE> causes
the extension of this (dynamically-defined) unary relation to be
computed.  Note the use of <CODE>bound-variables</CODE> to screen out unbound
variables before they are passed to the <CODE>setofall</CODE> predicate.
</DL>
</P><P>

<A NAME="IDX217"></A>
<DL>
<DT><U>Class:</U> <B>COLLECTION</B> <I>: ABSTRACT-COLLECTION</I>
<DD>Not documented.
<A NAME="IDX218"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-value</B> <I>: OBJECT</I>
<DD>Not documented.
</DL>
</DL>
</P><P>

<A NAME="IDX219"></A>
<DL>
<DT><U>Function:</U> <B>COLLECTIONOF</B> <I>((?m THING)) :-&#62; (?c COLLECTION)</I>
<DD>Abstract function existing to subsume <CODE>SETOF</CODE>
and <CODE>LISTOF</CODE>.
</DL>
</P><P>

<A NAME="IDX220"></A>
<DL>
<DT><U>Relation:</U> <B>COMMENT</B> <I>((?x THING) (?s STRING))</I>
<DD>?s is a comment attached to ?x.  Comments are
a generalization of other annotations such as <CODE>documentation</CODE> and
<CODE>issue</CODE> strings.
</DL>
</P><P>

<A NAME="IDX221"></A>
<DL>
<DT><U>Relation:</U> <B>COMMUTATIVE</B> <I>((?r RELATION))</I>
<DD>A relation ?r is commutative if its truth value is
invariant with any permutation of its arguments.
</DL>
</P><P>

<A NAME="IDX222"></A>
<DL>
<DT><U>Concept:</U> <B>CONCEPT</B> <I>((?x RELATION))</I>
<DD>The class of reified unary relations.  The Powerloom
notion of <CODE>concept</CODE> corresponds to the object-oriented notion of <CODE>class</CODE>.
From a logic standpoint, the notion of a concept is hard to distinguish
from the notion of <CODE>unary relation</CODE>.  The conceptual distinction is
best illustrated in the domain of linguistics, where concepts are
identified with collective nouns while unary relations are identified
with adjectives.  For example, <CODE>Rock</CODE> is a concept, while <CODE>rocky</CODE> is a
unary relation.
</DL>
</P><P>

<A NAME="IDX223"></A>
<DL>
<DT><U>Function:</U> <B>CONCEPT-PROTOTYPE</B> <I>((?c CONCEPT)) :-&#62; (?i THING)</I>
<DD>Function that, given a concept, returns a prototypical
instance that inherits all constraints that apply to any concept member,
and has no additional constraints.
</DL>
</P><P>

<A NAME="IDX224"></A>
<DL>
<DT><U>Class:</U> <B>CONTEXT</B> <I>: THING</I>
<DD>Not documented.
<A NAME="IDX225"></A>
<DL>
<DT><U>Slot:</U>  <B>child-contexts</B> <I>: (LIST OF CONTEXT)</I>
<DD>Not documented.
</DL>
<A NAME="IDX226"></A>
<DL>
<DT><U>Slot:</U>  <B>base-module</B> <I>: MODULE</I>
<DD>Not documented.
</DL>
<A NAME="IDX227"></A>
<DL>
<DT><U>Slot:</U>  <B>all-super-contexts</B> <I>: (CONS OF CONTEXT)</I>
<DD>Not documented.
</DL>
<A NAME="IDX228"></A>
<DL>
<DT><U>Slot:</U>  <B>context-number</B> <I>: INTEGER</I>
<DD>Not documented.
</DL>
</DL>
</P><P>

<A NAME="IDX229"></A>
<DL>
<DT><U>Relation:</U> <B>COVERING</B> <I>((?c COLLECTION) (?cover SET))</I>
<DD>True if ?c is a subset of the union of all
collections in the set ?cover (see <CODE>disjoint-covering</CODE>).
</DL>
</P><P>

<A NAME="IDX230"></A>
<DL>
<DT><U>Relation:</U> <B>CUT</B> <I>((?arguments THING))</I>
<DD>Prolog-like CUT.  Succeeds the first time and
then fails.  Side-effect:  Locally disables query optimization.
</DL>
</P><P>

<A NAME="IDX231"></A>
<DL>
<DT><U>Relation:</U> <B>DIRECT-SUBRELATION</B> <I>((?r RELATION) (?sub RELATION))</I>
<DD>True iff ?sub is a direct subrelation of ?r; written
in set notation, ?sub &#60; ?r, and there is no ?s such that ?sub &#60; ?s &#60; ?r.
This relation will generate bindings for at most one unbound argument.
</DL>
</P><P>

<A NAME="IDX232"></A>
<DL>
<DT><U>Relation:</U> <B>DIRECT-SUPERRELATION</B> <I>((?r RELATION) (?super RELATION))</I>
<DD>True iff ?super is a direct superrelation of ?r;
in set notation, ?super &#62; ?r, and there is no ?s such that ?super &#62; ?s &#62; ?r.
This relation will generate bindings for at most one unbound argument.
</DL>
</P><P>

<A NAME="IDX233"></A>
<DL>
<DT><U>Relation:</U> <B>DISJOINT</B> <I>((?c1 COLLECTION) (?c2 COLLECTION))</I>
<DD>True if the intersection of ?c1 and ?c2 is empty.
</DL>
</P><P>

<A NAME="IDX234"></A>
<DL>
<DT><U>Relation:</U> <B>DISJOINT-COVERING</B> <I>((?c COLLECTION) (?disjointcover SET))</I>
<DD>True if ?c is covered by the collections in ?disjointCover
and if the member sets in ?disjointCover are mutually-disjoint.  For
example the concepts <CODE>Igneous-Rock</CODE>, <CODE>Metamorphic-Rock</CODE>, and
<CODE>Sedimentary-Rock</CODE> together form a disjoint covering of the concept <CODE>Rock</CODE>.
</DL>
</P><P>

<A NAME="IDX235"></A>
<DL>
<DT><U>Relation:</U> <B>DOCUMENTATION</B> <I>((?x THING) (?s STRING))</I>
<DD>?s is a documentation string attached to ?x.  Some
of the PowerLoom text processing tools look for documentation strings and 
import them into documents.
</DL>
</P><P>

<A NAME="IDX236"></A>
<DL>
<DT><U>Relation:</U> <B>DOMAIN</B> <I>((?r RELATION) (?d COLLECTION))</I>
<DD>True if for any tuple <CODE>T</CODE> that satifies ?r, the first
argument of <CODE>T</CODE> necessarily belongs to the concept ?d.  <CODE>domain</CODE> exists
for convenience only and is defined in terms of <CODE>nth-domain</CODE>.  <CODE>domain</CODE>
assertions should be avoided, since they create redundant <CODE>nth-domain</CODE>
propositions (use <CODE>nth-domain</CODE> directly).
</DL>
</P><P>

<A NAME="IDX237"></A>
<DL>
<DT><U>Relation:</U> <B>DUPLICATE-FREE</B> <I>((?c COLLECTION))</I>
<DD>?c is duplicate-free if no two members
denote the same object.
</DL>
</P><P>

<A NAME="IDX238"></A>
<DL>
<DT><U>Concept:</U> <B>DUPLICATE-FREE-COLLECTION</B> <I>((?c COLLECTION))</I>
<DD>?c is free of duplicates
</DL>
</P><P>

<A NAME="IDX239"></A>
<DL>
<DT><U>Relation:</U> <B>EMPTY</B> <I>((?c COLLECTION))</I>
<DD>The collection ?c is empty if it has no members.  Note
that for collections possessing open-world semantics, (e.g., most concepts)
the fact that the collection has no known members does not necessarily
imply that it is empty.
</DL>
</P><P>

<A NAME="IDX240"></A>
<DL>
<DT><U>Relation:</U> <B>EQUIVALENT-RELATION</B> <I>((?r RELATION) (?equiv RELATION))</I>
<DD>True if ?r is equivalent to ?equiv; written in set notation,
?r = ?equiv.  This relation will generate bindings for at most one unbound
argument.
</DL>
</P><P>

<A NAME="IDX241"></A>
<DL>
<DT><U>Relation:</U> <B>EXAMPLE</B> <I>((?r RELATION) (?e THING))</I>
<DD>?e is an example of (the use of) ?r.
</DL>
</P><P>

<A NAME="IDX242"></A>
<DL>
<DT><U>Function:</U> <B>FILLERS</B> <I>((?r RELATION) (?i THING)) :-&#62; (?members SET)</I>
<DD>Given a relation ?r and instance ?i, returns
a set of known fillers of ?r applied to ?i.  IMPORTANT: this also collects
intensional fillers such as skolems that might be identical extensionally.
</DL>
</P><P>

<A NAME="IDX243"></A>
<DL>
<DT><U>Concept:</U> <B>FRAME-PREDICATE</B> <I>((?c RELATION))</I>
<DD>A frame predicate is a second-order relation that
is used to describe constraints on the set of fillers for a binary
relation applied to an instance.  Examples of frame predicates are
<CODE>range-cardinality</CODE>, <CODE>range-type</CODE>, and <CODE>numeric-minimum</CODE>.  Frame predicates
are typically used to capture the kinds of relations manipulated
by description logic systems such as USC/ISI's Loom system.
</DL>
</P><P>

<A NAME="IDX244"></A>
<DL>
<DT><U>Class:</U> <B>METHOD-SLOT</B> <I>: SLOT</I>
<DD>Not documented.
<A NAME="IDX245"></A>
<DL>
<DT><U>Slot:</U>  <B>method-setter?</B> <I>: BOOLEAN</I>
<DD>Not documented.
</DL>
<A NAME="IDX246"></A>
<DL>
<DT><U>Slot:</U>  <B>method-parameter-names</B> <I>: (LIST OF SYMBOL)</I>
<DD>Not documented.
</DL>
<A NAME="IDX247"></A>
<DL>
<DT><U>Slot:</U>  <B>method-parameter-type-specifiers</B> <I>: (LIST OF TYPE-SPEC)</I>
<DD>Not documented.
</DL>
<A NAME="IDX248"></A>
<DL>
<DT><U>Slot:</U>  <B>method-return-type-specifiers</B> <I>: (LIST OF TYPE-SPEC)</I>
<DD>Not documented.
</DL>
<A NAME="IDX249"></A>
<DL>
<DT><U>Slot:</U>  <B>method-stringified-source</B> <I>: STRING</I>
<DD>Not documented.
</DL>
<A NAME="IDX250"></A>
<DL>
<DT><U>Slot:</U>  <B>method-code</B> <I>: METHOD-CODE</I>
<DD>Not documented.
</DL>
<A NAME="IDX251"></A>
<DL>
<DT><U>Slot:</U>  <B>function-code</B> <I>: FUNCTION-CODE</I>
<DD>Not documented.
</DL>
<A NAME="IDX252"></A>
<DL>
<DT><U>Slot:</U>  <B>method-function?</B> <I>: BOOLEAN</I>
<DD>Not documented.
</DL>
</DL>
</P><P>

<A NAME="IDX253"></A>
<DL>
<DT><U>Relation:</U> <B>GOES-FALSE-DEMON</B> <I>((?r RELATION) (?computation COMPUTED-PROCEDURE))</I>
<DD>Names a <CODE>computation</CODE> (a function) that is attached (logically)
to ?r  Each time a proposition with predicate ?r becomes
false, the function is applied to that proposition.
</DL>
</P><P>

<A NAME="IDX254"></A>
<DL>
<DT><U>Relation:</U> <B>GOES-TRUE-DEMON</B> <I>((?r RELATION) (?computation COMPUTED-PROCEDURE))</I>
<DD>Names a <CODE>computation</CODE> (a function) that is attached (logically)
to ?r  Each time a proposition with predicate ?r becomes
true, the function is applied to that proposition.
</DL>
</P><P>

<A NAME="IDX255"></A>
<DL>
<DT><U>Relation:</U> <B>GOES-UNKNOWN-DEMON</B> <I>((?r RELATION) (?computation COMPUTED-PROCEDURE))</I>
<DD>Names a <CODE>computation</CODE> (a function) that is attached (logically)
to ?r  Each time a proposition with predicate ?r becomes
unknown, the function is applied to that proposition.
</DL>
</P><P>

<A NAME="IDX256"></A>
<DL>
<DT><U>Relation:</U> <B>HOLDS</B> <I>((?relation RELATION) (?arguments THING))</I>
<DD>True if the tuple <VAR>?arguments</VAR> is a member of the
relation <VAR>?relation</VAR>.  <CODE>holds</CODE> is a variable arity predicate that takes
a relation as its first argument, and zero or more additional arguments.
It returns values equivalent to a subgoal that has the first argument
as a predicate and the remaining arguments shifted one place to the left.
For <CODE>holds</CODE> to succeed, the (first) relation argument must be bound --
PowerLoom will NOT cycle through all relations searching for ones that
permit the proof to succeed.  However, users can obtain the same effect
if they choose by using other second-order predicates to generate
relation bindings.  For example, the query
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>   (retrieve all ?x (and (Relation ?r)
                         (holds ?r Fred ?x)))
</pre></td></tr></table></P><P>

retrieves all constants for which there is some binary relation that
relates <CODE>Fred</CODE> to that relation.
</DL>
</P><P>

<A NAME="IDX257"></A>
<DL>
<DT><U>Relation:</U> <B>IMAGE-URL</B> <I>((?x THING) (?url STRING))</I>
<DD>?url is a URL pointing to an image illustrating ?x.
The Ontosaurus browser looks for <CODE>image-url</CODE> values attached to
objects it is presenting, and displays them prominently, thereby spiffing
up its displays.
</DL>
</P><P>

<A NAME="IDX258"></A>
<DL>
<DT><U>Relation:</U> <B>INEQUALITY</B> <I>((?x THING) (?y THING))</I>
<DD>Abstract superrelation of inequality relations.
</DL>
</P><P>

<A NAME="IDX259"></A>
<DL>
<DT><U>Relation:</U> <B>INSTANCE-OF</B> <I>((?x THING) (?c COLLECTION))</I>
<DD>True if ?x is an instance of ?c.  Can
be used to generate concept values of ?c, given an instance ?x.
</DL>
</P><P>

<A NAME="IDX260"></A>
<DL>
<DT><U>Function:</U> <B>INVERSE</B> <I>((?r BINARY-RELATION)) :-&#62; (?inverserelation THING)</I>
<DD>Function that returns the inverse relation for ?r.
PERFORMANCE NOTE: for best results there should be only one <CODE>(inverse R I)</CODE>
assertion per relation pair <CODE>R</CODE> and <CODE>I</CODE>.  In that case <CODE>R</CODE> is viewed as the
canonical relation and <CODE>I</CODE> simply provides a different access mechanism to
the canonical relation.  In a logic-based KR paradigm inverse relations are
redundant and do not add anything that couldn't be represented or queried
without them, however, sometimes they can provide some extra convenience for
users.  Asserting <CODE>(inverse I R)</CODE> also will not cause an error but can degrade
backward inference performance due to the extra redundant rule that gets
generated.  If domain rules will be written in terms of both <CODE>R</CODE> and <CODE>I</CODE> (as
opposed to only <CODE>R</CODE>), <CODE>(inverse I R)</CODE> should be asserted also to get full
inferential connectivity between the two relations.
</DL>
</P><P>

<A NAME="IDX261"></A>
<DL>
<DT><U>Relation:</U> <B>IRREFLEXIVE</B> <I>((?r RELATION))</I>
<DD>A binary relation ?r is irreflexive if it is false when both
of its arguments are identical.
</DL>
</P><P>

<A NAME="IDX262"></A>
<DL>
<DT><U>Relation:</U> <B>ISSUE</B> <I>((?x THING) (?s STRING))</I>
<DD>?s is an issue attached to ?x.  An issue string 
normally comments on a topic that has not been resolved to everyone's
satisfaction.
</DL>
</P><P>

<A NAME="IDX263"></A>
<DL>
<DT><U>Relation:</U> <B>IST</B> <I>((?context CONTEXT) (?p PROPOSITION))</I>
<DD>True if proposition <VAR>?p</VAR> is true in context <VAR>?context</VAR>.
The <CODE>IST</CODE> (is true) relation allows one to evaluate a query or rule in more
than one context.  A common use of <CODE>IST</CODE> is in defining <CODE>lifting axioms</CODE>
that import knowledge from one context to another.  For example, below is
a rule that accesses a <CODE>patient-record</CODE> relation in a module called
<CODE>Medical-Kb</CODE>, <CODE>lifts-out</CODE> the <CODE>age</CODE> column, and imports it into a
<CODE>has-age</CODE> relation in the current context.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  (&#60;= (has-age ?person ?age)
      (and (has-ssn ?person ?ssn)
           (exists (?1 ?2 ?3 ?4)
              (ist Medical-Kb (patient-record ?ssn ?1 ?2 ?age ?3 ?4)))))
</pre></td></tr></table></P><P>

</DL>
</P><P>

<A NAME="IDX264"></A>
<DL>
<DT><U>Function:</U> <B>LENGTH</B> <I>((?x THING)) :-&#62; (?z INTEGER)</I>
<DD>Function that returns the length of a string or a logical list.
NOT YET IMPLEMENTED FOR LISTS.
</DL>
</P><P>

<A NAME="IDX265"></A>
<DL>
<DT><U>Relation:</U> <B>LENGTH-OF-LIST</B> <I>((?l COLLECTION) (?length INTEGER))</I>
<DD>Computes the length of the list or set ?l.
</DL>
</P><P>

<A NAME="IDX266"></A>
<DL>
<DT><U>Relation:</U> <B>LEXEME</B> <I>((?r THING) (?s STRING))</I>
<DD>?s is a lexeme for the relation or individual ?r.
A relation or individual ?r can have zero or more lexemes, words that are
natural langage equivalents of a logical constant.  The same lexeme may be
attached to more than one constant.
</DL>
</P><P>

<A NAME="IDX267"></A>
<DL>
<DT><U>Class:</U> <B>LIST</B> <I>: SEQUENCE</I>
<DD>Not documented.
<A NAME="IDX268"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-value</B> <I>: OBJECT</I>
<DD>Not documented.
</DL>
<A NAME="IDX269"></A>
<DL>
<DT><U>Slot:</U>  <B>the-cons-list</B> <I>: (CONS OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Not documented.
</DL>
</DL>
</P><P>

<A NAME="IDX270"></A>
<DL>
<DT><U>Function:</U> <B>LISTOF</B> <I>((?m THING)) :-&#62; (?c LIST)</I>
<DD>Term-forming function that defines an ordered list
consisting of all function arguments.  Within logical expressions
<CODE>listof</CODE> is most commonly used in conjunction with the <CODE>member-of</CODE>
predicate.  For example the query
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  (retrieve ?x (member-of ?x (listof a b c)))
</pre></td></tr></table></P><P>

returns the constants <CODE>a</CODE>, <CODE>b</CODE>, and <CODE>c</CODE> on successive iterations.
</DL>
</P><P>

<A NAME="IDX271"></A>
<DL>
<DT><U>Relation:</U> <B>MAXIMUM-VALUE</B> <I>((?l COLLECTION) (?max NUMBER))</I>
<DD>Binds ?max to the maximum of the numbers in the list ?l.
</DL>
</P><P>

<A NAME="IDX272"></A>
<DL>
<DT><U>Relation:</U> <B>MEAN-VALUE</B> <I>((?l COLLECTION) (?mean NUMBER))</I>
<DD>Binds ?mean to the mean of the numbers in ?l.
</DL>
</P><P>

<A NAME="IDX273"></A>
<DL>
<DT><U>Relation:</U> <B>MEDIAN-VALUE</B> <I>((?l COLLECTION) (?median NUMBER))</I>
<DD>Binds ?median to the median of the numbers in ?l.
</DL>
</P><P>

<A NAME="IDX274"></A>
<DL>
<DT><U>Relation:</U> <B>MEMBER-OF</B> <I>((?x THING) (?c COLLECTION))</I>
<DD>TRUE if ?x is a member of collection ?c.  A common use
of <CODE>member-of</CODE> is for binding a variable to successive members in a list
or set (see <CODE>listof</CODE> and <CODE>setof</CODE>).
</DL>
</P><P>

<A NAME="IDX275"></A>
<DL>
<DT><U>Relation:</U> <B>MINIMUM-VALUE</B> <I>((?l COLLECTION) (?min NUMBER))</I>
<DD>Binds ?min to the minimum of the numbers in the list ?l.
</DL>
</P><P>

<A NAME="IDX276"></A>
<DL>
<DT><U>Relation:</U> <B>MUTUALLY-DISJOINT-COLLECTION</B> <I>((?s SET))</I>
<DD>True if the members of ?s are pair-wise disjoint.  Used
most often to expresse disjointness constraints between concepts.  For
example
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>   (mutually-disjoint-collection (setof MAN WOMAN))
</pre></td></tr></table></P><P>

states that the concepts MAN and WOMAN are disjoint.
</P><P>

</DL>
</P><P>

<A NAME="IDX277"></A>
<DL>
<DT><U>Relation:</U> <B>NTH-DOMAIN</B> <I>((?r RELATION) (?i INTEGER) (?d COLLECTION))</I>
<DD>True if the nth value for a tuple T satisfying
?r must belong to the concept ?d.  Argument counting starts at zero.
</DL>
</P><P>

<A NAME="IDX278"></A>
<DL>
<DT><U>Relation:</U> <B>NUMERIC-MAXIMUM</B> <I>((?r RELATION) (?i THING) (?n NUMBER))</I>
<DD>Relation that specifies an upper bound <VAR>?n</VAR> on any numeric
value that can belong to the set of fillers of the relation ?r applied to ?i.
</DL>
</P><P>

<A NAME="IDX279"></A>
<DL>
<DT><U>Relation:</U> <B>NUMERIC-MINIMUM</B> <I>((?r RELATION) (?i THING) (?n NUMBER))</I>
<DD>Relation that specifies a lower bound <VAR>?n</VAR> on any numeric
value that can belong to the set of fillers of the relation ?r applied to ?i.
</DL>
</P><P>

<A NAME="IDX280"></A>
<DL>
<DT><U>Concept:</U> <B>NUMERIC-SET</B> <I>((?s COLLECTION))</I>
<DD>?s is a set of numbers
</DL>
</P><P>

<A NAME="IDX281"></A>
<DL>
<DT><U>Relation:</U> <B>ORDERED</B> <I>((?c COLLECTION))</I>
<DD>?c is ordered if the ordering of its
members is significant.  Lists are ordered, while sets are not.
</DL>
</P><P>

<A NAME="IDX282"></A>
<DL>
<DT><U>Relation:</U> <B>PHRASE</B> <I>((?r THING) (?s STRING))</I>
<DD>A phrase is a variablized sentence, a template, that
is used to express individual axiomatic facts as natural language
sentences.  By convention, a phrase contains one or more occurrences
of each variable in a relation or concept definition, it does not
begin with a capital letter, and it has no concluding period.
Systematic attachment of phrases to relations can be leveraged by
tools that generate natural language paraphrases of logic sentences.
</DL>
</P><P>

<A NAME="IDX283"></A>
<DL>
<DT><U>Function:</U> <B>PROJECT-COLUMN</B> <I>((?i INTEGER) (?c COLLECTION)) :-&#62; (?l LIST)</I>
<DD>Project elements in column ?i (zero-based) of the tuples
of ?c and collect them into a list ?l. 
</DL>
</P><P>

<A NAME="IDX284"></A>
<DL>
<DT><U>Relation:</U> <B>PROPER-SUBRELATION</B> <I>((?r RELATION) (?sub RELATION))</I>
<DD>True iff ?sub is a proper subrelation of ?r; written in
set notation, ?sub &#60; ?r.  This relation will generate bindings for at most
one unbound argument.
</DL>
</P><P>

<A NAME="IDX285"></A>
<DL>
<DT><U>Relation:</U> <B>PROPER-SUPERRELATION</B> <I>((?r RELATION) (?super RELATION))</I>
<DD>True iff ?super is a proper superrelation of ?r; written in
set notation, ?super &#62; ?r.  This relation will generate bindings for at most
one unbound argument.
</DL>
</P><P>

<A NAME="IDX286"></A>
<DL>
<DT><U>Class:</U> <B>PROPOSITION</B> <I>: CONTEXT-SENSITIVE-OBJECT, DYNAMIC-SLOTS-MIXIN, BACKLINKS-MIXIN</I>
<DD></P><P>

<A NAME="IDX287"></A>
<DL>
<DT><U>Slot:</U>  <B>home-context</B> <I>: CONTEXT</I>
<DD>Not documented.
</DL>
<A NAME="IDX288"></A>
<DL>
<DT><U>Slot:</U>  <B>kind</B> <I>: KEYWORD</I>
<DD>Not documented.
</DL>
<A NAME="IDX289"></A>
<DL>
<DT><U>Slot:</U>  <B>truth-value</B> <I>: TRUTH-VALUE</I>
<DD>Not documented.
</DL>
<A NAME="IDX290"></A>
<DL>
<DT><U>Slot:</U>  <B>arguments</B> <I>: VECTOR</I>
<DD>Not documented.
</DL>
<A NAME="IDX291"></A>
<DL>
<DT><U>Slot:</U>  <B>operator</B> <I>: GENERALIZED-SYMBOL</I>
<DD>Not documented.
</DL>
<A NAME="IDX292"></A>
<DL>
<DT><U>Slot:</U>  <B>dependent-propositions</B> <I>: (NON-PAGING-INDEX OF PROPOSITION)</I>
<DD>Not documented.
</DL>
</DL>
</P><P>

<A NAME="IDX293"></A>
<DL>
<DT><U>Relation:</U> <B>RANGE</B> <I>((?r RELATION) (?rng COLLECTION))</I>
<DD>True if for any tuple <CODE>T</CODE> that satifies ?r, the last
argument of <CODE>T</CODE> necessarily belongs to the concept ?rng.  <CODE>range</CODE> exists
for convenience only and is defined in terms of <CODE>nth-domain</CODE>.  <CODE>range</CODE>
assertions should be avoided, since they create redundant <CODE>nth-domain</CODE>
propositions (use <CODE>nth-domain</CODE> directly).
</DL>
</P><P>

<A NAME="IDX294"></A>
<DL>
<DT><U>Function:</U> <B>RANGE-CARDINALITY</B> <I>((?r RELATION) (?i THING)) :-&#62; (?card INTEGER)</I>
<DD>Function that returns the cardinality of the set
of fillers of the relation ?r applied to ?i.  The cardinality function
returns a value only when the relations <CODE>range-min-cardinality</CODE> and
<CODE>range-max-cardinality</CODE> compute identical values, i.e., when the
best lower and upper bounds on the cardinality are equal.  Each of
these bounding functions employs a variety of rules to try and
compute a tight bound.
</DL>
</P><P>

<A NAME="IDX295"></A>
<DL>
<DT><U>Relation:</U> <B>RANGE-CARDINALITY-LOWER-BOUND</B> <I>((?r RELATION) (?i THING) (?lb INTEGER))</I>
<DD>Relation that specifies a lower bound on the cardinality 
of the set of fillers of the relation ?r applied to ?i.  The difference
between <CODE>range-cardinality-lower-bound</CODE> and <CODE>range-min-cardinality</CODE> is
subtle but significant.   Suppose we state that nine is a lower bound
on the number of planets in the solar system, and then ask if eight is
(also) a lower bound:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>   (assert (range-cardinality-lower-bound hasPlanets SolarSystem 9))
   (ask (range-cardinality-lower-bound hasPlanets SolarSystem 8))  ==&#62; TRUE
</pre></td></tr></table></P><P>

PowerLoom will return TRUE.  However if we ask if the minimum cardinality
of the solar system's planets is eight, we get back UNKNOWN
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>   (ask (range-min-cardinality hasPlanets SolarSystem 8)) ==&#62; UNKNOWN
</pre></td></tr></table></P><P>

because eight is not the tightest lower bound.
</DL>
</P><P>

<A NAME="IDX296"></A>
<DL>
<DT><U>Relation:</U> <B>RANGE-CARDINALITY-UPPER-BOUND</B> <I>((?r RELATION) (?i THING) (?ub INTEGER))</I>
<DD>Relation that specifies an upper bound on the cardinality 
of the set of fillers of the relation ?r applied to ?i. (see the discussion
for <CODE>range-cardinality-lower-bound</CODE>).
</DL>
</P><P>

<A NAME="IDX297"></A>
<DL>
<DT><U>Function:</U> <B>RANGE-MAX-CARDINALITY</B> <I>((?r RELATION) (?i THING)) :-&#62; (?maxcard INTEGER)</I>
<DD>Returns the strictest computable upper bound on the
cardinality of the set of fillers of the relation ?r applied to ?i.
(see the discussion for <CODE>range-cardinality-lower-bound</CODE>).
</DL>
</P><P>

<A NAME="IDX298"></A>
<DL>
<DT><U>Function:</U> <B>RANGE-MIN-CARDINALITY</B> <I>((?r RELATION) (?i THING)) :-&#62; (?mincard INTEGER)</I>
<DD>Returns the strictest computable lower bound on the
cardinality of the set of fillers of the relation ?r applied to ?i.
(see the discussion for <CODE>range-cardinality-lower-bound</CODE>).
</DL>
</P><P>

<A NAME="IDX299"></A>
<DL>
<DT><U>Relation:</U> <B>RANGE-TYPE</B> <I>((?r RELATION) (?i THING) (?type COLLECTION))</I>
<DD>Relation that specifies a type/range of the relation ?r applied to ?i.
Multiple range types may be asserted for a single pair &#60;?r,?i&#62;.  Technically,
a retrieval of types for a given pair should include all supertypes
(superconcepts) of any type that is produced, but for utility's sake,
only asserted or directly inferrable types are returned.
</DL>
</P><P>

<A NAME="IDX300"></A>
<DL>
<DT><U>Relation:</U> <B>REFLEXIVE</B> <I>((?r RELATION))</I>
<DD>A binary relation ?r is reflexive if it is always true when
both of its arguments are identical.
</DL>
</P><P>

<A NAME="IDX301"></A>
<DL>
<DT><U>Class:</U> <B>RELATION</B> <I>: MAPPABLE-OBJECT</I>
<DD>Not documented.
<A NAME="IDX302"></A>
<DL>
<DT><U>Slot:</U>  <B>abstract?</B> <I>: BOOLEAN</I>
<DD>Not documented.
</DL>
</DL>
</P><P>

<A NAME="IDX303"></A>
<DL>
<DT><U>Relation:</U> <B>RELATION-COMPUTATION</B> <I>((?r RELATION) (?computation COMPUTED-PROCEDURE))</I>
<DD>Names a <CODE>computation</CODE> (a function) that evaluates an (atomic) relation
proposition during query processing.  The function is passed a proposition
for evaluation for which all arguments are bound.  The function
returns a BOOLEAN if it represents a predicate, or some sort of value
if it is a function.
</DL>
</P><P>

<A NAME="IDX304"></A>
<DL>
<DT><U>Relation:</U> <B>RELATION-CONSTRAINT</B> <I>((?r RELATION) (?computation COMPUTED-PROCEDURE))</I>
<DD>Names a <CODE>computation</CODE> (a function) that evaluates an (atomic) relation
proposition during query processing.  The function is passed a proposition
for evaluation for which at most one argument is unbound.  The function
returns a BOOLEAN if it represents a predicate, or some sort of value
if it is a function.  If all arguments are bound the function computes whether
the constraint holds.  If all but one argument is bound and the unbound
argument is a pattern variable then the missing value is computed.
</DL>
</P><P>

<A NAME="IDX305"></A>
<DL>
<DT><U>Relation:</U> <B>RELATION-EVALUATOR</B> <I>((?r RELATION) (?ev COMPUTED-PROCEDURE))</I>
<DD>Names an <CODE>evaluator</CODE> (a function) that evaluates an (atomic) relation
proposition during constraint propagation.  This defines an extensible
means for computing using auxiliary data structures.  The function is passed
a proposition for evaluation which might update the proposition, generate
additional assertions or trigger further evaluations.  Evaluators have to
check the truth-value of the passed-in proposition and perform their actions
accordingly.  An evaluated proposition might be true, false or even unknown
in case the propositon was just newly constructed.
</DL>
</P><P>

<A NAME="IDX306"></A>
<DL>
<DT><U>Relation:</U> <B>RELATION-SPECIALIST</B> <I>((?r RELATION) (?sp COMPUTED-PROCEDURE))</I>
<DD>Names a <CODE>specialist</CODE> (a function) that evaluates an (atomic) relation
proposition during query processing.  This defines an extensible
means for computing with the control stack.  The function is passed
a CONTROL-FRAME that contains the proposition, and returns a keyword
:FINAL-SUCCESS, :CONTINUING-SUCCESS, :FAILURE, or :TERMINAL-FAILURE
that controls the result of the computation.
</DL>
</P><P>

<A NAME="IDX307"></A>
<DL>
<DT><U>Concept:</U> <B>SCALAR</B> <I>((?x SCALAR))</I>
<DD>The class of scalar quantities.
</DL>
</P><P>

<A NAME="IDX308"></A>
<DL>
<DT><U>Concept:</U> <B>SCALAR-INTERVAL</B> <I>((?x SCALAR))</I>
<DD>An interval of scalar quantities. 
</DL>
</P><P>

<A NAME="IDX309"></A>
<DL>
<DT><U>Class:</U> <B>SET</B> <I>: LIST, SET-MIXIN</I>
<DD>Not documented.
<A NAME="IDX310"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-value</B> <I>: OBJECT</I>
<DD>Not documented.
</DL>
</DL>
</P><P>

<A NAME="IDX311"></A>
<DL>
<DT><U>Function:</U> <B>SETOF</B> <I>((?m THING)) :-&#62; (?c SET)</I>
<DD>Term-forming function that defines an enumerated set
consisting of all function arguments.  <CODE>setof</CODE> is like <CODE>listof</CODE> except
that it removes duplicate values.
</DL>
</P><P>

<A NAME="IDX312"></A>
<DL>
<DT><U>Relation:</U> <B>SINGLE-VALUED</B> <I>((?c RELATION))</I>
<DD>The relation ?c is single-valued if the value of its
last argument is a function of all other arguments.  All functions
are single-valued (see <CODE>function</CODE>).
</DL>
</P><P>

<A NAME="IDX313"></A>
<DL>
<DT><U>Relation:</U> <B>SQUARE-ROOT</B> <I>((?x NUMBER) (?y NUMBER))</I>
<DD>Relation that returns the positive and negative square roots:
?y = sqrt(?x).  For positive roots only see function SQRT.
</DL>
</P><P>

<A NAME="IDX314"></A>
<DL>
<DT><U>Relation:</U> <B>STANDARD-DEVIATION</B> <I>((?l COLLECTION) (?sd NUMBER))</I>
<DD>Binds ?sd to the standard deviation of the numbers in ?l.
</DL>
</P><P>

<A NAME="IDX315"></A>
<DL>
<DT><U>Function:</U> <B>STRING-CONCATENATE</B> <I>((?x1 STRING) (?x2 STRING)) :-&#62; (?x3 STRING)</I>
<DD>Concatenate strings ?x1 and ?x2 and bind ?x3 to the result.
</DL>
</P><P>

<A NAME="IDX316"></A>
<DL>
<DT><U>Relation:</U> <B>SUBRELATION</B> <I>((?r RELATION) (?sub RELATION))</I>
<DD>True iff ?sub is a subrelation of ?r; written in set
notation, ?sub =&#60; ?r.  This relation will generate bindings for at most
one unbound argument.
</DL>
</P><P>

<A NAME="IDX317"></A>
<DL>
<DT><U>Relation:</U> <B>SUBSET-OF</B> <I>((?sub COLLECTION) (?super COLLECTION))</I>
<DD>True if ?sub is a subset of ?super.  For performance
reasons, the <CODE>subset-of</CODE> predicate refuses to search for bindings if
both of its variables are unbound.  Implementation note: <CODE>subset-of</CODE> 
is treated specially internally to PowerLoom, and hence Powerloom does not
permit the augmentation of <CODE>subset-of</CODE> with additional inference rules.
In otherwords, <CODE>subset-of</CODE> behaves semantically like an operator instead
of a relation.
</DL>
</P><P>

<A NAME="IDX318"></A>
<DL>
<DT><U>Function:</U> <B>SUBSTRING</B> <I>((?s STRING) (?start INTEGER) (?end INTEGER)) :-&#62; (?sub STRING)</I>
<DD>Generate the substring of ?s starting at position ?start
(zero-based), ending just before position ?end and bind ?sub to the result.
This is the PowerLoom equivalent to the STELLA method <CODE>subsequence</CODE>.  In
addition, this function can be used to locate substrings in strings by
supplying values for ?s and ?sub and allowing ?start and ?end to be
bound by the function specialist.  In other words,
      (retrieve all (?start ?end) (substring "foo" ?start ?end "o"))
 ==&#62;  ?start = 1, ?end = 2,
      ?start = 2, ?end = 3.
</DL>
</P><P>

<A NAME="IDX319"></A>
<DL>
<DT><U>Relation:</U> <B>SUM</B> <I>((?l COLLECTION) (?sum NUMBER))</I>
<DD>Binds ?sum to the sum of the numbers in the list ?l.
</DL>
</P><P>

<A NAME="IDX320"></A>
<DL>
<DT><U>Relation:</U> <B>SUPERRELATION</B> <I>((?r RELATION) (?super RELATION))</I>
<DD>True iff ?super is a superrelation of ?r; written in set
notation, ?super &#62;= ?r.  This relation will generate bindings for at most
one unbound argument.
</DL>
</P><P>

<A NAME="IDX321"></A>
<DL>
<DT><U>Relation:</U> <B>SYMMETRIC</B> <I>((?r RELATION))</I>
<DD>A binary relation ?r is symmetric if it is commutative.
</DL>
</P><P>

<A NAME="IDX322"></A>
<DL>
<DT><U>Relation:</U> <B>SYNONYM</B> <I>((?term THING) (?synonym THING))</I>
<DD>Assert that <VAR>?synonym</VAR> is a synonym of <VAR>?term</VAR>.  This
causes all references to <VAR>?synonym</VAR> to be interpreted as references
to <VAR>?term</VAR>.  Retraction eliminates a synonym relation.
</DL>
</P><P>

<A NAME="IDX323"></A>
<DL>
<DT><U>Class:</U> <B>THING</B> <I>: STANDARD-OBJECT, DYNAMIC-SLOTS-MIXIN</I>
<DD>Defines a class that must be inherited by any
class that participates in the PowerLoom side of things.
<A NAME="IDX324"></A>
<DL>
<DT><U>Slot:</U>  <B>surrogate-value-inverse</B> <I>: SURROGATE</I>
<DD>Not documented.
</DL>
</DL>
</P><P>

<A NAME="IDX325"></A>
<DL>
<DT><U>Relation:</U> <B>TOTAL</B> <I>((?r FUNCTION))</I>
<DD>True if the function <VAR>?r</VAR> is defined for all
combinations of inputs.  By default, functions are not assumed to
be total (unlike Prolog, which <CODE>does</CODE> make such an assumption.
For example, if we define a two-argument function <CODE>foo</CODE> and then retrieve
its value applied to some random instances <CODE>a</CODE> and <CODE>b</CODE>, we get nothing
back:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>   (deffunction foo (?x ?y) :-&#62; ?z)
   (retrieve ?x (= ?x (foo a b)))
</pre></td></tr></table></P><P>

However, if we assert that <CODE>foo</CODE> is total, then we get a skolem back
when we execute the same retrieve:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>   (assert (total foo))
   (retrieve ?x (= ?x (foo a b)))
</pre></td></tr></table></P><P>

</DL>
</P><P>

<A NAME="IDX326"></A>
<DL>
<DT><U>Relation:</U> <B>TRANSITIVE</B> <I>((?r RELATION))</I>
<DD>A binary relation ?r is transitive if (?r ?x ?y)
and (?r ?y ?z) implies that (?r ?x ?z).  Note that functions cannot
be transitive, since their single-valuedness would not allow multiple
different values such as (?r ?x ?y) and (?r ?x ?z) due to the Unique
Names Assumption made by PowerLoom.
</DL>
</P><P>

<A NAME="IDX327"></A>
<DL>
<DT><U>Relation:</U> <B>TYPE-OF</B> <I>((?c COLLECTION) (?x THING))</I>
<DD>True if ?x is a member of the concept ?c.
</DL>
</P><P>

<A NAME="IDX328"></A>
<DL>
<DT><U>Function:</U> <B>VALUE</B> <I>((?function FUNCTION) (?arguments THING)) :-&#62; (?value THING)</I>
<DD>True if applying <VAR>?function</VAR> to <VAR>?arguments</VAR>
yields the value <CODE>?value</CODE>.  The <CODE>value</CODE> predicate is the analog
of <CODE>holds</CODE>, except that it applies to functions instead of relations.
</DL>
</P><P>

<A NAME="IDX329"></A>
<DL>
<DT><U>Relation:</U> <B>VARIABLE-ARITY</B> <I>((?r RELATION))</I>
<DD>Asserts that the relation ?r can take a variable
number of arguments.
</DL>
</P><P>

<A NAME="IDX330"></A>
<DL>
<DT><U>Relation:</U> <B>VARIANCE</B> <I>((?l COLLECTION) (?variance NUMBER))</I>
<DD>Binds ?variance to the variance of the numbers in ?l.
</DL>
</P><P>

<A NAME="Installation"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC63"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_13.html#SEC80">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Hans Chalupsky</I> on <I>May, 25  2006</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>
</FONT>

</BODY>
</HTML>
