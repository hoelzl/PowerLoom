<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on October, 29  2003 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>PowerLoom Manual: Commands</TITLE>

<META NAME="description" CONTENT="PowerLoom Manual: Commands">
<META NAME="keywords" CONTENT="PowerLoom Manual: Commands">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC43"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC42"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC44"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC44"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 8. Commands </H1>
<!--docid::SEC43::-->
<P>

This chapter lists all available PowerLoom commands alphabetically.
Each command is documented with its name, a (possibly empty) list of
parameters specified as <CODE>(&#60;name&#62; &#60;type&#62;)</CODE> pairs, its return
type, and its category (<EM>Command</EM>).  Almost all of the commands implicitly
quote their arguments, meaning that when calling them, you don't need
to add any quotation yourself.  For example, the command
<CODE>all-facts-of</CODE> is defined as follows:
</P><P>

<BLOCKQUOTE>
<A NAME="IDX3"></A>
<DL>
<DT><U>Command:</U> <B>all-facts-of</B> <I>((instanceRef NAME)) : (CONS OF PROPOSITION)</I>
<DD>Return a cons list of all definite (TRUE or FALSE) propositions
that reference the instance <VAR>instanceRef</VAR>.
</DL>
</BLOCKQUOTE>
<P>

The <CODE>all-facts-of</CODE> command has one parameter called
<VAR>instanceRef</VAR> of type <EM>NAME</EM>, and returns a STELLA
<EM>LIST</EM> containing zero or more objects of type
<EM>PROPOSITION</EM> as its result.  The type NAME subsumes the
types SYMBOL, SURROGATE, STRING, and KEYWORD.
Unless you are in a case-sensitive module, the following four commands
are equivalent:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>    (all-facts-of Merryweather)
    (all-facts-of :MERRYWEATHER)
    (all-facts-of "merryweather")
    (all-facts-of @MerryWeather)
</pre></td></tr></table></P><P>

Commands can also have <CODE>&#38;rest</CODE> parameters (similar to Lisp
functions).  These are either used to allow a variable number of
arguments, or to handle optional arguments, since STELLA does not
directly support optional arguments.
</P><P>

Here is a list of important parameter types used in the
command specifications below:
</P><P>

<UL>
<LI><EM>GENERALIZED-SYMBOL</EM>: A generalized symbol is either a plain
symbol (similar to a Lisp symbol) such as <CODE>Merryweather</CODE>, a keyword
(similar to a Lisp keyword) such as <CODE>:KIF</CODE>, or a STELLA surrogate
which is a symbol starting with an at-sign, e.g., <CODE>@CONS</CODE>.  STELLA
surrogates are used as names for objects of arbitrary types.
<P>

<LI><EM>NAME</EM>: Names can be either a string, or a
<EM>GENERALIZED-SYMBOL</EM> (i.e., a symbol, a keyword, or a
surrogate).  If a symbol is supplied, only its symbol-name is used.
Commands that take names as arguments usually coerce whatever argument
is entered into a string, but by allowing a NAME they make it a
little bit more convenient to type a name in an interactive
invocation.<A NAME="DOCF8" HREF="manual_fot.html#FOOT8">(8)</A>
<LI><EM>PARSE-TREE</EM>: A parse tree is similar to a Lisp s-expression,
i.e., it can either be an atom such as a symbol, number, or a string, or
a list of zero or more parse trees.  For example, the expression
<CODE>(happy Fred)</CODE> is a parse tree, and so are its components
<CODE>happy</CODE> and <CODE>Fred</CODE>.
</UL>
<P>

Here is the list of all available PowerLoom commands:
</P><P>

<A NAME="IDX4"></A>
<DL>
<DT><U>Command:</U> <B>all-facts-of</B> <I>((instanceRef NAME)) : (CONS OF PROPOSITION)</I>
<DD>Return a cons list of all definite (TRUE or FALSE) propositions
that reference the instance <VAR>instanceRef</VAR>.  This includes propositions
asserted to be true by default, but it does not include propositions
that are found to be TRUE only by running the query engine.  Facts
inferred to be TRUE by the forward chainer will be included.
Hence, the returned list of facts may be longer in a context where the
forward chainer has been run then in one where it has not (see
<CODE>run-forward-rules</CODE>).
</DL>
</P><P>

<A NAME="IDX5"></A>
<DL>
<DT><U>Command:</U> <B>ask</B> <I>(&#38;rest (proposition&#38;options PARSE-TREE)) : TRUTH-VALUE</I>
<DD>Perform inference to determine whether the proposition specified in
<VAR>proposition&#38;options</VAR> is true.  Return the truth-value found.  <CODE>ask</CODE>
will spend most of its effort to determine whether the proposition
is true and only a little effort via shallow inference strategies to
determine whether it is false.  To find out whether a proposition is
false with full inference effort <CODE>ask</CODE> its negation.
</P><P>

KIF example: <CODE>(ask (happy Fred))</CODE> will return TRUE if Fred was indeed
found to be happy.  Note, that for this query to run, the logic
constant <CODE>Fred</CODE> and the relation <CODE>happy</CODE> must already be defined (see
<CODE>assert</CODE>).  Use <CODE>(set/unset-feature goal-trace)</CODE> to en/disable goal
tracing of the inference engine.
</P><P>

The <CODE>ask</CODE> command supports two options, declared with the keywords
<CODE>:TIMEOUT</CODE> and <CODE>:DONT-OPTIMIZE</CODE>.  The argument to <CODE>:TIMEOUT</CODE> is an
integer or floating point time limit, specified in seconds.  For
example, the command <CODE>(ask (nervous Fred) :timeout 2.0)</CODE> will cease
inference after two seconds if a proof has not been found by then.
The argument to <CODE>:DONT-OPTIMIZE?</CODE> is the constant TRUE, which tells
PowerLoom not to optimize the query before evaluating it.
</DL>
</P><P>

<A NAME="IDX6"></A>
<DL>
<DT><U>Command:</U> <B>assert</B> <I>((proposition PARSE-TREE)) : OBJECT</I>
<DD>Assert the truth of <VAR>proposition</VAR>.  Return the asserted proposition object.
KIF example:  "(assert (happy Fred))" asserts that Fred is indeed happy.
Note that for this assertion to succeed, the relation <CODE>happy</CODE> must already
be defined.  If the constant <CODE>Fred</CODE> has not yet been created, it is
automatically created as a side-effect of calling <CODE>assert</CODE>.
</DL>
</P><P>

<A NAME="IDX7"></A>
<DL>
<DT><U>Command:</U> <B>assert-from-query</B> <I>((query CONS) &#38;rest (options OBJECT)) : (CONS OF PROPOSITION)</I>
<DD>Evaluate <VAR>query</VAR>, instantiate the query proposition for each generated
solution and assert the resulting propositions.  The accepted syntax
is as follows:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre> (assert-from-query &#60;query-command&#62;
                    [:relation &#60;relation-name&#62;]
                    [:pattern &#60;description-term&#62;]
                    [:module &#60;module-name&#62;])
</pre></td></tr></table></P><P>

&#60;query-command&#62; has to be a strict or partial retrieval command. If a
:relation option is supplied, &#60;relation-name&#62; is used as the relation
of the resulting propositions.  In this case the bindings of each
solution will become arguments to the specified relation in the order
of <VAR>query</VAR>s output variables (the arities have to match).  The
:pattern option is a generalization of this mechanism that specifies
an arbitrary proposition pattern to be instantiated by the query's
solution.  In this case &#60;description-term&#62; has to be a SETOFALL or
KAPPA expression whose IO-variables will be bound in sequence to the
bindings of a query solution to generate the resulting proposition.
Finally, if a :module option is specified, the assertions will be
generated in that module.  Note that for this to work the relations
referenced in the query proposition or pattern have to be visible in
the module.  Also, instances will not be copied to the target module,
therefore, the resulting propositions might reference external
out-of-module objects in case they are not visible there.
Here are some examples:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre> (assert-from-query (retrieve all (foo ?x ?y)))
 (assert-from-query (retrieve all (?y ?x)
                             (exists ?z
                               (and (foo ?x ?z)
                                    (foo ?z ?y))))
                    :relation bar :module other)
 (assert-from-query
   (retrieve all (and (relation ?x) (symmetric ?x)))
   :pattern (kappa (?pred)
              (forall (?x ?y)
                (=&#62; (holds ?pred ?x ?y)
                    (holds ?pred ?y ?x))))))
</pre></td></tr></table></P><P>

</DL>
</P><P>

<A NAME="IDX8"></A>
<DL>
<DT><U>Command:</U> <B>assert-rule</B> <I>((ruleName NAME)) : PROPOSITION</I>
<DD>Set the truth value of the rule named <VAR>ruleName</VAR> to 
TRUE.  The proposition having the name <VAR>ruleName</VAR> may be
any arbitrary proposition, although we expect that it is probably
a material implication.  (See <CODE>retract-rule</CODE>).
</DL>
</P><P>

<A NAME="IDX9"></A>
<DL>
<DT><U>Command:</U> <B>cc</B> <I>(&#38;rest (name NAME)) : CONTEXT</I>
<DD>Change the current context to the one named <VAR>name</VAR>.  Return the
value of the new current context.  If no <VAR>name</VAR> is supplied, return
the pre-existing value of the current context.  <CODE>cc</CODE> is a no-op if the
context reference cannot be successfully evaluated.
</DL>
</P><P>

<A NAME="IDX10"></A>
<DL>
<DT><U>Command:</U> <B>classify-relations</B> <I>((module NAME) (local? BOOLEAN)) :</I>
<DD>Classify named relations visible in <VAR>module</VAR>.
If <VAR>local?</VAR>, only classify descriptions defined within <VAR>module</VAR>, i.e.,
don't classify descriptions inherited from ancestor modules.
If <VAR>module</VAR> is NULL, classify relations in all modules.
</P><P>

Conceptually, the classifier operates by comparing each concept or relation
with all other concepts/relations, searching for a proof that a
subsumption relation exists between each pair. Whenever a new subsumption
relation is discovered, the classifier adds an <CODE>implication</CODE> link between
members of the pair, thereby augmenting the structure of the
concept or relation hierarchy. The implemented classification algorithm is
relatively efficient -- it works hard at limiting the number of concepts
or relations that need to be checked for possible subsumption
relationships.
</P><P>

</DL>
</P><P>

<A NAME="IDX11"></A>
<DL>
<DT><U>Command:</U> <B>classify-instances</B> <I>((module NAME) (local? BOOLEAN)) :</I>
<DD>Classify instances visible in <VAR>module</VAR>.
If <VAR>local?</VAR>, only classify instances that belong to <VAR>module</VAR>,
i.e., don't classify instances inherited from ancestor modules.
If <VAR>module</VAR> is NULL, classify instances in all modules.
</P><P>

Conceptually, the classifier operates by comparing each instance
with all concepts in the hierarchy, searching for a
proof for each pairing indicating that the instance belongs to the concept.
Whenever a new <CODE>is-a</CODE> relation is discovered, the classifier
adds an <CODE>is-a</CODE> link between the instance and the concept, thereby
recording an additional fact about the instance.  The implemented
classification algorithm is relatively efficient -- it works hard
at limiting the number of concepts or relations that need to
be checked for possible is-a relationships.
</P><P>

</DL>
</P><P>

<A NAME="IDX12"></A>
<DL>
<DT><U>Command:</U> <B>clear-instances</B> <I>(&#38;rest (name NAME)) :</I>
<DD>Destroy all instances belonging to module <VAR>name</VAR> or any of its children.
Leave meta-objects, e.g., concepts and relations, alone.
If no <VAR>name</VAR> is supplied, the current module will be cleared after
confirming with the user.
</DL>
</P><P>

<A NAME="IDX13"></A>
<DL>
<DT><U>Command:</U> <B>clear-module</B> <I>(&#38;rest (name NAME)) :</I>
<DD>Destroy all objects belonging to module <VAR>name</VAR> or any of its children.
If no <VAR>name</VAR> is supplied, the current module will be cleared after
confirming with the user.  Important modules such as STELLA are protected
against accidental clearing.
</DL>
</P><P>

<A NAME="IDX14"></A>
<DL>
<DT><U>Command:</U> <B>conceive</B> <I>((formula PARSE-TREE)) : OBJECT</I>
<DD>Guess whether <VAR>formula</VAR> represents a term or a sentence/proposition.
If we are not sure, assume its a proposition.
If its, a term, return its internal representation.  If a proposition,
construct a proposition for <VAR>formula</VAR> without asserting its truth value.
Return the conceived proposition object.  KIF example: "(conceive (happy Fred))"
builds the proposition expressing that Fred is happy without explictly asserting
or denying it.  Note, that for this to succeed, the relation <CODE>happy</CODE> must already
be defined (see <CODE>assert</CODE>).  If the logic constant <CODE>Fred</CODE> has not yet been
created, it is automatically created as a side-effect of calling <CODE>conceive</CODE>.
</DL>
</P><P>

<A NAME="IDX15"></A>
<DL>
<DT><U>Command:</U> <B>copyright</B> <I>() :</I>
<DD>Print detailed PowerLoom copyright information.
</DL>
</P><P>

<A NAME="IDX16"></A>
<DL>
<DT><U>Command:</U> <B>defconcept</B> <I>(&#38;rest (args PARSE-TREE)) : NAMED-DESCRIPTION</I>
<DD>Define (or redefine) a concept.  The accepted syntax is:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre> (defconcept &#60;conceptconst&#62; [(&#60;var&#62; &#60;parent&#62;*)]
    [:documentation &#60;string&#62;]
    [:&#60;= &#60;sentence&#62;] | [:=&#62; &#60;sentence&#62;] |
    [:&#60;&#60;= &#60;sentence&#62;] | [:=&#62;&#62; &#60;sentence&#62;] | 
    [:&#60;=&#62; &#60;sentence&#62;] | [:&#60;=&#62;&#62; &#60;sentence&#62;] | [:&#60;&#60;=&#62; &#60;sentence&#62;] |
    [:&#60;&#60;=&#62;&#62; &#60;sentence&#62;] |
    [:axioms {&#60;sentence&#62; | (&#60;sentence&#62;+)}] |
    &#60;keyword-option&#62;*)
</pre></td></tr></table></P><P>

Declaration of a concept variable <CODE>&#60;var&#62;</CODE> is optional, unless any
implication (arrow) options are supplied that need to reference it.  A
possibly empty list of concept names following <CODE>&#60;var&#62;</CODE> is taken as the list
of parents of <CODE>&#60;conceptconst&#62;</CODE>.  Alternatively, parents can be specified
via the <CODE>:=&#62;</CODE> option.  If no parents are specified, the parent of
<CODE>&#60;conceptconst&#62;</CODE> is taken to be THING.  <CODE>&#60;keyword-option&#62;</CODE> represents a
keyword followed by a value that states an assertion about <CODE>&#60;conceptconst&#62;</CODE>.
See <CODE>defrelation</CODE> for a description of <CODE>&#60;keyword-option&#62;</CODE>s.
</P><P>

</DL>
</P><P>

<A NAME="IDX17"></A>
<DL>
<DT><U>Command:</U> <B>deffunction</B> <I>(&#38;rest (args PARSE-TREE)) : NAMED-DESCRIPTION</I>
<DD>Define (or redefine) a logic function.  The accepted syntax is:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre> (deffunction &#60;funconst&#62; (&#60;vardecl&#62;+) [:-&#62; &#60;vardecl&#62;]
    [:documentation &#60;string&#62;]
    [:&#60;= &#60;sentence&#62;] | [:=&#62; &#60;sentence&#62;] |
    [:&#60;&#60;= &#60;sentence&#62;] | [:=&#62;&#62; &#60;sentence&#62;] | 
    [:&#60;=&#62; &#60;sentence&#62;] | [:&#60;=&#62;&#62; &#60;sentence&#62;] |
    [:&#60;&#60;=&#62; &#60;sentence&#62;] | [:&#60;&#60;=&#62;&#62; &#60;sentence&#62;] |
    [:axioms {&#60;sentence&#62; | (&#60;sentence&#62;+)}]
    [&#60;keyword-option&#62;*])
</pre></td></tr></table></P><P>

Function parameters can be typed or untyped.  If the <CODE>:-&#62;</CODE> option is
supplied, it specifies the output variable of the function.  Otherwise,
the last variable in the parameter list is used as the output variable.
See <CODE>defrelation</CODE> for a description of <CODE>&#60;keyword-option&#62;</CODE>s.
</P><P>

</DL>
</P><P>

<A NAME="IDX18"></A>
<DL>
<DT><U>Command:</U> <B>definstance</B> <I>(&#38;rest (args PARSE-TREE)) : LOGIC-OBJECT</I>
<DD>Define (or redefine) a logic instance (<CODE>definstance</CODE> is an alias
for <CODE>defobject</CODE> which see).
</DL>
</P><P>

<A NAME="IDX19"></A>
<DL>
<DT><U>Command:</U> <B>defmodule</B> <I>((name NAME) &#38;rest (options OBJECT)) :</I>
<DD>Define (or redefine) a module named <VAR>name</VAR>.
The accepted syntax is:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  (defmodule &#60;module-name&#62;
     [:documentation &#60;docstring&#62;]
     [:includes {&#60;module-name&#62; | (&#60;module-name&#62;*)}]
     [:uses {&#60;module-name&#62; | (&#60;module-name&#62;*)}]
     [:lisp-package &#60;package-name-string&#62;]
     [:java-package &#60;package-specification-string&#62;]
     [:cpp-namespace &#60;namespace-name-string&#62;]
     [:java-catchall-class
     [:api? {TRUE | FALSE}]
     [:case-sensitive? {TRUE | FALSE}]
     [:shadow (&#60;symbol&#62;*)]
     [:java-catchall-class &#60;class-name-string&#62;]
     [&#60;other-options&#62;*])
</pre></td></tr></table></P><P>

<VAR>name</VAR> can be a string or a symbol.
</P><P>

Modules include objects from other modules via two separate mechanisms:
(1) they inherit from their parents specified via the <CODE>:includes</CODE> option
and/or a fully qualified module name, and (2) they inherit from used
modules specified via the <CODE>:uses</CODE> option.  The main difference between
the two mechanisms is that inheritance from parents is transitive, while
uses-links are only followed one level deep.  I.e., a module A that uses
B will see all objects of B (and any of B's parents) but not see anything
from modules used by B.  Another difference is that only objects declared
as public can be inherited via uses-links (this is not yet enforced).
Note that - contrary to Lisp - there are separate name spaces for classes,
functions, and variables.  For example, a module could inherit the class
<CODE>CONS</CODE> from the <CODE>STELLA</CODE> module, but shadow the function of the same name.
</P><P>

The above discussion of <CODE>:includes</CODE> and <CODE>:uses</CODE> semantics keyed on the
inheritance/visibility of symbols. The PowerLoom system makes another
very important distinction: If a module <CODE>A</CODE> is inherited directly or
indirectly via <CODE>:includes</CODE> specification(s) by a submodule <CODE>B</CODE>, then all
definitions and facts asserted in <CODE>A</CODE> are visible in <CODE>B</CODE>. This is not the
cases for <CODE>:uses</CODE>; the <CODE>:uses</CODE> options does not impact inheritance of
propositions at all.
</P><P>

The list of modules specified in the
<CODE>:includes</CODE> option plus (if supplied) the parent in the path used for
<VAR>name</VAR> become the new module's parents. If no <CODE>:uses</CODE> option was
supplied, the new module will use the <CODE>STELLA</CODE> module by default,
otherwise, it will use the set of specified modules.
If <CODE>:case-sensitive?</CODE> is supplied as TRUE, symbols in the module will be
interned case-sensitively, otherwise (the default), they will be
converted to uppercase before they get interned. Modules can shadow
definitions of functions and classes inherited from parents or used
modules. Shadowing is done automatically, but generates a warning unless
the shadowed type or function name is listed in the <CODE>:shadow</CODE> option of
the module definition .
</P><P>

Examples:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  (defmodule "PL-KERNEL/PL-USER"
    :uses ("LOGIC" "STELLA")
    :package "PL-USER")

  (defmodule PL-USER/GENEALOGY)
</pre></td></tr></table></P><P>

The remaining options are relevant only for modules that contain STELLA
code.  Modules used only to contain knowledge base definitions and assertions
have no use for them:
</P><P>

The keywords <CODE>:lisp-package</CODE>, <CODE>:java-package</CODE>, and <CODE>:cpp-package</CODE> specify
the name of a native package or name space in which symbols of the module
should be allocated when they get translated into one of Lisp, Java, or
C++. By default, Lisp symbols are allocated in the <CODE>STELLA</CODE> package, and
C++ names are translated without any prefixes. The rules that the STELLA
translator uses to attach translated Java objects to classes and packages
are somewhat complex. Use :java-package option to specify a list of
package names (separated by periods) that prefix the Java object in this
module.  Use :java-catchall-class to specify the name of the Java class to
contain all global &#38; special variables, parameter-less functions and functions 
defined on arguments that are not classes in the current module.
The default value will be the name of the module.
</P><P>

When set to TRUE, the :api? option tells the PowerLoom User Manual
generator that all functions defined in this module should be included in
the API section. Additionally, the Java translator makes all API
functions <CODE>synchronized</CODE>.
</P><P>

</DL>
</P><P>

<A NAME="IDX20"></A>
<DL>
<DT><U>Command:</U> <B>defobject</B> <I>(&#38;rest (args PARSE-TREE)) : LOGIC-OBJECT</I>
<DD>Define (or redefine) a logic instance.  The accepted syntax is:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre> (defobject &#60;constant&#62;
    [:documentation &#60;string&#62;]
    [&#60;keyword-option&#62;*])
</pre></td></tr></table></P><P>

<CODE>&#60;keyword-option&#62;</CODE> represents a keyword followed by a value
that states an assertion about &#60;constant&#62;.  See <CODE>defrelation</CODE> for a
description of <CODE>&#60;keyword-option&#62;</CODE>s.
</P><P>

<CODE>defobject</CODE> provides a sugar-coated way to assert a collection of facts
about a logic constant, but otherwise adds nothing in terms of functionality.
</P><P>

</DL>
</P><P>

<A NAME="IDX21"></A>
<DL>
<DT><U>Command:</U> <B>defproposition</B> <I>(&#38;rest (args PARSE-TREE)) : PROPOSITION</I>
<DD>Define (or redefine) a named proposition.  The accepted syntax is:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre> (defproposition &#60;name&#62; &#60;sentence&#62;
    [:documentation &#60;string&#62;]
    [:forward-only? {true | false}]
    [:backward-only? {true | false}]
    [:dont-optimize? {true | false}]
    [:confidence-level {:strict | :default}]
    [&#60;keyword-option&#62;*])
</pre></td></tr></table></P><P>

&#60;sentence&#62; can be any sentence that is legal as a top-level assertion.
&#60;name&#62; can be a string or symbol and will be bound to the asserted
proposition represented by &#60;sentence&#62;.  After this definition every
occurrence of &#60;name&#62; will be replaced by the associated proposition.
</P><P>

The options :forward-only? and :backward-only? can be used to tell the
inference engine to only use the rule in forward or backward direction
(this can also be achieved by using the <CODE>&#60;&#60;=</CODE> or <CODE>=&#62;&#62;</CODE> implication
arrows).  :dont-optimize?  tells the inference engine to not rearrange
the order of clauses in the antecedent of a rule and instead evaluate
them in their original order.  :confidence-level can be used to mark a
proposition as default only.
</P><P>

<CODE>&#60;keyword-option&#62;</CODE> represents a keyword followed by a value
that states an assertion about the proposition &#60;name&#62;.  See <CODE>defrelation</CODE>
for a description of <CODE>&#60;keyword-option&#62;</CODE>s.
</P><P>

</DL>
</P><P>

<A NAME="IDX22"></A>
<DL>
<DT><U>Command:</U> <B>defrelation</B> <I>(&#38;rest (args PARSE-TREE)) : NAMED-DESCRIPTION</I>
<DD>Define (or redefine) a logic relation.  The accepted syntax is:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre> (defrelation &#60;relconst&#62; (&#60;vardecl&#62;+)
    [:documentation &#60;string&#62;]
    [:&#60;= &#60;sentence&#62;] | [:=&#62; &#60;sentence&#62;] |
    [:&#60;&#60;= &#60;sentence&#62;] | [:=&#62;&#62; &#60;sentence&#62;] | 
    [:&#60;=&#62; &#60;sentence&#62;] | [:&#60;=&#62;&#62; &#60;sentence&#62;] |
    [:&#60;&#60;=&#62; &#60;sentence&#62;] | [:&#60;&#60;=&#62;&#62; &#60;sentence&#62;] |
    [:axioms {&#60;sentence&#62; | (&#60;sentence&#62;+)}]
    [&#60;keyword-option&#62;*])
</pre></td></tr></table></P><P>

Relation parameters can be typed or untyped.
<CODE>&#60;keyword-option&#62;</CODE> represents a keyword followed by a value that states an
assertion about <CODE>&#60;relconst&#62;</CODE>.  For example, including the option <CODE>:foo bar</CODE>
states that the proposition <CODE>(foo &#60;relconst&#62; bar)</CODE> is true.  <CODE>:foo (bar fum)</CODE>
states that both <CODE>(foo &#60;relconst&#62; bar)</CODE> and <CODE>(foo &#60;relconst&#62; fum)</CODE> are true.
<CODE>:foo true</CODE> states that <CODE>(foo &#60;relconst&#62;)</CODE> is true, <CODE>:foo false</CODE> states that
<CODE>(not (foo &#60;relconst&#62;))</CODE> is true.
</P><P>

</DL>
</P><P>

<A NAME="IDX23"></A>
<DL>
<DT><U>Command:</U> <B>defrule</B> <I>(&#38;rest (args PARSE-TREE)) : PROPOSITION</I>
<DD>Define (or redefine) a named rule (<CODE>defrule</CODE> is an alias
for <CODE>defproposition</CODE> which see).
</DL>
</P><P>

<A NAME="IDX24"></A>
<DL>
<DT><U>Command:</U> <B>delete-rules</B> <I>((relation NAME)) :</I>
<DD>Delete the list of rules associated with <VAR>relation</VAR>.
This function is included mainly for debugging purposes, when
a user wants to verify the behavior of different sets of rules.
</DL>
</P><P>

<A NAME="IDX25"></A>
<DL>
<DT><U>Command:</U> <B>demo</B> <I>(&#38;rest (fileandpause OBJECT)) :</I>
<DD>Read logic commands from a file, echo them verbatimly to standard output,
and evaluate them just as if they had been typed in interactively.
When called with no arguments, present a menu of example demos, otherwise,
use the first argument as the name of the file to demo.
Pause for user confirmation after each expression has been read but
before it is evaluated.  Pausing can be turned off by suppling FALSE
as the optional second argument, or by typing <CODE>c</CODE> at the pause prompt.
Typing <CODE>?</CODE> at the pause prompt prints a list of available commands.
</DL>
</P><P>

<A NAME="IDX26"></A>
<DL>
<DT><U>Command:</U> <B>deny</B> <I>((proposition PARSE-TREE)) : OBJECT</I>
<DD>Assert the falsity of <VAR>proposition</VAR>.  Return the asserted proposition
object.  KIF example:  "(deny (happy Fred))" asserts that Fred is not happy,
which could have been done equivalently by "(assert (not (happy Fred)))".
Note, that for this to succeed, the relation <CODE>happy</CODE> must already be defined
(see <CODE>assert</CODE>).
</DL>
</P><P>

<A NAME="IDX27"></A>
<DL>
<DT><U>Command:</U> <B>describe</B> <I>((name OBJECT) &#38;rest (mode OBJECT)) :</I>
<DD>Print a description of an object in :verbose, :terse,
or :source modes.
</DL>
</P><P>

<A NAME="IDX28"></A>
<DL>
<DT><U>Command:</U> <B>destroy</B> <I>((objectSpec PARSE-TREE)) : OBJECT</I>
<DD>Find an object or proposition as specified by <VAR>objectSpec</VAR>, and destroy all
propositions and indices that reference it.  <VAR>objectSpec</VAR> must be a name or
a parse tree that evaluates to a proposition.  Return the deleted object, or
NULL if no matching object was found.
</DL>
</P><P>

<A NAME="IDX29"></A>
<DL>
<DT><U>Command:</U> <B>get-rules</B> <I>((relation NAME)) : (CONS OF PROPOSITION)</I>
<DD>Return the list of rules associated with <VAR>relation</VAR>.
</DL>
</P><P>

<A NAME="IDX30"></A>
<DL>
<DT><U>Command:</U> <B>help</B> <I>(&#38;rest (commands SYMBOL)) :</I>
<DD>Describe specific commands, or print a list of available commands.
</DL>
</P><P>

<A NAME="IDX31"></A>
<DL>
<DT><U>Command:</U> <B>in-module</B> <I>((name NAME)) : MODULE</I>
<DD>Change the current module to the module named <VAR>name</VAR>.
</DL>
</P><P>

<A NAME="IDX32"></A>
<DL>
<DT><U>Command:</U> <B>load</B> <I>((file STRING)) :</I>
<DD>Read logic commands from <VAR>file</VAR> and evaluate them.
</DL>
</P><P>

<A NAME="IDX33"></A>
<DL>
<DT><U>Command:</U> <B>load-file</B> <I>((file STRING)) :</I>
<DD>Read STELLA commands from <VAR>file</VAR> and evaluate them.
The file should begin with an <CODE>in-module</CODE> declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
<CODE>evaluate</CODE> to each of them.
</DL>
</P><P>

<A NAME="IDX34"></A>
<DL>
<DT><U>Command:</U> <B>presume</B> <I>((proposition PARSE-TREE)) : OBJECT</I>
<DD>Presume the default truth of <VAR>proposition</VAR>.  Return the presumed
proposition object.  KIF example:  "(presume (happy Fred))" states that Fred
is most probably happy.  Note, that for this to succeed, the relation
<CODE>happy</CODE> must already be defined (see <CODE>assert</CODE>).
</DL>
</P><P>

<A NAME="IDX35"></A>
<DL>
<DT><U>Command:</U> <B>print-features</B> <I>() :</I>
<DD>Print the currently enabled and available PowerLoom environment features.
</DL>
</P><P>

<A NAME="IDX36"></A>
<DL>
<DT><U>Command:</U> <B>print-rules</B> <I>((relation OBJECT)) :</I>
<DD>Print the list of rules associated with <VAR>relation</VAR>.
</DL>
</P><P>

<A NAME="IDX37"></A>
<DL>
<DT><U>Command:</U> <B>process-definitions</B> <I>() :</I>
<DD>Finish processing all definitions and assertions that have
been evaluated/loaded since that last call to <CODE>process-definitions</CODE>.
PowerLoom defers complete processing of definitions to make it easier
to support cyclic definitions.  Following finalization of definitions,
this call performs semantic validation of any assertions evaluated since
the last call to <CODE>process-definitions</CODE>.  PowerLoom calls this function
internally before each query; the primary reason to call it explicitly
is to force the production of any diagnostic information that results from
the processing and validation.
</DL>
</P><P>

<A NAME="IDX38"></A>
<DL>
<DT><U>Command:</U> <B>propagate-constraints</B> <I>(&#38;rest (name NAME)) :</I>
<DD>Trigger constraint propagation over all propositions of module <VAR>name</VAR>.
If no <VAR>name</VAR> is supplied, the current module will be used.  This also
enables incremental constraint propagation for future monotonic updates to
the module.  Once a non-monotonic update is performed, i.e., a retraction
or clipping of a function value, all cached inferences will be discarded
and constraint propagation will be turned off until this function is
called again.
</DL>
</P><P>

<A NAME="IDX39"></A>
<DL>
<DT><U>Command:</U> <B>repropagate-constraints</B> <I>(&#38;rest (name NAME)) :</I>
<DD>Force non-incremental constraint propagation over all propositions of
module <VAR>name</VAR>.  If no <VAR>name</VAR> is supplied, the current module will be used.
This also enables incremental constraint propagation for future monotonic
updates to the module similar to <CODE>propagate-constraints</CODE>.
</DL>
</P><P>

<A NAME="IDX40"></A>
<DL>
<DT><U>Command:</U> <B>reset-features</B> <I>() : (LIST OF KEYWORD)</I>
<DD>Reset the PowerLoom environment features to their default settings.
</DL>
</P><P>

<A NAME="IDX41"></A>
<DL>
<DT><U>Command:</U> <B>retract</B> <I>((proposition PARSE-TREE)) : OBJECT</I>
<DD>Retract the truth of <VAR>proposition</VAR>.  Return the retracted proposition
object.  KIF example:  "(retract (happy Fred))" retracts that Fred is
happy.  Note that for this assertion to succeed, the relation <CODE>happy</CODE> must already
be defined.  If the constant <CODE>Fred</CODE> has not yet been created, it is
automatically created as a side-effect of calling <CODE>retract</CODE>.
</DL>
</P><P>

<A NAME="IDX42"></A>
<DL>
<DT><U>Command:</U> <B>retract-facts-of</B> <I>((instanceRef OBJECT)) :</I>
<DD>Retract all definite (TRUE or FALSE) propositions
that reference the instance <VAR>instanceRef</VAR>.
</DL>
</P><P>

<A NAME="IDX43"></A>
<DL>
<DT><U>Command:</U> <B>retract-from-query</B> <I>((query CONS) &#38;rest (options OBJECT)) : (CONS OF PROPOSITION)</I>
<DD>Evaluate <VAR>query</VAR> which has to be a strict or partial retrieval
command, instantiate the query proposition for each generated solution
and retract the resulting propositions.  See <CODE>assert-from-query</CODE> for
available command options.
</DL>
</P><P>

<A NAME="IDX44"></A>
<DL>
<DT><U>Command:</U> <B>retract-rule</B> <I>((ruleName NAME)) : PROPOSITION</I>
<DD>If it is currently TRUE, set the truth value 
of the rule named <VAR>ruleName</VAR> to UNKNOWN  This
command may be used alternately with <CODE>assert-rule</CODE> to
observe the effects of querying with or without a particular (named) rule
being asserted within the current context. The proposition having the name
<VAR>ruleName</VAR> may be any arbitrary proposition, although we expect that it is
probably a material implication.
</DL>
</P><P>

<A NAME="IDX45"></A>
<DL>
<DT><U>Command:</U> <B>retrieve</B> <I>(&#38;rest (query PARSE-TREE)) : QUERY-ITERATOR</I>
<DD>Retrieve elements of a relation (tuples) that satisfy a proposition.
The accepted syntax is:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  (retrieve [&#60;integer&#62; | all]
            [[{&#60;vardecl&#62; | (&#60;vardecl&#62;+)}]
            &#60;proposition&#62;])
</pre></td></tr></table></P><P>

The variables and proposition are similar to an <CODE>exists</CODE> sentence or
<CODE>kappa</CODE> term without the explicit quantifier.  If variables are declared,
they must match the free variables referenced by &#60;proposition&#62;.  Otherwise,
the free variables referenced in &#60;proposition&#62; will be used as the query
variables.  If &#60;proposition&#62; is omitted, the most recently asked query
will be continued.
</P><P>

A solution is a set of bindings for the listed variables for which
&#60;proposition&#62; is true.  The optional first argument controls how many
solutions should be generated before control is returned.  The keyword
<CODE>all</CODE> indicates that all solutions should be generated.  By default,
<CODE>retrieve</CODE> returns after it has found one new solution or if it cannot
find any more solutions.
</P><P>

<CODE>retrieve</CODE> returns an iterator which saves all the necessary state of
a query and stores all generated solutions.  When used interactively,
the returned iterator will print out with the set of solutions collected
so far.  Calling <CODE>retrieve</CODE> without any arguments (or only with the first
argument) will generate one (or more) solutions to the most recently
asked query.
</P><P>

KIF examples:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  (retrieve (happy ?x))
</pre></td></tr></table></P><P>

will try to find one happy entity and store it in the returned 
query iterator.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  (retrieve 10 (happy ?x))
</pre></td></tr></table></P><P>

will try to find 10 happy entities.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  (retrieve 10)
</pre></td></tr></table></P><P>

will try to find the next 10 happy entities..
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  (retrieve all (happy ?x))
</pre></td></tr></table></P><P>

will find all happy entities.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  (retrieve all (?x Person) (happy ?x))
</pre></td></tr></table></P><P>

will to find all happy people.  Here we used the optional retrieve variable
syntax to restrict the acceptable solutions.  The above is equivalent to
the following query:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  (retrieve all (and (Person ?x) (happy ?x)))
</pre></td></tr></table></P><P>

Similarly,
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  (retrieve all (?x Person))
  (retrieve all (Person ?x))
  (retrieve all ?x (Person ?x))
</pre></td></tr></table></P><P>

will find all people.  Note that in the first case we only specify a query
variable and its type but omit the logic sentence which defaults to TRUE.  This
somewhat impoverished looking query can be paraphrased as "retrieve all ?x of
type Person such that TRUE."
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  (retrieve ?x (or (happy ?x) (parent-of Fred ?x)))
</pre></td></tr></table></P><P>

will try to find a person that is happy or has Fred as a parent.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  (retrieve (?y ?x) (parent-of ?x ?y))
</pre></td></tr></table></P><P>

will try to find the one pair of parent/child and return it in the order
of child/parent.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  (retrieve all (?x Person)
            (exists (?y Person) (parent-of ?x ?y)))
</pre></td></tr></table></P><P>

will generate the set of all parents.  Note, that for these queries to run,
the class <CODE>Person</CODE>, the relations <CODE>happy</CODE> and <CODE>parent-of</CODE>, and the logic
constant <CODE>Fred</CODE> must already be defined (see <CODE>assert</CODE>).
</P><P>

Use <CODE>(set/unset-feature trace-subgoals)</CODE> to en/disable goal tracing of the
inference engine.
</DL>
</P><P>

<A NAME="IDX46"></A>
<DL>
<DT><U>Command:</U> <B>save-module</B> <I>((name NAME) (file STRING)) :</I>
<DD>Save all definitions and assertions of module <VAR>name</VAR> to <VAR>file</VAR>.
</DL>
</P><P>

<A NAME="IDX47"></A>
<DL>
<DT><U>Command:</U> <B>set-feature</B> <I>(&#38;rest (features NAME)) : (LIST OF KEYWORD)</I>
<DD>Enable the PowerLoom environment feature(s) named by <VAR>features</VAR>.
Return the list of enabled features.  Calling <CODE>set-feature</CODE> without any
arguments can be used to display the currently enabled features.
The following features are supported:
</P><P>

<CODE>just-in-time-inference</CODE>: Enables interleaving of forward chaining inference
within backward chaining queries.
</P><P>

<CODE>iterative-deepening</CODE>: Tells the query processor to use iterative deepening
instead of a depth-first search to find answers.  This is less efficient
but necessary for some kinds of highly recursive queries.
</P><P>

<CODE>trace-subgoals</CODE>: Enables the generation of subgoaling trace information during
backchaining inference.
</P><P>

<CODE>trace-solutions</CODE>: Prints newly found solutions during retrieval right when they
are generated as opposed to when the query terminates.
</P><P>

<CODE>trace-classifier</CODE>: Tells the classifier to describe the inferences it draws.
</P><P>

<CODE>justifications</CODE>: Enables the generation of justifications during inference,
which is a prerequiste for the generation of explanations with <CODE>(why)</CODE>.
</P><P>

<CODE>emit-thinking-dots</CODE>: Tells PowerLoom to annotate its inference progress by
outputting characters indicating the completion of individual reasoning steps.
</P><P>

By default, the features <CODE>emit-thinking-dots</CODE> and <CODE>just-in-time-inference</CODE>
are enabled, and the others are disabled.
</P><P>

</DL>
</P><P>

<A NAME="IDX48"></A>
<DL>
<DT><U>Command:</U> <B>unset-feature</B> <I>(&#38;rest (features NAME)) : (LIST OF KEYWORD)</I>
<DD>Disable the PowerLoom environment feature(s) named by <VAR>features</VAR>.
Return the list of enabled features.  Calling <CODE>unset-feature</CODE> without any
arguments can be used to display the currently enabled features.
See <CODE>set-feature</CODE> for a description of supported features.
</DL>
</P><P>

<A NAME="IDX49"></A>
<DL>
<DT><U>Command:</U> <B>why</B> <I>(&#38;rest (args OBJECT)) :</I>
<DD>Print an explanation for the result of the most recent query.
Without any arguments, <CODE>why</CODE> prints an explanation of the top level
query proposition down to a maximum depth of 3.  <CODE>(why all)</CODE> prints
an explanation to unlimited depth.  Alternatively, a particular depth
can be specified, for example, <CODE>(why 5)</CODE> explains down to a depth of 5.
A proof step that was not explained explicitly (e.g., due to a depth
cutoff) can be explained by supplying the label of the step as the
first argument to <CODE>why</CODE>, for example, <CODE>(why 1.2.3 5)</CODE> prints an explanation
starting at 1.2.3 down to a depth of 5 (which is counted relative to the
depth of the starting point).  The keywords <CODE>brief</CODE> and <CODE>verbose</CODE> can be
used to select a particular explanation style.  In brief mode, explicitly
asserted propositions are not further explained and indicated with a
<CODE>!</CODE> assertion marker.  Additionally, relatively uninteresting proof steps
such as AND-introductions are skipped.  This explanation style option is
sticky and will affect future calls to <CODE>why</CODE> until it gets changed again.
The various options can be combined in any way, for example,
<CODE>(why 1.2.3 brief 3)</CODE> explains starting from step 1.2.3 down to a depth
of 3 in brief explanation mode.
</DL>
</P><P>

<A NAME="PowerLoom API"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC40"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_9.html#SEC44"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC76">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Hans Chalupsky</I> on <I>October, 29  2003</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
