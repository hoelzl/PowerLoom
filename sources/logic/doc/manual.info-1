This is manual.info, produced by makeinfo version 4.3 from manual.texi.

   This file documents the knowledge representation and reasoning
system.

Copyright (C) 2006 University of Southern California, Information
Sciences Institute, 4676 Admiralty Way, Marina Del Rey, CA 90292, USA

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   PowerLoom is a registered trademark of the University of Southern
California.



File: manual.info,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

PowerLoom Manual
****************

   This document describes the PowerLoom knowledge representation and
reasoning system.  PowerLoom is the successor to the Loom knowledge
representation system. It provides a language and environment for
constructing intelligent applications.

* Menu:

* Introduction::
* Conceptual Framework::
* Annotated Example::
* Communicating with PowerLoom::
* Commands::
* PowerLoom API::
* Built-In Relations::
* Installation::
* Miscellaneous::
* Glossary::
* PowerLoom Grammar::
* Function Index::
* Variable Index::
* Concept Index::


File: manual.info,  Node: Introduction,  Next: Conceptual Framework,  Prev: Top,  Up: Top

Introduction
************

   This document describes the PowerLoom knowledge representation and
reasoning system. PowerLoom is the successor to the Loom knowledge
representation system. It provides a language and environment for
constructing intelligent, knowledge-based applications. PowerLoom uses a
fully expressive, logic-based representation language (a variant of
KIF). It uses a natural deduction inference engine that combines forward
and backward chaining to derive what logically follows from the facts
and rules asserted in the knowledge base.  While PowerLoom is not a
description logic, it does have a description classifier which uses
technology derived from the Loom classifier to classify descriptions
expressed in full first order predicate calculus. PowerLoom uses modules
as a structuring device for knowledge bases, and ultra-lightweight
worlds to support hypothetical reasoning.

   To implement PowerLoom we developed a new programming language called
STELLA, which is a Strongly Typed, Lisp-like LAnguage that can be
translated into Lisp, Java, and C++. STELLA tries to preserve those
features of Lisp that facilitate symbolic programming and rapid
prototyping, while still allowing translation into readable as well as
efficient Java and C++ code. Because PowerLoom in written STELLA, we are
able to deliver it in all three languages.

* Menu:

* Powerloom Features::
* Powerloom History::
* Running PowerLoom::


File: manual.info,  Node: Powerloom Features,  Next: Powerloom History,  Prev: Introduction,  Up: Introduction

Powerloom Features
==================

   PowerLoom is a full-function, logic-based knowledge representation
and reasoning system, that supports all aspects of knowledge-based
applications.  It allows the representation of complex knowledge in a
declarative, logic-based language, supports a variety of reasoning
mechanisms to make implicit knowledge explicit, has a powerful query
engine to retrieve what has been asserted and logically follows from
the KB, provides file-based and RDBMS-based storage of knowledge bases,
has a context and module system to effectively partition and organize
large knowledge bases, and has an extensive API in multiple language to
allow easy and effective integration into knowledge-based applications.

   PowerLoom's focus is on expressivity of its representation language
while still providing good scalability to large ontologies and
knowledge bases.  In general, PowerLoom takes a _pragmatic stance_
where usability is more important than theoretical "neatness" and
expressivity is more important than inferential completeness.  From our
point of view, there is nothing magical about logic, it is just another
programming language (with difficult to understand semantics), so it
should help you to solve the task at hand as best as possible and not
hinder you by forcing you to work around restrictions of the logic.  Of
course, PowerLoom cannot completely escape the straight-jacket of
logic, but it tries to push the boundaries as much as possible.

   * *Representation language*: PowerLoom uses the language of
     predicate logic to represent knowledge.  The syntax is KIF (the
     Knowledge Interchange Format) which is one of the supported
     syntaxes of the upcoming Common Logic standard.  PowerLoom adds a
     variety of convenient definitional constructs as well as
     extensions beyond traditional first-order logic such as type-level
     predicates, relation variables in `holds' sentences, modal
     assertions (sentences about sentences), cross-context assertions
     via `ist' to represent lifting axioms, defaults (still
     experimental), and others.  The goal is to provide a highly
     expressive representation language, since KR failures or awkward
     models are often due to "we could not express X in language L".
     The theoretical undecidability and intractability of such an
     expressive language is counteracted by providing limited,
     "pragmatic" reasoning services that cover commonly encountered
     situations.  For example, reasoning with second-order sentences
     that quantify over relations is undecidable and leads to very
     unfocused search; however, such sentences are very useful to
     describe axiom schemata that can be cheaply run in forward
     direction to create regular first-order rules (in a process not
     unlike macro expansion).

   * *Reasoning*: The primary reasoning mechanism is logical deduction
     which infers statements that logically follow from the asserted
     statements and rules.  Such statements can be asked about using
     PowerLoom's query commands `ask' (for true/false questions) and
     `retrieve' (for Wh-questions).  PowerLoom uses a natural deduction
     system to answer queries but also has a large number of specialized
     reasoning procedures to efficiently handle concept and relation
     hierarchies, sets, frame predicates, search control, etc.  The
     specialist architecture is extensible to allow users to plug-in
     their own reasoners or computed predicates.  PowerLoom also
     supports hypothetical reasoning, equality reasoning, arithmetic
     and reasoning with inequalities.  While *PowerLoom is not a
     description logic*, it does have a classifier that can classify
     concept and relation hierarchies and instances defined using the
     full expressive power of first-order logic.  The classifier does
     not provide any additional inferences, but allows PowerLoom to
     eagerly pre-compute and cache subsumption relationships which can
     then be utilized over and over without having to re-derive them.
     PowerLoom also provides some experimental abductive and
     partial-match reasoning to handle incomplete knowledge bases.

   * *Meta-representation and reasoning*: Concepts, relations,
     contexts, rules, queries, etc. are all first-class citizens in the
     domain of discourse.  Therefore, they can have assertions made
     about them as well as reasoned about.  This mechanism is commonly
     used by the system itself, e.g., to assert that a relation is
     single valued or transitive, that a concept is closed, etc.

   * *Explanation*: PowerLoom can explain its reasoning by recording
     inference trees and then rendering those into human-understandable
     explanations.  PowerLoom also has an experimental "WhyNot"
     facility to explain inference failures where no successful proof
     tree was found.

   * *Contexts and modules*: Contexts and modules provide separate name
     and assertion spaces with inheritance which implement a powerful
     structuring mechanism for KBs.  Contexts allow encapsulation and
     organization of knowledge, efficient inference (by separating
     irrelevant knowledge or by separating ontologies and assertion
     spaces from volatile inference worlds), truth maintenance (via
     inference cache contexts), scenarios and hypothetical reasoning,
     non-monotonic overrides in sub-contexts, etc.  PowerLoom's context
     mechanism is built-in at a very low level using a very efficient
     and light-weight implementation for maximum performance.

   * *Open and closed-world*: By default, PowerLoom makes an open-world
     assumption and returns `unknown' if it cannot prove or disprove a
     question.  However, concepts and relations can be selectively
     marked as closed to support selective closed-world reasoning.
     PowerLoom also has a `fail' predicate (in addition to true
     negation via `not') to implement closed-world negation-as-failure
     which can be useful in certain situations.

   * *Knowledge base management*: PowerLoom supports incremental
     monotonic and non-monotonic updates that extend or
     non-monotonically change the assertion base.  In PowerLoom one can
     effectively interleave definitions, re-definitions, assertions and
     retractions with retrieval and inference without having to reload
     large knowledge bases from scratch after every change.  Truth
     maintenance of cached inference results that might have been
     invalidated by updates is done via inference cache contexts.
     After a knowledge base has been loaded and changed by some
     updates, the changed state can be saved out to a file or an
     (experimental) persistent store built on top of a relational
     database.

   * *Scalability*: Despite its emphasis on expressive representation
     which usually has to be paid for with intractable and expensive
     reasoning procedures, PowerLoom is very scalable and comes with a
     variety of mechanisms to control search and handle large
     ontologies and knowledge bases.  For example, PowerLoom's
     reasoning specialists handle a wide variety of inferencing very
     effectively without having to go through any rule chaining.
     Search control annotations can be used to help the inference
     engine use rules more effectively.  For example, depending on
     fan-out, certain rules are run more effectively forwards than
     backwards (or vice versa), and a KB developer can tell the system
     when that's the case.  PowerLoom has resource-bounded depth-first
     or iterative deepening search which provides an any-time inference
     scheme for situations where resources are limited.  A
     "just-in-time" forward inference engine elaborates the assertion
     neighborhood of objects touched upon by inference.  This allows
     focused forward inference relevant to current inference goals,
     without having to run forward inference over a potentially very
     large KB to completion.  PowerLoom has a static and dynamic query
     optimizer, that, similar to optimizers used in database systems,
     orders conjunctive goals based on relation extension sizes and
     rule fan-out to minimize intermediate result sets and chaining.
     The dynamic optimizer does this for each conjunctive subgoal based
     on actual bindings.  Given this mechanism it is possible to run
     PowerLoom queries that return 100,000's of solutions.  PowerLoom
     also has a powerful relational database interface that allows it to
     utilize the power of databases for handling large assertion bases
     (soon to be released).  One application of this PowerLoom/RDBMS
     integration is used with ISI's Omega ontology.  It is also a
     crucial part of our KOJAK Link Discovery System.

   * *Tools and APIs*: PowerLoom has a host of associated tools and
     APIs (not all of which have been released yet).  It comes with an
     interactive command-line interface which is useful for developing
     ontologies and knowledge bases, an extensive programmatic interface
     called PLI with Lisp, C++ and Java bindings, and a Lisp-based Loom
     API to load legacy Loom KBs.  Ontosaurus is a Web-based KB browser
     that dynamically generates HTML pages viewable in a standard Web
     browser.  Ontosaurus has been released in an experimental
     pre-release.  A soon-to-be-released Prot&eacute;g&eacute; plug-in
     allows export of Prot&eacute;g&eacute; ontologies into PowerLoom
     format.  A not yet released Java-based GUI provides a
     browse/edit/query environment for developing KBs.  The GUI uses a
     client/server architecture and is deployable via Java WebStart in
     standard browser. OntoMorph is a translation system that supports
     writing of KB translators and importers, e.g., to import
     ontologies written in other languages (for example, Flogic).

   * *Initial Semantic Web support*: Given PowerLoom's emphasis on
     expressive representation, we have not yet focused much on
     Semantic Web languages such as OWL, which restricts expressivity
     to gain decidability.  OWL also has other limitations such as
     restriction to binary relations and lack of support for arithmetic
     and inequalities which limits its usefulness for practical
     applications.  Nevertheless, given that people are starting to use
     these languages more and more, we've developed some initial import
     translators for RDF/RDFS and OWL which once they mature we will
     release as part of PowerLoom.

   * *Portability and integration*: Since PowerLoom is implemented in
     STELLA, it is available in Lisp, C++ and Java implementations and
     highly portable.  PowerLoom can be run in each of these languages
     under Unix (such as Linux, SunOS or MacOS X) as well as Windows
     2000 and XP.  Due to the availability in three main-stream
     languages, it can easily be integrated programmatically with most
     application software without having to use some complex
     integration framework.  The C++ and Java libraries for PowerLoom
     are also quite small and light-weight, for example, the necessary
     STELLA and PowerLoom jar files of the Java implementation are less
     than 2.5 Meg in size.


File: manual.info,  Node: Powerloom History,  Next: Running PowerLoom,  Prev: Powerloom Features,  Up: Introduction

Powerloom History
=================

   <to be written>


File: manual.info,  Node: Running PowerLoom,  Prev: Powerloom History,  Up: Introduction

Running PowerLoom
=================

   The easiest way to run PowerLoom on a variety of platforms is to use
the `powerloom' or `powerloom.bat' scripts in the top-level PowerLoom
directory.  If you have Java installed on your system, these scripts
should run out of the box without any further installation
requirements.  If you want to use the Lisp version of PowerLoom, simply
load the file `load-powerloom.lisp' into your Common Lisp.  If you want
to use the C++ version, you have to compile it first.  See the
Installation section in this manual for more details on how to install
the Lisp, C++ or Java version of PowerLoom *Note Installation::.

   Under Unix or MacOS X, open a shell window somewhere to run
PowerLoom.  For example,

     % powerloom
     Running Java version of PowerLoom...
     Initializing STELLA...
     Initializing PowerLoom...
     
         Welcome to PowerLoom 3.2.0
     
     Copyright (C) USC Information Sciences Institute, 1997-2006.
     PowerLoom comes with ABSOLUTELY NO WARRANTY!
     Type `(copyright)' for detailed copyright information.
     Type `(help)' for a list of available commands.
     Type `(demo)' for a list of example applications.
     Type `bye', `exit', `halt', `quit', or `stop', to exit.
     
     PL-USER |=

   Under Windows, you can do something similar by running a Command
Prompt window and executing the `powerloom.bat' script.  You can also
simply double click on the script which will run PowerLoom and bring up
a Command Prompt window for you.

   Once the `|=' prompt has come up you can type in PowerLoom commands
and see their results.  The string preceding the prompt indicates the
"current module" relative to which commands are interpreted.  For
example, type the `demo' command to see a menu of available demos.
Step through one or more of them to get familiar with PowerLoom.

   PowerLoom is a reasoning engine that is intended to be integrated
into some host application software somewhat similar to a database
system.  This is the main reason why it currently only ships with a
command-line interface; however, we do have an experimental PowerLoom
GUI which might also be released at some point.

* Menu:

* Command-Line Options::


File: manual.info,  Node: Command-Line Options,  Prev: Running PowerLoom,  Up: Running PowerLoom

Command-Line Options
--------------------

   There are a few command-line options that can be supplied to the
`powerloom' script.

     powerloom [c++|java]
               [{-e|--eval} STELLA-EXPRESSION]
               [--batch]

   The first optional argument determines what version to run if both
C++ and Java versions are installed.  If no specific version is
specified, the C++ version will be run if it is installed, otherwise,
the Java version will be run.

`--eval STELLA-EXPRESSION'
`-e STELLA-EXPRESSION'
     Specifies a STELLA expression that should be run just before the
     PowerLoom command loop gets initialized.  This expression has to
     be a known command (such as the various PowerLoom commands), since
     the STELLA evaluator cannot (yet) evaluate arbitrary STELLA code.
     For example, `powerloom -e '(demo "equations" FALSE)'' will run a
     particular demo before anything else.  You will need to
     appropriately quote special characters interpreted by the shell or
     the Command Prompt window.

`--batch'
     Runs PowerLoom in batch mode without running an interactive command
     loop.  This can be useful in conjunction with the `--eval' option
     to execute a single command or load a PowerLoom script via the
     `load' command.


File: manual.info,  Node: Conceptual Framework,  Next: Annotated Example,  Prev: Introduction,  Up: Top

Conceptual Framework
********************

   This chapter presents the fundamental conceptual building blocks
that are used to construct PowerLoom knowledge bases. The PowerLoom
language is based on KIF, which provides a syntax and a declarative
semantics for first-order predicate calculus expressions. KIF is a
proposed ANSII standard language used by a variety of knowledge
representation systems. Practical knowledge representation systems
necessarily add a procedural semantics that defines the interpretation
of knowledge structures when definitions and facts are retracted or
modified.  This chapter assumes that the reader has some familiarity
with the semantics of the predicate calculus, and instead focuses on
aspects of the semantics that go beyond the traditional (KIF) semantics.

   A PowerLoom knowledge base is constructed by first defining the
terminology (concepts and relations) for a domain, and then asserting
additional rules and facts about that domain. Facts can be asserted and
later retracted, so the answers returned by queries may change over
time. The knowledge structures are organized into logical containers
called "modules". The division into modules means that in general,
facts are not asserted globally, but instead hold only within a specific
context. For example, a logical proposition may evaluate as true within
one module, and evaluate as false within a different one.

   The discussion below uses some examples of actual PowerLoom syntax
to illustrate certain points.  However, we gloss over the fine points
of syntax, and instead focus on semantic issues.  The next chapter
reverses that emphasis, and presents a series of examples that
illustrate the breadth of syntactic constructs implemented for the
PowerLoom language.

* Menu:

* Terms and Propositions::
* Relation Definitions::
* Truth Values::
* Modules::


File: manual.info,  Node: Terms and Propositions,  Next: Relation Definitions,  Prev: Conceptual Framework,  Up: Conceptual Framework

Terms and Propositions
======================

   A knowledge base attempts to capture in abstract (machine
interpretable) form a useful representation of a physical or virtual
world. The entities in that world are modeled in the knowledge base by
objects we call _ terms_. Examples of terms are "Georgia" (denoting the
U.S., state), "BenjaminFranklin" (denoting the historical person by
that name), the number three, the string "abc", and the concept
"Person". Unlike objects in an object-oriented programming language,
the terms in a PowerLoom knowledge base usually have distinct names
(unless there are sufficiently many that naming them all becomes
impractical).

   Terms are categorized or related to one another by objects called
_relations_.  Examples of relations are "has age", "greater than", "is
married to", "plus".  Concepts such as "Person", "State", "Company",
and "Number" are considered a subcategory of relations.

   A _proposition_ is a logical sentence that has an associated truth
value. Examples are "Ben Franklin is a person", "Bill is married to
Hillary", "Two plus three equals six" (which is false). PowerLoom
follows KIF in adopting a prefix notation for the predicate calculus to
represent propositions. Possible representations of the three
propositions just mentioned are `(person ben-franklin)', `(married-to
Bill Hillary)', and `(= (+ 2 3) 6)'. These three propositions make
reference to relations named `person', `married-to', ` plus', and `='.

   The predicate calculus constructs complex sentences out of simpler
ones using the logical connectives `and', `or', `not', `<=', `=>', and
`<=>', and the quantifiers `exists' and `forall'. Some examples are
`(not (crook richard))' "Richard is not a crook", and `(forall ?p (=>
(person ?p) (exists ?m (has-mother ?p ?m))))' "every person has a
mother".


File: manual.info,  Node: Relation Definitions,  Next: Truth Values,  Prev: Terms and Propositions,  Up: Conceptual Framework

Definitions
===========

   PowerLoom requires that relations are defined before they are used
within assertions and queries.  The commands `defconcept',
`defrelation', and `deffunction' are used to define concepts,
relations, and functions, respectively.  The definitions

     (defconcept person)
     (defrelation married-to ((?p1 person) (?p2 person))
     (deffunction + ((?n1 number) (?n2 number)) :-> (?sum number))

   declare that `person' is a concept, that `married-to' is a binary
relation that takes arguments of type `person', and that `+' is a
function that takes arguments of type `number'(1).  The requirement
that relations be defined before they are referenced can be
inconvenient at times.  For example, suppose we wish to define `parent'
as "a person who is the parent of another person" and we also wish to
state that the first argument to the `parent-of' relation has type
`parent':

     (defconcept parent (?p)
       :<=> (and (person ?p) (exists ?c (parent-of ?p ?c))))
     (defrelation parent-of ((?p parent) (?c person)))

   In this example, the first reference to `parent-of' occurs before it
is defined. PowerLoom permits circular references such as these as long
as they occur within definitions. It does so by deferring evaluation of
rules that occur within definitions. Here is a specification that is
logically equivalent, but is not legal because the `parent-of' relation
appears in an assertion before it is defined:

     (defconcept parent (?p))
     (assert (forall (?p) (<=> (parent ?p)
                               (and (person ?p) (exists ?c (parent-of ?p ?c))))))
     (defrelation parent-of ((?p parent) (?c person)))

   So when does the rule inside of the first `parent' definition get
defined?  All axioms (facts and rules) that appear within the boundaries
of a definition are evaluated just prior to the next occurrence of a
PowerLoom query.  Hence, in the example above where the rule occurred
_within_ the definition, there was no error because evaluation of that
rule occured sometime after the second definition (which defines the
otherwise problematic reference to `parent-of').

   One will sometimes see the command `(process-definitions)' appearing
at intervals within a file containing PowerLoom commands. Each such
appearance forces the definitions that preceed it to be fully-evaluated.
This is done so that the interval between a definition and its
evaluation not be too great; it can get confusing if PowerLoom reports
a semantic violation long after the origin of the conflict.

   PowerLoom definitions commands (those prefixed by "def") have one
other semantic property that distinguishes them from ordinary
assertions. Any axioms that appear within a definition are tied to that
definition.  If a definition is modified and then reevaluated, axioms
that don't survive the modification are retracted.  For example,
suppose we evaluate the following two commands.

     (defrelation parent-of ((?p1 person) (?p2 person))
       :=> (relative-of ?p1 ?p2))
     (defrelation parent-of ((?p1 person) (?p2 person)))

   The first definition defines `person' as a binary relation, and also
states a rule that "`parent-of' implies `relative-of'".  The second
definitions erases that rule, i.e., the cumulative effect is as if the
first definition did not appear.  In contrast, consider the following
commands:

     (defrelation parent-of ((?p1 person) (?p2 person)))
     (assert (=> (parent-of ?p1 ?p2) (relative-of ?p1 ?p2)))
     (defrelation parent-of ((?p1 person) (?p2 person)))

   The assertion in this latter sequence is logically equivalent to the
axiom introduced by the `:=>' keyword in the former sequence.  However,
at the end of this sequence, the "`parent-of' implies `relative-of'"
rule is still in effect, since it appeared on its own, outside of a
definition.

   ---------- Footnotes ----------

   (1) The function `+' and the concept `number' are predefined in
PowerLoom.


File: manual.info,  Node: Truth Values,  Next: Modules,  Prev: Relation Definitions,  Up: Conceptual Framework

Truth Values
============

   A PowerLoom proposition is tagged with a truth value that has one of
five different settings--`true', `false', `default-true',
`default-false', or `unknown'. The most common setting is `true'; when
we make an assertion as in `(assert (Person Bill))', the proposition
`(Person Bill)' is assigned the truth value `true'. To assign the value
`false' to a proposition, one asserts that it is not true, e.g.,
`(assert (not (crook Richard)))'. The command `presume' is used to
assign a proposition the value `default-true', as in `(presume
(weather-in Los-Angeles Sunny))'. Presuming a negated proposition
assigns it the value `default-false'.

   The assignment of a truth value to a proposition via `assert' or
`presume' can upgrade the "strength" of a proposition, but it cannot
downgrade it. Hence, if a proposition currently has the value
`unknown', then it may be assigned any of the other four values. If the
value is `default-true' or `default-false', an assertion that assigns
the value `true' or `false' will overwrite the existing value. However,
if the truth value of a proposition is either `true' or `false',
assigning it the value `default-true' or `default-false' will have no
effect.

   If a proposition is asserted to be `true' and subsequently is
asserted to be `false' (or vice-versa), a _clash_ (or contradiction)
results. When a clash is detected by PowerLoom, a `clash-exception' is
thrown. The system's default behavior is for the exception to be caught
and ignored, with the result that an assertion that would otherwise
cause a clash never takes effect. Applications that execute commands
slightly below the top-level (i.e., below the clash exception catcher)
can catch the exception themselves and perform a specialized response.
PowerLoom's proof-by-contradiction specialist catches clashes to
determine that a contradiction has occurred.

   If a user or application wants to assign a proposition a truth value
that isn't stronger than the current value, it must first `retract' the
current value.  The PowerLoom `retract' operator has the effect of
undoing a prior assertion.  For example, if we assert that Mary is a
parent of Fred, and then retract that assertion, the value of the
proposition `(parent-of Mary Fred)' becomes `unknown'.  The proposition
can then be assigned any other truth value.

   We should note that executing a retraction does not necessarily
cause a proposition to cease being true.  Consider the following
sequence:

     (defconcept Person)
     (defconcept Employee (?e)
       :=> (Person ?e))
     (assert (Person Mary))
     (assert (Employee Mary))
     (retract (Person Mary))

   If we now ask PowerLoom whether or not Mary is a person, the answer
will be yes (TRUE) because Mary is asserted to be an employee, and
membership in `employee' implies membership in `person'.  In other
words, although the direct assertion that Mary is a person is not
present in the knowledge base, a logical proof exists that the
proposition "Mary is a person" is true.


File: manual.info,  Node: Modules,  Prev: Truth Values,  Up: Conceptual Framework

Modules
=======

   The knowledge loaded into an executing PowerLoom system is divided
into logical partitions called "modules".  The modules are arranged
into a hierarchy; knowledge inherits down the hierarchy from parents to
children.  A convenient way to organize knowledge is to put
definitional knowledge higher up in the module hierarchy, and factual
knowledge lower down.  For example, suppose we want to build a
knowledge base that defines a business domain, and include a
substantial number of facts about individual companies. We might use
one or a few modules to define terminology that relates to the business
domain, and then places the set of facts about each company in its own
module.  If we were querying the knowledge base about one or a few
companies, it would not be necessary to load the modules for the
remaining companies into the system.

   Facts asserted within a module are not visible in sibling modules,
or in ancestor modules. Thus, if we enter into PowerLoom an assertion
that"Georgia is a state", we are not asserting that Georgia is a state
in all possible worlds, but that, from the vantage point of the current
module and those modules below, it is the case that Georgia is a state.
If we want the fact that Georgia is a state to be recognized as true in
many or most other modules, then we should make our assertion in a
module that is relatively high up in the hierarchy, so that is visible
to (inherited by) the other modules.

   The inheritance of facts is _not monotonic_--a child module can
retract or override facts inherited from its ancestors. For example,
suppose we have two modules, called `above' and `below' such that the
`below' module is below (inherits from) the `above' module. Next,
suppose we make an assertion within the `above' module that "Joel is a
duck", and then we shift to the `below' module and retract the
proposition that "Joel is a duck". From the vantage point of the
`below' module, if we now ask if Joel is a duck, we will get back the
value `unknown'.  However, if we switch to the `above' module and ask
the same question, we get back the answer `true' This occurs because
the effect of the retraction operation that was applied to the `below'
module is not "visible" to modules above it (or to any sibling
modules). Hence, when module hierarchies are involved, it is
oversimplifying to state that a retraction has the effect of erasing a
prior assertion.

   The PowerLoom execution process maintains a pointer to the current
module, and all asserions, queries, etc. are made relative to that
module.  Hence, when we talk about "switching" from one module to
another, we are speaking literally--a `change-module' command (or one
of its equivalents) is invoked to switch from one module to another.
(1)

   PowerLoom comes with some modules already built-in. The module named
`PL-KERNEL' contains a set of general-purpose concept and relation
definitions that collectively form the foundation for constructing
application-specific knowledge bases. PowerLoom attaches specialized
reasoners to many of the relations in `PL-KERNEL'. The command
interpreter starts up in a module named `PL-USER'. That module is
initially empty, and is intended as a convenient place to experiment
with PowerLoom.

   ---------- Footnotes ----------

   (1) Many of the Powerloom API procedures take a module argument that
causes a temporary switch to a different module within the scope of
that procedure.


File: manual.info,  Node: Annotated Example,  Next: Communicating with PowerLoom,  Prev: Conceptual Framework,  Up: Top

Annotated Example
*****************

   The section presents a small example of a PowerLoom knowledge base.
It introduces the fundamental PowerLoom modelling concepts and
illustrates the syntax of basic PowerLoom declarations, assertions, and
commands.  This section can be read stand-alone, but readers who intend
to use PowerLoom to create their own models are encouraged to load the
demo file *???*, and run the examples "live".

   The conceptual terms introduced in this section include modules,
concepts, relations, functions, instances, propositions, assertions,
queries, retraction, positive and negative facts, clipping, rules, and
contexts.

* Menu:

* Using Modules::
* Concepts::
* Relations::
* Relation Hierarchies::
* Functions::
* Defined Concepts::
* Negation and Open and Closed World Semantics::
* Retraction::
* Clipping of Values::
* Rule-based Inference::
* Explanation::
* Contexts and Modules::
* Equality Reasoning::
* Classification::
* Truth Maintenance::
* Inference Control::
* Keyword Axioms::
* Cardinality/Type Reasoning with Frame Predicates::
* Loom-to-PowerLoom::
* Deviations from KIF::
* Differences from Loom::
* Defaults::
* Sets::


File: manual.info,  Node: Using Modules,  Next: Concepts,  Prev: Annotated Example,  Up: Annotated Example

Using Modules
=============

   We begin by creating a PowerLoom "module", which is a logical
container that holds the term definitions, rules, facts, etc.  that
make up all or a portion of a domain model.  We will call our module
`business'.  The `defmodule' command defines a new module.  The
`:includes' option within the `defmodule' tells PowerLoom that the
`business' module inherits all definitions and assertions present in
the `PL-USER' module, or in ancestor modules inherited by the `PL-USER'
module.  In particular, by inheriting `PL-USER', we indirectly inherit
the `PL-KERNEL' module that contains all of the built-in concepts and
relations.  The `in-module' command tells the PowerLoom system to make
`BUSINESS' the current module.  Until the current module is changed
again, all new introductions of terms and facts will be placed in the
`business' module.

     (defmodule "BUSINESS"
       :includes ("PL-USER"))
     (in-module "BUSINESS")

   The basic building blocks of a model are its concepts, relations, and
instances.(1)  A concept defines classes/categories of entities that
populate the domain model. A relation defines attributes and
relationships that allow the declaration of facts about an entity.
Instances are members of concepts. They appear as arguments to
propositional assertions.

   ---------- Footnotes ----------

   (1)  PowerLoom modules are case-insensitive by default.  This means,
for example, that a logical constant named "Foo" may be referenced by
any of the symbols 'FOO', 'foo', 'foO' etc.  You may create
case-sensitive modules, but if you do so, when inside that module all
PowerLoom commands and other symbols such as AND, EXISTS, etc.  will
need to be referred to using uppercase names, since no automatic
case-conversion will take place.


File: manual.info,  Node: Concepts,  Next: Relations,  Prev: Using Modules,  Up: Annotated Example

Concepts
========

   Concepts are defined using the `defconcept' command.  Here we define
the concepts `company' and `corporation':

     (defconcept company)
     (defconcept corporation (?c company))

   The first definition tells the system that `company' is a concept
(in the `business' module).  The second definition defines a concept
`corporation'.  The type declaration `(?c company)' indicates that
`corporation' is a subconcept of `company', i.e., all instances of
`corporation' are also instances of `company'.  Let us now create a
couple of companies:

     (assert (company ACME-cleaners))
     (assert (corporation megasoft))

   These two assertions create two new entities denoted by the terms
`ACME-cleaners' and `megasoft'.  Both of these entities are members of
the concept `company'.  `megasoft' is also a member of the concept
`corporation'.  We can test this by executing some PowerLoom queries:

     (retrieve all ?x (company ?x))
     =>
     There are 2 solutions:
       #1: ?X=ACME-CLEANERS
       #2: ?X=MEGASOFT
     
     (retrieve all ?x (corporation ?x))
     =>
     There is 1 solution:
       #1: ?X=MEGASOFT


File: manual.info,  Node: Relations,  Next: Relation Hierarchies,  Prev: Concepts,  Up: Annotated Example

Relations
=========

   So far, our two companies aren't very interesting. In order to say
more about them, we can define some relations and functions using the
declarations `defrelation' and `deffunction':

     (defrelation company-name ((?c company) (?name STRING)))

   This declaration defines a binary relation `company-name'.  The
first value in a `company-name' tuple must be an instance of type
`company', while the second value must be a string.  We can now give
our companies names, using the command `assert':

     (assert (company-name ACME-cleaners "ACME Cleaners, LTD"))
     (assert (company-name megasoft "MegaSoft, Inc."))

   We can retrieve pairs of companies and their names with the following
query (note that we omitted the optional retrieval variables in which
case they are determined by collecting the free variables in the query
expression):

     (retrieve all (company-name ?x ?y))
     =>
     There are 2 solutions:
       #1: ?X=MEGASOFT, ?Y="MegaSoft, Inc."
       #2: ?X=ACME-CLEANERS, ?Y="ACME Cleaners, LTD"

   Using retrieval variables is useful if we want to order the result
columns in a certain way, for example:

     (retrieve all (?y ?x) (company-name ?x ?y))
     =>
     There are 2 solutions:
       #1: ?Y="MegaSoft, Inc.", ?X=MEGASOFT
       #2: ?Y="ACME Cleaners, LTD", ?X=ACME-CLEANERS


File: manual.info,  Node: Relation Hierarchies,  Next: Functions,  Prev: Relations,  Up: Annotated Example

Relation Hierarchies
====================

   PowerLoom permits the specification of hierarchies both for concepts
and relations.  Previously , we defined a small concept hierarchy with
`company' on top and `corporation' below it.  We now define a
subrelation of the relation `company-name' called
`fictitious-business-name':

     (defrelation fictitious-business-name ((?c company) (?name STRING))
       :=> (company-name ?c ?name))

   PowerLoom defines a subconcept/subrelation relationship between a
pair of concepts or a pair of relations by asserting an "implication"
relation between them.  The above implication expands into the assertion
"for all values of ?c and ?name, if the `fictitious-business-name'
relation holds for ?c and?name, then the `company-name' relation also
holds for ?c and ?name".  This is equivalent to the assertion

     (forall (?c ?name) (=> (fictitious-business-name ?c ?name)
                            (company-name ?c ?name)))

Since implication relationships occur very commonly, PowerLoom provides
several syntactic shortcuts for defining them.  We have seen one such
shortcut earlier; our definition of `corporation' included the clause
"`(c ?company)'", which specified that `corporation' is a subconcept of
`company'.  In our definition of `fictitious-business-name', the keyword
`:=>' introduces a similar shortcut, which tells us that
`fictitious-business-name' is a subrelation of `company-name'.  Let us
assert a fictious business name for MegaSoft:

     (assert (fictitious-business-name megasoft "MegaSoft"))

   If we query for the company names of MegaSoft, we get two names, one
of them asserted directly, and one of them infered by the subrelation
rule:

     (retrieve all (company-name megasoft ?x))
     =>
     There are 2 solutions:
       #1: ?X="MegaSoft, Inc."
       #2: ?X="MegaSoft"


File: manual.info,  Node: Functions,  Next: Defined Concepts,  Prev: Relation Hierarchies,  Up: Annotated Example

Functions
=========

   This illustrates another point: A PowerLoom relation is by default
"multi-valued", which in the case of a binary relation means that a
single first value can be mapped by the relation to more than one second
value. In the present case, our model permits a `company' entity to
have more than one `company-name'. If a (binary) relation always maps
its first argument to exactly one value (i.e., if it it "single-valued")
we can specify it as a `function' instead of a `relation'.  For
example, we can use a function to indicate the number of employees for a
company:

     (deffunction number-of-employees ((?c company)) :-> (?n INTEGER))

   When defining a function, all arguments but the last appear just as
they do for a relation. The last argument (and its type) appears by
itself following the keyword `:->'. Defining a single-valued relation
as a function allows us to refer to it using a functional syntax within
a logical sentence, as in the following:

     (assert (= (number-of-employees ACME-cleaners) 8))
     (assert (= (number-of-employees megasoft) 10000))

   The functional syntax often results in shorter expressions than
equivalents that use relational syntax.  For example to retrieve all
companies with fewer than 50 employees, we can simply write:

     (retrieve all (and (company ?x) (< (number-of-employees ?x) 50)))
     =>
     There is 1 solution:
       #1: ?X=ACME-CLEANERS

   Using the syntax for relations, the same query would require the
introduction of an existential quantifier, as in:

     (retrieve all (and (company ?x)
                        (exists ?n
                          (and (number-of-employees ?x ?n)
                               (< ?n 50)))))
     =>
     There is 1 solution:
       #1: ?X=ACME-CLEANERS

   To repeat ourselves slightly, Powerloom allows users the choice of
using either relational or functional syntax when using a function in
predicate position. For example, if `f' is a function, then the
expressions `(f ?x ?y)' and `(= (f ?x) ?y)'  are equivalent.


File: manual.info,  Node: Defined Concepts,  Next: Negation and Open and Closed World Semantics,  Prev: Functions,  Up: Annotated Example

Defined Concepts
================

   If we find ourselves writing the same query (or subexpression)
repeatedly, we may wish to define a name for the concept embodying that
expression.  For example, below we define the term `small-company' to
represent the class of all companies with fewer than 50 employees:

     (defconcept small-company ((?c company))
       :<=> (and (Company ?c)
                 (< (number-of-employees ?c) 50)))

   Notice that we have used a new keyword, `:<=>'. This keyword defines
a bidirectional implication called "if-and-only-if".  Formally it is
equivalent to the following pair of assertions:

     (assert (forall ?c (=> (and (Company ?c)
                                 (< (number-of-employees ?c) 50))
                            (small-company ?c))))
     (assert (forall ?c (=> (small-company ?c)
                            (and (Company ?c)
                                 (< (number-of-employees ?c) 50)))))

   In other words, the `:<=>' keyword is a shortcut for an assertion
that uses the `<=>' relation, which itself is a shortcut representing
the conjunction of two single arrow implications. For example, `(<=> P
Q)' is equivalent to `(and (<= P Q) (=> P Q))', where the `<=' relation
is defined to be the inverse of the relation `=>'.

   Its not necessary that we exactly specify the number of employees in
a company.  Below, all we know about ZZ Productions is that they have
fewer than 20 employees:

     (assert (and (company zz-productions)
                  (< (number-of-employees zz-productions) 20)))

These facts are sufficient to classify ZZ Productions as a small
business:

     (retrieve all (small-company ?x))
     =>
     There are 2 solutions:
       #1: ?X=ZZ-PRODUCTIONS
       #2: ?X=ACME-CLEANERS


File: manual.info,  Node: Negation and Open and Closed World Semantics,  Next: Retraction,  Prev: Defined Concepts,  Up: Annotated Example

Negation and Open and Closed World Semantics
============================================

   PowerLoom implements a three-valued logic--the truth value of each
proposition entered into a PowerLoom knowledge base is recorded as
being either true, false, or unknown.(1) Many other systems (e.g.,
relational DBMSs) implement a two-valued logic, wherein if a fact is
not asserted to be true, it is assumed to be false.  The PowerLoom
command `ask' returns one of three (five) values: `true' if it can
prove the truth of a proposition, `false' if it can _easily_ prove the
falsity of a proposition(2) and otherwise it returns `unknown'. (The
values `default-true' and `default-false' are also possible if defaults
are used).

   Below, PowerLoom knows nothing about a newly-introduced concept
`s-corporation', so `ask' returns `unknown' to both a positive query
and its negation:

     (defconcept s-corporation (?c corporation))
     (ask (s-corporation zz-productions))
     =>
     UNKNOWN
     (ask (not (s-corporation zz-productions)))
     =>
     UNKNOWN

   If we assert that ZZ Productions is not an S-corporation, then
PowerLoom knows that the proposition in question is false:

     (assert (not (s-corporation zz-productions)))
     (ask (s-corporation zz-productions))
     =>
     FALSE
     (ask (not (s-corporation zz-productions)))
     =>
     TRUE

After asserting that ZZ Productions is not an S-corporation, a repeat
of the query asking if it _is_ one will now return `false', because the
explicit assertion of the negation allows a quick disproof of the
positive query.

*Note*: PowerLoom uses all its effort to prove that the proposition in
question is true, and only uses some effort to prove that it is false.
Therefore, only falsities that are discovered "on the way" or with
shallow inference strategies will be found (which was the case above).
If you want to check whether a proposition is false with maximum
effort, simply ask the negated proposition by wrapping an explicit
`not' arount it.  The reason for this asymmetry is that checking for
truth and falsity really amounts to asking two separate and possibly
expensive queries, and the user or programmer should decide whether the
effort should be expended to ask both queries instead of just one.

   PowerLoom can sometimes infer a negative fact without the necessity
of a direct assertion.  For example:

     (ask (= (number-of-employees ACME-cleaners) 8))
     =>
     TRUE
     (ask (= (number-of-employees ACME-cleaners) 10))
     =>
     FALSE
     (ask (not (= (number-of-employees ACME-cleaners) 10)))
     =>
     TRUE

   PowerLoom can infer the second and third answers because it knows
that the function `number-of-employees' can return only one value, and
if that value is the number eight, it cannot also be something else (in
this case, ten).

   Many systems, in particular, database systems and Prolog, make the
assumptions that if a proposition cannot be proved true, then it must be
false. This is called the "closed world assumption". By default,
PowerLoom makes an open-world assumption, but for specific relations it
can be instructed to assume a closed world if a user wants closed world
semantics. For example, suppose we introduce a relation `works-for',
and we assume that all `works-for' facts have been entered in our
knowledge base:

     (defrelation works-for (?p (?c Company)))
     (assert (works-for shirly ACME-cleaners))
     (assert (works-for jerome zz-productions))

   If we ask PowerLoom whether Jerome does NOT work for MegaSoft, it
will return `unknown'.  But if we assert that the relation `works-for'
is `closed', then PowerLoom will assume that Jerome only works for ZZ
Productions:

     (ask (not (works-for jerome megasoft)))
     =>
     UNKNOWN
     
     (assert (closed works-for))
     (ask (not (works-for jerome megasoft)))
     =>
     TRUE

   The reasoning employed to achieve the above result (that Jerome does
not work for MegaSoft) is called "negation as failure", which means that
if a proof of a proposition fails, then one may assume that the
proposition is false. We can achieve a negation-as-failure result a
second way (i.e., other than by using a closed world assumption) by
employing the query operator `fail'.  Here we retract the closure
assumption for `works-for' and achieve the desired result using `fail':

     (retract (closed works-for))
     (ask (not (works-for jerome megasoft)))
     =>
     UNKNOWN
     
     (ask (fail (works-for jerome megasoft)))
     =>
     TRUE

   When you see the operator "not" in an SQL query or a Prolog program,
it really stands for "fail".

   ---------- Footnotes ----------

   (1) Actually, PowerLoom implements a _five-valued_ logic -- the
remaining two values are "default true" and "default false". However,
the present discussion defers the subject of default truth values.

   (2) Because proving negations can be very difficult, PowerLoom will
only conduct a very quick and shallow search for a disproof.  More
extensive reasoning is used if a negation is asked about explicitly,
thus PowerLoom may return `unknown' if asked about `P', but true if
asked about `(not P)'.

