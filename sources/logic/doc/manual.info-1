This is manual.info, produced by makeinfo version 4.2 from manual.texi.

   This file documents the knowledge representation and reasoning
system.

Copyright (C) 2003 University of Southern California, Information
Sciences Institute, 4676 Admiralty Way, Marina Del Rey, CA 90292, USA

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   PowerLoom is a trademark of the University of Southern California.



File: manual.info,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

PowerLoom Manual
****************

   This document describes the PowerLoom knowledge representation and
reasoning system.  PowerLoom is the successor to the Loom knowledge
representation system. It provides a language and environment for
constructing intelligent applications.

* Menu:

* Introduction::
* Powerloom History::
* Installation::
* Conceptual Framework::
* Annotated Example::
* Communicating with PowerLoom::
* Commands::
* PowerLoom API::
* Built-In Relations::
* Miscellaneous::
* Glossary::
* PowerLoom Grammar::
* Function Index::
* Variable Index::
* Concept Index::


File: manual.info,  Node: Introduction,  Next: Powerloom History,  Prev: Top,  Up: Top

Introduction
************

   This document describes the PowerLoom knowledge representation and
reasoning system. PowerLoom is the successor to the Loom knowledge
representation system. It provides a language and environment for
constructing intelligent applications. PowerLoom uses a fully
expressive, logic-based representation language (a variant of KIF). It
uses a Prolog-technology backward chainer as its deductive component.
The backward chainer is not (yet) a complete theorem prover, but it can
handle Horn rules, negation, and simple equality reasoning.  Contrary to
Prolog, it also handles recursive rules without the risk of infinite
recursion.  An alternative reasoner, PowerLoom's description classifier,
uses technology derived from the Loom classifier to classify
descriptions expressed in full first order predicate calculus. PowerLoom
uses modules as a structuring device for knowledge bases, and
ultra-lightweight worlds to support hypothetical reasoning.

   To implement PowerLoom we developed a new programming language called
STELLA, which is a Strongly Typed, Lisp-like LAnguage that can be
translated into Lisp, Java, and C++. STELLA tries to preserve those
features of Lisp that facilitate symbolic programming and rapid
prototyping, while still allowing translation into readable as well as
efficient Java and C++ code. Because PowerLoom in written STELLA, we
are able to deliver it in all three languages.


File: manual.info,  Node: Powerloom History,  Next: Installation,  Prev: Introduction,  Up: Top

Powerloom History
*****************

   <to be written>


File: manual.info,  Node: Installation,  Next: Conceptual Framework,  Prev: Powerloom History,  Up: Top

Installation
************

* Menu:

* System Requirements::
* Unpacking the Sources::
* Lisp Installation::
* C++ Installation::
* Java Installation::
* Removing Unneeded Files::


File: manual.info,  Node: System Requirements,  Next: Unpacking the Sources,  Prev: Installation,  Up: Installation

System Requirements
===================

   To install and use PowerLoom you'll approximately need the following
amounts of disk space:

   * 15 MB for the tar-red or zip-ped archive file

   * 60 MB for the untarred sources, tanslations, compiled Java files
     and documentation

   * 14 MB to compile a Lisp version

   * 15 MB to compile the C++ version (without -g)

   * 4 MB to compile the Java version (already included)


   This means that you will need approximately 90 MB to work with one
Lisp, one C++ and one Java version of PowerLoom in parallel.  If you
also want to experiment with the Lisp translation variant that uses
structures instead of CLOS instances to implement STELLA objects, then
you will need an extra 15 MB to compile that.

   The full PowerLoom development tree is quite large, since for every
STELLA source file there are three to four translated versions and as
many or more compiled versions thereof.  The actual PowerLoom libraries
that you have to ship with an application, however, are quite small.
For example, the Java jar file `powerloom.jar' is only 2.2 MB (4 MB
including Java sources).  The dynamic C++ libraries `libstella.so' and
`liblogic.so' compiled on a Linux platform are about 7 MB total.
Additionally, if you don't need all the different translations of
PowerLoom, you can delete some of the versions to keep your development
tree smaller *Note Removing Unneeded Files::.

   To run the Lisp version of PowerLoom you need an ANSI Common-Lisp
(or at least one that supports CLOS and logical pathnames).  We have
successfully tested PowerLoom with Allegro-CL 4.2, 4.3, 5.0, 6.0 and
6.1, Macintosh CL 3.0 and 4.0, Lucid CL 4.1 (plus the necessary ANSI
extensions and Mark Kantrowitz's logical pathnames implementation) and
the freely available CMUCL 18c.  Our main development platform is
Allegro CL running under Sun Solaris and Linux RedHat, so, the closer
your environment is to ours, the higher are the chances that everything
will work right out of the box.  Lisp development under Windows is also
not a problem.

   To run the C++ version of PowerLoom you need a C++ compiler such as
g++ that supports templates and exception handling.  We have
successfully compiled and run PowerLoom with g++ 3.2 under Linux Redhat
8.0, and with CygWin 5.0 under Windows 2000 (CygWin provides a very
Unix-like environment).  We have not yet tried to run the C++ version
fully natively under Windows.  The main portability issue is the garbage
collector.  It is supposed to be very portable and run natively on
Windows platforms, but we have never verified that.

   For the Java version you will need Java JDK 1.2 or later.  To get
reasonable performance, you should use JDK 1.3 or later.  We've run the
Java version of PowerLoom on a variety of platforms without any
problems.

   Any one of the Lisp, C++ or Java implementations of PowerLoom can be
used to develop your own PowerLoom-based applications.  Which one you
choose is primarily a matter of your application and programming
environment.  The Lisp and Java versions are comparable in speed, the
C++ version is usually a factor of 2-3 faster than Lisp or Java.


File: manual.info,  Node: Unpacking the Sources,  Next: Lisp Installation,  Prev: System Requirements,  Up: Installation

Unpacking the Sources
=====================

   Uncompress and untar the file `powerloom-X.Y.Z.tar.gz' (or unzip the
file `powerloom-X.Y.Z.zip') in the parent directory of where you want
to install PowerLoom (`X.Y.Z' are place holders for the actual version
numbers).  This will create the PowerLoom tree in the directory
`powerloom-X.Y.Z/' (we will use Unix syntax for pathnames).  All
pathnames mentioned below will be relative to that directory which we
will usually refer to as the "PowerLoom directory".


File: manual.info,  Node: Lisp Installation,  Next: C++ Installation,  Prev: Unpacking the Sources,  Up: Installation

Lisp Installation
=================

   To install the Lisp version of PowerLoom startup Lisp and load the
file `load-powerloom.lisp' with:

     (CL:load "load-powerloom.lisp")

   The first time around this will compile all Lisp-translated STELLA
files before they are loaded.  During subsequent sessions the compiled
files will be loaded right away.

   If you want to use the version that uses Lisp structs instead of CLOS
objects to implement STELLA objects do the following:

     (CL:setq cl-user::*load-cl-struct-stella?* CL:t)
     (CL:load "load-powerloom.lisp")

   Alternatively, you can edit the initial value of the variable
`*load-cl-struct-stella?*' in the file `load-stella.lisp'.  Using
structs instead of CLOS objects greatly improves slot access speed,
however, it may cause problems with incremental re-definition of STELLA
classes (this is only an issue if you are developing your application
code in the STELLA language.  In that case it is recommended to only
use the struct option for systems that are in or near the production
stage).

   Once all the files are loaded, you should see a message similar to
this:

     PowerLoom 3.0.0 loaded.
     Type `(powerloom)' to get started.
     Type `(in-package "STELLA")' to run PowerLoom commands directly
        from the Lisp top level.
     USER(2):

   To reduce startup time, you might want to create a Lisp image that
has all of PowerLoom preloaded.

   Now type
     (in-package "STELLA")

   to enter the `STELLA' Lisp package where all the PowerLoom code
resides.  Alternatively, you can type

     (powerloom)

   which will bring up a PowerLoom listener that will allow you to
execute PowerLoom commands.

   *IMPORTANT*: All unqualified Lisp symbols in this document are
assumed to be in the `STELLA' Lisp package.  Moreover, the `STELLA'
package does *NOT* inherit anything from the `COMMON-LISP' package (see
the file `sources/stella/cl-lib/cl-setup.lisp' for the few exceptions),
hence, you have to explicitly qualify every Lisp symbol you want to use
with `CL:'.  For example, to get the result of the previous evaluation
you have to type `CL:*' instead of `*'.


File: manual.info,  Node: C++ Installation,  Next: Java Installation,  Prev: Lisp Installation,  Up: Installation

C++ Installation
================

   To compile the C++ version of PowerLoom change to the native C++
directory and run `make':

     % cd native/cpp/logic
     % make

   This will compile all PowerLoom and STELLA files, the C++ garbage
collector and generate static or dynamic `libstella' and `liblogic'
library files in the directory `native/cpp/lib' which can later be
linked with your own C++-translated PowerLoom (or other) code.  To test
whether the compilation was successful you can run PowerLoom from the
top-level PowerLoom directory like this:

     % ./native/cpp/logic/logic
     Initializing STELLA...
     Initializing PowerLoom...
     
         Welcome to PowerLoom 3.0.0
     
     Copyright (C) USC Information Sciences Institute, 1997-2003.
     PowerLoom comes with ABSOLUTELY NO WARRANTY!
     Type `(copyright)' for detailed copyright information.
     Type `(help)' for a list of available commands.
     Type `(demo)' for a list of example applications.
     Type `bye', `exit', `halt', `quit', or `stop', to exit.
     
     
     |=

   This will run various PowerLoom startup code and then bring up a
PowerLoom command loop where you can execute commands.  Type

     (demo)

   to bring up a menu of available demos, type

     (run-powerloom-tests)

   to run the PowerLoom test suite, or type

     exit

   to exit PowerLoom.


File: manual.info,  Node: Java Installation,  Next: Removing Unneeded Files,  Prev: C++ Installation,  Up: Installation

Java Installation
=================

   Nothing needs to be done to install the Java version.  Since Java
class files are platform independent, they are already shipped with the
PowerLoom distribution and can be found in the directory `native/java'
and its subdirectories.  Additionally, they have been collected into the
file `powerloom.jar' in the PowerLoom directory.  To try out the Java
version of PowerLoom run the following in the PowerLoom directory:

     % java -jar powerloom.jar
     Initializing STELLA...
     Initializing PowerLoom...
     
         Welcome to PowerLoom 3.0.0
     
     Copyright (C) USC Information Sciences Institute, 1997-2003.
     PowerLoom comes with ABSOLUTELY NO WARRANTY!
     Type `(copyright)' for detailed copyright information.
     Type `(help)' for a list of available commands.
     Type `(demo)' for a list of example applications.
     Type `bye', `exit', `halt', `quit', or `stop', to exit.
     
     
     |=

   Similar to the C++ executable, this will run various PowerLoom
startup code and then bring up a PowerLoom command loop where you can
execute commands.  Type

     (demo)

   to bring up a menu of available demos, type

     (run-powerloom-tests)

   to run the PowerLoom test suite, or type

     exit

   to exit PowerLoom.


File: manual.info,  Node: Removing Unneeded Files,  Prev: Java Installation,  Up: Installation

Removing Unneeded Files
=======================

   To save disk space you can remove files that you don't need.  For
example, if you are not interested in the C++ version of PowerLoom, you
can delete the directory `native/cpp'.  Similarly, you can remove
`native/java' to eliminate all Java-related files.  You could do the
same thing for the Lisp directory `native/lisp', but (in our opinion)
that would make it less convenient for you to develop new PowerLoom
code that is written in STELLA.  Finally, if you don't need any of the
STELLA sources, you can delete the directory `sources/stella'.  If you
don't need local copies of the STELLA and PowerLoom documentation, you
can delete parts or all of the directories `sources/stella/doc' and
`sources/logic/doc'.


File: manual.info,  Node: Conceptual Framework,  Next: Annotated Example,  Prev: Installation,  Up: Top

Conceptual Framework
********************

   This chapter presents the fundamental conceptual building blocks
that are used to construct PowerLoom knowledge bases. The PowerLoom
language is based on KIF, which provides a syntax and a declarative
semantics for first-order predicate calculus expressions. KIF is a
proposed ANSII standard language used by a variety of knowledge
representation systems. Practical knowledge representation systems
necessarily add a procedural semantics that defines the interpretation
of knowledge structures when definitions and facts are retracted or
modified.  This chapter assumes that the reader has some familiarity
with the semantics of the predicate calculus, and instead focuses on
aspects of the semantics that go beyond the traditional (KIF) semantics.

   A PowerLoom knowledge base is constructed by first defining the
terminology (concepts and relations) for a domain, and then asserting
additional rules and facts about that domain. Facts can be asserted and
later retracted, so the answers returned by queries may change over
time. The knowledge structures are organized into logical containers
called "modules". The division into modules means that in general,
facts are not asserted globally, but instead hold only within a specific
context. For example, a logical proposition may evaluate as true within
one module, and evaluate as false within a different one.

   The discussion below uses some examples of actual PowerLoom syntax
to illustrate certain points.  However, we gloss over the fine points
of syntax, and instead focus on semantic issues.  The next chapter
reverses that emphasis, and presents a series of examples that
illustrate the breadth of syntactic constructs implemented for the
PowerLoom language.

* Menu:

* Terms and Propositions::
* Relation Definitions::
* Truth Values::
* Modules::


File: manual.info,  Node: Terms and Propositions,  Next: Relation Definitions,  Prev: Conceptual Framework,  Up: Conceptual Framework

Terms and Propositions
======================

   A knowledge base attempts to capture in abstract (machine
interpretable) form a useful representation of a physical or virtual
world. The entities in that world are modeled in the knowledge base by
objects we call _ terms_. Examples of terms are "Georgia" (denoting the
U.S., state), "BenjaminFranklin" (denoting the historical person by
that name), the number three, the string "abc", and the concept
"Person". Unlike objects in an object-oriented programming language,
the terms in a PowerLoom knowledge base usually have distinct names
(unless there are sufficiently many that naming them all becomes
impractical).

   Terms are categorized or related to one another by objects called
_relations_.  Examples of relations are "has age", "greater than", "is
married to", "plus".  Concepts such as "Person", "State", "Company",
and "Number" are considered a subcategory of relations.

   A _proposition_ is a logical sentence that has an associated truth
value. Examples are "Ben Franklin is a person", "Bill is married to
Hillary", "Two plus three equals six". PowerLoom follows KIF in
adopting a prefix notation for the predicate calculus to represent
propositions. Possible representations of the three propositions just
mentioned are `(person ben-franklin)', `(married-to Bill Hillary)', and
`(= (+ 2 3) 6)'. These three propositions make reference to relations
named `person', `married-to', ` plus', and `='.

   The predicate calculus constructs complex sentences out of simpler
ones using the logical connectives `and', `or', `not', `<=', `=>', and
`<=>', and the quantifiers `exists' and `forall'. Some examples are
`(not (crook richard))' "Richard is not a crook", and `(forall ?p
(person ?p) (exists ?m (has-mother ?p ?m)))' "every person has a
mother".


File: manual.info,  Node: Relation Definitions,  Next: Truth Values,  Prev: Terms and Propositions,  Up: Conceptual Framework

Definitions
===========

   PowerLoom requires that relations are defined before they are used
within assertions and queries.  The commands `defconcept',
`defrelation', and `deffunction' are used to define concepts,
relations, and functions, respectively.  The definitions

     (defconcept person)
     (defrelation married-to ((?p1 person) (?p2 person))
     (deffunction + ((?n1 number) (?n2 number)) :-> (?sum number))

   declare that `person' is a concept, that `married-to' is a binary
relation that takes arguments of type `person', and that `+' is a
function that takes arguments of type `number'(1).  The requirement
that relations be defined before they are referenced can be
inconvenient at times.  For example, suppose we wish to define `parent'
as "a person who is the parent of another person" and we also wish to
state that the first argument to the `parent-of' relation has type
`parent':

     (defconcept parent (?p)
       :<=> (and (person ?p) (exists ?c (parent-of ?p ?c))))
     (defrelation parent-of ((?p parent) (?c person)))

   In this example, the first reference to `parent-of' occurs before it
is defined. PowerLoom permits circular references such as these as long
as they occur within definitions. It does so by deferring evaluation of
rules that occur within definitions. Here is a specification that is
logically equivalent, but is not legal because the `parent-of' relation
appears in an assertion before it is defined:

     (defconcept parent (?p))
     (assert (forall (?p) (<=> (parent ?p)
                               (and (person ?p) (exists ?c (parent-of ?p ?c))))))
     (defrelation parent-of ((?p parent) (?c person)))

   So when does the rule inside of the first `parent' definition get
defined?  All axioms (facts and rules) that appear within the boundaries
of a definition are evaluated just prior to the next occurrence of a
PowerLoom query.  Hence, in the example above where the rule occurred
_within_ the definition, there was no error because evaluation of that
rule occured sometime after the second definition (which defines the
otherwise problematic reference to `parent-of').

   One will sometimes see the command `(process-definitions)' appearing
at intervals within a file containing PowerLoom commands. Each such
appearance forces the definitions that preceed it to be fully-evaluated.
This is done so that the interval between a definition and its
evaluation not be too great; it can get confusing if PowerLoom reports
a semantic violation long after the origin of the conflict.

   PowerLoom definitions commands (those prefixed by "def") have one
other semantic property that distinguishes them from ordinary
assertions. Any axioms that appear within a definition are tied to that
definition.  If a definition is modified and then reevaluated, axioms
that don't survive the modification are retracted.  For example,
suppose we evaluate the following two commands.

     (defrelation parent-of ((?p1 person) (?p2 person))
       :=> (relative-of ?p1 ?p2))
     (defrelation parent-of ((?p1 person) (?p2 person)))

   The first definition defines `person' as a binary relation, and also
states a rule that "`parent-of' implies `relative-of'".  The second
definitions erases that rule, i.e., the cumulative effect is as if the
first definition did not appear.  In contrast, consider the following
commands:

     (defrelation parent-of ((?p1 person) (?p2 person)))
     (assert (=> (parent-of ?p1 ?p2) (relative-of ?p1 ?p2)))
     (defrelation parent-of ((?p1 person) (?p2 person)))

   The assertion in this latter sequence is logically equivalent to the
axiom introduced by the `:=>' keyword in the former sequence.  However,
at the end of this sequence, the "`parent-of' implies `relative-of'"
rule is still in effect, since it appeared on its own, outside of a
definition.

   ---------- Footnotes ----------

   (1) The function `+' and the concept `number' are predefined in
PowerLoom.


File: manual.info,  Node: Truth Values,  Next: Modules,  Prev: Relation Definitions,  Up: Conceptual Framework

Truth Values
============

   A PowerLoom proposition is tagged with a truth value that has one of
five different settings--`true', `false', `default-true',
`default-false', or `unknown'. The most common setting is `true'; when
we make an assertion as in `(assert (Person Bill))', the proposition
`(Person Bill)' is assigned the truth value `true'. To assign the value
`false' to a proposition, one asserts that it is not true, e.g.,
`(assert (not (crook Richard)))'. The command `presume' is used to
assign a proposition the value `default-true', as in `(presume
(weather-in Los-Angeles Sunny))'. Presuming a negated proposition
assigns it the value `default-false'.

   The assignment of a truth value to a proposition via `assert' or
`presume' can upgrade the "strength" of a proposition, but it cannot
downgrade it. Hence, if a proposition currently has the value
`unknown', then it may be assigned any of the other four values. If the
value is `default-true' or `default-false', an assertion that assigns
the value `true' or `false' will overwrite the existing value. However,
if the truth value of a proposition is either `true' or `false',
assigning it the value `default-true' or `default-false' will have no
effect.

   If a proposition is asserted to be `true' and subsequently is
asserted to be `false' (or vice-versa), a _clash_ (or contradiction)
results. When a clash is detected by PowerLoom, a `clash-exception' is
thrown. The system's default behavior is for the exception to be caught
and ignored, with the result that an assertion that would otherwise
cause a clash never takes effect. Applications that execute commands
slightly below the top-level (i.e., below the clash exception catcher)
can catch the exception themselves and perform a specialized response.
PowerLoom's proof-by-contradiction specialist catches clashes to
determine that a contradiction has occurred.

   If a user or application wants to assign a proposition a truth value
that isn't stronger than the current value, it must first `retract' the
current value.  The PowerLoom `retract' operator has the effect of
undoing a prior assertion.  For example, if we assert that Mary is a
parent of Fred, and then retract that assertion, the value of the
proposition `(parent-of Mary Fred)' becomes `unknown'.  The proposition
can then be assigned any other truth value.

   We should note that executing a retraction does not necessarily
cause a proposition to cease being true.  Consider the following
sequence:

     (defconcept Person)
     (defconcept Employee (?e)
       :=> (Person ?e))
     (assert (Person Mary))
     (assert (Employee Mary))
     (retract (Person Mary))

   If we now ask PowerLoom whether or not Mary is a person, the answer
will be yes (TRUE) because Mary is asserted to be an employee, and
membership in `employee' implies membership in `person'.  In other
words, although the direct assertion that Mary is a person is not
present in the knowledge base, a logical proof exists that the
proposition "Mary is a person" is true.


File: manual.info,  Node: Modules,  Prev: Truth Values,  Up: Conceptual Framework

Modules
=======

   The knowledge loaded into an executing PowerLoom system is divided
into logical partitions called "modules".  The modules are arranged
into a hierarchy; knowledge inherits down the hierarchy from parents to
children.  A convenient way to organize knowledge is to put
definitional knowledge higher up in the module hierarchy, and factual
knowledge lower down.  For example, suppose we want to build a
knowledge base that defines a business domain, and include a
substantial number of facts about individual companies. We might use
one or a few modules to define terminology that relates to the business
domain, and then places the set of facts about each company in its own
module.  If we were querying the knowledge base about one or a few
companies, it would not be necessary to load the modules for the
remaining companies into the system.

   Facts asserted within a module are not visible in sibling modules,
or in ancestor modules. Thus, if we enter into PowerLoom an assertion
that"Georgia is a state", we are not asserting that Georgia is a state
in all possible worlds, but that, from the vantage point of the current
module and those modules below, it is the case that Georgia is a state.
If we want the fact that Georgia is a state to be recognized as true in
many or most other modules, then we should make our assertion in a
module that is relatively high up in the hierarchy, so that is visible
to (inherited by) the other modules.

   The inheritance of facts is _not monotonic_--a child module can
retract or override facts inherited from its ancestors. For example,
suppose we have two modules, called `above' and `below' such that the
`below' module is below (inherits from) the `above' module. Next,
suppose we make an assertion within the `above' module that "Joel is a
duck", and then we shift to the `below' module and retract the
proposition that "Joel is a duck". From the vantage point of the
`below' module, if we now ask if Joel is a duck, we will get back the
value `unknown'.  However, if we switch to the `above' module and ask
the same question, we get back the answer `true' This occurs because
the effect of the retraction operation that was applied to the `below'
module is not "visible" to modules above it (or to any sibling
modules). Hence, when module hierarchies are involved, it is
oversimplifying to state that a retraction has the effect of erasing a
prior assertion.

   The PowerLoom execution process maintains a pointer to the current
module, and all asserions, queries, etc. are made relative to that
module.  Hence, when we talk about "switching" from one module to
another, we are speaking literally--a `change-module' command (or one
of its equivalents) is invoked to switch from one module to another.
(1)

   PowerLoom comes with some modules already built-in. The module named
`PL-KERNEL' contains a set of general-purpose concept and relation
definitions that collectively form the foundation for constructing
application-specific knowledge bases. PowerLoom attaches specialized
reasoners to many of the relations in `PL-KERNEL'. The command
interpreter starts up in a module named `PL-USER'. That module is
initially empty, and is intended as a convenient place to experiment
with PowerLoom.

   ---------- Footnotes ----------

   (1) Many of the Powerloom API procedures take a module argument that
causes a temporary switch to a different module within the scope of
that procedure.


File: manual.info,  Node: Annotated Example,  Next: Communicating with PowerLoom,  Prev: Conceptual Framework,  Up: Top

Annotated Example
*****************

   The section presents a small example of a PowerLoom knowledge base.
It introduces the fundamental PowerLoom modelling concepts and
illustrates the syntax of basic PowerLoom declarations, assertions, and
commands.  This section can be read stand-alone, but readers who intend
to use PowerLoom to create their own models are encouraged to load the
demo file *???*, and run the examples "live".

   The conceptual terms introduced in this section include modules,
concepts, relations, functions, instances, propositions, assertions,
queries, retraction, positive and negative facts, clipping, rules, and
contexts.

* Menu:

* Using Modules::
* Concepts::
* Relations::
* Relation Hierarchies::
* Functions::
* Defined Concepts::
* Negation and Open and Closed World Semantics::
* Retraction::
* Clipping of Values::
* Rule-based Inference::
* Explanation::
* Contexts and Modules::
* Classification::
* Truth Maintenance::
* Inference Control::
* Keyword Axioms::
* Cardinality/Type Reasoning with Frame Predicates::
* Loom-to-PowerLoom::
* Deviations from KIF::
* Differences from Loom::
* Defaults::
* Sets::


File: manual.info,  Node: Using Modules,  Next: Concepts,  Prev: Annotated Example,  Up: Annotated Example

Using Modules
=============

   We begin by creating a PowerLoom "module", which is a logical
container that holds the term definitions, rules, facts, etc.  that
make up all or a portion of a domain model.  We will call our module
`business'.  The `defmodule' command defines a new module.  The
`:includes' option within the `defmodule' tells PowerLoom that the
`business' module inherits all definitions and assertions present in
the `PL-USER' module, or in ancestor modules inherited by the `PL-USER'
module.  In particular, by inheriting `pl-user', we indirectly inherit
the `pl-kernel' module that contains all of the built-in concepts and
relations.  The `in-module' command tells the PowerLoom system to make
`business' the current module.  Until the current module is changed
again, all new introductions of terms and facts will be placed in the
`business' module.

     (defmodule "business"
       :includes ("PL-USER"))
     (in-module "business")

   The basic building blocks of a model are its concepts, relations, and
instances.(1) A concept defines classes/categories of entities that
populate the domain model. A relation defines attributes and
relationships that allow the declaration of facts about an entity.
Instances are members of concepts. They appear as arguments to
propositional assertions.

   ---------- Footnotes ----------

   (1)  PowerLoom modules are case-insensitive by default.  This means,
for example, that a logical constant named "Foo" may be referenced by
any of the symbols 'FOO', 'foo', 'foO' etc.


File: manual.info,  Node: Concepts,  Next: Relations,  Prev: Using Modules,  Up: Annotated Example

Concepts
========

   Concepts are defined using the `defconcept' command.  Here we define
the concepts `company' and `corporation':

     (defconcept company)
     (defconcept corporation (?c company))

   The first definition tells the system that `company' is a concept
(in the `business' module).  The second definition defines a concept
`corporation'.  The type declaration `(?c company)' indicates that
`corporation' is a subconcept of `company', i.e., all instances of
`corporation' are also instances of `company'.  Let us now create a
couple of companies:

     (assert (company ACME-cleaners))
     (assert (corporation megasoft))

   These two assertions create two new entities denoted by the terms
`ACME-cleaners' and `megasoft'.  Both of these entities are members of
the concept `company'.  `megasoft' is also a member of the concept
`corporation'.  We can test this by executing some PowerLoom queries:

     (retrieve all ?x (company ?x))
     =>
     There are 2 solutions:
       #1: ?X=ACME-CLEANERS
       #2: ?X=MEGASOFT
     
     (retrieve all ?x (corporation ?x))
     =>
     There is 1 solution:
       #1: ?X=MEGASOFT


File: manual.info,  Node: Relations,  Next: Relation Hierarchies,  Prev: Concepts,  Up: Annotated Example

Relations
=========

   So far, our two companies aren't very interesting. In order to say
more about them, we can define some relations and functions using the
declarations `defrelation' and `deffunction':

     (defrelation company-name ((?c company) (?name STRING)))

   This declaration defines a binary relation `company-name'.  The
first value in a `company-name' tuple must be an instance of type
`company', while the second value must be a string.  We can now give
our companies names, using the command `assert':

     (assert (company-name ACME-cleaners "ACME Cleaners, LTD"))
     (assert (company-name megasoft "MegaSoft, Inc."))

   We can retrieve pairs of companies and their names with the following
query:

     (retrieve all (?x ?y) (company-name ?x ?y))
     =>
     There are 2 solutions:
       #1: ?X=MEGASOFT, ?Y="MegaSoft, Inc."
       #2: ?X=ACME-CLEANERS, ?Y="ACME Cleaners, LTD"


File: manual.info,  Node: Relation Hierarchies,  Next: Functions,  Prev: Relations,  Up: Annotated Example

Relation Hierarchies
====================

   PowerLoom permits the specification of hierarchies both for concepts
and relations.  Previously , we defined a small concept hierarchy with
`company' on top and `corporation' below it.  We now define a
subrelation of the relation `company-name' called
`fictitious-business-name':

     (defrelation fictitious-business-name ((?c company) (?name STRING))
       :=> (company-name ?c ?name))

   PowerLoom defines a subconcept/subrelation relationship between a
pair of concepts or a pair of relations by asserting an "implication"
relation between them.  The above implication expands into the assertion
"for all values of ?c and ?name, if the `fictitious-business-name'
relation holds for ?c and?name, then the `company-name' relation also
holds for ?c and ?name".  This is equivalent to the assertion

     (forall (?c ?name) (=> (fictitious-business-name ?c ?name)
                            (company-name ?c ?name)))

Since implication relationships occur very commonly, PowerLoom provides
several syntactic shortcuts for defining them.  We have seen one such
shortcut earlier; our definition of `corporation' included the clause
"`(company ?c)'", which specified that `corporation' is a subconcept of
`company'.  In our definition of `fictitious-business-name', the keyword
`:=>' introduces a similar shortcut, which tells us that
`fictitious-business-name' is a subrelation of `company-name'.  Let us
assert a fictious business name for MegaSoft:

     (assert (fictitious-business-name megasoft "MegaSoft"))

   If we query for the company names of MegaSoft, we get two names, one
of them asserted directly, and one of them infered by the subrelation
rule:

     (retrieve all ?x (company-name megasoft ?x))
     =>
     There are 2 solutions:
       #1: ?X="MegaSoft"
       #2: ?X="MegaSoft, Inc."


File: manual.info,  Node: Functions,  Next: Defined Concepts,  Prev: Relation Hierarchies,  Up: Annotated Example

Functions
=========

   This illustrates another point: A PowerLoom relation is by default
"multi-valued", which in the case of a binary relation means that a
single first value can be mapped by the relation to more than one second
value. In the present case, our model permits a `company' entity to
have more than one `company-name'. If a (binary) relation always maps
its first argument to exactly one value (i.e., if it it "single-valued")
we can specify it as a `function' instead of a `relation'.  For
example, we can use a function to indicate the number of employees for a
company:

     (deffunction number-of-employees ((?c company)) :-> (?n INTEGER))

   When defining a function, all arguments but the last appear just as
they do for a relation. The last argument (and its type) appears by
itself following the keyword `:->'. Defining a single-valued relation
as a function allows us to refer to it using a functional syntax within
a logical sentence, as in the following:

     (assert (= (number-of-employees acme-cleaners) 8))
     (assert (= (number-of-employees megasoft) 10000))

   The functional syntax often results in shorter expressions than
equivalents that use relational syntax.  For example to retrieve all
companies with fewer than 50 employees, we can simply write:

     (retrieve all ?x (and (company ?x) (< (number-of-employees ?x) 50)))
     =>
     There is 1 solution:
       #1: ?X=ACME-CLEANERS

   Using the syntax for relations, the same query would require the
introduction of an existential quantifier, as in:

     (retrieve ?x (and (company ?x)
                       (exists ?n (and (number-of-employees ?x ?n)
                                       (< ?n 50)))))
     =>
     There is 1 solution so far:
       #1: ?X=ACME-CLEANERS

   To repeat ourselves slightly, Powerloom allows users the choice of
using either relational or functional syntax when using a function in
predicate position. For example, if `f' is a function, then the
expressions `(f ?x ?y)' and `(= (f ?x) ?y)'  are equivalent.


File: manual.info,  Node: Defined Concepts,  Next: Negation and Open and Closed World Semantics,  Prev: Functions,  Up: Annotated Example

Defined Concepts
================

   If we find ourselves writing the same query (or subexpression)
repeatedly, we may wish to define a name for the concept embodying that
expression.  For example, below we define the term `small-company' to
represent the class of all companies with fewer than 50 employees:

     (defconcept small-company ((?c company))
       :<=> (and (Company ?c)
                 (< (number-of-employees ?c) 50)))

   Notice that we have used a new keyword, `:<=>'. This keyword defines
a bidirectional implication called "if-and-only-if".  Formally it is
equivalent to the following pair of assertions:

     (assert (forall ?c (=> (and (Company ?c)
                                 (< (number-of-employees ?c) 50))
                            (small-company ?c))))
     (assert (forall ?c (=> (small-company ?c)
                            (and (Company ?c)
                                 (< (number-of-employees ?c) 50)))))

   In other words, the `:<=>' keyword is a shortcut for an assertion
that uses the `<=>' relation, which itself is a shortcut representing
the conjunction of two single arrow implications. For example, `(<=> P
Q)' is equivalent to `(and (<= P Q) (=> P Q))', where the `<=' relation
is defined to be the inverse of the relation `=>'.

   Its not necessary that we exactly specify the number of employees in
a company.  Below, all we know about ZZ Productions is that they have
fewer than 20 employees:

     (assert (and (company zz-productions)
                  (< (number-of-employees zz-productions) 20)))

These facts are sufficient to classify ZZ Productions as a small
business:

     (retrieve all ?x (small-company ?x))
     =>
     There are 2 solutions:
       #1: ?X=ZZ-PRODUCTIONS
       #2: ?X=ACME-CLEANERS


File: manual.info,  Node: Negation and Open and Closed World Semantics,  Next: Retraction,  Prev: Defined Concepts,  Up: Annotated Example

Negation and Open and Closed World Semantics
============================================

   PowerLoom implements a three-valued logic--the truth value of each
proposition entered into a PowerLoom knowledge base is recorded as being
either true, false, or unknown.(1) Many other systems (e.g., relational
DBMSs) implement a two-valued logic, wherein if a fact is not asserted
to be true, it is assumed to be false.  The PowerLoom command `ask'
returns one of three (five) values: `true' if it can prove the truth of
a proposition, `false' if it can _easily_ prove the falsity of a
proposition(2) and otherwise it returns `unknown'. (The values
`default-true' and `default-false' are also possible if defaults are
used).

   Below, PowerLoom knows nothing about a newly-introduced concept
`s-corporation', so `ask' returns `unknown' to both a positive query
and its negation:

     (defconcept s-corporation (?c corporation))
     (ask (s-corporation zz-productions))
     =>
     UNKNOWN
     (ask (not (s-corporation zz-productions)))
     =>
     UNKNOWN

   If we assert that ZZ Productions is not an S-corporation, then
PowerLoom knows that the proposition in question is false:

     (assert (not (s-corporation zz-productions)))
     (ask (s-corporation zz-productions))
     =>
     FALSE
     (ask (not (s-corporation zz-productions)))
     =>
     TRUE

After asserting that ZZ Productions is not an S-corporation, a repeat
of the query asking if it _is_ one will now return `false', because the
explicit assertion of the negation allows a quick disproof of the
positive query.

*Note*: PowerLoom uses all its effort to prove that the proposition in
question is true, and only uses some effort to prove that it is false.
Therefore, only falsities that are discovered "on the way" or with
shallow inference strategies will be found (which was the case above).
If you want to check whether a proposition is false with maximum
effort, simply ask the negated proposition by wrapping an explicit
`not' arount it.  The reason for this asymmetry is that checking for
truth and falsity really amounts to asking two separate and possibly
expensive queries, and the user or programmer should decide whether the
effort should be expended to ask both queries instead of just one.

   PowerLoom can sometimes infer a negative fact without the necessity
of a direct assertion.  For example:

     (ask (= (number-of-employees acme-cleaners) 8))
     =>
     TRUE
     (ask (= (number-of-employees acme-cleaners) 10))
     =>
     FALSE
     (ask (not (= (number-of-employees acme-cleaners) 10)))
     =>
     TRUE

   PowerLoom can infer the second and third answers because it knows
that the function `number-of-employees' can return only one value, and
if that value is the number eight, it cannot also be something else (in
this case, ten).

   Many systems, in particular, database systems and Prolog, make the
assumptions that if a proposition cannot be proved true, then it must be
false. This is called the "closed world assumption". By default,
PowerLoom makes an open-world assumption, but for specific relations it
can be instructed to assume a closed world if a user wants closed world
semantics. For example, suppose we introduce a relation `works-for',
and we assume that all `works-for' facts have been entered in our
knowledge base:

     (defrelation works-for (?p (?c Company)))
     (assert (works-for shirly ACME-cleaners))
     (assert (works-for jerome zz-productions))

   If we ask PowerLoom whether Jerome does NOT work for MegaSoft, it
will return `unknown'.  But if we assert that the relation `works-for'
is `closed', then PowerLoom will assume that Jerome only works for ZZ
Productions:

     (ask (not (works-for jerome megasoft)))
     =>
     UNKNOWN
     
     (assert (closed works-for))
     (ask (not (works-for jerome megasoft)))
     =>
     TRUE

   The reasoning employed to achieve the above result (that Jerome does
not work for MegaSoft) is called "negation as failure", which means that
if a proof of a proposition fails, then one may assume that the
proposition is false. We can achieve a negation-as-failure result a
second way (i.e., other than by using a closed world assumption) by
employing the query operator `fail'.  Here we retract the closure
assumption for `works-for' and achieve the desired result using `fail':

     (retract (closed works-for))
     (ask (not (works-for jerome megasoft)))
     =>
     UNKNOWN
     
     (ask (fail (works-for jerome megasoft)))
     =>
     TRUE

   When you see the operator "not" in an SQL query or a Prolog program,
it really stands for "fail".

   ---------- Footnotes ----------

   (1) Actually, PowerLoom implements a _five-valued_ logic -- the
remaining two values are "default true" and "default false". However,
the present discussion defers the subject of default truth values.

   (2) Because proving negations can be very difficult, PowerLoom will
only conduct a very quick and shallow search for a disproof.  More
extensive reasoning is used if a negation is asked about explicitly,
thus it may be the case that PowerLoom will return `unknown' if asked
about `P', but true if asked about `(not P)'.


File: manual.info,  Node: Retraction,  Next: Clipping of Values,  Prev: Negation and Open and Closed World Semantics,  Up: Annotated Example

Retraction
==========

   Below, we introduce a few new terms for defining geographic
information.  We define a relation called `contains' to assert that one
geographic location (the second argument to `contains') is located
within another:

     (defconcept geographic-location)
     (defconcept country (?l geographic-location))
     (defconcept state (?l geographic-location))
     (defconcept city (?l geographic-location))
     (defrelation contains ((?l1 geographic-location) (?l2 geographic-location)))

   Now, we can assert some facts about U.S. geography (including one
deliberate mistake):

     (assert (and
              (country united-states)
              (geographic-location eastern-us) (contains united-states eastern-us)
              (state georgia) (contains eastern-us georgia)
              (city atlanta) (contains georgia atlanta)
              (geographic-location southern-us) (contains united-states southern-us)
              (state texas) (contains eastern-us texas)
              (city dallas) (contains texas dallas)
              (city austin) (contains texas austin)
              ))

   We would like to repair the incorrect assertion `(contains
eastern-us texas)'.  The PowerLoom command `retract' allows us to erase
assertions that should not be true:

     (ask (contains eastern-us texas))
     =>
     TRUE
     
     (retract (contains eastern-us texas))
     (assert (contains southern-us texas))
     
     (ask (contains eastern-us texas))
     =>
     UNKNOWN

   Retraction should not be confused with assertion of negative
propositions.  For example, asserting that Texas is not a state would
not retract the assertion that it is (a state).  Instead, an evident
logical contradiction is detected as a "clash", and the clashing
proposition is disallowed:

     (assert (not (state texas)))
     =>
     Derived both TRUE and FALSE for the proposition `|P|(STATE TEXAS)'.
        Clash occurred in module ``|MDL|/PL-KERNEL-KB/business'.
     
     (ask (not (state texas)))
     =>
     FALSE


File: manual.info,  Node: Clipping of Values,  Next: Rule-based Inference,  Prev: Retraction,  Up: Annotated Example

Clipping of Values
==================

   Programmers are accustomed to changing the values of attributes for
program objects just by overwriting previous values.  PowerLoom
implements a similar semantics for the special case of functions and
single-valued relations.  When a second value is asserted for one of
these relations the previous value is automatically retracted.  We call
this _clipping_.

   To illustrate this behavior for both kinds of relations (a function
is considered a kind of relation), we will define a mapping from a
company to a city that contains its headquarters in two different ways:

     (deffunction headquarters ((?c company)) :-> (?city city))
     (defrelation headquartered-in ((?c company) (?city city))
       :axioms (single-valued headquartered-in))

   The clause "`:axioms (single-valued headquartered-in)'" tells
PowerLoom that the `headquartered-in' relation is single-valued, i.e.,
that it can map a company to at most one city.  This makes its behavior
similar to that of the function `headquarters'.  Here is an example of
clipping for the function `headquarters':

     (assert (= (headquarters zz-productions) atlanta))
     (retrieve all ?x (= ?x (headquarters zz-productions)))
     =>
     There is 1 solution:
       #1: ?X=ATLANTA
     
     (assert (= (headquarters zz-productions) dallas))
     (retrieve all ?x (= ?x (headquarters zz-productions)))
     =>
     There is 1 solution:
       #1: ?X=DALLAS

   Here is the same kind of clipping using a single-valued relation:

     (assert (headquartered-in megasoft atlanta))
     (retrieve all ?x (headquartered-in megasoft ?x))
     =>
     There is 1 solution:
       #1: ?X=ATLANTA
     
     (assert (headquartered-in megasoft dallas))
     (retrieve all ?x (headquartered-in megasoft ?x))
     =>
     There is 1 solution:
       #1: ?X=DALLAS

