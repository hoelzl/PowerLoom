;;; Version: test-suite.out,v 1.5 2006/05/10 22:43:29 hans Exp

;;; The more or less validated output of running `(run-powerloom-tests)'.
;;; Diff this against an actual run with a smart diff tool such as X/Emacs'
;;; `ediff-files' to see where there are deviations.  This also documents
;;; some known bugs and deficiencies that will hopefully be fixed some
;;; time down the road.

RUNNING POWERLOOM TEST SUITE
============================

STELLA version:    STELLA 3.3.2
PowerLoom version: PowerLoom 3.1.0.exp
Start time:        2006-MAY-08 16:20:02.000 -7.0


Now testing file `basics.plm':

|= (IN-PACKAGE "STELLA")


|= (DEFMODULE "/PL-KERNEL/PL-USER/BASICS")

/PL-KERNEL-KB/PL-USER/BASICS

|= (DEFMODULE "/PL-KERNEL/PL-USER/BASICS")

/PL-KERNEL-KB/PL-USER/BASICS

|= (DEFMODULE "BASICS" :INCLUDES ("PL-USER"))

/PL-KERNEL-KB/PL-USER/BASICS

|= (DEFMODULE "PL-USER/BASICS")

/PL-KERNEL-KB/PL-USER/BASICS

|= (IN-MODULE "BASICS")


|= (CLEAR-MODULE "BASICS")


|= (RESET-FEATURES)

|l|(:EMIT-THINKING-DOTS :JUST-IN-TIME-INFERENCE)

|= (IN-DIALECT KIF)

:KIF

|= (HELP ASSERT)

ASSERT ((proposition OBJECT)):
  Assert the truth of `proposition'.  Return the asserted proposition object.
  KIF example:  "(assert (happy Fred))" asserts that Fred is indeed happy.
  Note that for this assertion to succeed, the relation `happy' must already
  be defined.  If the constant `Fred' has not yet been created, it is
  automatically created as a side-effect of calling `assert'.

|= (HELP)

The following commands are available (type `(help <command>+)'
to get command-specific documentation):

ADD-LOAD-PATH:
  Append the directories listed in the |-separated
  `path' to the end of the PowerLoom load path.
ADD-TESTING-EXAMPLE:
  Add a query and score pair to the master list of 
ADD-TRAINING-EXAMPLE:
  Add a query and score pair to the master list of 
ALL-FACTS-OF:
  Return a cons list of all definite (TRUE or FALSE) propositions
  that reference the instance `instanceRef'.
ALL-FACTS-OF-N:
  This is a generalization of `all-facts-of' (which see).
ALL-SENTENCES-OF:
  Return a list of sentences describing facts about 'instanceRef'.
ASK:
  Perform inference to determine whether the proposition specified in
  `proposition&options' is true.
ASK-PARTIAL:
  Similar to `ask' (which see), but return the highest partial match score
  for the supplied proposition instead of a truth value.
ASSERT:
  Assert the truth of `proposition'.  Return the asserted proposition object.
ASSERT-FROM-QUERY:
  Evaluate `query', instantiate the query proposition for each generated
  solution and assert the resulting propositions.
ASSERT-RULE:
  Set the truth value of the rule named 'ruleName' to 
  TRUE.
CALL-ALL-FACTS-OF:
  Return a list of all definite (TRUE or FALSE) propositions
  that reference the instance `instanceRef'.
CC:
  Change the current context to the one named `name'.
CLASSIFY-INSTANCES:
  Classify instances visible in `module'.
CLASSIFY-RELATIONS:
  Classify named relations visible in `module'.
CLEAR-CACHES:
  Clear all query and memoization caches.
CLEAR-INSTANCES:
  Destroy all instances belonging to module `name' or any of its children.
CLEAR-MODULE:
  Destroy all objects belonging to module `name' or any of its children.
CONCEIVE:
  Guess whether 'formula' represents a term or a sentence/proposition.
CONCEIVE-TERM:
  `tree' is a term expression (a string or an s-expression),
  or is a class reference (a symbol or surrogate).
COPYRIGHT:
  Print detailed PowerLoom copyright information.
CREATE:
  Create a logic object with name 'name' and return it.
CURRENT-INFERENCE-LEVEL:
  Return the current inference level that is active in the
  current query, the current module, or, otherwise, globally.
DEFCONCEPT:
  Define (or redefine) a concept.
DEFFUNCTION:
  Define (or redefine) a logic function.
DEFINSTANCE:
  Define (or redefine) a logic instance (`definstance' is an alias
  for `defobject' which see).
DEFMODULE:
  Define (or redefine) a module named `name'.
DEFOBJECT:
  Define (or redefine) a logic instance.
DEFPROPOSITION:
  Define (or redefine) a named proposition.
DEFRELATION:
  Define (or redefine) a logic relation.
DEFRULE:
  Define (or redefine) a named rule (`defrule' is an alias
  for `defproposition' which see).
DELETE-RULES:
  Delete the list of rules associated with `relation'.
DEMO:
  Read logic commands from a file, echo them verbatimly to standard output,
  and evaluate them just as if they had been typed in interactively.
DENY:
  Assert the falsity of `proposition'.
DESTROY:
  Find an object or proposition as specified by `objectSpec', and destroy all
  propositions and indices that reference it.
DROP-LOAD-PATH:
  Remove the directories listed in the |-separated
  `path' from the PowerLoom load path.
FIND-INSTANCE:
  Return the nearest instance with name 'instanceRef'
  visible from the current module.
FIND-RULE:
  Search for a rule named 'ruleName'.
GET-LOAD-PATH:
  Return the current PowerLoom load path.
GET-RULES:
  Return the list of rules associated with `relation'.
HELP:
  Describe specific commands, or print a list of available commands.
IN-DIALECT:
  Change the current logic dialect to `dialect'.
IN-MODULE:
  Change the current module to the module named `name'.
LIST-FEATURES:
  Return a list containing two lists, a list of currently enabled PowerLoom
  features, and a list of all available PowerLoom features.
LIST-MODULES:
  Returns a cons of all modules defined in PowerLoom.
LIST-UNCLASSIFIED-INSTANCES:
  Collect all instances in `module' (or in any module if `module'
LIST-UNCLASSIFIED-RELATIONS:
  Collect all named description in `module' (or in any module if `module'
LIST-UNDEFINED-RELATIONS:
  Return a list of as yet undefined concepts and relations in `module'.
LOAD:
  Read logic commands from `file' and evaluate them.
POP-LOAD-PATH:
  Remove the first element from the PowerLoom load path
  and return the removed element.
POWERLOOM-INFORMATION:
  Returns information about the current PowerLoom implementation.
PRESUME:
  Presume the default truth of `proposition'.
PRINT-FEATURES:
  Print the currently enabled and available PowerLoom environment features.
PRINT-RULES:
  Print the list of true rules associated with `relation'.
PROCESS-DEFINITIONS:
  Finish processing all definitions and assertions that have
  been evaluated/loaded since that last call to 'process-definitions'.
PROPAGATE-CONSTRAINTS:
  Trigger constraint propagation over all propositions of module `name'.
PUSH-LOAD-PATH:
  Add the directories listed in the |-separated
  `path' to the front of the PowerLoom load path.
REGISTER-SPECIALIST-FUNCTION-NAME:
  registers a specialist function `stella-name' based on the `native-name'
  for the particular programming language in question.
REPROPAGATE-CONSTRAINTS:
  Force non-incremental constraint propagation over all propositions of
  module `name'.
RESET-FEATURES:
  Reset the PowerLoom environment features to their default settings.
RESET-POWERLOOM:
  Reset PowerLoom to its initial state.
RETRACT:
  Retract the truth of `proposition'.
RETRACT-FACTS-OF:
  Retract all definite (TRUE or FALSE) propositions
  that reference the instance `instanceRef'.
RETRACT-FROM-QUERY:
  Evaluate `query' which has to be a strict or partial retrieval
RETRACT-RULE:
  If it is currently true, set the truth value of the rule named
  'ruleName' to UNKNOWN.
RETRIEVE:
  Retrieve elements of a relation (tuples) that satisfy a proposition.
RETRIEVE-PARTIAL:
  Partial-match version of `retrieve' (which see) that generates scored
  partial solutions based on the current partial match strategy.
RUN-FORWARD-RULES:
  Run forward inference rules in module 'moduleRef'.
RUN-POWERLOOM-TESTS:
  Run the PowerLoom test suite.
SAVE-ALL-NEURAL-NETWORKS:
  Save all neural networks to `file' (if `file' is non-NULL).
SAVE-MODULE:
  Save all definitions and assertions of module `name' to `file'.
SET-ERROR-PRINT-CYCLE:
  Set number of cycles between which error rates are saved to
  the file established by the last call to `save-all-neural-networks' appended
  with extension `.
SET-FEATURE:
  Enable the PowerLoom environment feature(s) named by `features'.
SET-INFERENCE-LEVEL:
  Set the inference level of `module' to the level specified
  by 'levelKeyword'.
SET-LOAD-PATH:
  Set the PowerLoom load path to the |-separated
  directories listed in `path'.
SET-NUM-NEIGHBORS:
  Sets the number of nearest neighbors to predict from.
SET-NUM-TRAINING-PER-CASE:
  Sets the number of training examples for each case in the training set.
SET-SAVE-NETWORK-CYCLE:
  Set number of cycles between which networks are saved to the
  file established by the last call to `save-all-neural-networks'.
TIME-COMMAND:
  Execute `command', measure and report its CPU and elapsed time
  needed for its execution, and then return its result.
TRANSLATE-LOOM-FILE:
  Translate the Loom file `input' to PowerLoom and write the
  translation to the file `output'.
UNASSERT:
  Retract the truth, falsity or inconsistency of `proposition'.
UNSET-FEATURE:
  Disable the PowerLoom environment feature(s) named by `features'.
WHY:
  Print an explanation for the result of the most recent query.

Undocumented Commands:

ADD-CASE:
ADD-TABOO-OPERATORS:
ADD-TRAINING-EXAMPLE-IN-MODULE:
APPROXIMATE:
ASSERT-INDUCED-RULES:
BOTTOM-UP-RULE-INDUCTION:
CHECK-MASTER-NETWORK-LIST:
CLEAR-ALL-NEURAL-NETWORKS:
CLEAR-CASES:
CLEAR-SLOT-FROM-CLASS:
CLEAR-TRAINING-EXAMPLES:
DEFNETWORK:
DELETE-ALL-NEURAL-NETWORKS:
EVALUATE-RULE-INDUCTION:
FINALIZE-CASES:
GET-RULE:
GNP:
GUESS:
INDUCE-DECISION-RULES:
INDUCE-DECISION-TREE:
INDUCE-INFERENCE-RULES:
LOAD-NEURAL-NETWORK-FILE:
MULTIPLE-NETWORK-TRAINING-RUNS:
PRINT-FACTS:
SAVE-NEURAL-NETWORK:
SAVE-TRAINING-EXAMPLES:
SET-CASE-SOLUTION-COMBINATION:
SET-CLOSED-WORLD-TRAINING-EXAMPLES:
SET-ERROR-CUTOFF:
SET-GREEDY-NETWORK-PRUNING:
SET-LEARNING-RATE:
SET-MAXIMUM-SCORE-CUTOFF:
SET-MINIMUM-SCORE-CUTOFF:
SET-MOMENTUM-TERM:
SET-NEURAL-NETWORK-TRAINING-METHOD:
SET-PARTIAL-MATCH-MODE:
SET-PRINT-CASE-DISTANCES:
SET-RECURSIVE-DECISION-NODES:
SET-RULE-COMBINATION:
SET-RULE-INDUCTION-STRATEGY:
SET-SIGNATURE-RULES:
SET-SIGNATURE-STRATEGY:
SET-STRUCTURE-DEPTH:
SET-TRACE-NEURAL-NETWORK-TRAINING:
SET-TRAIN-CACHED-NEURAL-NETWORKS:
SET-WEIGHT-RANGE:
STRUCTURED-NEURAL-NETWORK-REGRESSION:
SWAP-IN-NETWORK-FILE:
SWAP-IN-NEW-NETWORKS:
TEST-CASE-BASED-REASONER:
TEST-CASE-MATCHER:
TEST-DOMAIN-THEORY:
TEST-NEURAL-NETWORK:
TEST-OVER-TRAINING-EXAMPLES:
THINGIFY-UNTYPED-INSTANCES:
TOP-DOWN-RULE-INDUCTION:
TRAIN-AND-TEST-CASE-MATCHER:
TRAIN-AND-TEST-NEURAL-NETWORK:
TRAIN-CASE-MATCHER:
TRAIN-NEURAL-NETWORK:
WHYNOT:

|= (DEFCONCEPT PERSON (?P) :DOCUMENTATION "The class of human beings.")

PERSON

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (PERSON JOE))

(PERSON JOE)

|= (DEFRELATION LIKES ((?P1 PERSON) (?P2 PERSON)) :DOCUMENTATION "True if ?p1 likes ?p2.")

LIKES

|= (DEFRELATION HAPPY ((?P PERSON)) :DOCUMENTATION "True if ?p is happy.")

HAPPY

|= (ASSERT (LIKES JOE FRED))

(LIKES JOE FRED)

|= (ASSERT (HAPPY FRED))

(HAPPY FRED)

|= (ASK (HAPPY FRED))

TRUE

|= (ASK (HAPPY JOE))

UNKNOWN

|= (ASSERT (NOT (HAPPY JOE)))

(not (HAPPY JOE))

|= (ASK (HAPPY JOE))

FALSE

|= (RETRIEVE ALL (PERSON ?X))

(JOE FRED)


|= (RETRIEVE ALL (LIKES JOE ?X))

(FRED)


|= (RETRIEVE ALL (?Y ?X) (LIKES ?X ?Y))

((FRED JOE))


|= (RETRIEVE ALL ((?Y PERSON) (?X PERSON)) (LIKES ?X ?Y))

((FRED JOE))


|= (RETRIEVE ALL (AND (PERSON ?Y) (PERSON ?X) (LIKES ?X ?Y)))

((FRED JOE))


|= (RETRIEVE (PERSON ?X))

(JOE)


|= (RETRIEVE 1 (PERSON ?X))

(JOE)


|= (RETRIEVE)

(JOE FRED)


|= (RETRIEVE 1)

(JOE FRED)


|= (DEFFUNCTION AGE ((?P PERSON)) :-> (?A INTEGER) :DOCUMENTATION "?a is ?p's age in years.")

AGE

|= (ASSERT (= (AGE FRED) 35))

(= (AGE FRED) 35)

|= (ASSERT (AGE FRED 35))

(= (AGE FRED) 35)

|= (ASK (= (AGE FRED) 35))

TRUE

|= (RETRIEVE (= (AGE FRED) ?X))

(35)


|= (RETRACT (= (AGE FRED) 35))

(= (AGE FRED) (AGE FRED))

|= (RETRIEVE (= (AGE FRED) ?X))

()


|= (ASSERT (= (AGE FRED) 36))

(= (AGE FRED) 36)

|= (RETRIEVE (= (AGE FRED) ?X))

(36)


|= (ASSERT (= (AGE FRED) 42))

(= (AGE FRED) 42)

|= (RETRIEVE (= (AGE FRED) ?X))

(42)


|= (ALL-FACTS-OF FRED)

((PERSON FRED) (LIKES JOE FRED) (HAPPY FRED) (= (AGE FRED) 42))

|= (RETRACT-FACTS-OF FRED)


|= (ALL-FACTS-OF FRED)

()

|= 

Finished testing file `basics.plm'.

Now testing file `classes.plm':

|= (IN-PACKAGE "STELLA")


|= (DEFMODULE "PL-USER/CONCEPTS")

/PL-KERNEL-KB/PL-USER/CONCEPTS

|= (IN-MODULE "CONCEPTS")


|= (CLEAR-MODULE "CONCEPTS")


|= (RESET-FEATURES)

|l|(:EMIT-THINKING-DOTS :JUST-IN-TIME-INFERENCE)

|= (IN-DIALECT KIF)

:KIF

|= (DEFCONCEPT PERSON :DOCUMENTATION "The class of human beings.")

PERSON

|= (DEFRELATION HAPPY ((?P PERSON)))

HAPPY

|= (DEFFUNCTION AGE ((?P PERSON)) :-> (?AGE INTEGER))

AGE

|= (DEFCONCEPT WARFIGHTER (PERSON) :DOCUMENTATION "People involved in military operations.")

WARFIGHTER

|= (DEFCONCEPT WARFIGHTER)

WARFIGHTER

|= (ASSERT (SUBSET-OF WARFIGHTER PERSON))

(forall (?x1)
   (<= (PERSON ?x1)
       (WARFIGHTER ?x1)))

|= (ASSERT (DOCUMENTATION WARFIGHTER "People involved in military operations."))

(DOCUMENTATION WARFIGHTER "People involved in military operations.")

|= (RETRIEVE (DOCUMENTATION WARFIGHTER ?DOC))

("People involved in military operations.")


|= (DEFCONCEPT ARMED-SERVICE :DOCUMENTATION "The class of armed services, for example, the US Navy.")

ARMED-SERVICE

|= (ASSERT (ARMED-SERVICE US-ARMY))

(ARMED-SERVICE US-ARMY)

|= (ASSERT (ARMED-SERVICE US-NAVY))

(ARMED-SERVICE US-NAVY)

|= (ASSERT (ARMED-SERVICE US-AIRFORCE))

(ARMED-SERVICE US-AIRFORCE)

|= (DEFFUNCTION SERVICE ((?P WARFIGHTER)) :-> (?S ARMED-SERVICE) :DOCUMENTATION "The armed service to which a warfighter belongs.")

SERVICE

|= (DEFFUNCTION SERVICE (?P) :-> ?S)

SERVICE

|= (ASSERT (NTH-DOMAIN SERVICE 0 WARFIGHTER))

(NTH-DOMAIN SERVICE 0 WARFIGHTER)

|= (ASSERT (NTH-DOMAIN SERVICE 1 ARMED-SERVICE))

(NTH-DOMAIN SERVICE 1 ARMED-SERVICE)

|= (ASSERT (DOCUMENTATION SERVICE "The armed service to which a warfighter belongs."))

(DOCUMENTATION SERVICE "The armed service to which a warfighter belongs.")

|= (DEFFUNCTION SERVICE ((?P WARFIGHTER) (?S ARMED-SERVICE)) :DOCUMENTATION "The armed service to which a warfighter belongs.")

SERVICE

|= (DEFFUNCTION FRIENDS ((?P PERSON)) :-> (?F SET) :DOCUMENTATION "The set of friends ?f of some person ?p.")

FRIENDS

|= (DEFCONCEPT CIVILIAN (?P PERSON) :DOCUMENTATION "People who are not warfighters." :<=> (AND (PERSON ?P) (NOT (WARFIGHTER ?P))))

CIVILIAN

|= (DEFCONCEPT CIVILIAN)

CIVILIAN

|= (ASSERT (SUBSET-OF CIVILIAN PERSON))

(forall (?x1)
   (<= (PERSON ?x1)
       (CIVILIAN ?x1)))

|= (ASSERT (DOCUMENTATION CIVILIAN "People who are not warfighters."))

(DOCUMENTATION CIVILIAN "People who are not warfighters.")

|= (ASSERT (FORALL (?P) (<=> (CIVILIAN ?P) (AND (PERSON ?P) (NOT (WARFIGHTER ?P))))))

((forall (?p)
   (<= (not (WARFIGHTER ?p))
       (CIVILIAN ?p))) (forall (?x1)
   (<= (PERSON ?x1)
       (CIVILIAN ?x1))) (forall (?p)
   (<= (CIVILIAN ?p)
       (and (PERSON ?p)
            (not (WARFIGHTER ?p))))))

|= (DEFCONCEPT ARMY-PERSON (?P WARFIGHTER) :<=> (AND (WARFIGHTER ?P) (= (SERVICE ?P) US-ARMY)))

ARMY-PERSON

|= (DEFCONCEPT NAVY-PERSON (?P WARFIGHTER) :<=> (AND (WARFIGHTER ?P) (= (SERVICE ?P) US-NAVY)))

NAVY-PERSON

|= (ASSERT (WARFIGHTER BUCK))

(WARFIGHTER BUCK)

|= (ASSERT (= (SERVICE BUCK) US-ARMY))

(= (SERVICE BUCK) US-ARMY)

|= (ASSERT (PERSON JOHN))

(PERSON JOHN)

|= (ASSERT (MEMBER-OF BUCK (FRIENDS JOHN)))

(MEMBER-OF BUCK (FRIENDS JOHN))

|= (ASSERT (MEMBER-OF JOHN (FRIENDS BUCK)))

(MEMBER-OF JOHN (FRIENDS BUCK))

|= (ASSERT (PERSON JUDY))

(PERSON JUDY)

|= (ASK (WARFIGHTER JUDY))

UNKNOWN

|= (ASK (CIVILIAN JUDY))

UNKNOWN

|= (ASSERT (WARFIGHTER JUDY))

(WARFIGHTER JUDY)

|= (ASSERT (= (SERVICE JUDY) US-NAVY))

(= (SERVICE JUDY) US-NAVY)

|= (ASK (NAVY-PERSON JUDY))

TRUE

|= (ASK (CIVILIAN JUDY))

UNKNOWN

|= (ASK (NOT (CIVILIAN JUDY)))

TRUE

|= (ASSERT (CIVILIAN BLIMPY))

(CIVILIAN BLIMPY)

|= (ASK (CIVILIAN BLIMPY))

TRUE

|= (ASK (WARFIGHTER BLIMPY))

FALSE

|= (ASK (NOT (WARFIGHTER BLIMPY)))

TRUE

|= (ASSERT (WARFIGHTER FRED))

(WARFIGHTER FRED)

|= (ASSERT (= (SERVICE FRED) US-AIRFORCE))

(= (SERVICE FRED) US-AIRFORCE)

|= (RETRIEVE ALL (PERSON ?P))

(JUDY JOHN FRED BUCK BLIMPY)


|= (RETRIEVE ALL (WARFIGHTER ?W))

(FRED JUDY BUCK)


|= (RETRIEVE ALL (AND (PERSON ?P) (NOT (CIVILIAN ?P))))

(JUDY FRED BUCK)


|= (RETRIEVE ALL (AND (PERSON ?P) (NOT (WARFIGHTER ?P))))

(BLIMPY)


|= (RETRIEVE ALL (CIVILIAN ?P))

(BLIMPY)


|= (RETRIEVE ALL (ARMY-PERSON ?W))

(BUCK)


|= (RETRIEVE ALL (NAVY-PERSON ?W))

(JUDY)


|= (RETRIEVE ALL (AND (WARFIGHTER ?W) (OR (= (SERVICE ?W) US-NAVY) (= (SERVICE ?W) US-AIRFORCE))))

(JUDY FRED)


|= (RETRIEVE ALL (AND (WARFIGHTER ?W) (MEMBER-OF (SERVICE ?W) (SETOF US-NAVY US-AIRFORCE))))

(FRED JUDY)


|= (RETRIEVE ALL (AND (PERSON ?P) (PERSON ?F) (MEMBER-OF ?F (FRIENDS ?P))))

((BUCK JOHN)
 (JOHN BUCK))


|= (RETRIEVE ALL (AND (ARMED-SERVICE ?S) (EXISTS (?P ?W) (AND (PERSON ?P) (WARFIGHTER ?W) (MEMBER-OF ?P (FRIENDS ?W)) (= (SERVICE ?W) ?S)))))

(US-ARMY)


|= 

Finished testing file `classes.plm'.

Now testing file `collections.plm':

|= (IN-PACKAGE "STELLA")


|= (DEFMODULE "PL-USER/COLLECTIONS")

/PL-KERNEL-KB/PL-USER/COLLECTIONS

|= (IN-MODULE "COLLECTIONS")


|= (CLEAR-MODULE "COLLECTIONS")


|= (RESET-FEATURES)

|l|(:EMIT-THINKING-DOTS :JUST-IN-TIME-INFERENCE)

|= (IN-DIALECT KIF)

:KIF

|= (DEFCONCEPT COLOR (?C) :<=> (MEMBER-OF ?C (SETOF RED ORANGE YELLOW GREEN BLUE PURPLE)))

COLOR

|= (DEFCONCEPT COLOR)

COLOR

|= (ASSERT (FORALL (?C) (<=> (COLOR ?C) (MEMBER-OF ?C (SETOF RED ORANGE YELLOW GREEN BLUE PURPLE)))))

((forall (?c)
   (<= (exists (?v10)
          (and (= (SETOF BLUE GREEN ORANGE PURPLE RED YELLOW) ?v10)
               (MEMBER-OF ?c ?v10)))
       (COLOR ?c))) (forall (?c)
   (<= (COLOR ?c)
       (exists (?v11)
          (and (= (SETOF BLUE GREEN ORANGE PURPLE RED YELLOW) ?v11)
               (MEMBER-OF ?c ?v11))))))

|= (DEFCONCEPT PRIMARY-COLOR (?C COLOR) :<=> (MEMBER-OF ?C (SETOF RED YELLOW BLUE)))

PRIMARY-COLOR

|= (DEFCONCEPT ALLIANCE-COLOR (?C COLOR) :<=> (MEMBER-OF ?C (SETOF RED BLUE)))

ALLIANCE-COLOR

|= (DEFCONCEPT TRAFFIC-LIGHT-COLOR (?C) :<=> (MEMBER-OF ?C (SETOF RED ORANGE GREEN)))

TRAFFIC-LIGHT-COLOR

|= (ASK (SUBSET-OF TRAFFIC-LIGHT-COLOR COLOR))

TRUE

|= (ASK (COLOR GREEN))

TRUE

|= (RETRIEVE ALL (COLOR ?X))

(RED ORANGE GREEN BLUE YELLOW PURPLE)


|= (RETRIEVE ALL (AND (COLOR ?X) (= ?X GREEN)))

WARNING: Type check violation: Assigned value `@GREEN'
   to skolem with type `@COLOR'.
   Warning occurred while parsing the proposition: 
   (KAPPA (?X) (AND (COLOR ?X) (= ?X @GREEN)))
(GREEN)


|= (RETRIEVE ALL (PRIMARY-COLOR ?X))

(BLUE RED YELLOW)


|= (ASK (NOT (PRIMARY-COLOR ORANGE)))

TRUE

|= (ASK (NOT (MEMBER-OF ORANGE PRIMARY-COLOR)))

TRUE

|= (RETRIEVE ALL (AND (COLOR ?X) (NOT (PRIMARY-COLOR ?X))))

(ORANGE GREEN PURPLE)


|= (ASK (MEMBER-OF BLUE (SETOF BLUE YELLOW)))

TRUE

|= (ASK (MEMBER-OF GREEN (SETOF BLUE YELLOW)))

FALSE

|= (ASK (NOT (MEMBER-OF BLUE (SETOF BLUE YELLOW))))

FALSE

|= (ASK (NOT (MEMBER-OF GREEN (SETOF BLUE YELLOW))))

TRUE

|= (ASK (SUBSET-OF (SETOF BLUE YELLOW) (SETOF BLUE YELLOW PURPLE)))

TRUE

|= (ASK (SUBSET-OF ALLIANCE-COLOR PRIMARY-COLOR))

TRUE

|= (ASK (SUBSET-OF (SETOF RED BLUE) PRIMARY-COLOR))

TRUE

|= (ASK (SUBSET-OF (SETOF RED BLUE) (SETOFALL ?X (PRIMARY-COLOR ?X))))

TRUE

|= (ASK (SUBSET-OF (SETOF RED BLUE) (SETOFALL (?X PRIMARY-COLOR))))

TRUE

|= (ASK (SUBSET-OF (SETOF RED BLUE) (SETOFALL (?X PRIMARY-COLOR) TRUE)))

TRUE

|= (ASK (SUBSET-OF (SETOFALL (?X COLOR) (NOT (PRIMARY-COLOR ?X))) COLOR))

TRUE

|= (ASK (SUBSET-OF (SETOFALL (?X COLOR) (NOT (PRIMARY-COLOR ?X))) (SETOFALL (?X COLOR) (NOT (ALLIANCE-COLOR ?X)))))

TRUE

|= (ASK (NOT (SUBSET-OF ALLIANCE-COLOR PRIMARY-COLOR)))

FALSE

|= (ASK (NOT (SUBSET-OF PRIMARY-COLOR ALLIANCE-COLOR)))

TRUE

|= (ASK (NOT (SUBSET-OF (SETOFALL (?X COLOR) (NOT (PRIMARY-COLOR ?X))) (SETOFALL (?X COLOR) (NOT (ALLIANCE-COLOR ?X))))))

FALSE

|= (ASK (NOT (SUBSET-OF (SETOFALL (?X COLOR) (NOT (ALLIANCE-COLOR ?X))) (SETOFALL (?X COLOR) (NOT (PRIMARY-COLOR ?X))))))

TRUE

|= 

Finished testing file `collections.plm'.

Now testing file `append.plm':

|= (IN-PACKAGE "STELLA")


|= (DEFMODULE "PL-USER/PROLOG-APPEND" :SHADOW (CONS))

/PL-KERNEL-KB/PL-USER/PROLOG-APPEND

|= (IN-MODULE "PROLOG-APPEND")


|= (CLEAR-MODULE "PROLOG-APPEND")


|= (RESET-FEATURES)

|l|(:EMIT-THINKING-DOTS :JUST-IN-TIME-INFERENCE)

|= (IN-DIALECT KIF)

:KIF

|= (DEFCONCEPT CONS-CELL)

CONS-CELL

|= (DEFFUNCTION CONS (?HEAD (?TAIL CONS-CELL)) :-> (?CONS CONS-CELL) :DOCUMENTATION "Add `?head' to the front of the cons-list `?tail'." :TOTAL TRUE)

CONS

|= (DEFFUNCTION APPEND ((?LIST1 CONS-CELL) (?LIST2 CONS-CELL)) :-> (?R CONS-CELL) :DOCUMENTATION "Append the cons-lists `?list1' and `?list2'.")

APPEND

|= (ASSERT (CONS-CELL NIL))

(CONS-CELL NIL)

|= (ASSERT (=> (AND (= ?LIST1 NIL) (= ?LIST2 ?RESULT)) (= (APPEND ?LIST1 ?LIST2) ?RESULT)))

(forall (?list1 ?list2 ?list2)
   (<= (= (APPEND NIL ?list2) ?list2)
       TRUE))

|= (ASSERT (=> (EXISTS (?HEAD ?TAIL ?REST) (AND (= ?LIST1 (CONS ?HEAD ?TAIL)) (= ?REST (APPEND ?TAIL ?LIST2)) (= ?RESULT (CONS ?HEAD ?REST)))) (= (APPEND ?LIST1 ?LIST2) ?RESULT)))

(forall (?list1 ?list2 ?result)
   (<= (= (APPEND ?list1 ?list2) ?result)
       (exists (?head ?tail ?rest)
          (and (= (CONS ?head ?tail) ?list1)
               (= (APPEND ?tail ?list2) ?rest)
               (= (CONS ?head ?rest) ?result)))))

|= (RETRIEVE ALL ?Z (= ?Z (APPEND NIL NIL)))

(NIL)


|= (RETRIEVE ALL ?Z (= ?Z (APPEND (CONS RED NIL) NIL)))

((CONS RED NIL))


|= (RETRIEVE ALL ?Z (= ?Z (APPEND NIL (CONS RED NIL))))

((CONS RED NIL))


|= (RETRIEVE ALL ?Z (= ?Z (APPEND (CONS RED NIL) (CONS BLUE NIL))))

((CONS RED (CONS BLUE NIL)))


|= (RETRIEVE ALL ?Z (= ?Z (APPEND (CONS YELLOW (CONS GREEN NIL)) (APPEND (CONS RED NIL) (CONS BLUE NIL)))))

((CONS YELLOW (CONS GREEN (CONS RED (CONS BLUE NIL)))))


|= (ASSERT (= (CONS GREEN NIL) GREEN-CONS))

(= (CONS GREEN NIL) GREEN-CONS)

|= (RETRIEVE ALL ?M (EXISTS (?T) (= (CONS ?M ?T) GREEN-CONS)))

(GREEN)


|= (RETRIEVE ALL (?M ?T) (= (CONS ?M ?T) GREEN-CONS))

((GREEN NIL))


|= 

Finished testing file `append.plm'.

Now testing file `inequalities.plm':

|= (IN-PACKAGE "STELLA")


|= (DEFMODULE "PL-USER/INEQUALITIES")

/PL-KERNEL-KB/PL-USER/INEQUALITIES

|= (IN-MODULE "INEQUALITIES")


|= (CLEAR-MODULE "INEQUALITIES")


|= (RESET-FEATURES)

|l|(:EMIT-THINKING-DOTS :JUST-IN-TIME-INFERENCE)

|= (IN-DIALECT KIF)

:KIF

|= (DEFCONCEPT PERSON (?P) :DOCUMENTATION "The class of human beings.")

PERSON

|= (DEFFUNCTION AGE ((?P PERSON)) :-> (?A INTEGER) :DOCUMENTATION "?a is ?p's age in years.")

AGE

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (> (AGE FRED) 30))

(> (AGE FRED) 30)

|= (ASK (> (AGE FRED) 30))

TRUE

|= (ASK (> (AGE FRED) 25))

TRUE

|= (ASSERT (PERSON SUSI))

(PERSON SUSI)

|= (ASSERT (= (AGE SUSI) 16))

(= (AGE SUSI) 16)

|= (ASK (> (AGE SUSI) 12))

TRUE

|= (ASK (> (AGE FRED) (AGE SUSI)))

TRUE

|= 

Finished testing file `inequalities.plm'.

Now testing file `recursion.plm':

|= (IN-PACKAGE "STELLA")


|= (DEFMODULE "/PL-KERNEL/PL-USER/RECURSION")

/PL-KERNEL-KB/PL-USER/RECURSION

|= (IN-MODULE "RECURSION")


|= (CLEAR-MODULE "RECURSION")


|= (RESET-FEATURES)

|l|(:EMIT-THINKING-DOTS :JUST-IN-TIME-INFERENCE)

|= (IN-DIALECT :KIF)

:KIF

|= (DEFCONCEPT PERSON (?P) :DOCUMENTATION "The class of human beings.")

PERSON

|= (DEFRELATION HAPPY ((?P PERSON)))

HAPPY

|= (DEFFUNCTION AGE ((?P PERSON)) :-> (?A INTEGER))

AGE

|= (DEFRELATION HAS-PARENT ((?P PERSON) (?PARENT PERSON)) :DOCUMENTATION "True if `self' has `parent' as a parent.")

HAS-PARENT

|= (DEFRELATION HAS-ANCESTOR ((?P PERSON) (?ANCESTOR PERSON)) :DOCUMENTATION "True if `self' has `ancestor' as an ancestor.")

HAS-ANCESTOR

|= (ASSERT (FORALL ((?X PERSON) (?Y PERSON)) (=> (HAS-PARENT ?X ?Y) (HAS-ANCESTOR ?X ?Y))))

(forall (?x ?y)
   (<= (HAS-ANCESTOR ?x ?y)
       (HAS-PARENT ?x ?y)))

|= (ASSERT (FORALL ((?X PERSON) (?Z PERSON)) (=> (EXISTS (?Y PERSON) (AND (HAS-ANCESTOR ?X ?Y) (HAS-ANCESTOR ?Y ?Z))) (HAS-ANCESTOR ?X ?Z))))

(forall (?x ?z)
   (<= (HAS-ANCESTOR ?x ?z)
       (exists (?y)
          (and (HAS-ANCESTOR ?x ?y)
               (HAS-ANCESTOR ?y ?z)))))

|= (ASSERT (AND (PERSON ABBY) (PERSON BENNY) (PERSON CARLA) (PERSON DEBBIE) (PERSON EDWARD) (PERSON FRED)))

((PERSON ABBY) (PERSON BENNY) (PERSON CARLA) (PERSON DEBBIE) (PERSON EDWARD) (PERSON FRED))

|= (ASSERT (HAS-PARENT ABBY BENNY))

(HAS-PARENT ABBY BENNY)

|= (ASSERT (HAS-ANCESTOR BENNY CARLA))

(HAS-ANCESTOR BENNY CARLA)

|= (ASSERT (HAS-PARENT CARLA DEBBIE))

(HAS-PARENT CARLA DEBBIE)

|= (ASSERT (HAS-ANCESTOR DEBBIE EDWARD))

(HAS-ANCESTOR DEBBIE EDWARD)

|= (ASSERT (HAS-PARENT EDWARD FRED))

(HAS-PARENT EDWARD FRED)

|= (RETRIEVE (?Z PERSON) (HAS-ANCESTOR ABBY ?Z))

(BENNY)


|= (RETRIEVE 2)

(BENNY CARLA DEBBIE)


|= (RETRIEVE)

(BENNY CARLA DEBBIE EDWARD)


|= (RETRIEVE)

(BENNY CARLA DEBBIE EDWARD FRED)


|= (RETRIEVE)

(BENNY CARLA DEBBIE EDWARD FRED)


|= (RETRIEVE ALL (?Z PERSON) (HAS-ANCESTOR BENNY ?Z))

(DEBBIE CARLA EDWARD FRED)


|= (RETRIEVE ALL (?Z PERSON) (HAS-ANCESTOR CARLA ?Z))

(FRED EDWARD DEBBIE)


|= (RETRIEVE ALL (?Z PERSON) (HAS-ANCESTOR DEBBIE ?Z))

(FRED EDWARD)


|= (RETRIEVE ALL (?Z PERSON) (HAS-ANCESTOR EDWARD ?Z))

(FRED)


|= (RETRIEVE ALL (?Z PERSON) (HAS-ANCESTOR FRED ?Z))

()


|= 

Finished testing file `recursion.plm'.

Now testing file `negation.plm':

|= (IN-PACKAGE "STELLA")


|= (DEFMODULE "/PL-KERNEL/PL-USER/NEGATION")

/PL-KERNEL-KB/PL-USER/NEGATION

|= (IN-MODULE "NEGATION")


|= (CLEAR-MODULE "NEGATION")


|= (RESET-FEATURES)

|l|(:EMIT-THINKING-DOTS :JUST-IN-TIME-INFERENCE)

|= (IN-DIALECT :KIF)

:KIF

|= (DEFCONCEPT PERSON (?P) :DOCUMENTATION "The class of human beings.")

PERSON

|= (DEFRELATION HAPPY ((?P PERSON)))

HAPPY

|= (DEFRELATION DESPONDENT ((?P PERSON)))

DESPONDENT

|= (DEFFUNCTION BOSS ((?P PERSON)) :-> (?B PERSON))

BOSS

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (PERSON EDWARD))

(PERSON EDWARD)

|= (ASSERT (PERSON CARLA))

(PERSON CARLA)

|= (ASSERT (= (BOSS FRED) EDWARD))

(= (BOSS FRED) EDWARD)

|= (ASSERT (= (BOSS EDWARD) CARLA))

(= (BOSS EDWARD) CARLA)

|= (ASSERT (NOT (HAPPY (BOSS FRED))))

(not (HAPPY (BOSS FRED)))

|= (DENY (HAPPY (BOSS FRED)))

(not (HAPPY (BOSS FRED)))

|= (RETRIEVE ALL (?X PERSON) (NOT (HAPPY (BOSS ?X))))

(FRED)


|= (RETRIEVE ALL (?X PERSON) (EXISTS (?Y PERSON) (AND (= (BOSS ?X) ?Y) (NOT (HAPPY ?Y)))))

(FRED)


|= (ASSERT (FORALL (?X PERSON) (=> (DESPONDENT ?X) (NOT (HAPPY ?X)))))

(forall (?x)
   (<= (not (HAPPY ?x))
       (DESPONDENT ?x)))

|= (ASSERT (PERSON GREG))

(PERSON GREG)

|= (ASSERT (DESPONDENT GREG))

(DESPONDENT GREG)

|= (ASK (HAPPY GREG))

FALSE

|= (ASK (NOT (HAPPY GREG)))

TRUE

|= (DEFRELATION HAS-FRIEND ((?X PERSON) (?Y PERSON)) :DOCUMENTATION "True, if `?x' has `?y' as a friend.")

HAS-FRIEND

|= (DEFRELATION HAS-ENEMY ((?X PERSON) (?Y PERSON)) :DOCUMENTATION "True, if `?x' has `?y' as an enemy.")

HAS-ENEMY

|= (ASSERT (FORALL ((?X PERSON) (?Y PERSON)) (=> (HAS-ENEMY ?X ?Y) (NOT (HAS-FRIEND ?X ?Y)))))

(forall (?x ?y)
   (<= (not (HAS-FRIEND ?x ?y))
       (HAS-ENEMY ?x ?y)))

|= (ASSERT (PERSON HARRY))

(PERSON HARRY)

|= (ASSERT (HAS-ENEMY GREG HARRY))

(HAS-ENEMY GREG HARRY)

|= (ASK (HAS-FRIEND GREG HARRY))

FALSE

|= (ASK (NOT (HAS-FRIEND GREG HARRY)))

TRUE

|= (DEFCONCEPT MALE-PERSON (?P PERSON))

MALE-PERSON

|= (DEFCONCEPT FEMALE-PERSON (?P PERSON))

FEMALE-PERSON

|= (ASSERT (FORALL (?X MALE-PERSON) (NOT (FEMALE-PERSON ?X))))

(forall (?x)
   (<= (not (FEMALE-PERSON ?x))
       (MALE-PERSON ?x)))

|= (ASSERT (PERSON IVAN))

(PERSON IVAN)

|= (ASSERT (MALE-PERSON IVAN))

(MALE-PERSON IVAN)

|= (ASK (FEMALE-PERSON IVAN))

FALSE

|= (ASK (NOT (FEMALE-PERSON IVAN)))

TRUE

|= 

Finished testing file `negation.plm'.

Now testing file `constraints.plm':

|= (IN-PACKAGE "STELLA")


|= (DEFMODULE "/PL-KERNEL/PL-USER/CONSTRAINTS")

/PL-KERNEL-KB/PL-USER/CONSTRAINTS

|= (IN-MODULE "CONSTRAINTS")


|= (CLEAR-MODULE "CONSTRAINTS")


|= (RESET-FEATURES)

|l|(:EMIT-THINKING-DOTS :JUST-IN-TIME-INFERENCE)

|= (IN-DIALECT :KIF)

:KIF

|= (DEFCONCEPT PERSON (?P) :DOCUMENTATION "The class of human beings.")

PERSON

|= (DEFRELATION HAPPY ((?P PERSON)))

HAPPY

|= (DEFFUNCTION AGE ((?P PERSON)) :-> (?A INTEGER))

AGE

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (UNSET-FEATURE :JUST-IN-TIME-INFERENCE)

|l|(:EMIT-THINKING-DOTS)

|= (ASSERT (OR (HAPPY FRED) (= (AGE FRED) 40)))

(or (HAPPY FRED)
    (= (AGE FRED) 40))

|= (ASK (= (AGE FRED) 40))

UNKNOWN

|= (ASSERT (NOT (HAPPY FRED)))

(not (HAPPY FRED))

|= (ASK (= (AGE FRED) 40))

UNKNOWN

|= (SET-FEATURE :JUST-IN-TIME-INFERENCE)

|l|(:JUST-IN-TIME-INFERENCE :EMIT-THINKING-DOTS)

|= (ASK (= (AGE FRED) 40))

TRUE

|= (SET-FEATURE TRACE-SUBGOALS)

|l|(:TRACE-SUBGOALS :JUST-IN-TIME-INFERENCE :EMIT-THINKING-DOTS)

|= (ASK (= (AGE FRED) 40))

PATTERN: []
| GOAL: (= (AGE FRED) 40)
| SUCC: truth=T
TRUE

|= (UNSET-FEATURE TRACE-SUBGOALS)

|l|(:JUST-IN-TIME-INFERENCE :EMIT-THINKING-DOTS)

|= (RETRACT (NOT (HAPPY FRED)))

(HAPPY FRED)

|= (ASK (= (AGE FRED) 40))

UNKNOWN

|= (ASSERT (PERSON FRITZ))

(PERSON FRITZ)

|= (ASSERT (= (AGE FRITZ) 25))

(= (AGE FRITZ) 25)

|= (ASK (HAPPY FRITZ))

UNKNOWN

|= (ASSERT (OR (HAPPY FRITZ) (= (AGE FRITZ) 40)))

(or (HAPPY FRITZ)
    (= (AGE FRITZ) 40))

|= (ASK (HAPPY FRITZ))

TRUE

|= (ASSERT (PERSON JOHN))

(PERSON JOHN)

|= (ASSERT (PERSON MARY))

(PERSON MARY)

|= (ASSERT (= (AGE JOHN) (AGE MARY)))

(= (AGE JOHN) (AGE MARY))

|= (ASK (= (AGE MARY) 25))

UNKNOWN

|= (ASSERT (= (AGE JOHN) 25))

(= (AGE JOHN) 25)

|= (ASK (= (AGE MARY) 25))

TRUE

|= 

Finished testing file `constraints.plm'.

Now testing file `equations.plm':

|= (IN-PACKAGE "STELLA")


|= (DEFMODULE "PL-USER/EQUATIONS")

/PL-KERNEL-KB/PL-USER/EQUATIONS

|= (IN-MODULE "EQUATIONS")


|= (CLEAR-MODULE "EQUATIONS")


|= (RESET-FEATURES)

|l|(:JUST-IN-TIME-INFERENCE :EMIT-THINKING-DOTS)

|= (IN-DIALECT KIF)

:KIF

|= (DEFCONCEPT MOVEMENT-EVENT (?EV) :DOCUMENTATION "The class of movement events.  The time of each event
depends on the movement speed and distance covered as expressed by the
defining rule." :=> (= (* (TIME ?EV) (SPEED ?EV)) (DISTANCE ?EV)))

MOVEMENT-EVENT

|= (DEFFUNCTION TIME ((?EV MOVEMENT-EVENT) ?TIME))

TIME

|= (DEFFUNCTION SPEED ((?EV MOVEMENT-EVENT) ?SPEED))

SPEED

|= (DEFFUNCTION DISTANCE ((?EV MOVEMENT-EVENT) ?DISTANCE))

DISTANCE

|= (DEFINSTANCE EV1 :MOVEMENT-EVENT TRUE :SPEED 10 :TIME 20)

EV1

|= (DEFINSTANCE EV2 :MOVEMENT-EVENT TRUE :SPEED 10 :DISTANCE 50)

EV2

|= (RETRIEVE ALL (DISTANCE EV1 ?X))

(200)


|= (RETRIEVE ALL (TIME EV2 ?X))

(5)


|= (DEFCONCEPT LINE)

LINE

|= (DEFRELATION POINT-OF (?L ?P))

POINT-OF

|= (DEFFUNCTION XCOORD (?X ?Y))

XCOORD

|= (DEFFUNCTION YCOORD (?X ?Y))

YCOORD

|= (DEFFUNCTION SLOPE (?X ?Y))

SLOPE

|= (DEFFUNCTION OFFSET (?X ?Y))

OFFSET

|= (ASSERT (=> (AND (LINE ?L) (POINT-OF ?L ?P)) (= (YCOORD ?P) (+ (* (XCOORD ?P) (SLOPE ?L)) (OFFSET ?L)))))

(forall (?l ?p)
   (<= (exists (?v15 ?v13 ?v11 ?v12 ?v14)
          (and (= (YCOORD ?p) ?v15)
               (= (XCOORD ?p) ?v11)
               (= (SLOPE ?l) ?v12)
               (= (* ?v11 ?v12) ?v13)
               (= (OFFSET ?l) ?v14)
               (= (+ ?v13 ?v14) ?v15)))
       (and (LINE ?l)
            (POINT-OF ?l ?p))))

|= (ASSERT (AND (LINE LN1) (POINT-OF LN1 PT1) (SLOPE LN1 2) (OFFSET LN1 1) (XCOORD PT1 3)))

((LINE LN1) (POINT-OF LN1 PT1) (= (SLOPE LN1) 2) (= (OFFSET LN1) 1) (= (XCOORD PT1) 3))

|= (RETRIEVE ALL (YCOORD PT1 ?X))

(7)


|= (ASSERT (AND (LINE LN2) (POINT-OF LN2 PT2) (SLOPE LN2 2) (OFFSET LN2 1) (YCOORD PT2 7)))

((LINE LN2) (POINT-OF LN2 PT2) (= (SLOPE LN2) 2) (= (OFFSET LN2) 1) (= (YCOORD PT2) 7))

|= (RETRIEVE ALL (XCOORD PT2 ?X))

(3)


|= (ASSERT (AND (LINE LN3) (POINT-OF LN3 PT3) (SLOPE LN3 2) (XCOORD PT3 3) (YCOORD PT3 7)))

((LINE LN3) (POINT-OF LN3 PT3) (= (SLOPE LN3) 2) (= (XCOORD PT3) 3) (= (YCOORD PT3) 7))

|= (RETRIEVE ALL (OFFSET LN3 ?X))

(1)


|= (ASSERT (AND (LINE LN4) (POINT-OF LN4 PT4) (OFFSET LN4 1) (XCOORD PT4 3) (YCOORD PT4 7)))

((LINE LN4) (POINT-OF LN4 PT4) (= (OFFSET LN4) 1) (= (XCOORD PT4) 3) (= (YCOORD PT4) 7))

|= (RETRIEVE ALL (SLOPE LN4 ?X))

(2)


|= 

Finished testing file `equations.plm'.

Now testing file `subsumption.plm':

|= (IN-PACKAGE "STELLA")


|= (DEFMODULE "/PL-KERNEL/KIF-FRAME-ONTOLOGY/SUBSUMPTION")

/PL-KERNEL-KB/KIF-FRAME-ONTOLOGY/SUBSUMPTION

|= (IN-MODULE "SUBSUMPTION")


|= (CLEAR-MODULE "SUBSUMPTION")


|= (RESET-FEATURES)

|l|(:JUST-IN-TIME-INFERENCE :EMIT-THINKING-DOTS)

|= (IN-DIALECT :KIF)

:KIF

|= (DEFCONCEPT PERSON (?P))

PERSON

|= (DEFFUNCTION FRIENDS-OF (?P) :-> (?F SET))

FRIENDS-OF

|= (DEFRELATION HAS-PARENT ((?X PERSON) (?Y PERSON)))

HAS-PARENT

|= (DEFRELATION MALE ((?P PERSON)))

MALE

|= (DEFRELATION HAS-FATHER ((?P PERSON) (?F PERSON)) :<=> (AND (HAS-PARENT ?P ?F) (MALE ?P)))

HAS-FATHER

|= (ASK (SUBSET-OF HAS-FATHER HAS-PARENT))

TRUE

|= (ASSERT (FORALL ((?X NUMBER) (?Y NUMBER)) (<= (>= ?X ?Y) (> ?X ?Y))))

(forall (?x ?y)
   (<= (>= ?x ?y)
       (> ?x ?y)))

|= (DEFCONCEPT PERSON-WITH-FRIENDS (?P) :<=> (>= (CARDINALITY (FRIENDS-OF ?P)) 1))

PERSON-WITH-FRIENDS

|= (DEFCONCEPT PERSON-WITH-ATLEAST-2-FRIENDS (?P) :<=> (>= (CARDINALITY (FRIENDS-OF ?P)) 2))

PERSON-WITH-ATLEAST-2-FRIENDS

|= (DEFCONCEPT PERSON-WITH-EXACTLY-2-FRIENDS (?P) :<=> (= (CARDINALITY (FRIENDS-OF ?P)) 2))

PERSON-WITH-EXACTLY-2-FRIENDS

|= (DEFCONCEPT PERSON-WITH-MORE-THAN-2-FRIENDS (?P) :<=> (> (CARDINALITY (FRIENDS-OF ?P)) 2))

PERSON-WITH-MORE-THAN-2-FRIENDS

|= (ASK (SUBSET-OF PERSON-WITH-EXACTLY-2-FRIENDS PERSON-WITH-ATLEAST-2-FRIENDS))

TRUE

|= (ASK (SUBSET-OF PERSON-WITH-ATLEAST-2-FRIENDS PERSON-WITH-EXACTLY-2-FRIENDS))

UNKNOWN

|= (ASK (SUBSET-OF PERSON-WITH-MORE-THAN-2-FRIENDS PERSON-WITH-ATLEAST-2-FRIENDS))

TRUE

|= (ASK (SUBSET-OF PERSON-WITH-ATLEAST-2-FRIENDS PERSON-WITH-MORE-THAN-2-FRIENDS))

UNKNOWN

|= (ASK (SUBSET-OF PERSON-WITH-ATLEAST-2-FRIENDS PERSON-WITH-FRIENDS))

TRUE

|= 

Finished testing file `subsumption.plm'.

Now testing file `family.plm':

|= (IN-PACKAGE "STELLA")


|= (DEFMODULE "ROYAL-FAMILY" :INCLUDES ("/PL-KERNEL/PL-USER"))

/PL-KERNEL-KB/PL-USER/ROYAL-FAMILY

|= (IN-MODULE "ROYAL-FAMILY")


|= (CLEAR-MODULE "ROYAL-FAMILY")


|= (RESET-FEATURES)

|l|(:JUST-IN-TIME-INFERENCE :EMIT-THINKING-DOTS)

|= (IN-DIALECT KIF)

:KIF

|= (DEFCONCEPT HUMAN () :DOCUMENTATION "The class of human beings.")

HUMAN

|= (DEFCONCEPT WOMAN (HUMAN) :DOCUMENTATION "The class of female human beings.")

WOMAN

|= (DEFCONCEPT MAN (HUMAN) :DOCUMENTATION "The class of male human beings.")

MAN

|= (DEFRELATION HAS-CHILD ((?P HUMAN) (?C HUMAN)) :DOCUMENTATION "True if ?p is a parent of ?c." :INVERSE HAS-PARENT)

HAS-CHILD

|= (DEFCONCEPT MOTHER (?M WOMAN) :DOCUMENTATION "The class of female humans with children." :<=> (EXISTS (?X HUMAN) (HAS-CHILD ?M ?X)))

MOTHER

|= (DEFCONCEPT FATHER (?F MAN) :DOCUMENTATION "The class of male humans with children." :<=> (EXISTS (?X HUMAN) (HAS-CHILD ?F ?X)))

FATHER

|= (DEFRELATION HAS-PARENT ((?C HUMAN) (?P HUMAN)) :DOCUMENTATION "True if ?c is a child of ?p.  Inverse of `has-child'.")

HAS-PARENT

|= (DEFCONCEPT PARENT (?P HUMAN) :DOCUMENTATION "The class of humans who have children." :<=> (OR (MOTHER ?P) (FATHER ?P)))

PARENT

|= (DEFCONCEPT GRANDMOTHER (?GM WOMAN) :DOCUMENTATION "The class of female humans who have children with children." :<=> (EXISTS (?X PARENT) (HAS-CHILD ?GM ?X)))

GRANDMOTHER

|= (ASK (SUBSET-OF GRANDMOTHER MOTHER))

TRUE

|= (ASK (SUBSET-OF GRANDMOTHER PARENT))

TRUE

|= (ASSERT (WOMAN ELISABETH))

(WOMAN ELISABETH)

|= (ASSERT (MAN CHARLES))

(MAN CHARLES)

|= (ASSERT (HAS-CHILD ELISABETH CHARLES))

(HAS-CHILD ELISABETH CHARLES)

|= (ASK (MOTHER ELISABETH))

TRUE

|= (ASK (GRANDMOTHER ELISABETH))

UNKNOWN

|= (ASSERT (MAN WILLIAM))

(MAN WILLIAM)

|= (ASSERT (HAS-CHILD CHARLES WILLIAM))

(HAS-CHILD CHARLES WILLIAM)

|= (ASK (GRANDMOTHER ELISABETH))

TRUE

|= (DEFRELATION MARRIED-TO ((?X HUMAN) (?Y HUMAN)) :DOCUMENTATION "True if ?x is married to ?y." :AXIOMS ((SYMMETRIC MARRIED-TO) (SINGLE-VALUED MARRIED-TO) (=> (AND (MARRIED-TO ?X ?Y) (MAN ?X)) (WOMAN ?Y)) (=> (AND (MARRIED-TO ?X ?Y) (WOMAN ?X)) (MAN ?Y))))

MARRIED-TO

|= (DEFCONCEPT WIFE (?W WOMAN) :DOCUMENTATION "The class of married women." :<=> (EXISTS (?X MAN) (MARRIED-TO ?X ?W)))

WIFE

|= (DEFCONCEPT MOTHER-IN-LAW (?M WOMAN) :DOCUMENTATION "The class of mothers of spouses." :<=> (EXISTS (?X ?Y) (AND (HAS-CHILD ?M ?X) (MARRIED-TO ?X ?Y))))

MOTHER-IN-LAW

|= (DEFCONCEPT MOTHER-IN-LAW-OF-WIFE (?M WOMAN) :DOCUMENTATION "The class of mothers of female spouses." :<=> (EXISTS (?X ?Y) (AND (HAS-CHILD ?M ?X) (MARRIED-TO ?X ?Y) (WIFE ?Y))))

MOTHER-IN-LAW-OF-WIFE

|= (ASK (SUBSET-OF MOTHER-IN-LAW-OF-WIFE MOTHER-IN-LAW))

TRUE

|= (DEFRELATION HAS-SON ((?X HUMAN) (?Y HUMAN)) :DOCUMENTATION "True if ?y is a son of ?x." :<=> (AND (HAS-CHILD ?X ?Y) (MAN ?Y)))

HAS-SON

|= (DEFRELATION HAS-DAUGHTER ((?X HUMAN) (?Y HUMAN)) :DOCUMENTATION "True if ?y is a daughter of ?x." :<=> (AND (HAS-CHILD ?X ?Y) (WOMAN ?Y)))

HAS-DAUGHTER

|= (ASK (HAS-SON ELISABETH CHARLES))

TRUE

|= (DEFCONCEPT MOTHER-WITH-AT-LEAST-ONE-SON (?M MOTHER) :<=> (RANGE-CARDINALITY-LOWER-BOUND HAS-SON ?M 1))

MOTHER-WITH-AT-LEAST-ONE-SON

|= (ASK (SUBSET-OF MOTHER-IN-LAW-OF-WIFE MOTHER-WITH-AT-LEAST-ONE-SON))

TRUE

|= (ASSERT (AND (WOMAN DIANA) (MARRIED-TO CHARLES DIANA)))

((WOMAN DIANA) (MARRIED-TO CHARLES DIANA))

|= (ASK (MOTHER-IN-LAW ELISABETH))

TRUE

|= (ASK (WIFE DIANA))

TRUE

|= (ASK (MOTHER-IN-LAW-OF-WIFE ELISABETH))

TRUE

|= (DEFFUNCTION MOTHER-IN-LAW-OF ((?X HUMAN)) :-> (?M WOMAN) :<=> (EXISTS (?Y HUMAN) (AND (MARRIED-TO ?Y ?X) (HAS-CHILD ?M ?Y))))

MOTHER-IN-LAW-OF

|= (RETRIEVE ALL ?X (= (MOTHER-IN-LAW-OF DIANA) ?X))

(ELISABETH)


|= (DEFCONCEPT MOTHER-WITH-MORE-SONS-THAN-DAUGHTERS (?M MOTHER) :<=> (EXISTS (?X ?Y) (AND (RANGE-CARDINALITY-LOWER-BOUND HAS-SON ?M ?X) (RANGE-CARDINALITY-UPPER-BOUND HAS-DAUGHTER ?M ?Y) (> ?X ?Y))))

MOTHER-WITH-MORE-SONS-THAN-DAUGHTERS

|= (ASK (SUBSET-OF MOTHER-WITH-MORE-SONS-THAN-DAUGHTERS MOTHER-WITH-AT-LEAST-ONE-SON))

TRUE

|= (ASSERT (CLOSED HAS-SON))

(CLOSED HAS-SON)

|= (ASSERT (CLOSED HAS-DAUGHTER))

(CLOSED HAS-DAUGHTER)

|= (ASK (MOTHER-WITH-MORE-SONS-THAN-DAUGHTERS ELISABETH))

UNKNOWN

|= 

Finished testing file `family.plm'.

Now testing file `relation-hierarchy.plm':

|= (IN-PACKAGE "STELLA")


|= (DEFMODULE "PL-USER/RELATION-HIERARCHY")

/PL-KERNEL-KB/PL-USER/RELATION-HIERARCHY

|= (IN-MODULE "RELATION-HIERARCHY")


|= (CLEAR-MODULE "RELATION-HIERARCHY")


|= (RESET-FEATURES)

|l|(:JUST-IN-TIME-INFERENCE :EMIT-THINKING-DOTS)

|= (IN-DIALECT :KIF)

:KIF

|= (DEFCONCEPT A (?X) :<=> (A-EQUIV ?X))

A

|= (DEFCONCEPT A-EQUIV)

A-EQUIV

|= (DEFCONCEPT B (?X A) :<=> (B-EQUIV ?X))

B

|= (DEFCONCEPT B-EQUIV)

B-EQUIV

|= (DEFCONCEPT C (?X A) :<=> (C-EQUIV ?X))

C

|= (DEFCONCEPT C-EQUIV)

C-EQUIV

|= (DEFCONCEPT D (?X B) :<=> (D-EQUIV ?X))

D

|= (DEFCONCEPT D-EQUIV)

D-EQUIV

|= (DEFCONCEPT E (?X B) :<=> (E-EQUIV ?X))

E

|= (DEFCONCEPT E-EQUIV)

E-EQUIV

|= (DEFCONCEPT F (?X C) :<=> (F-EQUIV ?X))

F

|= (DEFCONCEPT F-EQUIV)

F-EQUIV

|= (DEFCONCEPT G (?X C) :<=> (G-EQUIV ?X))

G

|= (DEFCONCEPT G-EQUIV)

G-EQUIV

|= (ASK (DIRECT-SUBRELATION B D))

TRUE

|= (ASK (DIRECT-SUBRELATION A D))

UNKNOWN

|= (ASK (DIRECT-SUBRELATION B B))

UNKNOWN

|= (ASK (DIRECT-SUBRELATION B B-EQUIV))

UNKNOWN

|= (ASK (DIRECT-SUPERRELATION B A))

TRUE

|= (ASK (DIRECT-SUPERRELATION B B))

UNKNOWN

|= (ASK (DIRECT-SUPERRELATION B B-EQUIV))

UNKNOWN

|= (ASK (SUBRELATION A D))

TRUE

|= (ASK (SUBRELATION A A))

TRUE

|= (ASK (SUBRELATION A A-EQUIV))

TRUE

|= (ASK (SUBRELATION B C))

UNKNOWN

|= (ASK (SUPERRELATION D A))

TRUE

|= (ASK (SUPERRELATION D D))

TRUE

|= (ASK (SUPERRELATION D D-EQUIV))

TRUE

|= (ASK (SUPERRELATION B C))

UNKNOWN

|= (ASK (PROPER-SUBRELATION A D))

TRUE

|= (ASK (PROPER-SUBRELATION A A))

UNKNOWN

|= (ASK (PROPER-SUBRELATION A A-EQUIV))

UNKNOWN

|= (ASK (PROPER-SUPERRELATION D A))

TRUE

|= (ASK (PROPER-SUPERRELATION D D))

UNKNOWN

|= (ASK (PROPER-SUPERRELATION D D-EQUIV))

UNKNOWN

|= (ASK (EQUIVALENT-RELATION B B))

TRUE

|= (ASK (EQUIVALENT-RELATION B-EQUIV B))

TRUE

|= (ASK (EQUIVALENT-RELATION B C))

UNKNOWN

|= (RETRIEVE ALL ?R (DIRECT-SUBRELATION A ?R))

(C B)


|= (RETRIEVE ALL ?R (DIRECT-SUBRELATION ?R D))

(B)


|= (RETRIEVE ALL ?R (DIRECT-SUPERRELATION D ?R))

(B)


|= (RETRIEVE ALL ?R (DIRECT-SUPERRELATION ?R A))

(C B)


|= (RETRIEVE ALL ?R (SUBRELATION A ?R))

(A-EQUIV A B B-EQUIV D D-EQUIV E E-EQUIV C C-EQUIV F F-EQUIV G G-EQUIV)


|= (RETRIEVE ALL ?R (SUBRELATION ?R D))

(B A A-EQUIV B-EQUIV D-EQUIV D)


|= (RETRIEVE ALL ?R (SUPERRELATION D ?R))

(B A A-EQUIV B-EQUIV D-EQUIV D)


|= (RETRIEVE ALL ?R (SUPERRELATION ?R A))

(A-EQUIV A B B-EQUIV D D-EQUIV E E-EQUIV C C-EQUIV F F-EQUIV G G-EQUIV)


|= (RETRIEVE ALL ?R (PROPER-SUBRELATION A ?R))

(B B-EQUIV D D-EQUIV E E-EQUIV C C-EQUIV F F-EQUIV G G-EQUIV)


|= (RETRIEVE ALL ?R (PROPER-SUBRELATION ?R D))

(B A A-EQUIV B-EQUIV)


|= (RETRIEVE ALL ?R (PROPER-SUPERRELATION D ?R))

(B A A-EQUIV B-EQUIV)


|= (RETRIEVE ALL ?R (PROPER-SUPERRELATION ?R A))

(B B-EQUIV D D-EQUIV E E-EQUIV C C-EQUIV F F-EQUIV G G-EQUIV)


|= (RETRIEVE ALL ?R (EQUIVALENT-RELATION ?R B))

(B-EQUIV B)


|= (RETRIEVE ALL ?R (EQUIVALENT-RELATION B ?R))

(B-EQUIV B)


|= (RETRIEVE ALL (?SUP ?SUB) (SUBRELATION ?SUP ?SUB))

()


|= 

Finished testing file `relation-hierarchy.plm'.

Now testing file `defaults.plm':

|= (IN-PACKAGE "STELLA")


|= (DEFMODULE "/PL-KERNEL/PL-USER/DEFAULTS")

/PL-KERNEL-KB/PL-USER/DEFAULTS

|= (IN-MODULE "DEFAULTS")


|= (CLEAR-MODULE "DEFAULTS")


|= (RESET-FEATURES)

|l|(:JUST-IN-TIME-INFERENCE :EMIT-THINKING-DOTS)

|= (IN-DIALECT :KIF)

:KIF

|= (DEFCONCEPT BIRD (?X) :DOCUMENTATION "The class of birds.")

BIRD

|= (DEFRELATION FLIES ((?X BIRD)))

FLIES

|= (DEFRELATION DEAD ((?X BIRD)))

DEAD

|= (DEFCONCEPT PENGUIN (?X BIRD) :DOCUMENTATION "The class of penguins.")

PENGUIN

|= (PRESUME (FORALL (?X BIRD) (FLIES ?X)))

(forall (?x1)
   (<= (FLIES ?x1)
       (BIRD ?x1)))

|= (ASSERT (FORALL (?X PENGUIN) (NOT (FLIES ?X))))

(forall (?x)
   (<= (not (FLIES ?x))
       (PENGUIN ?x)))

|= (ASSERT (FORALL (?X BIRD) (=> (DEAD ?X) (NOT (FLIES ?X)))))

(forall (?x)
   (<= (not (FLIES ?x))
       (DEAD ?x)))

|= (ASSERT (BIRD TWEETY))

(BIRD TWEETY)

|= (ASSERT (PENGUIN OPUS))

(PENGUIN OPUS)

|= (ASSERT (BIRD LARRY))

(BIRD LARRY)

|= (ASSERT (DEAD LARRY))

(DEAD LARRY)

|= (RETRIEVE ALL (?X BIRD) (FLIES ?X))

(TWEETY)


|= (RETRIEVE ALL (?X BIRD) (NOT (FLIES ?X)))

(LARRY OPUS)


|= (DEFCONCEPT PERSON (?X) :DOCUMENTATION "The class of human beings.")

PERSON

|= (DEFRELATION HAPPY ((?X PERSON)))

HAPPY

|= (DEFFUNCTION AGE ((?X PERSON)) :-> (?A INTEGER))

AGE

|= (DEFRELATION SICK ((?X PERSON)))

SICK

|= (PRESUME (FORALL (?X PERSON) (=> (=< (AGE ?X) 20) (HAPPY ?X))))

(forall (?x)
   (<= (HAPPY ?x)
       (exists (?v14)
          (and (= (AGE ?x) ?v14)
               (=< ?v14 20)))))

|= (PRESUME (FORALL (?X PERSON) (=> (SICK ?X) (NOT (HAPPY ?X)))))

(forall (?x)
   (<= (not (HAPPY ?x))
       (SICK ?x)))

|= (ASSERT (PERSON JOHN))

(PERSON JOHN)

|= (ASSERT (= (AGE JOHN) 19))

(= (AGE JOHN) 19)

|= (ASK (HAPPY JOHN))

DEFAULT-TRUE

|= (ASK (NOT (HAPPY JOHN)))

UNKNOWN

|= (ASSERT (PERSON MARY))

(PERSON MARY)

|= (ASSERT (= (AGE MARY) 19))

(= (AGE MARY) 19)

|= (ASSERT (NOT (HAPPY MARY)))

(not (HAPPY MARY))

|= (ASK (HAPPY MARY))

FALSE

|= (ASK (NOT (HAPPY MARY)))

TRUE

|= (ASSERT (PERSON FRANK))

(PERSON FRANK)

|= (ASSERT (SICK FRANK))

(SICK FRANK)

|= (ASSERT (HAPPY FRANK))

(HAPPY FRANK)

|= (ASK (HAPPY FRANK))

TRUE

|= (ASK (NOT (HAPPY FRANK)))

FALSE

|= (ASSERT (PERSON SUE))

(PERSON SUE)

|= (ASSERT (= (AGE SUE) 19))

(= (AGE SUE) 19)

|= (ASSERT (SICK SUE))

(SICK SUE)

|= (ASK (HAPPY SUE))

UNKNOWN

|= (ASK (NOT (HAPPY SUE)))


|= (RETRIEVE ALL (?X PERSON) (HAPPY ?X))

(FRANK JOHN)


|= (RETRIEVE ALL (?X PERSON) (NOT (HAPPY ?X)))

(MARY)


|= 

Finished testing file `defaults.plm'.

Now testing file `defaults2.plm':

|= (IN-PACKAGE "STELLA")


|= (DEFMODULE "/PL-KERNEL/PL-USER/DEFAULTS2")

/PL-KERNEL-KB/PL-USER/DEFAULTS2

|= (IN-MODULE "DEFAULTS2")


|= (CLEAR-MODULE "DEFAULTS2")


|= (RESET-FEATURES)

|l|(:JUST-IN-TIME-INFERENCE :EMIT-THINKING-DOTS)

|= (IN-DIALECT :KIF)

:KIF

|= (DEFCONCEPT ANIMAL (?X))

ANIMAL

|= (DEFRELATION FLIES ((?X ANIMAL)))

FLIES

|= (DEFCONCEPT BIRD (?X ANIMAL))

BIRD

|= (PRESUME (FORALL (?X) (=> (BIRD ?X) (FLIES ?X))))

(forall (?x1)
   (<= (FLIES ?x1)
       (BIRD ?x1)))

|= (DEFCONCEPT PENGUIN (?X BIRD) :=> (NOT (FLIES ?X)))

PENGUIN

|= (DEFCONCEPT COLOR (?X))

COLOR

|= (DEFRELATION COLOR-OF ((?X ANIMAL) (?C COLOR)))

COLOR-OF

|= (ASSERT (COLOR BROWN))

(COLOR BROWN)

|= (ASSERT (COLOR GREY))

(COLOR GREY)

|= (PRESUME (FORALL (?X) (<<= (COLOR-OF ?X BROWN) (ANIMAL ?X))))

(forall (?x)
   (<= (COLOR-OF ?x BROWN)
       (ANIMAL ?x)))

|= (PRESUME (FORALL (?X) (<<= (COLOR-OF ?X GREY) (FLIES ?X))))

(forall (?x)
   (<= (COLOR-OF ?x GREY)
       (FLIES ?x)))

|= (ASSERT (ANIMAL FIDO))

(ANIMAL FIDO)

|= (ASSERT (BIRD TWEETY))

(BIRD TWEETY)

|= (ASSERT (PENGUIN OPUS))

(PENGUIN OPUS)

|= (RETRIEVE ALL (?X ?Y) (AND (ANIMAL ?X) (COLOR-OF ?X ?Y)))

((TWEETY GREY)
 (FIDO BROWN)
 (TWEETY BROWN)
 (OPUS BROWN))


|= (RETRIEVE ALL (?X ?Y) (AND (ANIMAL ?X) (COLOR-OF ?X ?Y)))

((TWEETY GREY)
 (FIDO BROWN)
 (TWEETY BROWN)
 (OPUS BROWN))


|= 

Finished testing file `defaults2.plm'.

Now testing file `definition-syntax.plm':

|= (IN-PACKAGE "STELLA")


|= (DEFMODULE "PL-USER/DEFINITION-SYNTAX")

/PL-KERNEL-KB/PL-USER/DEFINITION-SYNTAX

|= (IN-MODULE "DEFINITION-SYNTAX")


|= (CLEAR-MODULE "DEFINITION-SYNTAX")


|= (DEFCONCEPT A)

A

|= (DEFCONCEPT A ())

A

|= (DEFCONCEPT A (()))

A

|= (DEFCONCEPT A (?X))

A

|= (DEFCONCEPT A ((?X)))

A

|= (DEFCONCEPT A (?X B))

A

|= (DEFCONCEPT A ((?X B)))

A

|= (DEFCONCEPT A (B))

A

|= (DEFCONCEPT A ((B)))

A

|= (DEFCONCEPT A (?X B C))

A

|= (DEFCONCEPT A ((?X B C)))

A

|= (DEFCONCEPT A (?X B C D))

A

|= (DEFCONCEPT A (?X B C D) :<=> (E ?X))

A

|= (DEFCONCEPT A ((?X B C D)))

A

|= (DEFCONCEPT A (B C D))

A

|= (DEFCONCEPT A (B C D) :<=> (E ?SELF))

A

|= (DEFCONCEPT B)

B

|= (DEFCONCEPT C)

C

|= (DEFCONCEPT D)

D

|= (DEFCONCEPT E)

E

|= (DEFCONCEPT A :<=> (E ?SELF))

A

|= 

Finished testing file `definition-syntax.plm'.

Now testing file `meta-relations.plm':

|= (IN-PACKAGE "STELLA")


|= (DEFMODULE "PL-USER/META-RELATIONS")

/PL-KERNEL-KB/PL-USER/META-RELATIONS

|= (IN-MODULE "META-RELATIONS")


|= (CLEAR-MODULE "META-RELATIONS")


|= (DEFRELATION FOO (?X ?Y))

FOO

|= (ASSERT (REFLEXIVE FOO))

(REFLEXIVE FOO)

|= (ASK (FOO A A))

TRUE

|= (ASK (IRREFLEXIVE FOO))

FALSE

|= (ASK (NOT (IRREFLEXIVE FOO)))

TRUE

|= (ASSERT (FOO A B))

(FOO A B)

|= (ASK (FOO B A))

UNKNOWN

|= (ASSERT (SYMMETRIC FOO))

(SYMMETRIC FOO)

|= (ASK (FOO B A))

TRUE

|= (ASK (COMMUTATIVE FOO))

TRUE

|= (ASK (ANTISYMMETRIC FOO))

FALSE

|= (ASK (NOT (ANTISYMMETRIC FOO)))

TRUE

|= (DEFRELATION FOO2 (?X ?Y))

FOO2

|= (ASSERT (IRREFLEXIVE FOO2))

(IRREFLEXIVE FOO2)

|= (ASK (FOO2 A A))

FALSE

|= (ASK (NOT (FOO2 A A)))

TRUE

|= (ASSERT (ANTISYMMETRIC FOO2))

(ANTISYMMETRIC FOO2)

|= (ASSERT (FOO2 A B))

(FOO2 A B)

|= (ASK (FOO2 B A))

FALSE

|= (ASK (NOT (FOO2 B A)))

TRUE

|= (DEFRELATION FOO3 (?X ?Y))

FOO3

|= (ASSERT (FOO3 A B))

(FOO3 A B)

|= (ASSERT (FOO3 B C))

(FOO3 B C)

|= (ASK (FOO3 A C))

UNKNOWN

|= (ASSERT (TRANSITIVE FOO3))

(TRANSITIVE FOO3)

|= (ASK (FOO3 A C))

TRUE

|= (DEFRELATION FOO4 (?X ?Y))

FOO4

|= (ASSERT (FOO4 A B))

(FOO4 A B)

|= (ASK (FOO4 B A))

UNKNOWN

|= (ASSERT (COMMUTATIVE FOO4))

(COMMUTATIVE FOO4)

|= (ASK (FOO4 B A))

UNKNOWN

|= (ASSERT (BINARY-RELATION FOO4))

(BINARY-RELATION FOO4)

|= (ASK (FOO4 B A))

TRUE

|= (ASK (SYMMETRIC FOO4))

TRUE

|= (ASK (FOO4 B A))

TRUE

|= (DEFRELATION PARENT (?X ?Y))

PARENT

|= (DEFRELATION CHILD (?X ?Y) :AXIOMS (INVERSE CHILD PARENT))

CHILD

|= (ASSERT (PARENT FRED FATHER))

(PARENT FRED FATHER)

|= (ASK (CHILD FATHER FRED))

TRUE

|= 

Finished testing file `meta-relations.plm'.

Now testing file `partial-match.plm':

|= (IN-PACKAGE "STELLA")


|= (DEFMODULE "/PL-KERNEL/PL-USER/PARTIAL-MATCH")

/PL-KERNEL-KB/PL-USER/PARTIAL-MATCH

|= (IN-MODULE "/PL-KERNEL/PL-USER/PARTIAL-MATCH")


|= (RESET-FEATURES)

|l|(:JUST-IN-TIME-INFERENCE :EMIT-THINKING-DOTS)

|= (IN-DIALECT KIF)

:KIF

|= (SET-PARTIAL-MATCH-MODE :BASIC)


|= (DEFCONCEPT PERSON (?P THING))

PERSON

|= (DEFRELATION HAPPY ((?P PERSON)))

HAPPY

|= (DEFRELATION MARRIED ((?P PERSON)))

MARRIED

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (PERSON MARY))

(PERSON MARY)

|= (ASSERT (PERSON CLYDE))

(PERSON CLYDE)

|= (ASSERT (PERSON ALICE))

(PERSON ALICE)

|= (ASSERT (HAPPY FRED))

(HAPPY FRED)

|= (ASSERT (HAPPY MARY))

(HAPPY MARY)

|= (ASSERT (MARRIED MARY))

(MARRIED MARY)

|= (ASSERT (MARRIED CLYDE))

(MARRIED CLYDE)

|= (RETRIEVE ALL (?X PERSON) (AND (HAPPY ?X) (MARRIED ?X)))

(MARY)


|= (RETRIEVE-PARTIAL ALL (?X PERSON) (AND (HAPPY ?X) (MARRIED ?X)))

((MARY 1.0)
 (FRED 0.5)
 (CLYDE 0.5))


|= (RETRIEVE-PARTIAL BEST (?X PERSON) (AND (HAPPY ?X) (MARRIED ?X)))

((MARY 1.0)
 (FRED 0.5)
 (CLYDE 0.5))


|= (RETRIEVE-PARTIAL BEST (?X PERSON) (OR (HAPPY ?X) (MARRIED ?X)))

((CLYDE 1.0)
 (MARY 1.0)
 (FRED 1.0))


|= (DEFRELATION HAPPILY-MARRIED ((?P PERSON)))

HAPPILY-MARRIED

|= (ASSERT (FORALL (?X PERSON) (=> (AND (HAPPY ?X) (MARRIED ?X)) (HAPPILY-MARRIED ?X))))

(forall (?x)
   (<= (HAPPILY-MARRIED ?x)
       (and (HAPPY ?x)
            (MARRIED ?x))))

|= (RETRIEVE-PARTIAL BEST (?X PERSON) (HAPPILY-MARRIED ?X))

((MARY 1.0)
 (FRED 0.5)
 (CLYDE 0.5))


|= 

Finished testing file `partial-match.plm'.

Now testing file `probability-learning.plm':

|= (IN-PACKAGE "STELLA")


|= (DEFMODULE "/PL-KERNEL/PL-USER/LEARNING")

/PL-KERNEL-KB/PL-USER/LEARNING

|= (IN-MODULE "/PL-KERNEL/PL-USER/LEARNING")


|= (RESET-FEATURES)

|l|(:JUST-IN-TIME-INFERENCE :EMIT-THINKING-DOTS)

|= (IN-DIALECT KIF)

:KIF

|= (SET-PARTIAL-MATCH-MODE :BASIC)


|= (DEFCONCEPT PERSON (?P THING))

PERSON

|= (DEFCONCEPT GENE (?G THING))

GENE

|= (DEFRELATION PARENT ((?X PERSON) (?Y PERSON)))

PARENT

|= (DEFRELATION GENOTYPE ((?X PERSON) (?Y GENE)))

GENOTYPE

|= (ASSERT (PERSON MARY))

(PERSON MARY)

|= (ASSERT (PERSON JOE))

(PERSON JOE)

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (PERSON MARTHA))

(PERSON MARTHA)

|= (ASSERT (GENE RED-HAIR))

(GENE RED-HAIR)

|= (ASSERT (PARENT MARY JOE))

(PARENT MARY JOE)

|= (ASSERT (PARENT MARY FRED))

(PARENT MARY FRED)

|= (ASSERT (PARENT MARY MARTHA))

(PARENT MARY MARTHA)

|= (ASSERT (GENOTYPE MARY RED-HAIR))

(GENOTYPE MARY RED-HAIR)

|= (ASSERT (FORALL ((?X PERSON) (?Y PERSON) (?G GENE)) (=> (AND (PARENT ?X ?Y) (GENOTYPE ?X ?G)) (GENOTYPE ?Y ?G))))

(forall (?x ?y ?g)
   (<= (GENOTYPE ?y ?g)
       (and (PARENT ?x ?y)
            (GENOTYPE ?x ?g))))

|= (ASK-PARTIAL (GENOTYPE JOE RED-HAIR))

1.0

|= (ADD-TRAINING-EXAMPLE (GENOTYPE JOE RED-HAIR) 0.33)


|= (SET-PARTIAL-MATCH-MODE :NN)


|= (TRAIN-NEURAL-NETWORK 100 1)

Training Networks
Saving networks
Cycle 0 Error: 0.1669701156599589
Cycle 25 Error: 0.06405564119627577
Cycle 50 Error: 2.0671998588550622e-4
Cycle 75 Error: 0.00459907518047481

|= (ASK-PARTIAL (GENOTYPE JOE RED-HAIR))

0.32937735861626877

|= (ASK-PARTIAL (GENOTYPE FRED RED-HAIR))

0.32937735861626877

|= (CLEAR-TRAINING-EXAMPLES)


|= (CLEAR-ALL-NEURAL-NETWORKS)


|= (ASK-PARTIAL (GENOTYPE JOE RED-HAIR))

0.5012190399133464

|= (ADD-TRAINING-EXAMPLE (GENOTYPE JOE RED-HAIR) 0.0)


|= (ADD-TRAINING-EXAMPLE (GENOTYPE FRED RED-HAIR) 1.0)


|= (ADD-TRAINING-EXAMPLE (GENOTYPE MARTHA RED-HAIR) 0.0)


|= (TRAIN-NEURAL-NETWORK 100 3)

Training Networks
Saving networks
Cycle 0 Error: 0.500495692573171
Cycle 25 Error: 0.44590958815345316
Cycle 50 Error: 0.44535564927044075
Cycle 75 Error: 0.44950845302413756

|= (ASSERT (PERSON SUE))

(PERSON SUE)

|= (ASSERT (PARENT MARY SUE))

(PARENT MARY SUE)

|= (ASK-PARTIAL (GENOTYPE SUE RED-HAIR))

0.3343855109694957

|= 

Finished testing file `probability-learning.plm'.

Now testing file `test-suite.plm':

|= (IN-PACKAGE "STELLA")


|= (DEFMODULE "PL-KERNEL/PL-USER/TEST")

/PL-KERNEL-KB/PL-USER/TEST

|= (IN-MODULE "TEST")


|= (IN-DIALECT :KIF)

:KIF

|= (RESET-FEATURES)

|l|(:JUST-IN-TIME-INFERENCE :EMIT-THINKING-DOTS)

|= (CLEAR-MODULE "TEST")


|= (CONCEIVE (NOT (= 5 6)))

TRUE

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON (?P) :DOCUMENTATION "The class of PERSON beings.")

PERSON

|= (DEFRELATION HAPPY ((?P PERSON)))

HAPPY

|= (DEFFUNCTION AGE ((?P PERSON)) :-> (?AGE INTEGER))

AGE

|= (DEFFUNCTION FATHER ((?P PERSON)) :-> (?F PERSON))

FATHER

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (EXISTS (?X PERSON) (= (FATHER FRED) ?X)))

((exists (sk153)
   (PERSON sk153)) (exists (sk153)
   (= (FATHER FRED) sk153)))

|= (RETRIEVE ALL ?X (PERSON ?X))

(sk153 FRED)


|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON (?P))

PERSON

|= (DEFCONCEPT DOG (?D) :=> (EXISTS (?P PERSON) (OWNER ?D ?P)))

DOG

|= (DEFFUNCTION OWNER ((?D DOG)) :-> (?O PERSON))

OWNER

|= (DEFRELATION LOVES ((?P PERSON) (?D DOG)))

LOVES

|= (ASSERT (FORALL (?D DOG) (EXISTS (?P PERSON) (LOVES ?P ?D))))

(forall (?d)
   (<= (exists (?p)
          (LOVES ?p ?d))
       (DOG ?d)))

|= (ASSERT (DOG REX))

(DOG REX)

|= (RETRIEVE ALL (?X PERSON) (OWNER REX ?X))

((OWNER REX))


|= (RETRIEVE ALL (?X PERSON) (LOVES ?X REX))

(sk157)


|= (RETRIEVE ALL (?X PERSON))

(sk157 (OWNER REX))


|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT BRIDGE (?B))

BRIDGE

|= (DEFCONCEPT BRIDGE-WORKAROUND (?BW) :=> (EXISTS (?B BRIDGE) (BRIDGE-OF ?BW ?B)))

BRIDGE-WORKAROUND

|= (DEFFUNCTION BRIDGE-OF ((?BW BRIDGE-WORKAROUND)) :-> (?B BRIDGE))

BRIDGE-OF

|= (ASSERT (BRIDGE-WORKAROUND BWA1))

(BRIDGE-WORKAROUND BWA1)

|= (RETRIEVE (?X BRIDGE) (BRIDGE-OF BWA1 ?X))

((BRIDGE-OF BWA1))


|= (RETRIEVE (?X BRIDGE))

((BRIDGE-OF BWA1))


|= (RETRACT (BRIDGE-WORKAROUND BWA1))

(BRIDGE-WORKAROUND BWA1)

|= (RETRIEVE (?X BRIDGE) (BRIDGE-OF BWA1 ?X))

WARNING: Type check violation on argument `@BWA1' in proposition
   (= (BRIDGE-OF BWA1) ?x).
   Argument must have type `BRIDGE-WORKAROUND'.
   Warning occurred while parsing the proposition: 
   (KAPPA ((ISA ?X @BRIDGE)) (BRIDGE-OF @BWA1 ?X))
()


|= (RETRIEVE (?X BRIDGE))

()


|= (PROPAGATE-CONSTRAINTS)


|= (ASSERT (BRIDGE-WORKAROUND BWA1))

(BRIDGE-WORKAROUND BWA1)

|= (RETRIEVE (?X BRIDGE) (BRIDGE-OF BWA1 ?X))

((BRIDGE-OF BWA1))


|= (RETRIEVE (?X BRIDGE))

((BRIDGE-OF BWA1))


|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT BRIDGE (?B))

BRIDGE

|= (ASK (SUBSET-OF BRIDGE THING))

TRUE

|= (ASK (SUBSET-OF THING BRIDGE))

UNKNOWN

|= (ASK (NOT (SUBSET-OF BRIDGE THING)))

UNKNOWN

|= (ASK (NOT (SUBSET-OF THING BRIDGE)))

UNKNOWN

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT ANIMAL (?A) :AXIOMS (ABSTRACT ANIMAL))

ANIMAL

|= (DEFCONCEPT PERSON (?P ANIMAL))

PERSON

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASK (ANIMAL FRED))

TRUE

|= (ASK (NOT (ANIMAL FRED)))

FALSE

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT BOAT (?B))

BOAT

|= (DEFFUNCTION MAX-CURRENT ((?B BOAT)) :-> (?MC FLOAT))

MAX-CURRENT

|= (DEFCONCEPT RIVER (?R))

RIVER

|= (DEFFUNCTION CURRENT ((?R RIVER)) :-> (?C FLOAT))

CURRENT

|= (DEFRELATION CURRENT-TOO-STRONG ((?X BOAT) (?Y RIVER)) :<=> (> (CURRENT ?Y) (MAX-CURRENT ?X)))

CURRENT-TOO-STRONG

|= (ASSERT (RIVER NILE))

(RIVER NILE)

|= (ASSERT (BOAT RAFT1))

(BOAT RAFT1)

|= (ASSERT (MAX-CURRENT RAFT1 3.0))

(= (MAX-CURRENT RAFT1) 3.0)

|= (ASSERT (CURRENT NILE 2.0))

(= (CURRENT NILE) 2.0)

|= (ASK (CURRENT-TOO-STRONG RAFT1 NILE))

UNKNOWN

|= (ASK (NOT (CURRENT-TOO-STRONG RAFT1 NILE)))

UNKNOWN

|= (DEFRELATION CURRENT-TOO-STRONG2 ((?X BOAT) (?Y RIVER)))

CURRENT-TOO-STRONG2

|= (ASSERT (FORALL ((?X BOAT) (?Y RIVER)) (=> (NOT (> (CURRENT ?Y) (MAX-CURRENT ?X))) (NOT (CURRENT-TOO-STRONG2 ?X ?Y)))))

(forall (?x ?y)
   (<= (not (CURRENT-TOO-STRONG2 ?x ?y))
       (exists (?v16 ?v17)
          (and (= (CURRENT ?y) ?v16)
               (= (MAX-CURRENT ?x) ?v17)
               (not (> ?v16 ?v17))))))

|= (ASSERT (FORALL ((?X BOAT) (?Y RIVER)) (=> (NOT (CURRENT-TOO-STRONG2 ?X ?Y)) (NOT (> (CURRENT ?Y) (MAX-CURRENT ?X))))))

(forall (?x ?y)
   (<= (exists (?v16 ?v17)
          (and (= (CURRENT ?y) ?v16)
               (= (MAX-CURRENT ?x) ?v17)
               (not (> ?v16 ?v17))))
       (not (CURRENT-TOO-STRONG2 ?x ?y))))

|= (ASK (CURRENT-TOO-STRONG2 RAFT1 NILE))

UNKNOWN

|= (ASK (NOT (CURRENT-TOO-STRONG2 RAFT1 NILE)))

TRUE

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON (?P) :DOCUMENTATION "The class of PERSON beings.")

PERSON

|= (DEFRELATION HAPPY ((?P PERSON)))

HAPPY

|= (DEFRELATION MARRIED ((?P PERSON)))

MARRIED

|= (ASSERT (FORALL (?X PERSON) (=> (MARRIED ?X) (HAPPY ?X))))

(forall (?x)
   (<= (HAPPY ?x)
       (MARRIED ?x)))

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASK (OR (NOT (MARRIED FRED)) (HAPPY FRED)))

UNKNOWN

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON (?P) :DOCUMENTATION "The class of PERSON beings.")

PERSON

|= (DEFRELATION HAPPY ((?P PERSON)))

HAPPY

|= (DEFRELATION RICH ((?P PERSON)))

RICH

|= (DEFRELATION MARRIED ((?P PERSON)))

MARRIED

|= (ASSERT (FORALL (?X PERSON) (=> (OR (RICH ?X) (AND (MARRIED ?X) (NOT (RICH ?X)))) (HAPPY ?X))))

(forall (?x)
   (<= (HAPPY ?x)
       (or (RICH ?x)
           (and (MARRIED ?x)
                (not (RICH ?x))))))

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (MARRIED FRED))

(MARRIED FRED)

|= (ASK (HAPPY FRED))

UNKNOWN

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PARTIALLY-TANGIBLE (?PT))

PARTIALLY-TANGIBLE

|= (DEFRELATION BETWEEN ((?A PARTIALLY-TANGIBLE) (?B PARTIALLY-TANGIBLE) (?C PARTIALLY-TANGIBLE)))

BETWEEN

|= (DEFRULE COMMUTATIVE-BETWEEN (FORALL ((?A PARTIALLY-TANGIBLE) (?B PARTIALLY-TANGIBLE) (?C PARTIALLY-TANGIBLE)) (=> (BETWEEN ?A ?B ?C) (BETWEEN ?A ?C ?B))))

(forall (?a ?b ?c)
   (<= (BETWEEN ?a ?c ?b)
       (BETWEEN ?a ?b ?c)))

|= (DEFRULE TRANSITIVE-BETWEEN (FORALL ((?A PARTIALLY-TANGIBLE) (?B PARTIALLY-TANGIBLE) (?C PARTIALLY-TANGIBLE) (?D PARTIALLY-TANGIBLE)) (=> (AND (BETWEEN ?A ?D ?C) (BETWEEN ?B ?A ?C)) (BETWEEN ?A ?D ?B))))

(forall (?a ?b ?c ?d)
   (<= (BETWEEN ?a ?d ?b)
       (and (BETWEEN ?a ?d ?c)
            (BETWEEN ?b ?a ?c))))

|= (ASSERT (PARTIALLY-TANGIBLE CITY1))

(PARTIALLY-TANGIBLE CITY1)

|= (ASSERT (PARTIALLY-TANGIBLE CITY2))

(PARTIALLY-TANGIBLE CITY2)

|= (ASSERT (PARTIALLY-TANGIBLE CITY3))

(PARTIALLY-TANGIBLE CITY3)

|= (ASSERT (PARTIALLY-TANGIBLE CITY4))

(PARTIALLY-TANGIBLE CITY4)

|= (ASK (BETWEEN CITY1 CITY2 CITY3))

UNKNOWN

|= (ASSERT (BETWEEN CITY1 CITY3 CITY2))

(BETWEEN CITY1 CITY3 CITY2)

|= (ASK (BETWEEN CITY1 CITY2 CITY3))

TRUE

|= (ASSERT (BETWEEN CITY4 CITY3 CITY1))

(BETWEEN CITY4 CITY3 CITY1)

|= (ASK (BETWEEN CITY1 CITY4 CITY2))

TRUE

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON (?P))

PERSON

|= (DEFRELATION NOBEL-PRIZE-WINNER ((?P PERSON)))

NOBEL-PRIZE-WINNER

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (PERSON EINSTEIN))

(PERSON EINSTEIN)

|= (ASSERT (NOBEL-PRIZE-WINNER EINSTEIN))

(NOBEL-PRIZE-WINNER EINSTEIN)

|= (ASK (NOT (NOBEL-PRIZE-WINNER FRED)))

UNKNOWN

|= (ASK (NOT (NOBEL-PRIZE-WINNER EINSTEIN)))

FALSE

|= (ASSERT (CLOSED NOBEL-PRIZE-WINNER))

(CLOSED NOBEL-PRIZE-WINNER)

|= (ASK (NOT (NOBEL-PRIZE-WINNER FRED)))

TRUE

|= (ASK (NOT (NOBEL-PRIZE-WINNER EINSTEIN)))

FALSE

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON (?P))

PERSON

|= (DEFFUNCTION NOF-BROTHERS ((?P PERSON)) :-> (?N INTEGER))

NOF-BROTHERS

|= (DEFFUNCTION NOF-SISTERS ((?P PERSON)) :-> (?N INTEGER))

NOF-SISTERS

|= (DEFRELATION BALANCED-SIBLINGS ((?P PERSON)))

BALANCED-SIBLINGS

|= (ASSERT (FORALL (?X PERSON) (=> (BALANCED-SIBLINGS ?X) (= (NOF-BROTHERS ?X) (NOF-SISTERS ?X)))))

(forall (?x)
   (<= (exists (?v17)
          (and (= (NOF-BROTHERS ?x) ?v17)
               (= (NOF-SISTERS ?x) ?v17)))
       (BALANCED-SIBLINGS ?x)))

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (BALANCED-SIBLINGS FRED))

(BALANCED-SIBLINGS FRED)

|= (RETRIEVE (?X INTEGER) (= (NOF-BROTHERS FRED) ?X))

((NOF-SISTERS FRED))


|= (RETRIEVE (?X INTEGER) (= (NOF-SISTERS FRED) ?X))

((NOF-SISTERS FRED))


|= (ASSERT (= (NOF-BROTHERS FRED) 5))

(= (NOF-BROTHERS FRED) 5)

|= (RETRIEVE (?X INTEGER) (= (NOF-SISTERS FRED) ?X))

(5)


|= (RETRIEVE (?X INTEGER) (= (NOF-BROTHERS FRED) ?X))

(5)


|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON (?P))

PERSON

|= (DEFFUNCTION HEIGHT ((?P PERSON)) :-> (?H FLOAT))

HEIGHT

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (> (HEIGHT FRED) 20.0))

(> (HEIGHT FRED) 20.0)

|= (ASSERT (PERSON JOE))

(PERSON JOE)

|= (ASSERT (< (HEIGHT JOE) 20.0))

(< (HEIGHT JOE) 20.0)

|= (ASK (< 20.0 (HEIGHT FRED)))

TRUE

|= (ASK (> 20.0 (HEIGHT JOE)))

TRUE

|= (DEFCONCEPT AVLB (?AVLB) :=> (< (TRAFFIC-CLASS ?AVLB) 17))

AVLB

|= (DEFFUNCTION TRAFFIC-CLASS ((?AVLB AVLB)) :-> (?I INTEGER))

TRAFFIC-CLASS

|= (ASSERT (AVLB B1))

(AVLB B1)

|= (ASK (< (TRAFFIC-CLASS B1) 17))

TRUE

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT ANIMAL (?A))

ANIMAL

|= (DEFCONCEPT PERSON (?P))

PERSON

|= (DEFFUNCTION LOVED-BY ((?A ANIMAL)) :-> (?P PERSON))

LOVED-BY

|= (DEFCONCEPT DOG (?D ANIMAL))

DOG

|= (DEFCONCEPT CAT (?C ANIMAL))

CAT

|= (DEFRELATION LOVES ((?P PERSON) (?A ANIMAL)))

LOVES

|= (DEFRULE CAT-LOVER-RULE (FORALL ((?P PERSON) (?C CAT)) (=> (AND (CAT ?C) (LOVES ?P ?C)) (= (LOVED-BY ?C) ?P))))

(forall (?p ?c)
   (<= (= (LOVED-BY ?c) ?p)
       (LOVES ?p ?c)))

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (DOG FIDO))

(DOG FIDO)

|= (ASSERT (CAT GARFIELD))

(CAT GARFIELD)

|= (ASSERT (LOVES FRED GARFIELD))

(LOVES FRED GARFIELD)

|= (ASK (LOVED-BY FIDO FRED))

UNKNOWN

|= (ASK (LOVED-BY GARFIELD FRED))

TRUE

|= (PROPAGATE-CONSTRAINTS)


|= (ASK (LOVED-BY FIDO FRED))

UNKNOWN

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT A)

A

|= (DEFRELATION R1 ((?A1 A) (?A2 A)))

R1

|= (DEFRELATION R2 ((?A1 A) (?A2 A)))

R2

|= (ASSERT (FORALL ((?A1 A) (?A2 A)) (=> (R2 ?A1 ?A2) (R2 ?A2 ?A1))))

(forall (?a1 ?a2)
   (<= (R2 ?a2 ?a1)
       (R2 ?a1 ?a2)))

|= (ASSERT (A A1))

(A A1)

|= (ASSERT (A A2))

(A A2)

|= (ASSERT (R2 A1 A2))

(R2 A1 A2)

|= (ASK (OR (R1 A2 A1) (R2 A2 A1)))

TRUE

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON (?P))

PERSON

|= (DEFFUNCTION BOSS ((?P PERSON)) :-> (?F PERSON))

BOSS

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (PERSON JOHN))

(PERSON JOHN)

|= (ASSERT (PERSON SUSI))

(PERSON SUSI)

|= (ASSERT (PERSON OTTO))

(PERSON OTTO)

|= (ASSERT (= (BOSS FRED) OTTO))

(= (BOSS FRED) OTTO)

|= (ASSERT (= (BOSS JOHN) OTTO))

(= (BOSS JOHN) OTTO)

|= (ASSERT (= (BOSS OTTO) SUSI))

(= (BOSS OTTO) SUSI)

|= (RETRIEVE ALL (?X PERSON) (= (BOSS ?X) OTTO))

(JOHN FRED)


|= (RETRIEVE ALL ((?X PERSON) (?Y PERSON)) (= (BOSS ?X) ?Y))

((OTTO SUSI)
 (JOHN OTTO)
 (FRED OTTO))


|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT HOUSE (?H))

HOUSE

|= (DEFCONCEPT PERSON (?P))

PERSON

|= (DEFRELATION CRAZY ((?P PERSON)))

CRAZY

|= (DEFFUNCTION LIVES-IN ((?P PERSON)) :-> (?F HOUSE))

LIVES-IN

|= (DEFCONCEPT NUTHOUSE (?H HOUSE))

NUTHOUSE

|= (DEFRULE NUTHOUSE-RULE (FORALL (?H HOUSE) (=> (FORALL (?P PERSON) (=> (LIVES-IN ?P ?H) (CRAZY ?P))) (NUTHOUSE ?H))))

(forall (?h)
   (<= (NUTHOUSE ?h)
       (forall (?p)
          (<= (CRAZY ?p)
              (= (LIVES-IN ?p) ?h)))))

|= (ASSERT (CLOSED PERSON))

(CLOSED PERSON)

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (PERSON MARY))

(PERSON MARY)

|= (ASSERT (NOT (CRAZY FRED)))

(not (CRAZY FRED))

|= (ASSERT (CRAZY MARY))

(CRAZY MARY)

|= (ASSERT (HOUSE H1))

(HOUSE H1)

|= (ASSERT (LIVES-IN FRED H1))

(= (LIVES-IN FRED) H1)

|= (ASSERT (LIVES-IN MARY H1))

(= (LIVES-IN MARY) H1)

|= (ASK (NUTHOUSE H1))

UNKNOWN

|= (RETRACT (NOT (CRAZY FRED)))

(CRAZY FRED)

|= (ASSERT (CRAZY FRED))

(CRAZY FRED)

|= (ASK (NUTHOUSE H1))

TRUE

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON (?P))

PERSON

|= (DEFRELATION HAPPY ((?P PERSON)))

HAPPY

|= (DEFRELATION RICH ((?P PERSON)))

RICH

|= (DEFRELATION SIBLING ((?X PERSON) (?Y PERSON)))

SIBLING

|= (ASSERT (FORALL (?X PERSON) (=> (HAPPY ?X) (EXISTS (?Y PERSON) (SIBLING ?X ?Y)))))

(forall (?x)
   (<= (exists (?y)
          (SIBLING ?x ?y))
       (HAPPY ?x)))

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASK (OR (RICH FRED) (NOT (HAPPY FRED))))

UNKNOWN

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON (?P))

PERSON

|= (DEFFUNCTION AGE ((?P PERSON)) :-> (?AGE INTEGER))

AGE

|= (DEFFUNCTION GOLF-HANDICAP ((?P PERSON)) :-> (?AGE INTEGER))

GOLF-HANDICAP

|= (DEFFUNCTION SON ((?P PERSON)) :-> (?F PERSON))

SON

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (PERSON JOE))

(PERSON JOE)

|= (ASSERT (= (SON FRED) JOE))

(= (SON FRED) JOE)

|= (ASSERT (= (AGE JOE) 12))

(= (AGE JOE) 12)

|= (ASSERT (= (GOLF-HANDICAP FRED) (AGE (SON FRED))))

(= (GOLF-HANDICAP FRED) (AGE (SON FRED)))

|= (PROPAGATE-CONSTRAINTS)


|= (RETRIEVE ALL (?X INTEGER) (= (GOLF-HANDICAP FRED) ?X))

(12)


|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON (?P))

PERSON

|= (DEFFUNCTION AGE ((?P PERSON)) :-> (?AGE INTEGER))

AGE

|= (DEFFUNCTION GOLF-HANDICAP ((?P PERSON)) :-> (?AGE INTEGER))

GOLF-HANDICAP

|= (DEFFUNCTION SON ((?P PERSON)) :-> (?F PERSON))

SON

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (PERSON JOE))

(PERSON JOE)

|= (ASSERT (= (AGE JOE) 12))

(= (AGE JOE) 12)

|= (ASSERT (= (GOLF-HANDICAP FRED) (AGE (SON FRED))))

(= (GOLF-HANDICAP FRED) (AGE (SON FRED)))

|= (ASSERT (= (SON FRED) JOE))

(= (SON FRED) JOE)

|= (PROPAGATE-CONSTRAINTS)


|= (RETRIEVE ALL (?X INTEGER) (= (GOLF-HANDICAP FRED) ?X))

(12)


|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON (?P))

PERSON

|= (DEFFUNCTION AGE ((?P PERSON)) :-> (?AGE INTEGER))

AGE

|= (DEFFUNCTION GOLF-HANDICAP ((?P PERSON)) :-> (?AGE INTEGER))

GOLF-HANDICAP

|= (DEFFUNCTION SON ((?P PERSON)) :-> (?F PERSON))

SON

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (PERSON JOE))

(PERSON JOE)

|= (ASSERT (= (GOLF-HANDICAP FRED) (AGE (SON FRED))))

(= (GOLF-HANDICAP FRED) (AGE (SON FRED)))

|= (ASSERT (= (AGE JOE) 12))

(= (AGE JOE) 12)

|= (ASSERT (= (SON FRED) JOE))

(= (SON FRED) JOE)

|= (PROPAGATE-CONSTRAINTS)


|= (RETRIEVE ALL (?X INTEGER) (= (GOLF-HANDICAP FRED) ?X))

(12)


|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON (?P))

PERSON

|= (DEFFUNCTION AGE ((?P PERSON)) :-> (?AGE INTEGER))

AGE

|= (DEFFUNCTION GOLF-HANDICAP ((?P PERSON)) :-> (?AGE INTEGER))

GOLF-HANDICAP

|= (DEFFUNCTION SON ((?P PERSON)) :-> (?F PERSON))

SON

|= (ASSERT (AND (PERSON MARY) (= (AGE MARY) 3)))

((PERSON MARY) (= (AGE MARY) 3))

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON (?P))

PERSON

|= (DEFFUNCTION AGE ((?P PERSON)) :-> (?AGE INTEGER))

AGE

|= (DEFFUNCTION GOLF-HANDICAP ((?P PERSON)) :-> (?AGE INTEGER))

GOLF-HANDICAP

|= (DEFFUNCTION SON ((?P PERSON)) :-> (?F PERSON))

SON

|= (DEFRELATION BELIEVES ((?X PERSON) (?Y PROPOSITION)))

BELIEVES

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (PERSON JOE))

(PERSON JOE)

|= (ASSERT (BELIEVES FRED (SON FRED JOE)))

(BELIEVES FRED (= (SON FRED) JOE))

|= (RETRIEVE (?X PROPOSITION) (BELIEVES FRED ?X))

((= (SON FRED) JOE))


|= (RETRIEVE ?X (BELIEVES FRED ?X))

((= (SON FRED) JOE))


|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON (?P))

PERSON

|= (DEFRELATION HAPPY ((?P PERSON)))

HAPPY

|= (DEFRELATION RICH ((?P PERSON)))

RICH

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (FORALL (?X PERSON) (=> (RICH ?X) (HAPPY ?X))))

(forall (?x)
   (<= (HAPPY ?x)
       (RICH ?x)))

|= (ASSERT (RICH FRED))

(RICH FRED)

|= (ASK (HAPPY FRED))

TRUE

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON (?P))

PERSON

|= (DEFRELATION PARENT ((?P1 PERSON) (?P2 PERSON)))

PARENT

|= (DEFRELATION GRANDPARENT ((?P PERSON)))

GRANDPARENT

|= (DEFRELATION RETIRED ((?P PERSON)))

RETIRED

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (NOT (GRANDPARENT FRED)))

(not (GRANDPARENT FRED))

|= (ASSERT (=> (AND (RETIRED ?X) (FAIL (PARENT ?X1 ?X))) (GRANDPARENT ?X)))

(forall (?x ?x1)
   (<= (GRANDPARENT ?x)
       (and (RETIRED ?x)
            (FAIL (PARENT ?x1 ?x)))))

|= (ASSERT (=> (AND (RETIRED ?X) (PARENT ?X1 ?X)) (NOT (GRANDPARENT ?X))))

(forall (?x ?x1)
   (<= (not (GRANDPARENT ?x))
       (and (RETIRED ?x)
            (PARENT ?x1 ?x))))

|= (ASK (NOT (GRANDPARENT FRED)))

TRUE

|= (CLEAR-MODULE "TEST")


|= (SET-FEATURE TRACE-SUBGOALS)

|l|(:TRACE-SUBGOALS :JUST-IN-TIME-INFERENCE :EMIT-THINKING-DOTS)

|= (DEFCONCEPT PERSON (?P))

PERSON

|= (DEFRELATION LOVES ((?X PERSON) (?Y PERSON)))

LOVES

|= (DEFRELATION HATES ((?X PERSON) (?Y PERSON)))

HATES

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (PERSON JOHN))

(PERSON JOHN)

|= (ASSERT (PERSON SUSI))

(PERSON SUSI)

|= (ASSERT (PERSON DEBBIE))

(PERSON DEBBIE)

|= (ASSERT (LOVES FRED SUSI))

(LOVES FRED SUSI)

|= (ASSERT (HATES JOHN DEBBIE))

(HATES JOHN DEBBIE)

|= (RETRIEVE ALL (?X ?Y ?Z ?ZZ) (AND (LOVES ?X ?Y) (LOVES ?Y ?X) (HATES ?Z ?ZZ) (HATES ?ZZ ?Z)))

PATTERN: [F,F,F,F]
| GOAL: (and (LOVES ?x ?y) (LOVES ?y ?x) (HATES ?z ?zz) (HATES ?zz ?z))
| | GOAL: (LOVES ?x ?y)
| | SUCC: ?X=FRED ?Y=SUSI truth=T
| | GOAL: (LOVES ?y/SUSI ?x/FRED)
| | FAIL
| | GOAL: (LOVES ?x ?y)
| | FAIL
| FAIL: truth=U
()


|= (ASSERT (HATES DEBBIE JOHN))

(HATES DEBBIE JOHN)

|= (RETRIEVE ALL (?X ?Y ?Z ?ZZ) (AND (LOVES ?X ?Y) (LOVES ?Y ?X) (HATES ?Z ?ZZ) (HATES ?ZZ ?Z)))

PATTERN: [F,F,F,F]
| GOAL: (and (LOVES ?x ?y) (LOVES ?y ?x) (HATES ?z ?zz) (HATES ?zz ?z))
| | GOAL: (LOVES ?x ?y)
| | SUCC: ?X=FRED ?Y=SUSI truth=T
| | GOAL: (LOVES ?y/SUSI ?x/FRED)
| | FAIL
| | GOAL: (LOVES ?x ?y)
| | FAIL
| FAIL: truth=U
()


|= (ASSERT (LOVES SUSI FRED))

(LOVES SUSI FRED)

|= (RETRIEVE ALL (?X ?Y ?Z ?ZZ) (AND (LOVES ?X ?Y) (LOVES ?Y ?X) (HATES ?Z ?ZZ) (HATES ?ZZ ?Z)))

PATTERN: [F,F,F,F]
| GOAL: (and (LOVES ?x ?y) (LOVES ?y ?x) (HATES ?z ?zz) (HATES ?zz ?z))
| | GOAL: (LOVES ?x ?y)
| | SUCC: ?X=SUSI ?Y=FRED truth=T
| | GOAL: (LOVES ?y/FRED ?x/SUSI)
| | SUCC: ?X=SUSI ?Y=FRED truth=T
| | GOAL: (HATES ?z ?zz)
| | SUCC: ?X=SUSI ?Y=FRED ?Z=DEBBIE ?ZZ=JOHN truth=T
| | GOAL: (HATES ?zz/JOHN ?z/DEBBIE)
| | SUCC: ?X=SUSI ?Y=FRED ?Z=DEBBIE ?ZZ=JOHN truth=T
| SUCC: ?X=SUSI ?Y=FRED ?Z=DEBBIE ?ZZ=JOHN truth=T
PATTERN: [F,F,F,F]
| GOAL: (and (LOVES ?x/SUSI ?y/FRED) (LOVES ?y/FRED ?x/SUSI) (HATES ?z ?zz) (HATES ?zz ?z))
| | GOAL: (HATES ?z ?zz)
| | SUCC: ?X=SUSI ?Y=FRED ?Z=JOHN ?ZZ=DEBBIE truth=T
| | GOAL: (HATES ?zz/DEBBIE ?z/JOHN)
| | SUCC: ?X=SUSI ?Y=FRED ?Z=JOHN ?ZZ=DEBBIE truth=T
| SUCC: ?X=SUSI ?Y=FRED ?Z=JOHN ?ZZ=DEBBIE truth=T
PATTERN: [F,F,F,F]
| GOAL: (and (LOVES ?x/SUSI ?y/FRED) (LOVES ?y/FRED ?x/SUSI) (HATES ?z ?zz) (HATES ?zz ?z))
| | GOAL: (HATES ?z ?zz)
| | FAIL
| | GOAL: (LOVES ?x ?y)
| | SUCC: ?X=FRED ?Y=SUSI truth=T
| | GOAL: (LOVES ?y/SUSI ?x/FRED)
| | SUCC: ?X=FRED ?Y=SUSI truth=T
| | GOAL: (HATES ?z ?zz)
| | SUCC: ?X=FRED ?Y=SUSI ?Z=DEBBIE ?ZZ=JOHN truth=T
| | GOAL: (HATES ?zz/JOHN ?z/DEBBIE)
| | SUCC: ?X=FRED ?Y=SUSI ?Z=DEBBIE ?ZZ=JOHN truth=T
| SUCC: ?X=FRED ?Y=SUSI ?Z=DEBBIE ?ZZ=JOHN truth=T
PATTERN: [F,F,F,F]
| GOAL: (and (LOVES ?x/FRED ?y/SUSI) (LOVES ?y/SUSI ?x/FRED) (HATES ?z ?zz) (HATES ?zz ?z))
| | GOAL: (HATES ?z ?zz)
| | SUCC: ?X=FRED ?Y=SUSI ?Z=JOHN ?ZZ=DEBBIE truth=T
| | GOAL: (HATES ?zz/DEBBIE ?z/JOHN)
| | SUCC: ?X=FRED ?Y=SUSI ?Z=JOHN ?ZZ=DEBBIE truth=T
| SUCC: ?X=FRED ?Y=SUSI ?Z=JOHN ?ZZ=DEBBIE truth=T
PATTERN: [F,F,F,F]
| GOAL: (and (LOVES ?x/FRED ?y/SUSI) (LOVES ?y/SUSI ?x/FRED) (HATES ?z ?zz) (HATES ?zz ?z))
| | GOAL: (HATES ?z ?zz)
| | FAIL
| | GOAL: (LOVES ?x ?y)
| | FAIL
| FAIL: truth=U
((SUSI FRED DEBBIE JOHN)
 (SUSI FRED JOHN DEBBIE)
 (FRED SUSI DEBBIE JOHN)
 (FRED SUSI JOHN DEBBIE))


|= (UNSET-FEATURE TRACE-SUBGOALS)

|l|(:JUST-IN-TIME-INFERENCE :EMIT-THINKING-DOTS)

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PROJECT)

PROJECT

|= (DEFCONCEPT PERSON)

PERSON

|= (DEFCONCEPT RESEARCH-AREA)

RESEARCH-AREA

|= (DEFRELATION WORKS-ON ((?U PERSON) (?L PROJECT)))

WORKS-ON

|= (DEFRELATION TOPIC ((?P PROJECT) (?A THING)))

TOPIC

|= (DEFRELATION RELATED ((?T1 RESEARCH-AREA) (?T2 RESEARCH-AREA)))

RELATED

|= (ASSERT (PROJECT ELECTRIC-ELVES))

(PROJECT ELECTRIC-ELVES)

|= (ASSERT (PROJECT POWERLOOM))

(PROJECT POWERLOOM)

|= (ASSERT (PROJECT SIMS))

(PROJECT SIMS)

|= (ASSERT (TOPIC ELECTRIC-ELVES INTELLIGENT-AGENTS))

(TOPIC ELECTRIC-ELVES INTELLIGENT-AGENTS)

|= (ASSERT (TOPIC POWERLOOM KNOWLEDGE-REPRESENTATION))

(TOPIC POWERLOOM KNOWLEDGE-REPRESENTATION)

|= (ASSERT (TOPIC SIMS AUTOMATED-PLANNING))

(TOPIC SIMS AUTOMATED-PLANNING)

|= (ASSERT (RELATED INTELLIGENT-AGENTS KNOWLEDGE-REPRESENTATION))

(RELATED INTELLIGENT-AGENTS KNOWLEDGE-REPRESENTATION)

|= (ASSERT (RELATED AUTOMATED-PLANNING INTELLIGENT-AGENTS))

(RELATED AUTOMATED-PLANNING INTELLIGENT-AGENTS)

|= (ASSERT (WORKS-ON CRAIG-KNOBLOCK ELECTRIC-ELVES))

(WORKS-ON CRAIG-KNOBLOCK ELECTRIC-ELVES)

|= (ASSERT (WORKS-ON CRAIG-KNOBLOCK SIMS))

(WORKS-ON CRAIG-KNOBLOCK SIMS)

|= (ASSERT (WORKS-ON HANS-CHALUPSKY ELECTRIC-ELVES))

(WORKS-ON HANS-CHALUPSKY ELECTRIC-ELVES)

|= (ASSERT (WORKS-ON HANS-CHALUPSKY POWERLOOM))

(WORKS-ON HANS-CHALUPSKY POWERLOOM)

|= (DEFRELATION OVERLAPPING-INTERESTS ((?VISITOR PERSON) (?VISITOR-INTEREST RESEARCH-AREA) (?STAFF PERSON) (?STAFF-INTEREST RESEARCH-AREA)) :<= (AND (EXISTS (?PROJECT) (AND (WORKS-ON ?VISITOR ?PROJECT) (TOPIC ?PROJECT ?VISITOR-INTEREST))) (EXISTS (?PROJECT) (AND (WORKS-ON ?STAFF ?PROJECT) (TOPIC ?PROJECT ?STAFF-INTEREST))) (OR (RELATED ?VISITOR-INTEREST ?STAFF-INTEREST) (RELATED ?STAFF-INTEREST ?VISITOR-INTEREST))))

OVERLAPPING-INTERESTS

|= (RETRIEVE ALL (?V ?VI ?S ?SI) (OVERLAPPING-INTERESTS ?V ?VI ?S ?SI))

((CRAIG-KNOBLOCK AUTOMATED-PLANNING CRAIG-KNOBLOCK INTELLIGENT-AGENTS)
 (CRAIG-KNOBLOCK AUTOMATED-PLANNING HANS-CHALUPSKY INTELLIGENT-AGENTS)
 (HANS-CHALUPSKY KNOWLEDGE-REPRESENTATION CRAIG-KNOBLOCK INTELLIGENT-AGENTS)
 (HANS-CHALUPSKY KNOWLEDGE-REPRESENTATION HANS-CHALUPSKY INTELLIGENT-AGENTS)
 (CRAIG-KNOBLOCK INTELLIGENT-AGENTS HANS-CHALUPSKY KNOWLEDGE-REPRESENTATION)
 (CRAIG-KNOBLOCK INTELLIGENT-AGENTS CRAIG-KNOBLOCK AUTOMATED-PLANNING)
 (HANS-CHALUPSKY INTELLIGENT-AGENTS HANS-CHALUPSKY KNOWLEDGE-REPRESENTATION)
 (HANS-CHALUPSKY INTELLIGENT-AGENTS CRAIG-KNOBLOCK AUTOMATED-PLANNING))


|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON (?X))

PERSON

|= (DEFRELATION HAPPY ((?X PERSON)))

HAPPY

|= (DEFRELATION RICH ((?X PERSON)))

RICH

|= (ASSERT (FORALL (?X PERSON) (=> (RICH ?X) (HAPPY ?X))))

(forall (?x)
   (<= (HAPPY ?x)
       (RICH ?x)))

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (NOT (HAPPY FRED)))

(not (HAPPY FRED))

|= (RETRIEVE ALL ?X (AND (PERSON ?X) (NOT (RICH ?X))))

(FRED)


|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON (?X))

PERSON

|= (DEFFUNCTION BOSS ((?X PERSON)) :-> (?B PERSON))

BOSS

|= (DEFFUNCTION FATHER ((?X PERSON)) :-> (?F PERSON))

FATHER

|= (DEFFUNCTION MOTHER ((?X PERSON)) :-> (?M PERSON))

MOTHER

|= (DEFRELATION RICH ((?X PERSON)))

RICH

|= (DEFRELATION HAPPY ((?X PERSON)))

HAPPY

|= (ASSERT (FORALL (?X PERSON) (=> (RICH ?X) (HAPPY ?X))))

(forall (?x)
   (<= (HAPPY ?x)
       (RICH ?x)))

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (PERSON FRANK))

(PERSON FRANK)

|= (ASSERT (PERSON SUSI))

(PERSON SUSI)

|= (ASSERT (RICH (FATHER FRANK)))

(RICH (FATHER FRANK))

|= (ASSERT (= (FATHER FRANK) (BOSS FRED)))

(= (FATHER FRANK) (BOSS FRED))

|= (ASK (HAPPY (FATHER FRANK)))

TRUE

|= (ASK (HAPPY (BOSS FRED)))

TRUE

|= (RETRIEVE ALL (?X PERSON) (HAPPY ?X))

((BOSS FRED))


|= (CLEAR-MODULE "TEST")


|= (DEFMODULE "TEST/TEMP-A")

/PL-KERNEL-KB/PL-USER/TEST/TEMP-A

|= (DEFMODULE "TEST/TEMP-B")

/PL-KERNEL-KB/PL-USER/TEST/TEMP-B

|= (DEFCONCEPT PERSON (?X))

PERSON

|= (DEFRELATION PARENT ((?X PERSON) (?Y PERSON)))

PARENT

|= (DEFRELATION CHILD ((?X PERSON) (?Y PERSON)))

CHILD

|= (DEFFUNCTION AGE ((?X PERSON)) :-> (?A INTEGER))

AGE

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (PERSON SUSI))

(PERSON SUSI)

|= (CC "TEST/TEMP-A")

/PL-KERNEL-KB/PL-USER/TEST/TEMP-A

|= (ASSERT (PARENT FRED SUSI))

(PARENT FRED SUSI)

|= (ASSERT (= (AGE FRED) 42))

(= (AGE FRED) 42)

|= (ASSERT (FORALL (?X ?Y) (=> (PARENT ?X ?Y) (CHILD ?Y ?X))))

(forall (?x ?y)
   (<= (CHILD ?y ?x)
       (PARENT ?x ?y)))

|= (CC "TEST/TEMP-B")

/PL-KERNEL-KB/PL-USER/TEST/TEMP-B

|= (ASSERT (PARENT FRED SUSI))

(PARENT FRED SUSI)

|= (ASSERT (= (AGE FRED) 42))

(= (AGE FRED) 42)

|= (ASSERT (FORALL (?X ?Y) (=> (PARENT ?X ?Y) (CHILD ?Y ?X))))

(forall (?x ?y)
   (<= (CHILD ?y ?x)
       (PARENT ?x ?y)))

|= (CLEAR-MODULE "TEST/TEMP-A")


|= (ASK (PARENT FRED SUSI))

TRUE

|= (ASK (= (AGE FRED) 42))

TRUE

|= (ASK (CHILD SUSI FRED))

TRUE

|= (CC TEST)

/PL-KERNEL-KB/PL-USER/TEST

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON (?X))

PERSON

|= (DEFFUNCTION BOSS ((?X PERSON)) :-> (?F PERSON))

BOSS

|= (DEFRELATION EMPLOYEE-OF ((?EMP PERSON) (?BOSS PERSON)))

EMPLOYEE-OF

|= (ASSERT (FORALL (?EMP ?BOSS) (=> (EMPLOYEE-OF ?EMP ?BOSS) (= (BOSS ?EMP) ?BOSS))))

(forall (?x1 ?x2)
   (<= (= (BOSS ?x1) ?x2)
       (EMPLOYEE-OF ?x1 ?x2)))

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (PERSON FRANK))

(PERSON FRANK)

|= (ASSERT (PERSON SUSI))

(PERSON SUSI)

|= (ASSERT (= (BOSS FRED) (BOSS SUSI)))

(= (BOSS FRED) (BOSS SUSI))

|= (ASSERT (EMPLOYEE-OF FRED FRANK))

(EMPLOYEE-OF FRED FRANK)

|= (RETRIEVE ?X (= (BOSS SUSI) ?X))

((BOSS SUSI))


|= (RETRIEVE ?X (= (BOSS FRED) ?X))

((BOSS SUSI))


|= (RETRIEVE ?X (= (BOSS SUSI) ?X))

((BOSS SUSI))


|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON (?X))

PERSON

|= (DEFFUNCTION BOSS ((?X PERSON)) :-> (?F PERSON))

BOSS

|= (DEFRELATION HAS-EMPLOYEE ((?BOSS PERSON) (?EMP PERSON)))

HAS-EMPLOYEE

|= (ASSERT (FORALL (?EMP ?BOSS) (=> (HAS-EMPLOYEE ?BOSS ?EMP) (= (BOSS ?EMP) ?BOSS))))

(forall (?emp ?boss)
   (<= (= (BOSS ?emp) ?boss)
       (HAS-EMPLOYEE ?boss ?emp)))

|= (ASSERT (PERSON FRED))

(PERSON FRED)

|= (ASSERT (PERSON FRANK))

(PERSON FRANK)

|= (ASSERT (PERSON SUSI))

(PERSON SUSI)

|= (ASSERT (= (BOSS FRED) (BOSS SUSI)))

(= (BOSS FRED) (BOSS SUSI))

|= (ASSERT (HAS-EMPLOYEE FRANK FRED))

(HAS-EMPLOYEE FRANK FRED)

|= (RETRIEVE ?X (= (BOSS SUSI) ?X))

((BOSS SUSI))


|= (RETRIEVE ?X (= (BOSS FRED) ?X))

(FRANK)


|= (RETRIEVE ?X (= (BOSS SUSI) ?X))

(FRANK)


|= (CLEAR-MODULE "TEST")


|= (DEFRELATION FOO (?X ?Y))

FOO

|= (ASSERT (SYMMETRIC FOO))

(SYMMETRIC FOO)

|= (ASSERT (REFLEXIVE FOO))

(REFLEXIVE FOO)

|= (ASSERT (FOO A B))

(FOO A B)

|= (ASK (FOO B A))

TRUE

|= (ASK (FOO B B))

TRUE

|= (DEFRELATION FOO2 (?X ?Y))

FOO2

|= (ASSERT (REFLEXIVE FOO2))

(REFLEXIVE FOO2)

|= (ASK (FOO2 A A))

TRUE

|= (ASSERT (SYMMETRIC FOO2))

(SYMMETRIC FOO2)

|= (ASSERT (FOO2 A B))

(FOO2 A B)

|= (ASK (FOO2 B A))

TRUE

|= (CLEAR-MODULE "TEST")


|= (DEFFUNCTION RFN (?X) :-> (?V RELATION))

RFN

|= (DEFFUNCTION FFN (?X) :-> (?V FUNCTION))

FFN

|= (DEFFUNCTION CFN (?X) :-> (?V CLASS))

CFN

|= (ASSERT ((RFN A) B))

((RFN A) B)

|= (ASK (RELATION (RFN A)))

TRUE

|= (ASK (CLASS (RFN A)))

UNKNOWN

|= (ASK (FUNCTION (RFN A)))

UNKNOWN

|= (RETRIEVE ?X (ARITY (RFN A) ?X))

(1)


|= (RETRIEVE ALL ?X ((RFN A) ?X))

(B)


|= (ASSERT ((FFN A) B C))

(= ((FFN A) B) C)

|= (ASK (RELATION (FFN A)))

TRUE

|= (ASK (CLASS (FFN A)))

FALSE

|= (ASK (FUNCTION (FFN A)))

TRUE

|= (RETRIEVE ?X (ARITY (FFN A) ?X))

(2)


|= (RETRIEVE ALL ?X ((FFN A) B ?X))

(C)


|= (ASSERT ((CFN A) B))

((CFN A) B)

|= (ASK (RELATION (CFN A)))

TRUE

|= (ASK (CLASS (CFN A)))

TRUE

|= (ASK (FUNCTION (CFN A)))

FALSE

|= (RETRIEVE ?X (ARITY (CFN A) ?X))

(1)


|= (RETRIEVE ALL ?X ((CFN A) ?X))

(B)


|= (ASSERT (EXISTS (?X) (= (RFN B) ?X)))

(= (RFN B) sk212)

|= (ASK (EXISTS (?X) (= (RFN B) ?X)))

TRUE

|= (ASSERT (HOLDS (RFN B) C))

((RFN B) C)

|= (ASK (EXISTS (?X) (= (RFN B) ?X)))

TRUE

|= (RETRIEVE ALL ?X ((RFN B) ?X))

(C)


|= (ASSERT ((RFN C) D))

((RFN C) D)

|= (RETRIEVE ?X (ARITY (RFN C) ?X))

(1)


|= (ASSERT ((RFN D) E F G))

((RFN D) E F G)

|= (RETRIEVE ?X (ARITY (RFN D) ?X))

(3)


|= (ASSERT ((RFN D) E F))

((RFN D) E F)

|= (RETRIEVE ?X (ARITY (RFN D) ?X))

(3)


|= (ASSERT (FUNCTION (RFN E)))

(FUNCTION (RFN E))

|= (ASSERT (VARIABLE-ARITY (RFN E)))

(VARIABLE-ARITY (RFN E))

|= (ASSERT ((RFN E) F G))

(= ((RFN E) F) G)

|= (ASK (FUNCTION (RFN E)))

TRUE

|= (ASK (VARIABLE-ARITY (RFN E)))

TRUE

|= (RETRIEVE ?X (ARITY (RFN E) ?X))

(-1)


|= (RETRIEVE ALL ?X ((RFN E) F ?X))

(G)


|= (ASSERT ((CFN B) (RFN F)))

((CFN B) (RFN F))

|= (ASSERT ((RFN F) G))

((RFN F) G)

|= (ASK ((CFN B) (RFN F)))

TRUE

|= (ASSERT (FUNCTION (RFN G)))

(FUNCTION (RFN G))

|= (ASSERT (= ((RFN G) H) X))

(= ((RFN G) H) X)

|= (ASSERT ((RFN G) H X))

(= ((RFN G) H) X)

|= (ASSERT (= (VALUE (RFN G) H) X))

(= ((RFN G) H) X)

|= (ASSERT (VALUE (RFN G) H X))

(= ((RFN G) H) X)

|= (ALL-FACTS-OF "X")

((= ((RFN G) H) X) (= ((RFN G) H) X))

|= (ASSERT (= ((FFN G) H) Y))

(= ((FFN G) H) Y)

|= (ASSERT ((FFN G) H Y))

(= ((FFN G) H) Y)

|= (ASSERT (= (VALUE (FFN G) H) Y))

(= ((FFN G) H) Y)

|= (ASSERT (VALUE (FFN G) H Y))

(= ((FFN G) H) Y)

|= (ALL-FACTS-OF "Y")

((= ((FFN G) H) Y) (= ((FFN G) H) Y))

|= (ASSERT (= ((FFN H) I) J))

(= ((FFN H) I) J)

|= (ASSERT (= (VALUE (FFN H) I) J))

(= ((FFN H) I) J)

|= (ASSERT ((FFN I) J ((FFN H) I)))

(= ((FFN I) J) ((FFN H) I))

|= (ASSERT ((FFN I) J (VALUE (FFN H) I)))

(= ((FFN I) J) ((FFN H) I))

|= (RETRIEVE ALL ?X ((FFN I) J ?X))

(J)


|= (ASSERT (FORALL (?X ?Y) (=> ((RFN H) ?X ?Y) ((RFN I) ?Y ?X))))

(forall (?x ?y)
   (<= ((RFN I) ?y ?x)
       ((RFN H) ?x ?y)))

|= (ASSERT ((RFN H) I J))

((RFN H) I J)

|= (ASK ((RFN I) J I))

TRUE

|= (ASSERT (FORALL (?X ?Y) (=> (= ((FFN J) ?X) ?Y) (= ((FFN K) ?Y) ?X))))

(forall (?x ?y)
   (<= (exists (?x)
          (= ((FFN K) ?y) ?x))
       (exists (?y)
          (= ((FFN J) ?x) ?y))))

|= (ASSERT (= ((FFN J) A) B))

(= ((FFN J) A) B)

|= (ASSERT (= ((FFN J) C) D))

(= ((FFN J) C) D)

|= (ASK (= ((FFN K) B) A))

TRUE

|= (RETRIEVE ALL (?X ?Y) (= ((FFN K) ?X) ?Y))

((D C)
 (B A))


|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON)

PERSON

|= (DEFFUNCTION FRIENDS ((?P PERSON)) :-> (?F SET))

FRIENDS

|= (ASSERT (= (SETOF HANS FRANZ) (FRIENDS FRED)))

(= (SETOF FRANZ HANS) (FRIENDS FRED))

|= (ASSERT (= (FRIENDS HANS) (SETOF FRED FRANZ)))

(= (FRIENDS HANS) (SETOF FRANZ FRED))

|= (RETRIEVE ALL ?F (MEMBER-OF ?F (FRIENDS FRED)))

(FRANZ HANS)


|= (RETRIEVE ALL ?F (MEMBER-OF ?F (FRIENDS HANS)))

(FRANZ FRED)


|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON)

PERSON

|= (DEFFUNCTION FRIENDS ((?P PERSON)) :-> (?F SET))

FRIENDS

|= (DEFCONCEPT FRIEND-OF-HANS (?X) :<<=>> (MEMBER-OF ?X (FRIENDS HANS)))

FRIEND-OF-HANS

|= (DEFCONCEPT HAS-HANS-AS-FRIEND (?X) :<<=>> (MEMBER-OF HANS (FRIENDS ?X)))

HAS-HANS-AS-FRIEND

|= (ASSERT (PERSON HANS))

(PERSON HANS)

|= (ASSERT (PERSON OTTO))

(PERSON OTTO)

|= (ASSERT (PERSON KARL))

(PERSON KARL)

|= (ASSERT (FRIEND-OF-HANS OTTO))

(FRIEND-OF-HANS OTTO)

|= (ASSERT (HAS-HANS-AS-FRIEND KARL))

(HAS-HANS-AS-FRIEND KARL)

|= (ASK (FRIEND-OF-HANS OTTO))

TRUE

|= (ASK (HAS-HANS-AS-FRIEND KARL))

TRUE

|= (RETRIEVE ALL ?X (MEMBER-OF OTTO ?X))

((FRIENDS HANS))


|= (RETRIEVE ALL ?X (MEMBER-OF HANS ?X))

((FRIENDS KARL))


|= (CLEAR-MODULE "TEST")


|= (DEFRELATION SIBLING-OF (?X ?Y))

SIBLING-OF

|= (DEFRELATION BROTHER-OF (?X ?Y))

BROTHER-OF

|= (DEFRELATION SON-OF (?X ?Y))

SON-OF

|= (ASSERT (FORALL (?X ?Y) (=> (BROTHER-OF ?X ?Y) (SIBLING-OF ?X ?Y))))

(forall (?x1 ?x2)
   (<= (SIBLING-OF ?x1 ?x2)
       (BROTHER-OF ?x1 ?x2)))

|= (ASSERT (FORALL (?X ?Y ?F) (=> (AND (SON-OF ?X ?F) (SON-OF ?Y ?F) (NOT (= ?X ?Y))) (BROTHER-OF ?X ?Y))))

(forall (?x ?y ?f)
   (<= (BROTHER-OF ?x ?y)
       (and (SON-OF ?x ?f)
            (SON-OF ?y ?f)
            (not (= ?x ?y)))))

|= (ASSERT (SON-OF HANS DAD))

(SON-OF HANS DAD)

|= (ASSERT (SON-OF FRANZ DAD))

(SON-OF FRANZ DAD)

|= (ASK (SIBLING-OF HANS FRANZ))

TRUE

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON)

PERSON

|= (DEFFUNCTION AGE ((?X PERSON)) :-> (?Y INTEGER))

AGE

|= (DEFCONCEPT TEENAGER ((?X PERSON)) :<=> (AND (PERSON ?X) (< (AGE ?X) 20) (> (AGE ?X) 12)))

TEENAGER

|= (ASSERT (AND (PERSON MIKE) (AGE MIKE 15)))

((PERSON MIKE) (= (AGE MIKE) 15))

|= (ASK (TEENAGER MIKE))

TRUE

|= (ASK (FORALL ?X (=> (AND (PERSON ?X) (< (AGE ?X) 20) (> (AGE ?X) 12)) (TEENAGER ?X))))

TRUE

|= (ASK (SUBSET-OF (KAPPA (?X) (AND (PERSON ?X) (< (AGE ?X) 20) (> (AGE ?X) 12))) TEENAGER))

TRUE

|= (ASK (FORALL ?X (=> (AND (PERSON ?X) (< (AGE ?X) 20) (> (AGE ?X) 15)) (TEENAGER ?X))))

TRUE

|= (ASK (SUBSET-OF (KAPPA (?X) (AND (PERSON ?X) (< (AGE ?X) 20) (> (AGE ?X) 15))) TEENAGER))

TRUE

|= (ASK (FORALL ?X (=> (AND (PERSON ?X) (< (AGE ?X) 23) (> (AGE ?X) 15)) (TEENAGER ?X))))

UNKNOWN

|= (ASK (SUBSET-OF (KAPPA (?X) (AND (PERSON ?X) (< (AGE ?X) 23) (> (AGE ?X) 15))) TEENAGER))

UNKNOWN

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON)

PERSON

|= (DEFFUNCTION AGE ((?X PERSON)) :-> (?Y NUMBER))

AGE

|= (ASSERT (AGE JEFF 42))

(= (AGE JEFF) 42)

|= (ASK (AGE JEFF 21))

FALSE

|= (ASK (NOT (AGE JEFF 21)))

TRUE

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT META-PROPERTY)

META-PROPERTY

|= (DEFCONCEPT EXTENSIONAL)

EXTENSIONAL

|= (DEFCONCEPT ENTITY)

ENTITY

|= (DEFCONCEPT EXTENSIONAL-P (?P) :<=> (AND (META-PROPERTY ?P) (FORALL ?X (=> (AND (ENTITY ?X) (?P ?X)) (EXTENSIONAL ?X)))))

EXTENSIONAL-P

|= (DEFCONCEPT TEST-CLASS (?X ENTITY) :AXIOMS (EXTENSIONAL-P TEST-CLASS))

TEST-CLASS

|= (ASSERT (TEST-CLASS FRED))

(TEST-CLASS FRED)

|= (ASK (EXTENSIONAL FRED))

TRUE

|= (ASK (HOLDS TEST-CLASS FRED))

TRUE

|= (ASK (EXTENSIONAL FRED))

TRUE

|= (CLEAR-MODULE "TEST")


|= (DEFFUNCTION AGE (?P) :-> (?A INTEGER))

AGE

|= (ASSERT (< (AGE BILL) 12))

(< (AGE BILL) 12)

|= (ASSERT (> (AGE BILL) 10))

(> (AGE BILL) 10)

|= (RETRIEVE ?X (= (AGE BILL) ?X))

(11)


|= (RETRACT (< (AGE BILL) 12))

(< (AGE BILL) 12)

|= (RETRIEVE ?X (= (AGE BILL) ?X))

((AGE BILL))


|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PRIMARY-COLOR (?C) :<<=>> (MEMBER-OF ?C (SETOF RED GREEN BLUE)))

PRIMARY-COLOR

|= (DEFFUNCTION FAVORITE-COLOR (?X ?Y))

FAVORITE-COLOR

|= (ASSERT (PRIMARY-COLOR RED))

(PRIMARY-COLOR RED)

|= (ASSERT (PRIMARY-COLOR (FAVORITE-COLOR JOE)))

(PRIMARY-COLOR (FAVORITE-COLOR JOE))

|= (RETRIEVE ALL (?X) (PRIMARY-COLOR ?X))

(((FAVORITE-COLOR JOE))
 (RED)
 (BLUE)
 (GREEN))


|= (ASSERT (PRIMARY-COLOR PINK))

(PRIMARY-COLOR PINK)

|= (RETRIEVE ALL (?X) (PRIMARY-COLOR ?X))

Derived both TRUE and FALSE for the proposition `(MEMBER-OF PINK (SETOF BLUE GREEN
RED))'.
   Clash occurred in the world `#<|WLD|466>' in module `/PL-KERNEL-KB/PL-USER/TEST'.
((PINK)
 ((FAVORITE-COLOR JOE))
 (RED)
 (BLUE)
 (GREEN))


|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT A :DOCUMENTATION "doc" :SYNONYM A-SYN)

A

|= (DEFRELATION R (?X))

R

|= (ASSERT (R A))

(R A)

|= (ASSERT (SYNONYM A A-SYN2))

(SYNONYM A A-SYN2)

|= (RETRIEVE ALL ?X (DOCUMENTATION A ?X))

("doc")


|= (RETRIEVE ALL ?X (DOCUMENTATION A-SYN ?X))

("doc")


|= (RETRIEVE ALL ?X (DOCUMENTATION A-SYN2 ?X))

("doc")


|= (ASK (R A))

TRUE

|= (DEFCONCEPT A :DOCUMENTATION "doc2")

A

|= (RETRIEVE ALL ?X (DOCUMENTATION A ?X))

("doc2")


|= (RETRIEVE ALL ?X (DOCUMENTATION A-SYN ?X))

()


|= (RETRIEVE ALL ?X (DOCUMENTATION A-SYN2 ?X))

("doc2")


|= (ASK (R A))

TRUE

|= (DEFPROPOSITION P (R FOO) :DOCUMENTATION "doc" :SYNONYM P-SYN)

(R FOO)

|= (ASSERT (R P))

(R (R FOO))

|= (ASSERT (SYNONYM P P-SYN2))

(SYNONYM (R FOO) P-SYN2)

|= (RETRIEVE ALL ?X (DOCUMENTATION P ?X))

("doc")


|= (RETRIEVE ALL ?X (DOCUMENTATION P-SYN ?X))

("doc")


|= (RETRIEVE ALL ?X (DOCUMENTATION P-SYN2 ?X))

("doc")


|= (ASK (R P))

TRUE

|= (DEFPROPOSITION P (R FOO) :DOCUMENTATION "doc2")

(R FOO)

|= (RETRIEVE ALL ?X (DOCUMENTATION P ?X))

("doc2")


|= (RETRIEVE ALL ?X (DOCUMENTATION P-SYN ?X))

()


|= (RETRIEVE ALL ?X (DOCUMENTATION P-SYN2 ?X))

("doc2")


|= (ASK (R P))

TRUE

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT A :DOCUMENTATION "doc" :SYNONYM A-SYN)

A

|= (DEFRELATION R (?X))

R

|= (ASSERT (R A))

(R A)

|= (ASSERT (SYNONYM A A-SYN2))

(SYNONYM A A-SYN2)

|= (DEFCONCEPT A :DOCUMENTATION "doc2")

A

|= (RETRIEVE ALL ?X (DOCUMENTATION A ?X))

("doc2")


|= (RETRIEVE ALL ?X (DOCUMENTATION A-SYN ?X))

()


|= (RETRIEVE ALL ?X (DOCUMENTATION A-SYN2 ?X))

("doc2")


|= (ASK (R A))

TRUE

|= (DEFPROPOSITION P (R FOO) :DOCUMENTATION "doc" :SYNONYM P-SYN)

(R FOO)

|= (ASSERT (R P))

(R (R FOO))

|= (ASSERT (SYNONYM P P-SYN2))

(SYNONYM (R FOO) P-SYN2)

|= (DEFPROPOSITION P (R FOO) :DOCUMENTATION "doc2")

(R FOO)

|= (RETRIEVE ALL ?X (DOCUMENTATION P ?X))

("doc2")


|= (RETRIEVE ALL ?X (DOCUMENTATION P-SYN ?X))

()


|= (RETRIEVE ALL ?X (DOCUMENTATION P-SYN2 ?X))

("doc2")


|= (ASK (R P))

TRUE

|= (CLEAR-MODULE "TEST")


|= (DEFRELATION R (?X ?Y))

R

|= (DEFRELATION S (?X ?Y))

S

|= (DEFPROPOSITION P1 (=> (R ?X ?Y) (S ?Y ?X)) :BACKWARD-ONLY? TRUE)

(forall (?x ?y)
   (<= (S ?y ?x)
       (R ?x ?y)))

|= (ASSERT (R A B))

(R A B)

|= (ASK (S B A))

TRUE

|= (UNSET-FEATURE JUST-IN-TIME-INFERENCE)

|l|(:EMIT-THINKING-DOTS)

|= (DEFPROPOSITION P1 (=> (R ?X ?Y) (S ?Y ?X)) :FORWARD-ONLY? TRUE)

(forall (?x ?y)
   (=> (R ?x ?y)
       (S ?y ?x)))

|= (ASK (S B A))

UNKNOWN

|= (SET-FEATURE JUST-IN-TIME-INFERENCE)

|l|(:JUST-IN-TIME-INFERENCE :EMIT-THINKING-DOTS)

|= (ASK (S B A))

TRUE

|= (CLEAR-MODULE "TEST")


|= (DEFRELATION BROTHER (?X ?Y) :CLOSED TRUE)

BROTHER

|= (ASSERT (AND (BROTHER FRED JOE) (BROTHER FRED JOHN) (BROTHER SUSI FRED)))

((BROTHER FRED JOE) (BROTHER FRED JOHN) (BROTHER SUSI FRED))

|= (RETRIEVE ALL (?X ?C) (AND (BROTHER SUSI ?X) (= (CARDINALITY (SETOFALL (?F) (BROTHER ?X ?F))) ?C)))

((FRED 2))


|= (RETRIEVE ALL (?C ?X) (AND (BROTHER SUSI ?X) (= (CARDINALITY (SETOFALL (?F) (BROTHER ?X ?F))) ?C)))

((2 FRED))


|= (CLEAR-MODULE "TEST")


|= (DEFFUNCTION R (?X ?Y) :<=> (S ?Y ?X))

R

|= (DEFFUNCTION S (?X ?Y) :<=> (R ?Y ?X))

S

|= (ASSERT (R FRED WILMA))

(= (R FRED) WILMA)

|= (ASSERT (R BARNEY BETTY))

(= (R BARNEY) BETTY)

|= (RETRIEVE ALL (S ?X ?Y))

((BETTY BARNEY)
 (WILMA FRED))


|= (CLEAR-MODULE "TEST")


|= (RETRIEVE 3 (MEMBER-OF ?SUPER (SETOFALL ?X (SUPERRELATION CONCEPT ?X))))

(CONCEPT RELATION SET)


|= (RETRIEVE ALL (MEMBER-OF ?X (KAPPA (?Y) (MEMBER-OF ?Y (SETOF "a" "b" "c")))))

("a" "b" "c")


|= (CLEAR-MODULE "TEST")


|= (DEFRELATION HAPPY (?X))

HAPPY

|= (DEFFUNCTION FATHER (?X ?Y))

FATHER

|= (ASSERT (HAPPY FRED))

(HAPPY FRED)

|= (UNASSERT (HAPPY FRED))

(HAPPY FRED)

|= (ASK (HAPPY FRED))

UNKNOWN

|= (ASSERT (NOT (HAPPY FRED)))

(not (HAPPY FRED))

|= (UNASSERT (HAPPY FRED))

(HAPPY FRED)

|= (ASK (NOT (HAPPY FRED)))

UNKNOWN

|= (ASSERT (HAPPY FRED))

(HAPPY FRED)

|= (UNASSERT (NOT (HAPPY FRED)))

(HAPPY FRED)

|= (ASK (HAPPY FRED))

UNKNOWN

|= (ASSERT (HAPPY FRED))

(HAPPY FRED)

|= (ASSERT (HAPPY JOE))

(HAPPY JOE)

|= (UNASSERT (AND (HAPPY FRED) (HAPPY JOE)))

((HAPPY FRED) (HAPPY JOE))

|= (ASK (HAPPY FRED))

UNKNOWN

|= (ASK (HAPPY JOE))

UNKNOWN

|= (ASSERT (NOT (HAPPY FRED)))

(not (HAPPY FRED))

|= (ASSERT (HAPPY JOE))

(HAPPY JOE)

|= (UNASSERT (AND (HAPPY FRED) (HAPPY JOE)))

((HAPPY FRED) (HAPPY JOE))

|= (ASK (NOT (HAPPY FRED)))

UNKNOWN

|= (ASK (HAPPY JOE))

UNKNOWN

|= (ASSERT (HAPPY FRED))

(HAPPY FRED)

|= (ASSERT (NOT (HAPPY FRED)))

Derived both TRUE and FALSE for the proposition `(HAPPY FRED)'.
   Clash occurred in module `/PL-KERNEL-KB/PL-USER/TEST'.
|= (ASK (HAPPY FRED))

UNKNOWN

|= (UNASSERT (HAPPY FRED))

(HAPPY FRED)

|= (ASK (HAPPY FRED))

UNKNOWN

|= (ASSERT (HAPPY FRED))

(HAPPY FRED)

|= (ASK (HAPPY FRED))

TRUE

|= (ASSERT (NOT (HAPPY FRED)))

Derived both TRUE and FALSE for the proposition `(HAPPY FRED)'.
   Clash occurred in module `/PL-KERNEL-KB/PL-USER/TEST'.
|= (ASK (HAPPY FRED))

UNKNOWN

|= (UNASSERT (NOT (HAPPY FRED)))

(HAPPY FRED)

|= (ASK (HAPPY FRED))

UNKNOWN

|= (ASSERT (HAPPY FRED))

(HAPPY FRED)

|= (ASK (HAPPY FRED))

TRUE

|= (ASSERT (= (FATHER FRED) DAD))

(= (FATHER FRED) DAD)

|= (UNASSERT (= (FATHER FRED) DAD))

(= (FATHER FRED) DAD)

|= (ASK (= (FATHER FRED) DAD))

UNKNOWN

|= (ASSERT (= (FATHER FRED) DAD))

(= (FATHER FRED) DAD)

|= (ASSERT (= (FATHER JOE) DAD))

(= (FATHER JOE) DAD)

|= (RETRACT (= (FATHER FRED) DAD))

(= (FATHER FRED) (FATHER FRED))

|= (ASK (= (FATHER FRED) DAD))

UNKNOWN

|= (ASSERT (= (FATHER FRED) DAD))

(= (FATHER FRED) DAD)

|= (ASSERT (= (FATHER JOE) DAD))

(= (FATHER JOE) DAD)

|= (RETRACT (= (FATHER JOE) DAD))

(= (FATHER JOE) (FATHER JOE))

|= (ASK (= (FATHER JOE) DAD))

UNKNOWN

|= (ASSERT (= (FATHER FRED) DAD))

(= (FATHER FRED) DAD)

|= (ASSERT (= (FATHER JOE) DAD))

(= (FATHER JOE) DAD)

|= (UNASSERT (= (FATHER FRED) DAD))

(= (FATHER FRED) DAD)

|= (ASK (= (FATHER FRED) DAD))

UNKNOWN

|= (ASSERT (= (FATHER FRED) DAD))

(= (FATHER FRED) DAD)

|= (ASSERT (= (FATHER JOE) DAD))

(= (FATHER JOE) DAD)

|= (UNASSERT (= (FATHER JOE) DAD))

(= (FATHER JOE) DAD)

|= (ASK (= (FATHER JOE) DAD))

UNKNOWN

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT A)

A

|= (DEFCONCEPT B)

B

|= (ASSERT (AND (A B1) (A B2) (A B3)))

((A B1) (A B2) (A B3))

|= (ASK-PARTIAL (OR (B A1) (AND (B A2) (B A3))) :MATCH-MODE :WHYNOT-DEEP :MINIMUM-SCORE 0.0)

0.0

|= (DEFRELATION HAPPY (?X))

HAPPY

|= (ASSERT (NOT (HAPPY JOE)))

(not (HAPPY JOE))

|= (ASSERT (NOT (HAPPY SUSI)))

(not (HAPPY SUSI))

|= (ASK (AND (HAPPY JOE) (HAPPY FRED)))

FALSE

|= (ASK (AND (HAPPY FRED) (HAPPY JOE)))

UNKNOWN

|= (ASK (NOT (AND (HAPPY FRED) (HAPPY JOE))))

TRUE

|= (ASK (AND (HAPPY FRED) (HAPPY JOE)) :THREE-VALUED? TRUE)

FALSE

|= (ASK (OR (HAPPY FRED) (HAPPY JOE)))

UNKNOWN

|= (ASK (OR (HAPPY JOE) (HAPPY FRED)))

UNKNOWN

|= (ASK (OR (HAPPY JOE) (HAPPY SUSI)))

FALSE

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT PERSON)

PERSON

|= (DEFCONCEPT MAN (PERSON))

MAN

|= (DEFCONCEPT WOMAN (PERSON))

WOMAN

|= (ASSERT (OR (MAN FRED) (WOMAN FRED)))

(or (MAN FRED)
    (WOMAN FRED))

|= (ASK (PERSON FRED) :INFERENCE-LEVEL :REFUTATION)

UNKNOWN  ;; BUG, SHOULD RETURN TRUE

|= (RETRIEVE (PERSON ?X) :INFERENCE-LEVEL :REFUTATION)

() ;; BUG, SHOULD RETURN FRED


|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT HUMAN)

HUMAN

|= (DEFCONCEPT MALE)

MALE

|= (DEFCONCEPT FEMALE)

FEMALE

|= (DEFCONCEPT PERSON (?X) :<=> (AND (HUMAN ?X) (OR (MALE ?X) (FEMALE ?X))))

PERSON

|= (DEFCONCEPT MAN (?X) :<=> (AND (HUMAN ?X) (MALE ?X)))

MAN

|= (DEFCONCEPT WOMAN (?X) :<=> (AND (HUMAN ?X) (FEMALE ?X)))

WOMAN

|= (DEFCONCEPT GENDER (?X) :<=> (OR (MALE ?X) (FEMALE ?X)))

GENDER

;;; NEED NATURAL DEDUCTION MODE TURNED OFF TO MAKE THESE
;;; WORK, SINCE WE NEED THE CONTRAPOSITIVE RULES:

|= (ASK (SUBSET-OF PERSON (KAPPA ?O (OR (MAN ?O) (WOMAN ?O)))) :INFERENCE-LEVEL :REFUTATION)

TRUE

;;; SHOULD RETURN TRUE BUT DOESN'T, SINCE WE CAN'T REASON BY
;;; CASES TO FIGURE OUT (HUMAN ?O):
|= (ASK (SUBSET-OF (KAPPA ?O (OR (MAN ?O) (WOMAN ?O))) PERSON) :INFERENCE-LEVEL :REFUTATION)

UNKNOWN ;; BUG

|= (ASK (SUBSET-OF (KAPPA ?O (AND (HUMAN ?O) (OR (MAN ?O) (WOMAN ?O)))) PERSON) :INFERENCE-LEVEL :REFUTATION)

TRUE

|= (ASK (SUBSET-OF PERSON GENDER) :INFERENCE-LEVEL :REFUTATION)

TRUE

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT NICE-INTEGER (INTEGER))

NICE-INTEGER

|= (DEFRELATION NICE-INTEGER-PAIR ((?X NICE-INTEGER) (?Y NICE-INTEGER)))

NICE-INTEGER-PAIR

|= (ASSERT (NICE-INTEGER 13))

(NICE-INTEGER 13)

|= (ASSERT (NICE-INTEGER 15))

(NICE-INTEGER 15)

;;; THESE ONLY WORK WITH `*backlink-all-proposition-arguments?*' TURNED ON:
|= (ASK (NICE-INTEGER 13))

TRUE

|= (ASK (NICE-INTEGER 15))

TRUE

|= (RETRIEVE ALL (NICE-INTEGER ?X))

(13 15)


|= (ASSERT (=> (AND (NICE-INTEGER ?X) (NICE-INTEGER ?Y)) (NICE-INTEGER-PAIR ?X ?Y)))

(forall (?x ?y)
   (<= (NICE-INTEGER-PAIR ?x ?y)
       (and (NICE-INTEGER ?x)
            (NICE-INTEGER ?y))))

|= (ASK (NICE-INTEGER-PAIR 13 15))

WARNING: Type check violation on argument `13' in proposition
   (NICE-INTEGER-PAIR 13 15).
   Argument must have type `NICE-INTEGER'.
   Warning occurred while parsing the proposition: 
   (KAPPA () (NICE-INTEGER-PAIR 13 15))
WARNING: Type check violation on argument `15' in proposition
   (NICE-INTEGER-PAIR 13 15).
   Argument must have type `NICE-INTEGER'.
   Warning occurred while parsing the proposition: 
   (KAPPA () (NICE-INTEGER-PAIR 13 15))
TRUE

|= (RETRIEVE ALL (NICE-INTEGER-PAIR ?X ?Y))

((13 15))


|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT A)

A

|= (DEFCONCEPT B)

B

|= (DEFRELATION R (?X ?Y))

R

|= (ASSERT (HOLDS (KAPPA (?X) (AND (A ?X) (B ?X))) FRED))

((B FRED) (A FRED))

|= (ASK (AND (A FRED) (B FRED)))

TRUE

|= (ASSERT (HOLDS (KAPPA (?X ?Y) (AND (A ?X) (B ?Y) (R ?X ?Y))) JOE SUSI))

((R JOE SUSI) (B SUSI) (A JOE))

|= (ASK (AND (A JOE) (B SUSI) (R JOE SUSI)))

TRUE

|= (ASSERT (=> (R ?X ?Y) (HOLDS (KAPPA (?S ?T) (AND (A ?S) (B ?T))) ?X ?Y)))

(forall (?x ?y)
   (<= (and (B ?y)
            (A ?x))
       (R ?x ?y)))

|= (ASSERT (R FOO BAR))

(R FOO BAR)

|= (ASK (AND (A FOO) (B BAR)))

TRUE

|= (CLEAR-MODULE "TEST")


|= (DEFCONCEPT GEO)

GEO

|= (ASSERT (GEO G_LA))

(GEO G_LA)

|= (ASSERT (GEO G_LACMSA))

(GEO G_LACMSA)

|= (ASSERT (GEO G_CA))

(GEO G_CA)

|= (DEFRELATION GEOPARTOF ((?X GEO) (?Y GEO)) :TRANSITIVE TRUE)

GEOPARTOF

|= (ASSERT (GEOPARTOF G_LA G_LACMSA))

(GEOPARTOF G_LA G_LACMSA)

|= (ASSERT (GEOPARTOF G_LACMSA G_CA))

(GEOPARTOF G_LACMSA G_CA)

|= (DEFRELATION R1 ((?POINT_ID GEO) (?COUNTY_ID GEO) (?TAZ GEO)) :<=> (AND (GEOPARTOF ?POINT_ID ?TAZ) (GEOPARTOF ?TAZ ?COUNTY_ID) (GEOPARTOF ?COUNTY_ID G_LACMSA)))

R1

|= (DEFRELATION R2 ((?POINT_ID GEO) (?COUNTY_ID GEO) (?TAZ GEO)) :<=> (AND (GEOPARTOF ?POINT_ID ?TAZ) (GEOPARTOF ?TAZ ?COUNTY_ID) (= ?COUNTY_ID G_LA)))

R2

|= (DEFRELATION R3 ((?POINT_ID GEO) (?COUNTY_ID GEO) (?TAZ GEO)) :<=> (AND (GEOPARTOF ?POINT_ID ?TAZ) (GEOPARTOF ?TAZ ?COUNTY_ID) (MEMBER-OF ?COUNTY_ID (SETOF G_LA))))

R3

|= (ASK (SUBSET-OF R2 R1))

TRUE

;;; THIS SHOULD ALSO RETURN TRUE, BUT WE ARE NOT QUITE SMART ENOUGH TO
;;; INFER THE EQUALITY CONSTRAINT FROM THE SINGLETON SET - MAYBE LATER:
|= (ASK (SUBSET-OF R3 R1))

UNKNOWN

|= (CLEAR-MODULE "TEST")


|= (DEFFUNCTION F (?X ?Y))

F

|= (DEFCONCEPT A)

A

|= (DEFCONCEPT B)

B

|= (DEFCONCEPT C (?X) :<=> (AND (A ?X) (B ?X)))

C

|= (ASSERT (A (F X)))

(A (F X))

|= (ASSERT (B (F Y)))

(B (F Y))

|= (ASSERT (= (F X) (F Y)))

(= (F X) (F Y))

|= (RETRIEVE ALL (C ?X))

((F Y))


|= (RETRIEVE ALL (C ?X))

((F Y))


|= (CLEAR-MODULE "TEST")


|= (DEFRELATION R (?X ?Y))

R

|= (DEFRELATION S (?X ?Y))

S

|= (DEFRELATION T (?X ?Y))

T

|= (ASSERT (=> (R ?X ?Y) (EXISTS ?Z (S ?X ?Z))))

(forall (?x ?y)
   (<= (exists (?z)
          (S ?x ?z))
       (R ?x ?y)))

|= (ASSERT (=> (S ?X ?Z) (FORALL ?E (=> (T ?E ?Z) (T ?Z ?E)))))

(forall (?x ?z)
   (<= (forall (?e)
          (<= (T ?z ?e)
              (T ?e ?z)))
       (S ?x ?z)))

|= (ASSERT (R A B))

(R A B)

|= (RUN-FORWARD-RULES "TEST")


|= (RETRIEVE ALL (S ?X ?Y))

((A sk291)
 (A sk290))


|= (CLEAR-MODULE "TEST")


|= (DEFRELATION R (?X (?Y STRING)))

R

|= (DEFCONCEPT C (?SELF) :=> (RANGE-TYPE R ?SELF STRING))

C

|= (PROCESS-DEFINITIONS)


|= (CLEAR-MODULE "TEST")


|= (DEFFUNCTION PREDICATE (?SELF ?VALUE))

PREDICATE

|= (DEFFUNCTION MYARITY (?SELF (?VALUE INTEGER)))

MYARITY

|= (ASSERT (FORALL (?V7134 ?V) (=>> (= (MYARITY ?V7134) ?V) (OR (NOT (= ?V7134 PHYCHSIM6_INSTANCE_10020)) (INTEGER ?V)))))

(forall (?v7134 ?v)
   (=> (= (MYARITY ?v7134) ?v)
       (or (not (= ?v7134 PHYCHSIM6_INSTANCE_10020))
           (INTEGER ?v))))

|= (ASSERT (MYARITY PHYCHSIM6_INSTANCE_10020 2))

(= (MYARITY PHYCHSIM6_INSTANCE_10020) 2)

|= (ASSERT (PREDICATE PHYCHSIM6_INSTANCE_1 PHYCHSIM6_INSTANCE_10020))

(= (PREDICATE PHYCHSIM6_INSTANCE_1) PHYCHSIM6_INSTANCE_10020)

|= (RUN-FORWARD-RULES TEST :FORCE)


|= (CLEAR-MODULE "TEST")


|= (CONCEIVE (AND))

TRUE

|= (CONCEIVE (OR))

FALSE

|= (CONCEIVE (NOT))

ERROR: Missing argument in NOT proposition: `(NOT)'.
   Error occurred while parsing the proposition: 
   (NOT)

|= (CONCEIVE (AND (RELATION RELATION)))

(RELATION RELATION)

|= (CONCEIVE (OR (RELATION RELATION)))

(RELATION RELATION)

|= (DEFRELATION R1 ((?X RELATION) (?Y RELATION)))

R1

|= (DEFRELATION R2 (?X ?Y) :<=> (R1 ?Y ?X))

R2

|= (DEFRELATION R3 (?X ?Y) :<=> (AND (R1 ?Y ?X) (= ?X ?Y)))

R3

|= (PROCESS-DEFINITIONS)


|= (PRINT-RULES R1)

(forall (?y ?x)
   (=>> (R1 ?y ?x)
        (R2 ?x ?y)))

(forall (?y ?x)
   (<= (R1 ?y ?x)
       (R2 ?x ?y)))

(forall (?y ?x)
   (<= (R1 ?y ?x)
       (R3 ?x ?y)))


|= (PRINT-RULES R2)

(forall (?x ?y)
   (=>> (R2 ?x ?y)
        (R1 ?y ?x)))

(forall (?x ?y)
   (<= (R2 ?x ?y)
       (R1 ?y ?x)))


|= (PRINT-RULES R3)

(forall (?x ?x)
   (=>> (R3 ?x ?x)
        (R1 ?x ?x)))

(forall (?x ?x)
   (<= (R3 ?x ?x)
       (R1 ?x ?x)))


|= (CONCEIVE (KAPPA (?X ?Y) (AND (R1 ?X ?Y) (= ?X ?Y))))

(kappa (?x ?x) (R1 ?x ?x))

|= (CONCEIVE (KAPPA (?X ?Y) (AND (R1 ?X ?Y))))

R1

|= (CONCEIVE (KAPPA ((?X RELATION) (?Y RELATION)) (AND (R1 ?X ?Y))))

R1

|= (CONCEIVE (KAPPA (?X ?Y) (AND (NOT (R1 ?X ?Y)) (= ?X ?Y))))

(kappa (?x ?x) (not (R1 ?x ?x)))

|= (CONCEIVE (KAPPA (?X ?Y) (AND (NOT (R1 ?X ?Y)))))

;;; THIS IS not-R1 EVEN THOUGH IT PRINTS DIFFERENTLY HERE:
(kappa ((?x1 RELATION) (?x2 RELATION)) (not (R1 ?x1 ?x2)))

|= (CONCEIVE (KAPPA ((?X RELATION) (?Y RELATION)) (AND (NOT (R1 ?X ?Y)))))

;;; THIS IS not-R1 EVEN THOUGH IT PRINTS DIFFERENTLY HERE:
(kappa ((?x1 RELATION) (?x2 RELATION)) (not (R1 ?x1 ?x2)))

|= (CLEAR-MODULE "TEST")


|= (DEFRELATION R1 (?X ?Y))

R1

|= (DEFRELATION R2 (?X ?Y))

R2

|= (ASSERT (=>> (AND (= ?X ?Y) (R1 ?X ?Y)) (R2 ?X ?Y)))

(forall (?x ?x)
   (=> (R1 ?x ?x)
       (R2 ?x ?x)))

|= (ASSERT (R1 A B))

(R1 A B)

|= (ALL-FACTS-OF A)

((R1 A B))

|= (CLEAR-MODULE "TEST")


|= (DEFFUNCTION FATHER (?X ?Y))

FATHER

|= (DEFRELATION PARENT (?X ?Y))

PARENT

|= (DEFRELATION MALE (?X))

MALE

|= (ASSERT (=> (AND (PARENT ?C ?P) (MALE ?P)) (FATHER ?C ?P)))

(forall (?c ?p)
   (<= (= (FATHER ?c) ?p)
       (and (PARENT ?c ?p)
            (MALE ?p))))

|= (ASSERT (FATHER FRED (FATHER JOE)))

(= (FATHER FRED) (FATHER JOE))

|= (ASSERT (PARENT FRED FRITZ))

(PARENT FRED FRITZ)

|= (ASSERT (MALE FRITZ))

(MALE FRITZ)

;;; SHOULD GET FRITZ BUT DOESN'T BECAUSE WE STOP AT THE ASSERTED VALUE:
|= (RETRIEVE ALL (FATHER FRED ?F))

((FATHER JOE)) ;; BUG

|= (RETRIEVE ALL (FATHER ?C ?F))

((JOE (FATHER JOE))
 (FRED (FATHER JOE))
 (FRED FRITZ))


|= (CLEAR-MODULE "TEST")


|= (DEFFUNCTION FATHER (?X ?Y))

FATHER

|= (DEFRELATION PARENT (?X ?Y))

PARENT

|= (DEFRELATION MALE (?X))

MALE

|= (ASSERT (=> (AND (PARENT ?C ?P) (MALE ?P)) (FATHER ?C ?P)))

(forall (?c ?p)
   (<= (= (FATHER ?c) ?p)
       (and (PARENT ?c ?p)
            (MALE ?p))))

|= (ASSERT (FATHER FRED FRITZ))

(= (FATHER FRED) FRITZ)

|= (ASSERT (PARENT FRED (FATHER JOE)))

(PARENT FRED (FATHER JOE))

|= (ASSERT (MALE (FATHER JOE)))

(MALE (FATHER JOE))

|= (RETRIEVE ALL (FATHER FRED ?F))

(FRITZ)


|= (RETRIEVE ALL (FATHER ?C ?F))

((JOE (FATHER JOE))
 (FRED FRITZ)
 (FRED (FATHER JOE)))


|= (CLEAR-MODULE "TEST")


|= (DEFRELATION V1 (?STUDENT ?NUMBER ?YEAR))

V1

|= (DEFRELATION V2 (?STUDENT ?DEPT ?COURSE))

V2

|= (ASK (SUBSET-OF (KAPPA (?S ?D) (EXISTS (?N ?Y ?C) (AND (V1 ?S ?N ?Y) (V2 ?S ?D ?C) (>= ?Y 1995)))) (KAPPA (?S ?D) (EXISTS (?N ?Y ?C) (AND (V1 ?S ?N ?Y) (V2 ?S ?D ?C) (>= ?Y 1990))))))

TRUE

|= (CLEAR-MODULE "TEST")


|= (DEFRELATION HAPPY (?X))

HAPPY

|= (DEFRELATION POOR (?X))

POOR

|= (DEFFUNCTION BOSS (?X ?Y))

BOSS

|= (ASSERT (=>> (POOR ?X) (NOT (HAPPY ?X))))

(forall (?x)
   (=> (POOR ?x)
       (not (HAPPY ?x))))

|= (ASK (=> (POOR FRED) (HAPPY FRED)) :INFERENCE-LEVEL :REFUTATION)

FALSE

|= (ASK (=> (POOR (BOSS FRED)) (HAPPY (BOSS FRED))) :INFERENCE-LEVEL :REFUTATION)

UNKNOWN

|= (ASK (=> (EXISTS (?B) (AND (= (BOSS FRED) ?B) (POOR ?B))) (EXISTS (?B) (AND (= (BOSS FRED) ?B) (HAPPY ?B)))) :INFERENCE-LEVEL :REFUTATION)

UNKNOWN

|= (ASSERT (EXISTS (?B) (AND (= (BOSS FRED) ?B) (POOR ?B))))

((= (BOSS FRED) sk303) (POOR sk303))

|= (ASK (EXISTS (?B) (AND (= (BOSS FRED) ?B) (HAPPY ?B))) :INFERENCE-LEVEL :REFUTATION)

FALSE

|= (CLEAR-MODULE "TEST")


|= (ASSERT (FORALL (?X ?Y) (=> (AND (RELATION ?X) (RELATION ?Y)) (BOUND-VARIABLES ?X ?Y))))

(forall (?x ?y)
   (<= (BOUND-VARIABLES ?x ?y)
       (and (RELATION ?x)
            (RELATION ?y))))

|= (ASSERT (FORALL (?T ?S) (=> (AND (RELATION ?S) (RELATION ?T)) (BOUND-VARIABLES ?S ?T))))

;;; WE SHOULD PICK UP THE DUPLICATE RULE HERE BUT FAIL DUE TO
;;; THE DIFFERENT ORDER IN WHICH THE VARIABLES ARE QUANTIFIED:
(forall (?x ?y)
   (<= (BOUND-VARIABLES ?x ?y)
       (and (RELATION ?x)
            (RELATION ?y))))

|= (CLEAR-MODULE "TEST")


|= (DEFRELATION R (?X ?Y))

R

|= (DEFRELATION S (?X ?Y))

S

|= (ASSERT (R A B))

(R A B)

|= (ASSERT (S A C))

(S A C)

|= (RETRIEVE ALL (HOLDS ?R A ?X))

((S C)
 (R B))


|= (RETRIEVE ALL (HOLDS ?R A B))

(R)


|= (RETRIEVE ALL (HOLDS ?R A C))

(S)


|= (CLEAR-MODULE "TEST")


|= (DEFFUNCTION F (?X ?Y))

F

|= (DEFRELATION R (?X ?Y))

R

|= (ASSERT (F A B))

(= (F A) B)

|= (ASSERT (NOT (F C D)))

(not (= (F C) D))

|= (ASSERT (R A B))

(R A B)

|= (ASSERT (NOT (R C D)))

(not (R C D))

|= (ASK (F A B))

TRUE

|= (ASK (NOT (F A B)))

FALSE

|= (ASK (F A C))

FALSE

|= (ASK (NOT (F A C)))

TRUE

|= (ASK (F C D))

FALSE

|= (ASK (NOT (F C D)))

TRUE  ;; SERIOUS BUG, WE DON'T GET THIS RIGHT NOW

|= (ASK (F C E))

UNKNOWN

|= (ASK (NOT (F C E)))

UNKNOWN

|= (ASK (R A B))

TRUE

|= (ASK (NOT (R A B)))

FALSE

|= (ASK (R A C))

UNKNOWN

|= (ASK (NOT (R A C)))

UNKNOWN

|= (ASK (R C D))

FALSE

|= (ASK (NOT (R C D)))

TRUE

|= (ASK (R C E))

UNKNOWN

|= (ASK (NOT (R C E)))

UNKNOWN

|= (ASSERT (SINGLE-VALUED R))

(SINGLE-VALUED R)

|= (ASK (R A B))

TRUE

|= (ASK (NOT (R A B)))

FALSE

|= (ASK (R A C))

FALSE

|= (ASK (NOT (R A C)))

TRUE

|= (ASK (R C D))

FALSE

|= (ASK (NOT (R C D)))

TRUE

|= (ASK (R C E))

UNKNOWN

|= (ASK (NOT (R C E)))

UNKNOWN

|= 

Finished testing file `test-suite.plm'.

FINISHED RUNNING POWERLOOM TEST SUITE
=====================================
Finish time:   2006-MAY-08 16:21:46.000 -7.0
Elapsed time:  plus 0 days; 104000 ms
