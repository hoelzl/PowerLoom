;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; Version: test-suite.ste,v 1.18 2003/10/16 02:30:13 hans Exp

;;; Various PowerLoom tests
;;; =======================

;;; Still pending bugs are annotated with `<<< FIX >>>'.


;; Standard demo preamble:

(in-package "STELLA")

(defmodule "PL-KERNEL/PL-USER/TEST")

(in-module "TEST")
(in-dialect :KIF)
(reset-features)


;;; BUILDING ODD-BALL PROPOSITIONS:

(clear-module "TEST")

(conceive (not (= 5 6)))


;;; PROPER ADDING OF SKOLEMS TO EXTENSIONS:

(clear-module "TEST")

(defconcept PERSON (?p) 
  :documentation "The class of PERSON beings.")
(defrelation happy ((?p PERSON)))
(deffunction age ((?p PERSON)) :-> (?age INTEGER))
(deffunction father ((?p PERSON)) :-> (?f PERSON))


(assert (PERSON fred))
(assert (exists (?x PERSON) (= (father fred) ?x)))
(retrieve all ?x (PERSON ?x))

;;; PROPER ADDING OF FORWARD INFERENCE (FUNCTION OUTPUT) SKOLEMS TO EXTENSIONS:

(clear-module "TEST")

(defconcept PERSON (?p))
(defconcept dog (?d)
    :=> (exists (?p PERSON) (owner ?d ?p)))
(deffunction owner ((?d DOG)) :-> (?o PERSON))
(defrelation loves ((?p PERSON) (?d dog)))

(assert (forall (?d dog) (exists (?p PERSON) (loves ?p ?d))))

(assert (dog rex))
(retrieve all (?x PERSON) (owner rex ?x))
(retrieve all (?x PERSON) (loves ?x rex))
(retrieve all (?x PERSON))

;;; PROPER RETRACTION OF SKOLEMS INFERRED DURING FORWARD INFERENCE:

(clear-module "TEST")

(defconcept bridge (?b))

(defconcept bridge-workaround (?bw)
   :=> (exists (?b bridge) (bridge-of ?bw ?b)))
(deffunction bridge-of ((?bw bridge-workaround)) :-> (?b BRIDGE))

;(propagate-constraints)
(assert (bridge-workaround bwa1))
(retrieve (?x bridge) (bridge-of bwa1 ?x))
(retrieve (?x bridge))
(retract (bridge-workaround bwa1))
;; NOW IT SHOULD DISAPPEAR:
(retrieve (?x bridge) (bridge-of bwa1 ?x))
(retrieve (?x bridge))
(propagate-constraints)
(assert (bridge-workaround bwa1))
(retrieve (?x bridge) (bridge-of bwa1 ?x))
;; <<< FIX >>> NOW IT SHOULD REAPPEAR:
(retrieve (?x bridge))


;;; DON'T BREAK ON FAILING `SUBSET' QUERIES:

(clear-module "TEST")

(defconcept bridge (?b))

(ask (subset-of bridge thing))
(ask (subset-of thing bridge))
(ask (not (subset-of bridge thing)))
(ask (not (subset-of thing bridge)))


;;; EXPOSED A PROBLEM WITH ROOT-TYPES AND QUERIES ON ABSTRACT CLASSES:

(clear-module "TEST")

(defconcept animal (?a)
  :axioms (ABSTRACT ANIMAL))
(defconcept PERSON (?p animal))

(assert (PERSON fred))
(ask (animal fred))
(ask (not (animal fred)))


;;; USING THE CONTRAPOSITIVE

(clear-module "TEST")

(defconcept boat (?b))
(deffunction max-current ((?b BOAT)) :-> (?mc FLOAT))

(defconcept river (?r))
(deffunction current ((?r RIVER)) :-> (?c FLOAT))
(defrelation current-too-strong ((?x boat) (?y river))
 :<=> (> (current ?y) (max-current ?x)))

(assert (river nile))
(assert (boat raft1))
(assert (max-current raft1 3.0))
(assert (current nile 2.0))

(ask (current-too-strong raft1 nile))

;;;; PROBLEM: `natural-deduction-mode?' KILLS THIS!!!!!!!!!!!!!!!!!

;; THIS MUST RETURN TRUE:
(ask (not (current-too-strong raft1 nile)))

;; TEST SYMMETRIE: CONTRAPOSITIVE DERIVED FROM A `NEGATIVE' RULE:
(defrelation current-too-strong2 ((?x boat) (?y river)))

(assert (forall ((?x boat) (?y river))
          (=> (not (> (current ?y) (max-current ?x)))
              (not (current-too-strong2 ?x ?y)))))

(assert (forall ((?x boat) (?y river))
          (=> (not (current-too-strong2 ?x ?y))
              (not (> (current ?y) (max-current ?x))))))

(ask (current-too-strong2 raft1 nile))
;; THIS MUST RETURN TRUE:
(ask (not (current-too-strong2 raft1 nile)))


;;; PROVING DISJUNCTIONS:

(clear-module "TEST")

(defconcept PERSON (?p)
  :documentation "The class of PERSON beings.")
(defrelation happy ((?p PERSON)))
(defrelation married ((?p PERSON)))

(assert (forall (?x person)
                (=> (married ?x) (happy ?x))))

(assert (person fred))

(ask (or (not (married fred))
         (happy fred)))

(clear-module "TEST")

(defconcept PERSON (?p)
  :documentation "The class of PERSON beings.")

(defrelation happy ((?p PERSON)))
(defrelation rich ((?p PERSON)))
(defrelation married ((?p PERSON)))

(assert (forall (?x PERSON)
          (=> (or (rich ?x)
                  (and (married ?x)
                       (not (rich ?x))))
              (happy ?x))))

(assert (PERSON fred))
(assert (married fred))

(ask (happy fred))


;;; STRESS DUPLICATE SUBGOAL MECHANISM:

(clear-module "TEST")

(defconcept partially-tangible (?pt))

(defrelation between
    ((?a partially-tangible) (?b partially-tangible) (?c partially-tangible)))

(defrule Commutative-Between
  (forall ((?a Partially-Tangible)
           (?b Partially-Tangible)
           (?c Partially-Tangible))
    (=> (Between ?a ?b ?c)
        (Between ?a ?c ?b))))

(defrule Transitive-Between 
  (forall ((?a Partially-Tangible)
           (?b Partially-Tangible)
	   (?c Partially-Tangible)
           (?d Partially-Tangible))
    (=> (and (Between ?a ?d ?c)
             (Between ?b ?a ?c))
	(Between ?a ?d ?b))))

(assert (partially-tangible city1))
(assert (partially-tangible city2))
(assert (partially-tangible city3))
(assert (partially-tangible city4))

;; THIS NEEDS TO FAIL AFTER TRYING ALL POSSIBILITES:
(ask (between city1 city2 city3))

(assert (between city1 city3 city2))

;; TEST COMMUTATIVITY:
(ask (between city1 city2 city3))

(assert (between city4 city3 city1))

;; TEST TRANSITIVITY (THIS IS SLOW):
(ask (between city1 city4 city2))


;;; CLOSED RELATIONS:

(clear-module "TEST")

(defconcept PERSON (?p))
(defrelation nobel-prize-winner ((?p PERSON)))

(assert (PERSON fred))
(assert (PERSON einstein))
(assert (nobel-prize-winner einstein))

(ask (not (nobel-prize-winner fred)))
(ask (not (nobel-prize-winner einstein)))

(assert (closed nobel-prize-winner))

(ask (not (nobel-prize-winner fred)))
(ask (not (nobel-prize-winner einstein)))


;;; FORWARD INFERENCE WITH EQUAL FUNCTION TERMS

(clear-module "TEST")

(defconcept PERSON (?p))
(deffunction nof-brothers ((?p PERSON)) :-> (?n INTEGER))
(deffunction nof-sisters ((?p PERSON)) :-> (?n INTEGER))
(defrelation balanced-siblings ((?p PERSON)))

(assert (forall (?x PERSON)
          (=> (balanced-siblings ?x)
              (= (nof-brothers ?x) (nof-sisters ?x)))))

(assert (PERSON fred))

(assert (balanced-siblings fred))

(retrieve (?x integer) (= (NOF-BROTHERS fred) ?x))
(retrieve (?x integer) (= (NOF-SISTERS fred) ?x))

(assert (= (NOF-BROTHERS fred) 5))

(retrieve (?x integer) (= (NOF-SISTERS fred) ?x))
(retrieve (?x integer) (= (NOF-BROTHERS fred) ?x))


;;; INEQUALITY FUN:

(clear-module "TEST")

(defconcept PERSON (?p))
(deffunction height ((?p PERSON)) :-> (?h FLOAT))

;; THIS RULE ISN'T NEEDED ANYMORE:
;; BUG: CAN'T DEFINE A BICONDITIONAL:
;(defrule greater-implies-less
;    (forall ((?x NUMBER) (?y NUMBER))
;      (<=> (> ?x ?y) (< ?y ?x))))

(assert (PERSON fred))
(assert (> (height fred) 20.0))
(assert (PERSON joe))
(assert (< (height joe) 20.0))
(ask (< 20.0 (height fred)))
(ask (> 20.0 (height joe)))

(defconcept avlb (?avlb)
  :=> (< (traffic-class ?avlb) 17))
(deffunction traffic-class ((?avlb avlb)) :-> (?i INTEGER))

(assert (avlb b1))
(ask (< (traffic-class b1) 17))

;;; ENFORCING VARIABLE TYPES DURING FORWARD INFERENCE:

(clear-module "TEST")

(defconcept animal (?a))
(defconcept PERSON (?p))
(deffunction loved-by ((?a ANIMAL)) :-> (?p PERSON))

(defconcept dog (?d animal))
(defconcept cat (?c animal))

(defrelation loves ((?p PERSON) (?a animal)))

;; BELOW WE INTENTIONALLY DUPLICATE THE VARIABLE TYPE RESTRICTION `(cat ?c)',
;;    SINCE THAT EXPOSED A BUG IN THE SIMPLIFIER WHERE IT COMPLETELY LOST THEM:
(defrule cat-lover-rule
    (forall ((?p PERSON) (?c cat))
      (=> (and (cat ?c)
               (loves ?p ?c))
          (= (loved-by ?c) ?p))))

(assert (PERSON fred))
(assert (dog fido))
(assert (cat garfield))
(assert (loves fred garfield))

;;; THIS FAILS AS IT SHOULD:
(ask (loved-by fido fred))
;;; THIS SUCCEEDS:
(ask (loved-by garfield fred))

(propagate-constraints)

;;; AFTER CONSTRAINT PROPAGATION THIS MUST STILL FAIL:
(ask (loved-by fido fred))


;;; STATE MACHINE FUN:

(clear-module "TEST")

(defconcept a)

(defrelation r1 ((?a1 a) (?a2 a)))
(defrelation r2 ((?a1 a) (?a2 a)))

(assert (forall ((?a1 a) (?a2 a))
          (=> (r2 ?a1 ?a2)
              (r2 ?a2 ?a1))))

(assert (a a1))
(assert (a a2))
(assert (r2 a1 a2))

;; THIS EXPOSED A BUG IN THE STATE MACHINE:
(ask (or (r1 a2 a1)
         (r2 a2 a1)))


;;; FUNCTION INVERSES:

(clear-module "TEST")

(defconcept person (?p))
(deffunction boss ((?p PERSON)) :-> (?f PERSON))

(assert (person fred))
(assert (person john))
(assert (person susi))
(assert (person otto))

(assert (= (boss fred) otto))
(assert (= (boss john) otto))
(assert (= (boss otto) susi))

(retrieve all (?x person) (= (boss ?x) otto))
(retrieve all ((?x person) (?y person)) (= (boss ?x) ?y))


;;; ITERATIVE FORALL (SHOULD BECOME A STANDARD DEMO)

(clear-module "TEST")

(defconcept house (?h))
(defconcept person (?p))
(defrelation crazy ((?p PERSON)))
(deffunction lives-in ((?p PERSON)) :-> (?f HOUSE))

(defconcept nuthouse (?h house))

(defrule nuthouse-rule
    (forall (?h house)
      (=> (forall (?p person)
	    (=> (lives-in ?p ?h)
		(crazy ?p)))
	  (nuthouse ?h))))

(assert (closed person))

(assert (person fred))
(assert (person mary))
(assert (not (crazy fred)))
(assert (crazy mary))
(assert (house h1))
(assert (lives-in fred h1))
(assert (lives-in mary h1))

(ask (nuthouse h1))

(retract (not (crazy fred)))
(assert (crazy fred))

(ask (nuthouse h1))


;;; CONSTRAINT PROPAGATION BUG DURING HYPOTHETICAL REASONING:

(clear-module "TEST")

(defconcept person (?p))
(defrelation happy ((?p PERSON)))
(defrelation rich ((?p PERSON)))


(defrelation sibling ((?x person) (?y person)))

(assert (forall (?x person)
          (=> (happy ?x)
              (exists (?y person)
                (sibling ?x ?y)))))

(assert (person fred))

;; THIS NEEDS TO FAIL, BUT IT USED TO BREAK `mapped-value-of', SINCE
;; `*queryIterator*' WAS STILL VISIBLE DURING THE CONSTRAINT PROPAGATION
;; CAUSED BY THE ASSERTION IN THE HYPOTHETICAL WORLD:
(ask (or (rich fred)
         (not (happy fred))))


;;; EQUALITY REASONING BUG WITH NESTED FUNCTIONS:

(clear-module "TEST")

(defconcept person (?p))
(deffunction age ((?p PERSON)) :-> (?age INTEGER))
(deffunction golf-handicap ((?p PERSON)) :-> (?age INTEGER))
(deffunction son ((?p PERSON)) :-> (?f PERSON))

(assert (person fred))
(assert (person joe))
(assert (= (son Fred) Joe))
(assert (= (age Joe) 12))
(assert (= (golf-handicap Fred) (age (son Fred))))

;(propagate-constraints)

;; THIS MUST RETURN 12:
(retrieve all (?x integer) (= (golf-handicap Fred) ?x))

;; TRY AGAIN WITH DIFFERENT ORDER:
(clear-module "TEST")

(defconcept person (?p))
(deffunction age ((?p PERSON)) :-> (?age INTEGER))
(deffunction golf-handicap ((?p PERSON)) :-> (?age INTEGER))
(deffunction son ((?p PERSON)) :-> (?f PERSON))

(assert (person fred))
(assert (person joe))
(assert (= (age Joe) 12))
(assert (= (golf-handicap Fred) (age (son Fred))))
(assert (= (son Fred) Joe))

;(propagate-constraints)

;; THIS MUST RETURN 12:
(retrieve all (?x integer) (= (golf-handicap Fred) ?x))


;;; CONSTANT INTRODUCTION BUG:

(clear-module "TEST")

(defconcept person (?p))
(deffunction age ((?p PERSON)) :-> (?age INTEGER))
(deffunction golf-handicap ((?p PERSON)) :-> (?age INTEGER))
(deffunction son ((?p PERSON)) :-> (?f PERSON))

;; THIS USED TO BREAK BECAUSE OF MISSING TYPE INFERENCE:
(assert (and (person Mary)
             (= (age Mary) 3)))


;;; PROPOSITION ARGUMENTS BUG:

(clear-module "TEST")

(defconcept person (?p))
(deffunction age ((?p PERSON)) :-> (?age INTEGER))
(deffunction golf-handicap ((?p PERSON)) :-> (?age INTEGER))
(deffunction son ((?p PERSON)) :-> (?f PERSON))

(defrelation believes ((?x person) (?y proposition)))

(assert (person fred))
(assert (person joe))

(assert (believes fred (son fred joe)))

(retrieve (?x proposition) (believes fred ?x))
(retrieve ?x (believes fred ?x))

;;; TESTING RELATION HIERARCHY LOOKUP:

(clear-module "TEST")

(defconcept person (?p))
(defrelation happy ((?p person)))
(defrelation rich ((?p person)))
(assert (person fred))
(assert (forall (?x person) (=> (rich ?x) (happy ?x))))
(assert (rich fred))
(ask (happy fred))

;;; COMPLEMENT TEST

(clear-module "TEST")

(defconcept person (?P))
(defrelation parent ((?p1 person) (?p2 person)))
(defrelation grandparent ((?p person)))
(defrelation retired ((?p person)))
(assert (person fred))
(assert (not (grandparent fred)))
(assert (=> (AND (RETIRED ?X) (FAIL (PARENT ?X1 ?X))) (GRANDPARENT ?X)))
(assert (=> (AND (RETIRED ?X) (PARENT ?X1 ?X)) (NOT (GRANDPARENT ?X))))
(ask (not (grandparent fred)))

;;; HANDLING CLUSTERED OF CONJUNCTIONS:

(clear-module "TEST")

(set-feature trace-subgoals)

(defconcept person (?p))
(defrelation loves ((?x person) (?y person)))
(defrelation hates ((?x person) (?y person)))

(assert (person fred))
(assert (person john))
(assert (person susi))
(assert (person debbie))

(assert (loves fred susi))
(assert (hates john debbie))

;; MUST FAIL WITHOUT BACKTRACKING:
(retrieve all (?x ?y ?z ?zz)
          (and (loves ?x ?y)
               (loves ?y ?x)
               (hates ?z ?zz)
               (hates ?zz ?z)))

(assert (hates debbie john))

;; MUST FAIL WITHOUT BACKTRACKING:
(retrieve all (?x ?y ?z ?zz)
          (and (loves ?x ?y)
               (loves ?y ?x)
               (hates ?z ?zz)
               (hates ?zz ?z)))

(assert (loves susi fred))

;; 4 SOLUTIONS:
(retrieve all (?x ?y ?z ?zz)
          (and (loves ?x ?y)
               (loves ?y ?x)
               (hates ?z ?zz)
               (hates ?zz ?z)))

(unset-feature trace-subgoals)

;;; CLUSTERED CONJUNCTION BUG

(clear-module "TEST")

(defconcept project)
(defconcept person)
(defconcept research-area)
(defrelation works-on ((?u person) (?l project)))
(defrelation topic ((?p project) (?a thing)))
(defrelation related ((?t1 research-area) (?t2 research-area)))

(assert (project electric-elves))
(assert (project powerloom))
(assert (project sims))

(assert (topic electric-elves intelligent-agents))
(assert (topic powerloom knowledge-representation))
(assert (topic sims automated-planning))

(assert (related intelligent-agents knowledge-representation))
(assert (related automated-planning intelligent-agents))

(assert (works-on craig-knoblock electric-elves))
(assert (works-on craig-knoblock sims))

(assert (works-on hans-chalupsky electric-elves))
(assert (works-on hans-chalupsky powerloom))

(defrelation overlapping-interests
    ((?visitor PERSON) (?visitor-interest RESEARCH-AREA)
     (?staff PERSON) (?staff-interest RESEARCH-AREA))
  :<= (and (exists (?project)
	     (and (works-on ?visitor ?project)
		  (topic ?project ?visitor-interest)))
	   (exists (?project)
	     (and (works-on ?staff ?project)
		  (topic ?project ?staff-interest)))
           ;; THIS WOULD PREVENT CLUSTERING:
           ;(not (= ?visitor ?staff))
           ;; RESIDUE GOAL, DO BACKTRACK IF WE FAIL HERE:
	   (or (related ?visitor-interest ?staff-interest)
               (related ?staff-interest ?visitor-interest))))

;;; 8 SOLUTIONS:
(retrieve all (?v ?vi ?s ?si) (overlapping-interests ?v ?vi ?s ?si))

;;; LAZY SATELITES PROBLEM:

(clear-module "TEST")
(defconcept person (?x))
(defrelation happy ((?x person)))
(defrelation rich ((?x person)))
(assert (forall (?x person)
           (=> (rich ?x) (happy ?x))))

(assert (person fred))
(assert (not (happy fred)))

;;;THIS SHOULD RETURN FRED EVEN IF WE USE LAZY SATELLITES
(retrieve all ?x (and (person ?x) (not (rich ?x))))

;;; ASSERTION LOOKUP WITH EQUALITY AND SPECIALIZING RELATIONS

(clear-module "TEST")
(defconcept person (?x))
(deffunction boss ((?x person)) :-> (?b person))
(deffunction father ((?x person)) :-> (?f person))
(deffunction mother ((?x person)) :-> (?m person))
(defrelation rich ((?x person)))
(defrelation happy ((?x person)))

(assert (forall (?x person) (=> (rich ?x) (happy ?x))))
(assert (person fred))
(assert (person frank))
(assert (person susi))
(assert (rich (father frank)))
(assert (= (father frank) (boss fred)))

(ask (happy (father frank)))
(ask (happy (boss fred)))
(retrieve all (?x person) (happy ?x))

;;; DON'T PICK UP DUPLICATE PROPOSITIONS/DESCRIPTIONS FROM UNRELATED CONTEXTS

(clear-module "TEST")
(defmodule "TEST/TEMP-A")
(defmodule "TEST/TEMP-B")

(defconcept person (?x))
(defrelation parent ((?x person) (?y person)))
(defrelation child ((?x person) (?y person)))
(deffunction age ((?x person)) :-> (?a INTEGER))
(assert (person fred))
(assert (person susi))

(cc "TEST/TEMP-A")
(assert (parent fred susi))
(assert (= (age fred) 42))
(assert (forall (?x ?y) (=> (parent ?x ?y) (child ?y ?x))))
(cc "TEST/TEMP-B")
(assert (parent fred susi))
(assert (= (age fred) 42))
(assert (forall (?x ?y) (=> (parent ?x ?y) (child ?y ?x))))
(clear-module "TEST/TEMP-A")
;;; NOW THESE MUST STILL RETURN TRUE:
(ask (parent fred susi))
(ask (= (age fred) 42))
(ask (child susi fred))
(cc test)

;;; EQUALITY/FORWARD-INFERENCE PROBLEMS

(clear-module "TEST")
(defconcept person (?x))
(deffunction boss ((?x person)) :-> (?f person))
(defrelation employee-of ((?emp person) (?boss person)))

(assert (forall (?emp ?boss)
          (=> (employee-of ?emp ?boss)
              (= (boss ?emp) ?boss))))

(assert (person fred))
(assert (person frank))
(assert (person susi))

(assert (= (boss fred) (boss susi)))
(assert (employee-of fred frank))
;;; FIX: SHOULD RETURN FRANK
(retrieve ?x (= (boss susi) ?x))
;;; FIX: SHOULD RETURN FRANK
(retrieve ?x (= (boss fred) ?x))
;;; FIX: SHOULD RETURN FRANK
(retrieve ?x (= (boss susi) ?x))

;;; VARIANT: FIX DIFFERENT FORWARD-INF BEHAVIOR BETWEEN RULES THAT TURN
;;;    INTO IMPLIES PROPOSITIONS AND OTHER RULES:
(clear-module "TEST")
(defconcept person (?x))
(deffunction boss ((?x person)) :-> (?f person))
;;; THIS DOESN'T TURN INTO AN IMPLIES:
(defrelation has-employee ((?boss person) (?emp person)))

(assert (forall (?emp ?boss)
          (=> (has-employee ?boss ?emp)
              (= (boss ?emp) ?boss))))

(assert (person fred))
(assert (person frank))
(assert (person susi))

(assert (= (boss fred) (boss susi)))
(assert (has-employee frank fred))
;;; FIX: STILL DOESN'T RETURN FRANK
(retrieve ?x (= (boss susi) ?x))
(retrieve ?x (= (boss fred) ?x))
;;; BUT NOW IT DOES (ELABORATION ABOVE WASN'T GOOD ENOUGH)
(retrieve ?x (= (boss susi) ?x))

;;; INCREMENTAL RE-ELABORATION FOR META-ASSERTIONS:

(clear-module "TEST")
(defrelation foo (?x ?y))
(assert (symmetric foo))
(assert (reflexive foo))
(assert (foo a b))
;; THESE MUST BOTH BE TRUE:
(ask (foo b a))
(ask (foo b b))

(defrelation foo2 (?x ?y))
(assert (reflexive foo2))
;; THIS STILL WORKS:
(ask (foo2 a a))
(assert (symmetric foo2))
(assert (foo2 a b))
;; THIS MUST STILL BE TRUE (IT WASN'T ALWAYS):
(ask (foo2 b a))

;;; USING NON-ATOMIC RELATION TERMS:

(clear-module "TEST")
(deffunction rfn (?x) :-> (?v relation))
(deffunction ffn (?x) :-> (?v function))
(deffunction cfn (?x) :-> (?v class))

(assert ((rfn a) b))
(ask (relation (rfn a)))
(ask (class (rfn a)))
(ask (function (rfn a)))
(retrieve ?x (arity (rfn a) ?x))
(retrieve all ?x ((rfn a) ?x))

(assert ((ffn a) b c))
(ask (relation (ffn a)))
(ask (class (ffn a)))
(ask (function (ffn a)))
(retrieve ?x (arity (ffn a) ?x))
(retrieve all ?x ((ffn a) b ?x))

(assert ((cfn a) b))
(ask (relation (cfn a)))
(ask (class (cfn a)))
(ask (function (cfn a)))
(retrieve ?x (arity (cfn a) ?x))
(retrieve all ?x ((cfn a) ?x))

(assert (exists (?x) (= (rfn b) ?x)))
(ask (exists (?x) (= (rfn b) ?x)))
(assert (holds (rfn b) c))
(ask (exists (?x) (= (rfn b) ?x)))
(retrieve all ?x ((rfn b) ?x))

;;; DIFFERENT FUNCTION VALUES CAN HAVE DIFFERENT ARITIES:
(assert ((rfn c) d))
(retrieve ?x (arity (rfn c) ?x))
(assert ((rfn d) e f g))
(retrieve ?x (arity (rfn d) ?x))
;;; FIX: WE SHOULD GET AN ARITY VIOLATION HERE:
(assert ((rfn d) e f))
(retrieve ?x (arity (rfn d) ?x))

;;; PRIOR ASSERTION CAN CONTROL THE NATURE OF THE RELATION DESCRIPTION:
(assert (function (rfn e)))
(assert (variable-arity (rfn e)))
(assert ((rfn e) f g))
(ask (function (rfn e)))
(ask (variable-arity (rfn e)))
(retrieve ?x (arity (rfn e) ?x))
(retrieve all ?x ((rfn e) f ?x))

;;; DON'T LOSE ASSERTIONS DURING SURROGATIFICATION:
(assert ((cfn b) (rfn f)))
(assert ((rfn f) g))
(ask ((cfn b) (rfn f)))

;;; DIFFERENT SYNTAXES, MAKE SURE WE PROPERLY PICK UP DUPLICATES:
(assert (function (rfn g)))
(assert (= ((rfn g) h) x))
(assert ((rfn g) h x))
(assert (= (value (rfn g) h) x))
(assert (value (rfn g) h x))
;;; WE SHOULD ONLY SEE ONE FUNCTION PROP HERE:
(all-facts-of "X")

(assert (= ((ffn g) h) y))
(assert ((ffn g) h y))
(assert (= (value (ffn g) h) y))
(assert (value (ffn g) h y))
;;; WE SHOULD ONLY SEE ONE FUNCTION PROP HERE:
(all-facts-of "Y")

(assert (= ((ffn h) i) j))
(assert (= (value (ffn h) i) j))
(assert ((ffn i) j ((ffn h) i)))
(assert ((ffn i) j (value (ffn h) i)))
;;; THIS MUST ONLY RETURN ONE SOLUTION:
(retrieve all ?x ((ffn i) j ?x))

;;; RULES:
(assert (forall (?x ?y)
          (=> ((rfn h) ?x ?y)
              ((rfn i) ?y ?x))))
(assert ((rfn h) i j))
(ask ((rfn i) j i))

(assert (forall (?x ?y)
          (=> (= ((ffn j) ?x) ?y)
              (= ((ffn k) ?y) ?x))))
(assert (= ((ffn j) a) b))
(assert (= ((ffn j) c) d))
(ask (= ((ffn k) b) a))
(retrieve all (?x ?y) (= ((ffn k) ?x) ?y))

;;; GENERATING `SETOF' ELEMENTS FROM EQUIVALENT SKOLEMS:

(clear-module "TEST")

(defconcept person)
(deffunction friends ((?p person)) :-> (?f set))

(assert (= (setof hans franz) (friends fred)))
(assert (= (friends hans) (setof fred franz)))

;;; TRY BOTH ARGUMENT ORDERS:
(retrieve all ?f (member-of ?f (friends fred)))
(retrieve all ?f (member-of ?f (friends hans)))

;;; PROPER HANDLING OF FULLY GROUND FUNCTION TERMS IN `INHERIT-DESCRIPTION':

(clear-module "TEST")

(defconcept person)
(deffunction friends ((?p person)) :-> (?f set))

;;; USES FULLY GROUND TERM `(friends hans)', WE DON'T WANT ITS OUTPUT TO
;;;    BECOME SKOLEMIZED, INSTEAD WE WANT TO USE THE FUNCTION OUTPUT SKOLEM:
(defconcept friend-of-hans (?x)
            :<<=>> (member-of ?x (friends hans)))

(defconcept has-hans-as-friend (?x)
            :<<=>> (member-of hans (friends ?x)))

(assert (person hans))
(assert (person otto))
(assert (person karl))
(assert (friend-of-hans otto))
(assert (has-hans-as-friend karl))

(ask (friend-of-hans otto))
(ask (has-hans-as-friend karl))

;;; THIS MUST RETURN `(FRIENDS HANS)', NOT AN ANONYMOUS SKOLEM:
(retrieve all ?x (member-of otto ?x))
(retrieve all ?x (member-of hans ?x))

;;; PROPER COMBINATION OF SUBRELATION LINKS AND RULES:

(clear-module "TEST")

(defrelation sibling-of (?x ?y))
(defrelation brother-of (?x ?y))
(defrelation son-of (?x ?y))

(assert (forall (?x ?y)
          (=> (brother-of ?x ?y)
              (sibling-of ?x ?y))))

(assert (forall (?x ?y ?f)
          (=> (and (son-of ?x ?f)
                   (son-of ?y ?f)
                   (not (= ?x ?y)))
              (brother-of ?x ?y))))

(assert (son-of hans dad))
(assert (son-of franz dad))

;;; THIS SHOULD RETURN TRUE:
(ask (sibling-of hans franz))

;;; SUBSUMPTION TESTS AND INTERVAL UNIFICATION:

(clear-module "TEST")

(defconcept person)
(deffunction age ((?x person)) :-> (?y integer))
(defconcept teenager ((?x person)) :<=> (and (person ?x)
                                             (< (age ?x) 20)
                                             (> (age ?x) 12)))

(assert (and (person mike) (age mike 15)))
(ask (teenager mike))

;;; SHOULD BE TRUE - CURRENTLY FAILS BECAUSE OF A STUPID ANTECEDENT
;;; TYPE CHECK FAILURE; SETTING `*type-check-strategy*' TO :NONE FIXES IT:
(ask (forall ?x (=> (and (person ?x)
                         (< (age ?x) 20)
                         (> (age ?x) 12))
                    (teenager ?x))))
;;; SHOULD BE TRUE:
(ask (subset-of (kappa (?x)
                  (and (person ?x)
                       (< (age ?x) 20)
                       (> (age ?x) 12)))
                teenager))

;;; SHOULD BE TRUE:
(ask (forall ?x (=> (and (person ?x)
                         (< (age ?x) 20)
                         (> (age ?x) 15))
                    (teenager ?x))))
;;; SHOULD BE TRUE:
(ask (subset-of (kappa (?x)
                  (and (person ?x)
                       (< (age ?x) 20)
                       (> (age ?x) 15)))
                teenager))

;;; THIS SHOULD RETURN FALSE OR AT LEAST UNKNOWN:
(ask (forall ?x (=> (and (person ?x)
                         (< (age ?x) 23)
                         (> (age ?x) 15))
                    (teenager ?x))))
;;; THIS SHOULD RETURN FALSE OR AT LEAST UNKNOWN:
(ask (subset-of (kappa (?x)
                  (and (person ?x)
                       (< (age ?x) 23)
                       (> (age ?x) 15)))
                teenager))

;;; INVERSE VALUE CLASH:

(clear-module "TEST")

(defconcept person)
(deffunction age ((?x Person)) :-> (?y number))

(assert (age Jeff 42))

(ask (age Jeff 21))
;;; FIX: THIS SHOULD BE TRUE:
(ask (not (age Jeff 21)))

;;; PROPER OPTIMIZATION OF HOLDS GOALS:

(clear-module "TEST")

(defconcept meta-property)
(defconcept extensional)
(defconcept entity)

(defconcept extensional-p (?p)
            :<=> (and (meta-property ?p)        
                      (forall ?x
                        (=> (and (entity ?x)
                                 (?p ?x))
                            (extensional ?x)))))

(defconcept test-class (?x entity)
            :axioms (extensional-p test-class))

(assert (test-class fred))

;;; THESE SHOULD ALL RETURN TRUE:
(ask (extensional fred))
(ask (holds test-class fred))
(ask (extensional fred))

;;; PROPER HANDLING OF INEQUALITY RETRACTION

(clear-module "TEST")

(deffunction age (?p) :-> (?a integer))

(assert (< (age bill) 12))
(assert (> (age bill) 10))

;;; SHOULD RETURN 11:
(retrieve ?x (= (age bill) ?x))

(retract (< (age bill) 12))

;;; SHOULD RETURN THE SKOLEM ONLY:
(retrieve ?x (= (age bill) ?x))

;;; TEST CLASH WITH ENUMERATED SETS VIA MEMBER-OF EVALUATOR:

(clear-module "TEST")

(defconcept Primary-Color (?c)
  :<<=>> (member-of ?c (setof Red Green Blue)))

(deffunction favorite-color (?x ?y))

(assert (primary-color red))
(assert (primary-color (favorite-color joe)))

;;; SHOULD GENERATE 4 SOLUTIONS:
(retrieve all (?x) (Primary-Color ?x))

(assert (primary-color pink))

;;; SHOULD GENERATE 5 SOLUTIONS AND A CLASH:
(retrieve all (?x) (Primary-Color ?x))

;;; REDEFINITION TESTS

(clear-module "TEST")

(defconcept A
  :documentation "doc"
  :synonym A-SYN)

(defrelation r (?x))
(assert (r a))
(assert (synonym a a-syn2))

(retrieve all ?x (documentation a ?x))
(retrieve all ?x (documentation a-syn ?x))
(retrieve all ?x (documentation a-syn2 ?x))
(ask (r a))

(defconcept A
  :documentation "doc2")

(retrieve all ?x (documentation a ?x))
(retrieve all ?x (documentation a-syn ?x))
(retrieve all ?x (documentation a-syn2 ?x))
(ask (r a))

(defproposition P (r foo)
  :documentation "doc"
  :synonym P-SYN)

(assert (r p))
(assert (synonym p p-syn2))

(retrieve all ?x (documentation p ?x))
(retrieve all ?x (documentation p-syn ?x))
(retrieve all ?x (documentation p-syn2 ?x))
(ask (r p))

(defproposition P (r foo)
  :documentation "doc2")

(retrieve all ?x (documentation p ?x))
(retrieve all ?x (documentation p-syn ?x))
(retrieve all ?x (documentation p-syn2 ?x))
(ask (r p))

;;; TEST AGAIN BUT BEFORE A's AXIOMS ARE FINALIZED:

(clear-module "TEST")

(defconcept A
  :documentation "doc"
  :synonym A-SYN)

(defrelation r (?x))
(assert (r a))
(assert (synonym a a-syn2))

(defconcept A
  :documentation "doc2")

(retrieve all ?x (documentation a ?x))
(retrieve all ?x (documentation a-syn ?x))
(retrieve all ?x (documentation a-syn2 ?x))
(ask (r a))

(defproposition P (r foo)
  :documentation "doc"
  :synonym P-SYN)

(assert (r p))
(assert (synonym p p-syn2))

(defproposition P (r foo)
  :documentation "doc2")

(retrieve all ?x (documentation p ?x))
(retrieve all ?x (documentation p-syn ?x))
(retrieve all ?x (documentation p-syn2 ?x))
(ask (r p))

;;; TEST PROPER REDEFINITION OF SATELLITE RULES:

(clear-module "TEST")

(defrelation r (?x ?y))
(defrelation s (?x ?y))

(defproposition p1 (=> (r ?x ?y) (s ?y ?x))
  :backward-only? true)

(assert (r a b))
(ask (s b a))

(unset-feature just-in-time-inference)

(defproposition p1 (=> (r ?x ?y) (s ?y ?x))
  :forward-only? true)

;;; SHOULD BE UNKNOWN:
(ask (s b a))

(set-feature just-in-time-inference)

;;; SHOULD BE TRUE:
(ask (s b a))

;;; TEST INSTANTIATION OF DESCRIPTIONS WITH EXTERNAL VARIABLES:

(clear-module "TEST")

(defrelation brother (?x ?y)
  :closed true)

(assert (and (brother fred joe)
             (brother fred john)
             (brother susi fred)))

;;; SHOULD RETURN FRED AND 2:
(retrieve all (?x ?c)
          (and (brother susi ?x)
               (= (cardinality (setofall (?f) (brother ?x ?f))) ?c)))
;;; SHOULD RETURN FRED AND 2:
(retrieve all (?c ?x)
          (and (brother susi ?x)
               (= (cardinality (setofall (?f) (brother ?x ?f))) ?c)))

;;; FORWARD-INSTANTIATING FUNCTION RULES:

(clear-module "TEST")

(deffunction r (?x ?y) :<=> (s ?y ?x))
(deffunction s (?x ?y) :<=> (r ?y ?x))

(assert (r fred wilma))
(assert (r barney betty))

;;; SHOULD GENERATE 2 SOLUTIONS AND NOT BREAK WITH EVER GROWING FN TERMS
;;; BY PROPERLY INSTANTIATING ON THE VALUES INSTEAD OF THE OUTPUT SKOLEMS:
(retrieve all (s ?x ?y))

;;; TEST MEMBER-OF ON DESCRIPTION ARGUMENTS:

(clear-module "TEST")

;;; SHOULD GENERATE 3 SOLUTIONS EACH:
(retrieve 3 (member-of ?super
                       (setofall ?x
                         (superrelation concept ?x))))

(retrieve all (member-of ?x (kappa (?y) (member-of ?y (setof "a" "b" "c")))))

;;; TEST CASES FOR UNASSERT & RETRACT:

(clear-module "TEST")

(defrelation happy (?x))
(deffunction father (?x ?y))

(assert (happy fred))
(unassert (happy fred))
(ask (happy fred))

(assert (not (happy fred)))
(unassert (happy fred))
(ask (not (happy fred)))

(assert (happy fred))
(unassert (not (happy fred)))
(ask (happy fred))

(assert (happy fred))
(assert (happy joe))
(unassert (and (happy fred) (happy joe)))
(ask (happy fred))
(ask (happy joe))

(assert (not (happy fred)))
(assert (happy joe))
(unassert (and (happy fred) (happy joe)))
(ask (not (happy fred)))
(ask (happy joe))

;;; UNASSERTING CONTRADICTIONS:
(assert (happy fred))
(assert (not (happy fred)))
(ask (happy fred))
(unassert (happy fred))
(ask (happy fred))
(assert (happy fred))
(ask (happy fred))
(assert (not (happy fred)))
(ask (happy fred))
(unassert (not (happy fred)))
(ask (happy fred))
(assert (happy fred))
(ask (happy fred))

(assert (= (father fred) dad))
(unassert (= (father fred) dad))
(ask (= (father fred) dad))

;;; FIXED RETRACTION BUG WITH TWO FUNCTION PROPOSITION WITH SAME VALUE:
(assert (= (father fred) dad))
(assert (= (father joe) dad))
(retract (= (father fred) dad))
(ask (= (father fred) dad))

(assert (= (father fred) dad))
(assert (= (father joe) dad))
(retract (= (father joe) dad))
(ask (= (father joe) dad))

(assert (= (father fred) dad))
(assert (= (father joe) dad))
(unassert (= (father fred) dad))
(ask (= (father fred) dad))

(assert (= (father fred) dad))
(assert (= (father joe) dad))
(unassert (= (father joe) dad))
(ask (= (father joe) dad))
