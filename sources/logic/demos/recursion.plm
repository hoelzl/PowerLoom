;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; Version: recursion.plm,v 1.10 2003/10/16 02:26:16 hans Exp


;;; Inference along parent and ancestor relations with recursive rules
;;; ==================================================================

;;; This file demonstrates that PowerLoom automatically handles
;;; reasoning with recursive rules despite its use of a Prolog-style
;;; backward chainer (in Prolog, recursive rules rules have to be
;;; handled by carefully ordering them to avoid infinite recursion).
;;; The example uses `parent' and `ancestor' relations, since those
;;; naturally lend themselves to recursive formulations.  The file
;;; also demonstrates the use of `PowerLoom's `defrelation' command.

;;; The best way to view this file is by calling `(demo)' and
;;; selecting it from the menu of example demos.  This demo assumes
;;; familiarity with some basic PowerLoom concepts which are described
;;; in the introductory demo (#1 on the demo menu) and other demos
;;; preceding this one.


;; Standard demo preamble:

(in-package "STELLA")

(defmodule "/PL-KERNEL/PL-USER/RECURSION")

(in-module "RECURSION")

(clear-module "RECURSION")
(reset-features)

(in-dialect :KIF)


;; The already familiar `Person' class:

(defconcept PERSON (?p)
  :documentation "The class of human beings.")

(defrelation happy ((?p PERSON)))
(deffunction age ((?p PERSON)) :-> (?a INTEGER))

;; Now we define two relations `has-parent' and `has-ancestor' with
;; PowerLoom's `defrelation' command.  `defrelation' is very similar
;; to `deffunction' (see the `append' demo), with the main difference
;; that it does not take a `:->' specification, since relations are
;; boolean-valued.  Similar to functions, relations are polymorphic
;; (indexed on the type of their first argument) unless they were
;; defined with `:polymorphic?' set to FALSE.  Note again, that
;; functions and relations must be defined before they can be used in
;; any assertion or query.

(defrelation has-parent ((?p PERSON) (?parent PERSON))
  :documentation "True if `self' has `parent' as a parent.")

(defrelation has-ancestor ((?p PERSON) (?ancestor PERSON))
  :documentation "True if `self' has `ancestor' as an ancestor.")

;; Rule 1: All parents are ancestors:

(assert (forall ((?x PERSON) (?y PERSON))
          (=> (has-parent ?x ?y)
              (has-ancestor ?x ?y))))

;; Rule 2: Transitivity of ancestor relations: If `?y' is an ancestor of
;; `?x' and `?z' is an ancestor of `?y' then `?z' is also an ancestor of
;; `?x'.  This rule is recursive, since its consequent (or head) defines a
;; `has-ancestor' relationship by recursively referencing `has-ancestor'
;; in its antecedent (or tail).  A naive backward chaining architecture
;; would backchain into the consequent and simply post the two new
;; `has-ancestor' subgoals from the rule's antecedent.  However, these
;; subgoals might be duplicates of the original goal which could lead to
;; infinite subgoaling.  This is actually the strategy used by Prolog, and
;; there rule recursion has to be handled by hand using knowledge of the
;; order in which rules and clauses are processed and carefully ordering
;; them to avoid infinite recursion.  In PowerLoom the order of assertions
;; is completely irrelevant, and duplicate subgoals are detected
;; automatically.  This is an important feature, since recursion is a very
;; natural and powerful way to formulate axioms or rules, and people often
;; write recursive rules without even realizing that they do:

(assert (forall ((?x PERSON) (?z PERSON))
          (=> (exists (?y PERSON)
                (and (has-ancestor ?x ?y)
                     (has-ancestor ?y ?z))) 
              (has-ancestor ?x ?z))))

;; Let us create some people (note, that the top-level `and' gets optimized
;; away to leave only assertions of the individual conjuncts):

(assert (and (Person Abby) (Person Benny) (Person Carla)
             (Person Debbie) (Person Edward) (Person Fred)))

;; Some parent and ancestor relationships we know about:

(assert (has-parent Abby Benny))
(assert (has-ancestor Benny Carla))
(assert (has-parent Carla Debbie))
(assert (has-ancestor Debbie Edward))
(assert (has-parent Edward Fred))

;; First, let us derive Abby's ancestors using PowerLoom's incremental
;; query machinery.  Remember, that a `retrieve' without a specification
;; of a desired number of solutions generates at most one solution:

(retrieve (?z PERSON) (has-ancestor Abby ?z))

;; More solutions of the most recent query can be generated by calling
;; `retrieve' without the query arguments (a desired number of new
;; solutions can still be specified):

(retrieve 2)
(retrieve)
(retrieve)
(retrieve)

;; Now let us retrieve all ancestors of all other people:

(retrieve all (?z PERSON) (has-ancestor Benny ?z))
(retrieve all (?z PERSON) (has-ancestor Carla ?z))
(retrieve all (?z PERSON) (has-ancestor Debbie ?z))
(retrieve all (?z PERSON) (has-ancestor Edward ?z))
(retrieve all (?z PERSON) (has-ancestor Fred ?z))
