;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;; BEGIN LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
; Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          ;
;                                                                            ;
; The contents of this file are subject to the Mozilla Public License        ;
; Version 1.1 (the "License"); you may not use this file except in           ;
; compliance with the License. You may obtain a copy of the License at       ;
; http://www.mozilla.org/MPL/                                                ;
;                                                                            ;
; Software distributed under the License is distributed on an "AS IS" basis, ;
; WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   ;
; for the specific language governing rights and limitations under the       ;
; License.                                                                   ;
;                                                                            ;
; The Original Code is the PowerLoom KR&R System.                            ;
;                                                                            ;
; The Initial Developer of the Original Code is                              ;
; UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          ;
; 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               ;
;                                                                            ;
; Portions created by the Initial Developer are Copyright (C) 1997-2006      ;
; the Initial Developer. All Rights Reserved.                                ;
;                                                                            ;
; Contributor(s):                                                            ;
;                                                                            ;
; Alternatively, the contents of this file may be used under the terms of    ;
; either the GNU General Public License Version 2 or later (the "GPL"), or   ;
; the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   ;
; in which case the provisions of the GPL or the LGPL are applicable instead ;
; of those above. If you wish to allow use of your version of this file only ;
; under the terms of either the GPL or the LGPL, and not to allow others to  ;
; use your version of this file under the terms of the MPL, indicate your    ;
; decision by deleting the provisions above and replace them with the notice ;
; and other provisions required by the GPL or the LGPL. If you do not delete ;
; the provisions above, a recipient may use your version of this file under  ;
; the terms of any one of the MPL, the GPL or the LGPL.                      ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; END LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; Version: propositions.ste,v 1.189 2006/05/14 07:34:02 hans Exp

;;; Parsing and constructing propositions.

(in-package "STELLA")

(in-module "LOGIC")


(deftype PROPOSITIONS-INDEX (SEQUENCE-INDEX OF PROPOSITION))
(deftype INSTANCES-INDEX (SEQUENCE-INDEX OF LOGIC-OBJECT))

(defclass BACKLINKS-INDEX (STANDARD-OBJECT)
  :documentation "Contains several types of indices pointing at dependent propositions."
  :slots
  ((dependent-propositions-list :type PROPOSITIONS-INDEX)
   (dependent-isa-propositions-list :type PROPOSITIONS-INDEX)
   (predicate-propositions-table
    :type (HASH-TABLE OF SURROGATE PROPOSITIONS-INDEX))
   ))

(defclass BACKLINKS-MIXIN ()
  :documentation "Inherited by objects that point back at propositions that reference
them."
  :slots ((dependent-propositions-index :type BACKLINKS-INDEX))
  :mixin? TRUE)

(defclass LOGIC-OBJECT (CONTEXT-SENSITIVE-OBJECT DYNAMIC-SLOTS-MIXIN BACKLINKS-MIXIN)
  :documentation "Object with propositions, and possibly a variable value."
  :public-slots 
  ((home-context :initially *module*) ;; prevent creation in volatile inference worlds
   (variable-value-inverse :type (CONS OF LOGIC-OBJECT)
                           :default NIL :context-sensitive? TRUE)
   (equivalent-value :type DESCRIPTION :context-sensitive? TRUE
                     :allocation :dynamic)
   (surrogate-value-inverse :type SURROGATE)
   (undeclared? :type BOOLEAN :allocation :dynamic)
   (hypothesized-instance? :type BOOLEAN :allocation :dynamic)
   (object-stringified-source :type STRING :allocation :dynamic
     ;; use accessors, since we make this into a real slot on descriptions:
     :reader stringified-source :writer stringified-source-setter)
   (object-originated-propositions :type (LIST OF PROPOSITION)
     :default NIL-LIST :allocation :dynamic
     ;; use accessors, since we make this into a real slot on descriptions:
     :reader originated-propositions :writer originated-propositions-setter
     :documentation "List of propositions generated by the definition of
this object."))
  :print-form (print-top-level-object self stream)
  :initializer log-logic-object)

(defclass LOGIC-THING (THING)
  :documentation "A subclass of THING so we can add methods to it in
the PowerLoom LOGIC module."
  )

(defun log-logic-object ((self LOGIC-OBJECT))
  ;; Attach 'self' to the current context.
  ;; But, don't log objects inside of descriptions, and don't
  ;;    log pattern variables.
  (when (or (description-mode?)
            (isa? self @PATTERN-VARIABLE))
    (return))
  ;; this is not valid anymore, given that we now allocate objects in modules:
  ;(safety 3 (eql? (home-context self) *context*) "CXT INITIALIZE BUG")
  (when (not *loadingRegenerableObjects?*)
    (push (locally-conceived-instances *context*) self)) )

(defclass SKOLEM (LOGIC-OBJECT)
  :documentation "Object whose identity and type are not fixed at creation time.
Potentially unifiable with any other object."
  :public-slots
  ((skolem-type :type TYPE)
   (skolem-name :type SYMBOL)
   (variable-value :type OBJECT :context-sensitive? TRUE)
   (defining-proposition :type PROPOSITION)
   ))

(defclass PATTERN-VARIABLE (SKOLEM)
  :documentation "A variable in a logical expression."
  :slots 
  ((bound-to-offset :type INTEGER)
   (original-skolem-name :type SYMBOL :allocation :dynamic)
   (variable-name :renames skolem-name)))

(deftype OBJECT-VECTOR (VECTOR OF OBJECT))
(deftype ARGUMENTS-VECTOR OBJECT-VECTOR)
(deftype VARIABLES-VECTOR (VECTOR OF PATTERN-VARIABLE))

(defconstant ZERO-VARIABLES-VECTOR VARIABLES-VECTOR
  (new VARIABLES-VECTOR :array-size 0)
  :documentation "Save space by structure-sharing zero-length variable vectors.")

(defclass FORWARD-CHAINING-INDEX (STANDARD-OBJECT)
  :slots ((forward-goal :type PROPOSITION)
          (master-rule :type PROPOSITION)
          (io-variables :type CONS)
          (query-body :type CONS)
          (input-bindings :type CONS)
          (cache-id :type SYMBOL)
          (consequent :type DESCRIPTION)))

(defclass DESCRIPTION (LOGIC-OBJECT)
  :public-slots
  ((proposition :type PROPOSITION)
   (io-variables :type VARIABLES-VECTOR)
   (internal-variables :type VARIABLES-VECTOR :initially ZERO-VARIABLES-VECTOR
     :documentation "The set of internally quantified variables besides the
descriptions's IO variables.  This set includes any top-level implicit
existential variables plus any variables introduced by some nested quantifier.
IMPORTANT: therefore, a description's internal variables are not necessarily
equivalent to its top-level implicit existential variables.")
   (external-variables :type VARIABLES-VECTOR :allocation :dynamic)
   (query-patterns :type (KEY-VALUE-LIST OF BOOLEAN-VECTOR DESCRIPTION))
   (complement-description :type DESCRIPTION :allocation :dynamic)
   (relative-complement :renames complement-description)
   ;; NOT USED:
   (taxonomy-node :type TAXONOMY-NODE :allocation :dynamic)
   (iota? :type BOOLEAN :allocation :dynamic)
   (dont-optimize? :type BOOLEAN :allocation :dynamic)
   (forward-chaining-indices :type (LIST OF FORWARD-CHAINING-INDEX)
			     :allocation :dynamic)
   (rules-with-deferred-satellites :type PROPOSITIONS-INDEX
				   :allocation :dynamic)
   (deferred-contrapositives? :type BOOLEAN-WRAPPER :allocation :dynamic
			      :default FALSE))
  :methods
  ((native-relation ((self DESCRIPTION)) :type RELATION (return NULL))))

(defclass NAMED-DESCRIPTION (DESCRIPTION)
  ;; Description that has a surrogate.
  :public-slots
  ((io-variable-names :type (LIST OF SYMBOL))
   (io-variable-types :type (LIST OF TYPE))
   (extension :type PROPOSITIONS-INDEX)
   (object-stringified-source :allocation :instance)
   (object-originated-propositions :type (LIST OF PROPOSITION)
     :default NIL-LIST :allocation :instance
     :documentation "List of propositions generated by the definition of
this description.")
   (native-relation-back-pointer :type RELATION :allocation :dynamic)
   ;; accelerate caching (quick test for non-cached description):
   (check-for-cached-goals? :type BOOLEAN :allocation :dynamic)
   ;; NOTHING FILLS THIS (BUT THE OPTIMIZER USES IT):
   (inverse-description :type NAMED-DESCRIPTION :allocation :dynamic))
  :methods
  ((native-relation
    ((self NAMED-DESCRIPTION)) :type RELATION
    (return (native-relation-back-pointer self)))
   (native-relation-setter
    ((self NAMED-DESCRIPTION) (value RELATION))
    (setf (native-relation-back-pointer self) value))))

(deftype PARTIAL-MATCH-SCORE FLOAT)

(deftype SET-OF-SUPPORT LIST)

(deftype TIMESTAMP INTEGER)

(defclass TRUTH-VALUE (LOGIC-OBJECT)
  :public-slots
  ((polarity :type KEYWORD :initially :UNKNOWN
             :documentation "One of :TRUE, :FALSE, :UNKNOWN or :INCONSISTENT.")
   (strength :type KEYWORD :initially NULL
             :documentation "Either NULL, :STRICT or :DEFAULT.")
   (positive-score :type PARTIAL-MATCH-SCORE :initially 0.0)))

(defclass PARTIAL-SUPPORT (STANDARD-OBJECT)
  :public-slots  ;; support for modus ponus inference
  ((fact :type PROPOSITION)
   (axiom :type PROPOSITION)
   (score :type FLOAT)
   (id :type Integer) ;; used for loop checking during NN training
   ;; arg-scores are necessary to to save because the scores on fact
   ;; will get overwritten if the rule is used again during the proof.
   (argument-scores :type (CONS of FLOAT-WRAPPER)))) 
(defglobal *partial-support-counter* integer 0)

;; QUESTION: CAN WE ELIMINATE 'BACKLINKS-MIXIN' HERE???:
(defclass PROPOSITION (CONTEXT-SENSITIVE-OBJECT DYNAMIC-SLOTS-MIXIN BACKLINKS-MIXIN)
  :documentation ""
  :public-slots 
  ((home-context :initially *module*) ;; prevent creation in volatile inference worlds
   (kind :type KEYWORD)
   (truth-value :type TRUTH-VALUE :context-sensitive? TRUE)
   (arguments :type VECTOR)
   (operator :type GENERALIZED-SYMBOL)
   (relationRef :type SURROGATE :renames operator)
   ;; we don't use a PROPOSITIONS-INDEX because normalization
   ;;    plays havoc with the back-indexing, and because
   ;;    the indices will almost always be very short:
   (dependent-propositions :type (NON-PAGING-INDEX OF PROPOSITION)
                           :initially NIL-NON-PAGING-INDEX)
   ;; mimic instance of THING:
   (surrogate-value-inverse :type SURROGATE :allocation :dynamic)
   ;; used by :FORALL and :EXISTS propositions:
   (io-variables :type VARIABLES-VECTOR :allocation :dynamic)
   ;; marks ISA propositions generated by a typed variable:
   (variable-type? :type BOOLEAN-WRAPPER :allocation :dynamic
                   :default FALSE)
   (asserted-by-type-checker? :type BOOLEAN :allocation :dynamic)
   ;; marks propositions living inside of a query or description:
   (descriptive? :type BOOLEAN :allocation :dynamic)
   ;; marks IMPLIES proposition representing super/sub link:
   (subrelation-link? :type BOOLEAN :allocation :dynamic)
   (subsumption-link? :type BOOLEAN :allocation :dynamic)
   (satellite-propositions :type (LIST OF PROPOSITION) :allocation :dynamic)
   ;; NOTE: Once we are more adept with justifications, this slot could be
   ;;    replaced with something like a :normalization justification:
   (master-proposition :type PROPOSITION :allocation :dynamic)
   ;; FIGURE OUT: COULD WE MERGE THIS SLOT WITH `satellite-propositions'?
   (proposition-originated-propositions :type (LIST OF PROPOSITION)
     :default NIL-LIST :allocation :dynamic
     ;; use accessors for uniform access with LOGIC-OBJECT's:
     :reader originated-propositions :writer originated-propositions-setter
     :documentation "List of propositions generated by the definition of
this proposition.")
   ;; :FORALL/:IMPLIES options:
   (dont-optimize? :type BOOLEAN :allocation :dynamic
                   :option-keyword :dont-optimize?)
   (forward-only? :type BOOLEAN :allocation :dynamic
                  :option-keyword :forward-only?)
   (backward-only? :type BOOLEAN :allocation :dynamic
                   :option-keyword :backward-only?)
   (proposition-stringified-source :type STRING :allocation :dynamic
     ;; use accessors for uniform access with LOGIC-OBJECT's:
     :reader stringified-source :writer stringified-source-setter)
   ;; finalization flag:
   (unfastened? :type BOOLEAN-WRAPPER :allocation :dynamic :default FALSE)
   (annotations :type (PROPERTY-LIST OF KEYWORD OBJECT) :allocation :dynamic)
   ;;
   ;; slots for the partial matcher
   ;;
   (weight :type FLOAT :allocation :dynamic)
   (neural-network :type PROPOSITION-NEURAL-NETWORK 
                   :allocation :dynamic)
   ;; used for momentum in learning
   (weight-delta :type FLOAT :default 0.0 :allocation :dynamic)
   ;; all AND and OR propositions have biases
   ;; match score will go away as soon as we get truth-value fixed
   (match-score :type FLOAT :allocation :dynamic)
   ;; dave's quick and dirty justifications.
   (support :type (CONS of PARTIAL-SUPPORT) :allocation :dynamic)
   )
  :print-form (print-top-level-object self stream))

(defclass QUANTITY-LOGIC-WRAPPER (LOGIC-THING)
  :public? TRUE
  :public-slots ((wrapper-value :type QUANTITY :required? TRUE)
                 (function-term :type CONS))
  :print-form (if *printReadably?*
                (print-native-stream stream (wrapper-value self))
                (print-native-stream stream "|Q|" (wrapper-value self))))

(defclass INTEGER-LOGIC-WRAPPER (INTEGER-WRAPPER BACKLINKS-MIXIN)
  :print-form (if *printReadably?*
                (print-native-stream stream (wrapper-value self))
                (print-native-stream stream "|W|" (wrapper-value self))))

(defclass FLOAT-LOGIC-WRAPPER (FLOAT-WRAPPER BACKLINKS-MIXIN)
  :print-form (if *printReadably?*
                (print-native-stream stream (wrapper-value self))
                (print-native-stream stream "|W|" (wrapper-value self))))

(defclass STRING-LOGIC-WRAPPER (STRING-WRAPPER BACKLINKS-MIXIN)
  :print-form (let ((value (wrapper-value self)))
                (if *printReadably?*
                  (print-string-readably value stream)
                  (if (defined? value)
                      (print-native-stream stream "|W|" #\" value #\")
                      (print-native-stream stream "|W|" "NULL-STRING")))))

(defun (stringified-source STRING) ((self OBJECT))
  ;; Generic slot reader for the source of `self'.  Handles that LOGIC-OBJECT
  ;;    and PROPOSITION do not descend from the same super class, and that
  ;;    NAMED-DESCRIPTION changes the slot allocation from dynamic to instance.
  (typecase self
    (NAMED-DESCRIPTION ; instance slot:
     (return (slot-value self object-stringified-source)))
    (LOGIC-OBJECT      ; dynamic slot:
     (return (slot-value self object-stringified-source)))
    (PROPOSITION
     (return (slot-value self proposition-stringified-source)))))

(defun (stringified-source-setter STRING) ((self OBJECT) (value STRING))
  ;; Generic slot writer for the source of `self' (also see reader).
  (typecase self
    (NAMED-DESCRIPTION ; instance slot:
     (setf (slot-value self object-stringified-source) value))
    (LOGIC-OBJECT      ; dynamic slot:
     (setf (slot-value self object-stringified-source) value))
    (PROPOSITION
     (setf (slot-value self proposition-stringified-source) value)))
  (return value))

(defun (originated-propositions (LIST OF PROPOSITION)) ((self OBJECT))
  ;; Generic slot reader for the originated propositions of `self'.
  (let ((value OBJECT NULL))
    (typecase self
      (NAMED-DESCRIPTION ; instance slot:
       (setq value (slot-value self object-originated-propositions)))
      (LOGIC-OBJECT      ; dynamic slot:
       (setq value (slot-value self object-originated-propositions)))
      (PROPOSITION
       (setq value (slot-value self proposition-originated-propositions))))
    (if (null? value) (return NIL-LIST) (return value))))

(defun (originated-propositions-setter (LIST OF PROPOSITION))
    ((self OBJECT) (value (LIST OF PROPOSITION)))
  ;; Generic slot writer for the originated propositions of `self'.
  (typecase self
    (NAMED-DESCRIPTION ; instance slot:
     (setf (slot-value self object-originated-propositions) value))
    (LOGIC-OBJECT      ; dynamic slot:
     (setf (slot-value self object-originated-propositions) value))
    (PROPOSITION
     (setf (slot-value self proposition-originated-propositions) value)))
  (return value))


(defglobal *operator-name-to-surrogate-table* (PROPERTY-LIST OF KEYWORD SURROGATE)
  (new PROPERTY-LIST :the-plist
       (bquote (:AND PL-KERNEL/@AND
                :OR PL-KERNEL/@OR
                :NOT PL-KERNEL/@NOT
                :FORALL PL-KERNEL/@FORALL
                :EXISTS PL-KERNEL/@EXISTS
                :EQUIVALENT PL-KERNEL/@EQUIVALENT
                :FAIL PL-KERNEL/@FAIL
                :COLLECT-INTO PL-KERNEL/@COLLECT-INTO ; weird
                :IMPLIES PL-KERNEL/@SUBSET-OF)))      ; different
  :documentation "Maps names of KIF operators to relational surrogates.")

(defun (create-proposition PROPOSITION) ((kind SYMBOL) (argumentCount INTEGER))
  ;; Create a proposition, allocate an arguments vector of size 'argumentCount',
  ;;    and initialize its 'kind' and 'operator' fields.
  (enforce-code-only)
  (let ((proposition (new PROPOSITION)))
    (setf (arguments proposition) (new ARGUMENTS-VECTOR :array-size argumentCount))
    (setf (kind proposition) (intern-keyword kind))
    (case kind
      ((FUNCTION PREDICATE ISA) NULL)
      (otherwise
       (setf (operator proposition)
             (lookup *operator-name-to-surrogate-table* (kind proposition)))))
    (when (description-mode?)
      (setf (descriptive? proposition) TRUE))
    (setf (unfastened? proposition) TRUE)
    (return proposition) ))

(defun enforce-code-only ()
  ;; Signal a proposition error if an attempt is made to perform
  ;;    a logic action in a code-only? module.
  (when (code-only? *module*)
    (signal-proposition-error
     "Can't create a relation, instance or proposition in module:" EOL
     "       " (module-name *module*) EOL
     "    because it is marked as 'code-only?'" EOL)) )


;;; Logic slots on Stella classes:

;; world properties:

(defslot CONTEXT monotonic? :type BOOLEAN :public? TRUE)
(defslot WORLD truth-maintained? :type BOOLEAN :public? TRUE)
(defslot WORLD up-to-date-inferences? :type BOOLEAN :public? TRUE)

(defglobal *logic-module* MODULE (get-stella-module "LOGIC" TRUE) :public? TRUE)
(defglobal *pl-kernel-module* MODULE (get-stella-module "PL-KERNEL" TRUE) :public? TRUE)

(defun (logic-module? BOOLEAN) ((self MODULE))
  :documentation "Return TRUE if 'self' is a logic module, implying
that relations defined within it define a knowledge base.  A module
is a logic module iff it inherits the module 'PL-KERNEL'."
  (return (or (eql? self *pl-kernel-module*)
              (exists m in (parent-modules self) where (logic-module? m))
              (exists m in (uses self) where (logic-module? m)))) )

;; AN IDEA, NOT USED YET:
;(defslot CONTEXT last-update-timestamp :type TIMESTAMP
;  :documentation "Records the time that a context was last updated.")

;; AN IDEA, NOT USED YET:
;(defslot WORLD context-assumed-propositions :type (LIST OF PROPOSITION))

(defslot MODULE locally-conceived-propositions-internal 
  :type PROPOSITIONS-INDEX)

(defun (locally-conceived-propositions PROPOSITIONS-INDEX) ((self MODULE))
  ;; Initialize the slot upon first read access.
  (let ((propositions (locally-conceived-propositions-internal self)))
    (when (null? propositions)
      (setq propositions 
            (create-sequence-index 
             :PAGING (make-selection-pattern
                      :CONTEXT-PROPOSITIONS NIL (cons self NIL))))
      (setf (slot-value self locally-conceived-propositions-internal)
            propositions))
    (return propositions)))

(defun locally-conceived-propositions-setter
       ((self MODULE) (value PROPOSITIONS-INDEX))
  (setf (locally-conceived-propositions-internal self) value) )

(defslot CONTEXT locally-conceived-instances-internal
  :type INSTANCES-INDEX)

(defun (locally-conceived-instances INSTANCES-INDEX) ((self CONTEXT))
  ;; Initialize the slot upon first read access.
  (let ((instances (locally-conceived-instances-internal self)))
    (when (null? instances)
      (setq instances 
            (create-sequence-index 
             :PAGING (make-selection-pattern
                      :CONTEXT-INSTANCES NIL (cons self NIL))))
      (setf (locally-conceived-instances-internal self) instances))
    (return instances)))

(defun locally-conceived-instances-setter
       ((self CONTEXT) (value INSTANCES-INDEX))
  (setf (locally-conceived-instances-internal self) value) )


  ;;
;;;;;; Time Stamps
  ;;

(defglobal *now-timestamp* TIMESTAMP 0
  :documentation "The NOW time stamp is incremented whenever a series
of one or more updates is followed by a query.")

(defun increment-now-timestamp ()
  ;; Bump the NOW time stamp counter.
  (setq *now-timestamp* (1+ *now-timestamp*)) )

;; TO DO: MAINTAIN INDEPENDENT TIMESTAMPS FOR EACH CONTEXT:
(defun (get-now-timestamp TIMESTAMP) ()
  ;; Return the timestamp for the current context.
  (return *now-timestamp*) )

(defglobal *last-kb-action* KEYWORD :UPDATE-PROPOSITION
  :documentation "Records whether the last KB access was a query or
an update.  Used to determine when to increment the NOW time stamp
counter.")

(defun update-now-timestamp ((kbAction KEYWORD))
  ;; Each time we switch from making updates to asking a query, or vice-versa,
  ;;    *now-timestamp* is incremented.
  ;; Bump the NOW time stamp if 'kbAction' is a top-level proposition update
  ;;    that follows a query action.
  ;; Insure that '*last-kb-action*' equals 'kbAction'.
  (when (eql? kbAction *last-kb-action*)
    (return))
  (case kbAction
    (:UPDATE-PROPOSITION
     ;; updates to caches or within a description are invisible to the
     ;;    timestamping:
     (when (or (description-mode?)
               (not (eql? *module* *context*))
               *invisibleassertion?*)
       (return))
     (increment-now-timestamp))
    (:EXECUTE-QUERY NULL))
  (setq *last-kb-action* kbAction) )


  ;;
;;;;;; Bottom
  ;;

;; Can't be a defconstant because of the startup-time initialization
;;   from the startup-time-progn!
(defglobal BOTTOM LOGIC-OBJECT NULL
  :public? TRUE
  :documentation "The undefined individual.  Denotes the non-existence of
an individual in whatever slot it occupies.")

;;; Use 'startup-time-progn so that we don't create a skolem too early
;;;    in the phases:
(startup-time-progn
  (setq BOTTOM (create-skolem NULL (quote BOTTOM))))

(defun (bottom? BOOLEAN) ((self OBJECT))
  :public? TRUE
  :documentation "Return TRUE if 'self' is the undefined individual BOTTOM."
  (return (eql? self BOTTOM)) )


  ;;
;;;;;; Useful Properties
  ;;

(defun (subrelation-of? BOOLEAN) ((desc1 NAMED-DESCRIPTION) (desc2 NAMED-DESCRIPTION))
  :public? TRUE
  ;; Return TRUE if the relation for 'type1' is a subrelation of
  ;;    the relation for 'type2', using only subrelation links to make the
  ;;    determination.
  ;; This is supposed to be a very fast test, using taxonomy nodes;
  ;;     but its not, yet.
  (special ((*reversePolarity?* FALSE))
   (return (relation-implies-relation? desc1 desc2))) )

(defun (logical-subtype-of? BOOLEAN) ((type1 SURROGATE) (type2 SURROGATE))
  :public? TRUE
  ;; Return TRUE if the relation for 'type1' is a subrelation of
  ;;    the relation for 'type2', using only subrelation links to make the
  ;;    determination.
  (if (eql? type1 type2)
      (return TRUE)
    (let ((desc1 (get-description type1))
          (desc2 (get-description type2)))
      (when (or (null? desc1)
                (null? desc2))
        (return FALSE))
      (return (subrelation-of? desc1 desc2)))))

(defun (logical-subtype-of-literal? BOOLEAN) ((type SURROGATE))
  :public? TRUE
  ;; Return TRUE if the relation for `type' is a subrelation of LITERAL.
  ;; Specialized and optimized version of `logical-subtype-of?' used in
  ;;    various places such as the query optimizer.
  (let ((desc (surrogate-to-description type))
        (literalClass (surrogate-to-description @LITERAL))
        (literalSubs NIL))
    (cond ((null? desc)
           (return FALSE))
          ((eql? desc literalClass)
           (return TRUE))
          (otherwise
           (special ((*reversePolarity?* FALSE)
                     (*context* (get-property-test-context)))
             (setq literalSubs
               (memoize (*context*)
                        :timestamps :META-KB-UPDATE :max-values 10
                        (consify (all-subcollections literalClass))))
             (when (memb? literalSubs desc)
               (return TRUE)))))
    (return FALSE)))

(defun (literal-type? BOOLEAN) ((type SURROGATE))
  :public? TRUE
  ;; Return TRUE if 'type' is a subtype of LITERAL or @LITERAL-WRAPPER
  ;; Designed not to break if 'type' does not have a STELLA class definition.
  (let ((value (surrogate-value type)))
    (return (and (isa? value @CLASS)
                 (or (subtype-of? type @LITERAL)
                     (subtype-of? type @LITERAL-WRAPPER)))) ))

(defun (boolean-type? BOOLEAN) ((self TYPE))
  :public? TRUE
  (return (or (eql? self @BOOLEAN)
              (eql? self @BOOLEAN-WRAPPER))) )

(defun (class-description? BOOLEAN) ((self NAMED-DESCRIPTION))
  :public? TRUE
  ;; Return TRUE if 'self' is a class.
  (return (class? self)))

(defun (function-description? BOOLEAN) ((self NAMED-DESCRIPTION))
  :public? TRUE
  ;; Return TRUE if 'self' is a function.
  (return (function? self)))

(defun (variable-arity? BOOLEAN) ((self DESCRIPTION))
  :public? TRUE
  ;; Return TRUE if 'self' is a variable arity relation.
  (return (test-property? self PL-KERNEL/@VARIABLE-ARITY) ))

(defmethod (arity INTEGER) ((self NAMED-DESCRIPTION))
  :public? TRUE
  ;; Return the arity of the named description 'self'.  If variable
  ;;    arity, return -1.
  (if (variable-arity? self)
    (return -1)
    (return (length (io-variable-types self)))) )

(defmethod (arity INTEGER) ((self DESCRIPTION))
  :public? TRUE
  ;; Return the arity of the unnamed description 'self'.
  (return (length (io-variables self))) )


(defun (monadic? BOOLEAN) ((self OBJECT))
  :public? TRUE
  ;; Return TRUE if 'self' is a unary description or an enumerated collection.
  (typecase self
    (DESCRIPTION (return (eql? (arity self) 1)))
    (COLLECTION (return TRUE))
    (otherwise (return FALSE))) )

(defun (computed-relation? BOOLEAN) ((description NAMED-DESCRIPTION))
  :public? TRUE
  ;; Return TRUE if 'self' has an attached procedure that computes
  ;;    its value when all arguments are bound.
  (return (or (and (defined? (native-relation description))
                   (not (abstract? (native-relation description))))
              (defined? (access-binary-value 
                         description PL-KERNEL/@RELATION-COMPUTATION)))) )

(defun (last-argument OBJECT) ((proposition PROPOSITION))
  :public? TRUE
  ;; Return the last argument to 'proposition'.
  :globally-inline? TRUE
  (return (nth (arguments proposition) (1- (length (arguments proposition))))) )


  ;;
;;;;;; Name access
  ;;

(defun (object-surrogate SURROGATE) ((self OBJECT))
  :documentation "Return the surrogate naming the object `self', which
may be a Stella class that is used in PowerLoom as well as
a more normal powerloom object."
  :public? TRUE
  (typecase self
    ((LOGIC-OBJECT PROPOSITION THING)
     (return (surrogate-value-inverse self)))
    (/STELLA/CLASS
     (return (class-type self)))
    (otherwise (return NULL))))

(defun (object-surrogate-setter SURROGATE) ((self OBJECT) (name SURROGATE))
  :documentation "Return the name of the logic object `self' to `name'."
  :public? TRUE
  (typecase self
    ((LOGIC-OBJECT PROPOSITION THING)
     (setf (surrogate-value-inverse self) name)
     (return name))))
    
(defun (object-name SYMBOL) ((self OBJECT))
  :documentation "Return the name symbol for the logic object `self'."
  :public? TRUE
  (let ((surrogate (object-surrogate self)))
    (if (defined? surrogate)
        (return (type-to-symbol surrogate))
      (return NULL))))

(defun (object-name-string STRING) ((self OBJECT))
  :documentation "Return the name string for the logic object `self'."
  :public? TRUE
  (let ((surrogate (object-surrogate self)))
    (if (defined? surrogate)
        (return (symbol-name surrogate))
      (return NULL))))

(defun (object-string-name STRING) ((self OBJECT))
  ;; DEPRECATED: Use `object-name-string' instead.
  (return (object-name-string self)))


  ;;
;;;;;; Inference Mode Flags
  ;;

(defspecial *evaluationMode*  KEYWORD :EXTENSIONAL-ASSERTION
  :documentation "Indicates the context for evaluating a proposition.  One
of :DESCRIPTION, :INTENSIONAL-ASSERTION, or :EXTENSIONAL-ASSERTION.")

(defun (description-mode? BOOLEAN) ()
  ;; Return TRUE if '*evaluationMode*' indicates that a description
  ;;    is being constructed.
  (return (eql? *evaluationMode* :DESCRIPTION)) )

;; TO DO: MAKE THIS A FEATURE:
(defspecial *clippingEnabled?* BOOLEAN TRUE
  :documentation "When enabled, slot-value assertions can be retracted
by later conflicting assertions.")

(defspecial *naturalDeductionMode?* BOOLEAN TRUE
  :documentation "When enabled, blocks normalizations that significantly
change the behavior of inference rules.")

(defun (natural-deduction-mode? BOOLEAN) ()
  :documentation "True if normalization is governed by natural
deduction semantics."
  (return *naturalDeductionMode?*) )

(defglobal *context-dependent-search-mode?*  BOOLEAN FALSE
  :documentation "Signals that we are performing search across multiple
contexts.  Used to disable retraction from collections, since that increases
the overhead of the context mechanism." )

(defun (context-dependent-search-mode? BOOLEAN) ()
  (return *context-dependent-search-mode?*) )


  ;;
;;;;;; Update of truth values
  ;;

;;; Contexts log the propositions created or bound locally.  Modules maintain
;;;    an index of all locally-created propositions; worlds maintain an index of
;;;    all propositions that became true or false locally.

;; Forward reference:
;(defun record-unevaluated-proposition ((proposition PROPOSITION)) )

(defun log-newly-conceived-proposition ((self MODULE) (proposition PROPOSITION))
  ;; Add "proposition" to the list of propositions created within "self".
  ;; REMOVE THIS WARNING AFTER WE NO LONGER SEE UNWARRANTED LOGGING:
  (when (and (exists arg in (arguments proposition)
                 where (isa? arg @PATTERN-VARIABLE))
             (eql? *powerloom-execution-mode* :DEVELOPMENT))
    (signal-proposition-warning "LOGGED QUESTIONABLE CONCEPTION: " EOL
                                "   " proposition))
  (insert (locally-conceived-propositions self) proposition) )

(defun clip-or-clash-with-old-predicate-value ((proposition PROPOSITION))
  ;; 'proposition' has become true, and its relation is single valued.
  ;; Look for propositions with clashing output values.
  ;; If clipping is enabled, retract these propositions;
  ;; Otherwise, signal a clash.
  ;; Note: We are a bit lazy here.  We call 'all-true-dependent-propositions',
  ;;    assuming that the first argument has backlinks.  If not, we might
  ;;    miss a clip or clash.
  (let ((arguments (arguments proposition))
        (countMinusTwo (- (length arguments) 2)))
    (foreach p in (all-true-dependent-propositions
                   (first arguments) (relationRef proposition) FALSE)
             do
             (when (forall i in (interval 1 countMinusTwo)
                           always (eql? (value-of (nth arguments i))
                                        (value-of (nth (arguments p) i))))
               ;; found true proposition that matches on all but the
               ;;    last argument:
               (cond
                ((eql? (value-of (last-argument p)) (value-of (last arguments)))
                 NULL)
                ((and *clippingEnabled?*
                      (world-state? *context*))
                 (deassign-truth-value p :RETRACT-TRUE))
                (otherwise
                 (signal-unification-clash
                  (value-of (last-argument p)) (value-of (last arguments))))))) ))

(defun run-update-equivalence-proposition-demon 
       ((proposition PROPOSITION) (updateMode KEYWORD))
  ;; Helping function for run-update-proposition-demon that will run when
  ;;    an equivalence proposition goes true.
  (let ((term1 (nth (arguments proposition) 0))
	(term2 (nth (arguments proposition) 1))
	(description 
	 (choose (function-output-skolem? term1)
		 (get-description (relationRef (defining-proposition (cast term1 SKOLEM))))
		 (choose (function-output-skolem? term2)
			 (get-description (relationRef (defining-proposition (cast term2 SKOLEM))))
			 NULL)))
        (demonComputation 
	 (choose (defined? description)
		 (access-binary-value description PL-KERNEL-KB/@UPDATE-PROPOSITION-DEMON)
		 NULL)))
    (when (defined? demonComputation)
      (let ((functionCode (function-code-from-procedure demonComputation)))
        (when (defined? functionCode)
          (funcall functionCode proposition updateMode)))) ))

(defun help-run-update-proposition-demon 
    ((proposition PROPOSITION) (updateMode KEYWORD))
  (let ((description (get-description (relationRef proposition)))
        (demonComputation 
	 (choose (defined? description)
		 (access-binary-value description PL-KERNEL-KB/@UPDATE-PROPOSITION-DEMON)
		 NULL)))
    (when (defined? demonComputation)
      (let ((functionCode (function-code-from-procedure demonComputation)))
        (when (defined? functionCode)
          (funcall functionCode proposition updateMode)))) ))

(defun run-update-proposition-demon 
       ((proposition PROPOSITION) (updateMode KEYWORD))
  ;; Access the relationRef description of 'proposition', looking
  ;;    for a computation asserted for the relation 'UPDATE-PROPOSITION-DEMON'.
  ;; If found, execute the procedure.
  (when (defined? (object-store *module*))
    (update-proposition-in-store (object-store *module*) proposition updateMode))
  (case (kind proposition)
    (:equivalent
     (run-update-equivalence-proposition-demon proposition updateMode))
    (otherwise
     (help-run-update-proposition-demon proposition updateMode))))

(defun run-truth-change-demon 
       ((proposition PROPOSITION) (truthChangeRelation SURROGATE))
  ;; Access the relationRef description of 'proposition', looking
  ;;    for a computation asserted for the relation 'truthChangeRelation'.
  ;; If found, execute the procedure.
  (let ((description (get-description (relationRef proposition)))
        (demonComputation
	 (choose (defined? description)
		 (access-binary-value description truthChangeRelation)
		 NULL)))
    (when (defined? demonComputation)
      (let ((functionCode (function-code-from-procedure demonComputation)))
        (when (defined? functionCode)
          (funcall functionCode proposition)))) ))

(defun run-goes-true-demons ((proposition PROPOSITION))
  ;; Called by "update-links-and-timestamps".
  ;; TO DO: TURN CASE STATEMENT INTO DEMON FORM WHEN WE HAVE ENOUGH
  ;;    RULES TO REACT TO TO GENERALIZE.
  (case (kind proposition)
    ((:FUNCTION :ISA)
     (run-truth-change-demon proposition PL-KERNEL/@GOES-TRUE-DEMON))
    (:PREDICATE
     (let ((description (get-description (relationRef proposition))))
       ;; if '(relationRef proposition)' is single-valued, maybe apply
       ;;    clipping:
       (when (single-valued-term? description)
         (clip-or-clash-with-old-predicate-value proposition)))
     (run-truth-change-demon proposition PL-KERNEL/@GOES-TRUE-DEMON))
    (:IMPLIES
     ;; THIS MAY OR MAY NOT BE A GOOD SHORT-CUT:  -rmm
     (when (or (not (isa? (nth (arguments proposition) 0) @DESCRIPTION))
               (not (isa? (nth (arguments proposition) 1) @DESCRIPTION)))
       (return))
     (when (not (description-mode?))
       (add-taxonomy-implies-subsumes-link
        (nth (arguments proposition) 0) (nth (arguments proposition) 1)))
     ;; possibly add an 'equivalent-value' link:
     (revise-equivalences proposition TRUE)
     ;; TO DO: INVENT *meta-rule-timestamp* OR *meta-update-timestamp*
     ;;    INSTEAD OF THIS ONE:
     ;; tricky: We don't want to flush 'inferable' caches when classifier 
     ;;    infers an IMPLIES link:
     ;; BUG: THIS MISSES NESTED RULES:
     (when (eql? *module* *context*)
       (bump-inferable-timestamp))
     ;; flush 'inferable-direct-subdescriptions' on consequent:
     (flush-inferable-direct-subdescriptions-cache proposition))
    (:FORALL
     (when (eql? (satellite-propositions proposition) NIL-LIST)
       (derive-satellite-rules proposition))
     ;; tricky: we need to flush 'inferable' caches on a :FORALL,
     ;;    because otherwise the caches block the logic that would
     ;;    spawn satellites:
     (bump-inferable-timestamp))
    (otherwise NULL))
  (return) )

(defun run-goes-false-demons ((proposition PROPOSITION))
  ;; Called by "update-links-and-timestamps".
  (case (kind proposition)
    ((:FUNCTION :ISA :PREDICATE)
     (run-truth-change-demon proposition PL-KERNEL/@GOES-FALSE-DEMON))
    (otherwise NULL))
  (return) )

(defun run-goes-unknown-demons ((proposition PROPOSITION))
  ;; Called by "update-links-and-timestamps".
  ;; TO DO: TURN CASE STATEMENT INTO DEMON FORM WHEN WE HAVE ENOUGH
  ;;    RULES TO REACT TO TO GENERALIZE.
  (case (kind proposition)
    (:ISA
     (let ((argument (nth (arguments proposition) 0)))
       (typecase argument
         (SKOLEM
          (let ((skolemType (skolem-type argument)))
            (when (and (eql? skolemType (relationRef proposition))
                       (not (eql? skolemType @THING)))
              (inform "Can't retract skolem type of " argument " equaling " 
                      (symbol-name skolemType) "." EOL))))
         (otherwise NULL)))
     (run-truth-change-demon proposition PL-KERNEL/@GOES-UNKNOWN-DEMON))
    ((:PREDICATE :FUNCTION)
     (run-truth-change-demon proposition PL-KERNEL/@GOES-UNKNOWN-DEMON))
    (:IMPLIES
     (drop-taxonomy-implies-subsumes-link
      (nth (arguments proposition) 0) (nth (arguments proposition) 1))
     ;; possibly add an 'equivalent-value' link:
     (revise-equivalences proposition FALSE)
     ;; guessing that previous value of 'proposition' was TRUE (nothing
     ;;    in the code 'cares' so far):
     (let ((p (master-proposition proposition)))
       (when (and (defined? p)
                  (true? p))
         (deassign-truth-value p :RETRACT-TRUE))))
    (:FORALL
     (foreach p in (satellite-propositions proposition)
              do (deassign-truth-value p :RETRACT-TRUE)))
    (otherwise NULL))
  (return) )

(defun update-links-and-timestamps ((proposition PROPOSITION) (updateMode KEYWORD))
  ;; Trigger inference demons in response to an update of the truth or falsity
  ;;    of a proposition.
  ;; TO DO: FIGURE OUT WHAT KIND OF DEMONS ARE ATTACHED TO PROPOSITIONS
  ;;   (ARE THERE RETRACTION DEMONS AS WELL AS ASSERTION DEMONS?).
  (when (null? proposition)
    (return))
  (update-now-timestamp :UPDATE-PROPOSITION)
  (case updateMode
    ((:ASSERT-TRUE :PRESUME-TRUE)
     (run-goes-true-demons proposition))
    ((:ASSERT-FALSE :PRESUME-FALSE)
     (run-goes-false-demons proposition))
    (:RETRACT-TRUE
     (run-goes-unknown-demons proposition))
    (:RETRACT-FALSE
     (run-goes-unknown-demons proposition))) )

(defun assign-truth-value ((self PROPOSITION) (truthValue OBJECT))
  ;; Assign 'truthValue' to 'self'.  'truthValue' can be either
  ;;    a boolean or an actual truth value object.
  (let ((oldTruthValue (truth-value self))
        (newTruthValue TRUTH-VALUE NULL))
    ;; KLUDGE to allow booleans as well as truth value objects;
    ;;    this should instead be handled by a coercion method.
    (cond
     ((eq? truthValue TRUE-WRAPPER)
      (setq newTruthValue TRUE-TRUTH-VALUE))
     ((eq? truthValue FALSE-WRAPPER)
      (setq newTruthValue FALSE-TRUTH-VALUE))
     (otherwise
      (setq newTruthValue truthValue)))
    (cond
     ((eql? oldTruthValue newTruthValue)
      NULL)
     ((defined? oldTruthValue)
      (cond
       ((or (eql? self TRUE-PROPOSITION)
            (eql? self FALSE-PROPOSITION))
        ;; avoid modifying global proposition constants:
        NULL)
       ((eql? oldTruthValue INCONSISTENT-TRUTH-VALUE)
        ;; if `self' is inconsistent, we require a deassign operation first:
        NULL)
       ((eql? newTruthValue TRUE-TRUTH-VALUE)
        (cond
         ((eql? oldTruthValue DEFAULT-TRUE-TRUTH-VALUE)
          (setf (truth-value self) NULL)
          (assign-truth-value self newTruthValue))
         ((eql? oldTruthValue DEFAULT-FALSE-TRUTH-VALUE)
          (deassign-truth-value self :RETRACT-FALSE)
          (assign-truth-value self newTruthValue))
         ((eql? oldTruthValue FALSE-TRUTH-VALUE)
          (signal-truth-value-clash self))))
       ((eql? newTruthValue FALSE-TRUTH-VALUE)
        (cond
         ((eql? oldTruthValue DEFAULT-FALSE-TRUTH-VALUE)
          (setf (truth-value self) NULL)
          (assign-truth-value self newTruthValue))
         ((eql? oldTruthValue DEFAULT-TRUE-TRUTH-VALUE)
          (deassign-truth-value self :RETRACT-TRUE)
          (assign-truth-value self newTruthValue))
         ((eql? oldTruthValue TRUE-TRUTH-VALUE)
          (signal-truth-value-clash self))))
       ((eql? newTruthValue DEFAULT-TRUE-TRUTH-VALUE)
        (cond
         (*deferingDefaultForwardInferences?*
	  (pushf (deferred-default-propositions *context*) self)
          (return))
         ((or (eql? oldTruthValue TRUE-TRUTH-VALUE)
              (eql? oldTruthValue FALSE-TRUTH-VALUE))
          NULL)
         ((eql? oldTruthValue DEFAULT-FALSE-TRUTH-VALUE)
          (deassign-truth-value self :RETRACT-FALSE))))
       ((eql? newTruthValue DEFAULT-FALSE-TRUTH-VALUE)
        (cond
         (*deferingDefaultForwardInferences?*
	  (pushf (deferred-default-propositions *context*) self)
          (return))
         ((or (eql? oldTruthValue FALSE-TRUTH-VALUE)
              (eql? oldTruthValue TRUE-TRUTH-VALUE))
          NULL)
         ((eql? oldTruthValue DEFAULT-TRUE-TRUTH-VALUE)
          (deassign-truth-value self :RETRACT-TRUE))))
       ((eql? newTruthValue INCONSISTENT-TRUTH-VALUE)
        (cond
         ((or (eql? oldTruthValue TRUE-TRUTH-VALUE)
              (eql? oldTruthValue DEFAULT-TRUE-TRUTH-VALUE))
          (deassign-truth-value self :RETRACT-TRUE))
         ((or (eql? oldTruthValue FALSE-TRUTH-VALUE)
              (eql? oldTruthValue DEFAULT-FALSE-TRUTH-VALUE))
          (deassign-truth-value self :RETRACT-FALSE)))
        (assign-truth-value self newTruthValue))
       (otherwise
        (signal-truth-value-clash self))))
     ((eql? (kind self) :FUNCTION)
      (setf (truth-value self) TRUE-TRUTH-VALUE))
     ((eql? newTruthValue INCONSISTENT-TRUTH-VALUE)
      (setf (truth-value self) newTruthValue))
     (otherwise
      (setf (truth-value self) newTruthValue)
      (handle-out-of-date-inference-cache :ASSERT self)
      (cond 
       ((eql? newTruthValue TRUE-TRUTH-VALUE)
        (update-links-and-timestamps self :ASSERT-TRUE))
       ((eql? newTruthValue FALSE-TRUTH-VALUE)
        (update-links-and-timestamps self :ASSERT-FALSE))
       ((eql? newTruthValue DEFAULT-TRUE-TRUTH-VALUE)
        (update-links-and-timestamps self :PRESUME-TRUE))
       ((eql? newTruthValue DEFAULT-FALSE-TRUTH-VALUE)
        (update-links-and-timestamps self :PRESUME-FALSE)))
      (react-to-kb-update *context* self))) ))

(defun deassign-truth-value ((self PROPOSITION) (updateMode KEYWORD))
  ;; Assign '(truth-value self)' the value NULL, and propagate the
  ;;    side-effects of the retraction to itself and equivalent truth values.
  ;; 'updateMode' is :RETRACT-TRUE or :RETRACT-FALSE or :RETRACT-INCONSISTENT.
  (setf (truth-value self) NULL)
  (unless (eql? updateMode :RETRACT-INCONSISTENT)
    ;; we don't have to do anything for :RETRACT-INCONSISTENT, since the
    ;;    retraction of the original truth value already handled the update:
    (handle-out-of-date-inference-cache :RETRACT self)
    (update-links-and-timestamps self updateMode))
  ;; TO DO: FIGURE OUT WHAT TO CALL FOR RETRACTION WITH TMS
  )
       
(defun update-proposition-truth-value ((self PROPOSITION) (updateMode KEYWORD))
  ;; Called by 'update-top-level-proposition'.
  ;; If 'self' already has a truth value, bind the value corresponding
  ;;    to 'updateMode' to it (possibly causing a clash).
  ;; If proposition has no truth value, assign or deassign it one.
  (case updateMode
    (:ASSERT-TRUE (assign-truth-value self TRUE))
    (:ASSERT-FALSE (assign-truth-value self FALSE))
    (:PRESUME-TRUE (assign-truth-value self DEFAULT-TRUE-TRUTH-VALUE))
    (:PRESUME-FALSE (assign-truth-value self DEFAULT-FALSE-TRUTH-VALUE))
    (:RETRACT-TRUE
     ;; if 'truthValue' does not evaluate to TRUE-TV then nothing happens.
     ;; also, :FUNCTION propositions are always true:
     (when (and (true? self)
                (not (eql? (kind self) :FUNCTION)))
       (deassign-truth-value self updateMode)))
    (:RETRACT-FALSE
     ;; if 'truthValue' does not evaluate to FALSE-TV then nothing happens:
     (when (false? self)
       (deassign-truth-value self updateMode)))
    (:CONCEIVE NULL))
  (run-update-proposition-demon self updateMode))

;; JUST AN IDEA. NOTHING CALLS THIS:  -rmm
(defun assign-proposition-weight
    ((self PROPOSITION) (weight PARTIAL-MATCH-SCORE))
  (let ((tv (truth-value self)))
    (cond ((= weight 1.0)
           (assign-truth-value self TRUE))
          ((= weight 0.0)
           (assign-truth-value self FALSE))
          ((or (eql? tv TRUE-TRUTH-VALUE)
               (eql? tv FALSE-TRUTH-VALUE)
               (null? tv))
           (setf (truth-value self)
             (new TRUTH-VALUE :positive-score weight)))
          (otherwise
           (setf (positive-score (truth-value self)) weight)))))

(defun (tickle-context CONTEXT) ()
  ;; Assert and then retract a meta-level proposition just to reset
  ;;    caches in the current context.
  (let ((description (get-description PL-KERNEL/@HIDDEN-RELATION)))
    ;; Assert and retract a meta-relation, so that the meta cache gets
    ;;    flushed along with the jit or default cache:
    (assert-property description PL-KERNEL/@HIDDEN-RELATION)
    (update-property description PL-KERNEL/@HIDDEN-RELATION :RETRACT-TRUE)
    (return *context*) ))

(defun (tickle-instances CONTEXT) ()
  ;; Assert and then retract a non-meta proposition just to reset non-meta
  ;;    caches current context.
  (let ((instance (either (get-instance "HIDDEN-INSTANCE")
                          (create-logic-instance @HIDDEN-INSTANCE NULL))))
    ;; Assert and retract a meta-relation, so that the meta cache gets
    ;;    flushed along with the jit or default cache:
    (assert-property instance PL-KERNEL/@HIDDEN-RELATION)
    (update-property instance PL-KERNEL/@HIDDEN-RELATION :RETRACT-TRUE)
    (return *context*) ))


  ;;
;;;;;; Slot demons
  ;;

(defun react-to-skolem-value-update
       ((skolem SKOLEM) (oldValue OBJECT) (newValue OBJECT)
        (topLevelUpdate? BOOLEAN))
  ;; 'skolem' has been bound to 'newValue' or unbound from 'oldValue'.
  ;; If the first argument to its defining proposition is bound to a
  ;;    native value (and if we are at top level, and if its an attribute
  ;;    proposition) then update the corresponding slot in that object.
  ;; Run update demons and inference demons on the slot 'relationRef', passing
  ;;    them 'self' AND 'newValue'.
  (let ((proposition (defining-proposition skolem)))
    (when (and topLevelUpdate?
               (native-slot-proposition? proposition))
      (let ((slot (native-relation (get-description (relationRef proposition))))
            (nativeFirstArgValue (value-of (first (arguments proposition)))))
        (if (defined? newValue)
          (assign-native-slot-value nativeFirstArgValue slot newValue)
          (drop-native-slot-value nativeFirstArgValue slot oldValue))))
    (when (not (eql? oldValue newValue))
      ;; Bump memoization time stamps similar to `react-to-kb-update':
      (bump-memoization-timestamp :KB-UPDATE)
      (when (or (and (defined? newValue)
                     (isa? newValue @DESCRIPTION))
                (meta-proposition? proposition))
        (bump-memoization-timestamp :META-KB-UPDATE))
      ;; Run truth-change demons if necessary:
      (when (defined? oldValue)
        (update-links-and-timestamps proposition :RETRACT-TRUE))
      (when (defined? newValue)
        (update-links-and-timestamps proposition :ASSERT-TRUE)))))


  ;;
;;;;;; Updates to Native Objects
  ;;

(defun (native-slot-proposition? BOOLEAN) ((self PROPOSITION))
  ;; Return TRUE if 'self' has an instance of THING as its first
  ;;    argument, and the relation for 'self' is attached to a native
  ;;    storage slot.
  (let ((arguments (arguments self)))
    (when (zero? (length arguments))
      (return FALSE))
    (let ((firstArg (choose (defined? (first arguments))
                            (value-of (first arguments))
                            NULL)))
      (when (and (defined? firstArg)
                 (isa? firstArg @THING))
        (let ((description (get-description (operator self))))
          (when (and (defined? description)
                     (defined? (native-relation description))
                     (isa? (native-relation description) @STORAGE-SLOT))
            (return TRUE))))
      (return FALSE)) ))

(defun (update-native-slot-proposition (CONS OF PROPOSITION))
       ((proposition PROPOSITION) (updateMode KEYWORD))
  ;; Update a storage slot value on a native object.
  (let ((slot (native-relation (surrogate-to-description
                                (relationRef proposition))))
        (object (value-of (first (arguments proposition))))
        (value (value-of (second (arguments proposition)))))
    (case updateMode
      (:ASSERT-TRUE
       (when *clippingEnabled?*
         (clear-native-slot-value object slot))
       (assign-native-slot-value object slot value))
      (:RETRACT-TRUE
       (drop-native-slot-value object slot value))
      (otherwise
       (warn "Illegal update to native slot value.  Mode:  " updateMode EOL
              "   Proposition:  " proposition EOL)))
    (return NIL) ))

(defun assign-native-slot-value ((self THING) (slot STORAGE-SLOT) (value OBJECT))
  ;; Assign the value 'value' for the slot 'slot' on 'self'.
  (when (skolem? value)
    (return))
  (let ((oldValue (read-slot-value self slot)))
    (when (eql? oldValue value)
      (return))
    ;; 'oldValue' /= 'value':
    (when (defined? oldValue)           ; check for pre-existing value
      (signal-unification-clash oldValue value))
    ;; assign 'value' to non-logical slot representation:
    (put-slot-value self slot value)))

(defun clear-native-slot-value ((object THING) (slot STORAGE-SLOT))
  ;; Retract the value 'value' for the slot 'slot' on 'object'.
  (put-slot-value object slot NULL) )

(defun drop-native-slot-value ((self THING) (slot STORAGE-SLOT) (value OBJECT))
  ;; Evaluate 'slot' applied to 'self'.
  ;; Verify that the value of the attribute <object, surrogate> is 'value'.
  ;;    If so, clear that attribute.
  (let ((oldValue (read-slot-value self slot)))
    (when (eql? value oldValue)
      (clear-native-slot-value self slot))))


  ;;
;;;;;; Computed and stored slot values
  ;;

;; TO DO: CONSIDER PHASING OUT AUTOMATIC CREATION OF DESCRIPTIONS
;;    FROM NATIVE SLOTS OR FUNCTIONS EXCEPT FOR STORAGE SLOTS:
(defun (lookup-slotref-on-instance SURROGATE) ((term OBJECT) (slotName SYMBOL))
  ;; Determine the type of the instance 'term', and search for a storage
  ;;    slot named 'slotName' on the class corresponding to that type.
  ;; Return the slot if it exists.
  (let  ((termType TYPE NULL))
    (setq termType (safe-logical-type term))
    (when (null? termType)
      (return NULL))
    ;; return NULL if the type of 'term' does not have a native class:
    (when (or (null? (surrogate-value termType))
              (not (isa? (surrogate-value termType) STELLA/@CLASS))
              (eql? termType @THING))
      (return NULL))
    ;; don't try to use a STELLA function as a relation:
    (when (defined? (lookup-function slotName))
      (return NULL))
    (let ((surrogate (lookup-slotref termType slotName)))
      (when (defined? surrogate)
        (return surrogate))
      ;; search classes that 'term' belongs to looking for one that
      ;;    inherits a slot named 'slotname':
      (typecase term
        (LOGIC-OBJECT
         (foreach prop in (unfiltered-dependent-isa-propositions term)
                  where (eql? (kind prop) :ISA)
                  do
                  (setq surrogate (lookup-slotref (relationRef prop) slotName))
                  (when (defined? surrogate)
                    (return surrogate))))
        (otherwise NULL))
      (typecase term
        (SKOLEM 
         (when (and (defined? (defining-proposition term))
                    (isa? (operator (defining-proposition term)) @SURROGATE))
           (let ((description 
                  (get-description (relationRef (defining-proposition term)))))
             (when (defined? description)
               (setq termType (last (io-variable-types description)))
               (setq surrogate (lookup-slotref termType slotName))
               (when (defined? surrogate)
                 (return surrogate))))))
        (otherwise NULL))
      ;; failure:
      (return NULL)) ))


  ;;
;;;;;; Value Evaluation Functions
  ;;

;;; 'value-of' returns the last LOGIC-OBJECT in a 'variable-value' chain.
;;; 'native-value-of' returns the last object in a 'variable-value' chain,
;;;    if its a non-LOGIC-OBJECT, or else returns null.
;;; 'innermost-of' returns the last pattern-variable encountered in a
;;     variable value chain.

(defun (unbound? BOOLEAN) ((skolem SKOLEM))
  :globally-inline? TRUE  :public? TRUE
  (return (null? (variable-value skolem))) )

(defun (value-of OBJECT) ((self OBJECT))
  :public? TRUE
  ;; The 'value-of' function recursively follows 'variable-value' pointers
  ;;    to determine the innermost binding of a skolem.
  (typecase self
    (SKOLEM
     (if (null? (variable-value self))
       (return self)
       (return (value-of (variable-value self)))))
    (SURROGATE (return (SURROGATE.value-of self)))
    (RELATION (return (RELATION.value-of self)))
    (otherwise (return self))) )

(defun (SURROGATE.value-of OBJECT) ((self SURROGATE))
  ;; Return the value of a surrogate.
  (let ((value (surrogate-value self)))
    (if (defined? value)
      (return (value-of value))
      (progn
        (when (dotted-string? (symbol-name self))
          (let ((slot SLOT (string-to-slot (symbol-name self))))
            (when (defined? slot)
              (return (value-of slot)))))
        (unless *suppressNonlogicObjectWarning?* ;; allow use on unbound sgts
          ;; UPGRADED FROM WARNING TO RUN-TIME ERROR:
          (signal-undefined-term (symbol-name self)))
        (return NULL))) ))

(defun (RELATION.value-of DESCRIPTION) ((self RELATION))
  ;; The value of a class or slot is its description.
  (let ((description (description self)))
    (when (defined? description)
      (return description))
    (typecase self
      (RELATION (setq description (get-description self)))
      (otherwise NULL))
    (when (defined? description)
      (return description))
    (unless *suppressNonlogicObjectWarning?*
      (signal-proposition-warning
       "value-of: encountered missing description on class or relation "
       (name self)))
    (return NULL) ))

(defun (equivalent-value-of OBJECT) ((self OBJECT))
  ;; Return the inner-most equivalent of 'self', following
  ;;    'equivalent-value' links.
  (when (null? self)
    (return NULL))
  (typecase self
    (LOGIC-OBJECT
     (if (defined? (equivalent-value self))
       (return (equivalent-value-of (equivalent-value self)))
       (return self)))
    (otherwise (return self))) )
    
(defspecial *computedQuery?* BOOLEAN FALSE
  :documentation "Used to signal 'ground-value-of' that it can
call 'bound-to' safely.")

(defun (ground-value-of OBJECT) ((self OBJECT))
  :public? TRUE
  ;; Follow variable-value links, and return a ground (non-variable)
  ;;    value if one exists.  Favor LOGIC-OBJECTs over native values.
  (typecase self
    (PATTERN-VARIABLE 
     (let ((value OBJECT NULL))
       (when (and (defined? (bound-to-offset self))
                  *computedQuery?*)
         (setq value (bound-to self)))
       ;; THIS IS AN EXPERIMENT:
       (when (null? value)
         (setq value (variable-value self)))
       (if (defined? value)
         (return (ground-value-of value))
         (return NULL))))
    (SKOLEM
     (let ((value (variable-value self)))
       (if (defined? value)
         (return (ground-value-of value))
         (return NULL))))
;    (LOGIC-OBJECT
;     (if (defined? (equivalent-value self))
;       (return (ground-value-of (equivalent-value self)))
;       (return self)))   ; XXQQ
    (SURROGATE
     (let ((value (surrogate-value self)))
       (if (defined? value)
         (return (ground-value-of value))
         (return NULL))))
    (RELATION
     (return (description self)))
    (otherwise (return self))) )

(defun (skolem? BOOLEAN) ((self OBJECT))
  :public? TRUE
  ;; Return TRUE if 'self' is a skolem, i.e., can itself be bound to another
  ;; object.
  (return (and (defined? self)
               (isa? self @SKOLEM))) )

(defun (variable? BOOLEAN) ((self OBJECT))
  :public? TRUE
  ;; Return TRUE if 'self' is a variable.
  (return (and (defined? self)
               (isa? self @PATTERN-VARIABLE)) ))

(defun (native-value? BOOLEAN) ((self OBJECT))
  :public? TRUE
  ;; Return TRUE if 'self' is a literal or other non-logic object.
  (if (defined? self)
    (return (not (isa? self @LOGIC-OBJECT)))
    (return FALSE)) )

;; TO DO: TO SPEED THINGS UP (I.E. TO AVOID THE TYPECASE) RECODE THIS
;;    TO CALL 'value-of' (AND THEN POSSIBLY BACK UP):
(defun (native-value-of OBJECT) ((self OBJECT))
  :public? TRUE
  ;; Follow variable-value links, and return a native (non LOGIC-OBJECT)
  ;;    value if one exists.
  (typecase self
    (PATTERN-VARIABLE
     (let ((value (ground-value-of self)))
       (if (defined? value)
         (return (native-value-of value))
         (return NULL))))
    (SKOLEM
     (let ((value (variable-value self)))
       (if (defined? value)
         (return (native-value-of value))
         (return NULL))))
    (LOGIC-OBJECT
     (return NULL))
    (SURROGATE
     (let ((value (surrogate-value self)))
       (if (defined? value)
         (return (native-value-of value))
         (return NULL))))
    (otherwise (return self))) )

(defun (innermost-variable-of PATTERN-VARIABLE) ((self PATTERN-VARIABLE))
  ;; Return the tightest (deepest) pattern variable in the value-of chain
  ;;    attached to 'self'.
  (loop
    (let ((tightestVariable self)
          (value OBJECT NULL))
      (loop
        (setq value (variable-value tightestVariable))
        (if (and (defined? value)
                 (variable? value))
          (setq tightestVariable value)
          (return tightestVariable))))) )

(defun (innermost-of OBJECT) ((self OBJECT))
  ;; In extensional mode, return the innermost equivalent in a value-of
  ;;    chain.  Called by routines instead of 'value-of' to insure
  ;;    that a null-valued surrogate returns itself instead of NULL.
  ;; In description mode, return the innermost equivalent in a value-of
  ;;    chain that is legal within a description (everything is legal
  ;;    except for a non-variable logic object).
  (if (description-mode?)
    (let ((nextValue OBJECT self)
          (tightestVariable PATTERN-VARIABLE NULL)
          (equivalent OBJECT NULL))       ; needed to avoid casting problem
      (loop
        (typecase nextValue
          (PATTERN-VARIABLE
           (setq equivalent (variable-value nextValue))
           (when (null? equivalent)
             (return nextValue))
           (setq tightestVariable nextValue))
          (DESCRIPTION
           (return nextValue))
          (LOGIC-OBJECT
           (return tightestVariable))    ; 'tightestVariable' should be a pattern variable
          (SURROGATE
           (return nextValue))
          (otherwise
           (return nextValue)))
        (setq nextValue equivalent)))
    ;; extensional mode:
    (let ((tightestValue self)
          (equivalent OBJECT NULL))       ; needed to avoid casting problem
      (loop
        (typecase tightestValue
          (SKOLEM
           (when (null? (variable-value tightestValue))
             (return tightestValue))
           (setq equivalent (variable-value tightestValue)))
;          (LOGIC-OBJECT
;           (when (null? (equivalent-value tightestValue))
;             (return tightestValue))
;           (setq equivalent (equivalent-value tightestValue))) ; XXQQ
          (SURROGATE 
           (when (null? (surrogate-value tightestValue))
             (return tightestValue))
           (setq equivalent (surrogate-value tightestValue)))
          (otherwise (return tightestValue)))
        (setq tightestValue equivalent)))) )


  ;;
;;;;;; Skolem functions
  ;;

(defglobal *skolem-id-counter* INTEGER 0)
(defspecial *variableIdCounter* INTEGER 0)

(defun (yield-anonymous-skolem-name SYMBOL) ((variable? BOOLEAN))
  ;; Return a new name that can be used to identify an anonymous skolem
  ;;    (or variable, if `variable?' is TRUE).
  (let ((suffix
         (choose variable?
                 (integer-to-string (++ *variableIdCounter*))
                 (integer-to-string (++ *skolem-id-counter*)))))
    (return
      (intern-symbol
       (concatenate
         (choose variable? "?V" "SK")
         (choose (= (length suffix) 1) "0" "")
         suffix)))))

(defspecial *freeSkolems* CONS NULL
  :documentation "Cons-list of top-level existentially-quantified skolems.")

(defun (help-create-skolem SKOLEM)
       ((self SKOLEM) (type TYPE) (name SYMBOL) (assertISA? BOOLEAN))
  ;; Assert an ISA proposition stating that 'self' has type 'type'.
  ;; If 'name' is NULL use a gensym of the form SKn instead
  ;;   (these make them a bit easier to track during debugging).
  (setq type (unwrap-wrapped-type type))
  (unless (defined? name)
    (setq name (yield-anonymous-skolem-name (variable? self))))
  (setf (skolem-name self) name)
  (when (and assertISA?
             (defined? type))
    (assert-isa-proposition self type))
  (return self) )

(defun (create-skolem SKOLEM) ((type TYPE) (name SYMBOL))
  :public? TRUE
  ;; Create a new skolem of type 'type'.
  ;; If 'name' is NULL use a gensym of the form SKn?
  ;;   (these make them a bit easier to track during debugging).
  (safety 3 (not (description-mode?))
          "INTERNAL ERROR: Trying to create a skolem in description mode.")
  (let ((skolem (new SKOLEM)))
    (when (defined? *freeSkolems*)
      (pushq *freeSkolems* skolem))
    (help-create-skolem skolem type name TRUE)
    (return skolem) ))

(defun (create-variable PATTERN-VARIABLE) 
       ((type TYPE) (name SYMBOL) (assertISA? BOOLEAN))
  :public? TRUE
  ;; Create a new variable of type 'type'.
  ;; If 'name' is NULL use a gensym of the form '?Vn'.
  ;; If "assertISA?', assert an :ISA proposition on the type 'type'.
  (let ((evaluationMode *evaluationMode*))
    (special ((*evaluationMode* evaluationMode))
      (when (and assertISA? (not (description-mode?)))
        (setq *evaluationMode* :DESCRIPTION))
      (return
        (help-create-skolem (new PATTERN-VARIABLE) type name assertISA?)))))

(defun (create-variable-or-skolem SKOLEM) ((type TYPE) (name SYMBOL))
  :public? TRUE
  ;; Create a variable or skolem, depending on whether or not we
  ;;    are in description mode.  No ISA proposition is created.
  (if (description-mode?)
    (return (create-variable type name FALSE))
    (let ((skolem (new SKOLEM)))
      (special ((*invisibleAssertion?* TRUE))
        (help-create-skolem skolem type name FALSE))
      (return skolem))) )

(defmethod (object-equal? BOOLEAN) ((self SKOLEM) (other OBJECT))
  ;; Return TRUE if `self' and `other' are considered identical skolems.
  (if (eql? self other)
      (return TRUE)
    (when (skolem? other)
      ;; check, whether they are the outputs of identical function propositions:
      (let ((propSelf (defining-proposition self))
            (propOther (defining-proposition (cast other SKOLEM))))
        (return (and (defined? propSelf)
                     (defined? propOther)
                     (equivalent-function-propositions?
                      propSelf propOther NULL))))))
  (return FALSE))


  ;;
;;;;;; Truth values
  ;;

(defconstant TRUE-TRUTH-VALUE TRUTH-VALUE
             (new TRUTH-VALUE
                  :polarity :TRUE :strength :STRICT :positive-score 1.0)
  :documentation "Value representing TRUE.")

(defconstant FALSE-TRUTH-VALUE TRUTH-VALUE
             (new TRUTH-VALUE
                  :polarity :FALSE :strength :STRICT :positive-score -1.0)
  :documentation "Value representing FALSE.")

(defconstant DEFAULT-TRUE-TRUTH-VALUE TRUTH-VALUE
             (new TRUTH-VALUE
                  :polarity :TRUE :strength :DEFAULT :positive-score 0.8)
  :documentation "Value representing DEFAULT-TRUE.")

(defconstant DEFAULT-FALSE-TRUTH-VALUE TRUTH-VALUE
             (new TRUTH-VALUE
                  :polarity :FALSE :strength :DEFAULT :positive-score -0.8)
  :documentation "Value representing DEFAULT-FALSE.")

(defconstant UNKNOWN-TRUTH-VALUE TRUTH-VALUE
             (new TRUTH-VALUE :polarity :UNKNOWN)
  :documentation "Value representing UNKNOWN.  Needed for those cases
where we need a non-NULL truth value to represents UNKNOWN.")

(defconstant INCONSISTENT-TRUTH-VALUE TRUTH-VALUE
             (new TRUTH-VALUE
                  :polarity :INCONSISTENT :strength :STRICT)
  :documentation "Value representing a contradiction.")

(defun (true? BOOLEAN) ((self PROPOSITION))
  :documentation
  "Return true if `self' is true (or default-true if we are
considering default assertions)."
  :public? TRUE
  (let ((truthValue (truth-value self)))
    (cond
     ((eql? truthValue TRUE-TRUTH-VALUE)
      (return TRUE))
     ((eql? truthValue DEFAULT-TRUE-TRUTH-VALUE)
      (when (using-default-knowledge?)
        (return TRUE)))
     ((and (defined? truthValue)
	   (eql? (polarity truthValue) :TRUE)
           (or (using-default-knowledge?)
               (eql? (strength truthValue) :STRICT)))
      (return TRUE)))
    (return FALSE)))

(defun (false? BOOLEAN) ((self PROPOSITION))
  :documentation
  "Return true if `self' is false (or default-false if we are
considering default assertions)."
  :public? TRUE
  (let ((truthValue (truth-value self)))
    (cond 
     ((eql? truthValue FALSE-TRUTH-VALUE)
      (return TRUE))
     ((eql? truthValue DEFAULT-FALSE-TRUTH-VALUE)
      (when (using-default-knowledge?)
        (return TRUE)))
     ((and (defined? truthValue)
	   (eql? (polarity truthValue) :FALSE)
           (or (using-default-knowledge?)
               (eql? (strength truthValue) :STRICT)))
      (return TRUE)))
    (return FALSE)))

(defun (unknown? BOOLEAN) ((self PROPOSITION))
  :documentation "Return true if the truth of `self' is unknown."
  :public? TRUE
  (let ((tv (truth-value self)))
    (return
      (or (unknown-truth-value? tv)
          (and (not (using-default-knowledge?))
               (default-truth-value? tv))
          (inconsistent-truth-value? tv)))))

(defun (inconsistent? BOOLEAN) ((self PROPOSITION))
  :documentation "Return true if `self' is inconsistent (true and false)."
  :public? TRUE
  (return (eql? (truth-value self) INCONSISTENT-TRUTH-VALUE)))

(defun (default-true? BOOLEAN) ((self PROPOSITION))
  :documentation "Return true if `self' is default true."
  :public? TRUE
  (return (eql? (truth-value self) DEFAULT-TRUE-TRUTH-VALUE)) )

(defun (default-false? BOOLEAN) ((self PROPOSITION))
  :documentation "Return true if `self' is default false."
  :public? TRUE
  (return (eql? (truth-value self) DEFAULT-FALSE-TRUTH-VALUE)) )

(defun (defaultify-truth-value TRUTH-VALUE) 
       ((true? BOOLEAN) (byDefault? BOOLEAN))
  ;; Return a suitable truth value.
  (return
   (choose true?
           (choose byDefault? DEFAULT-TRUE-TRUTH-VALUE TRUE-TRUTH-VALUE)
           (choose byDefault? DEFAULT-FALSE-TRUTH-VALUE FALSE-TRUTH-VALUE))) )

(defun (conjoin-truth-values TRUTH-VALUE) ((tv1 TRUTH-VALUE) (tv2 TRUTH-VALUE))
  :documentation
  "Return the logical conjunction of truth values `tv1' and `tv2'."
  :public? TRUE
  (cond
   ((or (eql? tv1 INCONSISTENT-TRUTH-VALUE)
        (eql? tv2 INCONSISTENT-TRUTH-VALUE))
    (return INCONSISTENT-TRUTH-VALUE))
   ((or (eql? tv1 FALSE-TRUTH-VALUE)
        (eql? tv2 FALSE-TRUTH-VALUE))
    (return FALSE-TRUTH-VALUE))
   ((and (eql? tv1 DEFAULT-FALSE-TRUTH-VALUE)
         (eql? tv2 DEFAULT-TRUE-TRUTH-VALUE))
    (return UNKNOWN-TRUTH-VALUE))
   ((and (eql? tv1 DEFAULT-TRUE-TRUTH-VALUE)
         (eql? tv2 DEFAULT-FALSE-TRUTH-VALUE))
    (return UNKNOWN-TRUTH-VALUE))
   ((or (null? tv1)
        (eql? tv1 UNKNOWN-TRUTH-VALUE)
        (null? tv2)
        (eql? tv2 UNKNOWN-TRUTH-VALUE))
    (return UNKNOWN-TRUTH-VALUE))
   ((or (eql? tv1 DEFAULT-FALSE-TRUTH-VALUE)
        (eql? tv2 DEFAULT-FALSE-TRUTH-VALUE))
    (return DEFAULT-FALSE-TRUTH-VALUE))
   ((or (eql? tv1 DEFAULT-TRUE-TRUTH-VALUE)
        (eql? tv2 DEFAULT-TRUE-TRUTH-VALUE))
    (return DEFAULT-TRUE-TRUTH-VALUE))
   (otherwise
    (return TRUE-TRUTH-VALUE))))

(defun (disjoin-truth-values TRUTH-VALUE) ((tv1 TRUTH-VALUE) (tv2 TRUTH-VALUE))
  :documentation
  "Return the logical disjunction of truth values `tv1' and `tv2'."
  :public? TRUE
  (cond
   ;; Note: we treat `INCONSISTENT-TRUTH-VALUE' just like FALSE:
   ((or (eql? tv1 TRUE-TRUTH-VALUE)
        (eql? tv2 TRUE-TRUTH-VALUE))
    (return TRUE-TRUTH-VALUE))
   ((or (eql? tv1 DEFAULT-TRUE-TRUTH-VALUE)
        (eql? tv2 DEFAULT-TRUE-TRUTH-VALUE))
    (return DEFAULT-TRUE-TRUTH-VALUE))
   ((or (null? tv1)
        (eql? tv1 UNKNOWN-TRUTH-VALUE)
        (null? tv2)
        (eql? tv2 UNKNOWN-TRUTH-VALUE))
    (return UNKNOWN-TRUTH-VALUE))
   ((or (eql? tv1 DEFAULT-FALSE-TRUTH-VALUE)
        (eql? tv2 DEFAULT-FALSE-TRUTH-VALUE))
    (return DEFAULT-FALSE-TRUTH-VALUE))
   (otherwise
    (return FALSE-TRUTH-VALUE))))

(defun (invert-truth-value TRUTH-VALUE) ((self TRUTH-VALUE))
  :documentation "Return the logical negation of `self'."
  :public? TRUE
  (cond
   ((eql? self TRUE-TRUTH-VALUE)
    (return FALSE-TRUTH-VALUE))
   ((eql? self DEFAULT-TRUE-TRUTH-VALUE)
    (return DEFAULT-FALSE-TRUTH-VALUE))
   ((eql? self FALSE-TRUTH-VALUE)
    (return TRUE-TRUTH-VALUE))
   ((eql? self DEFAULT-FALSE-TRUTH-VALUE)
    (return DEFAULT-TRUE-TRUTH-VALUE))
   ((eql? self INCONSISTENT-TRUTH-VALUE)
    (return INCONSISTENT-TRUTH-VALUE))
   (otherwise
    ;;; Allow UNKNOWN, similar to other truth-value combinators:
    ;(warn "Don't know how to invert truth value: " self EOL)
    (return UNKNOWN-TRUTH-VALUE))) )

(defun (weaken-truth-value TRUTH-VALUE) ((tv1 TRUTH-VALUE) (tv2 TRUTH-VALUE))
  :documentation
  "If `tv2' has lesser strength than `tv1', adapt the strength of `tv1' (not
its value!) and return the result.  Otherwise, return `tv1' unmodified."
  :public? TRUE
  (cond ((unknown-truth-value? tv2)
         (return UNKNOWN-TRUTH-VALUE))
        ((default-truth-value? tv2)
         (when (true-truth-value? tv1)
           (return DEFAULT-TRUE-TRUTH-VALUE))
         (when (false-truth-value? tv1)
           (return DEFAULT-FALSE-TRUTH-VALUE))))
  (return tv1))

(defun (strengthen-truth-value TRUTH-VALUE) ((tv1 TRUTH-VALUE) (tv2 TRUTH-VALUE))
  :documentation
  "If `tv2' has greater strength than `tv1', adapt the strength of `tv1' (not
its value!) and return the result.  Otherwise, return `tv1' unmodified."
  :public? TRUE
  (when (and (strict-truth-value? tv2)
             (default-truth-value? tv1))
    (when (true-truth-value? tv1)
      (return TRUE-TRUTH-VALUE))
    (when (false-truth-value? tv1)
      (return FALSE-TRUTH-VALUE)))
  (return tv1))

(defun (true-truth-value? BOOLEAN) ((self TRUTH-VALUE))
  :documentation "Return TRUE if `self' represents some form of truth."
  :public? TRUE :globally-inline? TRUE
  (return (or (eql? self TRUE-TRUTH-VALUE)
              (eql? self DEFAULT-TRUE-TRUTH-VALUE))))

(defun (false-truth-value? BOOLEAN) ((self TRUTH-VALUE))
  :documentation "Return TRUE if `self' represents some form of falsehood."
  :public? TRUE :globally-inline? TRUE
  (return (or (eql? self FALSE-TRUTH-VALUE)
              (eql? self DEFAULT-FALSE-TRUTH-VALUE))))

(defun (strict-truth-value? BOOLEAN) ((self TRUTH-VALUE))
  :documentation "Return TRUE if `self' is a strict truth value."
  :public? TRUE :globally-inline? TRUE
  (return (or (eql? self TRUE-TRUTH-VALUE)
              (eql? self FALSE-TRUTH-VALUE))))

(defun (default-truth-value? BOOLEAN) ((self TRUTH-VALUE))
  :documentation "Return TRUE if `self' is a default truth value."
  :public? TRUE :globally-inline? TRUE
  (return (or (eql? self DEFAULT-TRUE-TRUTH-VALUE)
              (eql? self DEFAULT-FALSE-TRUTH-VALUE))))

(defun (unknown-truth-value? BOOLEAN) ((self TRUTH-VALUE))
  :documentation "Return TRUE if `self' represents UNKNOWN."
  :public? TRUE :globally-inline? TRUE
  (return (or (eql? self UNKNOWN-TRUTH-VALUE)
              (null? self))))

(defun (inconsistent-truth-value? BOOLEAN) ((self TRUTH-VALUE))
  :documentation "Return TRUE if `self' represents INCONSISTENT."
  :public? TRUE :globally-inline? TRUE
  (return (eql? self INCONSISTENT-TRUTH-VALUE)))

(defun print-truth-value ((self TRUTH-VALUE) (stream OUTPUT-STREAM))
  ;; Print `self' onto `stream'.
  (cond
   ((eql? self TRUE-TRUTH-VALUE)
    (print-stream stream "TRUE"))
   ((eql? self FALSE-TRUTH-VALUE)
    (print-stream stream "FALSE"))
   ((eql? self DEFAULT-TRUE-TRUTH-VALUE)
    (print-stream stream "DEFAULT-TRUE"))
   ((eql? self DEFAULT-FALSE-TRUTH-VALUE)
    (print-stream stream "DEFAULT-FALSE"))
   ((eql? self UNKNOWN-TRUTH-VALUE)
    (print-stream stream "UNKNOWN"))
   ((eql? self INCONSISTENT-TRUTH-VALUE)
    (print-stream stream "INCONSISTENT"))
   (otherwise
    (print-stream stream "|i|" (primary-type self)))))


  ;;
;;;;;; Skolem unification
  ;;

(defun signal-unification-clash ((term1 OBJECT) (term2 OBJECT))
  ;; Signal a clash, and jump out of the current context.
  ;; TO DO: UPGRADE SIMILAR TO `signal-truth-value-clash' TO MARK
  ;;    (ONE OF) THE CULPRITS AS INCONSISTENT.  REQUIRES THAT THE
  ;;    RESPONSIBLE PROPOSITION IS SUPPLIED AS AN ARGUMENT.
  (if (and (defined? term1)
	   (defined? term2))
    (signal CLASH term1 " clashes with " term2)
    (signal CLASH "Unification clash.")) )

;; Not called anywhere:
(defun signal-variable-value-clash 
       ((skolem SKOLEM) (value1 OBJECT) (value2 OBJECT))
  ;; Signal a clash between values equated with 'skolem' and jump
  ;;    out of the current context.
  ;; TO DO: FIGURE OUT HOW TO ASSERT THE CLASHING PROPOSITION.
  (if (and (defined? value1)
             (defined? value2))
    (signal CLASH
	    "Skolem " skolem " is equated with multiple values:" EOL
	    "   " value1 " and " value2 ".")
    (signal CLASH "Variable value clash.")) )

(defun signal-truth-value-clash ((proposition PROPOSITION))
  ;; Mark `proposition' as inconsistent and signal a clash.
  (assign-truth-value proposition INCONSISTENT-TRUTH-VALUE)
  (cond
   ((eql? *context* (meta-inference-cache *module*))
    (signal CLASH
	    "Derived both TRUE and FALSE for the proposition " proposition "." EOL
	    "   Clash occurred in the meta inference cache for module "
            *module* "."))
   ((eql? *context* (truth-maintained-inference-cache *module*))
    (signal CLASH
	    "Derived both TRUE and FALSE for the proposition " proposition "." EOL
	    "   Clash occurred in the default inference cache for module "
            *module* "."))
   ((eql? *context* *module*)
    (signal CLASH
	    "Derived both TRUE and FALSE for the proposition " proposition "." EOL
	    "   Clash occurred in module " *module* "."))
   (otherwise
    (signal CLASH
	    "Derived both TRUE and FALSE for the proposition " proposition "." EOL
	    "   Clash occurred in the world " *context* 
            " in module " *module* "."))) )

(defun (logical-type TYPE) ((self OBJECT))
  ;; Return the base type for 'self'.
  (typecase self
    (DESCRIPTION
     (cond
      ((and (monadic? self)
            (iota? self))
       (return (skolem-type (first (io-variables self)))))
      ((and (monadic? self)
            (non-empty? (io-variables self)) ;; for robustness, shouldn't happen
            (defined? (skolem-type (first (io-variables self))))
            (class-description? 
             (surrogate-to-description 
              (skolem-type (first (io-variables self))))))
       (return PL-KERNEL/@CONCEPT))
      (otherwise
       (return PL-KERNEL/@RELATION))))
    (PATTERN-VARIABLE
     (let ((type (skolem-type self)))
       (when (and (defined? type)
                  (not (eql? type @THING)))
         (return type)))
     ;; THIS MAY BE REDUNDANT:  -rmm
     (foreach p in (unfiltered-dependent-isa-propositions self)
              where (and (eql? (kind p) :ISA)
                         (variable-type? p))
              do (return (relationRef p)))
     (return @THING))
    (SKOLEM
     (if (defined? (skolem-type self))
       (return (skolem-type self))
       (return @THING)))
    (LOGIC-OBJECT
     (return @THING))
    (LITERAL-WRAPPER (return (wrapper-value-type self)))
    (SURROGATE
     (if (and (defined? (surrogate-value self))
              (not (eql? (surrogate-value self) BOTTOM)))
       (return (logical-type (surrogate-value self)))
       (return @THING)))
    (SET (return PL-KERNEL/@SET))
    (CLASS (return PL-KERNEL/@CONCEPT))
    (SLOT (if (boolean-type? (slot-base-type self))
              (return PL-KERNEL/@RELATION)
            (return PL-KERNEL/@FUNCTION)))
    (otherwise (return (primary-type self)))) )

(defspecial *suppressUntypedTypeError?* BOOLEAN FALSE
  :documentation "Used by 'safe-logical-type' to ask for a type
without signalling an error if none exists.")

(defun (safe-logical-type TYPE) ((self OBJECT))
  ;; Compute the logical type of 'self'.  Return NULL if no type exists
  ;;    (rather than signalling an error).
  (special ((*suppressUntypedTypeError?* TRUE))
    (return (logical-type self)) ))

(defun (class-logical-type TYPE) ((self CLASS))
  ;; Given a class, return its type within the logic system.
  (safety 3 (not (subclass-of? self (type-class @WRAPPER)))
          "INTERNAL ERROR: Must have forgotten to unwrap a wrapper type")
  (return (class-type self)) )

(defun unify-types ((term1 SKOLEM) (term2 OBJECT))
  ;; Unification of the types of 'term1' and 'term2'.
  ;; Check for clash, and infer type of typeless skolem.
  ;; Also signal a clash if '(not-bottom? term1)' and '(bottom term2)'.
  ;; Note: Skolem types only get bound once.
  (let ((type1 (logical-type term1))
        (type2 (logical-type term2)))
    (cond
     ;; TO DO: REPLACE THIS WITH DISJOINT TYPES TEST:
     ((or (eql? type1 type2)
          (or (logical-subtype-of? type1 type2)
              (logical-subtype-of? type2 type1))))
     ((eql? type1 @THING)
      (when (isa? term1 @SKOLEM))
      (setf (skolem-type (cast term1 SKOLEM)) type2))
     ((eql? type2 @THING)
      (when (isa? term2 @SKOLEM)
        (setf (skolem-type (cast term2 SKOLEM)) type1)))
     (otherwise
      ;; not a clash if 'term2' is BOTTOM and 'term1' allows the binding:
      (when (bottom? term2)
        (return))
      (signal-unification-clash term1 term2))) ))

;(defun unify-attribute-propositions
;       ((attributes1 (LIST OF PROPOSITION))
;        (attributes2 (LIST OF PROPOSITION)))
;  ;; Linear time update of matching attribute propositions belonging to
;  ;;    two unified logic objects.
;  ;; Scan 'attributes1' and 'attributes2' in parallel, unifying the
;  ;;    output values wherever matching attribute proposition are found.
;  ;; Signal a clash if an attributes value clash is found.
;  (when (or (empty? attributes1)
;            (empty? attributes2))
;    (return))
;  ;; Scan for matching attributes.  Check for clashes:
;  (let ((cursor1 (the-cons-list attributes1))
;        (slotRef1 (relationRef (value cursor1)))
;        (cursor2 (the-cons-list attributes2))
;        (slotRef2 (relationRef (value cursor2))))
;    (loop
;      (if (slotRef-less-or-equal? slotRef1 slotRef2)
;        (progn
;          (when (eql? slotRef1 slotRef2)
;            (let ((p1 PROPOSITION (value cursor1))
;                  (p2 PROPOSITION (value cursor2)))                  
;              (equate-values (function-value p1) (function-value p2))))
;          (setq cursor1 (rest cursor1))
;          (when (null? cursor1)
;            (return))
;          (setq slotRef1 (relationRef (value cursor1))))
;        (progn
;          (setq cursor2 (rest cursor2))
;          (when (null? cursor2)
;            (return))
;          (setq slotRef2 (relationRef (value cursor2)))))) ))

(defun unify-skolem-and-value ((skolem SKOLEM) (value OBJECT))
  ;; NOT USED.
  ;; Helping method for 'bind-skolem-to-value'.
  ;; Inherit propositions attached to 'skolem' to 'value'.
  ;; Tricky: For :DESCRIPTION mode, we don't want unification to propagate 
  ;;    outside of the description.  However, if 'value' is a LOGIC-OBJECT,
  ;;    then it is necessarily a skolem belonging to the description (a 
  ;;    surrogate always gets sandwiched in between a skolem and a non-skolem 
  ;;    object).
  ;; TO DO: GENERALIZE THIS TO ITERATE OVER ALL PROPOSITIONS ATTACHED
  ;;    TO ANCESTORS OF '(equivalent-of skolem)':
  (foreach prop in (unfiltered-dependent-propositions skolem NULL)
      do (evaluate-proposition prop)) )

(defun bind-skolem-to-value 
       ((fromSkolem SKOLEM) (toValue OBJECT) (topLevelUpdate? BOOLEAN))
  ;; Make 'toValue' the value of 'fromSkolem'.
  ;; When constraint propagation is enabled, unify the types of 'toValue' and
  ;;    'fromSkolem', and recursively unify attribute values and dependent 
  ;;    propositions.
  ;; Assumes that 'fromSkolem' is not bound.
  ;; NOTE: TO PROPERLY HANDLE DEFAULT EQUIVALENCES AND FUNCTION VALUES,
  ;;    WE NOW ASSUME THAT THE TRUTH-VALUE OF EVERY VARIABLE-VALUE LINK 
  ;;    BETWEEN A SKOLEM AND ITS VALUE IS INFERRABLE FROM AN ASSOCIATED
  ;;    EQUIVALENCE PROPOSITION.  THUS THE VALUE LINKS ARE MERELY USED
  ;;    FOR EFFICENT REPRESENTATION OF EQUIVALENCE CLASSES.
  (safety 3 (unbound? fromSkolem) 
          "INTERNAL ERROR: Bound skolem passed to `bind-skolem-to-value'.")
  (let ((typeIsOK? BOOLEAN NULL)
        (type (skolem-type fromSkolem))
        (equatingProposition PROPOSITION NULL))
    (when (skolem? toValue)
      (setq equatingProposition (find-equating-proposition toValue fromSkolem))
      (when (and (defined? equatingProposition)
                 (default-true? equatingProposition))
        ;; Currently, we don't allow two skolems to be equated by default.  This
        ;;    ensures that every equivalence class (value-of chain) has at most
        ;;    one default link (the one leading to the extensional object), which
        ;;    in turn makes it easier to handle default overrides:
        (signal-proposition-error
         "Equating two skolems " fromSkolem " and " toValue
         " by default is not yet supported." EOL)))
    (mv-setq (typeIsOK? toValue) (check-coerced-type? toValue type TRUE))
    (when (not typeIsOK?)
      ;; quick type check failed, recover the offending equivalence proposition:
      (setq equatingProposition (find-equating-proposition toValue fromSkolem))
      (cond ((null? equatingProposition)
             (special ((*termUnderConstruction* *termUnderConstruction*))
               (when (null? *termUnderConstruction*)
                 (setq *termUnderConstruction*
                   (defining-proposition fromSkolem)))
               (signal-proposition-warning
                "Type check violation: Assigned value `" toValue "'" EOL
                "   to skolem with type `" type "'.")))
            (otherwise
             ;; This will `check-coerced-type?' again in non-shallow mode:
             (verify-argument-types-and-count equatingProposition)))))
  (setf (variable-value fromSkolem) toValue)
  ;; set variable-value-inverse link:
  (typecase toValue
    (SKOLEM
     ;; check for circular link; undo and exit if found:
     (let ((equivalentSkolem (variable-value toValue)))
       (loop
         (when (null? equivalentSkolem)
           (break))           
         (typecase equivalentSkolem
           (SKOLEM
            (when (eql? equivalentSkolem toValue)        ; oops; circularity
              (setf (variable-value fromSkolem) NULL)    ; undo last link
              (return))
            (setq equivalentSkolem (variable-value equivalentSkolem)))
           (otherwise (break)))))
     ;; no circularity; now set the inverse link:
     (setf (variable-value-inverse toValue)
           (cons fromSkolem (variable-value-inverse toValue)))
     ;; if 'toValue' is missing a type, supply one:
     (when (null? (skolem-type toValue))
       (setf (skolem-type toValue) (skolem-type fromSkolem))))
    (LOGIC-OBJECT
     (setf (variable-value-inverse toValue)
           (cons fromSkolem (variable-value-inverse toValue))))
    (otherwise
     ;; possibly relink 'fromSkolem' to point to wrapped version of 'toValue':
     (let ((proposition (defining-proposition fromSkolem)))
       (when (and (defined? proposition)
                  (rewrap-ith-argument?
                   toValue proposition (length (arguments proposition))))
         (setf (variable-value fromSkolem) (rewrap-argument toValue))))))
  (handle-out-of-date-inference-cache :ASSERT (defining-proposition fromSkolem))
  (react-to-kb-update *context* fromSkolem)
  (when (not (skolem? toValue))
    (when (defined? (defining-proposition fromSkolem))
      ;; Tricky: We DON'T call 'update-proposition-truth-value' here
      ;;    because the truth of a defining proposition isn't subject
      ;;    to the normal kinds of propagation:
      ;(assign-truth-value (defining-proposition fromSkolem) TRUE)
      (react-to-skolem-value-update 
       fromSkolem NULL toValue topLevelUpdate?))) )

(defun unbind-skolem-value ((skolem SKOLEM) (topLevelUpdate? BOOLEAN))
  ;; Called by 'unequate-values' and 'clip-value?'.
  ;; Remove the link between 'skolem' and '(variable-value skolem)'.
  ;; Note: This implicitly unbinds all skolems bound to 'skolem' (i.e., skolems
  ;;    higher in a 'variable-value' chain).
  (let ((oldValue (value-of skolem))
        (definingProp (defining-proposition skolem))
        (equatingProp PROPOSITION NULL))
    (unlink-equivalent-value skolem)
    (setq equatingProp (find-equating-proposition oldValue skolem))
    (cond
     ((defined? equatingProp)
      ;; Retract the corresponding equivalence proposition:
      (update-proposition-truth-value equatingProp :RETRACT-TRUE)
      (handle-out-of-date-inference-cache :RETRACT equatingProp))
     (otherwise
      (handle-out-of-date-inference-cache :RETRACT definingProp)))
    (when (defined? definingProp)
      (react-to-skolem-value-update
       skolem oldValue NULL topLevelUpdate?))))

(defun constrain-as-subset ((set1 COLLECTION)
                            (set2 COLLECTION))
  ;; Signal clash if 'set1' cannot logically represent a subset of 'set2'.
  ;; Assumes that 'set1' and 'set2' have no duplicates.
  ;; Assumes that skolem members are necessarily distinct from sibling set members.
  ;; TO DO: THE UNIFICATION IS NOT COMPLETE FOR SOME CASES WHEN SKOLEMS
  ;;    ARE PRESENT.
  ;; EXAMPLE OF INCOMPLETENESS:
  ;;   (subset-of {1,sk1} {2,sk2}) IMPLIES THAT sk1 = 2 and sk2 = 1.
  ;;   WE DON'T MAKE THAT INFERENCE (YET).
  (when (> (length set1) (length set2))
    (signal-unification-clash set1 set2))
  (let ((copy1 NIL)
        (copy2 NIL))
    ;; make copy of set2:
    (foreach i2 in set2 do (pushq copy2 i2))
    (foreach i1 in set1
             do
             (if (member? copy2 i1)
               (setq copy2 (remove copy2 i1))
               (pushq copy1 i1)))
    ;; at this point 'copy1' and 'copy2' represent 'set1' and 'set2' with
    ;;    matching members deleted.
    (when (empty? copy1)
      (return))
    (when (eql? (length copy2) 1)
      ;; both sets have a single member remaining. Equate them:
      (let ((item1 (first copy1))
            (item2 (first copy2)))
        (equate-values item1 item2)
        (return)))
    ;; 'copy2' has two or more members; 'copy1' has at least one:
    (let ((skolemCount1 0)
          (skolemCount2 0))
      (foreach i1 in copy1 where (skolem? i1)
               do (++ skolemCount1))
      (foreach i2 in copy2 where (skolem? i2)
               do (++ skolemCount2))
      (when (eql? (+ skolemCount1 skolemCount2) 0)
        (signal-unification-clash set1 set2))) ))

(defun equate-collections ((col1 COLLECTION) (col2 COLLECTION))
  ;; If 'col1' and 'col2' are logically incompatible signal
  ;;    a clash.
  ;; If a correspondence can be established between members of 'col1' and
  ;;    members of 'col2', then unify the corresponding members.
  (when (and (ordered? col1) (ordered? col2))
    (foreach i1 in col1
             as i2 in col2
             do (equate-values i1 i2))
    (return))
  (when (and (no-duplicates? col1) (no-duplicates? col2))
    (constrain-as-subset col1 col2)
    (constrain-as-subset col2 col1)))

(defun (logic-collection? BOOLEAN) ((term OBJECT))
  ;; Returns TRUE if `term' is a subtype of logic collection.
  (return (test-type-on-instance? term LOGIC/@COLLECTION)))

;; TO DO: INVENT A DEFAULT VERSION OF 'equate-values':
(defun equate-values ((term1 OBJECT) (term2 OBJECT))
  ;; Equate the terms 'term1' and 'term2'.
  ;; If one or the other is a skolem, point its value at the other.
  ;; Otherwise, if they are unequal, signal a clash.
  ;; CAUTION: Assumes that 'term1' and 'term2' represent the end-point of
  ;;    variable-value chains.  In particular, this means that any skolems
  ;;    detected are unbound.
  (cond
   ((eql? term1 term2) NULL)
   ((skolem? term1)
    (bind-skolem-to-value term1 term2 FALSE))
   ((skolem? term2)
    (bind-skolem-to-value term2 term1 FALSE))
   ;; TO DO: GENERALIZE THIS TO INCLUDE INTERVALS:
   ((and (stella-collection? term1)
         (stella-collection? term2))
    (equate-collections term1 term2))
   ((and (isa? term1 PL-KERNEL/@INTERVAL-CACHE)
         (isa? term2 PL-KERNEL/@INTERVAL-CACHE))
    ;; should we have an `equate-intervals' function?
    (pl-kernel/unify-interval-caches term1 term2 PL-KERNEL/@>=)
    (pl-kernel/unify-interval-caches term2 term1 PL-KERNEL/@>=))
   (otherwise ;; 'term1' and 'term2' are non-`eql?' constants:
    (signal-unification-clash term1 term2))))

;;; EXPERIMENT:
;;; IF WE KEEP THIS, IT HAS TO GO INTO THE DEFINITION OF `SKOLEM' TO MAKE IT
;;;    CONTEXT SENSITIVE.  WE WON'T KEEP IT.
(defslot SKOLEM conflicting-default-values
  :type (CONS OF PROPOSITION)
  :default NIL
  ; :context-sensitive? TRUE
  )

;;; EXPERIMENT:
(defun (unequate-conflicting-default-values? BOOLEAN)
    ((newEquatingProp PROPOSITION))
  ;; Situation: `newEquatingProp' has just been derived during forward inference.
  ;; Unequate any conflicting default values and return TRUE upon success.
  ;; .....
  ;; OUCH THIS IS UGLY.....AND STILL DOESN'T PROPERLY HANDLE THE RETRACTION OF
  ;;    THE DEFAULT PROPOSITIONS INVOLVED.  ALSO, IF WE RETRACT A VALUE THEN
  ;;    LATER DEFAULT FORWARD INFERENCES MIGHT THINK THERE IS NO PROBLEM!!!!!
  ;; FIX: USE AN INCOHERENT TRUTH-VALUE AND KEEP PROPAGATING UNTIL NO MORE
  ;;    CLASHES CAN BE DERIVED.  THE REMAINING CONSISTENT PROPOSITIONS ARE
  ;;    THE "SKEPTIC" CLOSURE.
  (let ((arguments (arguments newEquatingProp))
        (firstArg (first arguments))
        (firstArgIsSkolem? (skolem? firstArg))
        (firstArgValue (innermost-of firstArg))
        (secondArg (second arguments))
        (secondArgIsSkolem? (skolem? secondArg))
        (secondArgValue (innermost-of secondArg))
        (newIsDefault? (default-true? newEquatingProp))
        (newTruthValue OBJECT NULL)
        (equatingProp PROPOSITION NULL))
    ;; handle simple conflict/no-conflict cases:
    (cond ((eql? firstArgValue secondArgValue)
           (return TRUE))
          ((skolem? firstArgValue)
           ;; first arg is unbound:
           (if (or (empty? (conflicting-default-values
                            (cast firstArgValue SKOLEM)))
                   (not newIsDefault?))
               (return TRUE)
             (return FALSE)))
          ((skolem? secondArgValue)
           ;; second arg is unbound:
           (if (or (empty? (conflicting-default-values
                            (cast secondArgValue SKOLEM)))
                   (not newIsDefault?))
               (return TRUE)
             (return FALSE))))
    ;; check for illegal default equation of two skolems:
    (when (and firstArgIsSkolem?
               secondArgIsSkolem?
               newIsDefault?)
      ;; see `bind-skolem-to-value':
      (signal-proposition-error
       "Equating two skolems " firstArg " and " secondArg
       " by default is not yet supported." EOL))
    ;; Handle conflicts: there are 3 possible conflict scenarios:
    ;; (1) firstArg is a skolem with an existing value and we are trying to
    ;;     equate it with a new conflicting non-skolem value.
    ;; (2) secondArg is a skolem with an existing value and we are trying to
    ;;     equate it with a new conflicting non-skolem value.
    ;; (3) Both firstArg and secondArg are skolems with different existing values
    ;;     and we are now equating them.
    ;; To figure out whether there is a conflict and how to resolve it, we have
    ;;     to determine what scenario we are in, and then lookup the supporting
    ;;     equivalence propositions and act according to their truth values.
    ;; Temporarily "retract" the truth of `newEquatingProp' so we won't find it:
    (setq newTruthValue
      (slot-value newEquatingProp truth-value :context-sensitive? FALSE))
    (setf (slot-value newEquatingProp truth-value :context-sensitive? FALSE) NULL)
    (when firstArgIsSkolem?
      ;; we have a non-empty chain from `firstArg' to `firstArgValue' and
      ;;    `firstArgValue' is not a skolem and not eq to `secondArgValue':
      (special ((*dontUseDefaultKnowledge?* TRUE))
        (setq equatingProp (find-equating-proposition firstArgValue firstArg)))
      (when (null? equatingProp)
        ;; the first value holds only by default and needs to be retracted:
        (setq equatingProp (find-equating-proposition firstArgValue firstArg))
        (while (not (eql? (value-of firstArg) firstArgValue))
          (setq firstArg (value-of firstArg)))
        (let ((skolem SKOLEM firstArg))
          (setf (variable-value skolem) NULL)
          (setf (conflicting-default-values skolem)
            (cons equatingProp (conflicting-default-values skolem)))
          (when newIsDefault?
            (setf (conflicting-default-values skolem)
              (cons newEquatingProp (conflicting-default-values skolem)))))))
    (when secondArgIsSkolem?
      ;; we have a non-empty chain from `secondArg' to `secondArgValue' and
      ;;    `secondArgValue' is not a skolem and not eq to `secondArgValue':
      (special ((*dontUseDefaultKnowledge?* TRUE))
        (setq equatingProp (find-equating-proposition secondArgValue secondArg)))
      (when (null? equatingProp)
        ;; the second value holds only by default and needs to be retracted:
        (setq equatingProp (find-equating-proposition firstArgValue firstArg))
        (while (not (eql? (value-of secondArg) secondArgValue))
          (setq secondArg (value-of secondArg)))
        (let ((skolem SKOLEM secondArg))
          (setf (variable-value skolem) NULL)
          (setf (conflicting-default-values skolem)
            (cons equatingProp (conflicting-default-values skolem)))
          (when newIsDefault?
            (setf (conflicting-default-values skolem)
              (cons newEquatingProp (conflicting-default-values skolem)))))))
    ;; restore truth-value:
    (setf (slot-value newEquatingProp truth-value :context-sensitive? FALSE)
      newTruthValue)
    (return (or (and (not firstArgIsSkolem?)
                     (not secondArgIsSkolem?))
                ;; one or both were skolems; if both `newIsDefault?' will be FALSE:
                (not newIsDefault?)))))

(defun (unequate-values? BOOLEAN) ((term1 OBJECT) (term2 OBJECT))
  ;; Called by 'update-equivalence-proposition'.
  ;; If '(variable-value term1)' equals 'term2', break
  ;;    the link.  Otherwise, return FALSE indicating nothing happened.
  ;; Rationale: A direct equality link is assumed to be the result of an
  ;;    assertion (not an inference) and is therefore retractable.  Indirect
  ;;    (inferred) connections can't be retracted.
  (typecase term1
    (SKOLEM
     (when (eql? (variable-value term1) term2)
       (unbind-skolem-value term1 FALSE)
       (return TRUE)))
    (otherwise NULL))
  (return FALSE) )

(defun bind-to-equivalent-value ((from LOGIC-OBJECT) (to DESCRIPTION))
  ;; 'from' and 'to' are infered to be equivalent collections.
  ;; Bind 'from' to 'to' using either an 'equivalent-value' or a
  ;;    'variable-value' link.
  (when (eql? from to)
    (return))
  (typecase from
    (SKOLEM
     (safety 3 (null? (variable-value from)) "BUG in binding equivalent value")
     (setf (variable-value from) to))
    (otherwise
     (when (eql? (equivalent-value from) to)
       (return))
     (safety 3 (null? (equivalent-value from)) "BUG in binding equivalent value")
     (setf (equivalent-value from) to)))
  (setf (variable-value-inverse to)
        (cons from (variable-value-inverse from))) )

(defun unbind-equivalent-value ((self LOGIC-OBJECT))
  ;; Remove the link between 'self' and '(equivalent-value self)' or
  ;;    '(variable-value self)'.
  ;; Note: This implicitly unbinds all equivalents bound to 'self' (i.e., 
  ;;    instances higher in ab 'equivalent-value' chain).
  (typecase self
    (SKOLEM (unbind-skolem-value self FALSE))
    (otherwise
     (unlink-equivalent-value self)
     (handle-out-of-date-inference-cache :RETRACT NULL))))

(defun unlink-equivalent-value ((self LOGIC-OBJECT))
  ;; Remove the link between 'self' and '(equivalent-value self)' or
  ;;    '(variable-value self)'.
  ;; Note: This implicitly unbinds all equivalents bound to 'self' (i.e., 
  ;;    instances higher in an 'equivalent-value' chain).
  ;; Extracted from `unbind-skolem-value' to unlink only without the
  ;;    updating of inference caches (so we can use it in
  ;;    `destroy-logic-instance').  Generalized to handle skolems and
  ;;    general logic objects.
  (let ((oldValue OBJECT NULL))
    (typecase self
      (SKOLEM
       (setq oldValue (value-of self))
       (setf (variable-value self) NULL))
      (otherwise
       (setq oldValue (equivalent-value-of self))
       (setf (equivalent-value self) NULL)))
    (typecase oldValue
      (LOGIC-OBJECT
       ;; logic borrowed from 'unbind-skolem-value':
       ;; Remove 'self' from the list of variable value inverses 
       ;;    attached to 'oldValue'.
       ;; Tricky: The combination of structure sharing and context sensitivity
       ;;    means that we copy the list before destructivly modifying it:
       (if (eql? (first (variable-value-inverse oldValue)) self)
         (setf (variable-value-inverse oldValue)
               (rest (variable-value-inverse oldValue)))
         (setf (variable-value-inverse oldValue)
           (remove (copy-cons-list (variable-value-inverse oldValue)) self))))
      (otherwise NULL))))

(defun (equivalent-collection-priority INTEGER) ((self LOGIC-OBJECT))
  ;; Helping function for 'equivalence-collections'.
  ;; Return an integer indicating how strongly we wish to point
  ;;    AT 'self'.
  (typecase self
    (NAMED-DESCRIPTION (return 1))
    (DESCRIPTION (return 2))
    (otherwise (return 0))) )

;; DEBUGGING FLAG:
(defglobal *equivalence-collections?* BOOLEAN TRUE
  :documentation "Experiment with equality reasoning on collections.")

(defun equivalence-collections 
       ((collection1 LOGIC-OBJECT) (collection2 LOGIC-OBJECT))
  ;; Create an equivalence link between 'collection1' and
  ;;    'collection2'.
  ;; Prefer to point AT a description than a non-description, and
  ;;    prefer to point at an unnamed description over a named one.
  (when (not *equivalence-collections?*)
    (return))
  (let ((value1 (equivalent-value-of (value-of collection1)))
        (value2 (equivalent-value-of (value-of collection2))))
    (if (> (equivalent-collection-priority value1)
           (equivalent-collection-priority value2))
      (bind-to-equivalent-value value2 value1)
      (bind-to-equivalent-value value1 value2)) ))

(defun revise-equivalences ((proposition PROPOSITION) (goesTrue? BOOLEAN))
  ;; Called by 'run-goes-true-demons' and 'run-goes-unknown-demons'.
  ;; 'proposition' has just become true, or become unknown.
  ;; Revise 'equivalent-value' link between its arguments accordingly.
  (let ((arg1 LOGIC-OBJECT (nth (arguments proposition) 0))
        (arg2 LOGIC-OBJECT (nth (arguments proposition) 1)))
    (when (not *equivalence-collections?*)
      (return))
    (cond
     (goesTrue?
      (when (and (collection-implies-collection? arg1 arg2)
                 (collection-implies-collection? arg2 arg1))
        (equivalence-collections arg1 arg2)))
     ((or (defined? (equivalent-value arg1))
          (defined? (equivalent-value arg2)))
      (print "DIDN'T FINISH 'revise-equivalences' YET. DON'T KNOW HOW" EOL
             "   TO REMOVE AN 'equivalent-value' LINK" EOL))
     ((or (and (isa? arg1 @SKOLEM)
               (defined? (variable-value (cast arg1 SKOLEM))))
          (and (isa? arg2 @SKOLEM)
               (defined? (variable-value (cast arg2 SKOLEM)))))
      (print "DIDN'T FINISH 'revise-equivalences' YET. DON'T KNOW HOW" EOL
             "   TO REMOVE AN 'equivalent-value' LINK" EOL))) ))

(defun (find-equating-proposition PROPOSITION) ((directObject OBJECT)
                                                (indirectObject LOGIC-OBJECT))
  ;; Return a true equivalence proposition that has `directObject' as one
  ;;    argument and `indirectObject' (or one of `indirectObject's equivalents)
  ;;    as the other argument.  Looks up equivalence propositions from
  ;;    `indirectObject's backlinks which is why that argument needs to be
  ;;    a LOGIC-OBJECT.
  ;; This is primarily used to determine the truth-value of a
  ;;    `variable-value' link.
  (let ((indirectObjectValue (value-of indirectObject))
        (backlinkedIndirectObject indirectObjectValue))
    (when (not (isa? backlinkedIndirectObject @LOGIC-OBJECT))
      (setq backlinkedIndirectObject indirectObject))
    (return
      (some prop in (cast (choose
                           (description-mode?)
                           ;; can't look for true props in description mode:
                           (allocate-iterator
                            (unfiltered-dependent-propositions
                             backlinkedIndirectObject PL-KERNEL/@EQUIVALENT))
                           (all-true-dependent-propositions
                            backlinkedIndirectObject PL-KERNEL/@EQUIVALENT FALSE))
                          ;; problem with `choose' walker
                          (ITERATOR OF PROPOSITION))
          where (and
                 ;; still need this test for unfiltered case:
                 (eql? (operator prop) PL-KERNEL/@EQUIVALENT)
                 (or (and (eql? (first (arguments prop)) directObject)
                          (eql? (value-of (second (arguments prop)))
                                indirectObjectValue))
                     (and (eql? (second (arguments prop)) directObject)
                          (eql? (value-of (first (arguments prop)))
                                indirectObjectValue))))))))


  ;;
;;;;;; Special propositional constants
  ;;

(defconstant TRUE-PROPOSITION PROPOSITION
  (new PROPOSITION
       :kind :CONSTANT
       ;; BUG: Using @TRUE creates a LOGIC/@TRUE surrogate which doesn't
       ;;    have a corresponding symbol.  So, use STELLA/@TRUE for now:
       :operator STELLA/@TRUE
       :arguments (new ARGUMENTS-VECTOR :array-size 0)
       :truth-value TRUE-TRUTH-VALUE))

(defconstant FALSE-PROPOSITION PROPOSITION
  (new PROPOSITION
       :kind :CONSTANT
       :operator STELLA/@FALSE
       :arguments (new ARGUMENTS-VECTOR :array-size 0)
       :truth-value FALSE-TRUTH-VALUE))

(startup-time-progn
 (setf (surrogate-value STELLA/@TRUE) TRUE-PROPOSITION)
 (setf (surrogate-value STELLA/@FALSE) FALSE-PROPOSITION))


  ;;
;;;;;; 'evaluate-term' (called by the parser)
  ;;

;;; The proposition tree parser calls these methods to evaluate terms that
;;;    appear within proposition trees.

(defun (evaluate-term OBJECT) ((self OBJECT))
  (typecase self
    (LITERAL-WRAPPER (return (evaluate-LITERAL-WRAPPER-term self)))
    (SURROGATE
     (return (evaluate-SURROGATE-term self)))
    (SYMBOL (return (evaluate-SYMBOL-term self)))
    (CONS
     (case (first self)
       ((SETOFALL THE-ONLY KAPPA)
        (return (evaluate-LOGIC-OBJECT-term 
                 (evaluate-DESCRIPTION-term self TRUE))))
       (CREATE (return (evaluate-CREATE-term self)))
       (otherwise (return (evaluate-FUNCTION-term self)))))
    (LOGIC-OBJECT
     (return (evaluate-LOGIC-OBJECT-term self)))
    (PROPOSITION (return self))
    (THING (return self))
    (KEYWORD (return self))
    ;; should never happen
    (otherwise (error "Can't evaluate the term " self))) )

(defun (evaluate-LITERAL-WRAPPER-term OBJECT) ((self LITERAL-WRAPPER))
  (return (permanentify self)))

;;; TO DO: FIGURE OUT HOW TO ADD TYPES TO SURROGATES.  IDEA: IF SUBSTITUTING
;;;    A VALUE, THE PRIMARY TYPE OF THE NEW VALUE MUST SPECIALIZE THE PRIMARY
;;;    TYPE OF THE OLD VALUE.

;;; Evaluation of surrogates
;;;    Surrogates are evaluated differently depending on *evaluationMode*:
;;;   EXTENSIONAL:
;;;    The current value of the surrogate is returned.
;;;    The value of the surrogate must be defined at evaluation time --
;;;    if the surrogate is undefined, an instance is allocated on-the-fly,
;;;    and the surrogate is bound to it.
;;;   DESCRIPTION and QUERY:
;;;    The surrogate is returned unevaluated (except when they point to literals.
;;;    This has the beneficial effect of preventing the creating of backlinks
;;;    from external objects back into a description.
;;;   INTENSIONAL:
;;;    In this case we want ALL references (across all descriptions
;;;    and assertions) to refer to the same intensional object
;;;    regardless of the surrogate's binding.  We accomplish this by
;;;    inserting an intensional skolem between the surrogate and the
;;;    (extensional) skolem that it is bound to.

;;; Note on surrogate bindings:
;;;  The type of a surrogate is determined by the object that it points to.
;;;  If a different value is assigned to a surrogate, that value must have the
;;;     same primary type as its predecessor.
;;;  If we need to compute the type of a surrogate 'self', then it's an error
;;;     if '(value-of self)' is not defined.

(defun (evaluate-SURROGATE-term OBJECT) ((self SURROGATE))
  ;; Evaluate the surrogate 'self' (see comment above for details).
  (case *evaluationMode*
    (:EXTENSIONAL-ASSERTION
     (let ((value (surrogate-value self))
           (store OBJECT-STORE NULL))
       (cond
        ((defined? value)
         (typecase value
           (RELATION (return (get-description self)))
           (otherwise (return value))))
        (otherwise
         ;; tricky: if we locked onto an unbound surrogate outside of *module*
         ;;    (e.g., inherited from a code module), shadow it with a local one:
         (setq self (coerce-to-bound-or-local-surrogate self))
         (setq store (home-object-store self))
         (when (defined? store)
           (fetch-instance store self))
         (when (null? (surrogate-value self))
           ;; still NULL, bind it with a blank object (thus, allow implicit
           ;;    introduction of logic objects) - this does handle forward
           ;;    references to as yet undefined relations gracefully:
           (create-logic-instance self NULL))
         (return (surrogate-value self))))))
    (:DESCRIPTION
     (let ((surrogateValue (surrogate-value self))
           (store OBJECT-STORE NULL))
       (cond
        ((null? surrogateValue)
         ;; tricky: if we locked onto an unbound surrogate outside of *module*
         ;;    (e.g., inherited from a code module), shadow it with a local one:
         (setq self (coerce-to-bound-or-local-surrogate self))
         (setq store (home-object-store self))
         (when (defined? store)
           (fetch-instance store self))
         (when (null? (surrogate-value self))
           ;; still NULL, bind it with a blank object (thus, allow implicit
           ;;    introduction of logic objects) - this does handle forward
           ;;    references to as yet undefined relations gracefully:
           (create-logic-instance self NULL))
         (return self))
        ((isa? surrogateValue @LITERAL-WRAPPER)
         (return surrogateValue))
        (otherwise
         (return self)))))
    (:INTENSIONAL-ASSERTION
     (let ((directValue (surrogate-value self))
           (intensionalSkolem SKOLEM NULL))
       (when (skolem? directValue)
         (return directValue))
       ;; slip in a new skolem BETWEEN 'self' and its direct value:
       (setq intensionalSkolem (create-skolem
                                (choose (defined? directValue)
                                  (logical-type (value-of directValue))
                                  NULL)
                                NULL))
       (setf (surrogate-value self) intensionalSkolem)
       (bind-skolem-to-value intensionalSkolem directValue FALSE)
       (return intensionalSkolem)))) )

(defun (evaluate-LOGIC-OBJECT-term OBJECT) ((self LOGIC-OBJECT))
  ;; Evaluate the logic object `self'.
  ;; This supports automatically generated proposition trees that
  ;;    directly point to logic objects.
  ;; TO DO: FLESH OUT THE MISSING CASES ONCE WE FIGURE OUT WHAT
  ;;    THEY SHOULD EVALUATE TO (SEE ALSO `inherit-proposition-argument').
  (typecase self
    (PATTERN-VARIABLE NULL)
    (SKOLEM
     ;; Always return this, since they are legal and can arise in queries.
     ;; Was previously allowed except in (description-mode?).
     (return self))
    (DESCRIPTION
     ;; unnamed descriptions are legal proposition arguments, but within
     ;;    descriptions, named ones are pointed at by their surrogates:
     (when (description-mode?)
       (let ((name (surrogate-value-inverse self)))
         (when (defined? name)
           (return name))))
     (return self))
    (otherwise
     (if (description-mode?)
         (let ((name (surrogate-value-inverse self)))
           (when (defined? name)
             (return name)))
       (return self))))
  (signal-proposition-error "Illegal LOGIC-OBJECT term: " self)
  )

(defconstant ANONYMOUS-VARIABLE-NAME SYMBOL (QUOTE ?)
  :documentation "Variables with name 'ANONYMOUS-VARIABLE-NAME' are considered
anonymous, and are not assumed to be identical to any other variable also named
'ANONYMOUS-VARIABLE-NAME'.")

(defun (anonymous-variable? BOOLEAN) ((self SKOLEM))
  ;; Return TRUE if the name of 'self' matches ANONYMOUS-VARIABLE-NAME.
  (return (and (eql? (skolem-name self) ANONYMOUS-VARIABLE-NAME)
               (variable? self))) )

(defun (evaluate-SYMBOL-term OBJECT) ((self SYMBOL))
  ;; Look for a variable named 'self'.  If found, return its value.
  ;; Otherwise, signal an undeclared variable error.
  (let ((value (lookup-logic-variable-binding self)))
    (cond
     ((defined? value)
      (return value))
     ((eql? self ANONYMOUS-VARIABLE-NAME)
      (return (create-variable NULL ANONYMOUS-VARIABLE-NAME FALSE)))
     ((question-mark-symbol? self)
      (signal-proposition-error "Reference to undeclared variable: " self))
     ((automatic-instance-symbol? self)
      (return (evaluate-automatic-instance self)))
     (otherwise
      ;; maybe a symbol got substituted for a surrogate:
      (setq value (surrogate-value (symbol-to-surrogate self)))
      (if (defined? value)
        (return value)
        (signal-proposition-error "Reference to undeclared symbol: " self)))) ))

(defglobal *MISSING-KEY-VALUE-LIST* KEY-VALUE-LIST
  (new KEY-VALUE-LIST)
  :documentation "Represents a key-value list that should never be used.")

(defspecial *automaticInstanceTable* (KEY-VALUE-LIST OF SYMBOL LOGIC-OBJECT)
  *MISSING-KEY-VALUE-LIST*
  :documentation "Used by 'evaluate-automatic-instance' to
record current bindings of automatic instance symbols.")

(defun (evaluate-automatic-instance OBJECT) ((name SYMBOL))
  ;; Look for an automatic instance having name 'name' in the
  ;;    scope of the current assertion.  If none exists, create
  ;;    an new gensym logic instance, and add it to the table.
  (when (eql? *automaticInstanceTable* *MISSING-KEY-VALUE-LIST*)
    (signal-proposition-error "Automatic instance " name " found outside" EOL
                              "   the scope of an assertion."))
  (let ((instance (only-if (defined? *automaticInstanceTable*)
                           (lookup *automaticInstanceTable* name))))
    (when (null? instance)
      (let ((surrogate 
             (string-to-surrogate
              (gensym (subsequence (symbol-name name) 1 NULL)))))
        (setq instance (create-logic-instance surrogate NULL))
        (when (null? *automaticInstanceTable*)
          (setq *automaticInstanceTable* (new KEY-VALUE-LIST)))
        (insert-at *automaticInstanceTable* name instance)))
    (return (evaluate-LOGIC-OBJECT-term instance) )))

(defun signal-undefined-term ((term OBJECT))
  ;; Warn of undefined term and signal exception.
  (signal-proposition-error "Reference to undefined term: " term) )

(defun signal-untyped-term ((term OBJECT))
  ;; Warn of untyped term and signal exception.
  (when (not *suppressUntypedTypeError?*)
    (signal-proposition-error "Need a type for the untyped term: " term)) )

(defun (evaluate-CREATE-term OBJECT) ((term CONS))
  ;; Evaluate a term of the form '(create <name> [<type>])'.
  ;; Create a new LOGIC-OBJECT or native class of logical type <type>
  ;;    and return it.
  ;; If <name> was supplied, convert it into a surrogate and bind
  ;;    it to the newly created object.
  (let ((nameSymbol SYMBOL (second term))
        (name (only-if (defined? nameSymbol)
                       (symbol-to-surrogate nameSymbol)))
        (typeSymbol SYMBOL (third term))
        (type (only-if (defined? typeSymbol)
                       (symbol-to-surrogate typeSymbol)))
        (term OBJECT NULL))
    (exception-case
     (setq term (create-logic-instance name type))
     (LOGIC-EXCEPTION (e)
       (print-stream STANDARD-ERROR (exception-message e))))
    (return term) ))

(defun (create OBJECT) ((name GENERALIZED-SYMBOL)
                              &rest (type GENERALIZED-SYMBOL))
  :documentation "Create a logic object with name 'name' and return it.
If `type' is also supplied, assert that the object belongs to that type."
  :public? TRUE :command? TRUE :evaluate-arguments? FALSE
  (let ((createTree (bquote (CREATE & name && (coerce-&rest-to-cons type))))
        (result (evaluate-CREATE-term createTree)))
    (return result)))


  ;;
;;;;;; Root type
  ;;

;;; We are still figuring out what to do with this slot.  Current strategy:
;;; For SKOLEMs, it contains a type representing one of
;;;    the most specific types infered for it.
;;; Ordinary LOGIC-OBJECTs no longer have root types.

(defun update-skolem-type ((self SKOLEM) (type TYPE))
  ;; 'self' has been asserted or conceived to belong to 'type'.
  ;; Set the root type of 'self' to 'type'.
  (let ((oldType (skolem-type self)))
    (when (or (null? oldType)
              (logical-subtype-of? type oldType))
      (setf (skolem-type self) type)) ))

(defun update-skolem-type-from-isa-assertions ((self PROPOSITION))
  ;; Assume `self' is a proposition that is newly or about to be asserted.
  ;; If it is an ISA proposition, update the root type of its first argument,
  ;;    if that argument is a skolem.
  ;; If it is an AND, call it recursively on its arguments (this is needed
  ;;    for propositions inside descriptions).
  (case (kind self)
    (:ISA
     (let ((object (first (arguments self))))
       (when (isa? object @SKOLEM)
         (update-skolem-type object (relationRef self)))))
    (:AND
     (foreach arg in (arguments self)
         do (update-skolem-type-from-isa-assertions arg)))
    (otherwise NULL)))

(defun (description-extension< BOOLEAN)
       ((desc1 DESCRIPTION) (desc2 DESCRIPTION))
  ;; Return TRUE if the extension on `desc1' is smaller than
  ;;    the one on `desc2'.
  (return (< (estimated-length (get-description-extension desc1 TRUE)) 
             (estimated-length (get-description-extension desc2 TRUE)))))

(defun print-extension-sizes ((module MODULE) (sizeCutoff INTEGER))
  :documentation "Print the extension sizes of concepts visible in `module'.
If `module' is NULL the current module is used.  Do not report extensions
with size less than `sizeCutoff' (default is 10)."
  :public? TRUE
  (when (null? sizeCutoff)
    (setq sizeCutoff 10))
  (when (null? module)
    (setq module *module*))
  (let ((descriptions (new (LIST OF NAMED-DESCRIPTION)))
        (size STRING NULL))
    (foreach d in (all-named-descriptions module false)
        where (and (defined? (extension d))
                   (>= (estimated-length (extension d)) sizeCutoff))
        collect d into descriptions)
    (sort descriptions (the-code :function description-extension<))
    (foreach desc in (reverse descriptions)
        do (setq size (integer-to-string (estimated-length (extension desc))))
           (setq size
             (concatenate
               (make-string (- 8 (length size)) #\space)
               size))
           (print size " : " (description-name desc) EOL))))


  ;;
;;;;;; Redefinition of relations and their attached descriptions
  ;;

(defun transfer-logic-information-from-relation-hook
       ((relationsList (LIST OF RELATION)))
  ;; Hook function called by 'undefined-old-class', attach-slot, and
  ;;   'attach-function'.  Transfer
  ;;   description and class-extension from old relation to new relation.
  (let ((oldRelation (first relationsList))
        (newRelation (second relationsList))
        (oldDescription (description oldRelation))
        (newDescription (description newRelation)))
    ;; if there is a new description, transfer information from
    ;;    the old description to it.  Otherwise, transfer the old
    ;;    description to the new relation:
    (when (defined? oldDescription)
      (retract-relation-axioms oldDescription)
      (if (defined? newDescription)
        (progn
          (safety 3 (not (eql? oldDescription newDescription))
                  "INTERNAL ERROR: Redefined relation uses old description.")
          (transfer-propositions-and-backlinks
           (description oldRelation) (description newRelation))
          (destroy-instance oldDescription))
        (progn
          (setf (description newRelation) oldDescription)
          (setf (native-relation oldDescription) newRelation)
          ;; tricky: normally superrelation links happend upon
          ;;    creation of a description.  In this case no creation
          ;;    occurs, but previous superrelation links have been
          ;;    retracted; now new ones must be asserted:
          (finalize-superrelation-links newRelation)))
      (setf (description oldRelation) NULL))
    ;; THIS MAY OR MAY NOT STAY THIS WAY:
    (typecase oldRelation
      (CLASS
       ;; transfer native-objects extension:
       (setf (class-extension (cast newRelation CLASS))
             (class-extension oldRelation))
       (setf (class-extension oldRelation) NULL))
      (otherwise NULL)) ))

(startup-time-progn
  (add-hook *redefine-relation-hooks*
            (quote transfer-logic-information-from-relation-hook)))

(defun retract-relation-axioms ((oldRelation NAMED-DESCRIPTION))
  ;; Called by 'transfer-logic-information-from-class-hook'.
  ;; The relation for 'definition' is being redefined.
  ;; Retract the truth value of each axiom, constraint, 
  ;;    and superrelation proposition (the new relation definition
  ;;    may reassert all of them, or not).
  (let ((originatedPropositions (originated-propositions oldRelation)))
    (when (defined? originatedPropositions)
      (foreach proposition in originatedPropositions
               do (unassert-proposition proposition)))) )

(defun (assert-description-implies-description PROPOSITION)
       ((sub DESCRIPTION) (super DESCRIPTION) (dontUpdate? BOOLEAN))
  ;; Assert an IMPLIES proposition between the descriptions
  ;;   'sub' and 'super'.
  (let ((impliesProp (create-implies-proposition sub super)))
    (setq impliesProp (fasten-down-one-proposition impliesProp FALSE))
    (unless dontUpdate?
      (update-proposition-truth-value impliesProp :ASSERT-TRUE))
    (return impliesProp) ))

(defun (assert-implies-link-between-relations PROPOSITION)
       ((sub NAMED-DESCRIPTION) (super NAMED-DESCRIPTION))
  ;; Called by 'finalize-superrelation-links' to handle the indexing
  ;;    that accompanies super/sub relation links.
  ;; Assert an IMPLIES proposition between 'sub' and 'super'.
  ;; Mark it as a 'subrelation-link?' and add it to
  ;;    '(originated-propositions sub)'.
  (let ((impliesProp
         (assert-description-implies-description sub super TRUE)))
    ;; mark 'impliesProp' as a sub/super link:
    (setf (subrelation-link? impliesProp) TRUE)
    ;; update AFTER marking link as subrelation link (REASON WHY MAY
    ;;    NO LONGER BE VALID NOW THAT SORTAL CHECK IS ELIMINATED):
    (update-proposition-truth-value impliesProp :ASSERT-TRUE)
    (link-originated-proposition sub impliesProp)
    (return impliesProp) ))

(defun finalize-superrelation-links ((self RELATION))
  ;; Called by 'get-description' upon first creation of description
  ;;    for 'self', and by 'transfer-logic-information-from-relation-hook'.
  (let ((subDescription (get-description self)))
    (special
     ((*evaluationMode* :EXTENSIONAL-ASSERTION)
      (*fillingConstraintPropagationQueues?* FALSE))
     ;; tricky: we might have been in description mode when triggering
     ;;    finalization:
     (within-module (home-context subDescription)        
      (foreach super in (direct-superrelations self)
               where (defined? (description super))
               do
               ;; assert an IMPLIES link between 'self' and 'super':
               (assert-implies-link-between-relations
                subDescription (get-description super)))) )))


  ;;
;;;;;; Creation of LOGIC-OBJECTs
  ;;

(defun (update-isa-proposition PROPOSITION)
       ((self OBJECT) (type TYPE) (updateMode KEYWORD))
  :public? TRUE
  ;; Assert or retract an ISA proposition to 'self' representing
  ;;    membership in type.
  (let ((isaProposition
         ;; check for duplicate:
         (some p in (unfiltered-dependent-isa-propositions self)
               where (eql? (relationRef p) type))))
    (when (null? isaProposition)
      (setq isaProposition (create-proposition (quote ISA) 1))
      (setf (operator isaProposition) type)
      (setf (nth (arguments isaProposition) 0) self)
      (fasten-down-one-proposition isaProposition TRUE))
    (update-proposition-truth-value isaProposition updateMode)
    (return isaProposition) ))

(defun (assert-isa-proposition PROPOSITION) ((self OBJECT) (type TYPE))
  :public? TRUE
  ;; Assert an ISA proposition to 'self' representing
  ;;    membership in type.
  (if (defined? type)
    (return (update-isa-proposition self type :ASSERT-TRUE))
    (return NULL)) )

(defun (retract-isa-proposition PROPOSITION) ((self OBJECT) (type TYPE))
  :public? TRUE
  ;; Retract an ISA proposition about 'self' representing
  ;;    membership in type.
  (if (defined? type)
    (return (update-isa-proposition self type :RETRACT-TRUE))
    (return NULL)) )

(defun (update-property PROPOSITION)
       ((self LOGIC-OBJECT) (surrogate SURROGATE) (updateMode KEYWORD))
  :public? TRUE
  ;; Assert or retract that the unary relation named 'surrogate' holds for
  ;;    'instance'.
  (let ((propertyProposition
         PROPOSITION 
         (some p in (unfiltered-dependent-propositions self surrogate)
               where (and (eql? (relationRef p) surrogate)
                          (eql? (length (arguments p)) 1)))))
    (when (or (null? surrogate)
              (null? (surrogate-value surrogate)))
      (print "Error: Property " surrogate " is not defined." EOL)
      (return NULL))
    (when (null? propertyProposition)
      (setq propertyProposition (create-proposition (quote PREDICATE) 1))
      (setf (nth (arguments propertyProposition) 0) self)
      (setf (relationRef propertyProposition) surrogate)
      (fasten-down-one-proposition propertyProposition TRUE))
    (update-proposition-truth-value propertyProposition updateMode)
    (return propertyProposition) ))

(defun (assert-property PROPOSITION) ((instance LOGIC-OBJECT) (property SURROGATE))
  :public? TRUE
  ;; Assert that the unary relation named 'property' holds for 'instance'.
  (return (update-property instance property :ASSERT-TRUE)) )

(defun (retract-property PROPOSITION) ((instance LOGIC-OBJECT) (property SURROGATE))
  :public? TRUE
  ;; Retract that the unary relation named 'property' holds for 'instance'.
  (return (update-property instance property :RETRACT-TRUE)) )

;; TO DO: UPGRADE TO CLIP VALUES OF SINGLE-VALUED RELATIONS:
(defun (update-tuple PROPOSITION)
       ((relation SURROGATE) (arguments (CONS OF OBJECT)) (updateMode KEYWORD))
  :public? TRUE
  ;; Assert or retract a proposition that applies 'relation' to
  ;;    'arguments'.
  (let ((description (get-description relation))
        (proposition PROPOSITION NULL))
    (cond
     ((function-description? description)
      (let ((definingProposition
              (find-or-create-function-proposition
               relation (consify (but-last arguments)))))
        (setq proposition
              (update-equivalence-proposition
               (create-equivalence-proposition
                (last-argument definingProposition) (last arguments))
               updateMode))
        (when (null? proposition)
          (return definingProposition))))
     ((class-description? description)
      (return (update-isa-proposition (first arguments) relation updateMode)))
     (otherwise
      (setq proposition
            (create-proposition (quote PREDICATE) (length arguments)))
      (setf (relationRef proposition) relation)
      (foreach arg in arguments
               as i in (interval 0 NULL)
               do (setf (nth (arguments proposition) i) arg))))
    (setq proposition
          (fasten-down-one-proposition proposition FALSE))
    (update-proposition-truth-value proposition updateMode)
    (return proposition) ))

(defun (assert-tuple PROPOSITION)
       ((relation SURROGATE) (arguments (CONS OF OBJECT)))
  :public? TRUE
  ;; Assert a proposition that applies 'relation' to
  ;;    'arguments'.
  (return (update-tuple relation arguments :ASSERT-TRUE)) )

(defun (update-binary-value PROPOSITION) 
       ((relation SURROGATE) (self OBJECT) (value OBJECT) (updateMode KEYWORD))
  :public? TRUE
  ;; Assert or retract the last value for a binary relation or function.
  ;; Function case is particularly optimized to avoid creating temporary
  ;;    data structures (parse trees and propositions).
  ;; For functions and single-valued-relations, always clips old value,
  ;;    regardless of whether or not clipping is enabled.
  (special ((*clippingEnabled?* TRUE))
   (if (function-description? (get-description relation))
     (let ((proposition 
            (some p in (unfiltered-dependent-propositions self relation)
                  where (eql? (relationRef p) relation))))
       (when (or (null? proposition)
                 (skolem? value))
         (return (update-tuple relation (cons-list self value) updateMode)))
       (let ((skolemOutput (last-argument proposition)))
         ;; logic borrowed from 'update-equivalence-proposition':
         (case updateMode
           (:ASSERT-TRUE
            (cond
             ((clip-value? skolemOutput value) NULL)
             (otherwise
              (equate-values (value-of skolemOutput) (value-of value)))))
           (:RETRACT-TRUE
            (unequate-values? skolemOutput value)))
         (return proposition)))
     (return (update-tuple relation (cons-list self value) updateMode))) ))

(defun (assert-binary-value PROPOSITION)
       ((relation SURROGATE) (self OBJECT) (value OBJECT))
  :public? TRUE
  ;; Assert that the value of relation 'relation' applied to 'self' is 'value'.
  ;; Clips old value, if there is one.
  (return (update-binary-value relation self value :ASSERT-TRUE)) )

(defun (retract-binary-value PROPOSITION)
       ((relation SURROGATE) (self OBJECT) (value OBJECT))
  :public? TRUE
  ;; Retract that the value of relation 'relation' applied to 'self' is 'value'.
  (return (update-binary-value relation self value :RETRACT-TRUE)) )

(defun (assert-member-of-proposition PROPOSITION) ((self OBJECT) (collection OBJECT))
  :public? TRUE
  ;; Smart assert that 'self' is a member of 'collection'.  If
  ;;    'collection' is a named description, then use an ISA proposition.
  (when (null? collection)
    (return NULL))
  (typecase collection
    (NAMED-DESCRIPTION
     (when (eql? (surrogate-value-inverse collection) @THING)
       (return NULL))
     (return (assert-isa-proposition self (surrogate-value-inverse collection))))
    (otherwise
     (return (assert-tuple PL-KERNEL/@MEMBER-OF (cons-list self collection))))) )
       
;;; KLUDGE: Way to pass default type to 'create-logic-instance'.
;;;    Enables 'evaluate-term' to create an instance
;;;    of the appropriate type, if its instance is new.
(defspecial *defaultCreationType* SURROGATE NULL)

(defclass OBJECT-ALREADY-EXISTS-EXCEPTION (STELLA-EXCEPTION)
  :public? TRUE
  :public-slots ((existing-object :type OBJECT)))

(defun (help-create-logic-instance OBJECT) ((name SURROGATE) (type SURROGATE))
  :public? TRUE   ; Referenced from PLI module!
  (enforce-code-only)
  (when (null? type)
    (setq type *defaultCreationType*))
  (let ((description (only-if (defined? type)
                              (get-description type)))
        (nativeClass CLASS NULL)
        (newObject OBJECT NULL))
    (when (and (defined? type)
               (null? description))
      (signal UNDEFINED-CLASS-EXCEPTION
              "Can't create an instance of the undefined class " (symbol-name type)))
    (if (null? description)
      (setq newObject (new LOGIC-OBJECT))
      (progn
        (when (not (class-description? description))
          (signal OBJECT-NOT-CLASS-EXCEPTION
                  "Can't create an instance of a relation: " (symbol-name type)))
        (setq nativeClass (native-relation description))
        (cond
         ((or (null? nativeClass)
              (abstract? nativeClass))
          (setq newObject (new LOGIC-OBJECT)))
         ((subtype-of? (class-type nativeClass) @THING)
          (setq newObject (create-object type)))
         (otherwise
          (signal BAD-ARGUMENT-EXCEPTION
                  "Can't create an instance of the class " (symbol-name type) EOL
                  "   because it doesn't inherit the class 'THING'.")))))
    ;;; SUPERCEDED BY AUTOMATIC-FIX-TYPE-VIOLATIONS POLICY:  -rmm
    ;    ;; if 'type' is defined', attach ISA proposition to 'newObject':
    ;    (assert-isa-proposition newObject type)
    (when (defined? name)
      (when (defined? (surrogate-value name))
        (let ((error  (new OBJECT-ALREADY-EXISTS-EXCEPTION
                           :message (concatenate "An object named " (symbol-name name) " already exists.")
                           :existing-object (surrogate-value name))))
          (signal-exception error)))
      ;; point surrogate at 'newObject':
      (setf (surrogate-value name) newObject)
      ;; install backpointer to surrogate:
      (typecase newObject
        ((LOGIC-OBJECT THING)
         (setf (surrogate-value-inverse newObject) name))))
    ;; commented until we invent a better timestamp to memoize `get-instance'
    ;;    (:KB-UPDATE and :META-KB-UPDATE should only be bumped when absolutely
    ;;    necessary, since many memoized computations depend on them):
    ;(bump-memoization-timestamp :KB-UPDATE)
    (return newObject) ))

(defun (create-logic-instance OBJECT) ((name SURROGATE) (type SURROGATE))
  :public? TRUE
  ;; Create a new logic instance of type 'type'.  If 'type' specializes
  ;;    THING, instantiate a STELLA class.  Otherwise, create a LOGIC
  ;;    OBJECT.
  ;; Add it to the description extension for the root class or root classes
  ;;    of the class of 'type'.
  ;; If 'type' is not a root type, attach an ISA proposition to it asserting
  ;;    membership in the class 'type'.
  ;; If the surrogate 'name' is defined, doubly-link it to the new object.
  (exception-case (return (help-create-logic-instance name type))
    (UNDEFINED-CLASS-EXCEPTION (undefined)
       (inform (exception-message undefined))
       (return NULL))
    (OBJECT-NOT-CLASS-EXCEPTION (no-class)
       (inform (exception-message no-class))
       (return NULL))
    (BAD-ARGUMENT-EXCEPTION (bad-arg)
       (inform (exception-message bad-arg))
       (return NULL))
    (OBJECT-ALREADY-EXISTS-EXCEPTION (exists)
       (print (exception-message exists) EOL
              "Redefining the surrogate " (symbol-name name) 
               " will cause the existing" EOL
               "   object named " (symbol-name name) " to be destroyed. ")
       (if (y-or-n? "Do it? ")
         (progn 
           (destroy-instance (existing-object exists))
           (return (help-create-logic-instance name type)))
         (progn
           (print "Returning existing object:" EOL)
           (return (existing-object exists)))))))
  

  ;;
;;;;;; Constructing propositions from source trees
  ;;

;;; To detect duplicates of complex propositions (which might differ in
;;; argument order, variable names, etc.) we now store propositions and
;;; descriptions in a structured object index that indexes them based
;;; on a structure hash code.  In fact, we now store all propositions
;;; (not just complex ones) in this table, since it improves lookup times
;;; for cases where we have large numbers of backlinks and
;;; `find-similar-proposition' can take a long time.

;;; Issues/TO DO:
;;; - The structured object index could be stored on a per-module basis
;;;   and completely replace `locally-conceived-propositions' and `-terms'.
;;;   We would have to run up the hierarchy in some cases (e.g., if no
;;;   local relations or constants are referenced), but we would get better
;;;   module-local behavior with clearing, etc.  This would also mirror
;;;   better what we do for persistent storage and could aid lookup there as well.
;;; - eliminate use of `find-similar-proposition' in inherit-description and friends
;;;   once we are convinced that it doesn't buy us much anymore
;;; - with function propositions, we now don't evaluate terms when hashing to
;;;   find duplicates, which has some implications for equality reasoning.
;;; - when we load without checking duplicates, nothing is added to the index
;;;   which will fail to detect duplicates for the loaded propositions after
;;;   the load is over.  Maybe we still want to add propositions but not check
;;;   whether they are equivalent to any others in a bucket.

(defglobal *structured-objects-index*
    (KEY-VALUE-MAP OF INTEGER-WRAPPER (LIST OF CONTEXT-SENSITIVE-OBJECT))
  (new KEY-VALUE-MAP)
  :documentation "Contains a table of propositions and descriptions, indexed by a
structure hash code which might be shared by different objects.")

(defun cleanup-structured-objects-index ((clearModule MODULE))
  ;; Remove all deleted objects from the structured objects index
  ;;    and cleanup empty buckets.
  ;; If `clearModule' is non-NULL also delete all propositions with that
  ;;    home-context (necessary to clear rules that were forward-inferred
  ;;    and therefore didn't get logged on the module).
  (foreach (key bucket) in *structured-objects-index*
      do (foreach obj in bucket
             do (let ((context (home-context obj)))
                  (when (and (defined? context)
                             (or (deleted? context)
                                 (subcontext? context clearModule)))
                    (destroy-object obj))))
         (remove-deleted-members bucket)
         (when (empty? bucket)
           (remove-at *structured-objects-index* key))))

#|
(defun print-structured-objects-index-stats ()
  ;; Useful for performance debugging, e.g., if we get large buckets.
  (let ((nofBuckets 0)
        (avgLength 0.0)
        (maxLength 0)
        (maxLengthKey 0))
    (foreach (key bucket) in *structured-objects-index*
        do (++ nofBuckets)
           (++ avgLength (length bucket))
           (when (> (length bucket) maxLength)
             (setq maxLength (length bucket))
             (setq maxLengthKey key)))
    (print "Number of buckets: " nofBuckets EOL
           "Avg bucket size:   " (/ avgLength nofBuckets) EOL
           "Max bucket size:   " maxLength EOL
           "Max bucket ID:     " maxLengthKey EOL)))
|#

;;; Hashing issues:
;;; - (OR (R A) (S B)) and (OR (R B) (S A)) return the same code
;;;   due to the commutativity of XOR (despite some rotation)
;;; - similar for (OR (R A B) (S C D)) (OR (R C D) (S A B))
;;; - we currently map all variables onto the same code which
;;;   causes some issues for cases where we get lots and lots of
;;;   similar looking normalizations; distinguishing between
;;;   EXISTS and FORALL and free variables via an extra index
;;;   improves the situation but still doesn't buy us all that
;;;   much due to the above issues; think about better structure
;;;   hashing without preventing detection of different looking
;;;   duplicates (e.g., if order of quantified variables differs).

(defun (proposition-hash-index INTEGER) ((self PROPOSITION))
  ;; Compute a hash code that can be used to index `self' for
  ;;    the purpose of duplicate detection.
  ;; This purposely ignores variable names and positions and skolems
  ;;    and does the right thing for commutative propositions.  It
  ;;    is assumed that true equivalence is checked via
  ;;    `equivalent-propositions?'.
  ;; TO DO: THINK ABOUT USING A SIMILAR SCHEME FOR PERSISTENT STORES.
  (let ((code (object-hash-code (operator self)))
        (argCode 0)
        (commutative? FALSE))
    (case (kind self)
      ((:AND :OR :EQUIVALENT)
       (setq commutative? TRUE))
      (otherwise NULL))
    (setq code (rotate-hash-code code))
    (foreach arg in (arguments self)
        do (when (and (defined? *queryIterator*)
                      (variable? arg))
             ;; we have a variable that might be bound in a query;
             ;; use its value instead if it has one (for descriptions):
             (setq arg (first-defined (safe-bound-to arg) arg)))
           ;; don't evaluate the arg, since it might change the hash value
           ;; of propositions with function term arguments depending on which
           ;; equalities are currently asserted in the KB:
           ;(setq arg (value-of arg))
           (if (null? arg)
               ;; we have a partially built function proposition,
               ;; emulate function output skolem:
               (setq argCode (object-hash-code @SKOLEM))
             (typecase arg
               (PROPOSITION
                (setq argCode (proposition-hash-index arg)))
               (NAMED-DESCRIPTION
                (setq argCode (object-hash-code arg)))
               (DESCRIPTION
                ;; we ignore the fact that this is a description, but it's
                ;; unlikely that we would often clash because of that:
                (setq argCode (proposition-hash-index (proposition arg))))
               (PATTERN-VARIABLE
                (setq argCode (object-hash-code @PATTERN-VARIABLE)))
               (SKOLEM
                (let ((definingProp (defining-proposition arg)))
                  (if (and (defined? definingProp)
                           (not (eql? definingProp self)))
                      ;; we have a function term as an argument, hash it:
                      (setq argCode (proposition-hash-index definingProp))
                    (setq argCode (object-hash-code @SKOLEM)))))
               (WRAPPER
                (setq argCode (hash-code arg)))
               (otherwise
                (setq argCode (object-hash-code arg)))))
           (setq code (logxor code argCode))
           (unless commutative?
             ;; rotate right to take argument order into account:
             (setq code (rotate-hash-code code))))
    (return code)))

(defun (find-duplicate-complex-proposition PROPOSITION) ((self PROPOSITION))
  ;; Return a duplicate (or equivalent) of 'self' if there is one.
  ;; If not, add 'self' to `*structured-objects-index*'.
  ;; Also finds duplicate function propositions that are identical to
  ;;    `self' except for the last argument.
  (let ((index (wrap-integer (proposition-hash-index self)))
        (bucket (lookup *structured-objects-index* index))
        (homeModule (base-module (home-context self)))
        (function? (eql? (kind self) :FUNCTION)))
    (when (null? bucket)
      (insert-at *structured-objects-index* index (list self))
      (return NULL))
    (remove-deleted-members bucket)
    (foreach p in bucket
        do (typecase p
             (PROPOSITION
              (if function?
                  (let ((operator (operator self))
                        (arguments (arguments self))
                        (arity (length arguments)))
                    ;; special-purpose equality test that ignores the last argument:
                    (when (and (eql? operator (operator p))
                               (forall arg1 in arguments
                                   as arg2 in (arguments p)
                                   as i in (interval 2 arity) ;; only compare n-1 args
                                   always (eql? (value-of arg1) (value-of arg2)))
                               (eql? arity (length (arguments p)))
                               (subcontext? homeModule (base-module (home-context p))))
                      (return p)))
                (when (and (equivalent-propositions? self p NULL)
                           (subcontext? homeModule (base-module (home-context p))))
                  (return p))))
             (otherwise NULL)))
    (push bucket self)
    (return NULL) ))

(defun (find-duplicate-proposition PROPOSITION) ((self PROPOSITION))
  ;; If a duplicate of the proposition 'self' already exists, return it.
  ;; Also finds duplicate function propositions that are identical to
  ;;    `self' except for the last argument.
  (when (or (description-mode?)
            (descriptive? self))
    ;; to properly lookup descriptive propositions, we'd need to have
    ;; their free/io-variables and create mappings for each potential
    ;; duplicate before calling `equivalent-propositions?' (this can
    ;; cause problems in `copy-description' for optimized query patterns):
    (return NULL))
  (case (kind self)
    (:DISABLED ;(:PREDICATE :ISA) ;; use index for all propositions for now
     (return
       (some p in (find-similar-propositions self)
           where (and (equivalent-propositions? self p NULL)
                      ;; now propositions are always conceived in modules, but
                      ;; we keep this dereferencing here for safety:
                      (subcontext? (base-module (home-context self))
                                   (base-module (home-context p)))))))
    ;; NOTE: if the above gets enabled again, :FUNCTIONs need to be handled here:
    (otherwise
     (return (find-duplicate-complex-proposition self)))))

(defspecial *dont-check-for-duplicate-propositions?* BOOLEAN FALSE
  :documentation "If TRUE never check for the existence of duplicate
propositions when building a new proposition.")

(defun (fasten-down-one-proposition PROPOSITION) 
       ((self PROPOSITION) (dontCheckForDuplicates? BOOLEAN))
  ;; Link 'self' into the network of conceived propositions in the 
  ;;    current module, and return it.
  ;; If a duplicate of 'self' exists, discard 'self' and return the
  ;;     duplicate.
  ;; Called by 'CONS.build-proposition' and  'inherit-proposition'.
  (when (native-slot-proposition? self)
    (return self))
  ;; try to convert relation arguments to surrogates:
  ;; Tricky: do this BEFORE finding duplicates, because the 
  ;;    'find-duplicate-proposition' may use a discouraged argument
  ;;    to search for backlinks (when it shouldn't):
  (unless *loadingRegenerableObjects?*
    (surrogatify-discouraged-arguments self))
  (let ((duplicate PROPOSITION NULL))
    (unless (or dontCheckForDuplicates?
                *dont-check-for-duplicate-propositions?*
                *loadingRegenerableObjects?*)
      (setq duplicate (find-duplicate-proposition self)))
    (if (defined? duplicate)
        (progn
          ;; BUG: THIS ONLY PICKS UP CHANGES IN TOP-LEVEL ANNOTATIONS:
          (when (not (equal? (annotations duplicate) (annotations self)))
            (clear-proposition-annotations duplicate)
            (setf (annotations duplicate) (annotations self))
            (finalize-proposition-annotations duplicate)
            ;; re-evaluate, since the annotations changed:
            (evaluate-new-proposition duplicate))
          (return duplicate))
      (progn                          ; finish creating proposition:
        ;; log newly created proposition:
        (when (not (or (descriptive? self)
                       (description-mode?)))
          ;; NOTE: We log every proposition that might at some point
          ;;    become a legal top-level assertion right at construction
          ;;    time to not have to detect duplicates.  This excludes
          ;;    all propositions inside descriptions and arguments
          ;;    to quantified propositions that contain variables.
          ;; TRICKY: Even if a quantified proposition contains a ground
          ;;    proposition, the absence of backlinks from the assertion
          ;;    base to it will ensure the subsequent logging of the ground
          ;;    proposition should it ever become conceived independently,
	  ;;    since its quantified duplicate won't be found.
          (when (not *loadingRegenerableObjects?*)
            (log-newly-conceived-proposition *module* self)))
        (when (not *loadingRegenerableObjects?*)
          ;; wrap any literal arguments that need backlinks to propositions:
          (rewrap-proposition-arguments self))
        ;; insert back links from arguments:
        (when (not *loadingRegenerableObjects?*)
          (foreach arg in (arguments self)
              do (add-dependent-proposition-link arg self)))
        (update-description-extension self)
        ;; mark as fastened and remove storage for 'unfastened?' slot:
        (setf (unfastened? self) NULL)
        (finalize-proposition-annotations self)
        (evaluate-new-proposition self)
        (return self))) ))

(defspecial *visitedUnfastenedDefiningPropositions* LIST NULL
  :documentation "Used by 'recursively-fasten-down-propositions'.")

(defun (help-fasten-down-propositions PROPOSITION)
       ((self PROPOSITION) (dontCheckForDuplicates? BOOLEAN))
  ;; Fasten down 'self' and its arguments, recursively.
  ;; Return 'self' or its duplicate.
  (let ((dontCheckArgsForDuplicates? dontCheckForDuplicates?))
    (case (kind self)
      ((:FORALL :EXISTS)
       (setq dontCheckArgsForDuplicates? TRUE))
      (otherwise
       (when (descriptive? self)
         ;; can be problematic if we fasten down something like
         ;; (AND (R1 ?x) (R2 ?x)) and pick up non-matching argument
         ;; duplicates that build (AND (R1 ?x1) (R2 ?x2)); for this
         ;; reason, duplicate checking on descriptive propositions is
         ;; currently generally disabled.
         (setq dontCheckArgsForDuplicates? TRUE))))
    (foreach arg in (arguments self)
      as i in (interval 0 NULL)
      do (typecase arg
           (PROPOSITION
            (when (unfastened? arg)
              (setf (nth (arguments self) i)
                (help-fasten-down-propositions
                 arg dontCheckArgsForDuplicates?))))
           (SKOLEM
            (let ((definingProp (defining-proposition arg)))
              (when (and (defined? definingProp)
                         (unfastened? definingProp)
                         (not (member?
                               *visitedUnfastenedDefiningPropositions*
                               definingProp)))
                (insert *visitedUnfastenedDefiningPropositions* definingProp)
                (help-fasten-down-propositions
                 definingProp dontCheckArgsForDuplicates?))))
           (otherwise NULL)))
    (return (fasten-down-one-proposition self dontCheckForDuplicates?)) ))

(defun (recursively-fasten-down-propositions PROPOSITION)
       ((self PROPOSITION) (dontCheckForDuplicates? BOOLEAN))
  ;; Fasten down 'self' and its arguments, recursively, i.e., replace
  ;;    propositions by already-fastened duplicates, and install
  ;;    backlinks.
  ;; If we are in description mode, do additional type inference if
  ;;    unresolved slot references exist.
  ;; Return 'self' or its duplicate.
  (when (not (unfastened? self))
    (return self))
  (special ((*visitedUnfastenedDefiningPropositions* (list)))
    (return (help-fasten-down-propositions self dontCheckForDuplicates?)) ))

(defun unfasten-proposition ((proposition PROPOSITION))
  ;; Unfasten 'proposition' from its arguments, and mark it unfastened.
  (foreach arg in (arguments proposition)
               do (remove-dependent-proposition-link arg proposition))
  (setf (unfastened? proposition) TRUE) )


  ;;
;;;;;; Constructing propositions from source trees
  ;;

(defun instantiate-undefined-surrogates ((self PROPOSITION))
  ;; Helping function for 'build-top-level-proposition'.
  ;; Kludge to avoid undefined symbols within asserted exists.
  (case (kind self)
    ((:AND :OR :NOT :EXISTS)
     (foreach arg in (arguments self)
              do (instantiate-undefined-surrogates arg)))
    ((:PREDICATE :FUNCTION :ISA)
     (foreach arg in (arguments self)
              do
              (typecase arg
                (SURROGATE
                 (when (null? (surrogate-value arg))
                   (create-logic-instance arg NULL)))
                (otherwise NULL))))
    (otherwise NULL)) )

(defun (build-top-level-proposition PROPOSITION)
       ((tree OBJECT) (trueAssertion? BOOLEAN))
  ;; Create a proposition representing 'tree' and then assign it a
  ;;    truth value.
  (when (isa? tree @STRING-WRAPPER)
    ;; Convert 'string' into a parse tree, and then convert that into
    ;;    a proposition:
    (return (build-top-level-proposition (unstringify tree) trueAssertion?)))
  (let ((proposition PROPOSITION NULL)
        (logicVariableTable *logicVariableTable*))
    (special ((*logicVariableTable*
               (choose (defined? logicVariableTable)
                       logicVariableTable
                       NIL))
              (*variableIdCounter* *variableIdCounter*)
              (*termUnderConstruction* tree))
     (setq proposition (build-proposition tree))
     (when (defined? proposition)
       (normalize-top-level-proposition proposition NULL)
       (verify-forall-propositions proposition)
       (when (not (empty? (collect-unresolved-slot-references proposition)))
         ;; a bit of a kludge: figure out types of constants BEFORE they
         ;;    are asserted to help resolve unresolved references:
         (when trueAssertion?
           (update-skolem-type-from-isa-assertions proposition))
         ;; an error is signaled if not all references can be resolved:
         (resolve-unresolved-slot-references proposition))
       ;; kludge: eliminate undefined references
       (when (and trueAssertion?
                  (eql? (kind proposition) :EXISTS)
                  (not (description-mode?)))
         (instantiate-undefined-surrogates proposition))
       (setq proposition 
             (recursively-fasten-down-propositions proposition FALSE))))
    (return proposition) ))

(defun (build-proposition OBJECT) ((tree OBJECT))
  ;;  Create a proposition (or sentential variable) representing 'tree'.
  (typecase tree
    (CONS (return (CONS.build-proposition tree)))
    (SURROGATE (return (SURROGATE.build-proposition tree)))
    (SYMBOL (return (SYMBOL.build-proposition tree)))
    (otherwise
     (signal-proposition-error "Illegal logical sentence: " tree))))
 
(defun (SURROGATE.build-proposition PROPOSITION) ((self SURROGATE))
  ;; Find or create a constant proposition named 'self'.
  (let ((value (surrogate-value self))
        (proposition PROPOSITION NULL))
    (if (defined? value)
      (typecase value
        (PROPOSITION (setq proposition value))
        (otherwise
         (signal-proposition-error
          "Expected " (symbol-name self) " to have type proposition")))
      (progn
        ;; create a constant proposition for 'self':
        (setq proposition (create-proposition (quote CONSTANT) 0))
        (setf (relationRef proposition) self)
        (setf (surrogate-value self) proposition)
        (setf (surrogate-value-inverse proposition) self)))
    (return proposition) ))

(defun (SYMBOL.build-proposition OBJECT) ((symbol SYMBOL))
  ;; Return the proposition (TRUE/FALSE) or sentential variable
  ;;    represented by 'symbol'.
  (let ((proposition PROPOSITION NULL))
    (case symbol
      (TRUE (setq proposition TRUE-PROPOSITION))
      (FALSE (setq proposition FALSE-PROPOSITION))
      (otherwise
       ;; symbols denoting propositions turn into surrogates.
       ;;    'symbol' must be a variable:
       (return (evaluate-SYMBOL-term symbol))))
    (return proposition) ))

(defun (CONS.build-proposition PROPOSITION) ((tree CONS))
  ;; Create a proposition representing 'tree'.  'updateMode' is either
  ;;   an update operation or NULL, indicating the construction of a 
  ;;   soon-to-be-nested proposition.
  (let ((proposition PROPOSITION NULL))
    (safety 1 (isa? (first tree) @SYMBOL)
            "INTERNAL ERROR: Illegal operator in proposition tree.")
    (case (first tree)
      (= (setq proposition (build-equivalence-proposition tree)))
      ((AND OR NOT)
       (setq proposition (build-and-or-not-proposition tree)))
      (ISA (setq proposition (build-isa-proposition tree)))
      (PL-KERNEL/MEMBER-OF (setq proposition (build-member-of-proposition tree)))
      ((IMPLIES PL-KERNEL/SUBSET-OF)
       (setq proposition (build-implies-proposition tree)))
      (EXISTS (setq proposition (build-exists-proposition tree)))
      (FORALL (setq proposition (build-forall-proposition tree)))
      (FAIL (setq proposition (build-fail-proposition tree)))
      (COLLECT-INTO (setq proposition (build-collect-into-proposition tree)))
      (ABOUT (setq proposition (build-annotated-proposition tree)))
      (otherwise (setq proposition (build-predicate-proposition tree))))
    (when (null? proposition)
      (return NULL))
    ;; normalization will flatten later if we don't do it now, but
    ;;    its much cheaper to do it here:
    (when (contains-nested-argument? proposition)
      (setq proposition (flatten-nested-function-arguments proposition)))
    (return proposition) ))

(defun verify-number-of-proposition-arguments ((tree CONS) (correctNumber INTEGER))
  ;; Signal an error if 'tree', representing a proposition, has the wrong number
  ;;    of arguments.
  ;; Note: This is useful for propositions that assume a fixed number
  ;;    while building their arguments vector.
  ;; 'verify-argument-types-and-count' is needed where the argument
  ;;    count isn't known in advance.
  (when (not (eql? (length (rest tree)) correctNumber))
    (signal-proposition-error
     "Wrong number of arguments in proposition: " tree EOL
     "   Expected " correctNumber " arguments.")) )

(defmethod (description-surrogate TYPE) ((self DESCRIPTION))
  ;; Return the surrogate for the description 'self'.
  (let ((nativeRelation (native-relation self)))
    (when (defined? nativeRelation)
      (typecase nativeRelation
        (CLASS (return (class-logical-type nativeRelation)))
        (SLOT (return (slot-slotref nativeRelation)))
        (otherwise NULL)))
    (return NULL)) )

(defun (build-isa-proposition PROPOSITION) ((tree CONS))
  ;; Return an ISA proposition.
  (verify-number-of-proposition-arguments tree 2)
  (let ((proposition (create-proposition (quote ISA) 1))
        (type SURROGATE NULL)
        (symbol (third tree)))
    (typecase symbol
      (SURROGATE (setq type symbol))
      (SYMBOL (setq type (symbol-to-surrogate symbol)))
      (otherwise
       (signal-proposition-error
        "Illegal token where symbol expected: " symbol)))
    ;; check validity of class reference:
    (let ((class (get-description type)))
      (when (null? class)
        (signal-proposition-error 
         "No class is associated with the term " (symbol-name type)))
      (when (not (class-description? class))
        (signal-proposition-error
         "Term " (symbol-name type) " found where class expected.")))
    (setf (operator proposition) type)
    (setf (nth (arguments proposition) 0)
          (evaluate-typed-argument (second tree) type))
    (return proposition) ))

(defun (build-member-of-proposition PROPOSITION) ((tree CONS))
  ;; Return a PREDICATE or ISA proposition.
  ;; 'tree' represents a MEMBER-OF proposition.  If its second argument is the
  ;;    name of a class, convert to an ISA proposition.
  (verify-number-of-proposition-arguments tree 2)
  (let ((collectionRef (third tree)))
    ;; possibly convert to ISA proposition:
    (typecase collectionRef
      ((TYPE SYMBOL)
       (when (defined? (get-stella-class collectionRef FALSE))
         ;; mildly tricky: 'build-isa-proposition' doesn't notice that the
         ;;    predicate is MEMBER-OF instead of ISA:
         (return (build-isa-proposition tree))))
      (DESCRIPTION
       (when (and (named-description? collectionRef)
                  (class-description? (cast collectionRef NAMED-DESCRIPTION)))
         (return (build-isa-proposition 
                  (bquote (ISA & (second tree)
                               & (description-surrogate collectionRef)))))))
      (otherwise NULL)))
  (return (build-predicate-proposition tree)) )

(defun (member-of-proposition? BOOLEAN) ((proposition PROPOSITION))
  ;; Return TRUE if 'proposition' is a 'member' proposition.
  :globally-inline? TRUE
  (return (eql? (operator proposition) PL-KERNEL/@MEMBER-OF)) )

(defun (subset-of-proposition? BOOLEAN) ((proposition PROPOSITION))
  ;; Return TRUE if 'proposition' is a 'subset-of' proposition.
  :globally-inline? TRUE
  (return (eql? (operator proposition) PL-KERNEL/@SUBSET-OF)) )

(defun (simple-subrelation-proposition? BOOLEAN) ((proposition PROPOSITION))
  ;; Return TRUE if `proposition' is a "subset-of" proposition that
  ;; relates two named descriptions.
  :public? TRUE
  (return (and (subset-of-proposition? proposition)
	       (isa? (nth (arguments proposition) 0) @NAMED-DESCRIPTION)
	       (isa? (nth (arguments proposition) 1) @NAMED-DESCRIPTION))))


  ;;
;;;;;; Annotations
  ;;

(defun (extract-annotation OBJECT OBJECT) ((tree OBJECT) (option KEYWORD))
  ;; If 'tree' is annotated at top level and has an option matching
  ;;    'option', destructively remove that option and its value.
  ;; Return the mutilated tree and the value.
  (let ((value OBJECT NULL))
    (typecase tree
      (CONS
       (when (eql? (first tree) (quote ABOUT))
         (let ((options (new PROPERTY-LIST :the-plist (rest (rest tree)))))
           (setq value (lookup options option))
           (when (defined? value)
             (remove-at options option)
             (setf (rest (rest tree)) (the-plist options))))))
      (otherwise NULL))
    (return tree value)))

(defun (lookup-annotation OBJECT) ((proposition PROPOSITION) (key KEYWORD))
  ;; Lookup the value of `key' in `proposition's annotations.
  (let ((annotations (annotations proposition)))
    (if (defined? annotations)
        (return (lookup annotations key))
      (return NULL))))

(defun insert-annotation ((proposition PROPOSITION)
                          (key KEYWORD)
                          (value OBJECT))
  ;; Insert a `value' for `key' in `proposition's annotations.
  ;; Create annotations object if this is the first entry.
  (let ((annotations (annotations proposition)))
    (when (null? annotations)
      (setq annotations (new PROPERTY-LIST))
      (setf (annotations proposition) annotations))
    (insert-at annotations key value)))

(defun remove-annotation ((proposition PROPOSITION) (key KEYWORD))
  ;; Remove the value for `key' in `proposition's annotations.
  ;; Free up annotations object if this was the last entry.
  (let ((annotations (annotations proposition)))
    (when (null? annotations)
      (return))
    (remove-at annotations key)
    (when (empty? (the-plist annotations))
      ;; free up the dynamic slot space:
      (setf (annotations proposition) NULL))))

(defun (build-annotated-proposition PROPOSITION) ((tree CONS))
  ;; Add annotation(s) to a proposition which have the following form:
  ;;    (about <proposition> {<key> <value>}*)
  ;; Each key has to be a symbol or keyword.  Currently supported are
  ;;    :DIRECTION, :WEIGHT and any slot option keywords for slots on
  ;;    propositions
  ;; FIGURE OUT: SHOULD ANNOTATIONS BE CONTEXT SENSITIVE?
  (let ((proposition PROPOSITION (build-proposition (second tree)))
	(options (rest (rest tree))))
    ;; canonicalize option keywords and check for key/value balance:
    (while (non-empty? options)
      (if (isa? (first options) @GENERALIZED-SYMBOL)
          (setf (first options)
            (keywordify (cast (first options) @GENERALIZED-SYMBOL)))
        (signal-parsing-error "Illegal annotation option: " (first options)))
      (unless (defined? (second options))
        (signal-parsing-error
         "Missing annotation value for option: " (first options)))
      (setq options (rest (rest options))))
    (setf (annotations proposition)
      (new PROPERTY-LIST :the-plist (rest (rest tree))))
    (finalize-proposition-annotations proposition)
    (return proposition)))

(defun finalize-proposition-annotations ((proposition PROPOSITION))
  ;; Finalize the annotations associated with `proposition'.
  ;; This needs to be called whenever we copy a proposition or
  ;;    replace it with a preexisting duplicate.
  (let ((annotations (annotations proposition)))
    (when (defined? annotations)
      (foreach (option value) in annotations
          do (case option
               (:DIRECTION
                (typecase value
                  (GENERALIZED-SYMBOL
                   (case (string-upcase (symbol-name value))
                     ("FORWARD" (setf (forward-only? proposition) TRUE))
                     ("BACKWARD" (setf (backward-only? proposition) TRUE))
                     (otherwise
                      (remove-at annotations option)
                      (signal-parsing-error
                       "Illegal value for :direction option: " value))))
                  (otherwise
                   (remove-at annotations option)
                   (signal-parsing-error
                    "Illegal value for :direction option: " value))))
               (:WEIGHT
                (typecase value
                  ((INTEGER FLOAT)
                   ;; not yet:
                   ;;(assign-proposition-weight proposition value)
                   (setf (weight proposition) value))
                  (otherwise
                   (remove-at annotations option)
                   (signal-parsing-error
                    "Illegal value for :weight option: " value))))
               (:CONFIDENCE-LEVEL NULL) ;; handled elsewhere
               (otherwise
                (unless (run-option-handler? proposition option value)
                  (remove-at annotations option)
                  (signal-parsing-error
                   "Unrecognized annotation option: " option))))))))

(defun clear-proposition-annotations ((proposition PROPOSITION))
  ;; Clear all values generated by the annotations of `proposition'.
  (let ((annotations (annotations proposition)))
    (when (defined? annotations)
      (foreach (option value) in annotations
          do (ignore value)
	     (case option
               (:DIRECTION
                (setf (forward-only? proposition) FALSE)
                (setf (backward-only? proposition) FALSE))
               (:WEIGHT
                (setf (weight proposition) NULL))
               (otherwise
                (run-option-handler? proposition option NULL)))))))

#|

(defrelation RR (?x ?y)
   :axioms (about (<= (RR ?x ?y) (RR ?y ?x))
                  :direction :backward))
(defrelation SS (?x ?y)
  :axioms (<<= (SS ?x ?y) (RR ?x ?y))
  :axioms (=>> (SS ?x ?y) (and (A ?x) (B ?y))))

(assert (about
         (=> (r ?x ?y)
             (and (a ?x) (b ?y)))
         :direction :forward
         :creator "Baby Spice"
         :creation-date "April 9"))

(assert (about
         (=> (r ?x ?y)
             (and (a ?x) (b ?y)))
         :direction :forward
         :creator "Baby Spice"
         :creation-date "April 9"))

|#

(defun (function-induced-exists? BOOLEAN)
    ((proposition PROPOSITION))
  ;; Return true if `proposition' is an exists proposition that was
  ;;    generated by flattening nested function terms.
  ;; NOTE: This function can only determine whether something might
  ;;    be an exists generated by flattening.  It cannot actually
  ;;    determine whether the proposition was asserted like that directly.
  ;; THIS IS A KLUDGE.  IT SHOULD GO AWAY ONCE WE'VE DECIDED ON THE CORRECT
  ;;    WAY TO REPRESENT NON-TOTAL FUNCTIONS.
  (when (eql? (kind proposition) :EXISTS)
    (let ((firstArgument (first (arguments proposition))))
      (when (and (isa? firstArgument @PROPOSITION)
                 (eql? (kind (safe-cast firstArgument PROPOSITION)) :AND))
        (let ((existsVariables (io-variables proposition))
              (andProp PROPOSITION firstArgument)
              (andArguments (VECTOR OF PROPOSITION) (arguments andProp))
              (nonFunctionsCount 0))
          (when (forall variable in existsVariables
                    always (exists arg in andArguments
                               where (and (eql? (kind arg) :FUNCTION)
                                          (eql? (last (arguments arg))
                                                variable))))
            (foreach arg in andArguments
                where (and (not (eql? (kind arg) :FUNCTION))
                           (not (variable-type? arg)))
                do (++ nonFunctionsCount))
            (return (= nonFunctionsCount 1)))))))
  (return FALSE))

(defun (predicate-of-function-induced-exists PROPOSITION)
    ((existsProposition PROPOSITION))
  ;; Return the primary predicate proposition of the function-induced
  ;;    `existsProposition'.
  ;; THIS IS A KLUDGE.  IT SHOULD GO AWAY ONCE WE'VE DECIDED ON THE CORRECT
  ;;    WAY TO REPRESENT NON-TOTAL FUNCTIONS.
  (return
    (some arg in (cast (arguments (cast (first (arguments existsProposition))
                                        PROPOSITION))
                       (VECTOR OF PROPOSITION))
        where (and (not (eql? (kind arg) :FUNCTION))
                   (not (variable-type? arg))))))

(defun (embed-negation-within-function-induced-exists PROPOSITION)
       ((existsProposition PROPOSITION))
  ;; Helping function for 'build-and-or-not-proposition'.
  ;; Situation: 'existsProposition' is the result of flattening a functional
  ;;   argument to a predicate that itself is an argument of a NOT proposition.
  ;; Mildly tricky: We 'know' that flattening occurred, because normalization
  ;;   of parse trees eliminates an EXISTS proposition when it appears as
  ;;   an argument of a NOT proposition.
  ;; Find the nested predicate and negate it (destructively).
  ;; Return 'existsProposition'.
  ;; THIS IS A KLUDGE.  IT SHOULD GO AWAY ONCE WE'VE DECIDED ON THE CORRECT
  ;;    WAY TO REPRESENT NON-TOTAL FUNCTIONS.
  (safety 3 (function-induced-exists? existsProposition)
          "INTERNAL ERROR: `embed-negation-within-function-induced-exists'"
          " called with wrong kind of proposition.")
  (invert-proposition (predicate-of-function-induced-exists existsProposition))
  (return existsProposition))

(defun (build-and-or-not-proposition PROPOSITION) ((tree CONS))
  ;; Construct a proposition for each argument in 'tree'.
  (let ((term OBJECT NULL)
        (arguments NIL)
        (proposition PROPOSITION NULL)
        (argumentsVector VECTOR NULL))
    (case (first tree)
      ((AND OR NOT)
       (foreach arg in (rest tree)
           where (setq? term (build-proposition arg))
           collect term into arguments)))
    (when (and (empty? arguments)
               (eql? (first tree) (quote NOT)))
      (signal-proposition-error "Missing argument in NOT proposition: " tree))
    (when (and (eql? (first tree) (quote NOT))
               (isa? (first arguments) @PROPOSITION)
               (function-induced-exists? (first arguments)))
      (return (embed-negation-within-function-induced-exists (first arguments))))
    ;; slightly tricky: we evaluate arguments BEFORE creating proposition
    ;;    because we can't tell in advance how many there will be:
    (setq proposition (create-proposition (first tree) (length arguments)))
    (setq argumentsVector (arguments proposition))
    (foreach arg in arguments
             as i in (interval 0 NULL)
             do (setf (nth argumentsVector i) arg))
    (return proposition) ))

(defun (functional-term? BOOLEAN) ((term OBJECT))
  ;; Return TRUE if 'term' is a functional term of the form
  ;;   '(<slotName> <arg1> ... <argN>)' where <slotName> is not
  ;;   one of SETOFALL, THE-ONLY, SETOF, LISTOF, or KAPPA.
  (typecase term
    (CONS
     (case (first term)
       ((SETOFALL THE-ONLY SETOF LISTOF KAPPA) (return FALSE))
       (otherwise (return TRUE))))
    (otherwise (return FALSE))))

(defun (clip-value? BOOLEAN) ((term1 OBJECT) (term2 OBJECT))
  ;; Helping function for 'update-equivalence-proposition'.
  ;; Situation: At least one of 'term1' and 'term2' is not a skolem.
  ;; If 'term1' is a skolem bound (recursively) to 'value1' and if
  ;;    'value1' clashes with '(value-of term2)', and if 'term1' denotes
  ;;    the output of a function proposition, then execute a clip by
  ;;    assigning 'term2' to be the new value of the function proposition.
  ;; Defaults: Clipping a strict value with a different default value is
  ;;    legal, since this is interpreted as a deliberate update action as
  ;;    opposed to a strict fact shadowing a conflicting default.  In the
  ;;    case where the new value equals the old one, however, we won't
  ;;    downgrade the strict to a default assertion (that can always be
  ;;    achieved with an explicit retraction followed by an assertion).
  (typecase term1
    (SKOLEM
     (let ((value1 (value-of term1)))
       (when (eql? value1 term2)
         ;; returning TRUE tricks 'update-equivalence-proposition' by pretending
         ;;    to do a clip (just to speed things up a bit):
         (return TRUE))
       (when (and (not (skolem? value1))
                  (defined? (defining-proposition term1))
                  *clippingEnabled?*)
         ;; do the clip (unless the value was inherited, in which case we
         ;;    shadow the value) and return TRUE:
         (unbind-skolem-value term1 TRUE)
         (bind-skolem-to-value term1 (value-of term2) TRUE)
         (return TRUE))))
    (otherwise NULL))
  (return FALSE) )

(defun (create-equivalence-proposition PROPOSITION)
       ((term1 OBJECT) (term2 OBJECT))
  ;; Return a proposition equating 'term1' and 'term2'.
  (let ((proposition (create-proposition (quote EQUIVALENT) 2))
        (argumentsVector (arguments proposition)))
    (setf (nth argumentsVector 0) term1)
    (setf (nth argumentsVector 1) term2)
    (return proposition) ))

(defun (build-equivalence-proposition PROPOSITION) ((tree CONS))
  ;; 'tree' has the form '(= <arg1> <arg2> ...)'.
  ;; Return an equivalence proposition or a conjunction of
  ;;    equivalence propositions.
  (case (length tree)
    (3                                  ; two arguments
     (return (create-equivalence-proposition
              (evaluate-term (second tree))
              (evaluate-term (third tree)))))
    ((1 2)
     (signal-proposition-error "Missing argument/s in `=' proposition."))
    (otherwise                          ; three or more arguments
     (return (build-conjunction-of-equality-propositions (rest tree) NIL)))) )

(defun (build-conjunction-of-equality-propositions PROPOSITION)
       ((remainingTerms CONS) (equivalences (CONS OF PROPOSITION)))
  ;; Helping function for 'build-equivalence-proposition'.
  ;; If one term remains in 'remainingTerms', return conjunction of
  ;;    terms in 'equivalences'.
  ;; Otherwise, create an equivalence proposition between the first
  ;;    two terms and recurse.
  (when (empty? (rest remainingTerms))
    (return (conjoin-propositions equivalences)))
  (pushq equivalences
         (build-equivalence-proposition
          (bquote (= & (first remainingTerms) & (second remainingTerms)))))
  (return
   (build-conjunction-of-equality-propositions 
    (rest remainingTerms) equivalences)) )

(defun (build-fail-proposition PROPOSITION) ((tree CONS))
  ;; Return a :FAIL proposition.
  (let ((proposition (create-proposition (quote FAIL) 1))
        (argument (build-proposition (second tree))))
    (when (null? argument)
      (return NULL))
    (setf (nth (arguments proposition) 0) argument)
    (return proposition) ))

(defun (build-collect-into-proposition PROPOSITION) ((tree CONS))
  ;; Return a :COLLECT-INTO proposition.
  (let ((proposition (create-proposition (quote COLLECT-INTO) 2))
        (argumentsVector (arguments proposition)))
    (setf (nth argumentsVector 0) (evaluate-term (second tree)))
    (setf (nth argumentsVector 1) (evaluate-term (third tree)))
    (return proposition) ))


  ;;
;;;;;; Building :PREDICATE propositions
  ;;

(defun (holds-operator? BOOLEAN) ((operator OBJECT))
  ;; Called by 'build-predicate-proposition'.
  ;; Return TRUE if 'operator' is 'HOLDS or represents either a variable
  ;;    or a non-atomic term.
  (typecase operator
    (SYMBOL
     (return (or (eql? operator (quote PL-KERNEL/HOLDS))
                 (defined? (lookup-logic-variable-binding operator)))))
    (CONS
     (return TRUE))) )

;; TO DO: CONSIDER IN-LINING THIS IF THE SECOND-ORDER FUNCTION CODE
;;    DOESN'T CALL IT:
(defun verify-evaluable-operator ((operator OBJECT) (kind KEYWORD))
  ;; Evaluate 'term' and verify that its a variable of type 'RELATION' or
  ;;    'FUNCTION'.
  ;; TO DO: CHECK EXISTING SKOLEM TYPE.
  (typecase operator
    (PATTERN-VARIABLE
     (case kind
       (:PREDICATE (setf (skolem-type operator) PL-KERNEL/@RELATION))
       (:FUNCTION (setf (skolem-type operator) PL-KERNEL/@FUNCTION))))
    (otherwise NULL)) )

(defun (build-holds-proposition PROPOSITION) ((tree CONS))
  ;; Called by 'build-predicate-proposition'.
  (let ((operatorExpression (first tree))
        (explicitHolds? (eql? operatorExpression (quote PL-KERNEL/HOLDS)))
        (argCount (length (rest tree)))
        (proposition 
         (create-proposition
          (quote PREDICATE) (choose explicitHolds? argCount (1+ argCount)))))
    (setf (operator proposition) PL-KERNEL/@HOLDS)
    (when explicitHolds?
      (foreach arg in (rest tree)
          as i in (interval 0 NULL)
          do (setf (nth (arguments proposition) i)
               (choose (= i 0)
                       (evaluate-first-argument arg (quote PL-KERNEL/HOLDS))
                       (evaluate-term arg))))
      (return proposition))
    ;; This part might be obsolete, since now the KIF translator always
    ;;    generates explicit HOLDS and VALUE propositions:
    (let ((operator OBJECT NULL))
      (typecase operatorExpression
        (SYMBOL
         (setq operator (lookup-logic-variable-binding operatorExpression)))
        (CONS
         (setq operator
           (evaluate-first-argument
            operatorExpression (quote PL-KERNEL/HOLDS)))))
      (verify-evaluable-operator operator :PREDICATE)
      (setf (nth (arguments proposition) 0) operator)
      ;; evaluate remaining arguments (can't check for PROPOSITION argument):
      (foreach arg in (rest tree)
               as i in (interval 1 NULL)
               do (setf (nth (arguments proposition) i) (evaluate-term arg)))
      (return proposition)) ))

(defun (most-general-equivalent-slotref SURROGATE) ((surrogate SURROGATE))
  ;; Run up 'slot-direct-equivalent' links to produce a reference
  ;;    the the most general slot among an equivalent set of slots.
  (let ((slot SLOT (surrogate-value surrogate)))
    (when (null? slot)
      (return NULL))
    (when (defined? (slot-direct-equivalent slot))
      ;; switch to most general equivalent:
      (while (defined? (slot-direct-equivalent slot))
        (setq slot (slot-direct-equivalent slot)))
      ;; insure existence of surrogate for 'slot':
      (when (null? (slot-slotref slot))
        (lookup-slotref (slot-owner slot) (slot-name slot))))
    (return (slot-slotref slot)) ))

(defun (polymorphic-relation? BOOLEAN) ((self RELATION))
  ;; Return TRUE if 'self' is polymorphic.
  (typecase self
    ((STORAGE-SLOT TABLE) (return TRUE))
    (otherwise (return FALSE))) )

(defun (non-polymorphic-predicate? BOOLEAN) ((self LOGIC-OBJECT))
  ;; Helping function for 'evaluate-predicate'.
  ;; Return TRUE if the predicate for 'self' is not polymorphic.
  (typecase self
    (NAMED-DESCRIPTION
     (let ((relation (native-relation self)))
       (return (not (and (defined? relation)
                         (polymorphic-relation? relation))))))
    (LOGIC-OBJECT
     (return (not (test-isa? self PL-KERNEL/@POLYMORPHIC))))) )

(defun (evaluate-predicate LOGIC-OBJECT) 
       ((name GENERALIZED-SYMBOL) (firstArgument OBJECT))
  ;; If 'name' is a surrogate that points at a description, return the description.
  ;; If 'name' is the name of a class or function, return the
  ;;     attached description (creating one if none exists).
  ;; Otherwise, search for a method named 'name' on the class matching the
  ;;    type of 'firstArgument', returning its description if found.
  (let ((surrogate SURROGATE NULL)
        (predicateValue LOGIC-OBJECT NULL))
    (typecase name
      (SYMBOL (setq surrogate (symbol-to-surrogate name)))
      (SURROGATE (setq surrogate name)))
    (setq predicateValue (get-description surrogate))
    (if (defined? predicateValue)
      (return predicateValue)
      (progn
        (setq predicateValue (surrogate-value surrogate))
        (when (and (defined? predicateValue)
                   (test-isa? predicateValue PL-KERNEL/@RELATION)
                   (non-polymorphic-predicate? predicateValue))
          (return predicateValue))))
    ;; so far, either 'name' is undefined or its polymorphic:
    (when (defined? firstArgument)
      (let ((firstArgValue (value-of firstArgument))
            (symbol (surrogate-to-symbol surrogate)))
        (when (null? firstArgValue)
          (signal-undefined-term firstArgument))
        (setq surrogate (lookup-slotref-on-instance firstArgValue symbol))
        (when (defined? surrogate)
          (return (get-description (most-general-equivalent-slotref surrogate))))))
    (return NULL) ))

(defglobal *auto-coerce-propositional-arguments?* BOOLEAN FALSE
  :documentation "If TRUE, automatically coerce propositional arguments of a
proposition, even if the corresponding argument type of the hosting relation
doesn't indicate that."
  :public? TRUE)

(defun (propositional-argument? BOOLEAN) ((argument OBJECT))
  ;; Return TRUE if `argument' can be determined to be a tree that represents
  ;;    a proposition.
  (typecase argument
    (CONS
     (let ((operator (first argument))
           (firstArg (second argument)))
       (when (and (not (eql? operator (quote PL-KERNEL/VALUE)))
                  (holds-operator? operator))
         (return TRUE))
       (when (symbol? operator)
         (case operator
           ((AND OR NOT EXISTS FORALL =)
            (return TRUE))
           (otherwise
            (let ((predicate (evaluate-predicate operator firstArg))
                  (arity 0))
              (when (defined? predicate)
                (typecase predicate
                  (NAMED-DESCRIPTION
                   (cond ((function? predicate)
                          (setq arity (arity predicate))
                          (if (or (= arity -1)
                                  (= arity (length argument)))
                              (return FALSE)
                            (return TRUE)))
                         (otherwise
                          (return TRUE))))
                  (otherwise NULL)))))))))
    (otherwise NULL))
  (return FALSE))

(defun (evaluate-typed-argument OBJECT) ((argument OBJECT) (type SURROGATE))
  ;; Helping function for creating predicate arguments.
  ;; If 'type' is @PROPOSITION, create a proposition instead of a term.
  (cond
   ((or (eql? type @PROPOSITION)
        (and *auto-coerce-propositional-arguments?*
             (propositional-argument? argument)))
    (return (build-proposition argument)))
   ((defined? type)
    ;; signal 'type' so that, if its a native type, that a native
    ;;    instance will be created:
    (special ((*defaultCreationType* type))
      (return (evaluate-term argument))))
   (otherwise
    (return (evaluate-term argument)))) )

(defun (evaluate-first-argument OBJECT) ((argument OBJECT) (relationName SYMBOL))
  ;; Called by 'build-predicate-proposition'.
  ;; Evaluate 'argument', which is assumed to be the first argument
  ;;    to the relation named 'relation'
  ;; If 'relation' names a STELLA function whose first argument has type
  ;;    PROPOSITION, then 'argument' is evaluated as a proposition (sentence).
  ;; Otherwise, it is evaluated as a term.
  (let ((predicateValue  (evaluate-predicate relationName NULL))
        (type SURROGATE NULL)
        (firstArgument OBJECT NULL))
    (when (and (defined? predicateValue)
               (isa? predicateValue @NAMED-DESCRIPTION))
      (setq type (first (io-variable-types 
                         (cast predicateValue NAMED-DESCRIPTION)))))
    (setq firstArgument (evaluate-typed-argument argument type))
    (case relationName
      ((PL-KERNEL/VALUE PL-KERNEL/HOLDS)
       ;; Special-case the evaluation of the relation argument of VALUE and
       ;;    HOLDS propositions to avoid flattening in case it was a ground
       ;;    non-atomic term as in `(holds (fn a) ?x ?y)'.  This ensures we
       ;;    can properly eliminate the HOLDS during normalization.  In
       ;;    principle, we could do this for all fully ground function terms
       ;;    inside descriptions, however, too much machinery currently
       ;;    assumes flattened structures and doesn't expect skolems:
       (when (and (description-mode?)
                  (variable? firstArgument))
         (let ((fnProp
                (defining-proposition (cast firstArgument PATTERN-VARIABLE))))
           (when (and (defined? fnProp)
		      ;; Check all but last argument (- length 2)
		      (not (exists i in (interval 
					 0 (- (length (arguments fnProp)) 2))
			       where (variable? (nth (arguments fnProp) i)))))
             (special ((*evaluationMode* :EXTENSIONAL-ASSERTION))
               ;; we have a fully ground relation term, reevaluate it
               ;;    extensionally to get a skolem and avoid flattening:
               (setq firstArgument
                 (evaluate-typed-argument argument type)))))))
      (otherwise NULL))
    (when (null? firstArgument)
      (signal-undefined-term argument))
    (special ((*suppressNonLogicObjectWarning?* TRUE))
      (when (eql? (value-of firstArgument) BOTTOM)
        (signal-undefined-term firstArgument)))
    (return firstArgument) ))

(defun (evaluate-remaining-arguments CONS) 
       ((predicateValue LOGIC-OBJECT) (arguments CONS))
  ;; Called by 'build-predicate-proposition'.
  ;; Evaluate each of the terms in 'arguments', representing all but
  ;;    the first argument to a proposition with operator 'slot'.
  ;; Special care is taken if 'slot' is a meta-relation,
  ;;    or if an argument has type proposition.
  (let ((evaluatedArguments NIL))
    (if (and (defined? predicateValue )
             (isa? predicateValue @NAMED-DESCRIPTION))
      (let ((variableTypes (io-variable-types 
                            (cast predicateValue NAMED-DESCRIPTION))))
        (foreach type in (rest variableTypes)
                  do
                  (let ((arg (popq arguments)))
                    (when (defined? arg)
                      (pushq evaluatedArguments
                             (evaluate-typed-argument arg type)))))
        ;; handle variable arity:
        (foreach arg in arguments
                 do (pushq evaluatedArguments
                           (evaluate-typed-argument arg (last variableTypes))))
        (return (reverse evaluatedArguments)))
      (progn
        (foreach arg in arguments
                 collect (evaluate-term arg) into evaluatedArguments)
        (return evaluatedArguments))) ))

(defun (class-operator? BOOLEAN) ((operator GENERALIZED-SYMBOL))
  ;; Called by 'build-predicate-proposition' to determine if the operator
  ;;    of a unary predicate references a class instead of a unary relation
  (let ((description (get-description operator)))
    (return (and (defined? description)
                 (class-description? description)) ) ))

(defun (build-predicate-proposition PROPOSITION) ((tree CONS))
  ;; Evaluate each proposition argument, lookup the slot that corresponds to
  ;;    the predicate named in 'tree', and stuff them into a new predicate
  ;;    or function proposition.
  (when (and (eql? (length tree) 2)
             (class-operator? (first tree)))
    (return (build-isa-proposition
             (bquote (ISA & (second tree) & (first tree))))))
  (when (holds-operator? (first tree))
    (return (build-holds-proposition tree)))
  (let ((predicateName (first tree))
        (proposition
         (create-proposition (quote PREDICATE) (length (rest tree))))
        (firstArgument OBJECT NULL)
        (predicateValue LOGIC-OBJECT NULL))
    (cond
     ((nil? (rest tree))                ; no arguments
      (if (eql? predicateName (quote PL-KERNEL/CUT))
        NULL                            ; zero arity is OK
        ;; TO DO: FIGURE OUT HOW TO TEST FOR VARIABLE ARITY HERE, AND
        ;;    FLAG AS ERROR ONLY FOR FIXED ARITY:
        (inform "Predicate " predicateName " applied to zero arguments.")))
     (otherwise
      (setq firstArgument (evaluate-first-argument (second tree) predicateName))
      (setf (nth (arguments proposition) 0) firstArgument)))
    (setq predicateValue (evaluate-predicate predicateName firstArgument))
    (when (and (defined? predicateValue )
               (function? predicateValue))
      ;; tricky: we mandate that asserted functions have a SKOLEM for
      ;;    their last argument, while we prefer (but don't insist) that
      ;;    functions within a description don't generate their own result
      ;;    variable:
      (if (description-mode?)
        ;; change :PREDICATE to :FUNCTION:
        (setf (kind proposition) :FUNCTION)
        ;; convert from predicate to function form:
        (let ((lastArgIndex (1- (length tree)))
              (resultArgument (nth tree lastArgIndex)))
          (setf (nth tree lastArgIndex) NULL)
          (setq tree (remove tree NULL))
          (return (build-proposition
                   (bquote (= & tree & resultArgument)))))))
    ;; evaluate remaining predicate arguments:
    (foreach arg in (evaluate-remaining-arguments
                     predicateValue  (rest (rest tree)))
             as i in (interval 1 NULL)
             do (setf (nth (arguments proposition) i) arg))
    (setf (operator proposition)
          (choose (defined? predicateValue )
                  (surrogate-value-inverse predicateValue )
                  predicateName))
    ;; Copied relevant logic from `finish-creating-function-proposition'
    ;;    for proper handling of things like `(= ((FN A) B) C)':
    (when (eql? (operator proposition) PL-KERNEL/@VALUE)
      (setq proposition (normalize-VALUE-function proposition)))
    (verify-argument-types-and-count proposition)
    (return proposition) ))


  ;;
;;;;;; Type checking
  ;;

(defun (check-strict-type? BOOLEAN)
       ((self OBJECT) (type SURROGATE) (shallow? BOOLEAN))
  ;; Check that the type of 'self' satisfies 'type'.
  ;; Otherwise, return FALSE.
  ;; TO DO: POSSIBLY IMPLEMENT NON-SHALLOW TYPE CHECKS, RIGHT NOW THE
  ;;    SWITCH IS IGNORED.
  (ignore shallow?)
  ;; Quick tests:
  (when (or (null? type)
            (null? self)
            (eql? type STELLA/@THING))
    (return TRUE))
  (typecase self
    (PATTERN-VARIABLE
     (return TRUE))
    ((LITERAL-WRAPPER PROPOSITION)
     (when (and (isa? (surrogate-value type) STELLA/@CLASS)
                (subtype-of? (logical-type self) type))
       (return TRUE)))
    (otherwise NULL))
  ;; otherwise, look for type assertion:
  (return
    (or (test-isa? self type)
        ;; this should be redundant, but skolems may lack
        ;;    the :ISA proposition matching their root type:
        (logical-subtype-of? (logical-type self) type))))

(defun (check-type? BOOLEAN) 
       ((self OBJECT) (type SURROGATE) (shallow? BOOLEAN))
  :globally-inline? TRUE
  ;; Check that the type of 'self' satisfies 'type'.
  ;; Otherwise, return FALSE.
  ;; This will also return TRUE if in partial match mode.
  ;; `shallow?' controls depth of check.  See `check-strict-type'.
  (return (or (partial-match-mode?)
              (check-strict-type? self type shallow?))))

(defun (check-coerced-type? BOOLEAN OBJECT) 
       ((self OBJECT) (type SURROGATE) (shallow? BOOLEAN))
  ;; Check that the type of 'self' satisfies 'type'.  If so, return
  ;;    TRUE and 'self'.
  ;; If not, possibly coerce 'self' to a compatible value and return
  ;;    TRUE and the coerced value.
  ;; Otherwise, return FALSE.
  ;; `shallow?' controls depth of check.  See `check-strict-type'.
  (when (check-strict-type? self type shallow?)
    (return TRUE self))
  ;; 'self' does not strictly satisfy 'type'.  See if we can coerce it:
  (let ((substitutedValue (coerce-incompatible-value self type)))
    (when (defined? substitutedValue)
      (return TRUE substitutedValue)))
  (if (partial-match-mode?)
    (return TRUE self)
    (return FALSE self)) )

(defun (coerce-incompatible-value OBJECT) ((value OBJECT) (type SURROGATE))
  ;; If we can safely coerce 'value' to have type 'type', return
  ;;    the coerced value.
  (let ((substitute-value OBJECT NULL))
    (cond
     ((relationref-specializes-relationref? type PL-KERNEL/@QUANTITY)
      (return (coerce-quantity value type)))
     ((relationref-specializes-relationref? type PL-KERNEL/@DATE)
      (return (coerce-date value type)))
     ;; Handle logic-wrappers with types asserted about them, e.g., `(myint 42)'
     ;; This isn't really a proper coercion, but we need to make sure that the
     ;; coerced value winds up in the proposition, e.g., in query expressions:
     ((and (isa? value @LITERAL-WRAPPER)
           (test-isa? (rewrap-argument value) type))
      (return (rewrap-argument value))))
    (typecase value
      (INTEGER-WRAPPER
       (when (eql? type @FLOAT)
         (let ((intValue (wrapper-value value))
               (floatValue FLOAT (cast intValue @FLOAT)))
           (setq substitute-value (wrap-literal floatValue)))))
      (FLOAT-WRAPPER
       (when (eql? type @INTEGER)
         (let ((floatValue (wrapper-value value))
               (intValue (floor floatValue)))
           (when (= (cast intValue @FLOAT) floatValue)
             (setq substitute-value (wrap-literal intValue))))))
      (otherwise NULL))
    (return substitute-value) ))

(defun (coerce-quantity OBJECT) ((value OBJECT) (quantityTypeRef SURROGATE))
  ;; Called by 'coerce-incompatible-value'.
  ;; Try to coerce 'value' to be compatible with the quantity
  ;;    type concept pointed to by 'quantityTypeRef'.
  ;; NOT YET IMPLEMENTED; RETURN 'value' TO MAKE TYPE CHECKING SHUT UP:
  (return value) )

(defun (coerce-date OBJECT) ((value OBJECT) (dateTypeRef SURROGATE))
  ;; Called by 'coerce-incompatible-value'.
  ;; Try to coerce 'value' to be compatible with the quantity
  ;;    type concept pointed to by 'dateTypeRef'.
  ;; NOT YET IMPLEMENTED; RETURN 'value' TO MAKE TYPE CHECKING SHUT UP:
  (return value) )

(defglobal *type-check-policy* KEYWORD :AUTOMATICALLY-FIX-TYPE-VIOLATIONS
  :documentation "Three policies are implemented:
   :AUTOMATICALLY-FIX-TYPE-VIOLATIONS asserts missing types to fix type
       violations (default),
   :REPORT-TYPE-VIOLATIONS complains about missing or incorrect types,
   :SIGNAL-TYPE-VIOLATIONS throws exception for missing or incorrect types, and
   :IGNORE-TYPE-VIOLATIONS which disables all type checking.")

(defspecial *typeCheckMode* KEYWORD :POST-TYPE-VIOLATIONS
  :documentation "Controls the behavior of the type-checking
routines in the event that a type-check fails.  Options are:
  :POST-TYPE-VIOLATIONS              push offending proposition onto queue,
  :REPORT-TYPE-VIOLATIONS            print occasions of failed type checks,
  :SIGNAL-TYPE-VIOLATIONS            throw exception for failed type checks,
  :AUTOMATICALLY-FIX-TYPE-VIOLATIONS assert missing types on propositions, and
  :IGNORE-TYPE-VIOLATIONS            don't perform any type checking at all.")

(defun verify-one-argument-type 
       ((arg OBJECT) (type SURROGATE)
        (proposition PROPOSITION) (description NAMED-DESCRIPTION))
  ;; Helping function for 'verify-argument-types-and-count'.	
  (when (or (eql? *typeCheckMode* :IGNORE-TYPE-VIOLATIONS)
            ;; bail if 'type' is not defined:
            (null? (surrogate-value type)))
    (return))
  (let ((argValue (value-of arg))
        (typeIsOK? BOOLEAN NULL)
        (substituteValue OBJECT NULL))
    (mv-setq (typeIsOK? substituteValue)
             (check-coerced-type? argValue type FALSE))
    (cond
     ((not (eql? argValue substituteValue))
      ;; replace argument with coerced value:
      (foreach argToo in (arguments proposition)
               as t in (io-variable-types description)
               as i in (interval 0 NULL)
               where (and (eql? argToo arg)
                          (eql? t type))
               do (setf (nth (arguments proposition) i)
                        substituteValue)))
     ((not typeIsOK?)
      (handle-argument-type-violation proposition arg type)))))

(defun verify-argument-types-and-count ((proposition PROPOSITION))
  ;; Generate an exception if the number of arguments in 'proposition'
  ;;    does not match the arity of its predicate, or if the
  ;;    argument types clash.
  ;; TO DO: ADD DEBUG MODE WHERE INFERRED ASSERTIONS ARE TYPE-CHECKED:
  (when (or (eql? *typeCheckMode* :IGNORE-TYPE-VIOLATIONS)
            (not (world-state? *context*))
            (not (isa? (operator proposition) @SURROGATE)))
    (return))
  (let ((description (get-description (relationRef proposition)))
        (argumentCount (length (arguments proposition))))
    (case (kind proposition)
      ((:PREDICATE :FUNCTION :ISA)
       (when (null? description)       ; moved in here, since also null for `='
         (return))
       (let ((arity (arity description))
             (variableArity? (not (plus? arity)))
             (function? (eql? (kind proposition) :FUNCTION)))
         (when (and (not variableArity?)
                    (not (= argumentCount arity)))
           (handle-arity-violation proposition arity))
         (foreach arg in (arguments proposition)
             as i on (interval 1 (choose (and variableArity? function?)
                                         (1- argumentCount)
                                         argumentCount))
             as type in (all-domain-types description)
             where (and (defined? type)
                        (not (eql? type @THING))
                        (defined? arg))
             do (verify-one-argument-type arg type proposition description))
         (when function?
           (verify-one-argument-type
            (last (arguments proposition))
            (last (io-variable-types description))
            proposition description))))
      (:EQUIVALENT
       ;; `build-equivalence-proposition' already checks for proper argument
       ;;    count, so we only have to check for type problems (this is mainly
       ;;    to the benefit of `bind-skolem-to-value'):
       (let ((arg1 (first (arguments proposition)))
             (arg2 (second (arguments proposition)))
             (requiredType TYPE NULL)
             (constrainingArg OBJECT NULL)
             (offendingArg OBJECT NULL)
             (typeIsOK? BOOLEAN NULL)
             (substituteValue OBJECT NULL))
         (setq requiredType (safe-logical-type arg2))
         (mv-setq (typeIsOK? substituteValue)
           (check-coerced-type? arg1 requiredType FALSE))
         (cond ((not (eql? arg1 substituteValue))
                (setf (first (arguments proposition)) substituteValue)
                (return))
               ((not typeIsOK?)
                (setq constrainingArg arg2)
                (setq offendingArg arg1)))
         (when typeIsOK?
           (setq requiredType (safe-logical-type arg1))
           (mv-setq (typeIsOK? substituteValue)
             (check-coerced-type? arg2 requiredType FALSE))
           (cond ((not (eql? arg2 substituteValue))
                  (setf (second (arguments proposition)) substituteValue)
                  (return))
                 ((not typeIsOK?)
                  (setq constrainingArg arg1)
                  (setq offendingArg arg2))))
         (unless typeIsOK?
           (special ((*termUnderConstruction* *termUnderConstruction*))
             (when (and (null? *termUnderConstruction*)
                        (skolem? constrainingArg))
               ;; try to re-establish some better error context - adapting
               ;;    `print-skolem' would also do the trick here:
               (setq *termUnderConstruction*
                 (defining-proposition (cast constrainingArg SKOLEM))))
             (handle-argument-type-violation
              proposition offendingArg requiredType)))))
      (otherwise
       ;; NOTHING ELSE IMPLEMENTED YET
       NULL)) ))

(defun handle-argument-type-violation
    ((proposition PROPOSITION) (arg OBJECT) (requiredType SURROGATE))
  ;; Handle the situation where argument `arg' of `proposition' does not
  ;;    conform to `requiredType'.
  (case *typeCheckMode*
    (:POST-TYPE-VIOLATIONS
     (post-to-check-types-agenda proposition))
    (:REPORT-TYPE-VIOLATIONS
     (signal-proposition-warning
      "Type check violation on argument `" arg "' in proposition" EOL
      "   " proposition "." EOL
      "   Argument must have type `" (symbol-name requiredType) "'."))
    (:SIGNAL-TYPE-VIOLATIONS
     (signal-proposition-error
      "Type check violation on argument `" arg "' in proposition" EOL
      "   " proposition "." EOL
      "   Argument must have type `" (symbol-name requiredType) "'."))
    (:AUTOMATICALLY-FIX-TYPE-VIOLATIONS
     (safety 3 (and (world-state? *context*)
                    (not (descriptive? proposition)))
             "INTERNAL ERROR: `handle-argument-type-violation': Illegal "
             " proposition argument or context")
     ;; TO DO: CONDITIONALIZE THIS WITH CHECK FOR DISJOINT
     ;;    PREASSERTED TYPES:
     ;; clever: we don't make this assertion during the
     ;;    POST phase, allowing for the possibility
     ;;    that a specializing type will be asserted before
     ;;    the FIX-TYPES phase:
     (let ((isaProposition (assert-isa-proposition arg requiredType)))
       (setf (asserted-by-type-checker? isaProposition) TRUE)))))

(defun handle-arity-violation ((proposition PROPOSITION) (requiredArity INTEGER))
  ;; Handle the situation where `proposition's argument count
  ;;    does not conform to `requiredArity'.
  (case *typeCheckMode*
    (:POST-TYPE-VIOLATIONS
     (post-to-check-types-agenda proposition))
    ((:SIGNAL-TYPE-VIOLATIONS :REPORT-TYPE-VIOLATIONS
                              :AUTOMATICALLY-FIX-TYPE-VIOLATIONS)
     (signal-proposition-error
      "Too "
      (choose (> (length (arguments proposition)) requiredArity) "many" "few")
      " arguments in the proposition" EOL
      "   " (generate-term proposition) EOL
      "   Expected " requiredArity " argument(s)."))))

(defclass CHECK-TYPES-RECORD (STANDARD-OBJECT)
  :slots ((parent-proposition :type OBJECT)
          (parent-description :type DESCRIPTION)
          (module :type MODULE)) )

(defglobal *check-types-agenda* (KEY-VALUE-LIST OF PROPOSITION CHECK-TYPES-RECORD)
  (new KEY-VALUE-LIST)
  :documentation "List of propositions that have failed a type check,
but might pass once finalization is complete.")

(defun post-to-check-types-agenda ((self PROPOSITION))
  ;; 'self' failed a type check or an arity check.  Post it to agenda,
  ;;     and recheck it after everything has been finalized.
  (safety 3 (world-state? (home-context self))
          "INTERNAL ERROR: Checking types in non-world-state")
  (insert-at *check-types-agenda* self
             (new CHECK-TYPES-RECORD
                  :parent-proposition *termUnderConstruction*
                  :parent-description *descriptionUnderConstruction*
                  :module *module*)) )

(defun process-check-types-agenda ()
  ;; Called at the end of 'process-definitions'.
  ;; TO DO: PUT BAD GUYS ON A LIST OF BADDIES, OR ASSERT THEM TO A BAD GUYS
  ;;    CLASS.
  (when (or (empty? *check-types-agenda*)
            *inhibitObjectFinalization?*)
    (return))
  (safety 3 (objects-are-finalized?)
          "INTERNAL ERROR: Called 'process-check-types-agenda' "
          "when there are unfinalized objects")
  (safety 3 (world-state? *context*)
          "INTERNAL ERROR: Called 'process-check-types-agenda' "
          "when not in a world state")
  (pl-log :medium "Processing check-types agenda...")
  (let ((agenda (reverse *check-types-agenda*)))
    ;; Reset the agenda here to avoid infinite recursion (some type-checking
    ;;    involves proposition lookup which in turn accesses inference caches
    ;;    which in turn call `process-check-types-agenda'...):
    (setq *check-types-agenda* (new KEY-VALUE-LIST))
    (foreach (proposition record) in agenda
        where (not (deleted? proposition))
        do (special ((*typeCheckMode*
                      (choose
                       (and (descriptive? proposition)
                            (not (eql? *type-check-policy*
                                       :IGNORE-TYPE-VIOLATIONS)))
                       :REPORT-TYPE-VIOLATIONS
                       *type-check-policy*))
                     (*termUnderConstruction* (parent-proposition record))
                     (*descriptionUnderConstruction* (parent-description record)))
             (when (or (deleted? proposition)
                       (and (defined? *termUnderConstruction*)
                            (deleted? *termUnderConstruction*))
                       (and (defined? *descriptionUnderConstruction*)
                            (deleted? *descriptionUnderConstruction*)))
               (continue))
             (exception-case
                 (within-module (module record)
                   (verify-argument-types-and-count proposition))
               (LOGIC-EXCEPTION (e)
                 (print-stream STANDARD-ERROR (exception-message e))))))))

(defun process-definitions ()
  :public? TRUE :command? TRUE
  :documentation "Finish processing all definitions and assertions that have
been evaluated/loaded since that last call to 'process-definitions'.
PowerLoom defers complete processing of definitions to make it easier
to support cyclic definitions.  Following finalization of definitions,
this call performs semantic validation of any assertions evaluated since
the last call to 'process-definitions'.  PowerLoom calls this function
internally before each query; the primary reason to call it explicitly
is to force the production of any diagnostic information that results from
the processing and validation."
  (finalize-objects)
  (process-check-types-agenda))


  ;;
;;;;;; EXISTS and FORALL propositions
  ;;

(defun (build-exists-proposition PROPOSITION) ((tree CONS))
  ;; 'tree' has the form
  ;;    '(EXISTS <variables> <proposition>)'.
  ;; Description mode insures that correct things happen
  ;;    with function terms inside of existentially-quantified
  ;;    assertions.
  (mv-bind (variables proposition unused)
       (build-quantified-proposition tree TRUE)
   (ignore unused)
   (let ((existsProp (create-proposition (quote EXISTS) 1)))
     (setf (kind existsProp) :EXISTS)
     (setf (nth (arguments existsProp) 0) proposition)
     (setf (io-variables existsProp) 
           (copy-cons-list-to-variables-vector variables))
     (return existsProp))) )

(defun (top-level-exists-proposition? BOOLEAN) ((proposition PROPOSITION))
  ;; Return TRUE if `proposition' is a top-level exists proposition
  ;;    whose quantified variables got skolemized.
  (return (and (not (unknown? proposition))
               (help-collect-skolemized-exists-variables? proposition NULL))))

(defun (collect-skolemized-exists-variables (VECTOR OF SKOLEM))
    ((proposition PROPOSITION))
  ;; Assume `proposition' is a top-level exists proposition and collect
  ;;    its skolemized variables into a vector (needed for print routines).
  (let ((skolems (new (LIST OF SKOLEM)))
        (result (VECTOR OF SKOLEM) NULL))
    (help-collect-skolemized-exists-variables? proposition skolems)
    (if (empty? skolems)
        (setq result ZERO-VARIABLES-VECTOR)
      (setq result (new VECTOR :array-size (length skolems))))
    (foreach skolem in skolems
        as i in (interval 0 NULL)
        do (setf (nth result i) skolem))
    (free skolems)
    (return result)))

(defun (help-collect-skolemized-exists-variables? BOOLEAN)
    ((proposition PROPOSITION) (result (LIST OF SKOLEM)))
  ;; Helper function for `top-level-exists-proposition?' and
  ;;    `collect-skolemized-exists-variables?'.
  ;; Return TRUE if `proposition' is a top-level exists proposition.
  ;; If `result' was supplied as non-NULL, collect skolemized exists
  ;;    variables into it.
  (let ((arguments (arguments proposition))
        (argumentCount (length arguments)))
    (when (eql? (kind proposition) :FUNCTION)
      (-- argumentCount))
    (foreach arg in arguments
        as i in (interval 1 argumentCount)
        do (ignore i)
           (typecase arg
             (PROPOSITION
              (when (and (help-collect-skolemized-exists-variables? arg result)
                         (null? result))
                (return TRUE)))
             (PATTERN-VARIABLE NULL)
             (SKOLEM
              (when (exists prop in (unfiltered-dependent-isa-propositions arg)
                        where (and (eql? (kind prop) :ISA)
                                   (true? prop)
                                   (variable-type? prop)))
                (if (defined? result)
                    (insert-new result arg)
                  (return TRUE))))
             (otherwise NULL)))
    (if (defined? result)
        (return (non-empty? result))
      (return FALSE))))
                  
(defun (build-forall-proposition PROPOSITION) ((tree CONS))
  ;; 'tree' has the form
  ;;    '(FORALL <variables> <proposition> <proposition>)'.
  (let ((forallProp (create-proposition (quote FORALL) 2)))
    (mv-bind (variables antecedent consequent)
         (build-quantified-proposition tree TRUE)
     ;; create an explicit :FORALL proposition
     (setf (kind forallProp) :FORALL)
     (setf (io-variables forallProp) 
           (copy-cons-list-to-variables-vector variables))
     (setf (nth (arguments forallProp) 0)
           (choose (defined? antecedent) antecedent TRUE-PROPOSITION))
     (setf (nth (arguments forallProp) 1) consequent))
    (return forallProp) ))

(defun verify-forall-propositions ((proposition PROPOSITION))
  ;; If `proposition' is a :FORALL or a conjunction of :FORALL's check
  ;;    for properly matching variables between antecendent and consequent.
  ;;    Rules that reference variables in their consequents that are not
  ;;    restricted by the antecedent are usually a mistake, they can't be
  ;;    run forward, and they can cause problems during backchaining if
  ;;    such a variable is unbound (since nothing will bind it).
  (case (kind proposition)
    (:FORALL
     (let ((antecedent PROPOSITION (first (arguments proposition)))
           (consequent PROPOSITION (second (arguments proposition)))
           (antVars LIST NULL)
           (cqVars LIST NULL))
       (when (eql? (kind antecedent) :CONSTANT)
         ;; special-case rules of the form (=> TRUE (P ?x)):
         (return))
       (setq antVars (list))
       (setq cqVars (list))
       (collect-free-variables antecedent antVars (list) (list))
       (collect-free-variables consequent cqVars (list) (list))
       (unless (and (non-empty? cqVars)
                    (subset? cqVars antVars))
         (special ((*termSourceBeingParsed* NULL)
                   (*termUnderConstruction* NULL)
                   (*printReadably?* TRUE)
                   (*printMode* :REALISTIC)
                   (*prettyPrintLogicalForms?* TRUE)
                   (*prettyPrintKif?* TRUE))
           ;(setf (unfastened? proposition) FALSE)
           (setq cqVars (difference cqVars antVars))
           ;; Down-grade this to a warning for now, since in some cases with
           ;; equivalences and normalization this can occur and make sense:
           (signal-proposition-warning
            "Potentially problematic implication rule, consequent variable(s) "
            (replace-substrings (stringify (the-cons-list cqVars)) "?" "|V|?")
            EOL "   are not restricted/used by the antecedent: "
            EOL proposition)))))
    (:AND
     (foreach arg in (arguments proposition)
         do (verify-forall-propositions arg)))
    (otherwise NULL)))

(defun (maybe-substitute-surrogate-argument OBJECT) ((arg1 OBJECT) (arg2 OBJECT))
  ;; If 'arg1' is a description and 'arg2' is a skolem, return
  ;;    a surrogate for 'arg1'.  Otherwise, return 'arg1'.
  ;; Also return a surrogate if we are in description mode (to prevent
  ;;    an IMPLIES in a description from structure sharing with an
  ;;    assertional IMPLIES.
  (when (or (skolem? arg2)
            (description-mode?))
    (typecase arg1
      (DESCRIPTION
       (when (defined? (description-surrogate arg1))
         (return (description-surrogate arg1))))
      (otherwise NULL)))
  (return arg1) )

(defun (create-implies-proposition PROPOSITION) 
       ((tail OBJECT) (head OBJECT))
  ;; Create an IMPLIES, but don't install backlinks.
  (let ((impliesProp (create-proposition (quote IMPLIES) 2)))
    ;; Tricky: We don't want backlinks from named descriptions to
    ;;    collections associated with individuals.  Solution (for now)
    ;;    If either argument is a skolem, make the other a surrogate
    ;;    instead of a description.
    (setf (nth (arguments impliesProp) 0) 
          (maybe-substitute-surrogate-argument tail head))
    (setf (nth (arguments impliesProp) 1) 
          (maybe-substitute-surrogate-argument head tail))
    (verify-argument-types-and-count impliesProp)
    (return impliesProp) ))

(defun (build-implies-proposition PROPOSITION) ((tree CONS))
  ;; Convert an IMPLIES or SUBSET-OF parse tree into an :IMPLIES proposition.
  (verify-number-of-proposition-arguments tree 2)
  (let ((tailArg (evaluate-term (second tree)))
        (headArg (evaluate-term (third tree))))
    (return (create-implies-proposition tailArg headArg)) ))


  ;;
;;;;;; Function terms and function propositions
  ;;

;;; Representation Strategy: Function propositions are always intensionally
;;;    true.  This means that there is at most one function proposition
;;;    for any combination of n-1 arguments (and attribute propositions
;;;    are therefore unique).  To represent '(conceive (= y (f x)))
;;;    when the proposition is not TRUE, we use an equality proposition
;;;    between 'y' and a skolem that represents '(f x)'.

(defun (find-duplicate-function-proposition PROPOSITION) ((proposition PROPOSITION))
  ;; Look for an existing function proposition whose input arguments
  ;;    match those in 'proposition'.
  ;; This is now mostly obsolete and handled by `find-duplicate-proposition'.
  (if (or *loadingRegenerableObjects?*
          (not (isa? (operator proposition) @SURROGATE))) ; undefined reference?
      (return NULL)
    (return (find-duplicate-proposition proposition))))

(defun (unwrap-wrapped-type TYPE) ((type TYPE))
  ;; Help finish-creating-function-proposition' by unwrapping wrapped literals.
  (when (and (defined? type)
             (defined? (surrogate-value type))
             (isa? (surrogate-value type) @CLASS)
             (subtype-of? type @LITERAL-WRAPPER))
      ;; The logical type of wrapped literals is the literal type
      ;; (e.g., NUMBER for the result variable of 'NUMBER-WRAPPER.plus'):
      (setq type (wrapped-type-to-type type)))
  (return type) )

(defun (begin-creating-function-proposition PROPOSITION)
       ((surrogate GENERALIZED-SYMBOL) (inputArguments CONS))
  ;; Called by find-or-create-function-proposition'.
  ;; Create a new function proposition with no last argument.
  (let ((argCount (1+ (length inputArguments)))
        (proposition (create-proposition (quote FUNCTION) argCount)))
    (setf (operator proposition) surrogate)
    (foreach arg in inputArguments
             as i in (interval 0 NULL)
             do (setf (nth (arguments proposition) i) arg))
    (return proposition) ))

(defun (finish-creating-function-proposition PROPOSITION) 
       ((proposition PROPOSITION))
  ;; Called by find-or-create-function-proposition'.
  ;; Bind the last argument of 'proposition' to a newly-created skolem and
  ;;    fasten it down.
  (let ((argCount (length (arguments proposition)))
        (description (get-description (operator proposition)))
        (type TYPE NULL)
        (skolem SKOLEM NULL))
    (when (defined? description)
      (setq type (unwrap-wrapped-type (last (io-variable-types description)))))
    ;; make sure that the output skolem is in the same context as 'proposition':
    (within-context (home-context proposition)
      (setq skolem (create-variable-or-skolem type NULL)))
    (setf (nth (arguments proposition) (1- argCount)) skolem)
    (setf (defining-proposition skolem) proposition)
    (when (defined? type)
      (update-skolem-type skolem type))
    (when (eql? (operator proposition) PL-KERNEL/@VALUE)
      (setq proposition (normalize-VALUE-function proposition)))
    (verify-argument-types-and-count proposition)
    (when (isa? (operator proposition) @SURROGATE)
      (fasten-down-one-proposition proposition TRUE))
    (return proposition) ))

(defun (find-or-create-function-proposition PROPOSITION)
       ((predicate GENERALIZED-SYMBOL) (inputArguments CONS))
  ;; Return either an existing function term that applies 'predicate' to
  ;;    'inputArguments' or a newly created one.
  ;; Tricky: We check for a duplicate here to avoid generating multiple 
  ;;    skolems/variables representing the same function.
  (let ((proposition
         (begin-creating-function-proposition predicate inputArguments))
        ;; tricky: we don't look for duplicates in description mode
        ;;    because it would cause us (1) to pick up skolems that
        ;;    might not stay current with the surrogates in 'inputArguments',
        ;;    and (2) for reasons that aren't completely clear to me, it
        ;;    seems to create unwanted skolems.  -rmm
        (duplicate
         (only-if (not (description-mode?))
                  (find-duplicate-function-proposition proposition))))
    (when (defined? duplicate)
      (return duplicate))
    (setq proposition (finish-creating-function-proposition proposition))
    (when (or (not (descriptive? proposition))
              ;; if we have a constant term in a description, run demon also:
              (forall i in (interval 0 (- (length (arguments proposition)) 2))
                  always (not (variable? (nth (arguments proposition) i)))))
      (run-goes-true-demons proposition))
    (return proposition)))

(defun (create-function-proposition PROPOSITION)
       ((predicate GENERALIZED-SYMBOL) (inputArguments CONS))
  ;; Return a newly-created function term that applies 'predicate' to
  ;;    'inputArguments'.
  ;; Called by 'inherit-proposition'.
  (let ((proposition
         (begin-creating-function-proposition predicate inputArguments)))
    (return (finish-creating-function-proposition proposition)) ))

;;; Main entry to building a function term:
(defun (evaluate-FUNCTION-term OBJECT) ((tree CONS))
  ;; Return a skolem or LOGIC-OBJECT representing the output of the function
  ;;    term 'fnTerm'.
  (unless (isa? (first tree) @GENERALIZED-SYMBOL)
    ;; robustness check to guard against illegal input:
    (signal-proposition-error "Illegal function name in function term: "
                              tree))
  (let ((name GENERALIZED-SYMBOL (first tree))
        (firstArgument (evaluate-first-argument (second tree) name))
        (predicateValue  (evaluate-predicate name firstArgument))
        (inputArguments
         (evaluate-remaining-arguments predicateValue (rest (rest tree)))))
    (when (and (defined? predicateValue)
               (isa? predicateValue @DESCRIPTION)
               (not (function-description? predicateValue)))
      (signal-proposition-error
       "Relation " (description-name (cast predicateValue NAMED-DESCRIPTION))
       " found in function position."))
    (pushq inputArguments firstArgument)
    (when (and (defined? predicateValue)
               (eql? (object-surrogate predicateValue) PL-KERNEL/@SETOF))
      ;; normalize argument order of sets to pick up duplicates:
      (setq inputArguments (sort inputArguments (the-code :function logic-form-less?))))
    (let ((functionProposition
           (find-or-create-function-proposition
            (choose (defined? predicateValue ) 
                    (surrogate-value-inverse predicateValue )
                    name)
            inputArguments)))
      (when (and (symbol? (operator functionProposition))
                 (not (description-mode?)))
        ;; tricky: descriptions flatten everything, and find unresolved
        ;;    references late in the game.  Assertions don't flatten, plus
        ;;    the arguments are not variables, so type propagation won't
        ;;    tighten the types.  Hence, we signal an undefined reference
        ;;    here instead of waiting if we are not in description mode:
        (complain-about-undeclared-reference functionProposition)
        (create-dummy-relation functionProposition))
      (return (last-argument functionProposition))) ))

(defun (extensional-individual? BOOLEAN) ((individual OBJECT))
  ;; Return true if `individual' has an extension.
  ;; Pattern variables and skolems without any propositions asserted
  ;;    about them (or their equivalents) are considered intensional.
  ;;    All other objects are considered to be extensional.
  ;; This test is used to determine whether a function proposition
  ;;    has any existential import or not.
  (typecase individual
    (PATTERN-VARIABLE
     (return FALSE))
    (SKOLEM
     (let ((definingProposition (defining-proposition individual)))
       (when (exists prop in (unfiltered-dependent-propositions individual NULL)
                     where (and (not (eql? prop definingProposition))
                                (true-proposition? prop)))
         (return TRUE)))
     (return
      (exists sk in (variable-value-inverse individual)
              where (extensional-individual? sk))))
    (otherwise
     (return TRUE))))

;;; WHAT ABOUT DEFAULTS??? (see also `equate-values')
(defun (function-with-defined-value? BOOLEAN) ((proposition PROPOSITION))
  ;; Return TRUE if `proposition' is a function proposition whose output
  ;;    value is defined (has an extension) in the current context.
  (when (not (eql? (kind proposition) :FUNCTION))
    (return FALSE))
  (let ((lastArgument (last (arguments proposition)))
        (result?
         (and (or (test-property?
                   (get-description (relationRef proposition)) PL-KERNEL/@TOTAL)
                  (extensional-individual? (value-of lastArgument))))))
    (when (and result?
               (not (world-state? *context*)))
      ;; if we are within an inference cache, cache the truth of this
      ;;     computation:
      (assign-truth-value proposition TRUE)
      ;; this is a good time to explicitly infer the type of the skolem:
      (typecase lastArgument
        (SKOLEM
         (when (defined? (skolem-type lastArgument))
           (special ((*evaluationMode* :EXTENSIONAL-ASSERTION)
                     (*invisibleAssertion?* TRUE))
             (assert-isa-proposition lastArgument (skolem-type lastArgument)))))
        (otherwise NULL)))
    (return result?) ))

(defun (create-enumerated-set SKOLEM) ((set LIST))
  ;; Create a proposition representing 'set' and return its output skolem.
  ;; We don't run this through the complete function-proposition machinery
  ;;    to avoid generating backlinks from all the set elements.
  (let ((setProp (begin-creating-function-proposition
                  PL-KERNEL/@SETOF (the-cons-list set)))
        (skolem (create-skolem PL-KERNEL/@SET NULL)))
    (setf (nth (arguments setProp) (length set)) skolem)
    (setf (defining-proposition skolem) setProp)
    (add-dependent-proposition-link skolem setProp)
    (setf (unfastened? setProp) NULL)
    (return skolem) ))

(defun (create-logical-list SKOLEM) ((list LIST))
  ;; Create a proposition representing the list 'list' and return its
  ;;    output skolem.
  ;; We don't run this through the complete function-proposition machinery
  ;;    to avoid generating backlinks from all the list elements.
  (let ((listProp (begin-creating-function-proposition
                   PL-KERNEL/@LISTOF (the-cons-list list)))
        (skolem (create-skolem PL-KERNEL/@LIST NULL)))
    (setf (nth (arguments listProp) (length list)) skolem)
    (setf (defining-proposition skolem) listProp)
    (add-dependent-proposition-link skolem listProp)
    (setf (unfastened? listProp) NULL)
    (return skolem) ))

(defun (logical-collection? BOOLEAN) ((self OBJECT))
  ;; Return TRUE if 'self' is a skolem representing a logical list or set.
  (typecase self
    (SKOLEM
     (let ((definingProposition (defining-proposition self)))
       (return (and (defined? definingProposition)
                    (collectionOf-proposition? definingProposition)))))
    (otherwise (return FALSE))))

(defun (skolem-defined-by-operator? BOOLEAN) ((self OBJECT) (operator SURROGATE))
  ;; Return TRUE if `self' is a skolem defined by a proposition headed by `operator'
  :globally-inline? TRUE
  (typecase self
    (SKOLEM
     (let ((definingProposition (defining-proposition self)))
       (return (and (defined? definingProposition)
                    (eql? (operator definingProposition) operator)))))
    (otherwise (return FALSE))))
    

(defun (enumerated-set? BOOLEAN) ((self OBJECT))
  ;; Return TRUE if 'self' is a skolem representing an enumerated set.
  (return (skolem-defined-by-operator? self PL-KERNEL/@SETOF)))

(defun (enumerated-list? BOOLEAN) ((self OBJECT))
  ;; Return TRUE if 'self' is a skolem representing an enumerated list.
  (return (skolem-defined-by-operator? self PL-KERNEL/@LISTOF)))


  ;;
;;;;;; Canonicalizing proposition trees
  ;;

(defun (canonicalize-proposition-tree OBJECT) ((tree OBJECT))
  ;; Perform any necessary canonicalization on `tree' before
  ;;    a proposition gets built.
  ;; This used to do various conversions to negation normal form
  ;;    but is superseded now by `normalize-proposition' and friends
  ;;    which directly operate on propositions.
  (return tree))


  ;;
;;;;;; Updating propositions
  ;;

(defun erase-proposition ((proposition PROPOSITION))
  ;; Called by 'help-update-top-level-proposition'
  ;; Delete all backpointers pointers to 'proposition' and mark
  ;;    it :DELETED.
  (foreach arg in (arguments proposition)
           where (defined? arg)
           do (remove-dependent-proposition-link arg proposition))
  (free (arguments proposition))
  (setf (arguments proposition) NULL)
  (setf (deleted? proposition) TRUE) )

(defun (update-equivalence-proposition PROPOSITION)
       ((proposition PROPOSITION) (updateMode KEYWORD))
  ;; Try to equate (or unequate) the arguments to 'proposition'.
  ;; If no explicit (de)equivalencing occurs, return 'proposition'
  ;;    (except for :RETRACT-TRUE, which never returns a proposition).
  (let ((term1 (first (arguments proposition)))
        (term2 (second (arguments proposition))))
    (when (and (skolem? term1)
               (skolem? term2))
      (when (eql? updateMode :PRESUME-TRUE)
        (signal-proposition-error
         "Equating two skolems by default is not yet supported." EOL))
      ;; tricky: we do nothing for the case of two skolems, under the
      ;;    assumption that forward propagation is the only proper 
      ;;    time to unify two skolems:
      (return proposition))
    ;; possibly bind/unbind a value-of link:
    (case updateMode
      ((:ASSERT-TRUE :PRESUME-TRUE)
       ;; We need the equivalence prop asserted here so `bind-skolem-to-value'
       ;;    will do the right thing.  Alternatively, we could handle this by
       ;;    passing an update mode to `bind-skolem-to-value', clip-value, etc.
       (update-proposition-truth-value proposition updateMode)
       (cond
        ;; NOTE: A default value is allowed to clip a strict value.
        ((clip-value? term1 term2) NULL)
        ((clip-value? term2 term1) NULL)
        (otherwise
         (equate-values (value-of term1) (value-of term2)))))
      (:RETRACT-TRUE
       (cond
        ((unequate-values? term1 term2) NULL)
        ((unequate-values? term2 term1) NULL)))
      (:CONCEIVE (return proposition)))
    ;; EXPERIMENT: To be able to print something reasonable for top-level
    ;;    assertions of function values, e.g, `(= (age Fred) 25)', we
    ;;    return the function proposition here instead of NULL:
    (when (and (function-output-skolem? term1)
               (not (function-output-skolem? term2)))
      (run-update-proposition-demon proposition updateMode)
      (return (choose (deleted? proposition)
		      NULL
		      (defining-proposition (cast term1 SKOLEM)))))
    (when (and (function-output-skolem? term2)
               (not (function-output-skolem? term1)))
      (run-update-proposition-demon proposition updateMode)
      (return (choose (deleted? proposition)
		      NULL
		      (defining-proposition (cast term2 SKOLEM)))))
    (return NULL) ))

(defun (skolemize-exists-proposition PROPOSITION)
       ((existsProposition PROPOSITION))
  ;; Skolemize `existsProposition' and return the result.
  ;; Delete `existsProposition' as a side-effect.
  ;; We use `inherit-proposition' to properly re-evaluate surrogate
  ;;    constants, since some of them might have moved outside of
  ;;    "description-mode".
  (let ((mapping (new ENTITY-MAPPING))
        (skolemizedProposition PROPOSITION NULL))
    (foreach var in (io-variables existsProposition)
        do (create-skolem-for-unmapped-variable var mapping))
    (setq skolemizedProposition
      ;; Fastening will also establish newly necessary backlinks:
      (recursively-fasten-down-propositions
       (inherit-proposition (first (arguments existsProposition)) mapping)
       FALSE))
    (erase-proposition existsProposition)
    (return skolemizedProposition)))

(defun (help-update-top-level-proposition (CONS OF PROPOSITION))
       ((proposition PROPOSITION) (updateMode KEYWORD))
  ;; Called by 'update-top-level-proposition'.  'updateMode' is either
  ;;    :ASSERT-TRUE or :RETRACT-TRUE.
  ;; Distribute and/or optimize updates depending on 'updateMode' and
  ;;    'proposition'.
  ;; :AND proposition is turned into multiple propositions.
  ;; :EQUIVALENT proposition may be converted into an attribute assignment
  ;; :NOT proposition is converted into ASSERT-FALSE of argument.
  ;; variables in top-level :EXISTS are converted into skolems
  (when (null? proposition)
    (return NULL))
  (when (eql? (lookup-annotation proposition :CONFIDENCE-LEVEL) :DEFAULT)
    (setq updateMode (defaultify-update-mode updateMode))
    ;; only remove annotation if we really are generating a default assertion:
    (when (or (eql? updateMode :PRESUME-TRUE)
              (eql? updateMode :PRESUME-FALSE))
      (remove-annotation proposition :CONFIDENCE-LEVEL)))
  (when (native-slot-proposition? proposition)
    (return (update-native-slot-proposition proposition updateMode)))
  (special ((*context* (get-top-level-update-context)))
   (case (kind proposition)
     (:AND                             ; sometimes eliminate top-level AND:
      (let ((propositions NIL))
        (foreach arg in (arguments proposition)
            do (foreach p in (help-update-top-level-proposition arg updateMode)
		   where (and (defined? p) (not (deleted? p)))
                   collect p into propositions))
        (erase-proposition proposition)
        (return propositions)))
     (:EQUIVALENT
      (setq proposition (update-equivalence-proposition proposition updateMode))
      (when (null? proposition)
        (return NIL)))
     (:NOT                             ; eliminate top-level NOT:
      (let ((argument (first (arguments proposition))))
        (case updateMode
          ((:ASSERT-TRUE :ASSERT-FALSE
            :PRESUME-TRUE :PRESUME-FALSE
            :RETRACT-TRUE :RETRACT-FALSE)
           (update-proposition-truth-value
            argument (invert-update-mode updateMode))
           (erase-proposition proposition)
           ;; THIS IS PROBLEMATIC, SINCE WE ARE RETURNING THE WRONG
           ;;    PROPOSITION.  CONSIDER ADDING A PARAMETER THAT ASKS
           ;;    FOR A LIST BACK, AND OVERRIDES :NOT ELIMINATION:
	   (if (and (defined? argument) (not (deleted? argument)))
	       (return (cons-list argument))
	       (return NIL)))
          (otherwise NULL))))
     (:EXISTS
      (return
       (help-update-top-level-proposition
        (skolemize-exists-proposition proposition) updateMode)))
     (otherwise NULL))
   (when (not (eql? (kind proposition) :FUNCTION))
     (update-proposition-truth-value proposition updateMode))
   (if (deleted? proposition)
       (return NIL)
       (return (cons-list proposition))) ))

(defun (invert-update-mode KEYWORD) ((updateMode KEYWORD))
  ;; Return the inversion of `updateMode'.
  (case updateMode
    (:ASSERT-TRUE (return :ASSERT-FALSE))
    (:PRESUME-TRUE (return :PRESUME-FALSE))
    (:RETRACT-TRUE (return :RETRACT-FALSE))
    (:ASSERT-FALSE (return :ASSERT-TRUE))
    (:PRESUME-FALSE (return :PRESUME-TRUE))
    (:RETRACT-FALSE (return :RETRACT-TRUE))))

(defun (defaultify-update-mode KEYWORD) ((updateMode KEYWORD))
  ;; Return the default-truth version of `updateMode' or `updateMode'
  ;;    if it doens't have a default version.
  (case updateMode
    (:ASSERT-TRUE (return :PRESUME-TRUE))
    (:ASSERT-FALSE (return :PRESUME-FALSE))
    (otherwise (return updateMode))))

(defun (update-top-level-proposition (CONS OF PROPOSITION))
       ((tree OBJECT) (updateMode KEYWORD))
  ;; Distribute and/or optimize updates depending on 'updateMode' and
  ;;    'proposition'.
  (case updateMode
    ((:ASSERT-FALSE :PRESUME-FALSE :RETRACT-FALSE)
     (setq tree (bquote (not & tree)))
     (setq updateMode (invert-update-mode updateMode)))
    (otherwise NULL))
  (case updateMode
    (:ASSERT-TRUE
     (special ((*automaticInstanceTable* NULL))
      (return
       (help-update-top-level-proposition 
        (build-top-level-proposition tree TRUE) updateMode))))
    (otherwise
     (return
      (help-update-top-level-proposition 
       (build-top-level-proposition tree FALSE) updateMode)))) )

(defun (standardize-proposition-tree OBJECT) ((tree OBJECT))
  ;; Standardize (e.g., KIF-translate) and canonicalize the propostion
  ;;    tree `tree' and return the result.  If `tree' is a string,
  ;;    unstringify first and then standardize.
  (when (string? tree)
    ;; Support string representations of propositions - these might be
    ;;    easier to produce by some external non-STELLA callers:
    (setq tree (unstringify tree)))
  ;; do KIF translation and other preprocessing (e.g., symbols to surrogates):
  (setq tree (standardize-logical-parse-tree tree))
  (when (cons? tree)
    (setq tree
      ;; THIS IS ALMOST OBSOLETE, WE PROBABLY COULD AVOID THE COUPLE
      ;; OF GLITCHES THAT REMAIN BY IMPROVING `NORMALIZE-PROPOSITION':
      (canonicalize-proposition-tree tree)))
  (return tree))

(defun (update-proposition (CONS OF PROPOSITION)) ((tree OBJECT)
                                                   (updateMode KEYWORD))
  ;; Assert, retract, or deny the proposition 'tree'.
  ;; Inference note: By eliminating a top-level NOT operator before
  ;;    passing 'tree' to 'build-top-level-proposition', we make
  ;;    it simpler to exploit the 3-value logic as an alternative to
  ;;    explicit placement of NOT propositions.
  (exception-case 
      ;; prevent finalization in the middle of an update:
      (special ((*inhibitObjectFinalization?* TRUE))
        (return
          (update-top-level-proposition
           (standardize-proposition-tree tree)
           updateMode)))
    (LOGIC-EXCEPTION (e)
      (print-stream STANDARD-ERROR (exception-message e)))
    (READ-EXCEPTION (e)
      (print-stream STANDARD-ERROR (exception-message e))))
  ;; return after error:
  (return NULL))

(defun (build-top-level-term OBJECT) ((tree OBJECT))
  ;; Return a term representing (the already pre-parsed)'tree'.
  (let ((term OBJECT NULL))
    (special ((*logicVariableTable* NIL)
              (*variableIdCounter* 0)
              (*termUnderConstruction* tree))
      (typecase tree
        (CONS
         ;; trap sentences posing as terms:
         (when (member? (quote (FORALL EXISTS IMPLIES AND OR NOT))
                        (first tree))
           (warn "Sentence where term expected: " tree EOL)
           (return NULL)))
        (otherwise NULL))
      (setq term (evaluate-term tree)))
    (return term) ))

(defun (conceive-term OBJECT) ((tree OBJECT))
  :documentation "`tree' is a term expression (a string or an s-expression),
or is a class reference (a symbol or surrogate).  Return a (possibly 
newly-conceived) term representing the internalized representation of that term."
  :public? TRUE :command? TRUE :evaluate-arguments? TRUE :lisp-macro? FALSE
  (exception-case 
      (let ((standardizedTree (standardize-proposition-tree tree))
            (operator OBJECT NULL)
            (term OBJECT NULL))
        (when (cons? standardizedTree)
          (setq operator (first (cast standardizedTree CONS))))
        (if (and (defined? operator)
                 (defined? (get-relation operator))
                 (not (function? (get-relation operator))))
          ;; should have called 'conceive-sentence' in the first place:
          (setq term (conceive-sentence tree))
          (setq term (build-top-level-term standardizedTree)))
        (return term))
   (LOGIC-EXCEPTION (e)
      (print-stream STANDARD-ERROR (exception-message e)))
   (READ-EXCEPTION (e)
     (print-stream STANDARD-ERROR (exception-message e))))
  ;; return after error:
  (return NULL) )

(defun (conceive-sentence OBJECT) ((tree OBJECT))
  ;; Create a proposition representing 'tree'.
  (typecase tree
    (STRING (return (conceive-sentence (unstringify tree))))
    (otherwise (return (smart-update-proposition tree :CONCEIVE)))) )

(defun (conceive-formula OBJECT) ((tree OBJECT))
  ;; Guess whether 'tree' is a sentence or a term, and return
  ;;    a conceived version of it.
  (typecase tree
    (STRING (return (conceive-formula (unstringify tree))))
    (CONS
     (when (symbol? (first tree))
       (case (first tree)
         ((KAPPA LAMBDA SETOFALL PL-KERNEL/SETOF PL-KERNEL/LISTOF BAGOF)
          (return (conceive-term tree)))
         (otherwise NULL)))
     (return (conceive-sentence tree)))
    (SYMBOL
     (return (conceive-term tree)))
    (SURROGATE
     (return (conceive-term (surrogate-to-symbol tree))))
    (otherwise
     ;; PROBABLY COULD BE A BIT SMARTER HERE: -rmm
     (return (conceive-sentence tree)))) )


  ;;
;;;;;; Update proposition commands
  ;;

(defun (smart-update-proposition OBJECT) ((tree OBJECT) (updateMode KEYWORD))
  ;; Just like `update-proposition', but returns a single proposition
  ;;    rather than a singleton list.
  (let ((propositions (update-proposition tree updateMode)))
    (if (and (defined? propositions)
             (empty? (rest propositions)))
      (return (first propositions))
      (return propositions)) ))

(defun (assert OBJECT) ((proposition PARSE-TREE))
  :documentation
  "Assert the truth of `proposition'.  Return the asserted proposition object.
KIF example:  \"(assert (happy Fred))\" asserts that Fred is indeed happy.
Note that for this assertion to succeed, the relation `happy' must already
be defined.  If the constant `Fred' has not yet been created, it is
automatically created as a side-effect of calling `assert'."
  :public? TRUE :command? TRUE :evaluate-arguments? FALSE
  (return (smart-update-proposition proposition :ASSERT-TRUE)))

(defun (presume OBJECT) ((proposition PARSE-TREE))
  :documentation
  "Presume the default truth of `proposition'.  Return the presumed
proposition object.  KIF example:  \"(presume (happy Fred))\" states that Fred
is most probably happy.  Note, that for this to succeed, the relation
`happy' must already be defined (see `assert')."
  :public? TRUE :command? TRUE :evaluate-arguments? FALSE
  (return (smart-update-proposition proposition :PRESUME-TRUE)))

(startup-time-progn
  ;; handle conflict with STL macro (lib.assertions):
  (register-native-name (quote assert) :cpp :function))

(defun (retract OBJECT) ((proposition PARSE-TREE))
  :documentation
  "Retract the truth of `proposition'.  Return the retracted proposition
object.  KIF example:  \"(retract (happy Fred))\" retracts that Fred is
happy.  Note that for this assertion to succeed, the relation `happy' must already
be defined.  If the constant `Fred' has not yet been created, it is
automatically created as a side-effect of calling `retract'."
  :public? TRUE :command? TRUE :evaluate-arguments? FALSE
  (return (smart-update-proposition proposition :RETRACT-TRUE)))

(defun (deny OBJECT) ((proposition PARSE-TREE))
  :documentation
  "Assert the falsity of `proposition'.  Return the asserted proposition
object.  KIF example:  \"(deny (happy Fred))\" asserts that Fred is not happy,
which could have been done equivalently by \"(assert (not (happy Fred)))\".
Note, that for this to succeed, the relation `happy' must already be defined
(see `assert')."
  :public? TRUE :command? TRUE :evaluate-arguments? FALSE
  (return (smart-update-proposition proposition :ASSERT-FALSE)))

(defun (conceive OBJECT) ((formula PARSE-TREE))
  :documentation
  "Guess whether 'formula' represents a term or a sentence/proposition.
If we are not sure, assume its a proposition.
If its, a term, return its internal representation.  If a proposition,
construct a proposition for 'formula' without asserting its truth value.
Return the conceived proposition object.  KIF example: \"(conceive (happy Fred))\"
builds the proposition expressing that Fred is happy without explictly asserting
or denying it.  Note, that for this to succeed, the relation `happy' must already
be defined (see `assert').  If the logic constant `Fred' has not yet been
created, it is automatically created as a side-effect of calling `conceive'."
  :public? TRUE :command? TRUE :evaluate-arguments? FALSE
  (return (conceive-formula formula)) )

(defun (unassert OBJECT) ((proposition PARSE-TREE))
  :documentation
  "Retract the truth, falsity or inconsistency of `proposition'.  This is a
more general version of `retract' that also handles falsity.  For example, if
we assert the proposition \"(not (sad Fred))\", and then execute the statement
\"(unassert (sad Fred))\", the truth value of the proposition \"(sad Fred)\"
will be set to UNKNOWN.  If we had called `retract' in place of `unassert',
the proposition \"(sad Fred)\" would remain set to FALSE.   Note that for this
unassertion to succeed, the logic constant `Fred' and the relation `sad' must
already be defined."
  :public? TRUE :command? TRUE :evaluate-arguments? FALSE
  (let ((parsedProps (update-proposition proposition :CONCEIVE))
        (result NIL))
    (when (defined? parsedProps)
      (foreach prop in parsedProps
          do (when (eql? (kind prop) :NOT)
               (setq prop (first (arguments prop))))
             (unassert-proposition prop)
          collect prop into result))
    (return (choose (> (length result) 1) result (first result)))))

;;;;;; MAYBE USE HELP-UPDATE-TOP-LEVEL-PROPOSITION HERE TO BE MORE GENERAL?
(defun unassert-proposition ((self PROPOSITION))
  :documentation
  "Retract the truth, falsity or inconsistency of the proposition `self'."
  :public? TRUE
  (when (defined? self)
    (let ((equivalence? (eql? (kind self) :EQUIVALENT)))
      (cond
       ((true? self)
        (if equivalence?
            (update-equivalence-proposition self :RETRACT-TRUE)
          (update-proposition-truth-value self :RETRACT-TRUE)))
       ((false? self)
        (if equivalence?
            (update-equivalence-proposition self :RETRACT-FALSE)
          (update-proposition-truth-value self :RETRACT-FALSE)))
       ((inconsistent? self)
        (cond (equivalence?
               (deassign-truth-value self :RETRACT-INCONSISTENT)
               (update-equivalence-proposition self :RETRACT-TRUE)
               (update-equivalence-proposition self :RETRACT-FALSE))
              (otherwise
               (deassign-truth-value self :RETRACT-INCONSISTENT)
               ;; these are really no-ops but left here for symmetry:
               (update-proposition-truth-value self :RETRACT-TRUE)
               (update-proposition-truth-value self :RETRACT-FALSE))))))))


  ;;
;;;;;; Destruction of propositions and instances
  ;;

(defmethod (deleted? BOOLEAN) ((self PROPOSITION))
  ;; Return TRUE if 'self' has been deleted.
  (return (deleted-proposition? self)))

(defmethod (deleted?-setter BOOLEAN) ((self PROPOSITION) (value BOOLEAN))
  ;; If 'value' is TRUE, mark 'self' as deleted (for good).
  (when value
    (setf (kind self) :DELETED))
  (return value))

(defun (deleted-proposition? BOOLEAN) ((self PROPOSITION))
  ;; Called by 'remove-if'.
  (when (eql? (kind self) :DELETED)
    (return TRUE))
  #|
  ;; don't do this, it doesn't gain us that much but can cause very strange
  ;; bugs, since sub-propositions that might have been conceived while in
  ;; an inference cache might unexpectedly be deleted by this function
  ;; when the proposition gets printed somewhere, etc.  Instead, implement
  ;; proper cleanup functions that utilize the new *structured-objects-index*
  ;; which allows us to find all propositions asserted or inferred.
  (when (and (defined? (home-context self))
             ;; hand-inline `deleted?' method, since this is called
             ;; often in `select-relation-propositions':
             (discarded-context? (home-context self)))
    ;; Somebody deleted the home-context of the proposition which must have
    ;;    been a hypothetical or forward-chaining world; fully delete it now.
    ;; QUESTION: SHOULD WE ADD A LOCALLY-CONCEIVED-PROPOSITIONS SLOT TO WORLDS,
    ;;    SINCE NOT ALL PROPOSITIONS CONCEIVED IN A WORLD ARE REACHABLE VIA
    ;;    LOCALLY CONCEIVED INSTANCES UPON WORLD DESTRUCTION?
    (setf (home-context self) NULL)
    ;; don't do full-scale destruction here, since that causes inference
    ;; caches to be wiped out which can cause computations that don't
    ;; expect that to fail (e.g., `all-facts-of-instance').  Another
    ;; solution to this is to always conceive propositions in modules
    ;; and never in worlds.
    ;(destroy-proposition self)
    (setf (kind self) :DELETED)
    (return TRUE))
  |#
  (return FALSE))

(defun (destroy-proposition PROPOSITION) ((proposition PROPOSITION))
  :documentation "Retract and destroy the proposition 'proposition'.
Recursively destroy all propositions that reference 'proposition'.
Also, destroy all satellite propositions of 'proposition'."
  (when (deleted? proposition)
    (return proposition))
  ;; immediately mark it deleted so that nothing will backtrack onto it:
  (setf (deleted? proposition) TRUE)
  ;; remove pointer from surrogate:
  (when (defined? (surrogate-value-inverse proposition))
    (setf (surrogate-value (surrogate-value-inverse proposition)) NULL))
  ;; remove backlinks from arguments:
  (foreach arg in (arguments proposition)
           where (and (defined? arg)
                      (not (deleted? arg)))
           do
           ;; if 'proposition' is a defining proposition for a skolem,
           ;;    eliminate the skolem:
           (when (and (skolem? arg)
                      (eql? (defining-proposition (cast arg SKOLEM)) proposition))
             (destroy-term arg))
           (remove-dependent-proposition-link arg proposition))
  ;; recursively destroy dependent propositions:
  (foreach dep in (copy (dependent-propositions proposition))
           do (destroy-proposition dep)) 
  ;; destroy satellites:
  ;; tricky: copy the satellites list because the satellites destructively
  ;;    modify it as they are destroyed:
  (foreach satellite in (copy (satellite-propositions proposition))
           do (destroy-proposition satellite))
  (when (defined? (master-proposition proposition))
    (remove (satellite-propositions (master-proposition proposition))
            proposition))
  ;; let inference caches know of the "retraction" (if the context is NULL,
  ;;    we must have had world deletion that didn't propagate to this proposition,
  ;;    since it didn't reference locally conceived instances):
  (unless (null? (home-context proposition))
    (handle-out-of-date-inference-cache :RETRACT proposition))
  ;; Cleanup various slots:
  (setf (dependent-propositions proposition) NULL)
  (setf (operator proposition) NULL)
  (setf (arguments proposition) NULL)
  (setf (home-context proposition) NULL)
  (setf (slot-value proposition truth-value :context-sensitive? FALSE) NULL)
  (setf (dynamic-slots proposition) NULL)
  (return proposition) )

(defun destroy-logic-instance ((self OBJECT))
  ;; Helping function for 'destroy-term'.  Destroy all propositions
  ;;    that reference 'self' and mark it as deleted?  Don't call
  ;;    this directly  because it leaves dangling references to
  ;;    descriptions (i.e., it only works for 'ordinary' instances.
  (typecase self
    ((LOGIC-OBJECT THING)
     (when (or (null? self)
               (deleted? self))
       (return))
     (setf (deleted? self) TRUE)
     (safety 3 (deleted? self) "OOPS:  BUG IN DELETED? MARK")
     ;; detach from surrogate IF the surrogate points at 'self':
     (let ((surrogate (surrogate-value-inverse self)))
       (when (and (defined? surrogate)
                  (eql? (surrogate-value surrogate) self))
         (setf (surrogate-value surrogate) NULL)))))
  (foreach p in (unfiltered-dependent-propositions self NULL)
      do (destroy-proposition p))
  (typecase self
    (LOGIC-OBJECT
     ;; detach from equivalents:
     (unlink-equivalent-value self)
     (foreach equivalent in (variable-value-inverse self)
         where (not (deleted? equivalent))
         do (typecase equivalent
              (SKOLEM
               (setf (variable-value equivalent) NULL))
              (LOGIC-OBJECT
               (setf (equivalent-value equivalent) NULL))))
     (setf (variable-value-inverse self) NULL))
    (otherwise NULL)) )

(defun destroy-term ((self LOGIC-OBJECT))
  :documentation "Destroy all propositions that reference 'self',
and mark it as 'deleted?', thereby making it invisible within class
extensions.  Unlink descriptions from native relations."
  :public? TRUE
  (when (or (null? self)
            (deleted? self))
    (return))
  (destroy-logic-instance self)
  (typecase self
    (DESCRIPTION
     (typecase self
       (NAMED-DESCRIPTION
        (let ((nativeRelation (native-relation self)))
          (setf (native-relation self) NULL)
          (when (defined? nativeRelation)
            ;; Unlink it from its native relation:
            (setf (description nativeRelation) NULL))
          (when (defined? (extension self))
            (setf (extension self) NULL))))
       (otherwise NULL))
     (let ((complement (relative-complement self)))
       (when (defined? complement)
         (setf (relative-complement complement) NULL)
         (setf (relative-complement self) NULL)))
     ;; Cleanup various slots:
     (remove-all-dependent-proposition-links self)
     (setf (io-variables self) NULL)
     (setf (internal-variables self) NULL)
     (setf (proposition self) NULL)
     (setf (home-context self) NULL))
    (otherwise NULL))
  (clear (dynamic-slots self))
  ;; set the flag again, in case it was stored as a dynamic slot:
  (setf (deleted? self) TRUE))

(defun destroy-instance ((self OBJECT))
  :public? TRUE
  :documentation "Destroy all propositions that reference 'self',
and mark it as 'deleted?', thereby making it invisible within class
extensions."
  (typecase self
    (LOGIC-OBJECT (destroy-term self))
    (THING (destroy-logic-instance self))) )

(defun destroy-object ((self OBJECT))
  :public? TRUE
  :documentation
  "Destroy `self' which can be a term or a proposition.  Destroy all
propositions that reference 'self' and mark it as 'deleted?' (thereby
making it invisible within class extensions)."
  (typecase self
    (LOGIC-OBJECT (destroy-term self))
    (THING (destroy-logic-instance self))
    (PROPOSITION (destroy-proposition self))))


(defun (destroy OBJECT) ((objectSpec PARSE-TREE))
  :public? TRUE :command? TRUE :evaluate-arguments? FALSE
  :documentation
  "Find an object or proposition as specified by `objectSpec', and destroy all
propositions and indices that reference it.  `objectSpec' must be a name or
a parse tree that evaluates to a proposition.  Return the deleted object, or
NULL if no matching object was found."
  (let ((object OBJECT NULL))
    (typecase objectSpec
      (CONS
       ;; for propositions we always create the object, since it is too much
       ;;    work to try to figure out whether it already existed or not:
       (setq object (conceive-formula objectSpec)))
      (otherwise
       (setq object
         (coerce-to-instance-in-module objectSpec NULL FALSE NULL))))
    (when (defined? object)
      (destroy-object object))
    (return object)))

(defun (relation-in-module? BOOLEAN) ((self NAMED-DESCRIPTION))
  ;; Helping function for 'clear-logic-module-hook'.
  ;; Return TRUE if 'self' is defined in the module *module*.
  (return (eql? (home-context self) *module*)) )

(defun introduce-module ((module MODULE))
  :public? TRUE
  ;; Hook function called by 'define-module'.
  ;; Bind a surrogate to module and assert it into the extension of
  ;;    the class MODULE.
  ;; TEMPORARY UNTIL defclass THING GOES INTO STELLA.
  ;;    WRITE 'NULL' OVER INITIAL 'unbound' VALUE:
  (setf (surrogate-value-inverse module) NULL)
  (within-context *pl-kernel-module*
    (when (null? (surrogate-value-inverse module))
      (mv-bind (success? unused surrogate)
	  (bind-to-surrogate? module (name module) TRUE TRUE)
	(ignore unused)
	(when success?
	  (setf (surrogate-value-inverse module) surrogate))))
    (assert-isa-proposition module STELLA/@MODULE)) )

(startup-time-progn
  (add-hook *define-module-hooks* (quote introduce-module)))

(defun clear-logic-module-hook ((module MODULE))
  ;; Hook function called by 'clear-context/module'.
  ;; Destroy all propositions and terms associated with 'module'
  ;;    and any of its children.
  (within-module module
    (destroy-inference-caches module)
    (flush-inline-query-caches)
    (foreach term in (listify (all-terms module TRUE))
             do (destroy-instance term))
    (foreach proposition in (all-propositions module TRUE)
        do (destroy-proposition proposition))
    (cleanup-structured-objects-index module)
    (remove-deleted-members (locally-conceived-propositions module))
    (remove-deleted-members (locally-conceived-instances module))
    (cleanup-all-description-extensions)
    (cleanup-unfinalized-objects)
    ;; Clear memoization tables so we won't hold on to deleted objects
    ;;    (unfortunately, this will also cost us some still valid values):
    (clear-memoization-tables :KB-UPDATE)
    (clear-memoization-tables :META-KB-UPDATE)))

(startup-time-progn
  (add-hook *clear-module-hooks* (quote clear-logic-module-hook)))

(defun clear-instances (&rest (name NAME))
  :public? TRUE :command? TRUE :evaluate-arguments? FALSE
  :documentation
  "Destroy all instances belonging to module `name' or any of its children.
Leave meta-objects, e.g., concepts and relations, alone.
If no `name' is supplied, the current module will be cleared after
confirming with the user."
  (let ((optionalName (coerce-&rest-to-cons name)) 
        (module (coerce-to-module (first optionalName) TRUE)))
    (when (defined? module)
      (when (or (non-empty? optionalName)
                (y-or-n? (concatenate
                           "Really clear instances of module "
                           (concatenate (module-full-name module) "? "))))
        (do-clear-instances module)))))

(defun do-clear-instances ((module MODULE))
  :documentation
  "Function version of `clear-instances' that evaluates its argument."
  :public? TRUE
  (foreach child in (child-contexts module)
      where (isa? child @MODULE)
      do (do-clear-instances child))
  (within-module module
    (destroy-inference-caches module)             
    (foreach instance in (all-instances module TRUE)
        do (destroy-instance instance))
    ;; Do some housekeeping:
    (remove-deleted-members (locally-conceived-propositions module))))

(defun destroy-logic-context-hook ((self CONTEXT))
  ;; Clear instances belonging to 'self'.
  ; make 'handle-out-of-date-inference-cache' shut up:
  (setf (monotonic? self) FALSE)
  (within-context self
     (foreach i in (locally-conceived-instances self)
         do (destroy-term i)))
  (when (isa? self @MODULE)
    (clear-logic-module-hook self)
    (setf (surrogate-value (surrogate-value-inverse self)) NULL))
  (when (isa? self @WORLD)
    (unlink-inference-cache self)) )

(startup-time-progn
  (add-hook *destroy-context-hooks* (quote destroy-logic-context-hook)))

(defun clear-caches ()
  :documentation "Clear all query and memoization caches."
  :public? TRUE :command? TRUE
  (clear-query-results-cache)
  (clear-all-memoization-tables))

(defun reset-powerloom ()
  :documentation "Reset PowerLoom to its initial state.
CAUTION: This will destroy all loaded knowledge bases and might break other
loaded STELLA systems if they do reference PowerLoom symbols in their code."
  :public? TRUE :command? TRUE
  (within-module *stella-module*
    (let ((modules (LIST OF MODULE)
                   (list (get-stella-module "PLI" TRUE)
                         *pl-anonymous-module*
                         *pl-kernel-module*
                         *logic-module*)))
      (foreach mod in modules
          do (setf (clearable? mod) TRUE)
             (setf (protect-surrogates? mod) FALSE)
             (foreach sub in (all-subcontexts mod :preorder)
                 do (typecase sub
                      (MODULE
                       (setf (clearable? sub) TRUE)
                       (setf (protect-surrogates? sub) FALSE))
                      (otherwise NULL))))
      ;; clears recursively:
      (foreach mod in modules
          do (clear-context mod))
      (drop-hook *define-module-hooks* (quote introduce-module))
      (drop-hook *clear-module-hooks* (quote clear-logic-module-hook))
      (drop-hook *destroy-context-hooks* (quote destroy-logic-context-hook))
      (drop-hook *redefine-relation-hooks*
                 (quote transfer-logic-information-from-relation-hook))
      ;; destroys recursively:
      (foreach mod in modules
          do (destroy-module mod))
      (setq *pl-kernel-module* NULL)
      (setq *logic-module* NULL)
      (clear-all-memoization-tables)
      (startup-logic-system)))
  (change-module (get-stella-module "PL-USER" TRUE)))


;;;;; SORTING PREDICATES

(defun (cons-less-than? BOOLEAN) ((o1 CONS) (o2 CONS))
  (foreach i1 in o1
      as i2 in o2
      do (when (logic-form-less? i1 i2)
	   (return true))
	 (when (logic-form-less? i2 i1)
	   (return false)))
  (return (< (length o1) (length o2))))

(defun (safe-string-less? BOOLEAN) ((s1 string) (s2 string))
  ;; Compares the strings `s1' and `s2', correctly handling `null' values.
  (cond ((and (defined? s1) (defined? s2))
         (return (string-less? s1 s2)))
        ((defined? s2)
         (return FALSE))
        (otherwise
         (return TRUE))))

(defun (safe-quantity-less? BOOLEAN) ((q1 QUANTITY) (o2 OBJECT))
  ;; Compares `q1' and `o2', handling `null' and incompatible values.
  (cond ((and (defined? q1) (defined? o2))
         (exception-case 
              (return (less? q1 o2))
           (INCOMPATIBLE-QUANTITY-EXCEPTION ()
              (return FALSE))))
        ((defined? o2)
         (return FALSE))
        (otherwise
         (return TRUE))))

(defun (safe-quantity-greater-equal? BOOLEAN) ((q1 QUANTITY) (o2 OBJECT))
  ;; Compares `q1' and `o2', handling `null' and incompatible values.
  (cond ((and (defined? q1) (defined? o2))
         (exception-case 
              (return (greater-equal? q1 o2))
           (INCOMPATIBLE-QUANTITY-EXCEPTION ()
              (return FALSE))))
        ((defined? o2)
         (return FALSE))
        (otherwise
         (return TRUE))))

(defun (object-name-less-than? BOOLEAN) ((o1 LOGIC-OBJECT) (o2 LOGIC-OBJECT))
  (return (safe-string-less? (object-name o1) (object-name o2))))

(defun (module-name-less-than? BOOLEAN) ((m1 CONTEXT) (m2 CONTEXT))
  (return (safe-string-less? (context-name m1) (context-name m2))))

(defun (proposition-less-than? BOOLEAN)  ((p1 PROPOSITION) (p2 PROPOSITION))
  ;; Compares two propositions, place by place.  Shorter propositions will
  ;; sort ahead of longer ones that share the same prefix.
  (when (string-less? (symbol-name (operator p1)) (symbol-name (operator p2)))
    (return true))
  (when (string-less? (symbol-name (operator p2)) (symbol-name (operator p1)))
    (return false))
  (foreach a1 in (arguments p1)
      as a2 in (arguments p2)
      do (if (logic-form-less? a1 a2)
	     (return true)
	   (when (logic-form-less? a2 a1)
	     (return false))))
  (return (< (length (arguments p1))
	     (length (arguments p2)))))

(defun (proposition-head-sort-string STRING) ((p PROPOSITION))
  (case (kind p)
    (:IMPLIES
     (if (and (isa? (nth (arguments p) 0) @DESCRIPTION)
	      (isa? (nth (arguments p) 1) @DESCRIPTION))
	 (return "FORALL") ; { is 1 past #\z   was: (return "FORALL")
       (return "SUBSET-OF")))
    (otherwise
     (return (symbol-name (operator p))))))

(defun (object-sort-string STRING) ((o OBJECT))
  ;; Return a string for lexocographic sorting of `o'
  (when (null? o)
    (return "NULL"))
  (typecase o
    ((INTEGER-WRAPPER FLOAT-WRAPPER)
     (return (stringify o)))
    (BOOLEAN-WRAPPER
     (cond ((eq? o FALSE-WRAPPER) (return "FALSE"))
	   ((eq? o TRUE-WRAPPER) (return "TRUE"))
	   (otherwise (return "UNKNOWN"))))
    (STRING-WRAPPER
     (return (wrapper-value o)))
    (MUTABLE-STRING-WRAPPER
     (return (wrapper-value o)))
    (GENERALIZED-SYMBOL
     (return (symbol-name o)))
    (SKOLEM
     (let ((val (variable-value o)))
       (if (or (null? val) (eql? val o))
         (return (stringify o))
         (return (object-sort-string (variable-value o))))))
    (LOGIC-OBJECT ;NAMED-DESCRIPTION
     (return (object-string-name o)))
    (CONTEXT
     (return (context-name o)))
    (/PL-KERNEL-KB/COMPUTED-PROCEDURE
     (return (symbol-name (surrogate-value-inverse o))))
    (otherwise
     ;; This allows extensibility while still warning us of missing
     ;; types that are present in the LOGIC module itself.
     (when (eql? (home-module (primary-type o)) *logic-module*)
       (warn "OBJECT-SORT-STRING: Doesn't specifically handle object " o " yet!"))
     ; Should this use GENERATE-TERM?
     (return (stringify o)))
    ))
		     
(defun (logic-form-less? BOOLEAN) ((o1 OBJECT) (o2 OBJECT))
  :PUBLIC? TRUE
  :DOCUMENTATION "A sorting predicate for objects `o1' and `o2' that can appear in logical
forms.  Performs a combined numeric and lexocographic sort that accounts
for lists, collections and propositions.  Numbers precede all other values,
`null' follows all other values."

  ;; Quick test for equality:
  (when (eq? o1 o2)
    (return FALSE))

  ;; Handle skolems:
  ;; NOTE: THERE IS A POTENTIAL INFINITE RECURSION HERE, BUT I THINK
  ;;       THE EQUALITY TEST ABOVE STOPS IT FROM HAPPENING.  IT CAN COME
  ;;       ABOUT IF THE DEFINING PROPOSITION OF BOTH OBJECTS EVALUATES TO
  ;;       A PROPOSITION THAT HAS THE FUNCTION OUTPUT SKOLEM IN IT (AS IN
  ;;       SET DEFINITIONS, BUT THEN EITHER SOME ARGUMENT MUST BE DIFFERENT
  ;;       OR THE SKOLEM TERMS SHOULD BE THE SAME.  - tar 3-Jan-2006
  (when (isa? o1 @SKOLEM)
    (let ((value (variable-value (cast o1 @SKOLEM))))
      (if (and (null? value)
               (function-output-skolem? o1))
          (setq o1 (defining-proposition (cast o1 @SKOLEM)))
        (setq o1 value))))
  (when (isa? o2 @SKOLEM)
    (let ((value (variable-value (cast o2 @SKOLEM))))
      (if (and (null? value)
               (function-output-skolem? o2))
          (setq o2 (defining-proposition (cast o2 @SKOLEM)))
        (setq o2 value))))

  ;; Handle Nulls
  (when (null? o1)
    (return false))
  (when (null? o2)
    (return true))  

  ;; Handle more general cases.
  (typecase o1
    (INTEGER-WRAPPER
     (typecase o2
       (INTEGER-WRAPPER
	(return (< (wrapper-value o1) (wrapper-value o2))))
       (FLOAT-WRAPPER
	(return (< (wrapper-value o1) (wrapper-value o2))))
       (QUANTITY-LOGIC-WRAPPER
        (return (not (safe-quantity-greater-equal? (wrapper-value o2) o1))))
       (otherwise
	(return true))))
    (FLOAT-WRAPPER
     (typecase o2
       (INTEGER-WRAPPER
	(return (< (wrapper-value o1) (wrapper-value o2))))
       (FLOAT-WRAPPER
	(return (< (wrapper-value o1) (wrapper-value o2))))
       (QUANTITY-LOGIC-WRAPPER
        (return (not (safe-quantity-greater-equal? (wrapper-value o2) o1))))
       (otherwise
	(return true))))
    (QUANTITY-LOGIC-WRAPPER
     (typecase o2
       (QUANTITY-LOGIC-WRAPPER
        (return (safe-quantity-less? (wrapper-value o1) (wrapper-value o2))))
       (NUMBER-WRAPPER
        (return (less? (wrapper-value o1) o2)))
       (otherwise
        (return true))))
    (PROPOSITION
     (typecase o2
       (PROPOSITION 
	(return (proposition-less-than? o1 o2)))
       (NAMED-DESCRIPTION 
	(return (string-less? (proposition-head-sort-string o1)
			      (object-sort-string o2))))
       (DESCRIPTION
	(return (proposition-less-than? o1 (proposition o2))))
       (otherwise
	(return (string-less? (proposition-head-sort-string o1)
			      (object-sort-string o2))))))
    (NAMED-DESCRIPTION
     (typecase o2
       (PROPOSITION 
	(return (string-less? (object-sort-string o1)
			      (proposition-head-sort-string o2))))
       (NAMED-DESCRIPTION 
	(return (string-less? (object-sort-string o1)
			      (object-sort-string o2))))
       (DESCRIPTION
	(return (string-less? (object-sort-string o1)
			      (proposition-head-sort-string (proposition o2)))))
       (otherwise
	(return (string-less? (object-sort-string o1)
			      (object-sort-string o2))))))
    (DESCRIPTION
     (return (logic-form-less? (proposition o1) o2)))
    (otherwise
     (typecase o2
       (PROPOSITION 
	(return (not (string-less? (object-sort-string o1)
				   (proposition-head-sort-string o2)))))
       (NAMED-DESCRIPTION 
	(return (string-less? (object-sort-string o1)
			      (object-sort-string o2))))
       (DESCRIPTION
	(return (string-less? (object-sort-string o1)
			      (proposition-head-sort-string (proposition o2)))))
       (otherwise
	(return (string-less? (object-sort-string o1)
			      (object-sort-string o2))))))))



;-------------------------------------------------------------------------------
;;; IDEA:
;;;   (assert "(= (smokes (owner @BLUE-HOUSE)) \"CAMELS\")")
;;;        is interpreted (de re) as a fact about the current owner, while
;;;   (rule "(= (smokes (owner @BLUE-HOUSE)) \"CAMELS\")")
;;;        is interpreted (de dicto) as a rule about owners of the blue house.
;;; DE RE implies parse-time evaluation of each term, while DE DICTO implies
;;;   query-time evaluation.
;;; MORE EXAMPLES:
;;;    (assert "(= (nationality (the-only m isa PERSON where (= (smokes m) \"CAMELS\")))
;;;                \"RUSSIAN\")")
;;; VS:
;;;    (rule "(= (nationality (the-only m isa PERSON where (= (smokes m) \"CAMELS\")))
;;;                \"RUSSIAN\")")

;;; INFIX:
;;;    RULE  nationality( the-only(m:PERSON WHERE smokes(m) = "CAMELS") )
;;;              = "RUSSIAN"
;;;    END-RULE;
;;; DESCRIPTIONS:
;;;    (implies (and PERSON (fillers smokes "CAMELS"))
;;;             (and PERSON (fillers nationality "RUSSIAN")))

