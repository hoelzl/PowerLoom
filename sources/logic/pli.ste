;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;; BEGIN LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
; Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          ;
;                                                                            ;
; The contents of this file are subject to the Mozilla Public License        ;
; Version 1.1 (the "License"); you may not use this file except in           ;
; compliance with the License. You may obtain a copy of the License at       ;
; http://www.mozilla.org/MPL/                                                ;
;                                                                            ;
; Software distributed under the License is distributed on an "AS IS" basis, ;
; WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   ;
; for the specific language governing rights and limitations under the       ;
; License.                                                                   ;
;                                                                            ;
; The Original Code is the PowerLoom KR&R System.                            ;
;                                                                            ;
; The Initial Developer of the Original Code is                              ;
; UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          ;
; 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               ;
;                                                                            ;
; Portions created by the Initial Developer are Copyright (C) 1997-2006      ;
; the Initial Developer. All Rights Reserved.                                ;
;                                                                            ;
; Contributor(s):                                                            ;
;                                                                            ;
; Alternatively, the contents of this file may be used under the terms of    ;
; either the GNU General Public License Version 2 or later (the "GPL"), or   ;
; the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   ;
; in which case the provisions of the GPL or the LGPL are applicable instead ;
; of those above. If you wish to allow use of your version of this file only ;
; under the terms of either the GPL or the LGPL, and not to allow others to  ;
; use your version of this file under the terms of the MPL, indicate your    ;
; decision by deleting the provisions above and replace them with the notice ;
; and other provisions required by the GPL or the LGPL. If you do not delete ;
; the provisions above, a recipient may use your version of this file under  ;
; the terms of any one of the MPL, the GPL or the LGPL.                      ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; END LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; Version: pli.ste,v 1.48 2006/05/11 07:05:28 hans Exp

;;; Application Program Interface (API) for PowerLoom

(in-package "STELLA")

(in-module "PLI")


;;;  !!!! ****  STILL MISSING:   
;;;             retrieve-partial

  ;;
;;;;;; SETUP
  ;;

(defglobal *powerloom-initialized?* BOOLEAN FALSE)
(startup-time-progn
  (setq *powerloom-initialized?* TRUE))

(defun initialize ()
  :documentation "Initialize the PowerLoom logic system.  This function
needs to be called by all applications before using PowerLoom.  If it
is called more than once, every call after the first one is a no-op."
  :public? TRUE
  ;; NOTE: this does only protect us from multiple calls to `initialize'
  ;;    or from calling it after `startup-logic-system' has already run,
  ;;    but it does not prevent us from calling `startup-logic-system'
  ;;    multiple times (which is intentional).
  (with-process-lock *bootstrap-lock*
    (when (not *powerloom-initialized?*)
      ;; this will set `*powerloom-initialized?*' to true:
      (startup-logic-system))))

(defun reset-powerloom ()
  :documentation "Reset PowerLoom to its initial state.
CAUTION: This will destroy all loaded knowledge bases and might break other
loaded STELLA systems if they do reference PowerLoom symbols in their code."
  :public? TRUE
  (with-process-lock *powerloom-lock*
    (logic/reset-powerloom)))

(defun clear-caches ()
  :documentation "Clear all query and memoization caches."
  :public? TRUE
  (with-process-lock *powerloom-lock*
    (logic/clear-caches)))


  ;;
;;;;;; ENVIRONMENTS
  ;;

;;; THIS IS JUST A STUB CLASS:
(defclass ENVIRONMENT (STANDARD-OBJECT)
  :public? TRUE
  :slots ((level :type STRING))
  :print-form (print-native-stream stream "|ENV|" (level self))
  )

(defconstant ASSERTION-ENV ENVIRONMENT (new ENVIRONMENT :level "ASSERTION")
  :public? TRUE)
(defconstant TAXONOMIC-ENV ENVIRONMENT (new ENVIRONMENT :level "TAXONOMIC")
  :public? TRUE)
(defconstant INFERENCE-ENV ENVIRONMENT (new ENVIRONMENT :level "INFERENCE")
  :public? TRUE)


  ;;
;;;;;; PL ITERATOR
  ;;

;; Bob's original PL-ITERATOR.  Replaced by code below that doesn't
;; try to handle the Java interface side of things.
;; TO DO:  Revisit this to insert a special class in just the
;; Java hierarchy in order to get the appropriate inclusion of
;; the implements java.util.Iterator

(defclass PL-ITERATOR (ITERATOR)
  :public? TRUE
  :parameters ((any-value :type OBJECT))
  :slots ((cursor :type CONS))
;;  :java-native-type "pli.PL_ITERATOR"
  )

(defmethod (next? BOOLEAN) ((self PL-ITERATOR))
  :public? TRUE
  :documentation "Advance the PL-Iterator `self' and return `true' if more
elements are available, `false' otherwise."
  (let ((cursor (cursor self)))
    (when (nil? cursor)
      (setf (slot-value self value) NULL)
      (return FALSE))
    (setf (slot-value self value) (value cursor)) 
    (setf (cursor self) (rest cursor))
    (return TRUE)))

(defmethod (empty? BOOLEAN) ((self PL-ITERATOR))
  :public? TRUE
  :documentation "Return TRUE if the iterator `self' has no more elements."
  (return (eq? (cursor self) NIL)))

(defmethod (length INTEGER) ((self PL-ITERATOR))
  :public? TRUE
  :documentation "Number of items remaining in `self'.  Non destructive."
  (return (length (cursor self))))

(defglobal EMPTY-PL-ITERATOR PL-ITERATOR (new PL-ITERATOR :cursor NIL)
  :public? FALSE
  :documentation "Iterator that generates no values.")

(defun (cons-to-pl-iterator PL-ITERATOR) ((self CONS))
  :public? FALSE
  :documentation "Convert a Stella cons list into an API iterator."
  (if (empty? self)
    (return EMPTY-PL-ITERATOR)
    (return (new PL-ITERATOR :cursor self))))

(defun (list-to-pl-iterator PL-ITERATOR) ((self LIST))
  :public? FALSE
  :documentation "Convert a Stella list into an API iterator."
  (if (empty? self)
    (return EMPTY-PL-ITERATOR)
    (return (cons-to-pl-iterator (the-cons-list self)))))

(defun (iterator-to-pl-iterator PL-ITERATOR) ((self ITERATOR))
  :public? FALSE
  :documentation "Convert an arbitrary Stella iterator into an API iterator."
  ;; Strategy: Generate a cons list of values from `self' and stuff them
  ;;    into an iterator.
  (return (cons-to-pl-iterator (consify self))))

(defmethod (listify LIST) ((self PL-ITERATOR))
  :public? TRUE
  :documentation "Convert `self' into a Stella LIST."
  (return (new LIST :the-cons-list (collect x in self))))

(defmethod (consify CONS) ((self PL-ITERATOR))
  :public? TRUE
  :documentation "Convert `self' into a Stella CONS."
  (return (collect x in self)))


  ;;
;;;;;; Utility functions for PLI bodies
  ;;

(defun (safely-get-object OBJECT)
       ((name STRING) (module MODULE) (environment ENVIRONMENT))
  :public? FALSE
  ;; Helping function for API functions.  Retrieve an object
  ;;    named `name' in `module' subject to `environment' options.
  ;; If there is none, generate a suitable message.
  ;; Designed not to break if `name' is null.  Returns NULL if
  ;;    `name' is null.
  (when (null? name)
    (return NULL))
  (let ((object (get-object name module environment)))
    (if (null? object)
      (signal NO-SUCH-OBJECT-EXCEPTION
	      "Can't find an object named " name)
      (return object))))

(defun (safely-get-concept OBJECT)
       ((name STRING) (module MODULE) (environment ENVIRONMENT))
  :public? FALSE
  ;; Helping function for API functions.  Retrieve a concept
  ;;    named `name' in `module' subject to `environment' options.
  ;; If there is none, generate a suitable message.
  ;; Designed not to break if `name' is null.  Returns NULL if
  ;;    `name' is null.
  (when (null? name)
    (return NULL))
  (let ((object (get-concept name module environment)))
    (if (null? object)
      (signal NO-SUCH-OBJECT-EXCEPTION
	      "Can't find a concept named " name)
      (return object))))

(defun (safely-get-relation OBJECT)
       ((name STRING) (module MODULE) (environment ENVIRONMENT))
  :public? FALSE
  ;; Helping function for API functions.  Retrieve a relation or function
  ;;    named `name' in `module' subject to `environment' options.
  ;; If there is none, generate a suitable message.
  ;; Designed not to break if `module' is null.  Returns NULL if
  ;;    `module' is null.
  (when (null? name)
    (return NULL))
  (let ((object (get-relation name module environment)))
    (if (null? object)
      (signal NO-SUCH-OBJECT-EXCEPTION
	      "Can't find a relation named " name)
      (return object))))

(defun (safely-get-module CONTEXT) ((name STRING) (environment ENVIRONMENT))
  :public? FALSE
  ;; If `name' is non-null and non-empty, look for a module named `name',
  ;;    and complain if none is found.
  ;; Otherwise, return the current module.
  (ignore environment)                  ; TEMPORARY?
  (when (or (null? name)
            (eql? name ""))
    (return *module*))
  (return (get-stella-module name TRUE)))

(defun (safely-get-object-or-null OBJECT)
       ((name STRING) (module MODULE) (environment ENVIRONMENT))
  :public? FALSE
  ;; Helping function for API functions.
  ;; Same as `safely-get-object' but tolerates a null input.
  (when (or (null? module)
            (null? name)
	    (string-eql? name "")
            (string-equal? name "null"))
    (return NULL))
  (exception-case
      (return (get-object name module environment))
    (NO-SUCH-OBJECT-EXCEPTION ()
      (return NULL))))

(defun (sequence-to-cons-list CONS) ((sequence OBJECT))
  :public? FALSE
  ;; Convert `sequence' to a cons list.
  (typecase sequence
    (CONS (return sequence))
    (LIST (return (the-cons-list sequence)))
    (VECTOR
     (let ((result nil))
       (foreach i in (interval 0 (length sequence))
	   collect (nth sequence i) into result)
       (return result)))
    (otherwise
     (signal STELLA-EXCEPTION
	     "Don't know how to convert object of type "
	      (primary-type sequence) " into a cons list."))))

(defun (explode-string-list CONS) ((stringList STRING) (module MODULE))
  :public? FALSE
  ;; Return a list of logic terms extracted from `stringList'.
  (within-module module
   (let ((expression CONS (unstringify stringList))
         (term OBJECT NULL)
         (result NIL))
     (foreach ref in expression
              do (setq term (choose (eql? ref (quote NULL))
                                    NULL
                                    (evaluate-term ref)))
              collect term into result)
     (return result))))


(defun (legal-operator? BOOLEAN) ((operator SYMBOL))
  :public? FALSE
  (return (or (member? *kif-sentence-operators* operator)
              (member? *kif-term-operators* operator)
              (member? (quote (<=>> <<=> <<=>> <~> <~>> <<~> <<~>>
                                    about <<= =>> <~ ~> <<~ ~>>))
                       operator))))


  ;;
;;;;;; Names to instances and back
  ;;



(defun (get-keyword KEYWORD) ((name STRING))
  :public? TRUE
  :documentation "Returns the Stella KEYWORD `name' if it exists.  Case sensitive."
  (return (lookup-keyword name)))

(defun (get-symbol SYMBOL) ((name STRING) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Returns the Stella SYMBOL `name' visible in `module' if it
exists.  `name' is ALWAYS treated case sensitively."
  (with-logic-environment module environment
    (return (lookup-symbol name))
    #|  potentially case-insensitive version:
    ;; Additional doc string text:
    ;; "`name may be treated non case sensitively if `module' is not case sensitive."
    (let ((sym (lookup-symbol name)))
      (if (defined? sym)
        (return sym)
        (if (case-sensitive? *module*)
          (return (lookup-symbol (string-upcase name)))
          (return NULL))))
     |#
    ))

(defun (get-operator SYMBOL) ((name STRING))
  :public? TRUE
  :documentation "Returns the logical operator object (a Stella SYMBOL) for `name'.
If no such operator exists then a `no-such-object' exception is thrown."
  (unless (all-upper-case-string? name)
    (setq name (string-upcase name)))
  (let ((operator (lookup-symbol-in-module name *logic-module* false)))
    (if (and (defined? operator) (legal-operator? operator))
      (return operator)
      (signal NO-SUCH-OBJECT-EXCEPTION "No operator named " name)
     )))

(defun (get-object OBJECT) ((name STRING) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Look for an object named `name' that is local to
or visible from the module `module'."
  (with-logic-environment module environment
    (return (LOGIC/get-instance (intern-stella-name name)))))

(defun (s-get-object OBJECT) ((name STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Look for an object named `name' that is local to
or visible from the module `module-name'.  A module name of `null' or the
empty string refers to the current module.  If no module can be found
with the name `module-name', then a Stella `no-such-context-exception' is thrown."
  (return 
    (get-object name (safely-get-module module-name environment) environment)))

(defun (get-concept LOGIC-OBJECT) ((name STRING) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return a class/concept named `name' that is local to
or visible from the module `module'."
  (with-logic-environment module environment
    (return (LOGIC/get-class (intern-stella-name name)))))

(defun (s-get-concept LOGIC-OBJECT) ((name STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return a class/concept named `name' that is local to
or visible from the module `module-name'.  A module name of `null' or the
empty string refers to the current module.  If no module can be found
with the name `module-name', then a Stella `no-such-context-exception' is thrown."
  (return 
    (get-concept name (safely-get-module module-name environment) environment)))

(defun (get-relation LOGIC-OBJECT) ((name STRING) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return a concept or relation named `name' that is local to
or visible from the module `module'."
  (with-logic-environment module environment
    (return (LOGIC/get-relation (intern-stella-name name)))))

(defun (s-get-relation LOGIC-OBJECT) ((name STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return a concept or relation named `name' that is local to
or visible from the module `module-name'.  A module name of `null' or the
empty string refers to the current module.  If no module can be found
with the name `module-name', then a Stella `no-such-context-exception' is thrown."
  (return 
    (get-relation name (safely-get-module module-name environment) environment)))


;;;;
;;;;  GET-NAME series.
;;;;  GET-NAME is always fully qualified.
;;;;  GET-SHORT-NAME is never qualified.
;;;;  GET-NAME-IN-MODULE gets the name needed to find the object as seen from the module.
;;;;

;; TO DO:  WHAT ABOUT SKOLEMS? -- Nothing, they are unnamed objects.
(defun (get-name-in-module STRING) ((obj OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return the name, qualified as necessary, so that `obj' can be found from
`module'.  If there is no name for the object return `null'."
  (with-logic-environment module environment
    (typecase obj
      (SKOLEM
       (return NULL))
      (LOGIC-OBJECT
       (return (stringify (object-name obj))))
      (GENERALIZED-SYMBOL
       (return (stringify obj)))
      (MODULE
       (return (module-full-name obj)))
      (CONTEXT
       (return (context-name obj)))
      (/PL-KERNEL-KB/COMPUTED-PROCEDURE
       (return (stringify (surrogate-value-inverse obj))))
      (otherwise 
       (return NULL)))))

(defun (get-name STRING) ((obj OBJECT))
  :documentation "Return the fully qualified name of `obj', if it has one.  Otherwise return `null'."
  (return (get-name-in-module obj *root-module* NULL)))

(defun (get-short-name STRING) ((obj OBJECT))
  :public? TRUE
  :documentation "Return the short name of `obj', if it has one.  Otherwise return `null'."
  (typecase obj
    (SKOLEM
     (return NULL))
    (LOGIC-OBJECT
     (return (object-name-string obj)))
    ;; Do we want to do this?
    (KEYWORD
     (return (concatenate ":" (symbol-name obj))))
    (GENERALIZED-SYMBOL
     (return (symbol-name obj)))
    (CONTEXT
     (return (context-name obj)))
    (/PL-KERNEL-KB/COMPUTED-PROCEDURE
     (return (symbol-name (surrogate-value-inverse obj))))
    (otherwise 
     (return NULL))))



(defun (object-to-string STRING) ((self OBJECT))
  :public? TRUE
  :documentation "Return a printed representation of the term `self' as a string."
  (if (null? self)
    (return NULL)
    (special ((*printReadably?* TRUE))
      (typecase self
        (STRING-WRAPPER
         (return (wrapper-value self)))
	(SKOLEM 
	 (let ((value (value-of self)))
	   (if (eql? value self)
	     (return (stringify self))
	     (return (object-to-string value)))))
	(PL-ITERATOR
	 (return (stringify (consify self))))
	(otherwise (return (stringify self)))))))

(defun (object-to-integer INTEGER) ((self OBJECT))
  :public? TRUE
  :documentation
  "Coerce `self' to an integer, or throw a Stella Exception if the coersion is not feasible.
Floating point values will be coerced by rounding."
  (typecase self
    (SKOLEM 
     (let ((value (value-of self)))
       (if (eql? value self)
	 (signal STELLA-EXCEPTION "Can't coerce " self " to an integer.")
	 (return (object-to-integer value)))))
    (INTEGER-WRAPPER (return self))
    (FLOAT-WRAPPER (return (round (wrapper-value self))))
    (otherwise 
     (signal STELLA-EXCEPTION "Can't coerce " self " to an integer."))))

(defun (object-to-float FLOAT) ((self OBJECT))
  :public? TRUE
  :documentation
  "Coerce `self' to a float, or throw a Stella Exception if the coersion is not feasible."
  (typecase self
    (SKOLEM 
     (let ((value (value-of self)))
       (if (eql? value self)
	 (signal STELLA-EXCEPTION "Can't coerce " self " to a float.")
	 (return (object-to-float value)))))
    (INTEGER-WRAPPER (return self))
    (FLOAT-WRAPPER (return self))
    (otherwise 
     (signal STELLA-EXCEPTION "Can't coerce " self " to a float."))))

(defun (object-to-parsable-string STRING) ((self OBJECT))
  :public? TRUE
  :documentation "Return a string representing a printed
representation of the object `self'.  Like `object-to-string', but puts
escaped double quotes around strings."
  (typecase self
    (STRING-WRAPPER
     (return (concatenate "\"" self "\"")))
    (otherwise
     (return (object-to-string self)))))

;;; TO DO: Implement this:
;;; Note that this is different from (string-search-for-object string type)
;;; because the `type' here is a logic object, not a stella type! 
;;;
;;; Bob's intent was to use the type to help decide how to interpret the
;;; argument string, so that for example "foo" would be treated as an
;;; object of type STRING (or perhaps STRING-WRAPPER ?) if the type argument
;;; indicated that, whereas if type were Person, it would be treated as
;;; a logic object.
;;;

(defglobal *literal-concept* NAMED-DESCRIPTION NULL
  :public? FALSE)
(defglobal *string-concept* NAMED-DESCRIPTION NULL
  :public? FALSE)
(defglobal *integer-concept* NAMED-DESCRIPTION NULL
  :public? FALSE)
(defglobal *float-concept* NAMED-DESCRIPTION NULL
  :public? FALSE)

(startup-time-progn :final
  (setq *literal-concept* (s-get-concept "LITERAL" "PL-USER" NULL))
  (setq *string-concept*  (s-get-concept "STRING" "PL-USER" NULL))
  (setq *integer-concept* (s-get-concept "INTEGER" "PL-USER" NULL))
  (setq *float-concept*   (s-get-concept "FLOAT" "PL-USER" NULL)))


(defun (string-to-object OBJECT) 
    ((string STRING) (type LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Evaluate `string' with respect to `module' and `environment'
and return the corresponding logical term.  `type' is a concept used to assist the
correct interpretation of `string'.

Currently `type' only has an effect on the interpretation of literal types."
  (with-logic-environment module environment
    (let ((obj (unstringify string)))
      (typecase obj
	(LITERAL-WRAPPER
	 (when (null? type)
	   (return obj))
	 (typecase obj
	   (STRING-WRAPPER
	    (if (subrelation-of? type *string-concept*)
	      (return obj)
	      (signal PARSING-ERROR "String argument found, but " type " is not a subconcept of " *string-concept*)))
	   (INTEGER-WRAPPER
	    (cond ((subrelation-of? type *integer-concept*)
		   (return obj))
		  ((subrelation-of? type *float-concept*)
		   (return (cast (wrapper-value obj) FLOAT)))
		  (otherwise 
		   (return (get-object string module environment)))))
	   (FLOAT-WRAPPER
	    (cond ((subrelation-of? type *float-concept*)
		   (return obj))
		  (otherwise 
		   (return (get-object string module environment)))))))
	(otherwise
	 (cond ((null? type)
		(return (get-object string module environment)))
	       ((subrelation-of? type *string-concept*)
		(return string))
	       ((subrelation-of? type *literal-concept*)
		(signal PARSING-ERROR string " is a non-literal, but " type " is a subconcept of " *literal-concept*))
	       (otherwise
		(return (get-object string module environment)))))))))


  ;;
;;;;;; Retrieval
  ;;

#|
;; syntax games - these are not all valid examples:
(get-nth-string (retrieve "(?y)" "(age Fred ?y)" *module* NULL) 1 *module* NULL)
v.
(get-nth-string (retrieve "(age ?x ?y)" "(= ?x Fred)" *module* NULL) 2)*module* NULL
v.
(get-nth-string (retrieve "(age Fred ?y)" "TRUE" *module* NULL) 2 *module* NULL)
v.
(get-nth-string (parametric-retrieve "(age ?x ?y)" "TRUE" (list "Fred" NULL) *module* NULL)
                2 *module* NULL)
v.
(get-nth-string (parametric-retrieve "(?x ?y)" "(age ?x ?y)" (list "Fred" NULL) *module* NULL)
                2 *module* NULL)
v.
(get-nth-string (s-get-proposition "(age Fred null)" *module* NULL) 2 *module* NULL)
v.
(get-nth-string (s-get-propositions "(age Fred null)" *module* NULL) 2 *module* NULL)
v.
(get-nth-string (get-binary-proposition
                 (get-relation "age") (get-object "Fred") NULL *module* NULL)
                2 *module* NULL)
|#

(defun (help-get-true-extension-members (CONS OF PROPOSITION)) 
       ((relation NAMED-DESCRIPTION) (specialize? BOOLEAN))
  :public? FALSE
  ;; Return the asserted extension of `relation'.
  ;; TO DO: REWRITE AS AN ITERATOR?
  (let ((result (collect p in (all-extension-members relation)
                         where (true-proposition? p))))
    (when specialize?
      (foreach sub in (all-subcollections relation)
          ;; Needed because all-extension-members is only defined on named-descriptions
	  where (isa? sub @NAMED-DESCRIPTION)
	  do (foreach p in (all-extension-members sub)
		 where (true-proposition? p)
		 do (pushq result p)))
      (return (remove-duplicates result)))
    (return result)))

(defun (help-get-propositions (CONS OF PROPOSITION))
       ((relation LOGIC-OBJECT) (arguments CONS) (limit INTEGER)
        (module MODULE) (environment ENVIRONMENT))
  ;; Retrieve propositions with relation `relation' and arguments matching
  ;;    the bound members of `arguments'.  Retrieve at most `limit' propositions
  ;;    (zero or negative `limit' represents no bound).
  ;; Called by other API routines.
  :public? FALSE
  (when (null? relation)
    (return NIL))
  (with-logic-environment module environment
    (let ((specialize? (not (eql? environment ASSERTION-ENV)))
          (argumentWithBacklinks (some arg in arguments
                                       where (and (defined? arg)
                                                  (isa? arg @LOGIC-OBJECT))))
          (iterator (choose (defined? argumentWithBacklinks)
                            (all-true-dependent-propositions
                             argumentWithBacklinks (surrogate-value-inverse relation) specialize?)
                            (allocate-iterator
                             (help-get-true-extension-members relation specialize?))))
          (results NIL))
      (foreach p in iterator
               where (and (forall inputArg in arguments
                                  as arg2 in (arguments p)
                                  always (or (null? inputArg)
                                             (eql? inputArg (value-of arg2))))
                          (eql? (length arguments)
                                (length (arguments p))))
               do 
               (pushq results p)
               (-- limit)
               (when (eql? limit 0)
                 (break)))
      (return results))))
    
(defun (get-proposition PROPOSITION)
       ((relation-and-arguments OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return a proposition matching `relation-and-arguments' that
has been asserted (or inferred by forward chaining).  `relation-and-arguments'
is a sequence containing objects and nulls.  The first argument must be the
name of a relation.  A null value acts like a wild card.  If more than one 
proposition matches the input criteria, the selection among satisficing
propositions is arbitrary.  This procedure is normally applied to single-valued
relations or functions."
  (let ((list (sequence-to-cons-list relation-and-arguments))
        (relation (first list))
        (arguments (rest list)))
    (return (first (help-get-propositions
                    relation arguments 1 module environment)))))

(defun (s-get-proposition PROPOSITION)
       ((relation-and-arguments STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return a proposition matching `relation-and-arguments' that
has been asserted (or inferred by forward chaining).  `relation-and-arguments'
is a string that begins with a left parenthesis, followed by a relation name, 
one or more argument identifiers, and terminated by a right parenthesis.  Each
argument identifier can be the name of a logical constant, a literal
reference (e.g., a number), the null identifier, or a variable (an identifier that begins
with a question mark). Each occurrence of a null or a variable acts like a wild card.
If more than one proposition matches the input criteria, the selection among
satisficing propositions is arbitrary.  This procedure is normally applied to
single-valued relations or functions.

A module name of `null' or the
empty string refers to the current module.  If no module can be found
with the name `module-name', then a Stella `no-such-context-exception' is thrown."
  (let ((module (safely-get-module module-name environment))
        (elements (explode-string-list relation-and-arguments module))
        (relation (first elements))
        (arguments (rest elements)))
    (return
     (first (help-get-propositions relation arguments 1 module environment)))))

(defun (get-propositions (PL-ITERATOR OF PROPOSITION))
       ((relation-and-arguments OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return propositions matching `relation-and-arguments' that
have been asserted (or inferred by forward chaining).  `relation-and-arguments'
is a sequence containing objects and nulls.  The first argument must be the
name of a relation.  A null value acts like a wild card."
  (let ((list (sequence-to-cons-list relation-and-arguments))
        (relation (first list))
        (arguments (rest list)))
    (return (cons-to-pl-iterator
             (help-get-propositions relation arguments 0 module environment)))))

(defun (s-get-propositions (PL-ITERATOR OF PROPOSITION))
       ((relation-and-arguments STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return propositions matching `relation-and-arguments' that
have been asserted (or inferred by forward chaining).  `relation-and-arguments'
is a string that begins with a left parenthesis, followed by a relation name, 
one or more argument identifiers, and terminated by a right parenthesis.  Each
argument identifier can be the name of a logical constant, a literal 
reference (e.g., a number), the null identifier, or a variable (an identifier that begins
with a question mark). Each occurrence of a null or a variable acts like a wild card.

A module name of `null' or the
empty string refers to the current module.  If no module can be found
with the name `module-name', then a Stella `no-such-context-exception' is thrown."
  (let ((module (safely-get-module module-name environment))
        (elements (explode-string-list relation-and-arguments module))
        (relation (first elements))
        (arguments (rest elements)))
    (return (cons-to-pl-iterator
             (help-get-propositions relation arguments 0 module environment)))))


;; TO DO:  SHOULD THESE HAVE UNARY FORMS AS WELL?

(defun (get-binary-proposition PROPOSITION)
       ((relation LOGIC-OBJECT) (arg1 OBJECT) (arg2 OBJECT)
        (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return a proposition such that (`relation' `arg1' `arg2')
is true.  The `relation' argument must be bound to a relation.  One or both
of the `arg1' and `arg2' arguments may be set to NULL, which is interpreted
as a wildcard. If more than one proposition matches the input criteria,
the selection is arbitrary.  This procedure is normally applied to single-valued
relations or functions."
  ;; Instead of calling `help-get-propositions' immediately, a bit of extra
  ;;    code results in a small speedup.  If and when `help-get-propositions'
  ;;    is rewritten to return an iterator, the speed-up may be greater.
  (with-logic-environment module environment
    (let ((argumentWithBacklinks LOGIC-OBJECT NULL))
      (cond
       ((and (defined? arg1)
             (isa? arg1 @LOGIC-OBJECT))
        (setq argumentWithBacklinks arg1))
       ((and (defined? arg2)
             (isa? arg2 @LOGIC-OBJECT))
        (setq argumentWithBacklinks arg2)))
      (if (defined? argumentWithBacklinks)
        (foreach p in (all-true-dependent-propositions
                       argumentWithBacklinks (surrogate-value-inverse relation) FALSE)
                 where
                 (and (or (null? arg1)
                          (eql? arg1 (value-of (nth (arguments p) 0))))
                      (or (null? arg2)
                          (eql? arg2 (value-of (nth (arguments p) 1)))))
                 do (return p))
        ;; switch to more general-purpose retrieve:
        (return (first (help-get-propositions 
                        relation (cons-list arg1 arg2) 1 module environment))))
      (return NULL))))

(defun (get-binary-propositions (PL-ITERATOR OF PROPOSITION))
       ((relation LOGIC-OBJECT) (arg1 OBJECT) (arg2 OBJECT)
        (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return propositions such that (`relation' `arg1' `arg2')
is true.  The `relation' argument
must be bound to a relation.  One or both of the `arg1' and `arg2' arguments
may be set to NULL, which is interpreted as a wildcard."
  (return (cons-to-pl-iterator
           (help-get-propositions 
            relation (cons-list arg1 arg2) 0 module environment))))

(defun (get-inferred-binary-proposition-values PL-ITERATOR)
       ((relation LOGIC-OBJECT) (arg OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return all values `v' such that (`relation' `arg' `v')
has been asserted or can be inferred."
  (with-logic-environment module environment
    (return (cons-to-pl-iterator
             (apply-retrieve (?r ?i ?v) (?r ?i ?v) (relation arg NULL))))))

(defun (s-get-inferred-binary-proposition-values PL-ITERATOR)
       ((relation-name STRING) (arg-name STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return all values `v' such that (`relation-name' `arg-name' `v')
has been asserted or can be inferred.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown."
  (let ((module (safely-get-module module-name environment))
        (relation (safely-get-relation relation-name module environment))
        (object (safely-get-object arg-name module environment)))
    (if (all-defined? object relation)
      (return (get-inferred-binary-proposition-values relation object module environment))
      (return EMPTY-PL-ITERATOR))))

(defun (get-propositions-of (PL-ITERATOR OF PROPOSITION)) 
       ((object LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return all propositions that have `object' among their arguments,
and that are TRUE in the scope of the module `module'."
  (with-logic-environment module environment
    (return (list-to-pl-iterator (all-facts-of-instance object FALSE FALSE)))))

(defun (s-get-propositions-of (PL-ITERATOR OF PROPOSITION))
       ((object-name STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return all propositions that have the object named `object-name' among
their arguments, and that are TRUE in the scope of the module `module-name'.
A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown."
  (let ((module (safely-get-module module-name environment))
        (object (safely-get-object object-name module environment)))
    (if (all-defined? object)
      (return (get-propositions-of object module environment))
      (return EMPTY-PL-ITERATOR))))

(defun (get-propositions-in-module (PL-ITERATOR OF PROPOSITION))
       ((module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return propositions that have been conceived in
the module `module'."
  (with-logic-environment module environment
    (return (cons-to-pl-iterator 
             (consify (all-propositions *module* TRUE))))))


  ;;
;;;;;; Probes
  ;;

(defun (is-true-unary-proposition BOOLEAN)
       ((relation LOGIC-OBJECT) (arg OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return TRUE if the proposition (`relation' `arg') has
been asserted (or inferred by forward chaining)."
  (return (defined? (help-get-propositions
                     relation (cons-list arg) 1 module environment))))

(defun (is-true-binary-proposition BOOLEAN)
       ((relation LOGIC-OBJECT) (arg OBJECT) (value OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return TRUE if the proposition (`relation' `arg' `value') has
been asserted (or inferred by forward chaining)."
  (return (defined? (get-binary-proposition relation arg value module environment))))

;;; WHAT ARE THE DIFFERENCES BETWEEN THESE NEXT THREE???
;; NOT CLEAR IF WE SHOULD SUPPORT THIS: -rmm
(defun (is-true-proposition1 BOOLEAN) 
       ((relation-and-arguments OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return TRUE if a proposition (`relation' `args') has
been asserted (or inferred by forward chaining)."
  (let ((list (sequence-to-cons-list relation-and-arguments))
        (relation (first list))
        (arguments (rest list)))
    (return (defined? (help-get-propositions
                       relation arguments 1 module environment)))))

(defun (is-true-proposition BOOLEAN) 
       ((proposition PROPOSITION) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return TRUE if `proposition' is  TRUE in the module `module'."
  (with-logic-environment module environment
    (return (true-proposition? proposition))))

(defun (s-is-true-proposition BOOLEAN) 
       ((relation-and-arguments STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return TRUE if a proposition that prints as the string
`relation-and-arguments' is true in the module named `module-name'.
A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown."
  (return (defined? (s-get-proposition
                     relation-and-arguments module-name environment))))


  ;;
;;;;;; Isa and Subsumption Hierarchies
  ;;

(defun (is-subrelation BOOLEAN)
       ((sub LOGIC-OBJECT) (super LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return TRUE if `sub' is a subconcept/subrelation of `super'."
  (when (or (null? sub) (null? super))
    (return FALSE))
  (with-logic-environment module environment
    (return
      (true-truth-value? (description-specializes-description? sub super)))))

(defun (get-proper-subrelations (PL-ITERATOR OF LOGIC-OBJECT))
       ((relation LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return relations that specialize `relation'.
Non-reflexive."
  (with-logic-environment module environment
    (return (cons-to-pl-iterator (all-subrelations relation TRUE)))))

(defun (get-direct-subrelations (PL-ITERATOR OF LOGIC-OBJECT))
       ((relation LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return relations that directly specialize `relation'.
Non-reflexive."
  (with-logic-environment module environment
    (return (cons-to-pl-iterator (all-direct-subrelations relation TRUE)))))

(defun (get-proper-superrelations (PL-ITERATOR OF LOGIC-OBJECT))
       ((relation LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return relations that generalize `relation'.
Non-reflexive."
  (with-logic-environment module environment
    (return (cons-to-pl-iterator (all-superrelations relation TRUE)))))

(defun (get-direct-superrelations (PL-ITERATOR OF LOGIC-OBJECT))
       ((relation LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return relations that directly generalize `relation'.
Non-reflexive."
  (with-logic-environment module environment
    (return (cons-to-pl-iterator (all-direct-superrelations relation TRUE)))))

(defun (is-a BOOLEAN) ((object OBJECT) (concept LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return TRUE if `object' is a member of the concept `concept'."
  (with-logic-environment module environment
    (return (test-isa? object (surrogate-value-inverse concept)))))

(defun (get-concept-instances PL-ITERATOR)
       ((concept LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return instances of the concept `concept'.
Include instances of subconcepts of `concept'.  Depending on `concept',
the return values could be (wrapped) literals."
  (with-logic-environment module environment
    (if (and (defined? environment)
             (eql? (level environment) "ASSERTION"))
      (return 
       (list-to-pl-iterator 
        (remove-deleted-members (asserted-collection-members concept FALSE))))
      (return
       (retrieve (bquote (all ?x (& (object-name concept) ?x))) module environment)))))

(defun (s-get-concept-instances PL-ITERATOR)
       ((concept-name STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return instances of concept `concept-name'.
Include instances of subconcepts of `concept-name'.  Depending on `concept-name',
the return values could be (wrapped) literals.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown."
  (let ((module (safely-get-module module-name environment))
        (concept (safely-get-concept concept-name module environment)))
    (if (all-defined? concept)
      (return (get-concept-instances concept module environment))
      (return EMPTY-PL-ITERATOR))))

(defun (get-direct-concept-instances PL-ITERATOR)
       ((concept LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return instances of concept `concept'.
Exclude instances of subconcepts of `concept'.  Depending on `concept',
the return values could be (wrapped) literals."
  (with-logic-environment module environment
    (if (and (defined? environment)
             (eql? (level environment) "ASSERTION"))
      (return 
       (list-to-pl-iterator 
        (remove-deleted-members (asserted-collection-members concept TRUE))))
      (return
       (retrieve (bquote (all ?x (/LOGIC/AND (& (object-name concept) ?x)
                                             (/LOGIC/FAIL
                                              (LOGIC/EXISTS (?y)
                                                (/LOGIC/AND (PROPER-SUBRELATION & (object-name concept) ?Y)
                                                            (?Y ?X)))))))
                 module environment)))))

(defun (s-get-direct-concept-instances PL-ITERATOR)
       ((concept-name STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return instances of concept `concept-name'.
Exclude instances of subconcepts of `concept-name'.  Depending on `concept-name',
the return values could be (wrapped) literals.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown."
  (let ((module (safely-get-module module-name environment))
        (concept (safely-get-concept concept-name module environment)))
    (if (all-defined? concept)
      (return (get-direct-concept-instances concept module environment))
      (return EMPTY-PL-ITERATOR)) ))

(defun (get-concept-instances-matching-value PL-ITERATOR)
       ((concept LOGIC-OBJECT) (relation LOGIC-OBJECT) (value OBJECT)
        (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return members of concept `concept' that
have an attribute matching `value' for the binary relation `relation', i.e.,
`(relation <result> value)' holds."
  (with-logic-environment module environment
    (let ((instances (get-concept-instances concept module environment))
          (answers NIL))
      (foreach i in instances
               where (is-true-binary-proposition relation i value module environment)
               do (pushq answers i))
      (return (cons-to-pl-iterator answers)))))

(defun (get-concept-instance-matching-value OBJECT)
       ((concept LOGIC-OBJECT) (relation LOGIC-OBJECT) (value OBJECT)
        (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return a member of concept `concept' that
has an attribute matching `value' for the binary relation `relation', i.e.,
`(relation <result> value)' holds."
  (with-logic-environment module environment
    (let ((instances (get-concept-instances concept module environment)))
      (foreach i in instances
               where (is-true-binary-proposition relation i value module environment)
               do (return i))
      (return NULL))))

#|
;; What about?
(defun (get-types (PL-ITERATOR OF LOGIC-OBJECT))
       ((object LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :documentation "Return all named concepts that `object' belongs to."
  (with-logic-environment module environment
     (return (cons-to-pl-iterator (all-types object)))))

(defun (get-types (PL-ITERATOR OF LOGIC-OBJECT))
       ((object LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :documentation "Return all named concepts that `object' belongs to."
  (with-logic-environment module environment
    (return (cons-to-pl-iterator (all-direct-types object)))))
|#

(defun (get-types (PL-ITERATOR OF LOGIC-OBJECT))
       ((object LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return all named concepts that `object' belongs to."
  (let ((directTypes (get-direct-types object module environment))
        (types NIL))
    (foreach d in directTypes
             do
             (when (not (member? types d))
               (pushq types d))
             (foreach c in (all-supercollections d)
                      where (isa? c @NAMED-DESCRIPTION)
                      do
                      (when (not (member? types c))
                        (pushq types c))))
    (return (cons-to-pl-iterator types))))

(defun (get-direct-types (PL-ITERATOR OF LOGIC-OBJECT))
       ((object LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return most specific concepts that `object' belongs to."
  (with-logic-environment module environment
   (let ((derivableTypes NIL))
     (foreach prop in (all-true-dependent-propositions object NULL FALSE)
              where (eql? (kind prop) :ISA)
              do (pushq derivableTypes (get-nth-value prop 0 module environment)))
     (return (cons-to-pl-iterator (most-specific-named-descriptions derivableTypes))))))

(defun (get-relation-extension (PL-ITERATOR OF PROPOSITION))
       ((relation LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :documentation "Return propositions that satisfy `relation'.
Include propositions that satisfy subrelations of `relation'."
  (with-logic-environment module environment
    (return (cons-to-pl-iterator
             (help-get-true-extension-members
              relation (not (= environment ASSERTION-ENV)))))))

(defun (s-get-relation-extension (PL-ITERATOR OF PROPOSITION))
       ((relation-name STRING) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return propositions that satisfy the relation named
`relation-name'.  Include propositions that satisfy subrelations of the relation."
  (let ((relation (safely-get-relation relation-name module environment)))
    (if (defined? relation)
      (return (get-relation-extension relation module environment))
      (return EMPTY-PL-ITERATOR))))


  ;;
;;;;;; Modules and modules
  ;;

(defun (get-module MODULE) ((name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return a module named `name'."
  (ignore environment)
  (return (get-stella-module name FALSE)))

(defun (get-current-module MODULE) ((environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return the currently set module"
  (ignore environment)
  (return *module*))

(defun (get-home-module MODULE) ((object LOGIC-OBJECT))
  :public? TRUE
  :documentation "Return the module in which `object' was created."
  (return (home-module object)))

(defun (get-modules (PL-ITERATOR OF MODULE)) ((kb-modules-only? BOOLEAN))
  :public? TRUE
  :documentation "Return all modules currently loaded into PowerLoom.  If `kb-modules-only?'
is `true', then Stella modules that are used only for program code are
not included in the list."
  (return (cons-to-pl-iterator (list-modules kb-modules-only?))))

(defun (create-module MODULE) ((name STRING) (parent MODULE) (case-sensitive? BOOLEAN))
  :public? TRUE
  :documentation "Creates a new module `name' as a child of `parent'.  The flag
`case-sensitive?' controls whether names read in this module will be
case sensitive or not."
  (let ((full-name (choose (defined? parent)
                           (concatenate (module-full-name parent) "/" name)
                           name))
        (case-sensitive-symbol (choose case-sensitive? (quote TRUE) (quote FALSE))))
    (return
     (define-module full-name (bquote (:case-sensitive? & case-sensitive-symbol))))))

(defun (s-create-module MODULE) ((name STRING) (parent-name STRING) (case-sensitive? BOOLEAN)
                                 (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Creates a new module `name' as a child of `parent-name'.  The flag
`case-sensitive?' controls whether names read in this module will be
case sensitive or not."
  (return
   (create-module name (safely-get-module parent-name environment) case-sensitive?)))

(defun (change-module MODULE) ((module MODULE))
  :public? TRUE
  :documentation "Set the current module to `module' and return it.
If `module' is `null', then no switch is performed and the current
module is returned."
  (when (null? module)
    (return *module*))
  (return (LOGIC/change-module module)))

(defun (s-change-module MODULE) ((name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Set the current module to the module named `name'.
The return value is the module named `name' unless `name' is null or
the empty string.  In that case, the current module is returned.
If no module named `name' exists, a Stella `no-such-context-exception'
is thrown."
  (return (change-module (safely-get-module name environment))))

(defun (clear-module MODULE) ((module MODULE))
  :public? TRUE
  :documentation "Destroy the contents of the module `module' as well as
the contents of all of its children, recursively."
  (call-clear-module module)
  (return module))

(defun (s-clear-module MODULE) ((name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Destroy the contents of the module named `name', as
well as the contents of all of its children, recursively.  If no module
named `name' exists, a Stella `no-such-context-exception' is thrown."
  (let ((module (safely-get-module name environment)))
    (call-clear-module module)
    (return module)))

(defun (get-child-modules (PL-ITERATOR OF MODULE)) ((module MODULE))
  :public? TRUE
  :documentation "Return the modules that are immediate children of `module'."
  (let ((directSubModules NIL))
    ;; Filter out non-modules:
    (foreach child in (child-contexts module)
	where (isa? child @MODULE)
	collect child into directSubModules)
    (return (cons-to-pl-iterator directSubModules)) ))

(defun (s-get-child-modules (PL-ITERATOR OF MODULE)) 
    ((name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return the modules that are immediate children of module `name'.
If no module named `name' exists, a Stella `no-such-context-exception'
is thrown."
  (return (get-child-modules (safely-get-module name environment))))

(defun (get-parent-modules (PL-ITERATOR OF MODULE)) ((module MODULE))
  :public? TRUE
  :documentation "Return the modules that are immediate parents of `module'."
  (return (list-to-pl-iterator (parent-modules module))))

(defun (s-get-parent-modules (PL-ITERATOR OF MODULE))
 ((name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return the modules that are immediate parents of module `name'.
If no module named `name' exists, a Stella `no-such-context-exception'
is thrown."
  (return (get-parent-modules (safely-get-module name environment))))

(defun (generate-unique-name STRING) ((prefix STRING) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Generates a name based on `prefix' with a number appended that
is not currently in use in `module.'  In a non-case-sensitive module, the returned
name will be all upper case (This latter feature may change!)"
  (with-logic-environment module environment
    (unless (or (case-sensitive? *module*)
                (all-upper-case-string? prefix))
        (setq prefix (string-upcase prefix)))
    (return (yield-unique-gensym-name prefix *module*))))
 

  ;;
;;;;;; Update
  ;;


(defun (create-keyword KEYWORD) ((name STRING))
  :public? TRUE
  :documentation "Returns the Stella keyword `name', creating it if
necessary.  `name' is treated case-sensitively.  This should
generally not be necessary to do."
  (return (intern-rigid-symbol-wrt-module name *module* KEYWORD-SYM)))

(defun (create-symbol SYMBOL) ((name STRING) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Returns the Stella symbol `name' visible in `module',
creating it if necessary.  `name' is ALWAYS treated case-sensitively,
even if `module' is case insensitive. This should generally not be
necessary to do."
  (with-logic-environment module environment
    (return (intern-symbol-in-module name *module* FALSE))))

(defun (create-object LOGIC-OBJECT) 
    ((name STRING) (concept LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Create an object named `name' of type `concept' in the designated
module.  Both `name' and `concept' can be `null'.  If `name' is `null' then an
object will be created with a new, non-conflicting name based on the name of
`concept', or system-generated if no concept is specified.  If `concept' is
`null', then the object will be of type THING.  It is an error to create an
object with the same name as an existing object.

Note that the string can be a qualified name, in which case the object
will be created in the module specified, but with a name as determined
by the qualified name.  Vertical bars in the name string are interpreted
as Stella escape characters.

Note that because names in modules that are not case-sensitive are
canonicalized, the name of the returned object may not match `name'
exactly.

Return the object."
  (with-logic-environment module environment
    (let ((object LOGiC-OBJECT null)
          (name-symbol SYMBOL null)
          (object-surrogate SURROGATE null))
      (cond ((defined? name)
             (setq name-symbol (intern-stella-name name)))
            ((defined? concept)
             ;; Use this temporarily to get the appropriate modules.
             (setq name-symbol (get-short-name concept))
             (setq name-symbol (intern-symbol-in-module 
                                (generate-unique-name (symbol-name name-symbol)
                                                      (home-context name-symbol)
                                                      NULL)
                                (home-context name-symbol)
                                TRUE)))
            (otherwise
             (setq name-symbol (intern-symbol-in-module 
                                (generate-unique-name "I" null null)
                                *module*
                                TRUE))))
      (setq object-surrogate (lookup-surrogate-in-module (symbol-name name-symbol)
                                                         (home-context name-symbol)
                                                         FALSE))
      (when (null? object-surrogate)
        (setq object-surrogate (intern-surrogate-in-module (symbol-name name-symbol)
                                                           (home-context name-symbol)
                                                           FALSE)))
      (setq object (help-create-logic-instance object-surrogate NULL))
      (when (defined? concept)
        (if (defined? (assert-unary-proposition concept object module environment))
          (return object)
          (return NULL)))
      (return object) )))

(defun (s-create-object LOGIC-OBJECT)
 ((name STRING) (concept-name STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Create an object named `name' of type `concept-name' in the designated
module.  Both `name' and `concept-name' can be null strings.  If `name' is a null string
then an object will be created with a new, non-conflicting name based on `concept-name', or
system-generated if no concept nameis specified.  If `concept-name' is the null string, then
the object will be of type THING.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly.

Return the object."
  (let ((module (safely-get-module module-name environment)))
    (return 
     (create-object name 
                    (safely-get-concept concept-name module environment)
                    module
                    environment)) ))

(defun (create-concept LOGIC-OBJECT) ((name STRING) (parent LOGIC-OBJECT)
				      (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation
  "Create a concept named `name' in the designated `module', with the
designated `parent' superconcept (which can be left undefined).  Additional
superconcepts can be added via assertions of the `subset-of' relation.  Note
that a specified `parent' concept needs to be created separately.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly."
  (with-logic-environment module environment
    (return 
      (call-defconcept
       (bquote (& (intern-stella-name name)
                  && (choose (defined? parent)
                             (bquote (:subset-of & (object-name parent)))
                             NIL)))))))

(defun (s-create-concept LOGIC-OBJECT) ((name STRING) (parent-name STRING) 
					(module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation
  "Create a concept named `name' in the designated module, with
with the concept named `parent-name' as superconcept (which can be left
undefined).  Additional superconcepts can be added via assertions of the
`subset-of' relation.  Note that a specified parent concept needs to be
created separately.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly."
  (let ((module (safely-get-module module-name environment)))
    (return 
      (create-concept name
		      (safely-get-concept parent-name module environment)
		      module
		      environment))))

(defun (create-relation LOGIC-OBJECT) ((name STRING) (arity INTEGER)
				       (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Create a relation named `name' with arity `arity' in the
designated module.  Domain and range information can be added via assertions
of `nth-domain' (or `domain' and `range') relations.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly."
  (unless (> arity 0)
    (signal-parsing-error "Relations must have arity of at least 1"))
  (let ((args NIL))
    (with-logic-environment module environment
      (foreach i in (interval 0 (1- arity))
          collect (yield-system-defined-parameter-name i *module*)
          into args)
      (return
	(call-defrelation (bquote (& (intern-stella-name name) & args)))))))

(defun (s-create-relation LOGIC-OBJECT) ((name STRING) (arity INTEGER) 
                                         (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Create a relation named `name' with arity `arity' in the
designated module.  Domain and range information can be added via assertions
of `nth-domain' (or `domain' and `range') relations.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly."
  (return 
    (create-relation name arity
                     (safely-get-module module-name environment)
                     environment)))

(defun (create-function LOGIC-OBJECT) ((name STRING) (arity INTEGER)
				       (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation
  "Create a function named `name' with arity `arity'  in the designated 
`module'.  Domain and range information can be added via assertions of
`nth-domain' (or `domain' and `range') relations.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly."
  (unless (> arity 0)
    (signal-parsing-error "Functions must have arity of at least 1"))
  (let ((args NIL))
    (with-logic-environment module environment
      (foreach i in (interval 0 (1- arity))
          collect (yield-system-defined-parameter-name i *module*)
          into args)
      (return
	(call-deffunction (bquote (& (intern-stella-name name) & args)))))))

(defun (s-create-function LOGIC-OBJECT) ((name STRING) (arity INTEGER) 
                                         (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation
  "Create a function named `name' with arity `arity' in the designated 
module.  Domain and range information can be added via assertions of
`domain', `nth-domain' and `range' relations.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown.

Note that because names in modules that are not case-sensitive are canonicalized,
the name of the returned object may not match `name' exactly."
  (return 
    (create-function name arity
                     (safely-get-module module-name environment)
                     environment)))

(defun register-specialist-function ((name STRING) (function-reference FUNCTION-CODE)
                                     (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation
  "Register `name' as a function name in `module' which will invoke the
native code procedure described by `function-reference.'  The `name'
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The function must conform
to the signature for specialist functions.

The exact form of `function-reference' depends on the underlying
programming language.  The following type mappings are used:
          C++:  
  Common Lisp:  FUNCTION   (result of #' or (FUNCTION ...))
         Java:  java.lang.reflect.Method"
  (with-logic-environment module environment
    (/logic/register-specialist-function name function-reference)))

(defun s-register-specialist-function ((name STRING) (native-name STRING)
                                       (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation
  "Register `name' as a function name in the module named `module-name'.
This function will the native code named `native-name'.  The `name'
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The `native-name' will be
processed in a manner that depends on the underlying programming
language.  The following type mappings are used:
          C++:  Not available.  Error signaled.
  Common Lisp:  The native-name is read by READ-FROM-STRING and then
                the SYMBOL-FUNCTION is taken.
         Java:  A fully package-qualified name is required.  It is
                looked up using the Reflection tools.
The function found must conform to the signature for specialist functions."
  (with-logic-environment (safely-get-module module-name environment) environment
    (/logic/register-specialist-function-name name native-name)))


(defun (create-enumerated-list LOGIC-OBJECT) 
       ((members CONS) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation
  "Create a logical term that denotes a list containing `members' in
`module' using `environment'.  Useful for passing lists as arguments
to parameterized queries."
  (with-logic-environment module environment
    (return (create-logical-list (new LIST :the-cons-list members)))))

(defun (create-enumerated-set LOGIC-OBJECT) 
       ((members CONS) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation
  "Create a logical term that denotes the enumerated set containing `members'
in `module' using `environment'."
  (with-logic-environment module environment
    (return (/logic/create-enumerated-set (new LIST :the-cons-list members)))))

(defun destroy-object ((object LOGIC-OBJECT))
  :public? TRUE
  :documentation "Delete the object `object', retracting all facts attached to it."
  (with-process-lock *powerloom-lock*
    (destroy-instance object)))

(defun s-destroy-object
 ((object-name STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Delete the object named `object-name', retracting all facts
attached to it.

A module name of `null' or the empty string refers to the current module. 
If no module can be found with the name `module-name', then a Stella 
`no-such-context-exception' is thrown."
  (let ((module (safely-get-module module-name environment))
        (object (safely-get-object object-name module environment)))
    (when (all-defined? object)
      (destroy-object object))))

(defun (assert-unary-proposition PROPOSITION) 
    ((relation LOGIC-OBJECT) (arg OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Assert that the proposition (`relation' `arg') is TRUE in `module'.  Return the asserted proposition."
  (with-logic-environment module environment
    (if (class? relation)
      (return (assert-isa-proposition arg (surrogate-value-inverse relation)))
      (return (assert-property arg (surrogate-value-inverse relation))))))

(defun (assert-binary-proposition PROPOSITION)
       ((relation LOGIC-OBJECT) (arg OBJECT) (value OBJECT)
	(module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Assert that the proposition (`relation' `arg' `value') is TRUE
in `module'.  Return the asserted proposition."
  (with-logic-environment module environment
    (return (assert-binary-value (surrogate-value-inverse relation) arg value))))

(defun (assert-nary-proposition PROPOSITION) 
       ((relation-and-arguments OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Assert that the proposition represented by the list ` relation-and-arguments' satisfies
the relation `relation'."
  (let ((list (sequence-to-cons-list relation-and-arguments))
        (relation NAMED-DESCRIPTION (first list))
        (relationSurrogate (surrogate-value-inverse relation))
        (arguments (rest list)))
    (with-logic-environment module environment
      (return (assert-tuple relationSurrogate arguments)))))

(defun (retract-unary-proposition PROPOSITION) 
    ((relation LOGIC-OBJECT) (arg OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Retract that the proposition (`relation' `arg') is TRUE in `module'.  Return the asserted proposition."
  (with-logic-environment 
    module environment
    (if (class? relation)
      (return (retract-isa-proposition arg (surrogate-value-inverse relation)))
      (return (retract-property arg (surrogate-value-inverse relation))))))

(defun (retract-binary-proposition PROPOSITION)
       ((relation LOGIC-OBJECT) (arg OBJECT) (value OBJECT)
	(module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Retract that the proposition (`relation' `arg' `value') is TRUE
in `module'.  Return the asserted proposition."
  (with-logic-environment module environment
    (return (retract-binary-value (surrogate-value-inverse relation) arg value))))


(defun (retract-nary-proposition PROPOSITION) 
       ((relation-and-arguments OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Retract the proposition that `arguments' satisfies
the relation `relation'."
  (let ((list (sequence-to-cons-list relation-and-arguments))
        (relation NAMED-DESCRIPTION (first list))
        (relationSurrogate (surrogate-value-inverse relation))
        (arguments (rest list)))
    (with-logic-environment module environment
      (return (update-tuple relationSurrogate arguments :RETRACT-TRUE)))))

(defun (assert-proposition PROPOSITION) 
    ((proposition PROPOSITION) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Assert that the proposition `proposition' is true in `module'.
Return the asserted proposition."
  (with-logic-environment module environment
    (help-update-top-level-proposition proposition :ASSERT-TRUE)
    (return proposition)))

(defun (s-assert-proposition (PL-ITERATOR OF PROPOSITION))
    ((sentence STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Assert that the logical sentence `sentence' is true in the module
named `module-name'.  A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.

Return an iterator of the propositions resulting from sentence."
  (let ((module (safely-get-module module-name environment))
        (propositions (PL-ITERATOR OF PROPOSITION) NULL)
	(return-value (PL-ITERATOR OF PROPOSITION) NULL))
    (with-logic-environment module environment
      (setq propositions (s-conceive sentence module-name environment))
      (setq return-value (cons-to-pl-iterator (cursor propositions))) ; Preserve for return
      (foreach proposition in propositions
	  do (help-update-top-level-proposition proposition :ASSERT-TRUE))
      (return return-value))))

(defun (retract-proposition PROPOSITION) 
    ((proposition PROPOSITION) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Retract the truth of the proposition `proposition' in `module'.
Return the retracted proposition."
  (with-logic-environment module environment
    (help-update-top-level-proposition proposition :RETRACT-TRUE)
    (return proposition)))

(defun (s-retract-proposition (PL-ITERATOR OF PROPOSITION)) 
    ((sentence STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Retract the truth of the logical sentence `sentence' in the module named
`module-name'.  A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown.

Return an iterator of the retracted propositions resulting from sentence."
  (let ((module (safely-get-module module-name environment))
        (propositions (PL-ITERATOR OF PROPOSITION) NULL)
	(return-value (PL-ITERATOR OF PROPOSITION) NULL))
    (with-logic-environment module environment
      (setq propositions (s-conceive sentence module-name environment))
      (setq return-value (cons-to-pl-iterator (cursor propositions))) ; Preserve for return
      (foreach proposition in propositions
	  do (help-update-top-level-proposition proposition :RETRACT-TRUE))
      (return return-value))))

(defun (conceive (PL-ITERATOR OF PROPOSITION))
    ((sentence OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Create one or more proposition objects from the sentence `sentence'
in the  module `module'.  Return an iterator of the propositions.
If any of the new propositions has the same structure as an already existing
proposition, an automatic check for duplicates will return the pre-existing
proposition.  Multiple propositions may be returned for a single sentence
because of normalization of equivalences, conjunctions, etc.

Signals a `Proposition-Error' if PowerLoom could not conceive `sentence'."
  (if (null? sentence)
    (return NULL)
    (with-logic-environment module environment
      (let ((propositions (conceive-formula sentence)))
	(when (null? propositions)
	  (signal-proposition-error "Failed to conceive " sentence))
	(typecase propositions
	  (PROPOSITION
	   (return (cons-to-pl-iterator (cons propositions NIL))))
	  (CONS
	   (return (cons-to-pl-iterator propositions)))
          (otherwise
           (signal-proposition-error "Formula is not a sentence: " sentence)))) )))

(defun (s-conceive (PL-ITERATOR OF PROPOSITION))
    ((sentence STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Create one or more proposition objects from the sentence `sentence'
in the  module named `module-name'.  Return an iterator of the propositions.
If any of the new propositions has the same structure as an already existing
proposition, an automatic check for duplicates will return the pre-existing
proposition.  Multiple propositions may be returned for a single sentence
because of normalization of equivalences, conjunctions, etc.

A module name of `null' or the empty string refers to the current module.
If no module can be found with the name `module-name', then a Stella
`No-Such-Context-Exception' is thrown.

Signals a `Proposition-Error' if PowerLoom could not conceive `sentence'."
  (let ((module (safely-get-module module-name environment)))
    (with-logic-environment module environment
      (return (conceive (unstringify sentence) module environment))) ))


  ;;
;;;;;; Rules
  ;;

(defun (get-rules (PL-ITERATOR OF PROPOSITION)) 
    ((relation LOGIC-OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return rules attached to the concept/relation `relation'
in either antecedent or consequent position."
  (if (null? relation)
    (return EMPTY-PL-ITERATOR)
    (with-logic-environment module environment
       (return (cons-to-pl-iterator (call-get-rules relation))))))

(defun (s-get-rules (PL-ITERATOR OF PROPOSITION)) 
       ((relation-name STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return rules attached to the concept/relation named
`relation-name' found in the module named `module-name'.

A module name of `null' or the empty string refers to the current module.
If no module can be found with the name `module-name', then a Stella
`No-Such-Context-Exception' is thrown."
  (let ((module (safely-get-module module-name environment))
        (relation (safely-get-relation relation-name module environment)))
    (return (get-rules relation module environment))))

(defun s-print-rules ((name STRING) (stream OUTPUT-STREAM)
		      (module-name STRING) (environment ENVIRONMENT))
  :documentation "Print rules attached to the concept/relation named `name'.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  :public? TRUE
  (when (null? stream)
    (setq stream STANDARD-OUTPUT))
  (foreach rule in (s-get-rules name
				module-name
				environment)
      do (print-logical-form rule stream)
         (print-stream stream EOL EOL)))

(defun run-forward-rules ((module OBJECT) (force? BOOLEAN))
  :public? TRUE
  :documentation "Run forward inference rules in module `module'.
If `module' is NULL, the
current module will be used.  If forward inferencing is already up-to-date
in the designated module, no additional inferencing will occur, unless `force'
is set to TRUE, in which case all forward rules are run or rerun.

Calling `run-forward-rules' temporarily puts the module into a mode where
future assertional (monotonic) updates will trigger additional forward
inference.  Once a non-monotonic update is performed, i.e., a retraction
or clipping of relation value, all cached forward inferences will be discarded
and forward inferencing will be disabled until this function is
called again."
  (when (null? module)
    (setq module *module*))
  (when (defined? module)
    (call-run-forward-rules module force?)))


  ;;
;;;;;; Frame queries
  ;;

(defun (get-arity INTEGER) ((relation LOGIC-OBJECT))
  :public? TRUE
  :documentation "Return the arity of the relation `relation'."
  (typecase relation
    (NAMED-DESCRIPTION (return (arity relation)))
    (otherwise (return 0))))

(defun (s-get-arity INTEGER) ((relation-name STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return the arity of the relation named `relation-name'.

 A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (let ((module (safely-get-module module-name environment))
        (relation (safely-get-relation relation-name module environment)))
    (if (all-defined? relation)
      (return (get-arity relation))
      (return NULL))))

(defun (get-domain LOGIC-OBJECT) ((relation LOGIC-OBJECT))
  :public? TRUE
  :documentation "Return the type (a concept) for the first argument to the binary
relation `relation'."
  (typecase relation
    (NAMED-DESCRIPTION (return (get-nth-domain relation 0)))
    (otherwise (return NULL))))

(defun (s-get-domain LOGIC-OBJECT) ((relation-name STRING) 
                                    (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return the type (concept) for the first argument to the binary
relation `relation-name'.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (let ((module (safely-get-module module-name environment))
        (relation (safely-get-relation relation-name module environment)))
    (if (all-defined? relation)
      (return (get-domain relation))
      (return NULL))))

(defun (get-range LOGIC-OBJECT) ((relation LOGIC-OBJECT))
  :public? TRUE
  :documentation "Return the type (a concept) for fillers of the binary relation
`relation'."
  (typecase relation
    (NAMED-DESCRIPTION (return (get-nth-domain relation 1)))
    (otherwise (return NULL))))

(defun (s-get-range LOGIC-OBJECT) ((relation-name STRING)
                                   (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return the type (a concept) for fillers of the binary relation
`relation-name'.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (let ((module (safely-get-module module-name environment))
        (relation (safely-get-relation relation-name module environment)))
    (if (all-defined? relation)
      (return (get-range relation))
      (return NULL))))

(defun (get-nth-domain LOGIC-OBJECT) ((relation LOGIC-OBJECT) (n INTEGER))
  :public? TRUE
  :documentation "Return the type (a concept) for the the nth argument of the
relation `relation'.  Counting starts at zero."
  (if (class? relation)
    (return (choose (eql? n 0) relation NULL))
    (typecase relation
      (NAMED-DESCRIPTION
       (if (and (>= n 0)
                (< n (length (io-variable-types relation))))
         (let ((type (surrogate-value (nth (io-variable-types relation) n))))
           (when (null? type)
             (return NULL))
           (typecase type
             (CLASS (return (description type)))
             (LOGIC-OBJECT (return type))))
         (return NULL)))
      (otherwise (return NULL)))))

(defun (s-get-nth-domain LOGIC-OBJECT)
       ((relation-name STRING) (n INTEGER) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation
  "Return the type (a concept) for the nth argument of the relation
named `relation-name'.  Counting starts at zero.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (let ((module (safely-get-module module-name environment))
        (relation (safely-get-relation relation-name module environment)))
    (if (all-defined? relation)
      (return (get-nth-domain relation n))
      (return NULL))))

(defun load ((filename STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Read logic commands from the file named `filename' and evaluate them.
The file should begin with an `in-module' declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
`evaluate' to each of them."
  (with-logic-environment *module* environment
    (LOGIC/load filename)))

(defun load-stream ((stream INPUT-STREAM) (environment ENVIRONMENT))
  :public? TRUE
  :documentation
  "Read logic commands from the STELLA stream `stream' and evaluate them.
The stream should begin with an `in-module' declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
`evaluate' to each of them."
  (with-logic-environment *module* environment
    (LOGIC/load-stream stream)))

(defun load-native-stream ((stream NATIVE-INPUT-STREAM) (environment ENVIRONMENT))
  :public? TRUE
  :documentation
  "Read logic commands from the native input stream `stream' and evaluate them.
Assumes `stream' is a line-buffered stream which is a safe compromise but does
not generate the best efficiency for block-buffered streams such as files.
The stream should begin with an `in-module' declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
`evaluate' to each of them."
  (with-logic-environment *module* environment
    (LOGIC/load-stream (new INPUT-STREAM :native-stream stream))))

(defun save-module ((module MODULE) (filename STRING) (ifexists STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Save the contents of the module `mod' into a file named `filename'.
If a file named `filename' already exists, then the action taken depends on the
value of `ifexists'.  Possible values are \"ASK\", \"REPLACE\", \"WARN\" and \"ERROR\":

  REPLACE => Means overwrite without warning.
  WARN    => Means overwrite with a warning.
  ERROR   => Means don't overwrite, signal an error instead.
  ASK     => Ask the user whether to overwrite or not.  If not overwritten, an 
             exception is thrown."
  (let ((exists? (stella/probe-file? filename)))
    (cond ((or (not exists?) (string-equal? ifexists "REPLACE"))
	   NULL)			; Do nothing, replace file if needed.
	  ((string-equal? ifexists "ASK")
	   (unless (yes-or-no? (concatenate "File `" filename 
					    "' already exists.  Overwrite it? (yes or no) "))
	     (ensure-file-does-not-exist filename "save-module")))
	  ((string-equal? ifexists "WARN")
	   (warn "File " filename " already exists, overwriting."))
	  ((string-equal? ifexists "ERROR")
	   (ensure-file-does-not-exist filename "save-module"))
	  (otherwise
           (signal BAD-ARGUMENT-EXCEPTION
                   "Unrecognized ifexists option " ifexists)))
    (with-logic-environment module environment
      (with-output-file (stream filename)
	(do-save-module *MODULE* stream))) ))

(defun s-save-module ((module-name STRING) (filename STRING) (ifexists STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Save the contents of the module `module-name' into a file named `filename'.
If a file named `filename' already exists, then the action taken depends on the
value of `ifexists'.  Possible values are \"ASK\", \"REPLACE\", \"WARN\" and \"ERROR\":

  REPLACE => Means overwrite without warning.
  WARN    => Means overwrite with a warning.
  ERROR   => Means don't overwrite, signal an error instead.
  ASK     => Ask the user whether to overwrite or not.  If not overwritten, an
             exception is thrown.

A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (save-module (safely-get-module module-name environment) filename ifexists environment))


  ;;
;;;;;; Extracting column values from propositions and iterators
  ;;

(defun (get-predicate LOGIC-OBJECT) ((prop PROPOSITION))
  :public? TRUE
  :documentation "Return the concept or relation predicate for
the proposition `prop'."
  ;; Called by `get-nth-value'.
  (let ((relation LOGIC-OBJECT (get-description (relationref prop))))
    (when (null? relation)
      ;; if we can't return a NAMED-DESCRIPTION, we settle for returning
      ;;    a LOGIC-OBJECT:
      (setq relation (surrogate-value (relationref prop))))
    (return relation)))

(defun (get-column-count INTEGER) ((obj OBJECT))
  :public? TRUE
  :documentation "Return the number of columns in `obj', which must
be of type proposition, cons, vector or PL-iterator.  For a proposition,
the number includes both the predidate and arguments. For the PL-iterator
case,the number of columns is for the current value of the iterator.

For non sequence objects, the column count is zero."
  (when (null? obj)
    (return 0))
  (typecase obj
    (PROPOSITION
     (return (1+ (length (arguments obj)))))
    (PL-ITERATOR
     (return (get-column-count (value obj))))
    (CONS
     (return (length obj)))
    (VECTOR
     (return (length obj)))
    (otherwise 
     (return 1))))

(defun (get-nth-value OBJECT) ((sequence OBJECT) (n INTEGER) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return the value in the `nth' column of `sequence'.
Counting starts at zero.  Unless `n' is zero, `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the number
of columns is for the current value of the iterator.

As a special case, a column number of zero will also return `sequence' itself
if it is not one of the types enumerated above.  This is done to allow the
use of `get-nth-value' on PL-iterators with only a single return variable."
  (when (or (>= n (get-column-count sequence))
	    (< n 0))
    (signal LOGIC-EXCEPTION "Column index " n " is out of range for " sequence))
  (typecase sequence
    (PROPOSITION
     (if (eql? n 0)
       (return (get-predicate sequence))
       (let ((value (nth (arguments sequence) (1- n))))
         (typecase value
           (SKOLEM
            (with-logic-environment module environment
              (return (value-of value))))
           (otherwise
            (return value))))))
    (PL-ITERATOR
     (return (get-nth-value (value sequence) n module environment)))
    (CONS
     (return (nth sequence n)))
    (VECTOR
     (return (nth sequence n)))
    (otherwise
     (return sequence)) ))

(defun (get-nth-string STRING) ((sequence OBJECT) (n INTEGER) (module MODULE)(environment ENVIRONMENT))
  :public? TRUE
  :documentation "Return a string representation of the value in the `nth' column of
`sequence'. Counting starts at zero.   Unless `n' is zero, `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  This will always
succeed, even if the `nth' value is not a string object.  In that case, a
string reprensentation will be returned.


As a special case, a column number of zero will also return `sequence' itself
as a string if it is not one of the types enumerated above.  This is done to 
allow the use of `get-nth-string' on PL-iterators with only a single return variable."
  (return (object-to-string (get-nth-value sequence n module environment))))

(defun (get-nth-integer INTEGER) ((sequence OBJECT) (n INTEGER) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation  "Return an integer representation of the value in the `nth' column of
`sequence'. Counting starts at zero.   Unless `n' is zero, `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  If this is not
an integer value, then an exception will be thrown.


As a special case, a column number of zero will also return the integer
value of `sequence' itself if it is not one of the types enumerated
above.   This allows the use of `get-nth-integer' on PL-iterators with
only a single return variable.  If  `sequence' cannot be turned into an
integer, an exception will be thrown."
  (return (object-to-integer (get-nth-value sequence n module environment))))

(defun (get-nth-float FLOAT) ((sequence OBJECT) (n INTEGER) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation  "Return the floating point value in the `nth' column of
`sequence'. Counting starts at zero.  `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  If this is not
a floating point value, then an exception will be thrown.


As a special case, a column number of zero will also return the floating
point value of `sequence' itself if it is not one of the types enumerated
above.  This allows the use of `get-nth-float' on PL-iterators with only
a single return variable.    If  `sequence' cannot be turned into a floating
point value, an exception will be thrown."
  (return (object-to-float (get-nth-value sequence n module environment))))

(defun (get-nth-logic-object LOGIC-OBJECT) ((sequence OBJECT) (n INTEGER) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation
  "Return a logic object representation of the value in the `nth' column
of `sequence'.  Counting starts at zero.   Unless `n' is zero, `sequence' must be of type
proposition, cons, vector or PL-iterator.  A zero column number returns
a proposition's relational predicate.  For the PL-iterator case, the
the current value pointed to by the iterator is used.  A zero column number
returns the proposition's relational predicate.  If the return value is
not a LOGIC-OBJECT, an exception is thrown.

As a special case, a column number of zero will also return `sequence' itself
if it is not one of the types enumerated above.  This is done to allow the
use of `get-nth-value' on PL-iterators with only a single return variable.
If `sequence' is not a LOGIC-OBJECT, an exception is thrown."
  (let ((value (get-nth-value sequence n module environment)))
    (if (isa? value @LOGIC-OBJECT)
      (return value)
      (signal STELLA-EXCEPTION "Can't coerce " value " to a LOGIC-OBJECT."))))

(defun (get-enumerated-collection-members CONS) ((collection OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation
  "Returns the members of an enumerated collection.  This works on all types
of collection, i.e., sets and lists"
  (with-logic-environment module environment
    (let ((members (asserted-collection-members collection TRUE)))
      (if (defined? members)
        (return (the-cons-list members))
        (return NULL)))))


  ;;
;;;;;; Evaluation
  ;;

(defun (evaluate OBJECT) ((command OBJECT) (module MODULE) (environment ENVIRONMENT))
  :public? TRUE
  :documentation "Evaluate the command `command' within `module' and return
the result. Currently, only the evaluation of (possibly nested) commands and
global variables is supported.  Commands are simple to program in Common Lisp,
since they are built into the language, and relatively awkward in Java and C++.
Users of either of those languages are more likely to want to call `s-evaluate'."
  (when (defined? command)
    (with-logic-environment module environment
      (return (STELLA/evaluate command))))
  (return NULL))

(defun (s-evaluate OBJECT) ((command STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE 
  :documentation
  "Evaluate the command represented by the string `command' within `module' and
return the result.  Currently, only the evaluation of (possibly nested) commands and
global variables is supported.

 A module name of `null' or the empty string refers to the
current module.  If no module can be found with the name `module-name',
then a Stella `no-such-context-exception' is thrown."
  (let ((module (safely-get-module module-name environment)))
    (with-logic-environment module environment
       (return (evaluate (unstringify command)
			 module
			 environment)))))


  ;;
;;;;;;  Queries
  ;;


;;; Type tests for returned values:

(defun (is-logic-object BOOLEAN) ((obj OBJECT))
  :public? TRUE
  :documentation "Test whether `obj' is of type LOGIC-OBJECT"
  (return (isa? obj @LOGIC-OBJECT)))

(defun (is-integer BOOLEAN) ((obj OBJECT))
  :public? TRUE
  :documentation "Test whether `obj' is of type INTEGER"
  (return (isa? obj @INTEGER-WRAPPER)))

(defun (is-float BOOLEAN) ((obj OBJECT))
  :public? TRUE
  :documentation "Test whether `obj' is of type FLOAT (double)"
  (return (isa? obj @FLOAT-WRAPPER)))

(defun (is-number BOOLEAN) ((obj OBJECT))
  :public? TRUE
  :documentation "Test whether `obj' is of type NUMBER.  This can
be either an integer or a floating point number.  One key characteristic
is that 'object-to-integer' and `object-to-float' will both work on it."
  (return (isa? obj @NUMBER-WRAPPER)))

(defun (is-string BOOLEAN) ((obj OBJECT))
  :public? TRUE
  :documentation "Test whether `obj' is of type STRING"
  (return (isa? obj @STRING-WRAPPER)))

(defun (is-enumerated-collection BOOLEAN) ((obj OBJECT))
  :public? TRUE
  :documentation "Test whether `obj' is an enumerated collection.  This
subsumes both sets and lists."
  (return (logical-collection? obj)))

(defun (is-enumerated-set BOOLEAN) ((obj OBJECT))
  :public? TRUE
  :documentation "Test whether `obj' is an enumerated set."
  (return (enumerated-set? obj)))

(defun (is-enumerated-list BOOLEAN) ((obj OBJECT))
  :public? TRUE
  :documentation "Test whether `obj' is an enumerated list"
  (return (enumerated-list? obj)))


;;; Interpreting truth values:

(defun (is-true BOOLEAN) ((tv TRUTH-VALUE))
  :public? TRUE
  :documentation "Tests whether `tv' is a true truth value.  It can be true
either absolutely or by default."
  (return (true-truth-value? tv)))

(defun (is-false BOOLEAN) ((tv TRUTH-VALUE))
  :public? TRUE
  :documentation "Tests whether `tv' is a false truth value.  It can be false
either absolutely or by default."
  (return (false-truth-value? tv)))

(defun (is-unknown BOOLEAN) ((tv TRUTH-VALUE))
  :public? TRUE
  :documentation "Tests whether `tv' is an unknown truth value."
  (return (unknown-truth-value? tv)))

(defun (is-inconsistent BOOLEAN) ((tv TRUTH-VALUE))
  :public? TRUE
  :documentation "Tests whether `tv' is an inconsistent truth value."
  (return (inconsistent-truth-value? tv)))

(defun (is-strict BOOLEAN) ((tv TRUTH-VALUE))
  :public? TRUE
  :documentation "Tests whether `tv' is a strict (non-default) truth value."
  (return (strict-truth-value? tv)))

(defun (is-default BOOLEAN) ((tv TRUTH-VALUE))
  :public? TRUE
  :documentation "Tests whether `tv' is a default truth value."
  (return (default-truth-value? tv)))

(defun (ask TRUTH-VALUE) ((query CONS) (module MODULE) (environment ENVIRONMENT))
  :documentation
  "Returns a truth value for `query' in `module' and `environment'.
`query' has the same syntax as the PowerLoom `ask' command (which see)
but with the `ask' operator omitted.  For example, here are some legal
`query' arguments:
	 
    ((happy Fred))
    ((happy Fred) :inference-level :assertion)
    ((happy Fred) :inference-level :assertion :timeout 1.0)
	
As a convenience, a `query' argument whose first element is a symbol is
interpreted as a sentence that is queried without any options.  For example:
	 
    (happy Fred)
	
is a legal `query' argument.  Note that for a setence whose relation is a list
itself, e.g., `((FruitFn BananaTree) MyBanana)' this shortcut is not available,
that is, in that case an extra level of list nesting is always necessary.
The returned truth value represents the logical truth of the queried sentence
as determined by PowerLoom.  It can be be tested via the functions `is-true',
`is-false' and `is-unknown' (which see)."
  :public? TRUE
  (with-logic-environment module environment
    (setq query (deobjectify-tree query))
    ;; Test for the case where `query' is the sentence and no ASK options are
    ;;    being given and add the required extra level of nesting:
    (when (symbol? (first query))
      (setq query (cons query NIL)))
    (return (call-ask query))))

(defun (s-ask TRUTH-VALUE) ((query STRING) (module-name STRING) (environment ENVIRONMENT))
  :documentation
  "Returns a truth value for `query' in module `module-name' and `environment'.
`query' has the same syntax as the PowerLoom `ask' command (which see) but
with the `ask' operator omitted.  Different from the PLI `ask' function, `s-ask'
does not expect a top-level pair of parentheses.  For example, here are some legal
`query' arguments:
	 
    \"(happy Fred)\"
    \"(happy Fred) :inference-level :assertion\"
    \"(happy Fred) :inference-level :assertion :timeout 1.0\"
	
Names in `query' will be interpreted relative to module `module-name'.
A null `module-name' or the empty string refers to the current module.
If no module can be found with the name `module-name', then a STELLA
`no-such-context-exception' is thrown.
The returned truth value represents the logical truth of the queried sentence
as determined by PowerLoom.  It can be be tested via the functions `is-true',
`is-false' and `is-unknown' (which see)."
  :public? TRUE
  (let ((queryForm NIL)
        (module (safely-get-module module-name environment)))
    (with-logic-environment module environment
      (foreach sexp in (s-expressions (new STRING-INPUT-STREAM :the-string query))
          collect sexp into queryForm))
    (return (ask queryForm (safely-get-module module-name environment) environment))))

(defun (retrieve PL-ITERATOR) ((query CONS) (module MODULE) (environment ENVIRONMENT))
  :documentation
  "Returns an iterator of variable bindings that when substituted for the
open variables in `query' satisfy the query proposition.  The query is
run in `module' and relative to `environment'.  `query' has the same syntax
as the PowerLoom `retrieve' command (which see) but with the `retrieve'
operator omitted.    For example, here are some legal `query' arguments:
	 
    ((happy ?x))
    (10 (happy ?x))
    (all (happy ?x))
    (all ?x (happy ?x))
    (10 (happy ?x) :inference-level :assertion)
    (10 (happy ?x) :inference-level :assertion :timeout 1.0)
	
If there is only a single output variable (as in all the examples above)
each element generated by the returned iterator will be a binding for
that variable - unless, the output variable was declared with a surrounding
pair of parentheses.  For example:
	 
    (all (?x) (happy ?x))
	
In that case, the generated elements will be one-element lists.  If there
are multiple output variables, each element generated by the returned
iterator will be a list of variable bindings that can be accessed using
the various `get-nth-...' functions.  The list of output variables does
not need to be declared in which case they are taken to be the open variables
in the query proposition in the order in which they were encountered.  If
order does matter or should be different from its default, it can be forced
by declaring the set of output variables."
  :public? TRUE
  (with-logic-environment module environment
    (setq query (deobjectify-tree query))
    ;; NOTE: This works around the problem that query iterators would
    ;; otherwise be forced to completion by iterator-to-pl-iterator.
    ;; If that changes, then we can simplify this code.
    (return (cons-to-pl-iterator (consify-current-solutions (call-retrieve query))))))

(defun (s-retrieve PL-ITERATOR) ((query STRING) (module-name STRING) (environment ENVIRONMENT))
  :public? TRUE
  :documentation
  "Returns an iterator of variable bindings that when substituted for the
open variables in `query' satisfy the query proposition.  The query is
run in `module' and relative to `environment'.  `query' has the same syntax
as the PowerLoom `retrieve' command (which see) but with the `retrieve'
operator omitted.  Different from the PLI `retrieve' function, `s-retrieve'
does not expect a top-level pair of parentheses.  For example, here are some
legal `query' arguments:
	 
    \"(happy ?x)\"
    \"10 (happy ?x)\"
    \"all (happy ?x)\"
    \"all ?x (happy ?x)\"
    \"10 (happy ?x) :inference-level :assertion\"
    \"10 (happy ?x) :inference-level :assertion :timeout 1.0\"
	
If there is only a single output variable (as in all the examples above)
each element generated by the returned iterator will be a binding for
that variable - unless, the output variable was declared with a surrounding
pair of parentheses.  For example:
	 
    \"all (?x) (happy ?x)\"
	
In that case, the generated elements will be one-element lists.  If there
are multiple output variables, each element generated by the returned
iterator will be a list of variable bindings that can be accessed using
the various `get-nth-...' functions.  The list of output variables does
not need to be declared in which case they are taken to be the open variables
in the query proposition in the order in which they were encountered.  If
order does matter or should be different from its default, it can be forced
by declaring the set of output variables.

Names in `query' will be interpreted relative to module `module-name'.
A null `module-name' or the empty string refers to the current module.
If no module can be found with the name `module-name', then a STELLA
`no-such-context-exception' is thrown."
  :public? TRUE
  (let ((queryForm NIL)
        (module (safely-get-module module-name environment)))
    (with-logic-environment module environment
      (foreach sexp in (s-expressions (new STRING-INPUT-STREAM :the-string query))
          collect sexp into queryForm))
    (return (retrieve queryForm module environment))))


;;; TO DO:  PARTIAL RETRIEVE?
;;;


;;; Main entry point.
;;;

(defmain ()
  :documentation "Main PowerLoom entry point for your code in C++ and Java."
  :public? TRUE :startup-system? FALSE
  (print "Initializing STELLA..." EOL)
  (startup-stella-system)
  (print "Initializing PowerLoom..." EOL)
  (startup-logic-system)
  (STELLA/change-module "PL-USER")
  (powerloom))
