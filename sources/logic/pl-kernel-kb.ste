;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;; BEGIN LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
; Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          ;
;                                                                            ;
; The contents of this file are subject to the Mozilla Public License        ;
; Version 1.1 (the "License"); you may not use this file except in           ;
; compliance with the License. You may obtain a copy of the License at       ;
; http://www.mozilla.org/MPL/                                                ;
;                                                                            ;
; Software distributed under the License is distributed on an "AS IS" basis, ;
; WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   ;
; for the specific language governing rights and limitations under the       ;
; License.                                                                   ;
;                                                                            ;
; The Original Code is the PowerLoom KR&R System.                            ;
;                                                                            ;
; The Initial Developer of the Original Code is                              ;
; UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          ;
; 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               ;
;                                                                            ;
; Portions created by the Initial Developer are Copyright (C) 1997-2006      ;
; the Initial Developer. All Rights Reserved.                                ;
;                                                                            ;
; Contributor(s):                                                            ;
;                                                                            ;
; Alternatively, the contents of this file may be used under the terms of    ;
; either the GNU General Public License Version 2 or later (the "GPL"), or   ;
; the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   ;
; in which case the provisions of the GPL or the LGPL are applicable instead ;
; of those above. If you wish to allow use of your version of this file only ;
; under the terms of either the GPL or the LGPL, and not to allow others to  ;
; use your version of this file under the terms of the MPL, indicate your    ;
; decision by deleting the provisions above and replace them with the notice ;
; and other provisions required by the GPL or the LGPL. If you do not delete ;
; the provisions above, a recipient may use your version of this file under  ;
; the terms of any one of the MPL, the GPL or the LGPL.                      ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; END LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; Version: pl-kernel-kb.ste,v 1.62 2006/05/11 07:05:27 hans Exp

;;; Support to bootstrap the built-in PL-KERNEL KB that defines a fairly
;;; minimal set of mathematical and logical definitions.

(in-package "STELLA")

(in-module "PL-KERNEL")


(defglobal *pl-kernel-kb-definitions* CONS NULL)

(defun initialize-kernel-kb ()
  :documentation "Bootstrap the PowerLoom built-in kernel KB."
  :public? TRUE :command? TRUE
  ;; Bootstrap.  Create a dummy CONCEPT concept and its extension.
  ;;    Then re/define the real CONCEPT and by doing so insert it
  ;;    into its own extension.
  ;; TO DO: - make THING real
  ;;        - allow to rerun this by recording the appropriate symbols and
  ;;          and surrogates before the first initialization (we don't want
  ;;          to clear those since symbol variables point at them in code).
  (let ((kernelInitFile ; not currently used
         (lookup-configuration-property
          "PLKernelKBInitFile" "PL:sources;logic;pl-kernel-kb.plm" NULL))
        (kernelKBDefinitions
         ;; copy these, since normalization might destructively modify them:
         (copy-cons-tree *pl-kernel-kb-definitions*))
        (dummyConcept NAMED-DESCRIPTION NULL))
    (ignore kernelInitFile)
    (special ((*warnIfRedefine?* FALSE))
      (within-module (get-stella-module "PL-KERNEL-KB" TRUE)
        ;; create dummy CONCEPT and necessary supporting structure by hand:
        (setq dummyConcept
          (new NAMED-DESCRIPTION
               :surrogate-value-inverse PL-KERNEL/@CONCEPT
               :io-variable-types (stella/list PL-KERNEL/@CONCEPT)))
        (setf (surrogate-value PL-KERNEL/@CONCEPT) dummyConcept)
        (get-description-extension dummyConcept TRUE)
        ;; needed to make `class?' test succeed:
        (update-isa-proposition dummyConcept PL-KERNEL/@CONCEPT :ASSERT-TRUE)
        ;; establish synonym between CONCEPT and CLASS by hand - if we ever
        ;;    wipe out all references to PL-KERNEL/@CLASS this hackery can go:
        (setf (surrogate-value PL-KERNEL/@CLASS) dummyConcept)
        ;; now define CONCEPT to its real definition:
        ;(evaluate (lookup-defconcept-CONCEPT kernelInitFile))
        (evaluate (first kernelKBDefinitions))
        ;; reset @CLASS to point to the redefined description (having to do
        ;;    this is the only reason why this bootstrap is a bit hairy):
        (setf (surrogate-value PL-KERNEL/@CLASS)
          (surrogate-value PL-KERNEL/@CONCEPT))
        ;(load kernelInitFile)
        (foreach definition in (rest kernelKBDefinitions)
            do (evaluate definition))
        (finalize-objects)
        ;; Instantiate all currently existing modules in the knowledge base.
        ;;    Assign a surrogate to each module that doesn't already have one
        ;;    (because it was created during the STELLA bootstrap phase).
        ;;    Also, add each such module to the extension of the class MODULE.
        (foreach mdl in (all-modules)
            do (introduce-module mdl))
        ;; Attach documentation to 'Thing' - this might be avoidable once we
        ;;    create a proper concept definition for THING, since there is no
        ;;    reason why this has to coincide with the STELLA class:
        (let ((thing (get-description (get-stella-class (quote THING) TRUE))))
          (evaluate-string
           "(ASSERT (DOCUMENTATION THING  
           \"The class of all things.  `Thing' is the top-most concept
in the concept hierarchy.\"))"))))))

#|
;; leave this here in case we decide again to load the PL-KERNEL from a file:
(defun (lookup-defconcept-CONCEPT CONS) ((file STRING))
  ;; Find the definition of CONCEPT in `file' and return the result.
  ;; Assumes the definition is right at the beginning of the kernel init file.
  (let ((definition NIL))
    (within-module (get-stella-module "PL-KERNEL-KB" TRUE)
      (with-input-file (in file)
        (foreach exp in (s-expressions in)
            where (cons? exp)
            do (setq definition exp)
               (if (eql? (second definition) (quote PL-KERNEL/CONCEPT))
                   (break)
                 (setq definition NULL))))
      (return definition))))
|#

(startup-time-progn
  (setq *pl-kernel-kb-definitions*
    ;; this is intentionally not a backquote to avoid the generation
    ;; of tons of ugly and unnecessary cons tree building code:
    '(

            
    ;;
  ;;;;;;
;;;;;;;;;; PL-KERNEL Definitions
  ;;;;;;
    ;;

(defconcept CONCEPT (?x RELATION)
  :documentation "The class of reified unary relations.  The Powerloom
notion of `concept' corresponds to the object-oriented notion of `class'.
From a logic standpoint, the notion of a concept is hard to distinguish
from the notion of `unary relation'.  The conceptual distinction is
best illustrated in the domain of linguistics, where concepts are
identified with collective nouns while unary relations are identified
with adjectives.  For example, `Rock' is a concept, while `rocky' is a
unary relation."
  :axioms (and (synonym CONCEPT CLASS)
               (closed CONCEPT)))

(defconcept RELATION (?x SET)
  :documentation "The class of relations.  This includes all concepts and
all functions."
  :axioms (closed RELATION))

(defconcept FUNCTION (?r RELATION)
  :documentation "A relation is a function if its last argument
is a function of its first n-1 arguments, i.e., if it is a single-valued
relation.  Functions explicitly declared as such differ from relations
in that they may appear syntactically as a term applied to n-1 arguments.
For example, to express the sentence \"two plus two equals four\", because
`+' is a function we can write `(= (+ 2 2) 4)'.  The same sentence written
in relational syntax would look like `(+ 2 2 4)'.  If a relation is
introduced using the `defrelation' syntax and also declared to be
single-valued, the functional syntax does not apply; only the explicit
use of `deffunction' sanctions the use of that syntax."
  :axioms (closed FUNCTION))


  ;;
;;;;;; Meta-classes:
  ;;

(defconcept AGGREGATE (?a)
  :documentation "?a is an aggregate")

(defconcept COLLECTION (?c AGGREGATE)
  :documentation "The class of all collections.  This includes all sets,
lists, concepts, and relations."
  :axioms (ABSTRACT COLLECTION))

(defconcept DUPLICATE-FREE-COLLECTION (?c COLLECTION)
  :documentation "?c is free of duplicates"
  :=>> (duplicate-free ?c))

(defconcept SET (?s DUPLICATE-FREE-COLLECTION)
  :documentation "This class denotes the mathematical notion of a 'set';
a collection that has no duplicates.")

(defconcept NUMERIC-SET (?s COLLECTION)
  :documentation "?s is a set of numbers"
  ;:<=> (subset-of ?s NUMBER)
  :axioms (ABSTRACT NUMERIC-SET))

(defconcept LIST (?l COLLECTION)
  :documentation "A list is an ordered collection of elements.  The range
of the function `listof' consists of elements of type `List'."
  :=>> (ordered ?l))

(defconcept GROUP (?c DUPLICATE-FREE-COLLECTION)
  :documentation "?c is a group")

(defconcept STUFF (?s AGGREGATE)
  :documentation "?s is stuff")

(defconcept SCALAR (?x)
  :documentation "The class of scalar quantities.")
(assert (subset-of NUMBER SCALAR))

(defconcept SCALAR-INTERVAL (?x SCALAR)
  :documentation "An interval of scalar quantities. ")

;; INTEGER-INTERVAL is a native STELLA class:
(assert (subset-of INTEGER-INTERVAL SCALAR-INTERVAL))


  ;;
;;;;;; Annotations; Documentation Strings
  ;;

(defrelation phrase (?r (?s STRING))
  :documentation "A phrase is a variablized sentence, a template, that
is used to express individual axiomatic facts as natural language
sentences.  By convention, a phrase contains one or more occurrences
of each variable in a relation or concept definition, it does not
begin with a capital letter, and it has no concluding period.
Systematic attachment of phrases to relations can be leveraged by
tools that generate natural language paraphrases of logic sentences."
  :phrase "?r has phrase ?s")

(defrelation lexeme (?r (?s String))
  :documentation "?s is a lexeme for the relation or individual ?r.
A relation or individual ?r can have zero or more lexemes, words that are
natural langage equivalents of a logical constant.  The same lexeme may be
attached to more than one constant.")
  
(defrelation comment (?x (?s String))
  :documentation "?s is a comment attached to ?x.  Comments are
a generalization of other annotations such as `documentation' and
`issue' strings.")

(defrelation documentation (?x (?s String))
  :documentation "?s is a documentation string attached to ?x.  Some
of the PowerLoom text processing tools look for documentation strings and 
import them into documents."
  :=> (comment ?x ?s))

(defrelation issue (?x (?s String))
  :documentation "?s is an issue attached to ?x.  An issue string 
normally comments on a topic that has not been resolved to everyone's
satisfaction."
  :=> (comment ?x ?s))

(defrelation example ((?r Relation) ?e)
  :documentation "?e is an example of (the use of) ?r.")

(defrelation image-url (?x (?url String))
  :documentation "?url is a URL pointing to an image illustrating ?x.
The Ontosaurus browser looks for `image-url' values attached to
objects it is presenting, and displays them prominently, thereby spiffing
up its displays.")


  ;;
;;;;;; Specialists and Computations
  ;;

(defrelation relation-specialist ((?r RELATION) (?sp COMPUTED-PROCEDURE))
  :documentation
  "Names a 'specialist' (a function) that evaluates an (atomic) relation
proposition during query processing.  This defines an extensible
means for computing with the control stack.  The function is passed
a CONTROL-FRAME that contains the proposition, and returns a keyword
:FINAL-SUCCESS, :CONTINUING-SUCCESS, :FAILURE, or :TERMINAL-FAILURE
that controls the result of the computation."
  :axioms (single-valued RELATION-SPECIALIST))

(defrelation relation-evaluator ((?r RELATION) (?ev COMPUTED-PROCEDURE))
  :documentation
  "Names an 'evaluator' (a function) that evaluates an (atomic) relation
proposition during constraint propagation.  This defines an extensible
means for computing using auxiliary data structures.  The function is passed
a proposition for evaluation which might update the proposition, generate
additional assertions or trigger further evaluations.  Evaluators have to
check the truth-value of the passed-in proposition and perform their actions
accordingly.  An evaluated proposition might be true, false or even unknown
in case the propositon was just newly constructed."
  :axioms (single-valued RELATION-EVALUATOR))

(defrelation relation-computation 
  ((?r RELATION) (?computation COMPUTED-PROCEDURE))
  :documentation
  "Names a 'computation' (a function) that evaluates an (atomic) relation
proposition during query processing.  The function is passed a proposition
for evaluation for which all arguments are bound.  The function
returns a BOOLEAN if it represents a predicate, or some sort of value
if it is a function."
  :=>> (relation-specialist ?r computation-specialist)
  :axioms (single-valued RELATION-COMPUTATION))

(defrelation relation-constraint 
  ((?r RELATION) (?computation COMPUTED-PROCEDURE))
  :documentation
  "Names a 'computation' (a function) that evaluates an (atomic) relation
proposition during query processing.  The function is passed a proposition
for evaluation for which at most one argument is unbound.  The function
returns a BOOLEAN if it represents a predicate, or some sort of value
if it is a function.  If all arguments are bound the function computes whether
the constraint holds.  If all but one argument is bound and the unbound
argument is a pattern variable then the missing value is computed."
  :=>> (relation-specialist ?r constraint-specialist)
  :axioms (single-valued RELATION-CONSTRAINT))

(defrelation handles-reverse-polarity ((?cp COMPUTED-PROCEDURE))
  :documentation
  "Very specialized PowerLoom predicate.  Indicates that a computed procedure
used as a relation specialist is programmed to handle reverse
polarity (*reversePolarity?*).")

(defrelation update-proposition-demon 
  ((?r RELATION) (?computation COMPUTED-PROCEDURE))
  :documentation
  "Names a 'computation' (a function) that is attached (logically)
to ?r  Each time a proposition with predicate ?r has its truth
value updated (even redundantly), the function is applied to that
proposition."
  :axioms (single-valued update-proposition-demon))

(defrelation goes-true-demon 
  ((?r RELATION) (?computation COMPUTED-PROCEDURE))
  :documentation
  "Names a 'computation' (a function) that is attached (logically)
to ?r  Each time a proposition with predicate ?r becomes
true, the function is applied to that proposition."
  :axioms (single-valued GOES-TRUE-DEMON))

(defrelation goes-unknown-demon 
  ((?r RELATION) (?computation COMPUTED-PROCEDURE))
  :documentation
  "Names a 'computation' (a function) that is attached (logically)
to ?r  Each time a proposition with predicate ?r becomes
unknown, the function is applied to that proposition."
  :axioms (single-valued GOES-UNKNOWN-DEMON))

(defrelation goes-false-demon 
  ((?r RELATION) (?computation COMPUTED-PROCEDURE))
  :documentation
  "Names a 'computation' (a function) that is attached (logically)
to ?r  Each time a proposition with predicate ?r becomes
false, the function is applied to that proposition."
  :axioms (single-valued GOES-FALSE-DEMON))


  ;;
;;;;;; Synonyms
  ;;

(defrelation synonym (?term ?synonym)
  :phrase "?synonym is a synonym for ?term"
  :documentation "Assert that `?synonym' is a synonym of `?term'.  This
causes all references to `?synonym' to be interpreted as references
to `?term'.  Retraction eliminates a synonym relation.")

(assert (and (goes-true-demon SYNONYM assert-synonym-demon)
             (goes-unknown-demon SYNONYM retract-synonym-demon)))


  ;;
;;;;;; Collection-forming functions
  ;;

(deffunction collectionof (?m) :-> (?c COLLECTION)
  :documentation "Abstract function existing to subsume 'SETOF'
and 'LISTOF'."
  :axioms (variable-arity collectionof))

(deffunction setof (?m) :-> (?c SET)
  :documentation "Term-forming function that defines an enumerated set
consisting of all function arguments.  `setof' is like `listof' except
that it removes duplicate values."
  :axioms (and (subset-of SETOF COLLECTIONOF)
               (variable-arity SETOF)
               (total SETOF)))

(deffunction listof (?m) :-> (?c LIST)
  :documentation "Term-forming function that defines an ordered list
consisting of all function arguments.  Within logical expressions
`listof' is most commonly used in conjunction with the `member-of'
predicate.  For example the query
	 
  (retrieve ?x (member-of ?x (listof a b c)))
	
returns the constants `a', `b', and `c' on successive iterations."
  :axioms (and (subset-of LISTOF COLLECTIONOF)
               (variable-arity LISTOF)
               (total LISTOF)))


  ;;
;;;;;; Meta-meta:
  ;;

(defrelation HOLDS ((?relation RELATION) ?arguments)
  :documentation "True if the tuple '?arguments' is a member of the
relation '?relation'.  `holds' is a variable arity predicate that takes
a relation as its first argument, and zero or more additional arguments.
It returns values equivalent to a subgoal that has the first argument
as a predicate and the remaining arguments shifted one place to the left.
For `holds' to succeed, the (first) relation argument must be bound --
PowerLoom will NOT cycle through all relations searching for ones that
permit the proof to succeed.  However, users can obtain the same effect
if they choose by using other second-order predicates to generate
relation bindings.  For example, the query
	 
   (retrieve all ?x (and (Relation ?r)
                         (holds ?r Fred ?x)))
	
retrieves all constants for which there is some binary relation that
relates `Fred' to that relation."
  :axioms (and (variable-arity HOLDS)
               (relation-specialist HOLDS holds-specialist)))

(deffunction VALUE ((?function FUNCTION) ?arguments) :-> ?value
  :documentation "True if applying '?function' to '?arguments'
yields the value '?value'.  The `value' predicate is the analog
of `holds', except that it applies to functions instead of relations."
  :axioms (and (variable-arity VALUE)
               (relation-specialist VALUE value-specialist)))

(defrelation IST ((?context CONTEXT) (?p PROPOSITION))
  :documentation "True if proposition '?p' is true in context '?context'.
The `IST' (is true) relation allows one to evaluate a query or rule in more
than one context.  A common use of `IST' is in defining 'lifting axioms'
that import knowledge from one context to another.  For example, below is
a rule that accesses a `patient-record' relation in a module called
`Medical-Kb', 'lifts-out' the `age' column, and imports it into a
`has-age' relation in the current context.
	 
  (<= (has-age ?person ?age)
      (and (has-ssn ?person ?ssn)
           (exists (?1 ?2 ?3 ?4)
              (ist Medical-Kb (patient-record ?ssn ?1 ?2 ?age ?3 ?4)))))
	
"
  :axioms (and (relation-specialist IST IST-specialist)
               (handles-reverse-polarity IST-specialist)))


  ;;
;;;;;; Inference/search control
  ;;

(defrelation CUT (?arguments)
  :documentation "Prolog-like CUT.  Succeeds the first time and
then fails.  Side-effect:  Locally disables query optimization."
  ;; Note: The variable arity exists because zero-arity relations
  ;;    are not supported.
  :axioms (and (variable-arity CUT)
               (relation-specialist CUT cut-specialist)))

(defrelation BOUND-VARIABLES (?arguments)
  :documentation "True if all arguments are bound.  The `bound-variables'
predicate is used as a performance enhancer, to prevent other predicates
from backchaining excessively while searching for bindings of certain of
their arguments. Purists will shun the use of this predicate, but some rules
are inherently inefficient without the addition of some kind of control logic.
Because evaluation of the `bound-variables' predicate evaluation of
predicates being 'guarded', using this predicate has the side-effect
of locally disabling query optimization.  (See `collect-into-set' for
an example that uses `bound-variables'."
  :axioms (and (variable-arity BOUND-VARIABLES)
               (handles-reverse-polarity bound-variables-specialist)
               (relation-specialist
                BOUND-VARIABLES bound-variables-specialist)))

(defrelation FORK ((?test PROPOSITION) (?then PROPOSITION) (?else PROPOSITION))
  :documentation "Fail-based conditional.  If ?test succeeds, evaluates
?then; otherwise evaluates ?else."
  :axioms (relation-specialist FORK fork-specialist))

(defrelation QUERY ((?prop PROPOSITION) ?options)
  :documentation "EXPERIMENTAL search-control relation that allows one to prove
or retrieve bindings for ?prop with modified search control ?options.  The list
of accepted ?options is currently the same as are legal for a top-level `ask'
or `retrieve' query.  The special option value :INHERIT inherits the option
value from the parent or top-level query.  The option pair :INHERIT :ALL
inherits all parent options which can then be further modified by additional
individual option specifications.  At most how many solutions will be generated
is controlled by the :HOW-MANY option (just like in the top level `retrieve').
The default is 1 which is again the same as for `retrieve' but different from
how normal subgoals behave (those behave in a lazy all solutions mode).
The reason for this is that for partial match subqueries, solutions need to be
generated eagerly, therefore, a default of generating all solutions is not
desirable."
  :variable-arity TRUE
  :relation-specialist query-specialist)

     
  ;;
;;;;;; System Relations
  ;;

(defrelation HIDDEN-RELATION ((?r RELATION))
  :documentation "Indicates that ?r is used like an internal data
structure; not for user consumption.")

(deffunction OBSERVED-CARDINALITY-OF ((?r RELATION)) :-> (?card INTEGER)
  :documentation "Used by PowerLoom to record the sizes of class
and relation extensions.  Only filled if the relation extension was
directly accessed by some query."
  :axioms (hidden-relation observed-cardinality-of))

(defrelation POLYMORPHIC ((?r RELATION))
  :documentation "True if ?r' supports polymorphism.")


  ;;
;;;;;; 'instance-of' and 'subset-of'
  ;;

(defrelation instance-of ((?x THING) (?c COLLECTION))
  :documentation "True if ?x is an instance of ?c.  Can
be used to generate concept values of ?c, given an instance ?x."
  :axioms (relation-specialist instance-of instance-of-specialist))

(defrelation type-of ((?c COLLECTION) (?x THING))
  :documentation "True if ?x is a member of the concept ?c."
  :<<=>> (instance-of ?x ?c)
  :axioms (inverse instance-of type-of))

(defrelation subset-of ((?sub COLLECTION) (?super COLLECTION))
  :documentation "True if ?sub is a subset of ?super.  For performance
reasons, the `subset-of' predicate refuses to search for bindings if
both of its variables are unbound.  Implementation note: `subset-of' 
is treated specially internally to PowerLoom, and hence Powerloom does not
permit the augmentation of `subset-of' with additional inference rules.
In otherwords, `subset-of' behaves semantically like an operator instead
of a relation."
  :axioms (relation-specialist subset-of subset-of-specialist))

(defrelation member-of ((?x THING) (?c COLLECTION))
  :documentation "TRUE if ?x is a member of collection ?c.  A common use
of `member-of' is for binding a variable to successive members in a list
or set (see `listof' and `setof')."
  :axioms (and (relation-specialist member-of member-of-specialist)
               (handles-reverse-polarity member-of-specialist)
               (relation-evaluator MEMBER-OF MEMBER-OF-evaluator)))


  ;;
;;;;;; Stuff
  ;;

;; questionable, whether this belongs into the kernel KB:
(defrelation portion-of ((?x AGGREGATE) (?y AGGREGATE))
  :phrase "?x is a portion of (a piece of) ?y"
  :axioms ((transitive portion-of)))


  ;;
;;;;;; domain, range, etc.
  ;;

(defrelation domain ((?r RELATION) (?d COLLECTION))
  :documentation "True if for any tuple `T' that satifies ?r, the first
argument of `T' necessarily belongs to the concept ?d.  `domain' exists
for convenience only and is defined in terms of `nth-domain'.  `domain'
assertions should be avoided, since they create redundant `nth-domain'
propositions (use `nth-domain' directly)."
  :<<=>> (nth-domain ?r 0 ?d)
  ;;; SHOULD A VARIANT OF THIS AXIOM BE MOVED INTO `NTH-DOMAIN' INSTEAD?
  :=>> (=>> (holds ?r ?i ?v) (holds ?d ?i)))

(defrelation range ((?r RELATION) (?rng COLLECTION))
  :documentation "True if for any tuple 'T' that satifies ?r, the last
argument of 'T' necessarily belongs to the concept ?rng.  `range' exists
for convenience only and is defined in terms of `nth-domain'.  `range'
assertions should be avoided, since they create redundant `nth-domain'
propositions (use `nth-domain' directly)."
  :<<= (and (> (arity ?r) 1)
            (nth-domain ?r (- (arity ?r) 1) ?rng))
  ;; separate rule so we don't assert an arity if we run in forward direction:
  :=>> (nth-domain ?r (- (arity ?r) 1) ?rng)
  ;;; SHOULD A VARIANT OF THIS AXIOM BE MOVED INTO `NTH-DOMAIN' INSTEAD?
  :=>> (=>> (holds ?r ?i ?v) (holds ?rng ?v)))

(defrelation nth-domain ((?r RELATION) (?i INTEGER) (?d COLLECTION))
  :documentation "True if the nth value for a tuple T satisfying
?r must belong to the concept ?d.  Argument counting starts at zero."
  :axioms (<<= (nth-domain ?r 0 ?r)
               (concept ?r)))


  ;;
;;;;;; Set and Roleset relations
  ;;

(defrelation closed ((?c COLLECTION))
  :phrase "?c is closed"
  :documentation "The collection ?c is closed if all of its members are known.
Asserting that a relation is closed makes certain computations easier.
For example, suppose that the relation `happy' is closed,
implying that all things that are happy will be asserted as such.
To prove `(not (happy Fred))', PowerLoom can use a negation-as-failure 
proof strategy which returns TRUE if `Fred' cannot be proved to be happy.
Also, if the relation `children' is closed, then a value for the expression
`(range-max-cardinality children Fred)' can be inferred merely by
counting the number of fillers of the `children' role on `Fred'."
  :axioms (and (handles-reverse-polarity closed-specialist)
               (relation-specialist CLOSED closed-specialist)))

(defrelation empty ((?c COLLECTION))
  :documentation "The collection ?c is empty if it has no members.  Note
that for collections possessing open-world semantics, (e.g., most concepts)
the fact that the collection has no known members does not necessarily
imply that it is empty."
  :axioms (and (relation-specialist EMPTY empty-specialist)
               (computed EMPTY)))

(defrelation single-valued ((?c RELATION))
  :documentation "The relation ?c is single-valued if the value of its
last argument is a function of all other arguments.  All functions
are single-valued (see `function')."
  :axioms (and (handles-reverse-polarity single-valued-specialist)
               (relation-specialist SINGLE-VALUED single-valued-specialist)))

(defrelation computed ((?c RELATION))
  :documentation "?c is computed if it can be evaluated only if all of
its input arguments are bound (or all of them if it is a relation).
Considered by the query optimizer when looking for generators.")

(deffunction the-roleset ((?r RELATION) ?i) :-> (?rs SET)
  :documentation "Function that defines a mapping from a relation
and instance to the skolem that (intensionally) denotes the
corresponding set of role fillers."
  ;; THIS WOULD BE GOOD IF WE COULD AUTOMATICALLY INSTANTIATE THE KAPPA
  ;;    IN BOTH DIRECTIONS:
  ;:<=> (= (kappa ?v (holds ?r ?i ?v)) ?rs)
;; THIS MAY NOT BE WORTH THE OVERHEAD, PLUS IT UNCOVERS A BUG:
;  :=>> (and (SET ?rs)
;            (=>> (range ?r ?range) (subset-of ?rs ?range)))
  ;; OOPS: POWERLOOM BACKWARD CHAINS ON THIS (ELIMINATE FOR NOW; RESTORE
  ;;    WHEN WE CAN FORWARD CHAIN ON COMPLEX ANTECEDENTS):
;  :axioms (=> (and (the-roleset ?subR ?i ?subRS)
;                   (the-roleset ?superR ?i ?superRS)
;                   (subset-of ?subR ?superR))
;              (subset-of ?subRS ?superRS))
  )

(deffunction fillers ((?r RELATION) ?i) :-> (?members SET)
  :documentation "Given a relation ?r and instance ?i, returns
a set of known fillers of ?r applied to ?i.  IMPORTANT: this also collects
intensional fillers such as skolems that might be identical extensionally."
  :<<= (and (bound-variables ?r ?i)
            (collect-into-set (setofall ?v (holds ?r ?i ?v)) ?members))
  :axioms (computed FILLERS))

(deffunction cardinality ((?c SET)) :-> (?card INTEGER)
  :documentation "Function that returns the cardinality of a set."
  :<<=  (and (closed ?c)
             (length-of-list (collect-into-set ?c) ?card)))

(defconcept frame-predicate ((?c RELATION))
  :documentation "A frame predicate is a second-order relation that
is used to describe constraints on the set of fillers for a binary
relation applied to an instance.  Examples of frame predicates are
`range-cardinality', `range-type', and `numeric-minimum'.  Frame predicates
are typically used to capture the kinds of relations manipulated
by description logic systems such as USC/ISI's Loom system.")
  
;; THIS REALLY NEEDS A SPECIALIST TO COMPUTE A MOST SPECIFIC TYPE:
(defrelation range-type ((?r RELATION) ?i (?type COLLECTION))
  :documentation
  "Relation that specifies a type/range of the relation ?r applied to ?i.
Multiple range types may be asserted for a single pair <?r,?i>.  Technically,
a retrieval of types for a given pair should include all supertypes
(superconcepts) of any type that is produced, but for utility's sake,
only asserted or directly inferrable types are returned."
  :axioms (=>> (and (range-type ?r ?i ?type)
                    ;; avoid rules that are redundant to `nth-domain' statements:
                    (fail (nth-domain ?r 1 ?type)))
               (forall ?v (=>> (holds ?r ?i ?v) (holds ?type ?v))))
  :<<=>> (subset-of (the-roleset ?r ?i) ?type)
  :<<= (and (bound-variables ?r ?i ?type)
            (fork (and (single-valued ?r)
                       (exists ?v (holds ?r ?i ?v)))
                  ;; single-valued test:
                  (exists ?v (and (holds ?r ?i ?v)
                                  (holds ?type ?v)))
                  ;; multiple-valued test:
                  (or (and (or (closed ?r)
                               (closed (the-roleset ?r ?i)))
                           (forall ?v (=> (holds ?r ?i ?v) (holds ?type ?v))))
                      (exists (?superR ?superVT)
                              (and (subset-of ?r ?superR)
                                   (range-type ?superR ?i ?superVT)
                                   (subset-of ?superVT ?type))))))
  :computed TRUE
  :frame-predicate TRUE
  :relation-specialist range-type-specialist)

(defrelation range-cardinality-lower-bound ((?r RELATION) ?i (?lb INTEGER))
  :documentation "Relation that specifies a lower bound on the cardinality 
of the set of fillers of the relation ?r applied to ?i.  The difference
between `range-cardinality-lower-bound' and `range-min-cardinality' is
subtle but significant.   Suppose we state that nine is a lower bound
on the number of planets in the solar system, and then ask if eight is
(also) a lower bound:
	 
   (assert (range-cardinality-lower-bound hasPlanets SolarSystem 9))
   (ask (range-cardinality-lower-bound hasPlanets SolarSystem 8))  ==> TRUE
	
PowerLoom will return TRUE.  However if we ask if the minimum cardinality
of the solar system's planets is eight, we get back UNKNOWN
	 
   (ask (range-min-cardinality hasPlanets SolarSystem 8)) ==> UNKNOWN
	
because eight is not the tightest lower bound."
  :axioms (<<= (range-cardinality-lower-bound ?r ?i ?lb)
               (and (bound-variables ?r ?i ?lb)
                    (=< ?lb (range-min-cardinality ?r ?i))))
  :axioms (=>> (range-cardinality-lower-bound ?r ?i ?lb)
               (>= (cardinality (the-roleset ?r ?i)) ?lb))
  :axioms (and (frame-predicate RANGE-CARDINALITY-LOWER-BOUND)
               (relation-specialist
                RANGE-CARDINALITY-LOWER-BOUND range-min-cardinality-specialist)
                (handles-reverse-polarity range-min-cardinality-specialist)))

(defrelation range-cardinality-upper-bound ((?r RELATION) ?i (?ub INTEGER))
  :documentation "Relation that specifies an upper bound on the cardinality 
of the set of fillers of the relation ?r applied to ?i. (see the discussion
for `range-cardinality-lower-bound')."
  :axioms (<<= (range-cardinality-upper-bound ?r ?i ?ub)
               (and (bound-variables ?r ?i ?ub)
                    (>= ?ub (range-max-cardinality ?r ?i))))
  :axioms (=>> (range-cardinality-upper-bound ?r ?i ?ub)
               (=< (cardinality (the-roleset ?r ?i)) ?ub))
  :axioms (and (frame-predicate RANGE-CARDINALITY-UPPER-BOUND)
               (relation-specialist
                RANGE-CARDINALITY-UPPER-BOUND range-max-cardinality-specialist)
               (handles-reverse-polarity range-max-cardinality-specialist)))

(deffunction range-cardinality ((?r RELATION) ?i) :-> (?card INTEGER)
  :documentation "Function that returns the cardinality of the set
of fillers of the relation ?r applied to ?i.  The cardinality function
returns a value only when the relations `range-min-cardinality' and
`range-max-cardinality' compute identical values, i.e., when the
best lower and upper bounds on the cardinality are equal.  Each of
these bounding functions employs a variety of rules to try and
compute a tight bound."
  :<=> (and (range-min-cardinality ?r ?i ?card)
            (range-max-cardinality ?r ?i ?card))
#|
  :axioms (<<= (range-cardinality ?r ?i ?card)
               (and (range-min-cardinality ?r ?i ?card)
                    (range-max-cardinality ?r ?i ?card)))
|#
  :axioms (=>> (range-cardinality ?r ?i ?card)
               (= (cardinality (the-roleset ?r ?i)) ?card))
  :axioms (and (frame-predicate range-cardinality)
               (computed range-cardinality)))

(deffunction range-min-cardinality ((?r RELATION) ?i) :-> (?minCard INTEGER)
  :documentation "Returns the strictest computable lower bound on the
cardinality of the set of fillers of the relation ?r applied to ?i.
(see the discussion for `range-cardinality-lower-bound')."
  ;; :<~ (range-cardinality-lower-bound ?r ?i ?minCard)
  ;; Do we need this? -tar
  :<<= (or (and (single-valued ?r)
                (exists ?v (holds ?r ?i ?v))
                (= ?minCard 1))
           ;; quick proof missed; try complex proof:
           (maximum-value
            (collect-into-set
             (setofall 
              ?m (or (>= (cardinality (the-roleset ?r ?i)) ?m)
                     (= ?m 0)
                     (length-of-list (fillers ?r ?i) ?m)
                     (exists ?subR
                             (and (subset-of ?subR ?r)
                                  (>= (cardinality (the-roleset ?subR ?i))
                                      ?m)))
                     )))
            ?minCard))
  :axioms (and (frame-predicate RANGE-MIN-CARDINALITY)
               #|(computed RANGE-MIN-CARDINALITY)
               ;; NOT SURE IF WE NEED A SPECIALIST HERE: -rmm
               (relation-specialist
                RANGE-MIN-CARDINALITY range-min-cardinality-specialist)
                |#
               ))

(deffunction range-max-cardinality ((?r RELATION) ?i) :-> (?maxCard INTEGER)
  :documentation "Returns the strictest computable upper bound on the
cardinality of the set of fillers of the relation ?r applied to ?i.
(see the discussion for `range-cardinality-lower-bound')."
   ;; :<~ (range-cardinality-upper-bound ?r ?i ?maxCard)
   ;; Do we need this?  -tar
  :<<= (or (and (single-valued ?r)
                (exists ?v (holds ?r ?i ?v))
                (= ?maxCard 1))
           ;; quick proof missed; try complex proof:
           (minimum-value
            (collect-into-set
             (setofall
              ?m (or (=< (cardinality (the-roleset ?r ?i)) ?m)
                     (and (single-valued ?r)
                          (= ?m 1))
                     ;; BUG: 'empty' USED AS GENERATOR:
                     (and (empty (the-roleset ?r ?i))
                          (= ?m 0))
                     (and (closed ?r)
                          (range-min-cardinality ?r ?i ?m))
                     (exists ?superR
                             (and (subset-of ?r ?superR)
                                  (=< (cardinality (the-roleset ?superR ?i))
                                      ?m)))
                     )))
            ?maxCard))
  :axioms (and (frame-predicate RANGE-MAX-CARDINALITY)
               (=> (exists (?min) (and (range-min-cardinality ?r ?i ?min)
                                       (> ?min ?max)))
                   (not (range-max-cardinality ?r ?i ?max)))
               #|
               (computed RANGE-MAX-CARDINALITY)
               (relation-specialist
                RANGE-MAX-CARDINALITY range-max-cardinality-specialist)
                |#
               ))

(deffunction qualified-range-min-cardinality ((?r RELATION) ?i (?q COLLECTION))
  :-> (?card INTEGER)
  :documentation "Function that returns the minimum cardinality of the set of
fillers of type ?q of the relation ?r applied to ?i.  NOT YET IMPLEMENTED."
  #|
  :=> (>= (cardinality (setofall ?v (and (holds ?r ?i ?v) (holds ?q ?v))))
          ?card)
  |#
  :axioms (and (frame-predicate QUALIFIED-range-min-cardinality)
	       (computed QUALIFIED-range-min-cardinality)))

(deffunction qualified-range-max-cardinality ((?r RELATION) ?i (?q COLLECTION))
  :-> (?card INTEGER)
  :documentation "Function that returns the maximum cardinality of the set of
fillers of type ?q of the relation ?r applied to ?i.  NOT YET IMPLEMENTED."
  :axioms (and (frame-predicate QUALIFIED-range-max-cardinality)
               (computed QUALIFIED-range-max-cardinality)))

(deffunction qualified-range-cardinality ((?r RELATION) ?i (?q COLLECTION))
  :-> (?card INTEGER)
  :documentation "Function that returns the cardinality of the set of
fillers of type ?q of the relation ?r applied to ?i.  The cardinality function
returns a value only when the relations `qualified-range-min-cardinality' and
`qualified-range-max-cardinality' compute identical values, i.e., when the
best lower and upper bounds on the cardinality are equal.  Each of
these bounding functions employs a variety of rules to try and
compute a tight bound.  NOT YET IMPLEMENTED."
  #|
  :<<=>> (and (qualified-range-cardinality-lower-bound ?r ?i ?q ?card)
              (qualified-range-cardinality-upper-bound ?r ?i ?q ?card))
  |#
  :axioms (and (frame-predicate QUALIFIED-range-cardinality)
               (computed QUALIFIED-range-cardinality)))


(deffunction numeric-interval ((?x NUMERIC-SET))
  :-> (?interval INTEGER-INTERVAL)
  :documentation "Function that returns an interval representing
the range of allowable numeric values for its members."
  :=>> (SCALAR-INTERVAL ?interval))

(defrelation numeric-minimum ((?r RELATION) ?i (?n NUMBER))
  :documentation "Relation that specifies a lower bound '?n' on any numeric
value that can belong to the set of fillers of the relation ?r applied to ?i."
  :<<=>> (>= (interval-lower-bound (numeric-interval (the-roleset ?r ?i))) ?n)
  :axioms (frame-predicate numeric-minimum))

(defrelation numeric-maximum ((?r RELATION) ?i (?n NUMBER))
  :documentation "Relation that specifies an upper bound '?n' on any numeric
value that can belong to the set of fillers of the relation ?r applied to ?i."
  :<<=>> (=< (interval-upper-bound (numeric-interval (the-roleset ?r ?i))) ?n)
  :axioms (frame-predicate numeric-maximum))

(deffunction interval-cache-of (?x) :-> (?b INTERVAL-CACHE)
  :documentation "Binds an instance ?x of type NUMBER or QUANTITY to a 
structure that records its tightest lower and upper bounds."
  :axioms (hidden-relation INTERVAL-CACHE-OF))


  ;;
;;;;;; Relation Hierarchies
  ;;

(defrelation direct-subrelation ((?r RELATION) (?sub RELATION))
  :documentation "True iff ?sub is a direct subrelation of ?r; written
in set notation, ?sub < ?r, and there is no ?s such that ?sub < ?s < ?r.
This relation will generate bindings for at most one unbound argument."
  :axioms (relation-specialist direct-subrelation
                               relation-hierarchy-specialist))

(defrelation direct-superrelation ((?r RELATION) (?super RELATION))
  :documentation "True iff ?super is a direct superrelation of ?r;
in set notation, ?super > ?r, and there is no ?s such that ?super > ?s > ?r.
This relation will generate bindings for at most one unbound argument."
  :axioms (and (inverse direct-superrelation direct-subrelation)
               (relation-specialist direct-superrelation
                                    relation-hierarchy-specialist)))

(defrelation subrelation ((?r RELATION) (?sub RELATION))
  :documentation "True iff ?sub is a subrelation of ?r; written in set
notation, ?sub =< ?r.  This relation will generate bindings for at most
one unbound argument."
  :axioms (relation-specialist subrelation
                               relation-hierarchy-specialist))

(defrelation superrelation ((?r RELATION) (?super RELATION))
  :documentation "True iff ?super is a superrelation of ?r; written in set
notation, ?super >= ?r.  This relation will generate bindings for at most
one unbound argument."
  :axioms (and (inverse superrelation subrelation)
               (relation-specialist superrelation
                                    relation-hierarchy-specialist)))

(defrelation proper-subrelation ((?r RELATION) (?sub RELATION))
  :documentation "True iff ?sub is a proper subrelation of ?r; written in
set notation, ?sub < ?r.  This relation will generate bindings for at most
one unbound argument."
  :axioms (relation-specialist proper-subrelation
                               relation-hierarchy-specialist))

(defrelation proper-superrelation ((?r RELATION) (?super RELATION))
  :documentation "True iff ?super is a proper superrelation of ?r; written in
set notation, ?super > ?r.  This relation will generate bindings for at most
one unbound argument."
  :axioms (and (inverse proper-superrelation proper-subrelation)
               (relation-specialist proper-superrelation
                                    relation-hierarchy-specialist)))

(defrelation equivalent-relation ((?r RELATION) (?equiv RELATION))
  :documentation "True if ?r is equivalent to ?equiv; written in set notation,
?r = ?equiv.  This relation will generate bindings for at most one unbound
argument."
  :axioms (relation-specialist equivalent-relation
                               relation-hierarchy-specialist))


  ;;
;;;;;; Sets
  ;;

;;; TO DO: Implement properly or eliminate:
(deffunction union-of ((?s1 COLLECTION) (?s2 COLLECTION)) :-> (?union SET)
  :documentation "True if the union of the collections ?s1 and ?s2
equals ?union."
  ;; POWERLOOM IS NOT ABLE TO REASON WITH THIS AXIOM:
  ;; COMMENTED OUT BECAUSE POWERLOOM TRIES TO INFER 'member-of'
  ;; RELATIONS USING IT:
  ;:<=> (forall ?i (<=> (or (member-of ?i ?s1)
  ;                         (member-of ?i ?s2))
  ;                     (member-of ?i ?union)))
  )


  ;;
;;;;;; Arithmetic Relations and Functions
  ;;

(deffunction + ((?x NUMBER) (?y NUMBER)) :-> (?z NUMBER)
  :documentation "Function that adds two numbers.")

;; keep constraint information outside for bootstrap reasons:
(assert (and (computed +)
             (relation-constraint + PLUS-constraint)
             (relation-specialist + constraint-specialist)))

(deffunction - ((?x NUMBER) (?y NUMBER)) :-> (?z NUMBER)
  :documentation "Function that subtracts two numbers.")

(assert (and (computed -)
             (relation-constraint - MINUS-constraint)
             (relation-specialist - constraint-specialist)))
         
(deffunction * ((?x NUMBER) (?y NUMBER)) :-> (?z NUMBER)
  :documentation "Function that multiplies two numbers.")

(assert (and (computed *)
             (relation-constraint * TIMES-constraint)
             (relation-specialist * constraint-specialist)))
         
(deffunction / ((?x NUMBER) (?y NUMBER)) :-> (?z NUMBER)
  :documentation "Function that divides two numbers.")

(assert (and (computed /)
             (relation-constraint / DIVIDE-constraint)
             (relation-specialist / constraint-specialist)))
         
(deffunction SQRT ((?x NUMBER)) :-> (?y NUMBER)
  :documentation "Function that returns the positive square root:
?y = sqrt(?x).  For positive and negative roots see relation SQUARE-ROOT"
  :axioms (and (computed SQRT)
	       (relation-constraint SQRT SQRT-constraint)
               (relation-specialist SQRT constraint-specialist)))

(defrelation SQUARE-ROOT ((?x NUMBER) (?y NUMBER))
  :documentation "Relation that returns the positive and negative square roots:
?y = sqrt(?x).  For positive roots only see function SQRT."
  :axioms (and (computed SQUARE-ROOT)
               (relation-specialist SQUARE-ROOT square-root-specialist)))


(defrelation ABSOLUTE-VALUE ((?x NUMBER) (?y NUMBER))
  :documentation "Relation that computes ?y = abs(?x).  If ?x is unbound,
then both positive and negative values of ?y will be returned."
  :axioms (and (computed ABSOLUTE-VALUE)
               (relation-specialist ABSOLUTE-VALUE absolute-value-specialist)))

(defrelation NEGATE ((?x NUMBER) (?y NUMBER))
  :documentation "Relation that computes ?y = - ?x."
  :axioms (and (computed NEGATE)
	       (relation-constraint NEGATE negate-constraint)
               (relation-specialist NEGATE constraint-specialist)))

;;; Introduce 'INEQUALITY-specialist':
(assert (handles-reverse-polarity INEQUALITY-specialist))

;; The following inequalities need to work on items of both
;; number and quantity.  But since there is no common superclass,
;; they will need to be untyped in their arguments.

(defrelation INEQUALITY (?x ?y)
  :documentation "Abstract superrelation of inequality relations."
  :<<= (=< ?x ?y)
  :<<= (>= ?x ?y)
  :axioms (abstract INEQUALITY))

(defrelation < (?x ?y)
  :documentation "True if ?x < ?y."
  :<<= (exists ?z (and (< ?x ?z) (=< ?z ?y)))
  :<<= (exists ?z (and (=< ?x ?z) (< ?z ?y))))

(assert (and (computed <)
             (relation-specialist < INEQUALITY-specialist)
             (relation-evaluator < INEQUALITY-evaluator)))

(defrelation =< (?x ?y)
  :documentation "True if ?x <= ?y."
  :<<= (exists ?z (and (=< ?x ?z) (=< ?z ?y)))
  :<<= (< ?x ?y))

(assert (and (computed =<)
             (relation-specialist =< INEQUALITY-specialist)
             (relation-evaluator =< INEQUALITY-evaluator)))

;;; Tricky:  The inference rules for transitivity and the relation
;;;    between =< and < are not mirrored for >= and >.
;;;    It is assumed that the '<=>' rules for
;;;    GREATER-THAN and GREATER-OR-EQUAL will enable those predicates
;;;    to be 'converted' into one of former two.

(defrelation > (?x ?y)
  :documentation "True if ?x > ?y."
  :<<=>> (< ?y ?x))

(assert (and (computed >)
             (relation-specialist > INEQUALITY-specialist)
             (relation-evaluator > INEQUALITY-evaluator)))

(defrelation >= (?x ?y)
  :documentation "True if ?x >= ?y."
  :<<=>> (=< ?y ?x)
  :<<= (> ?x ?y))

(assert (and (computed >=)
             (relation-specialist >= INEQUALITY-specialist)
             (relation-evaluator >= INEQUALITY-evaluator)))


  ;;
;;;;;; Utility functions
  ;;

(deffunction collect-into-set ((?c COLLECTION)) :-> (?l SET)
  :documentation "Infer as many members of ?c as possible and
collect them into a set ?l.  For example, here is a rule
used to compute bindings for the `fillers' predicate:
	 
  (<= (fillers ?r ?i ?v)
      (and (bound-variables ?r ?i)
           (collect-into-set (setofall ?v (holds ?r ?i ?v)) ?members)))
	
When `?r' and `?i' are bound, the term `(setofall ?v (holds ?r ?i ?v))'
evaluates to a unary relation satisfied for each filler of the relation
in `?r' applied to the instance in `?i'.  `collect-into-set' causes
the extension of this (dynamically-defined) unary relation to be
computed.  Note the use of `bound-variables' to screen out unbound
variables before they are passed to the `setofall' predicate."
  :axioms (relation-specialist COLLECT-INTO-SET collect-into-set-specialist))

;;; TO DO: SHOULD BE REPLACED BY `LENGTH':
(defrelation length-of-list ((?l COLLECTION) (?length INTEGER))
  :documentation "Computes the length of the list or set ?l."
  :axioms (and (computed length-of-list)
               (relation-specialist
                LENGTH-OF-LIST length-of-list-specialist)
               (single-valued LENGTH-OF-LIST)))

(defrelation minimum-value ((?l COLLECTION) (?min NUMBER))
  :documentation "Binds ?min to the minimum of the numbers in the list ?l."
  :axioms (and (relation-specialist
                MINIMUM-VALUE minimum-of-numbers-specialist)
               (single-valued MINIMUM-VALUE)))

(defrelation maximum-value ((?l COLLECTION) (?max NUMBER))
  :documentation "Binds ?max to the maximum of the numbers in the list ?l."
  :axioms (and (relation-specialist
                MAXIMUM-VALUE maximum-of-numbers-specialist)
               (single-valued MAXIMUM-VALUE)))

(defrelation sum ((?l COLLECTION) (?sum NUMBER))
  :documentation "Binds ?sum to the sum of the numbers in the list ?l."
  :axioms (and (relation-specialist
                SUM sum-of-numbers-specialist)
               (single-valued SUM)))

(deffunction project-column ((?i INTEGER) (?c COLLECTION)) :-> (?l LIST)
  :documentation "Project elements in column ?i (zero-based) of the tuples
of ?c and collect them into a list ?l. "
  :axioms (relation-specialist PROJECT-COLUMN project-column-specialist))


  ;;
;;;;;; Statistical functions
  ;;

(defrelation mean-value ((?l COLLECTION) (?mean NUMBER))
  :documentation "Binds ?mean to the mean of the numbers in ?l."
  :axioms (and (computed MEAN-VALUE)
               (relation-specialist MEAN-VALUE mean-of-numbers-specialist)
               (single-valued MEAN-VALUE)))

(defrelation median-value ((?l COLLECTION) (?median NUMBER))
  :documentation "Binds ?median to the median of the numbers in ?l."
  :axioms (and (computed MEDIAN-VALUE)
               (relation-specialist MEDIAN-VALUE median-of-numbers-specialist)
               (single-valued MEDIAN-VALUE)))

(defrelation standard-deviation ((?l COLLECTION) (?sd NUMBER))
  :documentation "Binds ?sd to the standard deviation of the numbers in ?l."
  :axioms (and (computed STANDARD-DEVIATION)
               (relation-specialist
                STANDARD-DEVIATION standard-deviation-specialist)
               (single-valued STANDARD-DEVIATION)))

(defrelation variance ((?l COLLECTION) (?variance NUMBER))
  :documentation "Binds ?variance to the variance of the numbers in ?l."
  :axioms (and (computed VARIANCE)
               (relation-specialist VARIANCE variance-specialist)
               (single-valued VARIANCE)))


  ;;
;;;;;; Literal manipulations
  ;;

(deffunction string-concatenate ((?x1 STRING) (?x2 STRING)) :-> (?x3 STRING)
  :documentation "Concatenate strings ?x1 and ?x2 and bind ?x3 to the result."
  :axioms (and (computed string-concatenate)
               (relation-constraint STRING-CONCATENATE concatenate-constraint)
               (relation-specialist STRING-CONCATENATE constraint-specialist)))

(deffunction substring ((?s STRING) (?start INTEGER) (?end INTEGER))
  :-> (?sub STRING)
  :documentation "Generate the substring of ?s starting at position ?start
(zero-based), ending just before position ?end and bind ?sub to the result.
This is the PowerLoom equivalent to the STELLA method `subsequence'.  In
addition, this function can be used to locate substrings in strings by
supplying values for ?s and ?sub and allowing ?start and ?end to be
bound by the function specialist.  In other words,
      (retrieve all (?start ?end) (substring \"foo\" ?start ?end \"o\"))
 ==>  ?start = 1, ?end = 2,
      ?start = 2, ?end = 3."
  :axioms (and (computed substring)
               (relation-specialist substring subsequence-specialist)))

(deffunction string-match ((?pattern STRING) (?object THING)
                           (?start INTEGER) (?end INTEGER))
  :-> (?match-position INTEGER)
  :documentation "Match ?pattern against ?object between ?start and ?end
(zero-based), and return the position of the first match or fail if no
match exists.  Supplying -1 for ?end indicates the end of ?object.  ?object
can be a named logic object or a string.  ?pattern will eventually allow
support regular expressions, currently it only handles string literals.
Apart from doing to-string coercion on ?object this is somewhat redundant,
since `substring' can generate ?start/?end pairs if its string and
substring arguments are bound."
  :axioms (and (computed string-match)
               (relation-computation string-match string-match-computation)
               (relation-specialist string-match computation-specialist)))

;;; TO DO: FOLD `LENGTH-OF-LIST' INTO THIS:
(deffunction LENGTH ((?x THING)) :-> (?z INTEGER)
  :documentation
  "Function that returns the length of a string or a logical list.
NOT YET IMPLEMENTED FOR LISTS."
  :axioms (and (computed LENGTH)
               (relation-computation LENGTH LENGTH-computation)
               (relation-specialist LENGTH computation-specialist)))


  ;;
;;;;;;
  ;;

;;; Introduce 'computation-specialist' and 'constraint-specialist'
;;;    (defined in 'specialists.ste'):
(assert (COMPUTED-PROCEDURE computation-specialist))
(assert (handles-reverse-polarity computation-specialist))
(assert (COMPUTED-PROCEDURE constraint-specialist))
(assert (handles-reverse-polarity constraint-specialist))

(deffunction object-name (?x) :-> (?c STRING)
  :documentation "The name of the object ?X as a string.  This is just the
name, with module prefixes NOT included."
  :axioms (and (computed object-name)
               (relation-computation object-name
                                     object-name-computation)
               (relation-specialist object-name
                                    computation-specialist)))

(deffunction name-to-object ((?n STRING)) :-> ?o
  :documentation "Find or create the PowerLoom logic object ?o named by
the name ?n in the current module.  We are interpreting the name ?n literally
here, i.e., it is not a print name as assumed by PLI functions and an object
with exactly that name will be looked up or created.  We are intentionally
using a separate function here (instead of folding this into `object-name'),
since we might want to be able to look for an object with a certain name
but not create one if it doesn't exist."
  :axioms (and (computed name-to-object)
               (relation-computation name-to-object
                                     name-to-object-computation)
               (relation-specialist name-to-object
                                    computation-specialist)))


(deffunction arity ((?r RELATION)) :-> (?arity INTEGER)
  :documentation "The number of arguments/domains of the relation '?r'.")

;; moved outside definition of `arity' for bootstrap reasons, since relation
;;    finalization of `nth-domain' needs arity computation to be available:
(assert (and (computed ARITY)
             (relation-specialist ARITY ARITY-specialist)
             (handles-reverse-polarity ARITY-specialist)))

(defrelation variable-arity ((?r Relation))
  :documentation "Asserts that the relation ?r can take a variable
number of arguments."
  :axioms (closed variable-arity))

(defconcept BINARY-RELATION (?r RELATION)
  :documentation "The class of binary relations."
  :<<=>> (and (relation ?r) (arity ?r 2)))

(deffunction inverse ((?r BINARY-RELATION)) :-> ?inverseRelation
  :documentation "Function that returns the inverse relation for ?r.
PERFORMANCE NOTE: for best results there should be only one `(inverse R I)'
assertion per relation pair `R' and `I'.  In that case `R' is viewed as the
canonical relation and `I' simply provides a different access mechanism to
the canonical relation.  In a logic-based KR paradigm inverse relations are
redundant and do not add anything that couldn't be represented or queried
without them, however, sometimes they can provide some extra convenience for
users.  Asserting `(inverse I R)' also will not cause an error but can degrade
backward inference performance due to the extra redundant rule that gets
generated.  If domain rules will be written in terms of both `R' and `I' (as
opposed to only `R'), `(inverse I R)' should be asserted also to get full
inferential connectivity between the two relations."
  :=>> (BINARY-RELATION ?inverseRelation)
  ;; every assertion `(I x y)' forward chains into `(R y x)' and
  ;;    every query  `(I x y)' backward chains into `(R y x)'.
  :=>> (<<=>> (holds ?inverseRelation ?y ?x) (holds ?r ?x ?y))
  :axioms (symmetric inverse))


  ;;
;;;;;; Meta-properties:
  ;;

(defrelation duplicate-free ((?c COLLECTION))
  :documentation "?c is duplicate-free if no two members
denote the same object.")

(defrelation different (?x ?y)
  :documentation "True if no two arguments are the same.  This is equivalent to
`(duplicate-free (list-of ?x ?y ...))' but without the need to generate a
collection object.  The main use for this is to state and test pairwise
inequalities between N entities without having to generate O(N**2) statements."
  :variable-arity TRUE
  :computed TRUE
  :relation-specialist different-specialist)

(defrelation ordered ((?c COLLECTION))
  :documentation "?c is ordered if the ordering of its
members is significant.  Lists are ordered, while sets are not.")

(defrelation commutative ((?r RELATION))
  :documentation "A relation ?r is commutative if its truth value is
invariant with any permutation of its arguments."
  ;; TO DO: Add a rule or specialist to handle this case.
  ;; Also, should this have a definition for functions as well?
  :=>> (=> (binary-relation ?r)
           (symmetric ?r)))

(defrelation reflexive ((?r RELATION))
  :documentation "A binary relation ?r is reflexive if it is always true when
both of its arguments are identical."
  :=>> (binary-relation ?r)
  :<=> (not (irreflexive ?r))

  #|
  ;; more (too) ambitious by ensuring that ?x satisfies all domains of ?r,
  ;; i.e., here we treat domains as constraints rather than inferences.
  :=>> (forall (?x ?d)
         (=> (subset-of (collect-into-set
                         (setofall ?d
                           (nth-domain ?r 0 ?d)))
                        (collect-into-set
                         (setofall ?d
                           (and (nth-domain ?r 0 ?d)
                                (holds ?d ?x)))))
          (holds ?r ?x ?x)))
  |#
  :<= (and (binary-relation ?r) (forall ?x (holds ?r ?x ?x)))
  ;;  Other half of inference rule replaced by specialist:
  :=> (relation-specialist ?r REFLEXIVE-RELATION-specialist)
  :axioms (handles-reverse-polarity REFLEXIVE-RELATION-specialist))

(defrelation irreflexive ((?r RELATION))
  :documentation "A binary relation ?r is irreflexive if it is false when both
of its arguments are identical."
  :=>> (binary-relation ?r)
  :<=> (not (reflexive ?r))

  :<= (and (binary-relation ?r) (forall ?x (not (holds ?r ?x ?x))))
  ;; Other half of inference rule replaced by specialist:
  :=> (relation-specialist ?r IRREFLEXIVE-RELATION-specialist)
  :axioms (handles-reverse-polarity IRREFLEXIVE-RELATION-specialist))

(defrelation symmetric ((?r RELATION))
  :documentation "A binary relation ?r is symmetric if it is commutative."
  :=>> (binary-relation ?r)
  :=>> (commutative ?r)
  :=>> (forall (?x ?y) (<<= (holds ?r ?x ?y) (holds ?r ?y ?x)))
  :<=> (not (antisymmetric ?r)))

(defrelation antisymmetric ((?r RELATION))
  :documentation "A binary relation ?r is antisymmetric if whenever (?r ?x ?y)
is true (?r ?y ?x) is false unless ?x equals ?y."
  :=>> (binary-relation ?r)
  :<=> (not (symmetric ?r))
;;; THIS WE CAN'T INDEX AND IT'S ONLY USEFUL FOR IDENTIFYING SKOLEMS:
;  :=>> (forall (?x ?y)
;         (=> (and (holds ?r ?x ?y)
;                  (holds ?r ?y ?x))
;             (= ?x ?y)))
  :=> (forall (?x ?y)
        (=> (and (holds ?r ?x ?y)
                 (not (= ?x ?y)))
            (not (?r ?y ?x)))))

(defrelation transitive ((?r RELATION))
  :documentation "A binary relation ?r is transitive if (?r ?x ?y)
and (?r ?y ?z) implies that (?r ?x ?z).  Note that functions cannot
be transitive, since their single-valuedness would not allow multiple
different values such as (?r ?x ?y) and (?r ?x ?z) due to the Unique
Names Assumption made by PowerLoom."
  :=>> (and (binary-relation ?r)
            (not (function ?r)))
  :=>> (=> (and (binary-relation ?r) (?r ?x ?y) (?r ?y ?z)) (?r ?x ?z)))

(defrelation total ((?r FUNCTION))
  :documentation "True if the function '?r' is defined for all
combinations of inputs.  By default, functions are not assumed to
be total (unlike Prolog, which 'does' make such an assumption.
For example, if we define a two-argument function `foo' and then retrieve
its value applied to some random instances `a' and `b', we get nothing
back:
	 
   (deffunction foo (?x ?y) :-> ?z)
   (retrieve ?x (= ?x (foo a b)))
	
However, if we assert that `foo' is total, then we get a skolem back
when we execute the same retrieve:
	 
   (assert (total foo))
   (retrieve ?x (= ?x (foo a b)))
	
")

(defrelation abstract ((?r RELATION))
  :documentation "True if there are no direct assertions made
to the relation ?r.")


  ;;
;;;;;; Concept prototypes
  ;;

(deffunction concept-prototype ((?c CONCEPT)) :-> ?i
  :documentation "Function that, given a concept, returns a prototypical
instance that inherits all constraints that apply to any concept member,
and has no additional constraints."
;  :=>> (holds ?c ?i)
  :axioms (and (relation-specialist
                CONCEPT-PROTOTYPE CONCEPT-PROTOTYPE-specialist)
               (total CONCEPT-PROTOTYPE))
  :synonym CLASS-PROTOTYPE)


  ;;
;;;;;; 'member-of', 'instance-of' and 'subset-of' rules
  ;;

;; PROBABLY A BAD IDEA:
#|
(defrule "'member-of' chained with 'subset-of' rule"
  (<= (member-of ?x ?c2)
      (and (bound-variables ?c2)
           (member-of ?x ?c1)
           (subset-of ?c1 ?c2))))
|#

(defrule "'Instance-of' chained with 'subset-of' rule"
  (<= (instance-of ?x ?c2)
      (and (bound-variables ?c2)
           (instance-of ?x ?c1)
           (subset-of ?c1 ?c2))))

(defrule "'Not instance-of' rule"
  (<= (not (instance-of ?x ?c))
      (and (collection ?c) (closed ?c)
           (fail (instance-of ?x ?c)))))

;;; BUG: THIS RULE DOESN'T GET PROPERLY INDEXED YET:
(defrule "Forward 'instance-of' rule"
  (=> (instance-of ?x ?c)
      (and (concept ?c)
           (holds ?c ?x)))
  :forward? TRUE)

;; NOT CLEAR IF 'closed-super-collection' BEHAVES WELL ENOUGH TO
;;    JUSTIFY ITS 'elegance':   -rmm
#|
;; Helper relation:
(defrelation closed-super-collection (?c1 ?c2))

;; TO DO: FIGURE OUT HOW THESE RULES INTERACT WITH REVERSE POLARITY:
(defrule "Intermediate closed collection rule"
  (<= (subset-of ?c1 ?c2)
      (and (bound-variables ?c1 ?c2)
           (concept ?c1)
           (closed-super-collection ?c1 ?closedC)
           (forall ?x (=> (holds ?closedC ?x)
                          (or (holds ?c2 ?x)
                              (not (holds ?c1 ?x)))))))
  :backward? TRUE)

(defrule "Find a closed supercollection"
  (<= (closed-super-collection ?c1 ?c2)
      (and (subset-of ?c1 ?c2) (closed ?c2) (cut)))
  :backward? TRUE)
|#


  ;;
;;;;;; Case-match and partial-match support
  ;;

#|
;; Can't use `defobject' here, since NULL gets coerced to a real NULL by
;; the command evaluator.
;; Also, for now we create this instance via code in `partial-match.ste'
;; so we don't shadow the symbol `STELLA/NULL' which is needed by various
;; PL-KERNEL-KB code files.
(assert (Thing NULL))

;; do not assert anything about NULL, since `null-instance-propositions-exist?'
;; relies on that:
(assert (documentation NULL
         "NULL value instance.  Unifies with any object as part of a
partial query that allows goals with unbound variables to succeed.  Can be
used to assert results of partial queries with unbound arguments."))
|#
  
;;; THESE NEED TO GO SOMEWHERE ELSE:

(defconcept USER-THING (?x)
  ;; this is exactly like thing, except it will have an extension.
  ;; I hate doing this, but Bob and Hans won't build support for
  ;; generating from thing and I've run into numerous occasions
  ;; where I need it.
  :documentation "The class of user-defined things.")

;; General case-match predicate
(defrelation case-match ((?x thing) (?y thing)))

(defrule case-match-rule
    (forall ((?x thing) (?y thing))
      (=> (= ?x ?y)
	  (case-match ?x ?y))))

;; Soft equals relation so the rule optimizer doesn't take away
;; the equals conditions.  For example in the following clauses:

;; (and (parent ?x ?x1)
;;      (parent ?y ?x2)
;;      (= ?x1 ?x2))

;; would be optimized to:

;; (and (parent ?x ?x1)
;;      (parent ?y ?x1))

;; This is not a good thing to do when partial matching.

(defrelation soft-eq ((?x thing) (?y thing)))

(defrule soft-eq-rule
    (forall ((?x thing) (?y thing))
      (=> (= ?x ?y)
	  (soft-eq ?x ?y))))


  ;;
;;;;;; Contexts and modules:
  ;;

;;; DOCUMENT AND RENAME:
(deffunction context-of (?x) :-> (?c CONTEXT)
  :axioms (and (computed context-of)
               (relation-computation context-of
                                     context-of-computation)
               (relation-specialist context-of
                                    computation-specialist)))


  ;;
;;;;;; Disjointness helper relations
  ;;

;; TO DO: CONSIDER GOING TO EXPENSIVE DISJOINTNESS AFTER META-LEVEL
;;    CACHING IS IMPLEMENTED:
(defrelation disjoint ((?c1 COLLECTION) (?c2 COLLECTION))
  :documentation "True if the intersection of ?c1 and ?c2 is empty."
  :irreflexive TRUE
  ;:<=> (not (exists ?i (and (member-of ?i ?c1)
  ;                          (member-of ?i ?c2))))
  :<<= (cheap-disjoint ?c1 ?c2))

(defrelation mutually-disjoint-collection ((?s SET))
  :documentation "True if the members of ?s are pair-wise disjoint.  Used
most often to expresse disjointness constraints between concepts.  For
example
	 
   (mutually-disjoint-collection (setof MAN WOMAN))
	
states that the concepts MAN and WOMAN are disjoint.
"
  :=>> (=> (and (member-of ?c1 ?s)
                (member-of ?c2 ?s)
                (not (= ?c1 ?c2)))
           (disjoint ?c1 ?c2)))

(defrelation covering ((?c COLLECTION) (?cover SET))
  :documentation "True if ?c is a subset of the union of all
collections in the set ?cover (see `disjoint-covering').")  

(defrelation disjoint-covering ((?c COLLECTION) (?disjointCover SET))
  :documentation "True if ?c is covered by the collections in ?disjointCover
and if the member sets in ?disjointCover are mutually-disjoint.  For
example the concepts `Igneous-Rock', `Metamorphic-Rock', and
`Sedimentary-Rock' together form a disjoint covering of the concept `Rock'."
  :<<= (and (covering ?c ?disjointCover)
            (mutually-disjoint-collection ?disjointCover)))

(defrelation cheap-disjoint ((?c1 COLLECTION) (?c2 COLLECTION))
  :documentation "Find proof of disjointness without using refutation."
  :<<= (and (has-partition-membership ?c1)
            (has-partition-membership ?c2)
            (exists (?proposition ?partition1 ?partition2)
                    (and
                     (partition-membership ?c1 ?proposition ?partition1)
                     (partition-membership ?c2 ?proposition ?partition2)
                     (not (= ?partition1 ?partition2))))))

(defrelation refutation-disjoint ((?c1 COLLECTION) (?c2 COLLECTION))
  :documentation "Assume that an instance belongs to both ?c1 and ?c2
and look for a clash."
  :axioms (relation-specialist 
           REFUTATION-DISJOINT REFUTATION-DISJOINT-specialist))

;;; Hidden predicates for computing (cheap) disjointness:

(defrelation has-partition-membership ((?c COLLECTION))
  :documentation "TRUE if one or more PARTITION-MEMBERSHIP tuples
exist with ?c as the first argument.  FALSE if none exists.
Unknown if a derivation of PARTITION-MEMBERSHIP tuples has not
occurred.  A specialist for this relation creates PARTITION-MEMBERSHIP
tuples as a side-effect of querying this predicate."
  :axioms (and (hidden-relation HAS-PARTITION-MEMBERSHIP)
               (relation-specialist 
                HAS-PARTITION-MEMBERSHIP HAS-PARTITION-MEMBERSHIP-specialist)))

(defrelation partition-membership 
  ((?c COLLECTION) (?proposition PROPOSITION) (?partition COLLECTION))
  :documentation "Caches the fact that ?partition is a partition of
a mutually-disjoint collection, and that ?c is a subset of ?partition.
Used to support rapid computation of pairwise disjointness."
  :axioms (hidden-relation PARTITION-MEMBERSHIP))

            
))) ;; end of *pl-kernel-kb-definitions*


(startup-time-progn
  (initialize-kernel-kb))
