;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;; BEGIN LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
; Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          ;
;                                                                            ;
; The contents of this file are subject to the Mozilla Public License        ;
; Version 1.1 (the "License"); you may not use this file except in           ;
; compliance with the License. You may obtain a copy of the License at       ;
; http://www.mozilla.org/MPL/                                                ;
;                                                                            ;
; Software distributed under the License is distributed on an "AS IS" basis, ;
; WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   ;
; for the specific language governing rights and limitations under the       ;
; License.                                                                   ;
;                                                                            ;
; The Original Code is the PowerLoom KR&R System.                            ;
;                                                                            ;
; The Initial Developer of the Original Code is                              ;
; UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          ;
; 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               ;
;                                                                            ;
; Portions created by the Initial Developer are Copyright (C) 1997-2010      ;
; the Initial Developer. All Rights Reserved.                                ;
;                                                                            ;
; Contributor(s):                                                            ;
;                                                                            ;
; Alternatively, the contents of this file may be used under the terms of    ;
; either the GNU General Public License Version 2 or later (the "GPL"), or   ;
; the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   ;
; in which case the provisions of the GPL or the LGPL are applicable instead ;
; of those above. If you wish to allow use of your version of this file only ;
; under the terms of either the GPL or the LGPL, and not to allow others to  ;
; use your version of this file under the terms of the MPL, indicate your    ;
; decision by deleting the provisions above and replace them with the notice ;
; and other provisions required by the GPL or the LGPL. If you do not delete ;
; the provisions above, a recipient may use your version of this file under  ;
; the terms of any one of the MPL, the GPL or the LGPL.                      ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; END LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; Version: query.ste,v 1.190 2010/09/10 02:30:11 hans Exp

;;; Incremental backward chaining.

(in-package "STELLA")

(in-module "LOGIC")


  ;;
;;;;;; Inference Levels
  ;;

(defclass INFERENCE-LEVEL (STANDARD-OBJECT)
  :slots ((keyword :type KEYWORD))
  :documentation "This class hierarchy is used to choose the
level of inference applied when dispatching queries (canned
or ad hoc).")

(defclass NORMAL-INFERENCE-LEVEL (INFERENCE-LEVEL)
  :documentation "The normal inference level employs all proof strategies
except disjunctive implication introduction and refutation.")

(defclass BACKTRACKING-INFERENCE-LEVEL (NORMAL-INFERENCE-LEVEL)
  :documentation "Specifies subsumption level inference plus backtracking.")

(defclass SUBSUMPTION-INFERENCE-LEVEL (BACKTRACKING-INFERENCE-LEVEL)
  :documentation "Specifies lookup augmented with cached
subsumption links and equality reasoning.")

(defclass SHALLOW-INFERENCE-LEVEL (SUBSUMPTION-INFERENCE-LEVEL)
  :documentation "Specifies lookup of assertions plus simple frame computations.")

(defclass ASSERTION-INFERENCE-LEVEL (SUBSUMPTION-INFERENCE-LEVEL)
  :documentation "Specifies lookup of assertions only.")

(defclass REFUTATION-INFERENCE-LEVEL (NORMAL-INFERENCE-LEVEL)
  :documentation "Normal inference augmented by refutation proof strategy.")

(defglobal NORMAL-INFERENCE NORMAL-INFERENCE-LEVEL
  (new NORMAL-INFERENCE-LEVEL :keyword :NORMAL))
(defglobal BACKTRACKING-INFERENCE BACKTRACKING-INFERENCE-LEVEL
  (new BACKTRACKING-INFERENCE-LEVEL :keyword :BACKTRACKING))
(defglobal SUBSUMPTION-INFERENCE SUBSUMPTION-INFERENCE-LEVEL
  (new SUBSUMPTION-INFERENCE-LEVEL :keyword :SUBSUMPTION))
(defglobal SHALLOW-INFERENCE SHALLOW-INFERENCE-LEVEL 
  (new SHALLOW-INFERENCE-LEVEL :keyword :SHALLOW))
(defglobal ASSERTION-INFERENCE ASSERTION-INFERENCE-LEVEL
  (new ASSERTION-INFERENCE-LEVEL :keyword :ASSERTION))
(defglobal REFUTATION-INFERENCE REFUTATION-INFERENCE-LEVEL
  (new REFUTATION-INFERENCE-LEVEL :keyword :REFUTATION))

(defspecial *inferenceLevel* NORMAL-INFERENCE-LEVEL NORMAL-INFERENCE
  :documentation "Specifies the level/depth of inference applied
during a query.  Possible values are:
  :ASSERTION -- database lookup with no inheritance;
  :SHALLOW -- includes database lookup, computed predicates and specialists;
  :SUBSUMPTION -- shallow plus cached subsumption links and equality reasoning;
  :BACKTRACKING -- all of the above plus backtracking over rules;
  :NORMAL -- all of the above plus universal introduction;
  :REFUTATION -- all of the above plus disjunctive implication introduction and refutation.")

(defslot MODULE inference-level :type INFERENCE-LEVEL
         :documentation
         "The default inference level used for inferences in a module.")

(defun (current-inference-level NORMAL-INFERENCE-LEVEL) ()
  :documentation "Return the current inference level that is active in the
current query, the current module, or, otherwise, globally."
  :public? TRUE :command? TRUE
  ;; Return the inference level for *module*, or 'NORMAL-INFERENCE'
  ;;    if no level has been set.
  (let ((level
         (choose (defined? *queryIterator*)
                 (inference-level *queryIterator*)
                 (inference-level *module*))))
    (if (defined? level)
        (return level)
      (return *inferenceLevel*))))

(defun (get-inference-level INFERENCE-LEVEL) ((levelKeyword KEYWORD))
  ;; Return the inference level corresponding to 'levelKeyword'.
  (case levelKeyword
    (:NORMAL (return NORMAL-INFERENCE))
    (:SHALLOW (return SHALLOW-INFERENCE))
    (:ASSERTION (return ASSERTION-INFERENCE))
    (:SUBSUMPTION (return SUBSUMPTION-INFERENCE))
    (:BACKTRACKING (return BACKTRACKING-INFERENCE))
    (:REFUTATION (return REFUTATION-INFERENCE))
    (otherwise
     (warn "Illegal inference level: " levelKeyword "." EOL
            "   Legal values are :ASSERTION :SHALLOW :SUBSUMPTION :BACKTRACKING :NORMAL :REFUTATION."
            EOL)))
  (return *inferenceLevel*) )

(defun (set-inference-level KEYWORD) ((level NAME) (module NAME))
  :documentation "Set the inference level of `module' to the level specified
by 'levelKeyword'.  If `module' is NULL, set the level globally."
  :command? TRUE :public? TRUE :evaluate-arguments? FALSE
  (let ((theModule (coerce-to-module module TRUE))
        (theLevel (keywordify (coerce-to-string level))))
    (when (null? module)
      (setq theModule NULL))
  (return (call-set-inference-level theLevel theModule))))

(defun (call-set-inference-level KEYWORD) ((levelKeyword KEYWORD)
                                           (module MODULE))
  :documentation "Set the inference level of `module' to the level specified
by 'levelKeyword'.  If `module' is NULL and we are inside a query, set the
level of the current query iterator.  Otherwise, set the level globally."
  :public? TRUE
  (let ((level (get-inference-level levelKeyword)))
    (cond ((defined? module)
           (setf (inference-level module) level))
          ((defined? *queryIterator*)
           (setf (inference-level *queryIterator*) level))
          (otherwise
           (setq *inferenceLevel* level)))
    (return (keyword level))))

(defspecial *dontUseDefaultKnowledge?* BOOLEAN FALSE
  :documentation "Controls whether queries use default knowledge or not.")

(defun (using-default-knowledge? BOOLEAN) ()
  ;; Return TRUE if we are allowing proofs to reference default knowledge.
  :globally-inline? TRUE
  (return (not *dontUseDefaultKnowledge?*)) )


  ;;
;;;;;; More Inference Parameters
  ;;

;;; These variables control kinds of inference strategies used by
;;;    the query processor.

(defglobal *maximum-backtracking-depth* INTEGER *default-maximum-depth*
  :documentation "Value for the maximum depth allowable during
backtrack search.")

(defspecial *type-check-strategy* KEYWORD :LOOKUP
  :documentation "Determines whether there is a slow but thorough type test
when variables are bound, a fast but very shallow one, or none.  Values
are :NONE, :LOOKUP, :DISJOINT.  The default is :LOOKUP.")

(defglobal *duplicate-subgoal-strategy* KEYWORD :DUPLICATE-GOALS
  :documentation "Determines what kind of duplicate subgoal test to use.  Choices
are :DUPLICATE-RULES, :DUPLICATE-GOALS, and :DUPLICATE-GOALS-WITH-CACHING.")

(defglobal *duplicate-goal-search-depth* INTEGER NULL
  :documentation "Sets the maximum number of frames search looking for
a duplicate subgoal.  Default value is infinite.  Possibly this should
be replaced by a function that increases with depth of search.")

(defglobal *duplicate-rule-search-depth* INTEGER NULL
  :documentation "Set limit on number of frames searched looking for
a duplicate rule.  Default value is infinite.")

(defglobal *globally-closed-collections?* BOOLEAN FALSE
  :documentation "If TRUE, all collections are assumed to be closed.")

(defspecial *generate-all-proofs?* BOOLEAN FALSE
  :documentation "If TRUE, the backchainer follows all lines of proof
for each goal, rather than switching to a new goal once the first proof
of a goal is achieved.  The partial matcher sets this variable to
TRUE to force generation of proofs having possibly different
weights.")

(defun trace-subgoals ()
  (set-feature :trace-subgoals))
(defun untrace-subgoals ()
  (unset-feature :trace-subgoals))
(defun trace-rules ()
  (add-trace :PROPAGATE))
(defun untrace-rules ()
  (drop-trace :PROPAGATE))

(defun (toggle-trace-subgoals STRING) ()
  (if (member? *current-powerloom-features* :trace-subgoals)
    (progn
      (unset-feature :trace-subgoals)
      (drop-trace :STRATEGIES)
      (return "Subgoal tracing disabled."))
    (progn
      (set-feature :trace-subgoals)
      (add-trace :STRATEGIES)
      (return "Subgoal tracing enabled."))) )

(defun (toggle-trace-rules STRING) ()
  (if (and (defined? *traced-keywords*)
           (member? *traced-keywords* :propagate))
    (progn
      (drop-trace :PROPAGATE)
      (return "Rule tracing disabled."))
    (progn
      (add-trace :PROPAGATE)
      (return "Rule tracing enabled."))) )
    

  ;;
;;;;;; Classes for Incremental Query Interpreter
  ;;

(deftype COST-ESTIMATE FLOAT
  "Type used by the query optimizer to compute estimates of the cost of
executing a query.")

;;; A query stacks record maintains the following data for an environment 'e':
;;; Query variables are bound to values indirectly, through the stack
;;;    '(variable-frame-stack e)'.  Each query variable contains an
;;;    offset into that stack.  Offsets are relative to
;;;    '(pattern-variable-binding-offset e)', i.e., the first variable
;;;    bound in a query has offset zero.
;;; When a :PATTERN frame is  exited, all bindings above
;;;    '(pattern-variable-binding-offset e)' are freed, and all
;;;    entries on (unbinding-stack e) above ??? are freed.
;;; A each binding of a variable is accompanied by an entry
;;;    in '(unbinding-stack e)' that records the absolute
;;;;   offset of the variable's value within '(variable-frame-stack e)'.
;;; When a query backs over a choice point, all bindings recorded subsequent
;;;    to that choice point are nullified.

(defclass QUERY-ITERATOR (ITERATOR DYNAMIC-SLOTS-MIXIN)
  :public? TRUE
  :documentation "A query iterator points to a query environment
representing the initial or intermediate state of a query.  The iterator's
'value' is a vector representing a satisfying set bindings of the query's
output variables.  Each call to the iterator writes a new set of bindings
into the vector."
  :parameters ((any-value :type QUERY-SOLUTION))
  :public-slots 
  ((external-variables :type VARIABLES-VECTOR)
   (initial-bindings :type ARGUMENTS-VECTOR :allocation :dynamic
     :documentation "Supports cached queries; conceivably, this could be static.")
   (exhausted? :type BOOLEAN)
   (auxiliary-query :type QUERY-ITERATOR :allocation :dynamic)
   (negated-query :renames auxiliary-query)
   (options :type PROPERTY-LIST :initially (new PROPERTY-LIST))
   (solutions :type QUERY-SOLUTION-TABLE
              :initially (new QUERY-SOLUTION-TABLE)
              :documentation "Each element holds a solution record with a
vector of bindings of the free external variables of the query plus all
the appropriate truth-value and justification support.")
   (atomic-singletons? :type BOOLEAN :allocation :dynamic
                     :documentation "If TRUE, then singleton result tuples are
consified (and printed) as atoms instead of singleton lists.")
   ;; bookkeeping:
   (query-context :type CONTEXT)
   (base-control-frame :type CONTROL-FRAME)
   (current-control-frame :type CONTROL-FRAME)
   (current-pattern-record :type PATTERN-RECORD)
   (current-parallel-thread :type PARALLEL-THREAD)
   (control-frame-priority-queue :type CONTROL-FRAME-PRIORITY-QUEUE)
   ;; duplicate subgoal bookkeeping:
   (augmented-goal-cache? :type BOOLEAN)
   (active-goal-caches :type (LIST OF GOAL-CACHE) :allocation :embedded)
   (triggered-depth-cutoff? :type BOOLEAN)
   (failed-to-find-duplicate-subgoal? :type BOOLEAN)
   (found-at-least-one-solution? :type BOOLEAN)
   (timestamp :type TIMESTAMP)
   ;; partial match slots:
   (partial-match-strategy :type PARTIAL-MATCH-FRAME)
   (latest-positive-score :type PARTIAL-MATCH-SCORE :allocation :dynamic)
   ;; possible replacement for 'latest-positive-score' - SHOULD BOTH GO AWAY:
   (latest-partial-score :type PARTIAL-MATCH-SCORE
                         :renames latest-positive-score)
   ;; query optimizer bookkeeping (if we ever start to heavily rely on the
   ;;    static optimizer again, we have to rethink the :dynamic allocation):
   (optimizer-goal-records :type (EXTENSIBLE-VECTOR OF GOAL-RECORD)
                           :allocation :dynamic)
   (residue-goals :type (LIST OF PROPOSITION) :allocation :dynamic)
   (best-goal-sequence :type (LIST OF PROPOSITION) :allocation :dynamic)
   (best-cost :type COST-ESTIMATE :allocation :dynamic)
   ;; inference and resource control:
   (inference-level :type INFERENCE-LEVEL)
   (iterative-deepening? :type BOOLEAN :allocation :dynamic)
   (current-depth-cutoff :type INTEGER)
   (maximum-depth :type INTEGER)
   (allotted-time :type FLOAT
     :documentation "If defined, timeout after that many seconds.")
   (allotted-clock-ticks :type INTEGER
     :documentation "If defined, timeout after that many :DOWN moves.")
   (current-clock-ticks :type INTEGER :initially 0)
   (timeout? :type BOOLEAN
     :documentation "Set to TRUE if query times out.")
   (depth-cutoffs? :type BOOLEAN
     :documentation "Set to TRUE if one or more depth cutoffs occurred."))
  :print-form (print-query-iterator self stream))

;;; Needs to preceed first reference:
(deftype GOAL-BINDINGS (CONS OF OBJECT))

(defclass CONTROL-FRAME (STANDARD-OBJECT DYNAMIC-SLOTS-MIXIN)
  :public? TRUE
  :public-slots
  ((state :type KEYWORD)
   (proposition :type PROPOSITION)
   (description :type DESCRIPTION :allocation :dynamic)
   (truth-value :type TRUTH-VALUE)
   (reverse-polarity? :type BOOLEAN)
   ;; these measure state machine moves, not real time:
   (starting-clock-ticks :type INTEGER
     :documentation "Clock ticks at last :DOWN move.")
   (allotted-clock-ticks :type INTEGER
     :documentation "Total clock ticks allotted to prove this goal.")
   ;; proof tree pointers:
   (up :type CONTROL-FRAME)
   (down :type CONTROL-FRAME)
   (back :type CONTROL-FRAME :allocation :dynamic) ; used only by :CONTAINED-BY proof
   (result :type CONTROL-FRAME)     ;; points to most recently succeeded or failed
                                    ;; subgoal after moving up (could be merged
                                    ;; with `down' for a bit of extra complexity)
   (arguments :type (VECTOR OF CONTROL-FRAME)
              :allocation :dynamic) ;; used by :AND frames
   (argument-cursor :type INTEGER :initially 0)
   ;; variable un/binding:
   (pattern-record :type PATTERN-RECORD)
   (inherited-pattern-record :type PATTERN-RECORD)
   (choice-point-unbinding-offset :type INTEGER)
   ;; strategy slots:
   (current-strategy :type KEYWORD)
   (next-strategies :type (CONS OF KEYWORD) :initially NIL)
   (iterator :type ITERATOR :allocation :dynamic)
   (antecedents-rule :type PROPOSITION :allocation :dynamic)
   (proof-adjunct :type PROOF-ADJUNCT :allocation :dynamic)
   ;; end of strategy slots
   (partial-match-frame :type PARTIAL-MATCH-FRAME)
   ;; COULD THESE SLOTS BE ONLY FOR SOME FRAMES???:     
   (justifications :type LIST :allocation :embedded) ;; try to eliminate this slot
   (justification :type JUSTIFICATION :allocation :dynamic)
   ;; caching-related slots:
   (cached-single-valued? :type BOOLEAN :allocation :dynamic)
   ;; old and new caching:
   (goal-bindings :type GOAL-BINDINGS)
   ;; new caching:
   (cached-goal-result? :TYPE BOOLEAN)
   (dont-cache-goal-failure? :type BOOLEAN)
   ;; old caching:
   (goal-cache :type GOAL-CACHE :allocation :dynamic)
   (cached-bindings-iterator :type (ITERATOR OF GOAL-BINDINGS)
                             :allocation :dynamic)
   )
  :public-methods
  ((holds-by-default? ((self CONTROL-FRAME))
     :type BOOLEAN :globally-inline? TRUE
     (return (default-truth-value? (truth-value self)))))
  :print-form (print-control-frame self stream))

(defclass PARALLEL-THREAD (STANDARD-OBJECT)
  :slots ((top-control-frame :type CONTROL-FRAME)
          (hypothetical-world :type WORLD)
          ;; used only if 'unbound-variables?' is TRUE:
          (variable-bindings :type (VECTOR OF OBJECT))
          (unbinding-stack :type INTEGER-VECTOR)
          (top-unbinding-stack-offset :type INTEGER)
          ;; (NOT YET) used by 'select-next-child-thread':
          (priority :type INTEGER)
          (status :type KEYWORD)
          ))

(defclass PARALLEL-CONTROL-FRAME (CONTROL-FRAME)
  :slots ((child-threads :type (LIST OF PARALLEL-THREAD)
                         :allocation :embedded)
          (unbound-variables? :type BOOLEAN)
          (current-child-thread :type PARALLEL-THREAD)
          (saved-parent-context :type CONTEXT)
          (saved-parent-parallel-thread :type PARALLEL-THREAD))
;  :recycle-method :free-list
  )

(defclass CONTROL-FRAME-PRIORITY-QUEUE (STANDARD-OBJECT)
  :slots
  ((queue :type (LIST OF PARALLEL-CONTROL-FRAME))))

(defspecial *queryIterator* QUERY-ITERATOR NULL
  :documentation
  "Points to the query iterator for the currently executing query.")

(defglobal *default-maximum-depth* INTEGER 25
  :documentation "Possibly a good value for the maximum backtracking depth.
More testing is needed.")

(defglobal *initial-backtracking-depth* INTEGER 5
  :documentation "Value of the initial depth used during an interative
deepening search.")

(defglobal *iterative-deepening-mode?* BOOLEAN FALSE
  :documentation "Default setting.  If TRUE, queries are evaluated
using iterative deepening from depth '*initial-backtracking-depth*'
to depth '*maximum-backtracking-depth*'.")

(defglobal *emit-thinking-dots?* BOOLEAN TRUE
  :documentation "When TRUE, various kinds of characters are
emitted to STANDARD-OUTPUT while PowerLoom is 'thinking'.")

(defglobal *thinking-dot-counter* INTEGER 0
  :documentation "Used to determine when to generate linefeeds
after forty-or-so thinking dots.")

(defglobal *thinking-dot-table* (PROPERTY-LIST OF KEYWORD CHARACTER-WRAPPER)
  (new PROPERTY-LIST :the-plist
       (bquote (:UPCLASSIFY & (wrap-literal #\u)
                :DOWNCLASSIFY & (wrap-literal #\d)
                :PROPAGATE & (wrap-literal #\f)      ;; for "forward"
                :PARTIAL-MATCH & (wrap-literal #\p)
                )))
  :documentation "Maps kind of thinking keywords to characters.")

(defun emit-thinking-dot ((kindOfThinking KEYWORD))
  ;; Print a character representing 'kindOfThinking', indicating
  ;;    that we have just performed one unit of some particular
  ;;    reasoning task.
  (when *emit-thinking-dots?*
    (let ((character CHARACTER-WRAPPER
                     (lookup *thinking-dot-table* kindOfThinking)))
      (when (defined? character)
        (print (wrapper-value character))
        (++ *thinking-dot-counter*)
        (when (>= *thinking-dot-counter* 70)
          (print EOL)
          (setq *thinking-dot-counter* 0))))) )


  ;;
;;;;;; Classes that augment the data in a CONTROL-FRAME
  ;;

(defclass PROOF-ADJUNCT (STANDARD-OBJECT)
  :documentation "Subclasses of 'PROOF-ADJUNCT' provide for specialized
slots (specialized for a particular strategy) to hold a record of
an ongoing proof thread.")

(defclass PATTERN-RECORD (STANDARD-OBJECT)
  :documentation "A pattern record records bookkeeping data used during
the processing of a description."
  :slots ((control-frame :type CONTROL-FRAME)
          (variable-bindings :type (VECTOR OF OBJECT))
          (unbinding-stack :type INTEGER-VECTOR)
          (top-unbinding-stack-offset :type INTEGER)
          (description :type DESCRIPTION)
          (external-arguments :type ARGUMENTS-VECTOR)
          (boolean-vector :type BOOLEAN-VECTOR)
          (optimal-pattern :type DESCRIPTION)
          (collection-list :type LIST))
; :recycle-method :free-list
  :terminator terminate-pattern-record?)

(defclass BOOLEAN-VECTOR-INDEX-NODE (STANDARD-OBJECT)
  :slots
  ((true-link :type BOOLEAN-VECTOR-INDEX-NODE)
   (false-link :type BOOLEAN-VECTOR-INDEX-NODE)
   (the-vector :type BOOLEAN-VECTOR)) )

(defglobal *boolean-vector-index* BOOLEAN-VECTOR-INDEX-NODE
  (new BOOLEAN-VECTOR-INDEX-NODE :the-vector (new BOOLEAN-VECTOR :array-size 0))
  :documentation "Points to the head of a discrimination tree of containing
all boolean vectors.")


  ;;
;;;;;; Boolean vectors
  ;;

;;; The discrimination tree *boolean-vector-index* stores boolean
;;;    vectors.  It is used to quickly locate a boolean vector matching
;;;    a given variable vector.  The tree enables boolean vectors to be
;;;    structure shared, so that a pointer equality test suffices to 
;;;    compare equality of boolean vectors.

(defun (create-boolean-vector-index-node BOOLEAN-VECTOR-INDEX-NODE)
       ((parentNode BOOLEAN-VECTOR-INDEX-NODE) (lastValue BOOLEAN))
  ;; Grow a new node in the *boolean-vector-index* tree.
  ;; Create a BOOLEAN-VECTOR-INDEX-NODE, allocate a vector for it one longer
  ;;    than the vector in 'parentNode', and link 'parentNode' to it.
  (let ((node (new BOOLEAN-VECTOR-INDEX-NODE))
        (vectorLength INTEGER (1+ (length (the-vector parentNode))))
        (vector (new BOOLEAN-VECTOR :array-size vectorLength)))
    (setf (the-vector node) vector)
    (foreach i in (interval 0 (- vectorLength 2))
             do (setf (nth vector i) (nth (the-vector parentNode) i)))
    (setf (nth vector (1- vectorLength)) lastValue)
    (if lastValue
      (setf (true-link parentNode) node)
      (setf (false-link parentNode) node))
    (return node) ))

(defun (arguments-vector-to-boolean-vector BOOLEAN-VECTOR)
       ((argumentsVector ARGUMENTS-VECTOR))
  ;; Walk the discrimination tree *boolean-vector-index* to locate a 
  ;;    boolean vector containing a true entry for every constant or
  ;;    bound variable entry in 'argumentsVector'.
  (let ((node *boolean-vector-index*)
        (nextNode BOOLEAN-VECTOR-INDEX-NODE NULL)
        (bound? FALSE))
    (foreach
      arg in argumentsVector
      do
      (setq bound? TRUE)
      ;; TO DO: Figure out whether we can use 'argument-bound-to' here if
      ;;        we ensure that 'bound-to-offset' is properly initialized.
      (typecase arg
        (PATTERN-VARIABLE
         (setq bound? (defined? (bound-to arg))))
        (otherwise NULL))
      (if bound?
        (progn
          (setq nextNode (true-link node))
          (when (null? nextNode)
            (setq nextNode (create-boolean-vector-index-node node TRUE))))
        (progn
          (setq nextNode (false-link node))
          (when (null? nextNode)
            (setq nextNode (create-boolean-vector-index-node node FALSE)))))
      (setq node nextNode))
    (return (the-vector node)) ))

(defun (zero-one-list-to-boolean-vector BOOLEAN-VECTOR)
       ((zeroOneLIst (LIST OF INTEGER-WRAPPER)))
  ;; Walk the discrimination tree *boolean-vector-index* to locate a 
  ;;    boolean vector containing a true entry for every ONE
  ;;    element of 'booleanList'.
  (let ((node *boolean-vector-index*)
        (nextNode BOOLEAN-VECTOR-INDEX-NODE NULL))
    (foreach
      bit in zeroOneList
      do
      (if (eql? bit ONE-WRAPPER)
        (progn
          (setq nextNode (true-link node))
          (when (null? nextNode)
            (setq nextNode (create-boolean-vector-index-node node TRUE))))
        (progn
          (setq nextNode (false-link node))
          (when (null? nextNode)
            (setq nextNode (create-boolean-vector-index-node node FALSE)))))
      (setq node nextNode))
    (return (the-vector node)) ))


  ;;
;;;;;; Query Environments
  ;;

;;; A query environment is an object that points to all data structures
;;;    needed to interpret a particular query.  This includes several
;;;    stacks, and pointers into those stacks.
;;; Multiple environments are needed in the case that execution of queries
;;;    is overlapped.

(defun pop-control-frame ((frame CONTROL-FRAME))
  ;; Pop 'frame' (assumes that frames below it are already popped).
;  (trace-if :QUERY-STACKS "POP-control-frame:  state= " (state frame)
;            " F" (debug-frame-id frame) EOL)
  (when (or (eql? (state frame) :PATTERN)
            (eql? (state frame) :CONTAINED-BY))
    (reset-current-pattern-record frame :PARENT))
  (when (defined? (cached-bindings-iterator frame))
    (free (cached-bindings-iterator frame))
    (setf (cached-bindings-iterator frame) NULL))
  (setf (choice-point-unbinding-offset frame) NULL)
  (free frame)
  (setf (state frame) :POPPED) )

;; PROBLEM: WE MISS SOME FRAMES DURING POPPING (ONES POINTING
;;    'back' TO 'frame'.  THIS IS GOING TO REDUCE THE UTILITY OF
;;    THE FREE LIST:
(defun pop-frames-up-to ((frame CONTROL-FRAME))
  ;; Pop frames below 'frame' and then pop 'frame'.
  (when (defined? (down frame))
    (pop-frames-up-to (down frame)))
  ;; nullify down pointer to 'frame':
  (when (defined? (up frame))
    (setf (down (up frame)) NULL))
  ;; pop 'frame':
  (pop-control-frame frame) )

(defun pop-down-frame ((frame CONTROL-FRAME))
  ;; Pop the frame below 'frame', and nullify the pointer to it.
  (pop-control-frame (down frame))
  (safety 3 (null? (down (down frame))) 
          "Forgot to pop frame below current frame.")
  (setf (down frame) NULL) )

(defun activate-pattern-record
       ((patternRecord PATTERN-RECORD) (variableCount INTEGER))
  ;; Allocate (if necessary) a vector of size 'variableCount' and
  ;;    attach it to 'patternRecord'; otherwise, clear existing vector.
  ;; Also, allocate/clear 'unbinding-stack'.
  ;; Reset 'current-pattern-record' to 'patternRecord', making all bound-to
  ;;    computation refer to this pattern environment.
  ;; Called by 'overlay-with-pattern-frame?'.
  (let ((vector (variable-bindings patternRecord))
        (stack (unbinding-stack patternRecord)))
    (if (and (defined? vector)
             (>= (array-size vector) variableCount))
      ;; clear existing vector and stack:
      (foreach i in (interval 0 (1- variableCount))
               do 
               (setf (nth vector i) NULL)
               (setf (nth stack i) NULL))
      (progn
        ;; allocate new vector
        (setf (variable-bindings patternRecord)
              (new VECTOR :array-size variableCount))
        (setf (unbinding-stack patternRecord)
              (new INTEGER-VECTOR :array-size variableCount))))
    (setf (top-unbinding-stack-offset patternRecord) -1)
    ;; reset 'current-pattern-record':
    (setf (current-pattern-record *queryIterator*) patternRecord) ))

(defun reset-current-pattern-record
       ((frame CONTROL-FRAME) (localOrParent KEYWORD))
  ;; Reset the pointer to the beginning of the current block of variable
  ;;    frames (used to compute 'bound-to') to either the variables
  ;;    for the current pattern frame, or for a parent pattern frame.
  (case localOrParent
    (:LOCAL 
     (setf (current-pattern-record *queryIterator*)
           (pattern-record frame)))
    (:PARENT
     (if (defined? (inherited-pattern-record frame))
       (setf (current-pattern-record *queryIterator*)
             (inherited-pattern-record frame))
       ;; point to block of external variables that holds query result:
       (setf (current-pattern-record *queryIterator*)
             (pattern-record (base-control-frame *queryIterator*)))))) )

(defun print-environment-stacks ()
  ;; Debugging aid: Print out the contents of the query environment.
  (let ((frame (current-control-frame *queryIterator*))
        (currentPatternRecord (current-pattern-record *queryIterator*)))
    (print "-------------------------" EOL)
    (print "current-control-frame " frame EOL)
    (print "    ")
    (foreach arg in (variable-bindings currentPatternRecord)
             do
             (if (defined? arg)
               (print arg " ")
               (print "_ ")))
    (print EOL)
    (print "    " (unbinding-stack currentPatternRecord) EOL)
    (print "-------------------------" EOL) ))


  ;;
;;;;;; Binding pattern variables
  ;;

(defun set-pattern-variable-binding ((variable PATTERN-VARIABLE) (value OBJECT))
  ;; Set '(bound-to variable)' to 'value' and record the binding occurrence
  ;;    on the choice point binding stack.
 (trace-if :query-stacks "set-pattern-variable-binding: " variable " " value 
           "  F" (debug-frame-id (control-frame (current-pattern-record *queryIterator*)))
           EOL)
  (let ((patternRecord (current-pattern-record *queryIterator*))
        (vbOffset (bound-to-offset variable))
        (ubStackOffset
         INTEGER (1+ (top-unbinding-stack-offset patternRecord))))
    ;; assign new binding to 'variable':
    (setf (nth (variable-bindings patternRecord) vbOffset)
          value)
    ;; allocate new unbinding stack cell:
    (setf (top-unbinding-stack-offset patternRecord) ubStackOffset)
    ;; record location of variable binding value for later unbinding:
    (setf (nth (unbinding-stack patternRecord) ubStackOffset) vbOffset) ))

(defun change-pattern-variable-binding ((variable PATTERN-VARIABLE) (newValue OBJECT))
  ;; Change the value of `variable' (which is assumed to be bound!) to `newValue'.
  ;; Different from `set-pattern-variable-binding', since there is no
  ;;    unbinding maintenance required.
  (let ((patternRecord (current-pattern-record *queryIterator*))
        (vbOffset (bound-to-offset variable)))
    (setf (nth (variable-bindings patternRecord) vbOffset) newValue)))

(defun unbind-variables-beginning-at
       ((patternRecord PATTERN-RECORD) (ubStackOffset INTEGER))
  ;; Unbind pattern variables at and above 'ubStackOffset' on the unbinding stack.
  ;; For each entry U stored in the unbinding stack, from 'ubStackOffset'
  ;;    to the the top of the unbinding stack, set to NULL within the variable
  ;;   frame stack each entry corresponding to a U value (each U is an
  ;;   offset pointing into the variable frame stack).
  (let ((variableBindingsVector (variable-bindings patternRecord))
        (unbindingStack (unbinding-stack patternRecord)))
    ;; return if there are no variables to unbind (protects against 
    ;;    erroneously executing the last line of this function):
    (when (< (top-unbinding-stack-offset patternRecord) ubStackOffset)
      (return))
  (trace-if :query-stacks "unbind-variables-beginning-at: "
            "UBS= " ubStackOffset
            "  F" (debug-frame-id (control-frame patternRecord))
            "  #bindings= " (1+ (- (top-unbinding-stack-offset patternRecord)
                                   ubStackOffset)) EOL)
    (foreach i in (interval ubStackOffset
                            (top-unbinding-stack-offset patternRecord))
             do
             (setf (nth variableBindingsVector (nth unbindingStack i)) NULL)
             ;; -rmm SEEMS REDUNDANT, BUT MAKES DEBUGGING EASIER:
             (setf (nth unbindingStack i) NULL))
    ;; free unbinding frames:
    (setf (top-unbinding-stack-offset patternRecord) (1- ubStackOffset)) ))

(defun create-choice-point ((frame CONTROL-FRAME))
  ;; Create a choice point for the current stack 'frame' OR unbind
  ;;    all variables above an already set choice point.
  ;; If the choice point offset is null, initialize it to the 
  ;;   current top of the unbinding stack
  ;; Otherwise, we are reentering 'frame'. Undo all of its current bindings.
  ;; This relies on the fact, that new stack frames have a NULL choice point
  ;;    offset, which is the reason why it is NULL-ified when the frame
  ;;    gets popped.
  (let ((patternRecord (inherited-pattern-record frame)))
 (trace-if :query-stacks "create-choice-point: "
           "F " (debug-frame-id frame)
           " CP= "(choice-point-unbinding-offset frame)
           " NEWCP= "(1+ (top-unbinding-stack-offset patternRecord)) EOL)
    (safety 3 (eql? patternRecord (current-pattern-record *queryIterator*))
            "create-choice-point PATTERN RECORD OUT OF SYNC WITH CURRENT PR")
    (if (null? (choice-point-unbinding-offset frame))
      (setf (choice-point-unbinding-offset frame)
            (1+ (top-unbinding-stack-offset patternRecord)))
      (unbind-variables-beginning-at
       patternRecord (choice-point-unbinding-offset frame))) ))

(defun unwind-to-choice-point ((frame CONTROL-FRAME))
  ;; If 'frame' has a choice-point set, unbind variables
  ;;    placed on the stack after the choice-point was set.
  ;; Must only be called on a frame containing an atomic
  ;;    goal that is deepest on the stack.
  (let ((choicePoint (choice-point-unbinding-offset frame)))
    (when (defined? choicePoint)
      (unbind-variables-beginning-at
       (inherited-pattern-record frame) choicePoint)) ))

(defun (new-bindings-since-last-choice-point? BOOLEAN) ((frame CONTROL-FRAME))
  ;; Return TRUE if the unbindings stack has grown since the choice point
  ;;    was set for 'frame'.
  ;; Assumes that a choice point has been set for 'frame'.
  (safety 3 (defined? (choice-point-unbinding-offset frame)))
  (return (<= (choice-point-unbinding-offset frame)
              (top-unbinding-stack-offset (inherited-pattern-record frame)))) )

(defun (bound-to OBJECT) ((self PATTERN-VARIABLE))
  ;; Return the value of the current binding of 'self'.
  :globally-inline? TRUE  :public? TRUE
  (return
   (nth (variable-bindings (current-pattern-record *queryIterator*))
        (bound-to-offset self))) )

(defun (safe-bound-to OBJECT) ((self PATTERN-VARIABLE))
  ;; Return the value of the current binding of 'self'.
  ;; Similar to `bound-to' but doesn't break if called in the wrong environment.
  (when (defined? *queryIterator*)
    (let ((bindings
           (variable-bindings (current-pattern-record *queryIterator*)))
          (offset (bound-to-offset self)))
      (when (and (defined? bindings)
                 (defined? offset)
                 (< offset (length bindings)))
        (return (nth bindings offset)))))
  (return NULL))

(defun (bound-to-in-frame OBJECT) ((self PATTERN-VARIABLE)
                                   (frame CONTROL-FRAME))
  ;; Return the value of the binding of 'self' relative to the frame 'frame'.
  ;; Safe accessor, doesn't break if called in the wrong environment.
  (let ((bindings (variable-bindings (operative-pattern-record frame))) 
        (offset (bound-to-offset self)))
    (if (and (defined? bindings)
             (defined? offset)
             (< offset (length bindings)))
        (return (nth bindings offset))
      (return NULL))))

(defun (bound-to-in-record OBJECT) ((self PATTERN-VARIABLE) (record PATTERN-RECORD))
  ;; Return the value of the current binding of `self' in `record'.
  :globally-inline? TRUE  :public? TRUE
  (return (nth (variable-bindings record) (bound-to-offset self))))

(defun (contains-operator? BOOLEAN)
       ((proposition PROPOSITION) (operator SURROGATE))
  :public? TRUE
  ;; Search 'proposition' and its arguments for a proposition
  ;;    whose operator is 'operator'.
  (return
   (or (eql? (operator proposition) operator)
       (exists arg in (arguments proposition)
               where (and (isa? arg @PROPOSITION)
                          (contains-operator? arg operator))))) )

(defun (argument-bound-to OBJECT) ((self OBJECT))
  :public? TRUE
  ;; If 'self' is a pattern variable, return its current binding.
  ;; Otherwise, return 'self'.
  (typecase self
    (PATTERN-VARIABLE 
     (let ((value (bound-to self)))
       ;; THIS IS AN EXPERIMENT:
       (when (and (null? value)
                  (defined? (variable-value self)))
         (setq value (value-of self))         
         (when (skolem? value)
           (return NULL))
         ;; cache '(value-of self)' self to speed up future calls:
         ;; OOPS: WHAT IF UNIFICATION FAILS???:
         (bind-variable-to-value? self value TRUE))
       (return value)))
    (SURROGATE
     (return (value-of self)))
    (DESCRIPTION
     ;; if 'self' is a description containing a HOLDS relation, look
     ;;    for a duplicate - hc: not sure this is ever exercised, but
     ;;    this might be another place to instantiate descriptions
     ;;    with external variables:
     (when (and (defined? (external-variables self)) ;; HOLDS-KLUDGE
                (contains-operator? (proposition self) PL-KERNEL/@HOLDS))
       (return (first-defined (find-duplicate-description self) self)))
     (return (value-of self)))
    (otherwise (return (value-of self)))) )

(defun (safe-argument-bound-to OBJECT) ((self OBJECT))
  ;; Safe version of `argument-bound-to' (which see) that does not
  ;; break if we are called outside of a query or on a variable
  ;; that isn't allocated on the binding stack.
  (typecase self
    (PATTERN-VARIABLE
     ;; we mirror the variable case, since we still want to pick up
     ;; `variable-value's:
     (let ((value OBJECT NULL))
       (when (and (defined? *queryIterator*)
                  (defined? (bound-to-offset self)))
         (setq value (bound-to self)))
       (when (and (null? value)
                  (defined? (variable-value self)))
         (setq value (value-of self))         
         (when (skolem? value)
           (setq value NULL)))
       (return value)))
    (otherwise
     (return (argument-bound-to self)))))

(defun (help-unify-attributes? BOOLEAN) ((value1 OBJECT) (value2 OBJECT))
  ;; Helping function for 'help-bind-variable-to-value?'.
  ;; Evaluate equivalence of 'value1' and 'value2' (possibly recursively).
  ;; Return TRUE if success.
  (return (or (eql? value1 value2)
              (and (skolem? value1)
                   (help-bind-variable-to-value? value1 value2)))) )

;; NOTHING CALLS THIS (USED TO BE CALLED BY 'help-bind-variable-to-value?'):
(defun (fails-unification-type-check? BOOLEAN) ((v1 PATTERN-VARIABLE) (i2 OBJECT))
  ;; Called by 'help-bind-variable-to-value?'.
  ;; Return TRUE if a type on object 'i2' is provably disjoint from
  ;;    a type on variable 'v1'.
  ;; EXPERIMENTING WITH DIFFERENT DEGREES OF TYPE CHECKING.
  (case *type-check-strategy*
    (:NONE (return FALSE))
    (:LOOKUP
     (let ((type (skolem-type v1))
           (typeIsOK? (check-type? i2 type TRUE)))
       (if (and (not typeIsOK?)
                (non-inferable? (surrogate-to-description type)))
         (return TRUE)
         (return FALSE))))
    (:SHALLOW-DISJOINT 
     ;; REINSTATE THIS LOGIC WHEN 'disjoint-classes?' IS SMART ENOUGHT TO
     ;;    KNOW THAT NUMBER AND INTEGER ARE NOT DISJOINT:
 ;         (print "DISJOINT?: " (skolem-type v1) "  " (logical-type i2) EOL)
     (when (and (defined? (skolem-type v1))
                (disjoint-classes? (get-description (skolem-type v1))
                                   (get-description (logical-type i2))))
;              (print "YES, DISJOINT: " v1 "  " i2 EOL)
       (return TRUE))
     (return FALSE))
    (:DISJOINT
     (let ((type1 TYPE NULL)
           (type2 TYPE NULL))
       (foreach p in (unfiltered-dependent-isa-propositions v1)
                where (eql? (kind p) :ISA)
                do
                (setq type1 (second (arguments p)))
                (break))
       (when (null? type1)
         (return FALSE))
       (typecase i2
         (LOGIC-OBJECT
          (foreach p in (unfiltered-dependent-isa-propositions i2)
                   where (eql? (kind p) :ISA)
                   do
                   (setq type2 (second (arguments p)))
                   (break)))
         (otherwise
          (setq type2 (logical-type i2))))
       (when (null? type2)
         (return FALSE))
;       (let ((result? (disjoint-classes?
;                        (get-description type1) (get-description type2))))
;         (when result?
;           (print "DISJOINT TYPES: " type1 "   " type2 EOL))
;         (return result?))
       (return (disjoint-classes? 
                (get-description type1) (get-description type2)))))) )

(defun (fails-antecedent-type-check? BOOLEAN) ((v1 PATTERN-VARIABLE) (i2 OBJECT))
  ;; Called by allocate-antecedents-iterator'.
  ;; Strategy: Return TRUE if lookup can't prove that 'i2' satisfies the
  ;;    root type on 'v1' and that root type is non-inferable.
  (case *type-check-strategy*
    (:LOOKUP
     (let ((type (skolem-type v1))
           (typeIsOK? (check-type? i2 type TRUE)))
       (if (and (not typeIsOK?)
                (non-inferable? (surrogate-to-description type)))
         (return TRUE)
         (return FALSE))))
    (:NONE (return FALSE))) )

(defun (help-bind-variable-to-value? BOOLEAN) 
       ((variable PATTERN-VARIABLE) (value OBJECT))
  ;; Helping function for 'bind-variable-to-value?'.
  ;; 'value' is assumed to be non-null.
  (case *type-check-strategy*
    (:LOOKUP
     (let ((typeIsOK? BOOLEAN NULL))
       ;; tricky: 'value' may be coerced as a side-effect of the type check:
       (mv-setq (typeIsOK? value) (check-coerced-type? value (skolem-type variable) TRUE))
       (when (and (not typeIsOK?)
                  (non-inferable? (surrogate-to-description (skolem-type variable))))
         ;; trace type violation failures in the goal tree, since they can
         ;; lead to very mysterious and hard to debug inference failures:
         (trace-if :GOAL-TREE
          "*** type violation: var=" (skolem-name variable) " type="
          (skolem-type variable) " value=" value EOL)
         (return FALSE))))
    (:NONE NULL))
  (let ((boundToValue (bound-to variable))
        (variableValue (variable-value variable)))
    (elaborate-instance value)
    (cond
     ((and (defined? variableValue)
           (null? boundToValue))
      (setq variableValue (value-of variableValue))
      (set-pattern-variable-binding variable variableValue)
      (return (eql? variableValue value)))
     ((null? boundToValue)
      (set-pattern-variable-binding variable value))
     ((equal? (value-of boundToValue) (value-of value))
      ;; Disabled: changing the variable value to an equivalent is a bad idea, since
      ;; the equivalence might be due to a hypothetical context (e.g., in PL-Mediator),
      ;; which, once the context goes away, leaves us with an incorrect binding.  We
      ;; now dereference bindings at the top level, since collecting all members of an
      ;; equivalence class will need a specialist and a LISTOF result term anyway.
      #|
      (unless (eql? boundToValue (value-of boundToValue))
        ;; in some cases the elaboration above might discover additional equivalences
        ;; and we change the binding here to the newly discovered equivalent representative
        ;; - we could do that when the bindings are collected at the top-level but that
        ;; would prevent us from ever retrieving all members of an equivalence class:
        (change-pattern-variable-binding variable (value-of boundToValue)))
      |#
      (return TRUE))                    ; quick exit, succeed
     (otherwise (return FALSE)))        ; fail
    ;; 'variable' is newly-bound to 'value';
    (return TRUE) ))

(defun (bind-variable-to-value? BOOLEAN)
       ((variable PATTERN-VARIABLE) (value OBJECT) (autoCleanup? BOOLEAN))
  :public? TRUE
  ;; Bind 'variable' to the value 'value'.  Recursively bind any variables
  ;;    representing attribute values.  If successful, return TRUE.
  ;; If the unification operation fails at any point, return FALSE.
  ;; If 'autoCleanup?, all bindings are undone upon occurrence of unification
  ;;    failure.  Otherwise, the caller assumes responsibility for cleaning up.
  (when (or (null? value)
            ;; guard against descriptions and propositions with unbound external vars:
            (not (argument-bound? value)))
    (when (and (partial-match-mode?)
               (allow-unbound-variables?
                (partial-match-strategy *queryIterator*)))
      (return TRUE))
    (signal-proposition-warning
     "Tried to bind " variable " to NULL value.  Potentially a PowerLoom bug")
    (return FALSE))
  ;; instantiate any external variables in descriptions and propositions:
  (setq value (instantiate-external-bindings value))
  (if autoCleanup?
    (let ((patternRecord (current-pattern-record *queryIterator*))
          (ubStackOffset (top-unbinding-stack-offset patternRecord))
          (success? FALSE))
      ;; 'ubStackOffset' saves the location of the top-most variable binding
      ;;     so that new bindings generated during unification can be quickly
      ;;     eliminated if unification fails:
      (setq success? (help-bind-variable-to-value? variable value))
      (when (not success?)
        (unbind-variables-beginning-at patternRecord (1+ ubStackOffset)))
      (return success?))
    (return (help-bind-variable-to-value? variable value))) )

(defun (bind-argument-to-value? BOOLEAN)
       ((argument OBJECT) (value OBJECT) (autoCleanup? BOOLEAN))
  :public? TRUE
  ;; Bind 'argument' (a proposition argument) to 'value'.
  ;; If 'argument' is a variable, unify the types of the two inputs, and
  ;;    recursively unify attribute propositions attached to 'argument'.
  ;; If the unification operation fails at any point, return FALSE.
  ;; If 'autoCleanup?, all bindings are undone upon occurrence of unification
  ;;    failure.  Otherwise, the caller assumes responsibility for cleaning up.
  (when (null? value)
    (when (and (partial-match-mode?)
               (allow-unbound-variables?
                (partial-match-strategy *queryIterator*)))
      (return TRUE))
    ;; Last time we saw this bug with strict inference, it was caused by
    ;;    COLLECT-INTO-SET applied to a KAPPA with unbound external variables.
    (signal-proposition-warning
     "Tried to bind " argument " to NULL value.  Potentially a PowerLoom bug")
    (return FALSE))
  ;; instantiate any external variables in descriptions and propositions:
  (setq value (instantiate-external-bindings value))
  (typecase argument
    (PATTERN-VARIABLE
     (return (bind-variable-to-value? argument value autoCleanup?)))
    (SURROGATE
     (return (eql? (value-of argument) value)))
    (PROPOSITION
     (when (isa? value @PROPOSITION)
       (let ((mapping (new ENTITY-MAPPING)))
         (when (and (unify-propositions? argument value mapping)
                    (forall (var val) in mapping
                      always (bind-variable-to-value? var val autoCleanup?)))
           (return TRUE))))
     (return FALSE))
    (otherwise (return (eql? argument value)))) )

(defun (bind-vector-of-arguments-to-values? BOOLEAN) 
       ((arguments ARGUMENTS-VECTOR) (values CONS))
  ;; Bind the arguments in 'arguments' to the values in 'values'.
  ;; Return TRUE if all bindings succeed.  Clean-up bindings if failure.
  ;; note: unbinding logic copied from 'bind-argument-to-value?'.
  (let ((patternRecord (current-pattern-record *queryIterator*))
        (ubStackOffset (top-unbinding-stack-offset patternRecord))
        (success? FALSE))
    (setq success?
          (forall arg in arguments
                  as v in values
                  always (bind-argument-to-value? arg v FALSE)))
    (when (not success?)
      (unbind-variables-beginning-at patternRecord (1+ ubStackOffset)))
    (return success?) ))


  ;;
;;;;;; Query trace routines
  ;;

(defun print-control-frame-stack ((frame CONTROL-FRAME))
  ;; TO DO: FIGURE OUT IF WE WANT TO PRINT FRAMES BELOW
  ;;    :AND frames.
  (print frame EOL)
  (when (defined? (down frame))
    (print-control-frame-stack (down frame))) )

(defun pcs ()
  (print-control-frame-stack (base-control-frame *queryIterator*)) )

(defun (variable-from-unbinding-offset PATTERN-VARIABLE)
       ((description DESCRIPTION) (ubOffset INTEGER))
  ;; Helping function for 'print-variable-bindings'.
  ;; Return the variable in 'description' whose 'bound-to-offset'
  ;;    points to the same position in the variable stack as 'ubOffset'.
  (let ((patternRecord (current-pattern-record *queryIterator*))
        (offset INTEGER ;; BUG; NEEDED FOR C++ BECAUSE ARGS TO '-' ARE WRAPPED
                (nth (unbinding-stack patternRecord) ubOffset)))
    (foreach vbl in (io-variables description)
             where (eql? (bound-to-offset vbl) offset)
             do (return vbl))
    (foreach vbl in (internal-variables description)
             where (eql? (bound-to-offset vbl) offset)
             do (return vbl))
    (return NULL) ))

(defspecial *printInFrame* CONTROL-FRAME NULL
  :documentation "If set, controls diagnostic printing by making
variable bindings appear relative to the frame '*printInFrame*'.")

(defun print-one-variable-binding ((variable PATTERN-VARIABLE))
  ;; Helping function for 'print-variable-bindings'.
  (print (skolem-name variable) "=")
  (if (defined? (bound-to-offset variable))
      (let ((value (choose (defined? *printInFrame*)
                           (bound-to-in-frame variable *printInFrame*)
                           (safe-bound-to variable))))
        (print-unformatted-logical-form value STANDARD-OUTPUT))
    (print (quote NULL)))
  (print " ") )

(defun print-variable-bindings ((frame CONTROL-FRAME))
  ;; Helping function for 'trace-goal-tree'.
  ;; Print variables bindings for current subquery.
  (let ((patternRecord (operative-pattern-record frame))
        (description DESCRIPTION NULL))
    (when (defined? patternRecord)
      (when (eql? (state frame) :CONTAINED-BY)
        (let ((memberProposition PROPOSITION
                                 (nth (arguments (proposition frame)) 0))
              (member (nth (arguments memberProposition) 0)))
          (typecase member
            (PATTERN-VARIABLE (print-one-variable-binding member))
            (LIST (foreach m in member do (print-one-variable-binding m)))))
        (return))
      ;; we are returning from a subquery; print out all local bindings:
      (setq description (optimal-pattern patternRecord))
      (when (defined? description)
        (foreach vbl in (io-variables description)
            where (defined? (bound-to-in-record vbl patternRecord))
            do (print-one-variable-binding vbl))
        (foreach vbl in (internal-variables description)
            where (defined? (bound-to-in-record vbl patternRecord))
            do (print-one-variable-binding vbl))))))

(defun print-rule-in-goal-tree
       ((frame CONTROL-FRAME) (impliesProp PROPOSITION) (depth INTEGER))
  ;; For goal tracing, print rule indicating that 'description' IMPLIES
  ;;    the goal in the current pattern.
  (let ((patternRecord (pattern-record frame))
        (reversePolarity? (reverse-polarity? frame)))
    (print "RULE: ")
    (let ((ruleName (surrogate-value-inverse impliesProp)))
      (when (and (null? ruleName)
                 (defined? (master-proposition impliesProp)))
        (setq ruleName 
              (surrogate-value-inverse (master-proposition impliesProp))))
      (when (defined? ruleName)
        (print (symbol-name ruleName) EOL)
        (print-indent STANDARD-OUTPUT (+ (* 2 depth) 6))))
    (special ((*printMode* :FLAT)  ;; WAS :REALISTIC, BUT I WANT THE SUGAR-COATING -rmm
              (*printLogicalFormStream* STANDARD-OUTPUT)
              (*indentCounter* (+ (* 2 depth) 7))
              ;; disable printing of variable bindings within rule:
              (*queryIterator* NULL))
      (print-descriptions-as-kif-rule
       (choose reversePolarity?
               ;; modus tollens, head is the subgoal, get the optimized version:
               (first-defined (optimal-pattern patternRecord)
                              (description patternRecord))
               (nth (arguments impliesProp) 1))
       (choose reversePolarity?
               (nth (arguments impliesProp) 0)
               ;; modus ponens, tail is the subgoal, get the optimized version:
               (first-defined (optimal-pattern patternRecord)
                              (description patternRecord)))
       impliesProp
       reversePolarity?))))

(defun print-goal-in-goal-tree ((frame CONTROL-FRAME) (depth INTEGER))
  ;; For goal tracing, print the current goal.
  (if (defined? (proposition frame))
    (let ((invert? (reverse-polarity? frame)))
      (print "GOAL: ")
      (when invert?
        (print #\~))
      (special ((*printMode* :REALISTIC)
                (*printLogicalFormStream* STANDARD-OUTPUT)
                (*indentCounter* (+ (* 2 depth) 7)))
        (print-unformatted-logical-form (proposition frame) STANDARD-OUTPUT)
        (when (defined? (allotted-clock-ticks frame))
          (print " ticks=" (allotted-clock-ticks frame)))))
    ;; PLAYING AROUND A BIT HERE:  -rmm
    (print "STRATEGY: " (current-strategy (up frame))) ))

(defun (compute-frame-depth INTEGER) ((frame CONTROL-FRAME))
  ;; Compute the depth of `frame' for the benefit of inference trace routines
  ;;    that need to run outside of the state-machine loop.
  ;; Utility function for trace functions that don't have access to the `depth'
  ;;    variable of the state machine.
  (let ((depth 0)
        (cursor
         (choose (defined? *queryIterator*)
                 (base-control-frame *queryIterator*)
                 NULL)))
    (while (defined? cursor)
      (when (eql? cursor frame)
        (break))
      (setq cursor (down cursor))
      (++ depth))
    (if (eql? cursor frame)
        (return depth)
      (return NULL))))

(defun print-vertical-bars ((depth INTEGER))
  ;; Print 'depth' vertical bars, separated by spaces.
  (foreach i on (interval 1 depth) do (print "| ")) )

(defun unwind-to-choice-points-below-frame ((frame CONTROL-FRAME))
  ;; Unwind variables bound after each choice point established at
  ;;    the farthest down frame below 'frame'.
  ;; Called by 'trace-goal-tree' to allow bindings to be seen accurately
  ;;    as we move down the control stack.
  (while (defined? (down frame))
    (setq frame (down frame)))
  (unwind-to-choice-point frame))

(defun trace-goal-tree ((frame CONTROL-FRAME) (depth INTEGER) (lastMove KEYWORD))
  ;; Print out a trace of backtracking goals and successes/failures.
  
  ;; tricky: initiate slightly premature unbinding
  ;;    (just before the state machine would have done it anyway) in order to
  ;;    make pattern variables print correctly (i.e., so they don't look bound 
  ;;    when they aren't):
  (when (eql? lastMove :DOWN)
    (unwind-to-choice-points-below-frame frame))
  (when (and (eql? (state frame) :ITERATIVE-FORALL)
             (eql? lastMove :DOWN))
    ;; premature exit because the overlay adds nothing to the previous :FORALL goal
    (return))
  (when (trace-keyword? :STATE-MACHINE)
    (typecase frame
      (PARALLEL-CONTROL-FRAME
       (print "P" (debug-frame-id frame)))
      (otherwise
       (print "F" (debug-frame-id frame))))
    (if (defined? (choice-point-unbinding-offset frame))
      (print "," (choice-point-unbinding-offset frame) " ")
      (print "   "))
    (print (choose (holds-by-default? frame) "D " "S ")))
  (when (or (eql? (state frame) :PARALLEL-STRATEGIES)
            (and (eql? (state frame) :STRATEGY)
                 (null? (current-strategy frame))))
    (return))
  ;; TO DO: FIGURE OUT THE TEST HERE (I CAN'T RECALL WHY WE WOULDN'T
  ;;    ALWAYS PRINT VERTIAL BARS) -rmm
  (when (not (and (eql? lastMove :DOWN)
                  (member? (quote (:ATOMIC-GOAL :STRATEGY))
                           (state frame))
                  (eql? (first (next-strategies frame)) :SPECIALIST)
                  (not (trace-keyword? :STRATEGIES))))
    (print-vertical-bars depth))
  (case lastMove
    (:DOWN
     (case (state frame)
       ((:ATOMIC-GOAL :STRATEGY)
        (if (eql? (first (next-strategies frame)) :SPECIALIST)        ; first time?
          (progn
            (when (trace-keyword? :STRATEGIES)
              (print "TRY STRATEGIES: "))  ; skip EOL:
            (return))
          (progn
            (print-goal-in-goal-tree frame depth)
            (when (trace-keyword? :STRATEGIES)
              (print EOL) (print-vertical-bars depth)
              (print "STRATEGY: ") ;skip EOL:
              (return)))))
       (:PATTERN
        ;; BUG: DOESN'T HANDLE OTHER THAN :ANTECEDENTS PROOFS YET:
        (trace-if :STRATEGIES EOL)      ; Only needed sometimes, but can't tell when.
        (let ((upFrame (up frame)))
          (if (and (defined? upFrame)
                   (defined? (antecedents-rule upFrame)))
            (print-rule-in-goal-tree frame (antecedents-rule upFrame) depth)
            (progn
              (when (partial-match-mode?) (print EOL))
              (if (defined? (collection-list (pattern-record frame)))
                (print "COLLECTION: [")
                (print "PATTERN: ["))
              (let ((firstTime? TRUE))
                (foreach tv in (boolean-vector (pattern-record frame))
                         do
                         (if firstTime?
                           (setq firstTime? FALSE)
                           (print ","))
                         (if tv (print "T") (print "F"))))
              (print "]")
              ))))
       (otherwise
        (print-goal-in-goal-tree frame depth))))
    (:UP-TRUE
     (case (state frame)
       (otherwise
        (print "| SUCC: " )
        (special ((*printInFrame* frame))
          (print-variable-bindings frame))
        (let ((truthValue (truth-value frame)))
          (when (defined? truthValue)
            (print "truth=")
            (cond ((true-truth-value? truthValue)
                   (if (default-truth-value? truthValue)
                       (print "t")
                     (print "T")))
                  ((false-truth-value? truthValue)
                   (if (default-truth-value? truthValue)
                       (print "f")
                     (print "F")))
                  ((unknown-truth-value? truthValue)
                   (print "U"))
                  (otherwise
                   (print "?"))))))))
    (:UP-FAIL
     (print "| FAIL")
     (case (state frame)
       ((:ATOMIC-GOAL :STRATEGY)
        (when (and (trace-keyword? :STRATEGIES)
                   (not (empty? (next-strategies frame))))
          (print EOL)
          (print-vertical-bars depth)
          (print "TRY STRATEGIES: ")    ; skip EOL:
          (return)))
       (otherwise NULL))
     (let ((truthValue (truth-value frame)))
       (when (or (defined? truthValue)
                 (defined? (partial-match-frame frame)))
         (print ":"))
       (when (defined? truthValue)
         (print " truth=")
         (cond ((true-truth-value? truthValue)
                (if (default-truth-value? truthValue)
                    (print "t")
                  (print "T")))
               ((false-truth-value? truthValue)
                (if (default-truth-value? truthValue)
                    (print "f")
                  (print "F")))
               ((unknown-truth-value? truthValue)
                (print "U"))
               (otherwise
                (print "?"))))))
    (otherwise (print "????: ")))
  (when (trace-keyword? :STATE-MACHINE)
    (print " state= " (state frame) "  lastMove= " lastMove
           " depth= " depth " revPty?= " (reverse-polarity? frame)))

  ;; Added to see partial matches in goal trace - Moriarty
  (cond
   ((not (defined? (partial-match-frame frame)))
    (print EOL))
   (otherwise
    (print " ")
    (case lastMove
      ((:DOWN :UP-TRUE :UP-FAIL)
       (trace-frame-partial-truth
        (partial-match-frame frame) lastMove STANDARD-OUTPUT)
       (print EOL))
      (otherwise NULL)))))


  ;;
;;;;;; Partial match interpreter, called within the query interpreter
  ;;

(defun (old-interpret-AND-scores KEYWORD) ((frame CONTROL-FRAME)
                                           (lastMove KEYWORD))
  ;; OLD VERSION OF THE PARTIAL MATCH INTERPRETER FOR :AND FRAMES; SHOULD
  ;;    GO AWAY ONCE WE'VE ADAPTED THE NN MATCHER TO THE NEW SCHEME ALSO.
  ;; Called at each move to an :AND state to compute the current 
  ;;    partial match scores, and to determine match success or failure.
  ;; The return value (:DOWN, :UP-TRUE, or :UP-FAIL) may override the
  ;;    state machine sequencing.
  (case lastMove
    (:DOWN
     (let ((pmf (partial-match-frame frame)))
       (if (null? pmf)
	   (create-and-link-partial-match-frame frame :AND)

	 ;; Pop partial match scores and weights until the number of weights
	 ;; agrees with the cursor position.  This resets the argument scores
	 ;; when you are retrieving alternate bindings
	 (progn
	   (while (> (length (argument-scores (partial-match-frame frame)))
		     (argument-cursor frame))
	     (pop-partial-match-score (partial-match-frame frame)))
	   (set-dynamic-cutoff pmf)))))

    ((:UP-TRUE :UP-FAIL)
     (let ((pmf (partial-match-frame frame))
	   (arity (length (arguments (proposition frame))))
	   (i 0))
       (setf (success? pmf) (eql? lastmove :UP-TRUE))
       (record-latest-partial-match-score frame)

       (when (trace-keyword? :GOAL-TREE)
	 (print (latest-positive-score *queryIterator*) ", "
		(compute-AND-score (partial-match-frame frame)) EOL))

       ;; If unbound vars were left by a function call, pass over all
       ;; propositions that refer to that variable
       (when (not (empty? (unbound-vars pmf)))
	 (setf (latest-positive-score *queryiterator*) 0.0)
	 (while (and (< (1+ (argument-cursor frame)) arity)
		     (exists var in (get-unbound-variables
				     (nth (arguments (proposition frame))
					  (1+ (argument-cursor frame))))
			 where
			   (search-cons-tree? (unbound-vars pmf) var)))
	   (++ i)
	   (setf (argument-cursor frame) (+ (argument-cursor frame) 1))
	   (record-latest-partial-match-score frame))
	 (setf (unbound-vars pmf) nil)
	 (when (trace-keyword? :GOAL-TREE)
	   (print "   *** Skipping " i " propositions . . ." EOL)))
       
       ;; If fail-unbound-clauses, then skip over any propositions with
       ;; all unbound variables
       
       (when *fail-unbound-clauses?*
	 (while (and (< (1+ (argument-cursor frame)) arity)
		     (all-variables-unbound? 
		      (nth (arguments (proposition frame))
			   (1+ (argument-cursor frame)))))
	   (++ i)
	   (setf (argument-cursor frame) (+ (argument-cursor frame) 1))
	   (setf (latest-positive-score *queryiterator*) 0.0)
	   (record-latest-partial-match-score frame))
	 (when (and (> i 0)
		    (trace-keyword? :GOAL-TREE))
	   (print "   *** Skipping " i " propositions . . ." EOL)))
       
       (cond 
	((compute-partial-match-AND-failure? frame)
;;	 (compute-partial-match-score? frame)
	 (setq lastMove :UP-FAIL))
	((and (eql? (1+ (argument-cursor frame)) arity)
              ;; all conjuncts evaluated; compute final score:
	      (not (compute-partial-match-score? frame)))
	 (setq lastMove :UP-FAIL))
	(otherwise
	 (setq lastMove :UP-TRUE))))))

  ;; if you are failing, clean up the frame:
  (when (and (eql? lastMove :UP-FAIL)
             (defined? (down frame)))
    (setf (down frame) NULL))
  (return lastMove) )

(defmethod (continue-partial-AND-proof KEYWORD) ((self CONTROL-FRAME)
                                                 (frame CONTROL-FRAME)
                                                 (lastMove KEYWORD))
  ;; Called instead of `continue-AND-proof' if we are in partial match mode
  ;;    to compute partial match scores and success or failure.
  ;; Wraps around `continue-AND-proof' to create an "advised" version.  The
  ;;    real work is done by methods defined on associated partial match frames.
  ;; The `frame' argument is needed, since `(control-frame self)' points to the
  ;;    first frame of an AND but not to any of its forward frames.
  (let ((pmf (partial-match-frame self)))
    (when (null? pmf)
      (create-and-link-partial-match-frame self :AND))
    (return
      (continue-partial-AND-proof (partial-match-frame self) frame lastMove))))

;;; TO DO: ADAPT TO NEW PARTIAL MATCH SCHEME SIMILAR TO HANDLING OF AND:
(defun (interpret-ITERATIVE-FORALL-scores KEYWORD) ((frame CONTROL-FRAME)
                                                    (lastMove KEYWORD))
  ;; Called at each move to an :ITERATIVE-FORALL state to compute the current 
  ;;    partial match scores, and to determine match success or failure.
  ;; The return value (:DOWN, :UP-TRUE, or :UP-FAIL) may override the
  ;;    state machine sequencing.
  ;; TODO: make this have the same semantics of an AND.  Currently, it just
  ;; fails if the score is less than 0.9
  (case lastMove
    (:DOWN
     (if (null? (partial-match-frame frame))
       (create-and-link-partial-match-frame frame :ITERATIVE-FORALL)

       ;; Pop partial match scores and weights until the number of weights
       ;; agrees with the cursor position.  This resets the argument scores
       ;; when you are retrieving alternate bindings
       (while (> (length (argument-scores (partial-match-frame frame)))
		 (argument-cursor frame))
	 (pop-partial-match-score (partial-match-frame frame)))))

    ((:UP-TRUE :UP-FAIL)
     (record-latest-partial-match-score frame)
     (when (trace-keyword? :GOAL-TREE)
       (print "ITERATIVE-FORALL " (latest-positive-score *queryIterator*) EOL))
     (when (< (latest-positive-score *queryIterator*) 0.9)
       (setq lastMove :UP-FAIL))))
  (return lastMove) )

(defun (old-interpret-OR-scores KEYWORD) ((frame CONTROL-FRAME)
                                          (lastMove KEYWORD))
  ;; OLD VERSION OF THE PARTIAL MATCH INTERPRETER FOR :OR GOALS; SHOULD
  ;;    GO AWAY ONCE WE'VE ADAPTED THE NN MATCHER TO THE NEW SCHEME ALSO.
  ;; Called at each move to an :OR state to compute the current 
  ;;    partial match scores, and to determine match success or failure.
  ;; The return value (:DOWN, :UP-TRUE, or :UP-FAIL) may override the
  ;;    state machine sequencing.
  (case lastMove
    (:DOWN
     (let ((pmf (partial-match-frame frame)))
       (if (null? pmf)
	   (create-and-link-partial-match-frame frame :OR)

	 ;; Pop partial match scores and weights until the number of weights
	 ;; agrees with the cursor position.  This resets the argument scores
	 ;; when you are retrieving alternate bindings
	 (progn
	   (while (> (length (argument-scores (partial-match-frame frame)))
		     (argument-cursor frame))
	     (pop-partial-match-score (partial-match-frame frame)))
	   (set-dynamic-cutoff pmf)))))
    ((:UP-TRUE :UP-FAIL)
     (record-latest-partial-match-score frame)
     (when (trace-keyword? :GOAL-TREE)
       (print (latest-positive-score *queryIterator*) ", "
              (compute-OR-score (partial-match-frame frame)) EOL))
     (cond
      ((compute-partial-match-OR-success? frame)
;;       (compute-partial-match-score? frame)
       (setq lastMove :UP-TRUE))
      ((and (eql? (1+ (argument-cursor frame))
                  (length (arguments (proposition frame))))
	    ;; all disjuncts evaluated; compute final score:
            (compute-partial-match-score? frame))
       (setq lastMove :UP-TRUE))
      (otherwise
       (setq lastMove :UP-FAIL)))))
    (return lastMove) )

(defmethod (continue-partial-OR-proof KEYWORD) ((self CONTROL-FRAME)
                                                (lastMove KEYWORD))
  ;; Called instead of `continue-OR-proof' if we are in partial match
  ;;    mode to compute partial match scores and success or failure.
  ;; Wraps around `continue-OR-proof' to create an "advised" version.
  ;;    Real work is done by methods defined on associated partial match frames.
  (let ((pmf (partial-match-frame self)))
    (when (null? pmf)
      (create-and-link-partial-match-frame self :OR))
    (return
      (continue-partial-OR-proof (partial-match-frame self) lastMove))))

(defun (old-interpret-FAIL-score KEYWORD) ((frame CONTROL-FRAME)
                                           (lastMove KEYWORD))
  ;; OLD VERSION OF THE PARTIAL MATCH INTERPRETER FOR :NOT GOALS; SHOULD
  ;;    GO AWAY ONCE WE'VE ADAPTED THE NN MATCHER TO THE NEW SCHEME ALSO.
  ;; Called at each move to a :NOT state to compute the current 
  ;;    partial match scores, and to determine match success or failure.
  ;; The return value (:DOWN, :UP-TRUE, or :UP-FAIL) may override the
  ;;    state machine sequencing.
  (case lastMove
    (:DOWN
     (setf (latest-positive-score *queryIterator*) 0.0)
     (when (null? (partial-match-frame frame))
       (create-and-link-partial-match-frame frame :NOT)))
    ((:UP-TRUE :UP-FAIL)
     (record-latest-partial-match-score frame)
     (if (compute-partial-match-score? frame)
       (setq lastMove :UP-TRUE)
       (setq lastMove :UP-FAIL))))
  (return lastMove) )

(defmethod (continue-partial-NOT-proof KEYWORD) ((self CONTROL-FRAME)
                                                 (lastMove KEYWORD))
  ;; Called instead of `continue-NOT-proof' if we are in partial match
  ;;    mode to compute partial match scores and success or failure.
  ;; Wraps around `continue-NOT-proof' to create an "advised" version.
  ;;    Real work is done by methods defined on associated partial match frames.
  (let ((pmf (partial-match-frame self)))
    (when (null? pmf)
      (create-and-link-partial-match-frame self :NOT))
    (return
      (continue-partial-NOT-proof (partial-match-frame self) lastMove))))

(defun (old-interpret-GOAL-scores KEYWORD) ((frame CONTROL-FRAME)
                                            (lastMove KEYWORD))
  ;; OLD VERSION OF THE PARTIAL MATCH INTERPRETER FOR ATOMIC GOALS; SHOULD
  ;;    GO AWAY ONCE WE'VE ADAPTED THE NN MATCHER TO THE NEW SCHEME ALSO.
  (case lastMove
    (:DOWN
     (let ((pmf (partial-match-frame frame)))
       (if (null? pmf)
	   (create-and-link-partial-match-frame frame :ATOMIC-GOAL)
	 (set-dynamic-cutoff pmf))))
    ((:UP-TRUE :UP-FAIL)
     ;; If this is a subgoalling strategy, treat it like an OR.  
     (when (trace-keyword? :GOAL-TREE)
       (print (latest-positive-score *queryIterator*) EOL))
     (when (or (eql? (current-strategy frame) :FULL-SUBQUERY)
               (eql? (current-strategy frame) :ANTECEDENTS))
       (record-latest-partial-match-score frame)
       (cond
	((and (compute-partial-match-OR-success? frame)
              (not (unbound-variables-in-frame? frame)))
	 (setq lastMove :UP-TRUE))
	;; check and see if this is the last rule
        ;; IS THIS REWRITE OK??? -rmm
	((and (empty? (iterator frame))
	      (not (unbound-variables-in-frame? frame))
	      ;; all disjuncts evaluated; compute final score:
	      (compute-partial-match-score? frame))
	 (setq lastMove :UP-TRUE))
	(otherwise
	 (setq lastMove :UP-FAIL))))))
  (attach-support frame lastmove) ;; simple justifications
  (when (and (eql? lastMove :UP-FAIL)
             (defined? (down frame)))
    (setf (down frame) NULL))
  (let ((result (continue-strategies-proofs frame lastMove)))
    (cond  ;; make sure you weren't shortcut:
     ((and (eql? result :FAILURE)
           (compute-partial-match-score? frame))
      (setq lastMove :UP-TRUE)
      (return :FINAL-SUCCESS))
     (otherwise
      (return result)))))

(defun attach-support ((frame CONTROL-FRAME) (lastmove KEYWORD))
  ;; quick and dirty justifications stuff for learning-partial-match
  ;; this should be cleaned up when real justifications arrive.
  (if (and (not (eql? lastmove :DOWN))
;;;	   (eql? (current-strategy frame) :FULL-SUBQUERY)
	   (eql? (current-strategy frame) :ANTECEDENTS)
	   (isa? (partial-match-frame frame) @NN-PARTIAL-MATCH)
	   ;; this next condition is a cop out.  Fix the problem, Dave.
	   (not (null? (child (partial-match-frame frame)))))
      (let ((pmf NN-PARTIAL-MATCH (partial-match-frame frame))
	    (support (new PARTIAL-SUPPORT)))
	(setf (id support) (++ *partial-support-counter*))
	(setf (axiom support) (first (rules pmf)))
	(setf (fact support) ;; get the proposition from below
	  (proposition (control-frame (child pmf))))
	(setf (argument-scores support) 
	  (reverse (copy-cons-list (argument-scores (child pmf)))))
	(setf (score support) (match-score (fact support)))
	(if (defined? (support (proposition frame)))
	    (setf (support (proposition frame)) 
	      (cons support (support (proposition frame))))
	  (setf (support (proposition frame)) (cons-list support))))
    (setf (support (proposition frame)) null)))

(defmethod (continue-partial-strategies-proofs KEYWORD) ((self CONTROL-FRAME)
                                                         (lastMove KEYWORD))
  ;; Called instead of `continue-strategies-proofs' if we are in partial match
  ;;    mode to compute partial match scores and success or failure.
  ;; Wraps around `continue-strategies-proofs' to create an "advised" version.
  ;;    Real work is done by methods defined on associated partial match frames.
  (when (eql? (current-strategy self) :FULL-SUBQUERY)
    ;; special-case, since this results in an overlay:
    (return (continue-strategies-proofs self lastMove)))
  (let ((pmf (partial-match-frame self)))
    (when (null? pmf)
      (create-and-link-partial-match-frame self :ATOMIC-GOAL))
    (return
      (continue-partial-strategies-proofs (partial-match-frame self) lastMove))))


  ;;
;;;;;; Control Frames
  ;;

(defun (operative-pattern-record PATTERN-RECORD) ((frame CONTROL-FRAME))
  ;; Return the pattern record for 'frame' that supplies its
  ;;    variables.
  (safety 3 (or (eql? (state frame) :PATTERN)
                (eql? (state frame) :CONTAINED-BY)
                (eql? (state frame) :POPPED)
                (null? (up frame))      ; base control frame
                (null? (pattern-record frame)))
          "BUG -- Unexpected defined 'pattern-record' slot.")
  (return (choose (defined? (pattern-record frame))
                  (pattern-record frame)
                  (inherited-pattern-record frame))) )

;; TO DO: INVENT FAST VERSION OF THIS THAT SKIPS MOST OF
;;    THE INITIALIZATIONS:
(defun (create-down-frame CONTROL-FRAME) 
       ((upFrame CONTROL-FRAME) (downProposition PROPOSITION))
  ;; Allocate a new control frame, initialize it, and doubly-link
  ;;    it to 'upFrame'.
  (let ((downFrame (new CONTROL-FRAME)))
    ;; set upward and downward links:
    (setf (down upFrame) downFrame)
    (setf (up downFrame) upFrame)
    ;; initialize state variables:
    (setf (reverse-polarity? downFrame) (reverse-polarity? upFrame))
    (setf (proposition downFrame) downProposition)
    (setf (down downFrame) NULL)
    (setf (back downFrame) NULL)
    (setf (pattern-record downFrame) NULL)
    (setf (truth-value downFrame) NULL)
    (clear (justifications downFrame))
    (setf (justification downFrame) NULL)
    (setf (goal-cache downFrame) NULL)
    (setf (goal-bindings downFrame) NULL)
    (setf (cached-bindings-iterator downFrame) NULL)
    (when (defined? downProposition)
      ;; note: 'try-full-subquery-proof' passes in NULL proposition
      (setf (state downFrame) (kind downProposition))
      (when (reverse-polarity? downFrame)
        (case (state downFrame)
          (:AND (setf (state downFrame) :OR))
          (:OR (setf (state downFrame) :AND))
          (otherwise NULL)))
      ;; initialize argument cursor:
      (setf (argument-cursor downFrame) 0))
    (setf (inherited-pattern-record downFrame)
          (operative-pattern-record upFrame))
    (return downFrame) ))

(defun (set-frame-truth-value TRUTH-VALUE)
    ((frame CONTROL-FRAME) (truthValue TRUTH-VALUE))
  ;; Set the truth-value of `frame' to `truthValue', or its inverse if
  ;;    `frame' is a reverse polarity frame.  Return the truth value
  ;;    assigned to `frame'.
  ;; IMPORTANT: For propagation of truth values between frames use
  ;;    `propagate-frame-truth-value', since it handles polarity flips.
  (return
    (setf (truth-value frame)
      (choose (reverse-polarity? frame)
              (invert-truth-value truthValue)
              truthValue))))

(defun (propagate-frame-truth-value TRUTH-VALUE) ((source CONTROL-FRAME)
                                                  (target CONTROL-FRAME))
  ;; Propagate the truth value of `source' to `target' and invert it if
  ;;    they have opposite polarity.  Return the truth value assigned
  ;;    to the `target' frame.
  (return
    (setf (truth-value target)
      (choose (not (eql? (reverse-polarity? source) (reverse-polarity? target)))
              (invert-truth-value (truth-value source))
              (truth-value source)))))


;;; Debugging aids:

(defglobal *control-frame-id-counter* INTEGER -1
  :documentation
  "Generates unique IDs for control frames.  Used only for debugging.")

(defslot CONTROL-FRAME debug-frame-id-internal :type INTEGER)
(defun (debug-frame-id INTEGER) ((frame CONTROL-FRAME))
  ;; Return a unique ID for `frame'.
  (let ((id (debug-frame-id-internal frame)))
    (when (null? id)
      (++ *control-frame-id-counter*)
      (setq id *control-frame-id-counter*)
      (setf (debug-frame-id-internal frame) id))
    (return id)))


  ;;
;;;;;; Parallel Control Frames
  ;;

(defun copy-frame-state ((fromFrame CONTROL-FRAME) (toFrame CONTROL-FRAME))
  ;; Called by 'parallelize-control-frame'.
  (setf (proposition toFrame) (proposition fromFrame))
  (setf (description toFrame) (description fromFrame))
  (setf (reverse-polarity? toFrame) (reverse-polarity? fromFrame))
  (setf (up toFrame) (up fromFrame))
  (setf (partial-match-frame toFrame) (partial-match-frame fromFrame))
;; STRATEGIES FRAMES SHOULDN'T USE THESE:
;  (setf (back toFrame) (back fromFrame))
;  (setf (argument-cursor toFrame) (argument-cursor fromFrame))
  (safety 3 (null? (pattern-record fromFrame)) "Bug in 'copy-frame-state'")
  (setf (inherited-pattern-record toFrame) (inherited-pattern-record fromFrame))
  (setf (choice-point-unbinding-offset toFrame)
        (choice-point-unbinding-offset fromFrame))
  (setf (next-strategies toFrame) (next-strategies fromFrame))
  (setf (cached-bindings-iterator toFrame) (cached-bindings-iterator fromFrame))
  (setf (goal-bindings toFrame) (goal-bindings fromFrame))
  (setf (goal-cache toFrame) (goal-cache fromFrame)))

(defun (parallelize-control-frame PARALLEL-CONTROL-FRAME) 
       ((frame CONTROL-FRAME))
  ;; Insure that the strategy frame 'frame' is a parallel control frame.
  ;; If not, parallelize as follows:
  ;;    Create a new parallel control frame with the same goal and
  ;;    "almost the same" pattern record environment
  ;;    as 'frame'.  Call it the parent frame.
  ;;    Transfer all untried strategies in '(next-strategies frame)'
  ;;    to the parent.
  ;;    If 'frame' has a continuable state, make 'frame' a child of the
  ;;    parent frame.  If not all arguments are bound, isolate the state
  ;;    of the child by copying its variable bindings and unbinding
  ;;    stack state, and then erasing (using 'create-choice-point')
  ;;    any side-effects created thus far by the child.
  ;; If 'frame' is the current frame, make parent the current frame.
  (when (eql? (state frame) :PARALLEL-STRATEGIES)
    (return frame))
  (let ((parallelParent PARALLEL-CONTROL-FRAME (new PARALLEL-CONTROL-FRAME)))
    (setf (state parallelParent) :PARALLEL-STRATEGIES)
    ;; copy non-strategy contents of 'frame' into 'parallelParent':
    (copy-frame-state frame parallelParent)
    ;; replace 'frame' by 'parallelParent' in the original stack:
    (setf (down (up frame)) parallelParent)
    ;; clear selected slots in 'frame':
    (setf (next-strategies frame) NIL)          ; parent still points to next strategies
    (setf (cached-bindings-iterator frame) NULL)
    (setf (goal-cache frame) NULL)
    ;; calculate 'unbound-variables?'
    (setf (unbound-variables? parallelParent)
          (not (all-arguments-bound? (proposition parallelParent))))
    ;; if 'frame' has a continuable state, create a thread for it, so that it
    ;;    can be reentered later on:
    (when (or (defined? (down frame))
              (defined? (iterator frame)))
      (let ((childThread (new PARALLEL-THREAD)))
        ;; link 'frame' below 'parallelParent':
        (setf (up frame ) parallelParent)
        (setf (top-control-frame childThread) frame)
        (insert (child-threads parallelParent) childThread)
        (when (unbound-variables? parallelParent)
          ;; record current state of query stacks in 'childThread':
          (let ((patternRecord (inherited-pattern-record frame)))
            (setf (variable-bindings childThread)
                  (copy (variable-bindings patternRecord)))
            (setf (unbinding-stack childThread)
                  (copy (unbinding-stack patternRecord)))
            (setf (top-unbinding-stack-offset childThread)
                  (top-unbinding-stack-offset patternRecord)))
          ;; wipe out bindings visible by the parent produced by the
          ;;    child frame:
;; TO DO: FIGURE OUT IF THIS IS A SAFE WAY TO ERASE BINDINGS:
;          (unwind-to-choice-point parallelParent)
          )))
    (when (eql? (current-control-frame *queryIterator*) frame)
      (setf (current-control-frame *queryIterator*) parallelParent))
    (return parallelParent)) )

(defun enter-parallel-thread 
       ((pFrame PARALLEL-CONTROL-FRAME) (childThread PARALLEL-THREAD))
  ;; We are moving down from 'pFrame' into the frame for 'childThread', or
  ;;    for the current thread if 'childThread' is NULL.
  ;; Possibly change to a hypothetical world.
  (if (defined? childThread)
    (progn
      (setf (current-child-thread pFrame) childThread)
      (setf (down pFrame) (top-control-frame childThread)))
    (setq childThread (current-child-thread pFrame)))
  (setf (saved-parent-parallel-thread pFrame)
        (current-parallel-thread *queryIterator*))
  (setf (current-parallel-thread *queryIterator*) childThread)
  (setf (saved-parent-context pFrame) *context*)
  (when (defined? (hypothetical-world childThread))
    (change-context (hypothetical-world childThread))) )

(defun exit-parallel-thread ((pFrame PARALLEL-CONTROL-FRAME))
  ;; We are moving up out of a thread.
  ;; Possibly exit from a hypothetical world.
  (setf (current-parallel-thread *queryIterator*)
        (saved-parent-parallel-thread pFrame))
  (when (defined? (saved-parent-context pFrame))
    (if (and (null? (down pFrame))
             (defined? (hypothetical-world (current-child-thread pFrame))))
      (progn
        (pop-world)                     ; discard hypothetical world
        (safety 3 (eql? *context* (saved-parent-context pFrame))
                "INTERNAL ERROR: Bug switching contexts"))
      (change-context (saved-parent-context pFrame)))
    (setf (saved-parent-context pFrame) NULL))
  (when (null? (down pFrame))
    (remove (child-threads pFrame) (current-child-thread pFrame))
    (setf (current-child-thread pFrame) NULL)) )

(defun (enter-hypothetical-world WORLD) ((pFrame PARALLEL-CONTROL-FRAME))
  ;; Change the context to the hypothetical world for the current
  ;;    child frame environment of 'pFrame'.
  ;; Side-effect:  If the current child frame environment for 'pFrame'
  ;;    has not yet been assigned its own hypothetical world, create one.
  (let ((childThread (current-child-thread pFrame))
        (world (hypothetical-world childThread)))
    ;; if 'world' is defined already, then we must already be in it.
    ;; otherwise, create a new world, and save the old context:
    (if (null? world)
      (progn
        (setf (hypothetical-world childThread) (push-monotonic-world))
        (initialize-inference-world *context*))
      (safety 3 (eql? *context* world) "Bug entering hypothetical world"))
    (return world) ))


  ;;
;;;;;; Query Interpreter
  ;;

;;;  Macros and functions define the moves of a state machine
;;;    that manipulates the stacks in a query environment while evaluating
;;;    a query.  A "move" involves pushing, popping, or overlaying the
;;;    top query frame.  The function 'execute-backward-chaining-proof?'
;;;    declares local variables 'frame', and 'lastMove' that
;;;    are referenced by the macros.

;;; The macros 'move-in-place', 'move-forward', 'move-backward', 'move-down',
;;;    and 'move-up' were moved to 'logic-macros.ste'.

(defun (partial-match-mode? BOOLEAN) ()
  ;; Return TRUE if a query is computing partial matches.
  :globally-inline? TRUE
  (return (and (defined? *queryIterator*)
               (defined? (partial-match-strategy *queryIterator*))) ))

(defun (execute-backward-chaining-proof? BOOLEAN) ((query QUERY-ITERATOR))
  ;; Generate successive sets of bindings that satisfy `query'.
  ;; NOTE: It is the responsibility of the caller to setup `*context*'.
  (when (null? (down (base-control-frame query)))
    (return FALSE))
  (special ((*queryIterator* query))
    (let ((frame (base-control-frame query))
          (depth 0)
          ;; state variable:
          (lastMove :DOWN)
          (resultOfNextMove KEYWORD NULL)
          ;; query clock:
          (clockTicks (current-clock-ticks query))
          (startTime (get-ticktock))
          (startTicks clockTicks)
          (allottedTime (allotted-time query))
          (allottedTicks (allotted-clock-ticks query))
          (checkForTimeout? (defined? allottedTime))
          (checkForMoveout? (defined? allottedTicks))
          (traceSubgoals? (trace-keyword? :GOAL-TREE))
          (timeout? FALSE)
          (success? FALSE))

      (setf (timeout? query) FALSE)
      ;; simulate `move-down' into base control frame without a parent:
      (setf (starting-clock-ticks frame) clockTicks)
      (when checkForMoveout?
        ;; We don't need to propagate this, it will be done by the down move:
        (setf (allotted-clock-ticks frame) allottedTicks))
      ;; reset `truth-value' and friends for new round of inference:
      (setf (truth-value frame) NULL)
      (setf (justification frame) NULL)
      (when (partial-match-mode?)
        ;; attach partial match frame to base-control-frame and reset it:
        (setf (partial-match-frame frame)
          (partial-match-strategy query))
        (clear-frame-partial-truth (partial-match-frame frame)))
      (setq lastMove :DOWN)
      
      (loop
        (safety 3 (not (deleted? *context*)) 
                "INTERNAL ERROR: Slipped into a deleted context.")
        (setf (current-control-frame query) frame)

        ;; handle tracing:
        (when traceSubgoals?
          (case lastMove
            ((:UP-TRUE :UP-FAIL)
             (trace-goal-tree
              ;; since we moved up, `frame' already points at the parent of the
              ;;    frame that produced the last result, so, rebind to result:
              (result frame)
              depth lastMove))
            (otherwise
             (trace-goal-tree frame depth lastMove))))

        ;; handle global CPU timeouts:
        (when (and checkForTimeout?
                   (= (logand clockTicks 15) 0)) ;; check every 16 down moves
          (let ((currentTime (get-ticktock))
                (difference (ticktock-difference startTime currentTime)))
            (when (>= difference 0.02)
              (-- allottedTime difference)
              (setq startTime currentTime))
            (when (<= allottedTime 0.0)
              (setq timeout? TRUE))))

        (setq resultOfNextMove (evaluate-next-move frame lastMove clockTicks))
        (setq frame (current-control-frame query))

        (case resultOfNextMove
          (:MOVE-DOWN
           (move-down)
           (when (and timeout?
                      (eql? lastMove :DOWN))
             (setq success? FALSE)
             (break)))
          (:FINAL-SUCCESS
           (move-up TRUE POP-FRAME))
          (:CONTINUING-SUCCESS
           (move-up TRUE KEEP-FRAME))
          (:FAILURE
           (move-up FAIL POP-FRAME))
          (:MOVE-IN-PLACE
           (move-in-place))
          (:TIMEOUT
           (move-up FAIL KEEP-FRAME))))
      (setf (allotted-time query) allottedTime)
      (setf (timeout? query) timeout?)
      (when checkForMoveout?
        (setf (allotted-clock-ticks query)
          ;; subtract what we've used up so far:
          (max (- allottedTicks (- clockTicks startTicks)) 0))
        (unless timeout?
          (setf (timeout? query) (= (allotted-clock-ticks query) 0))))
      (return success?))))

(defun (evaluate-next-move KEYWORD)
       ((frame CONTROL-FRAME) (lastMove KEYWORD) (clockTicks INTEGER))
  ;; Dispatch proof procedures for the query machine.
  (case (state frame)
    (:AND
     (if (partial-match-mode?)
         (return (continue-partial-AND-proof frame frame lastMove))
       (return (continue-AND-proof frame lastMove))))
    (:OR
     (if (partial-match-mode?)
         (return (continue-partial-OR-proof frame lastMove))
       (return (continue-OR-proof frame lastMove))))
    (:NOT
     (if (partial-match-mode?)
         (return (continue-partial-NOT-proof frame lastMove))
       (return (continue-NOT-proof frame lastMove))))
    ((:ISA :FUNCTION :PREDICATE :EQUIVALENT :IMPLIES)
     ;; Moved creation of choicepoint into `initiate-atomic-goal-proofs' after
     ;; yield-goal-bindings is called, otherwise, bindings cached during that step (e.g.,
     ;; from description variables being bound to computed values) will immediately
     ;; be undone in `continue-strategies-proofs':
     ;(create-choice-point frame)
     (return (initiate-atomic-goal-proofs frame)))
    ((:ATOMIC-GOAL :STRATEGY)
     (if (partial-match-mode?)
         (return (continue-partial-strategies-proofs frame lastMove))
       (return (continue-strategies-proofs frame lastMove))))
    (:SCAN-CACHED-BINDINGS 
     (return (continue-cached-bindings-proof frame lastMove)))
    (:PATTERN (return (continue-pattern-proof frame lastMove)))
    (:FORALL (return (continue-FORALL-proof frame lastMove)))
    ((:CONTAINED-BY :ITERATIVE-FORALL)
     (when (partial-match-mode?)
       (setq lastMove (interpret-ITERATIVE-FORALL-scores frame lastMove)))
     (return (continue-contained-by-proof frame lastMove)))
    (:EXISTS (return (continue-EXISTS-proof frame lastMove)))
    (:CONSTANT (return (continue-CONSTANT-proof frame lastMove)))
    (:FAIL
     (if (partial-match-mode?)
         (return (continue-partial-FAIL-proof frame lastMove))
       (return (continue-FAIL-proof frame lastMove))))
    (:PARALLEL-STRATEGIES
     (return (continue-parallel-strategies-proofs frame lastMove)))
    (otherwise
     (signal FAIL-EXCEPTION
	     "Error.  No query state implemented for operator " 
	     (state frame) EOL)
     )) )


  ;;
;;;;;; :AND, :OR, and :NOT logic
  ;;

(defmethod (clustered-conjunction? BOOLEAN) ((self PROPOSITION))
  ;; Return TRUE if `self' is a clustered conjunction where any two
  ;;    clusters do not share any unbound variables.
  ;; Clustered conjunctions are generated by the optimizer which converts
  ;;    open subgoal clusters into conjunctive arguments of `self'.
  ;; NOTE: Clustered conjunctions can never be entered directly by the user,
  ;;    since they are flattened away during normalization.
  (return
    (exists conjunct in (arguments self)
      where (eql? (kind (cast conjunct PROPOSITION)) :AND))))
  
(defun (continue-AND-proof KEYWORD) ((frame CONTROL-FRAME) (lastMove KEYWORD))
  ;; Move into and back out of an :AND control frame.
  (let ((proposition (proposition frame))
        (conjuncts (VECTOR OF CONTROL-FRAME) NULL))
    (case lastMove
      (:DOWN
       ;; either we are pointing at the first conjunct, or we are
       ;;    pointing at the last conjunct having future bindings
       ;;    during an exit of a prior successful evaluation:
       (cond
        ((clustered-conjunction? proposition)
         (overlay-with-strategy-frame frame :CLUSTERED-CONJUNCTION)
         (return :MOVE-IN-PLACE))
        ;; if closed, switch from NOT to FAIL proof:
        ((and (reverse-polarity? frame)
              (closed-proposition? proposition))
         (return (overlay-with-fail-frame frame proposition)))
        (otherwise
         (setq conjuncts (arguments frame))
         (when (null? conjuncts)
           ;; first time around (minor performance bug: if the first conjunct
           ;;    fails, we allocated a vector for nothing):
           (setq conjuncts
             (new VECTOR :array-size (length (arguments proposition))))
           (setf (arguments frame) conjuncts)
           (when (dynamically-optimize-proposition? proposition)
             ;; copy the proposition arguments vector, so reordering them
             ;;    during optimization doesn't influence recursive goals:
             (setq proposition (shallow-copy-proposition proposition))
             (setf (proposition frame) proposition)))
         (when (and (dynamically-optimize-proposition? proposition)
                    ;; if we already have a down frame, don't reoptimize, since
                    ;;    that's unnecessary and could destroy the alignment
                    ;;    between proposition and frame arguments:
                    (null? (down frame)))
           (dynamically-reoptimize-arguments
            (arguments proposition) (argument-cursor frame)))
         (return :MOVE-DOWN))))

      (:UP-TRUE
       (setq conjuncts (arguments frame))
       (setf (nth conjuncts (argument-cursor frame)) (result frame))
       (cond
        ((= (argument-cursor frame) (1- (length conjuncts)))
         ;; all conjuncts evaluated successfully, compute results:
         (setf (down frame) NULL)
         (foreach conjunct in conjuncts
             as i in (interval 0 NULL)
             do (setf (truth-value frame)
                  (choose (= i 0)
                          (truth-value conjunct)
                          (conjoin-truth-values
                           (truth-value frame)
                           (truth-value conjunct))))
                ;; find the most recent conjunct that is still alive:
                (when (not (eql? (state conjunct) :POPPED))
                  (setf (argument-cursor frame) i)
                  (setf (down frame) conjunct)))
         (when (record-justifications?)
           (record-AND-INTRODUCTION-justification frame lastMove))
         (if (defined? (down frame))
             (return :CONTINUING-SUCCESS)
           (return :FINAL-SUCCESS)))
        (otherwise
         ;; evaluate next conjunct:
         (setf (down frame) NULL)
         (++ (argument-cursor frame))
         (when (dynamically-optimize-proposition? proposition)
           (dynamically-reoptimize-arguments
            (arguments proposition) (argument-cursor frame)))
         (return :MOVE-DOWN))))

      (:UP-FAIL
       (setq conjuncts (arguments frame))
       (when (null? conjuncts)
         (setf (truth-value frame)
           (conjoin-truth-values UNKNOWN-TRUTH-VALUE (truth-value (result frame))))
         (return :FAILURE))
       (setf (down frame) NULL)
       (foreach conjunct in conjuncts
           as i in (interval 0 NULL)
           do ;; find the most recent conjunct that is still alive:
             (when (null? conjunct)
               (break))
             (when (not (eql? (state conjunct) :POPPED))
               (setf (argument-cursor frame) i)
               (setf (down frame) conjunct)))
       (cond
        ((defined? (down frame))
         (return :MOVE-DOWN))
        (otherwise
         ;; fail, since there is no preceeding conjunct to backtrack to:
         (propagate-frame-truth-value (result frame) frame)
         ;; if any of the evaluated conjuncts is false, propagate up falsity
         ;;    (we need to look at all of them, because of the partial matcher):
         (setf (nth conjuncts (argument-cursor frame)) (result frame))
         (foreach conjunct in conjuncts
             as i in (interval 0 (argument-cursor frame))
             do (ignore i)
		(when (null? conjunct)
                  (break))
                (setf (truth-value frame)
                  (conjoin-truth-values (truth-value frame) (truth-value conjunct))))
         (return :FAILURE)))))))

(defun (continue-or-proof KEYWORD) ((frame CONTROL-FRAME) (lastMove KEYWORD))
  ;; Move into and back out of an :OR control frame.
  ;; At any time, at most one query frame representing a disjunct is
  ;;    on the stack -- each successive disjunct overlays the previous one:
  (let ((proposition (proposition frame)))
    (case lastMove
      (:DOWN
       ;; if closed, switch from NOT to FAIL proof:
       (when (and (reverse-polarity? frame)
                  (closed-proposition? proposition))
         (return (overlay-with-fail-frame frame proposition)))
       ;; evaluate next disjunct or previously-successful disjunct:
       (unless (defined? (down frame))
         ;; only create a choice point if we are moving down to a new goal,
         ;; otherwise the creation might undo variable bindings we still need:
         (create-choice-point frame))
       (return :MOVE-DOWN))
      (:UP-TRUE
       (setf (truth-value frame) (truth-value (result frame)))
       (when (record-justifications?)
         (record-OR-INTRODUCTION-justification frame lastMove))
       (when (null? (down frame))
         (setf (argument-cursor frame) (1+ (argument-cursor frame))))
       ;; tricky: if we can succeed without creating new bindings, then we
       ;;    conclude that the success is final instead of continuing:
       (cond
        ((or (>= (argument-cursor frame) (length (arguments proposition)))
             (and (not (new-bindings-since-last-choice-point? frame))
                  (not *generate-all-proofs?*)))
         ;; NOTE: GOAL proofs don't propagate :FINAL-SUCCESS from 
         ;;    individual strategies if there are more strategies to try.
         ;;    In such a case we have to pop the :ATOMIC-GOAL frame here:
         (when (defined? (down frame))
           (pop-frames-up-to (down frame)))
         (return :FINAL-SUCCESS))
        (otherwise
         (return :CONTINUING-SUCCESS))))
      (:UP-FAIL
       ;; make sure we propagate-up falsity:
       (setf (truth-value frame)
         (choose (null? (truth-value frame))
                 ;; first time around, make sure we set the slot to something defined:
                 (first-defined (truth-value (result frame)) UNKNOWN-TRUTH-VALUE)
                 (disjoin-truth-values
                  (truth-value frame)
                  (truth-value (result frame)))))
       ;; move cursor to point to next disjunct (if there is one):
       (setf (argument-cursor frame) (1+ (argument-cursor frame)))
       (if (< (argument-cursor frame)
              (length (arguments proposition)))
         ;; evaluate next disjunct:
         (progn
           (create-choice-point frame)
           (return :MOVE-DOWN))
         ;; possibly try disjunctive-implication proof:
         (case (keyword (current-inference-level))
           ((#|:NORMAL|# :REFUTATION)
            (overlay-with-strategy-frame frame :DISJUNCTIVE-IMPLICATION-INTRODUCTION)
            (return :MOVE-IN-PLACE))
           (otherwise
            (return :FAILURE)))))) ))

(defun (continue-NOT-proof KEYWORD) ((frame CONTROL-FRAME) (lastMove KEYWORD))
  ;; Move into or out of a :NOT control frame.
  ;; Interpret a :NOT goal by inverting the 'reverse-polarity?' slot
  ;;    on 'frame'.  This gets inherited by frame allocated for the argument
  ;;    to the :NOT, making it operate with reversed polarity.
  (case lastMove
    (:DOWN
     (when (defined? (down frame))
       (return :MOVE-DOWN))
     (let ((argument PROPOSITION (first (arguments (proposition frame)))))
       ;; switch from NOT proof to FAIL proof, on the theory that
       ;;    its easier to prove failure than a strict negation:
       (when (and (not (reverse-polarity? frame))
                  (closed-proposition? argument))
         (return (overlay-with-fail-frame frame argument)))
       ;; tricky: we "prematurely" create a down frame that would have been
       ;;    created directly upon return so that we can reverse its polarity here:
       (create-down-frame frame argument)
       (setf (reverse-polarity? (down frame)) (not (reverse-polarity? frame)))
       (return :MOVE-DOWN)))
    (:UP-TRUE
     (setf (truth-value frame)
       (invert-truth-value (truth-value (result frame))))
     (when (record-justifications?)
       (record-DISPROOF-justification frame lastMove))
     (cond
      ((null? (down frame))
       (return :FINAL-SUCCESS))
      (otherwise
       (return :CONTINUING-SUCCESS))
      #|
      ;; THESE HAVE BEEN CLIPPED OUT TO ALLOW NEGATED GENERATORS:  -rmm
      (*generate-all-proofs?*
       (return :CONTINUING-SUCCESS))
      (otherwise
       ;; eliminate any down frames and return for good:
       (pop-frames-up-to (down frame))
       (return :FINAL-SUCCESS))
       |#
      ))
    (:UP-FAIL
     (setf (truth-value frame)
       (invert-truth-value (truth-value (result frame))))
     (when (and (record-justifications?)
                ;; This will not be defined for UNKNOWN or INCONSISTENT results:
                (defined? (justification (result frame))))
       (record-DISPROOF-justification frame lastMove))
     (return :FAILURE))))

(defun (overlay-with-fail-frame KEYWORD) 
       ((frame CONTROL-FRAME) (proposition PROPOSITION))
  ;; Convert 'frame', which has reversed polarity, to a :FAIL frame,
  ;;    with 'proposition' as the argument to the FAIL.
  ;; Cancel the reversed polarity.
  ;; This overlay is applied when the proposition is closed.
  (let ((failProposition (create-proposition (quote FAIL) 1)))
    (setf (nth (arguments failProposition) 0) proposition)
    (setf (proposition frame) failProposition)
    (setf (state frame) :FAIL)
    (setf (reverse-polarity? frame) FALSE)
    (return :MOVE-IN-PLACE) ))


  ;;
;;;;;; Evaluation of atomic propositions within a query
  ;;

(defspecial *reversePolarity?* BOOLEAN FALSE
  :public? TRUE
  :documentation "Signals atomic proposition provers that polarity is negative.")

(defun (overlay-with-strategy-frame KEYWORD) ((frame CONTROL-FRAME) (strategy KEYWORD))
  ;; Convert 'frame' into a :STRATEGY frame, with 'strategy' specifying the
  ;;    next proof strategy.
  (setf (next-strategies frame) (cons-list strategy))
  (setf (state frame) :STRATEGY)
  (return :MOVE-IN-PLACE) )

(defun (check-for-duplicate-goal? BOOLEAN) ((frame CONTROL-FRAME))
  ;; Return TRUE if the goal in 'frame' is a duplicate of another
  ;;    above it on the stack.
  (unless (or (eql? *duplicate-subgoal-strategy* :DUPLICATE-GOALS)
              (eql? *duplicate-subgoal-strategy* :DUPLICATE-GOALS-WITH-CACHING))
    (return FALSE))
  (let ((operator (operator (proposition frame)))
        (goalBindings (goal-bindings frame))
        (previousFrame (up frame))
        (duplicateFrame CONTROL-FRAME NULL))
    (foreach i in (interval 1 *duplicate-goal-search-depth*)
        do (ignore i)
	   (when (null? previousFrame)
             (break))
           (when (and (defined? (goal-bindings previousFrame))
                      (eql? operator (operator (proposition previousFrame)))
                      (forall b1 in goalBindings
                          as b2 in (goal-bindings previousFrame)
                          always (eql? b1 b2))
                      (eql? (reverse-polarity? frame)
                            (reverse-polarity? previousFrame)))
             (setq duplicateFrame previousFrame)
             (break))
           (setq previousFrame (up previousFrame)))
    (cond
     ((defined? duplicateFrame)
      (trace-goal-cache "DUPLICATE GOAL:" frame)
      (when (cache-query-results?)
        ;; To be safe, don't cache failure on all intermediate frames:
        (dont-cache-goal-failure-between-frames frame (down duplicateFrame)))
      (return TRUE))
     (otherwise
      (return FALSE)))))

(defun (initiate-atomic-goal-proofs KEYWORD) ((frame CONTROL-FRAME))
  ;; 'frame' points to an atomic proposition.  Generate the next set
  ;;    of bindings for its goal.
  (special ((*reversePolarity?* (reverse-polarity? frame)))
   (let ((proposition (proposition frame))
         (inferenceLevel (keyword (current-inference-level)))
         (strategies (CONS OF KEYWORD) NULL))
;; CHANGED TO ALLOW ITERATION OVER UNBOUND NEGATED PROPOSITIONS:
;     (when (and *reversePolarity?*
;                (not (all-arguments-bound? proposition)))
;       (return :FAILURE))
     (case (kind proposition)
       ((:PREDICATE :ISA :FUNCTION)
        ;; check for duplicate subgoal; if found, use limited inference
        ;;    or use cached bindings:
        (setf (goal-bindings frame)
              (yield-goal-bindings proposition))
        (when (check-for-duplicate-goal? frame)
          (case *duplicate-subgoal-strategy*
            (:DUPLICATE-GOALS
             (setq inferenceLevel :SHALLOW))
            (:DUPLICATE-GOALS-WITH-CACHING
             (setf (state frame) :SCAN-CACHED-BINDINGS)
             (create-choice-point frame)
             (return :MOVE-IN-PLACE))))
        (case inferenceLevel
          ((:NORMAL :BACKTRACKING)
           (setq strategies
                 (quote
                  (:SPECIALIST :LOOKUP-GOAL-CACHES :LOOKUP-ASSERTIONS 
                               :SHALLOW-DISPROOF :ALL-SUBGOAL-STRATEGIES))))
          (:REFUTATION
           (setq strategies
                 (quote
                  (:SPECIALIST :LOOKUP-GOAL-CACHES :LOOKUP-ASSERTIONS 
                               :SHALLOW-DISPROOF :ALL-SUBGOAL-STRATEGIES :REFUTATION))))
          (otherwise
           (setq strategies
                 ;; Since caching is not yet sensitive to inference levels we disable
                 ;; it in non-chaining inference modes, otherwise we can get unexpected
                 ;; results if, for example, we are looking for assertions only; the
                 ;; proper fix would be to build this into the caching machinery:
                 ;; PROBLEM: IF WE HAVE RECURSIVE RULES, WE NEED PREVIOUSLY CACHED RESULTS
                 ;; WHEN WE CUT OFF A DUPLICATE SUBGOAL; IN FACT, WE NEED COMPLETE
                 ;; CACHED RESULTS AND NOT THE INCOMPLETE VERSION WE ARE USING NOW...
                 (quote
                  (:SPECIALIST :LOOKUP-GOAL-CACHES :LOOKUP-ASSERTIONS :SHALLOW-DISPROOF)))))
        (when (and (eql? (kind proposition) :FUNCTION)
                   (not *reversePolarity?*))
          (setq strategies
                (concatenate (copy-cons-list strategies) 
                             (cons-list :MANUFACTURE-SKOLEM)))))
       (:EQUIVALENT
        (setq strategies (quote (:EQUIVALENCE))))
       (:IMPLIES
        (setq strategies (quote (:SPECIALIST :ALL-SUBGOAL-STRATEGIES :IMPLIES)))))
     ;; Convert 'frame' from a proposition frame into a :ATOMIC-GOAL frame,
     ;;    with 'strategies' specifying the initial KEYWORD list of untried
     ;;    proof strategies.
     (setf (next-strategies frame) strategies)
     (setf (state frame) :ATOMIC-GOAL)
     ;; moved here from `evaluate-next-move' (which see):
     (create-choice-point frame)
     (return :MOVE-IN-PLACE) )))

(defun (all-arguments-bound? BOOLEAN) ((goal PROPOSITION))
  ;; Return TRUE if all arguments of 'goal', including arguments nested
  ;;    inside of a propositional argument, are bound.
  (if (defined? (io-variables goal))
      (return (quantified-argument-bound? goal NULL))
    (return (argument-bound? goal))))

(defun (all-key-arguments-bound? BOOLEAN) ((goal PROPOSITION))
  ;; Return TRUE if all key arguments of `goal' (i.e., the input arguments
  ;;    of a function or single-valued predicate) are bound.
  ;; TO DO: IMPROVE THIS TO UNDERSTAND UNIQUNESS KEYS.
  (if (or (eql? (kind goal) :FUNCTION)
          (single-valued-predicate? goal))
      (if (defined? (io-variables goal))
          (return
            (forall i in (interval 0 (- (length (arguments goal)) 2))
                always (quantified-argument-bound? (nth (arguments goal) i) NULL)))
        (return
            (forall i in (interval 0 (- (length (arguments goal)) 2))
                always (argument-bound? (nth (arguments goal) i)))))
    (return FALSE)))


  ;;
;;;;;; PATTERN-RECORDs
  ;;

(defun (create-pattern-record PATTERN-RECORD)
       ((frame CONTROL-FRAME) (description DESCRIPTION) 
        (externalArguments ARGUMENTS-VECTOR))
  ;; Allocate (from the stack 'subquery-frame-stack') a subquery
  ;;    frame, point it at 'description', and copy unbound
  ;;    variables in 'externalArguments' into the vector
  ;;    '(unbound-arguments iterator)'.
  ;; Doubly-link the subquery frame to 'frame'.
  ;; Initialize a stored-arguments iterator.
  ;; If 'description' is NULL, the :CONTAINED-BY logic is allocating a dummy frame.
  (let ((patternRecord (new PATTERN-RECORD)))
    (when (defined? description)
      (setf (description patternRecord) description)
      (if (defined? externalArguments)
        (let ((externalArgumentsCopy
               (copy-pattern-arguments externalArguments description)))
          ;; record environment for evaluating a pattern:
          (setf (external-arguments patternRecord) externalArgumentsCopy)
          (setf (boolean-vector patternRecord)
                (arguments-vector-to-boolean-vector externalArgumentsCopy)))
        ;; compute 'boolean-vector' without referencing 'externalArguments'
        ;;    that reflects all unbound variables:
        (let ((onesList (new LIST)))
          (foreach v on (io-variables description)
                   collect ZERO-WRAPPER into onesList)
          (setf (boolean-vector patternRecord)
                (zero-one-list-to-boolean-vector onesList))
          (free onesList))))
    (setf (collection-list patternRecord) NULL)
    ;; doubly-link to 'frame':
    (setf (pattern-record frame) patternRecord)
    (setf (control-frame patternRecord) frame)
    (return patternRecord) ))

(defun (terminate-pattern-record? BOOLEAN) ((self PATTERN-RECORD))
  ;; Free storage tied to 'self'.
  ;; Tricky: Reset current pattern frame to parent:
  (when (defined? (external-arguments self))
    (free (external-arguments self)))
  (setf (optimal-pattern self) NULL)
  (return TRUE))

(defun (copy-pattern-arguments ARGUMENTS-VECTOR) ((arguments OBJECT-VECTOR)
                                                  (description DESCRIPTION))
  ;; Make a copy of (external) 'arguments'.  Conceivably, there could be more
  ;; than are consumed by `description' which is why we are using its arity.
  (when (null? arguments)
    (return NULL))
  (let ((argumentCount (arity description))
        (copiedArguments ARGUMENTS-VECTOR NULL))
    (when (= argumentCount -1)
      ;; `description is variable arity, consume all arguments:
      (setq argumentCount (length arguments)))
    (setq copiedArguments
      (new ARGUMENTS-VECTOR :array-size argumentCount))
    (foreach i in (interval 0 (1- argumentCount))
        do (setf (nth copiedArguments i) (nth arguments i)))
    (return copiedArguments)) )


  ;;
;;;;;; :PATTERN frames
  ;;

(defun (compute-external-bindings CONS) ((externalArguments ARGUMENTS-VECTOR))
  ;; Return a cons list of values representing current bindings of
  ;;    variables in 'externalArguments'.
  (let ((externalBindings NIL))
    (when (null? externalArguments)
      (return NIL))
    (foreach arg in externalArguments
        collect (instantiate-external-bindings (safe-argument-bound-to arg))
        into externalBindings)
    (return externalBindings) ))

(defun (instantiate-external-bindings OBJECT) ((self OBJECT))
  ;; Instantiate any bound external variables of `self' with their current
  ;;    bindings and return the instantiated object.
  ;; This is useful for cases where a variable is bound to a description that
  ;;    references external variables, e.g., the following query generates
  ;;    such a case via a `cardinality' rule that uses `collect-into-set'
  ;;    (see test suite):
  ;;
  ;;         (retrieve (?c ?x)
  ;;           (and (brother susi ?x)
  ;;                (= (cardinality (setofall (?f) (brother ?x ?f))) ?c)))
  ;;
  ;;    Unfortunately, the external variables mechanism isn't sufficient to
  ;;    handle this, since the `bound-to-offset' of ?x will point to the
  ;;    wrong variable in the subgoal frame (it was already initialized when
  ;;    the top-level description got copied).
  (typecase self
    (NAMED-DESCRIPTION NULL)
    (DESCRIPTION
     (when (defined? (external-variables self))
       (let ((mapping (new ENTITY-MAPPING)))
         (foreach var in (external-variables self)
             where (argument-bound? var)
             do (insert-at mapping var (safe-argument-bound-to var)))
         (unless (empty? mapping)
           (return (instantiate-external-variables self mapping))))))
    ;; some day we might also want to do this for propositions:
    (PROPOSITION NULL)
    (otherwise NULL))
  (return self))

(defun (instantiate-external-variables DESCRIPTION) ((self DESCRIPTION)
                                                     (bindings ENTITY-MAPPING))
  ;; Instantiate any external variables of `self' with their current
  ;;    binding from `bindings' and return the instantiated description.
  (unless (empty? bindings)
    (special ((*evaluationMode* :DESCRIPTION)
              (*queryIterator* NULL))
      (let ((description (new DESCRIPTION)))
        ;; re-evaluate terms, since in descriptions named objects
        ;;    are represented via surrogates to avoid backlinking:
        (foreach (var binding) in bindings
            do (insert-at bindings var (evaluate-term binding)))
        (setf (io-variables description) (copy (io-variables self)))
        ;; ensure unbound variables are mapped onto themselves during
        ;;    the inheritance operation below:
        (foreach var in (io-variables self)
            do (insert-at bindings var var))
        (foreach var in (external-variables self)
            where (null? (lookup bindings var))
            do (insert-at bindings var var))
        (foreach var in (internal-variables self)
            do (insert-at bindings var var))
        (setf (proposition description)
          (inherit-proposition (proposition self) bindings))
        ;; do check for duplicates here, otherwise we might get multiple
        ;;    concept prototypes for the same description in subsumption tests:
        (return (finish-building-description description TRUE :TOP-LEVEL)))))
  (return self))

(defun (check-for-single-valued-goal? BOOLEAN) 
       ((pattern DESCRIPTION) (ioBindings CONS))
  ;; Help function for 'overlay-with-pattern-frame?'
  ;; Calculate bound variables for 'pattern', and return TRUE
  ;;    if the remaining variables can be bound at most once.
  (let ((ioVariables NIL)
        (boundVariables NIL))
    (foreach vbl in (io-variables pattern)
             collect vbl into ioVariables)
    ;; collect from 'ioVariables' those matched to a bound variable
    ;;    in 'ioBindings':
    (foreach v1 in ioVariables
             as v2 in ioBindings
             where (defined? v2)
             do (pushq boundVariables v1))
    (return
     (single-valued-goal? (proposition pattern) ioVariables boundVariables)) ))

(defun (overlay-with-pattern-frame? BOOLEAN)
       ((frame CONTROL-FRAME) (description DESCRIPTION) 
        (ioArguments ARGUMENTS-VECTOR))
  ;; Convert control frame to :PATTERN frame.
  ;; Return TRUE if binding of arguments to io variables does not incur
  ;;    a unification failure.
  (let ((ioBindings (compute-external-bindings ioArguments))
        (externalBindings
         (choose (defined? (external-variables description))
                 (compute-external-bindings (external-variables description))
                 NIL))
        ;; careful: create new pattern record AFTER copying bindings:
        (patternRecord 
         (create-pattern-record frame description ioArguments))
        (optimalPattern DESCRIPTION NULL))
    (when (null? ioArguments)
      (foreach v on (io-variables description)
               collect NULL into ioBindings))
    (setf (state frame) :PATTERN)
    (setq optimalPattern 
          (select-optimal-query-pattern
           description (boolean-vector patternRecord) frame))
    (setf (optimal-pattern patternRecord) optimalPattern)
    ;; cache single-valued? computation:
    (when (check-for-single-valued-goal? optimalPattern ioBindings)
      (setf (cached-single-valued? frame) TRUE))
    ;; replace with proposition of optimal pattern:
    (setf (proposition frame) (proposition optimalPattern))
    ;; Tricky: Initializing the pattern record invalidates the
    ;;    'bound-to' computations on 'ioArguments', so we must copy the
    ;;    results of those computations before allocating:
    ;; initialize variable bindings vector for the variables local
    ;;    to 'optimalPattern':
    (let ((variablesCount (+ (length ioBindings)
                             (length (internal-variables optimalPattern))
                             (length externalBindings))))
      (activate-pattern-record patternRecord variablesCount))
    ;; tricky: binding must take place on local block of variables, not
    ;;    parent block:
    ;; bind io variables to same bindings as the io arguments:
    (foreach ioVar in (io-variables optimalPattern)
             as binding in ioBindings
             do (when (and (defined? binding)
                           (not (bind-variable-to-value? ioVar binding FALSE)))
                  (return FALSE)))
    ;; bind external variables to same bindings as the external arguments:
    (when (non-empty? externalBindings)
      (foreach externalVar in (external-variables optimalPattern)
               as binding in externalBindings
               do (when (and (defined? binding)
                             (not (bind-variable-to-value?
                                   externalVar binding FALSE)))
                    (return FALSE))))
    ;; Create down frame, knowing that we will soon be moving down to it:
    (when (null? (down frame))
      (create-down-frame frame (proposition optimalPattern)))
    ;; if just-in-time inference, elaborate embedded surrogates:
    (elaborate-surrogates-in-proposition (proposition optimalPattern))
    (return TRUE) ))

(defun (transfer-pattern-query-bindings? BOOLEAN)
       ((frame CONTROL-FRAME) (futureBindings? BOOLEAN))
  ;; Transfer variable bindings from 'frame' to its parent pattern record.
  ;; OPTIMIZATION: TEST FOR CASE WHEN ALL EXTERNAL VARIABLES ARE ALREADY
  ;;    BOUND.  IN THAT CASE, SKIP THE LOOP THAT TRIES TO TRANSFER ZERO VARS.
 (trace-if :query-stacks "TRANSFER-pattern-query-bindings?: " EOL)
  (let ((childPatternRecord (pattern-record frame))
        (booleanVector (boolean-vector childPatternRecord))
        (externalArguments (external-arguments childPatternRecord))
        (ioVariables (io-variables (optimal-pattern childPatternRecord)))        
        (lastIndex INTEGER (1- (length booleanVector)))
        (ioVariableValues NIL)
        (topUnbindingOffset INTEGER NULL))
    ;; collect sparse list of io-variable values:
    ;; moderately tricky -- we use a sparse bindings list because we don't want
    ;;    to clobber existing bindings in '(external-arguments childPatternRecord)'.    
    (foreach i in (interval 0 lastIndex)
             collect (choose (not (nth booleanVector i)) 
                             (bound-to (nth ioVariables i))
                             NULL)
             into ioVariableValues)
    ;; tricky: we reset current pattern record BEFORE the transfer so
    ;;    that 'bind-argument-to-value?' will work on the right variables:
    (reset-current-pattern-record frame :PARENT)
    ;; save top of unbinding stack in case of failure -- rewind after
    ;;    transfer failure avoids unbinding local variables:
    (let ((parentPatternRecord (current-pattern-record *queryIterator*)))
      (setq topUnbindingOffset 
            (top-unbinding-stack-offset parentPatternRecord))
      (foreach value in ioVariableValues
               as externalArg in externalArguments
               as initiallyBound? in booleanVector
               where (not initiallyBound?)
               do
               (when (not (bind-argument-to-value? externalArg value FALSE))
                 ;; transfer fails!
 (trace-if :query-stacks "TRANSFER FAILS! " EOL)
                 ;; undo partial transfer of bindings:
                 (unbind-variables-beginning-at
                  parentPatternRecord (1+ topUnbindingOffset))
                 (when futureBindings?
                   ;; tricky: we are about to descend back down to child frame:
                   (reset-current-pattern-record frame :LOCAL))
                 (return FALSE))))
    (return TRUE) ))

(defun collect-pattern-query-bindings ((frame CONTROL-FRAME))
  ;; Collect variable bindings from :PATTERN 'frame' into collection-list.
  (let ((patternRecord (pattern-record frame))
        (ioVariables (io-variables (optimal-pattern patternRecord)))        
        (ioVariableValues NIL))
    ;; collect list of io-variable values:
    (foreach v in ioVariables
             collect (bound-to v) into ioVariableValues)
    ;; transfer subquery variable bindings to external variables:
    (case (length ioVariableValues)
      (1
 (when (null? (first ioVariableValues))
   (warn "Pushing NULL binding onto collection.  Variable= " (first ioVariables))
   (return))
       (push (collection-list patternRecord) (first ioVariableValues)))
      (otherwise
       ;; note: don't free 'ioVariableValues':
       (push (collection-list patternRecord) ioVariableValues))) ))

(defun (get-rule-of-antecedent-frame PROPOSITION) ((frame CONTROL-FRAME))
  ;; If `frame' is a pattern frame that evaluated the antecedent of a rule,
  ;;    return the rule; otherwise, return NULL.
  (when (eql? (state frame) :PATTERN)
    (let ((parent (up frame)))
      (when (defined? parent)
        (return (antecedents-rule parent)))))
  (return NULL))

(defun (continue-pattern-proof KEYWORD) ((frame CONTROL-FRAME)
                                         (lastMove KEYWORD))
  ;; Move into or out of a :PATTERN frame.
  (case lastMove
    (:DOWN
     ;; reset vf offset from parent to current frame:
     (reset-current-pattern-record frame :LOCAL)
     (safety 3 (defined? (down frame))
             "INTERNAL ERROR: Missing down frame.")
     (return :MOVE-DOWN))
    (:UP-TRUE
     (let ((futureBindings? (defined? (down frame)))
           (result (result frame))
           (rule (get-rule-of-antecedent-frame frame)))
       ;; Ugly that we have to check for a default rule here, but since we
       ;;    use an overlay and dont have a separate rule frame, doing it in
       ;;    `continue-antecedents-proof' is a bit too late for the goal trace:
       (setf (truth-value frame)
         (weaken-truth-value
          (propagate-frame-truth-value result frame)
          (choose (defined? rule)
                  (truth-value rule)
                  TRUE-TRUTH-VALUE)))
       (when (defined? (partial-match-frame result))
         (propagate-frame-partial-truth (partial-match-frame result) frame))
       (when (record-justifications?)
         (record-PATTERN-justification frame lastMove))
       (cond
        ((defined? (collection-list (pattern-record frame)))
         (collect-pattern-query-bindings frame)
         (if futureBindings?
             (return :MOVE-DOWN)
           ;; careful: we avoid popping the stack because the parent
           ;;    frame looks down to pick up collection result:
           (progn
             (reset-current-pattern-record frame :PARENT)
             (return :CONTINUING-SUCCESS))))
        ;; note: 'transfer-...' calls 'reset-current-variable-...':
        ((transfer-pattern-query-bindings? frame futureBindings?)
         (if futureBindings?
             (progn
               (when (and (cached-single-valued? frame)
                          (not *generate-all-proofs?*))
                 ;; only one value needs to be returned.  Cut-off
                 ;;    future backtracking:
                 (pop-frames-up-to (down frame))
                 (return :FINAL-SUCCESS))
               (return :CONTINUING-SUCCESS))
           (return :FINAL-SUCCESS)))
        (futureBindings?
         (return :MOVE-DOWN))
        (otherwise
         (return :FAILURE)))))
    ((:UP-FAIL :FAILED-OVERLAY)
     (let ((result (result frame)))
       (propagate-frame-truth-value result frame)
       (when (defined? (partial-match-frame result))
         (propagate-frame-partial-truth (partial-match-frame result) frame))
       (when (record-justifications?)
         (record-PATTERN-justification frame lastMove))
       (if (defined? (collection-list (pattern-record frame)))
           ;; careful: we avoid popping the stack because the parent
           ;;    frame looks down to pick up collection result:
           ;; NOTE: the new `result' slot could be used instead.
           (progn
             (reset-current-pattern-record frame :PARENT)
             (return :CONTINUING-SUCCESS))
         (return :FAILURE))))) )


  ;;
;;;;;; disjoint-classes?
  ;;

(defun (disjoint-classes? BOOLEAN) ((desc1 NAMED-DESCRIPTION) (desc2 NAMED-DESCRIPTION))
  :public? TRUE
  ;; Return TRUE if 'desc1' and 'desc2' are disjoint.
  ;; Caution: Assumes that 'desc1' and 'desc2' are root classes.
  ;; CURRENT KLUDGE MARKS CLASSES THAT SHARE A COMMON LOGIC INSTANCE.
  ;;    WE GET FALSE NEGATIVES IF 'desc1' AND 'desc2' HAVE NOTHING
  ;;       IN COMMON WITH EACH OTHER, BUT EACH DOES WITH SOME OTHER ROOT CLASS.
  ;;    WE GET FALSE POSITIVE IF 'desc1' AND 'desc2' HAVE A COMMON
  ;;       SUBCLASS THAT HAS NOT BEEN INSTANTIATED.
  ;; BUG: ADD A SEARCH FOR A COMMON SUBCLASS. RETURN TRUE ONLY IF DISTINCT
  ;;    TYPES DO NOT HAVE A COMMON SUBCLASS:
  (return (and (not (eql? desc1 desc2))
               (not (relation-implies-relation? desc1 desc2))
               (not (relation-implies-relation? desc2 desc1)))) )

(defglobal *trace-disjointness-subgoals?* BOOLEAN FALSE
  :documentation "If true and goal tracing is on, subgoals of disjointness
queries will also be traced."
  :public? TRUE)

(defun (disjoint-terms? BOOLEAN) ((d1 DESCRIPTION) (d2 DESCRIPTION))
  :documentation "Return TRUE if 'd1' and 'd2' belong to disjoint partitions."
  :public? TRUE
  ;; TO DO: this gets some caching from the goal-caches machinery, but it probably
  ;;    should be memoized; the question is what timestamp to use, since even
  ;;    META-KB-UPDATE gets bumped frequently during forward inference.
  (when (null? (surrogate-value PL-KERNEL/@PARTITION-MEMBERSHIP))
    ;; prevent crash during kernel bootstrap:
    (return FALSE))
  (when-cyc-kludges-enabled
   (when (and (isa? d1 @NAMED-DESCRIPTION)
              (isa? d2 @NAMED-DESCRIPTION))
     ;; Assume these are Cyc collections and use their disjointness test
     ;;    (this is of course not a generally valid assumption, thus, kludge):
     (return
       (true-truth-value?
        (evaluate-selection-pattern
         (make-relation-pattern-2 PL-KERNEL/@DISJOINT d1 d2))))))
  (let ((tracedKeywords *traced-keywords*)
        (disjoint? FALSE))
    (unless *trace-disjointness-subgoals?*
      (setq *traced-keywords* NULL))
    ;; EXPERIMENT: memoize this even though the cache will be wiped out often:
    (special ((*evaluationMode* :EXTENSIONAL-ASSERTION))
      (setq disjoint?
        (memoize (d1 d2 *context*)
                 ;; NOTE: :META-KB-UPDATE gets bumped during forward inference, e.g.,
                 ;; if we infer `duplicate-free' for some collection - so, not too useful:
                 :timestamps :META-KB-UPDATE
                 :max-values 10000
                 (apply-ask (?d1 ?d2)
                            (disjoint ?d1 ?d2)
                            (d1 d2)))))
    (setq *traced-keywords* tracedKeywords)
    (return disjoint?)))

(defun (expensive-disjoint-terms? BOOLEAN)
       ((d1 DESCRIPTION) (d2 DESCRIPTION))
  :public? TRUE
  ;; Return TRUE if 'd1' and 'd2' belong to disjoint partitions.
  (return
   (apply-ask (?d1 ?d2) 
              (or (disjoint ?d1 ?d2)
                  (and (PL-KERNEL/class ?d1)
                       (PL-KERNEL/class ?d2)
                       (refutation-disjoint ?d1 ?d2)))
              (d1 d2))) )


  ;;
;;;;;; 'member-of-collection?' and 'asserted-collection-members'
  ;;

(defun (collectionOf-proposition? BOOLEAN) ((definingProposition PROPOSITION))
  ;; Return TRUE if the defining proposition 'definingProposition' is 
  ;;    a subtype of COLLECTIONOF.
  (return (logical-subtype-of? (relationRef definingProposition)
                               PL-KERNEL/@COLLECTIONOF)) )

(defun (member-of-collection? BOOLEAN) ((member OBJECT) (collection OBJECT))
  ;; Called by 'MEMBER-OF-specialist' and 'try-implies-proof'.
  ;; 'collection' can be a description, native collection, or a skolem.
  ;; Quick, shallow proof of collection membership.
  ;; Return TRUE if 'member' is directly asserted to be a member of
  ;;    'collection'.
  ;; If *reversePolarity?*, return TRUE if 'member' is directly 
  ;;    asserted NOT to be a member of 'collection'.
  ;; Strategy: Look for matching ISA proposition or matching MEMBER
  ;;    proposition.
  ;; PROBLEM: This isn't able to communicate default truth.
  (typecase collection
    (NAMED-DESCRIPTION
     ;; note: 'all-true-dependent-propositions' understands *reversePolarity?*:
     (return (next? (all-true-dependent-propositions
		     member (surrogate-value-inverse collection) TRUE))))
    (STELLA/COLLECTION
     (let ((member? (exists m in collection where (eql? (value-of m) member))))
       (if *reversePolarity?*
         (return (not member?))
         (return member?))))
    (SKOLEM
     (let ((success? FALSE)
           (enumeratedCollections
            (all-defining-propositions collection PL-KERNEL/@COLLECTIONOF TRUE)))
       (cond
        ((non-empty? enumeratedCollections)
         (foreach col in enumeratedCollections
             do (foreach arg in (arguments col)
                    ;; don't match the last (skolem) argument:
                    as i in (interval 2 (length (arguments col)))
                    where (eql? (value-of arg) member)
                    do (ignore i)
		       (setq success? TRUE)
                       (break)))
         (if *reversePolarity?*
             (return (not success?))
           (return success?)))
        (otherwise
         (foreach p in (all-true-dependent-propositions 
                        member PL-KERNEL/@MEMBER-OF FALSE)
             do (let ((subcollection LOGIC-OBJECT
                                     (value-of (second (arguments p)))))
                  (when (choose *reversePolarity?*
                                ;; NOT SURE IF WE SHOULD BE REVERSING
                                ;;    ARGUMENTS HERE:  -rmm
                                (collection-implies-collection?
                                 collection subCollection)
                                (collection-implies-collection?
                                 subCollection collection))
                    (return TRUE))))
         (return FALSE)))))
    (LOGIC-OBJECT
     (let ((equivalentSkolem SKOLEM (first (variable-value-inverse collection))))
       ;; assumption: there is at-most one equivalent skolem:
       (when (defined? equivalentSkolem)
         (return (member-of-collection? member equivalentSkolem)))))
    (otherwise NULL))
  (warn "member-of-collection?: Illegal collection type: "
        (symbol-name (wrapped-type-to-type (primary-type collection))) EOL
        "   member=" member " collection=" collection EOL)
  (return FALSE))

(defun (asserted-collection-members LIST) ((self OBJECT) (direct? BOOLEAN))
  :public? TRUE
  ;; Called lots of places, including 'MEMBER-OF-specialist'.
  ;; If 'self' is a native collection, a skolem collection, or a
  ;;    named description, return a list of asserted members of 'self'.
  ;; Otherwise, return NULL.
  ;; If direct?, don't look down isa hierarchies.
  ;; PROBLEM: This isn't able to communicate default truth.
  (typecase self
    (COLLECTION
     (let ((members (new LIST)))
       (foreach m in self collect m into members)
       (return members)))
    (NAMED-DESCRIPTION
     (let ((members (list)))
       (foreach prop in (all-true-extension-members self (not direct?))
           collect (first (arguments prop)) into members)
       (return members)))
    (DESCRIPTION (return NULL))
    (SKOLEM
     (let ((members (new LIST))
           (enumeratedCollections
            (all-defining-propositions self PL-KERNEL/@COLLECTIONOF TRUE)))
       (if (non-empty? enumeratedCollections)
           (foreach col in enumeratedCollections
               do (foreach arg in (arguments col)
                      ;; don't collect the last (skolem) argument:
                      as i in (interval 2 (length (arguments col)))
                      collect (value-of arg) into members))
         (foreach p in (all-true-dependent-propositions
                        self PL-KERNEL/@MEMBER-OF FALSE)
             where (or (and direct?
                            (eql? (value-of (second (arguments p)))
                                  (value-of self)))
                       (and (not direct?)
                            (collection-implies-collection?
                             (value-of (second (arguments p)))
                             (value-of self))))
             collect (first (arguments p)) into members))
       (return members)))
    (LOGIC-OBJECT
     (let ((equivalentSkolem SKOLEM (first (variable-value-inverse self))))
       ;; assumption: there is at-most one equivalent skolem:
       (when (defined? equivalentSkolem)
         (return (asserted-collection-members equivalentSkolem direct?))))
     (warn "Hmm. PowerLoom doesn't know how to interpret the LOGIC-OBJECT: " self
           EOL "   as a collection." EOL)
     (return NIL-LIST))
    (otherwise (return NULL))) )


  ;;
;;;;;; Description extensions
  ;;

(defclass DESCRIPTION-EXTENSION-ITERATOR (ITERATOR)
  :documentation "Iterates over the extension of a description and
its subdescriptions, returning those propositions that are currently true."
  :parameters ((any-value :type PROPOSITION))
  :slots ((root-description :type NAMED-DESCRIPTION)
          (subcollections :type (CONS OF CONS) :initially NULL)
          (extension-iterator :type (ITERATOR OF PROPOSITION))
          (reference-proposition :type PROPOSITION)
          (already-generated-list :type LIST :initially (new LIST))
          (already-generated-table :type HASH-TABLE)
          (removing-duplicates? :type BOOLEAN)
          (truth-value :type TRUTH-VALUE)))

(defun (all-true-extension-members DESCRIPTION-EXTENSION-ITERATOR)
       ((self NAMED-DESCRIPTION) (specialize? BOOLEAN))
  ;; Allocate an iterator that generates true propositions in the extension
  ;;    of the description 'self'.
  ;; If 'specialize', also scan the extensions of descriptions that
  ;;    specialize 'self'.
  (let ((iterator (new DESCRIPTION-EXTENSION-ITERATOR)))
    (setf (root-description iterator) self)
    ;; iterator over the root extension:
    (setf (extension-iterator iterator) (all-extension-members self))
    ;; SLIGHTLY TRICKY: NULL indicates that we should generate subcollections
    ;;    once we've run out of members in the root extension:
    (if specialize?
        (setf (subcollections iterator) NULL)
      (setf (subcollections iterator) NIL))
    (setf (removing-duplicates? iterator) 
          (and specialize? (eql? (arity self) 1)))
    (return iterator)) )

(defun (all-matching-extension-members (ITERATOR OF PROPOSITION))
       ((self PROPOSITION) (specialize? BOOLEAN))
  ;; Return an iterator that generates propositions whose predicate
  ;;    matches or specializes the predicate for 'self'.
  ;; Side-effect: Bind the variables in 'self' to the arguments of
  ;;    each returned proposition.
  (let ((iterator (all-true-extension-members
                   (surrogate-to-description (relationRef self))
                   specialize?)))
    (setf (reference-proposition iterator) self)
    (return iterator) ))

(defglobal *duplicateInstancesCacheCrossoverPoint* INTEGER 20
  :documentation "Point where a cache of generated instances in a 
description extension iterator is switched from a list to a hash table")

(defmethod (next? BOOLEAN) ((self DESCRIPTION-EXTENSION-ITERATOR))
  ;; Iterate over the description extension embedded within 'self'
  ;;    and the extensions of the subcollections.
  ;; Guaranteed NOT to generate duplicates if 'self' is unary.
  ;; Binds unbound variables of the current pattern record if called
  ;;    within a query.
  (let ((withinQuery? (defined? *queryIterator*))
        (patternRecord
         (choose withinQuery?
                 (current-pattern-record *queryIterator*)
                 NULL))
        (ubStackOffset
         (choose withinQuery?
                 (1+ (top-unbinding-stack-offset patternRecord))
                 NULL)))
    (loop
      (loop
        ;; find a true extension member that is not a duplicate:
        (when (not (next? (extension-iterator self)))
          (break))
        (let ((value (value (extension-iterator self))))
          (when (not (and (true-proposition? value)
                          (or (null? (reference-proposition self))
                              (arguments-match-arguments? 
                               value (reference-proposition self)))))
            (continue))
          (setf (slot-value self value) value)
          (setf (truth-value self) (proposition-truth-value value))
          (when (and (defined? (subcollections self))
                     (non-empty? (subcollections self)))
            (setf (truth-value self)
              (conjoin-truth-values (truth-value self)
                                    (second (first (subcollections self))))))
          (when (not (removing-duplicates? self))
            (return TRUE))
          (let ((instance (first (arguments value))))
            (when (and (null? (already-generated-table self))
                       (>= (length (already-generated-list self))
                           *duplicateInstancesCacheCrossoverPoint*))
              (let ((hashTable (new HASH-TABLE)))
                (foreach m in (already-generated-list self)
                    do (insert-at hashTable m m))
                (setf (already-generated-table self) hashTable)))
            (if (defined? (already-generated-table self))
                (when (not (defined? (lookup (already-generated-table self)
                                             instance)))
                  (insert-at (already-generated-table self) instance instance)
                  (return TRUE))
              (when (not (member? (already-generated-list self) instance))
                (push (already-generated-list self) instance)
                (return TRUE)))
            (when withinQuery?
              ;; we skipped a duplicate, unbind any newly bound variables to
              ;;    clear the way for the next possible binding:
              ;; note: unbinding logic copied from 'bind-argument-to-value?'.
              (unbind-variables-beginning-at patternRecord ubStackOffset)))))

      ;; visit the next subcollection:
      (let ((subcollections (subcollections self))
            (subcollection NAMED-DESCRIPTION NULL))
        (if (null? subcollections)
            ;; first time around:
            (setq subcollections
              (all-supported-named-subcollections (root-description self)))
          (setq subcollections (rest subcollections)))
        (while (non-empty? subcollections)
          (setq subcollection (first (first subcollections)))
          (if (not (empty? (get-description-extension subcollection TRUE)))
              (break)
            (setq subcollections (rest subcollections))))
        (when (null? subcollection)
          (break))
        (setf (extension-iterator self)
          (all-extension-members subcollection))
        (setf (subcollections self) subcollections)))
    (return FALSE)))


  ;;
;;;;;; Depth violation handler
  ;;

(defun (help-find-duplicated-goal CONTROL-FRAME CONTROL-FRAME INTEGER)
       ((goalFrame CONTROL-FRAME))
  ;; Helping function for 'find-duplicated-goal'.
  ;; Search for two goals matching 'atomicGoal', starting from the
  ;;    bottom of the stack.  Return three values, the frame that first
  ;;    posted the (matching) goal (called the 'firstGoalFrame'), the frame
  ;;    below the second frame posting the same goal (called the
  ;;    'restartFrame'), and the depth of that second frame.
  (let ((atomicGoal (proposition goalFrame))
        (bindings (goal-bindings goalFrame))
        (depth 1)
        (firstGoalFrame CONTROL-FRAME NULL)
        (testGoal PROPOSITION NULL)
        (testFrame CONTROL-FRAME NULL)
        (restartFrame CONTROL-FRAME NULL)
        (restartDepth INTEGER NULL))
; (print "HELP FIND GOAL " atomicGoal "  bindings: " bindings EOL)
    (setq testFrame (down (base-control-frame *queryIterator*)))
    (loop
      (setq testGoal (proposition testFrame))
      (when (and (defined? testGoal)
                 (eql? (operator testGoal) (operator atomicGoal))
                 (eql? (reverse-polarity? testFrame)
                       (reverse-polarity? goalFrame))
                 (or (and (null? bindings)
                          (null? (goal-bindings testFrame)))
                     (and (defined? bindings)
                          (defined? (goal-bindings testFrame))
                          (forall b1 in bindings
                              as b2 in (goal-bindings testFrame)
                              always (eql? b1 b2)))))
        (if (null? firstGoalFrame)
          (setq firstGoalFrame testFrame)
          (return firstGoalFrame restartFrame restartDepth)))
      (setq restartFrame testFrame)
      (setq restartDepth depth)
      (setq testFrame (down testFrame))
      (setq depth (1+ depth))
      (when (null? testFrame)
        ;; ran out of frames, return failure:
        (return NULL NULL NULL))) ))

(defun (find-duplicated-goal CONTROL-FRAME CONTROL-FRAME INTEGER)
       ((frame CONTROL-FRAME))
  ;; Return a frame on the control frame stack whose goal appears at
  ;;    least once more (above it) on the stack (i.e., the goal is 'duplicated').
  ;; Also, return the control frame and depth for the frame immediately
  ;;    below the frame posting the second ocurrence of the goal.
  ;; Strategy: First scan backwards from the top looking for an atomic
  ;;    goal.  Then scan forwards from the bottom looking for two
  ;;    instances of the same goal.
  (let ((trialFrame frame)
        (trialGoal PROPOSITION NULL)
        (firstRealControlFrame
         (down (base-control-frame *queryIterator*))))
    (while (not (eql? trialFrame firstRealControlFrame))
      (setq trialGoal (proposition trialFrame))
      (when (defined? trialGoal)
        (case (kind trialGoal)
          ((:ISA :PREDICATE :FUNCTION)
           (mv-bind (goalFrame restartFrame restartDepth)
                    (help-find-duplicated-goal trialFrame)
                    (when (defined? goalFrame)
 (trace-goal-cache "DUPLICATED GOAL: " trialFrame)
 (trace-if :GOAL-CACHES "   RESTART DEPTH " restartDepth EOL)
                      (return goalFrame restartFrame restartDepth))))
          (otherwise NULL)))
      (setq trialFrame (up trialFrame)))
 (trace-if :GOAL-CACHES "FAILED TO FIND DUPLICATE GOAL" EOL)
      ;; record cutoff failure:
      (setf (failed-to-find-duplicate-subgoal? *queryIterator*) TRUE)
      (return NULL NULL NULL) ))

(defun (handle-depth-violation CONTROL-FRAME INTEGER)
    ((frame CONTROL-FRAME) (depth INTEGER))
  ;; Record violation of current depth cutoff, and possibly 
  ;;    create a goal cache.
  ;; If a duplicate goal was found, truncate the stack down to that goal
  ;;    and return the revised depth.
  (trace-if (:GOAL-TREE :GOAL-CACHES) "*** Inference depth cutoff: depth=" depth EOL)
  (setf (triggered-depth-cutoff? *queryIterator*) TRUE)
  (when (cache-query-results?)
    (dont-cache-goal-failure-between-frames
     frame (base-control-frame *queryIterator*)))
  (register-inference-cutoff frame :DEPTH-VIOLATION)
  ;; register it on the query iterator so we can tell the user:
  (setf (depth-cutoffs? *queryIterator*) TRUE)
  (cond
   ((or (eql? *duplicate-subgoal-strategy* :DUPLICATE-GOALS)
        (eql? *duplicate-subgoal-strategy* :DUPLICATE-GOALS-WITH-CACHING))
    ;; no point in looking for duplicates, since that's done for each subgoal:
  ;;;; MAYBE WE SHOULD HAVE A UTILITY FUNCTION CREATING ALL THE NECESSARY
  ;;;;    DUMMY TRUTH VALUE, SINCE THAT'S NEEDED IN VARIOUS PLACES (E.G.,
  ;;;;    HANDLE-TIMEOUT AND `skip-AND-partial-match-clauses'):
    (set-frame-truth-value frame UNKNOWN-TRUTH-VALUE)
    (when (and (partial-match-mode?)
               (null? (partial-match-frame frame)))
      (create-and-link-partial-match-frame frame NULL)
      (set-frame-partial-truth (partial-match-frame frame) NULL 0.0 NULL TRUE))
    (when (record-justifications?)
      (record-goal-justification
       frame
       (new PRIMITIVE-STRATEGY
            :inference-rule :DEPTH-CUTOFF
            :strategy :FAILURE)))
    (setf (state frame) :POPPED)
    (setf (result (up frame)) frame)
    (setq frame (up frame))
    (-- depth))
   (otherwise
    (mv-bind (goalFrame restartFrame restartDepth)
        (find-duplicated-goal frame)
      (when (and (defined? goalFrame)
                 (null? (find-goal-cache goalFrame))
                 (create-goal-cache? goalFrame))
        (trace-if :GOAL-CACHES "*** Inference restart: restartDepth=" restartDepth EOL)
        ;; pop frames above 'restartFrame':
        (when (defined? (down restartFrame))
          (pop-frames-up-to (down restartFrame))
          (setf (down restartFrame) NULL))
        (safety 3 (or (zero? (compute-frame-depth restartFrame))
                      (eql? restartDepth (compute-frame-depth restartFrame)))
                "INTERNAL ERROR: Incorrect depth value in restart frame.")
        (setq frame restartFrame)
        (setq depth restartDepth)))))
  (return frame depth))

(startup-time-progn
  (define-explanation-phrase :depth-cutoff :technical
    "because of an inference depth cutoff")
  (define-explanation-phrase :depth-cutoff :lay
    "because the maximum inference search depth was exceeded"))

(defun (handle-timeout CONTROL-FRAME INTEGER)
    ((frame CONTROL-FRAME) (depth INTEGER))
  ;; Handle timeout of `frame' at `depth'.
  ;; Return the continuation frame and the new depth.
  (trace-if :GOAL-TREE
            "*** Timeout: start=" (starting-clock-ticks frame)
            ;" allotted=" (allotted-clock-ticks frame) ;; always 0
            " depth=" depth EOL)
  (when (cache-query-results?)
    (dont-cache-goal-failure-between-frames
     frame (base-control-frame *queryIterator*)))
  (register-inference-cutoff frame :TIMEOUT)
  (set-frame-truth-value frame UNKNOWN-TRUTH-VALUE)
  (when (partial-match-mode?)
    (when (null? (partial-match-frame frame))
      (create-and-link-partial-match-frame frame NULL))
    (set-frame-partial-truth (partial-match-frame frame) NULL 0.0 NULL TRUE))
  (when (record-justifications?)
    (record-goal-justification
     frame
     (new PRIMITIVE-STRATEGY :inference-rule :TIMEOUT :strategy :FAILURE)))
  (setf (state frame) :POPPED)
  (setf (result (up frame)) frame)
  (setq frame (up frame))
  (-- depth)
  (return frame depth))

(startup-time-progn
  (define-explanation-phrase :timeout :technical
    "because of an inference timeout")
  (define-explanation-phrase :timeout :lay
    "because the allotted inference CPU time was exceeded"))


  ;;
;;;;;; Managing Query Solutions
  ;;

;;; Query solutions are kept in a KEY-VALUE-MAP indexed by solution bindings
;;; vectors.  This allows us a fast check for duplicate solutions.  Most of
;;; the code deals with implementing a KEY-VALUE-MAP that also preserves the
;;; order of solutions - THIS FUNCTIONALITY SHOULD EVENTUALLY MOVE TO
;;; collections.ste AT WHICH POINT THE CODE HERE WILL BECOME MUCH SIMPLER.

(defclass QUERY-SOLUTION-TABLE (DICTIONARY)
  :documentation "Special key/value map for query solutions indexed by output
variable binding vectors that also preserves the order of solution generation."
  :parameters ((any-key :type ARGUMENTS-VECTOR)
               (any-value :type QUERY-SOLUTION))
  :slots (;; minor inelegance: need to point to the map via a slot instead
          ;; of inheriting KEY-VALUE-MAP, since we can't call super methods
          ;; yet which is necessary for insertion or removal:
          (the-map :type (KEY-VALUE-MAP OF (LIKE (any-key self))
                                           (LIKE (any-value self)))
                   :initially (new KEY-VALUE-MAP :equal-test? TRUE))
          (query :type QUERY-ITERATOR) ;; not yet used
          (first :type QUERY-SOLUTION)
          (last :type QUERY-SOLUTION)))

(defclass QUERY-SOLUTION (STANDARD-OBJECT)
  :slots ((bindings :type ARGUMENTS-VECTOR)
          (truth-value :type TRUTH-VALUE)
          (match-score :type PARTIAL-MATCH-SCORE)
          (justification :type JUSTIFICATION)
          (best-justification :type JUSTIFICATION :renames justification)
          (all-justifications :type (LIST OF JUSTIFICATION)
                              :documentation "All recorded justifications for
this solution in case we have multiple ones from a partial match operation.")
          (next :type QUERY-SOLUTION)))

(defmethod (lookup (LIKE (any-value self))) ((self QUERY-SOLUTION-TABLE)
                                             (key (LIKE (any-key self))))
  :documentation "Lookup the solution identified by `key' in `self' and
return its value, or NULL if no such solution exists."
  :public? TRUE
  (return (lookup (the-map self) key)))

(defmethod insert-at ((self QUERY-SOLUTION-TABLE)
                      (key (LIKE (any-key self)))
                      (value (LIKE (any-value self))))
  :documentation "Insert `value' identified by `key' into `self'.  If a solution
with that key already exists, destructively modify it with the slot values of
`value'.  This is necessary to preserve the order of solutions in `self'."
  :public? TRUE
  (let ((map (the-map self))
        (duplicate (lookup map key)))
    (cond ((defined? duplicate)
           ;; destructively copy potentially different slots of new `value':
           (setf (truth-value duplicate) (truth-value value))
           (setf (match-score duplicate) (match-score value))
           (setf (justification duplicate) (justification value))
           (setf (all-justifications duplicate) (all-justifications value)))
          (otherwise
           (insert-at map key value)
           (cond ((null? (first self))
                  (setf (first self) value)
                  (setf (last self) value))
                 (otherwise
                  (setf (next (last self)) value)
                  (setf (last self) value)))))))

(defmethod (deleted? BOOLEAN) ((self QUERY-SOLUTION))
  (return (null? (bindings self))))

(defmethod (deleted?-setter BOOLEAN) ((self QUERY-SOLUTION) (value BOOLEAN))
  (if value
      (setf (bindings self) NULL)
    (setf (bindings self) (vector)))
  (return value))

(defmethod remove-at ((self QUERY-SOLUTION-TABLE) (key (LIKE (any-key self))))
  :documentation "Remove the solution identified by `key' from `self'.
To preserve the solution ordering chain, the solution is marked as deleted
and will be completely removed upon the next iteration through `self'."
  :public? TRUE
  (let ((map (the-map self))
        (solution (lookup map key)))
    (when (defined? solution)
      (remove-at map key)
      ;; mark solution as "deleted?" but keep it to not break the chain;
      ;; it will be removed during the next iteration over `self':
      (setf (deleted? solution) TRUE))))

(defmethod (pop (LIKE (any-value self))) ((self QUERY-SOLUTION-TABLE))
  :documentation "Remove and return the first solution of `self' or NULL
if the table is empty."
  :public? TRUE
  (let ((first (first self)))
    (when (defined? first)
      (setf (first self) (next first))
      (when (eql? first (last self))
        (setf (last self) NULL))
      (remove-at (the-map self) (bindings first)))
    (return first)))

(defmethod (length INTEGER) ((self QUERY-SOLUTION-TABLE))
  :documentation "Return the number of entries in `self'."
  :public? TRUE
  (return (length (the-map self))))

(defmethod (empty? BOOLEAN) ((self QUERY-SOLUTION-TABLE))
  :documentation "Return TRUE if `self' has zero entries."
  :public? TRUE
  (return (empty? (the-map self))))

(defmethod (non-empty? BOOLEAN) ((self QUERY-SOLUTION-TABLE))
  :documentation "Return TRUE if `self' has at least 1 entry."
  :public? TRUE
  (return (non-empty? (the-map self))))

(defmethod (nth (LIKE (any-value self))) ((self QUERY-SOLUTION-TABLE)
                                          (position INTEGER))
  :documentation "Return the nth solution in `self', or NULL if it is empty."
  :public? TRUE
  (foreach solution in self
      do (if (= position 0)
             (return solution)
           (-- position)))
  (return NULL))

(defmethod clear ((self QUERY-SOLUTION-TABLE))
  (clear (the-map self))
  (setf (first self) NULL)
  (setf (last self) NULL))

(defmethod (consify CONS) ((self QUERY-SOLUTION-TABLE))
  :documentation
  "Collect all solutions of `self' into a cons list and return the result."
  :public? TRUE
  (let ((result NIL))
    (foreach solution in self
        collect solution into result)
    (return result)))

(defmethod (sort (LIKE self)) ((self QUERY-SOLUTION-TABLE)
                               (predicate FUNCTION-CODE))
  :documentation "Perform a stable, destructive sort of `self' according to
`predicate', and return the result.  If `predicate' has a '<' semantics, the
result will be in ascending order."
  :public? TRUE
  (let ((thePredicate
         (first-defined predicate
                        (the-code :function query-solution-less-than?)))
        (solutions (sort (consify self) thePredicate))
        (current QUERY-SOLUTION NULL)
        (next QUERY-SOLUTION NULL))
    (setf (first self) (first solutions))
    (setf (last self) (first solutions))
    (loop
      (setq current (first solutions))
      (cond ((defined? current)
             (setq next (first (rest solutions)))
             (setf (next current) next)
             (when (null? next)
               (setf (last self) current))
             (setq solutions (rest solutions)))
            (otherwise
             (break))))
    (return self)))

(defun (query-solution-less-than? BOOLEAN) ((x QUERY-SOLUTION)
                                            (y QUERY-SOLUTION))
  ;; Default predicate that sorts solutions by their binding columns.
  (foreach xBinding in (bindings x)
      as yBinding in (bindings y)
      do (cond ((eql? xBinding yBinding)
                (continue))
               ((logic-form-less? xBinding yBinding)
                (return TRUE))
               (otherwise
                (return FALSE))))
  (return FALSE))

(defun (query-solution-greater-than? BOOLEAN) ((x QUERY-SOLUTION)
                                               (y QUERY-SOLUTION))
  ;; Predicate that sorts solutions by their binding columns (for descending order).
  (return (query-solution-less-than? y x)))

(defclass QUERY-SOLUTION-TABLE-ITERATOR (DICTIONARY-ITERATOR)
  :slots ((the-table :type QUERY-SOLUTION-TABLE)
          (cursor :type QUERY-SOLUTION)))

(defmethod (allocate-iterator (DICTIONARY-ITERATOR OF (LIKE (any-key self))
                                                      (LIKE (any-value self))))
    ((self QUERY-SOLUTION-TABLE))
  (return (new QUERY-SOLUTION-TABLE-ITERATOR :the-table self)))

(defmethod (next? BOOLEAN) ((self QUERY-SOLUTION-TABLE-ITERATOR))
  ;; Return the next non-deleted element in `self'; excise any deleted
  ;;    entries as a side effect.
  (let ((table (the-table self))
        (cursor (cursor self))
        (previous cursor))
    (cond ((first-iteration? self)
           (setq previous NULL)
           (setq cursor (first table))
           (setf (first-iteration? self) FALSE))
          (otherwise
           (setq previous cursor)
           (setq cursor (next cursor))))
    (while (and (defined? cursor)
                (deleted? cursor))
      (setq cursor (next cursor)))
    (setf (cursor self) cursor)
    (cond ((defined? cursor)
           ;; we found a non-deleted solution:
           (if (null? previous)
               (setf (first table) cursor)
             (setf (next previous) cursor))
           (setf (slot-value self key) (bindings cursor))
           (setf (slot-value self value) cursor)
           (return TRUE))
          ((defined? previous)
           ;; no non-deleted solution after previous:
           (setf (next previous) NULL)
           (setf (last table) previous)))
    (return FALSE)))


  ;;
;;;;;; Print functions
  ;;

(defun print-control-frame ((self CONTROL-FRAME) (stream NATIVE-OUTPUT-STREAM))
  ;; Print 'self' to 'stream'.  Mainly needed for debugging.
  (typecase self
    (PARALLEL-CONTROL-FRAME
     (print-native-stream stream "|PLL-CF|" (debug-frame-id self) "["))
    (otherwise
     (print-native-stream stream "|CF|" (debug-frame-id self) "[")))
  (if (defined? (choice-point-unbinding-offset self))
    (print-native-stream stream (choice-point-unbinding-offset self))
    (print-native-stream stream "_"))
  (special ((*printInFrame* self))
    (let ((printTimes? (defined? (allotted-clock-ticks self))))
      (print-native-stream 
       stream ; " " (argument-cursor self)
       " " (state self)
       " " (current-strategy self))
      (if (defined? (up self))
        (print-native-stream stream "  UP: " (debug-frame-id (up self)))
        (print-native-stream stream "  UP: -"))
      (if (defined? (down self))
        (print-native-stream stream "  DOWN: " (debug-frame-id (down self)))
        (print-native-stream stream "  DOWN: -"))
      (print-native-stream stream "  DEPTH: " (compute-frame-depth self))
      (when (defined? (description self))
        (print-native-stream stream " DESC: " (description self)))
      (when printTimes?
        (print-native-stream
         stream
         " CLOCK: " (current-clock-ticks *queryIterator*)
         " START: " (starting-clock-ticks self)
         " TICKS: " (allotted-clock-ticks self)))
      (print-native-stream
       stream
       " " (proposition self) "]"))))

(defun print-goal-stack ((frame CONTROL-FRAME) (verbose? BOOLEAN))
  :documentation "Print stack of goals.  Assumes that query has been interrupted
with a full stack of control frames."
  (when (defined? (proposition frame))
    (special ((*printInFrame* frame))
      (if verbose?
          (progn
            (print-control-frame frame (native-stream STANDARD-OUTPUT))
            (print EOL))
        (print (proposition frame) EOL))))
  (when (defined? (down frame))
    (print-goal-stack (down frame) verbose?)) )

(defun pgs () (print-goal-stack (base-control-frame *queryIterator*) FALSE))
(defun vpgs () (print-goal-stack (base-control-frame *queryIterator*) TRUE))

(defun print-query-iterator
    ((self QUERY-ITERATOR) (stream NATIVE-OUTPUT-STREAM))
  ;; Print all solutions collected in 'self' so far to 'stream'.
  (if *printReadably?*
      (print-query-iterator-readably self stream)
    (print-query-iterator-ornately self stream)))

(defun print-query-iterator-ornately
    ((self QUERY-ITERATOR) (stream NATIVE-OUTPUT-STREAM))
  (let ((solutions (solutions self))
        (nOfSolutions (length solutions))
        (exhausted? (exhausted? self)))
    (case nOfSolutions
      (0 (print-stream stream "No solutions"))
      (1 (print-stream stream "There is 1 solution"))
      (otherwise
       (print-stream stream "There are " nOfSolutions " solutions")))
    (unless exhausted?
      (print-stream stream " so far"))
    (when (or (timeout? self)
              (depth-cutoffs? self))
      (print-stream stream " (")
      (when (timeout? self)
        (print-stream stream "timeout")
        (when (depth-cutoffs? self)
          (print-stream stream ", ")))
      (when (depth-cutoffs? self)
        (print-stream stream "depth cutoffs"))
      (print-stream stream ")"))
    (when (= nOfSolutions 0)
      (print-stream stream "." EOL)
      (return))
    (print-stream stream ":" EOL)
    (special ((*printReadably?* TRUE))
      (foreach solution in solutions
          as i in (interval 1 *printlength*)
          do (print-query-iterator-solution-ornately self solution i stream)
             (when (< i nOfSolutions)
               (print-stream stream EOL))
             (when (and (= i *printlength*)
                        (< i nOfSolutions))
               (print-stream stream "  ......" EOL))))))

(defun print-query-iterator-solution-ornately
    ((self QUERY-ITERATOR)
     (solution QUERY-SOLUTION)
     (solutionNumber INTEGER)
     (stream NATIVE-OUTPUT-STREAM))
  ;; Print `solution' of `self' onto `stream' as solution number `solutionNumber'.
  ;; If `solutionNumber' is NULL try to infer it from the iterator `self'.
  ;; This was extracted so we can also use it for `trace-solution'.
  (when (null? solutionNumber)
    (setq solutionNumber 0)
    (foreach solution in (solutions self)
        where (not (equal? (bindings solution) solution))
        do (++ solutionNumber)))
  (special ((*printReadably?* TRUE))
    (print-stream stream "  #" solutionNumber ": ")
    (foreach value in (bindings solution)
        as variable in (external-variables self)
        as vi in (interval 0 NULL)
        do (print-stream
            stream (choose (= vi 0) "" ", ") (skolem-name variable) "=" value))
    (when (and (defined? (partial-match-strategy self))
               (defined? (match-score solution)))
      (print-stream stream " " (match-score solution)))))

(defun trace-solution ((self QUERY-ITERATOR)
                       (solution QUERY-SOLUTION)
                       (solutionNumber INTEGER))
  ;; Trace the new `solution' of `self' onto STANDARD-OUTPUT.
  (when (trace-keyword? :TRACE-SOLUTIONS)
    (print-stream STANDARD-OUTPUT "SOLUTION ")
    (print-query-iterator-solution-ornately
     *queryIterator* solution solutionNumber STANDARD-OUTPUT)
    (print-stream STANDARD-OUTPUT EOL)))

(defun print-query-iterator-readably
    ((self QUERY-ITERATOR) (stream NATIVE-OUTPUT-STREAM))
  (let ((solutions (solutions self))
	(first? TRUE)
	(atomicSingletons? (and (atomic-singletons? self)
				(null? (partial-match-strategy self)))))
    (print-stream stream "(")
    (foreach solution in solutions
        as i in (interval 1 *printlength*)
        do (unless first?
	     (if atomicSingletons?
		 (print-stream stream " ")
	         (print-stream stream EOL " ")))
	   (setq first? FALSE)
	   (unless atomicSingletons? (print-stream stream "("))
	   (foreach value in (bindings solution)
               as vi in (interval 0 NULL)
               do (print-stream
                   stream 
                   (choose (= vi 0) "" " ")
		   value)
		  ;; Print match score if partial-match is on - Moriarty
		  (when (defined? (partial-match-strategy self))
		    (print-stream stream " " (match-score solution))))
	   (unless atomicSingletons? (print-stream stream ")"))
           (when (and (= i *printlength*)
                      (< i (length solutions)))
               (print-stream stream " ...")))
    (print-stream stream ")" EOL)))


  ;;
;;;;;; Top-level query interface
  ;;

(defun (allocate-query-iterator QUERY-ITERATOR) ()
  ;; Allocate a query iterator, initialize time stamps and return the result.
  (let ((queryIterator (new QUERY-ITERATOR)))
    (update-now-timestamp :EXECUTE-QUERY)
    (setf (timestamp queryIterator) (get-now-timestamp))
    (return queryIterator) ))

;; NOTHING CALLS THIS:
(defmethod free ((self QUERY-ITERATOR))
  ;; Free-up and/or recycle storage within 'self'.
  (free-query-iterator self) )

(defun free-query-iterator ((self QUERY-ITERATOR))
  ;; Free-up and/or recycle storage within 'self'.
  (when (null? (base-control-frame self))
    ;; already free'd:
    (return))
  (free (value self))
  ;; mark 'self' as discarded:
  (setf (base-control-frame self) NULL) )

(defun (allocate-collection-variables VARIABLES-VECTOR) 
       ((frame CONTROL-FRAME) (description DESCRIPTION))
  ;; Called by 'initialize-query-iterator'.
  ;; Make a copy of the variables in 'description' and allocate a block of variable
  ;;    frames for them.
  ;; QUESTION: CAN'T WE JUST USE THE io-variables OF 'description' AS IS (I.E., 
  ;;    ELIMINATE THE COPY OPERATION)???
  (let ((variablesCount (length (io-variables description)))
        (externalVariables 
         (new VARIABLES-VECTOR :array-size variablesCount)))
     ;; fill 'externalVariables' with unbound pattern variables:
    (foreach ioVar in (io-variables description)
           as i in (interval 0 NULL)
           do
           (setf (nth externalVariables i)
                 (create-variable (skolem-type ioVar) (skolem-name ioVar) FALSE ; TRUE -rmm 12/13/99
                                  ))
           (setf (bound-to-offset (nth externalVariables i)) i))
    (when (null? (pattern-record frame))
      (create-pattern-record frame NULL NULL))
    (activate-pattern-record (pattern-record frame) variablesCount)
    (return externalVariables) ))

(defun (create-query-iterator QUERY-ITERATOR) ((description DESCRIPTION)
                                               (outsideBindings VECTOR))
  ;; Create a query iterator, a query environment, and a top-level query frame
  ;;    for the query defined by `description'.
  ;; If 'outsideBindings' is non-nil, bind io-variables in 'description'
  ;;    to those arguments.
  (return
    (initialize-query-iterator
     (allocate-query-iterator) description outsideBindings)))

(defun (initialize-query-iterator QUERY-ITERATOR)
    ((queryIterator QUERY-ITERATOR)
     (description DESCRIPTION)
     (outsideBindings VECTOR))
  ;; Initialize `queryIterator' with a query environment and a top-level query
  ;;    frame for the query defined by `description'.
  ;; Any slots already initialized by `process-query-options' will
  ;;    be left alone and used as appropriate.
  ;; If 'outsideBindings' is non-nil, bind io-variables in 'description'
  ;;    to those arguments.
  (let ((baseControlFrame (new CONTROL-FRAME))
        (externalVariables VARIABLES-VECTOR NULL))
    (special ((*queryIterator* queryIterator)
              ;; Bind these because of `create-variable' below, which
              ;;    creates ISA propositions that shouldn't be recorded
              ;;    if this query is part of a proposition construction
              ;;    higher up:
              (*evaluationMode* :DESCRIPTION))
     (when (test-query-option? queryIterator :DONT-OPTIMIZE?)
       (setf (dont-optimize? description) TRUE)
       (setf (dont-optimize? (proposition description)) TRUE))
     (setf (query-context queryIterator) *context*)
     (setf (base-control-frame queryIterator) baseControlFrame)
     (setf (current-control-frame queryIterator) baseControlFrame)
     (setq *control-frame-id-counter* 0)
     ;; initialize 'baseControlFrame' slots:
     (setf (proposition baseControlFrame) (proposition description))
     (setf (up baseControlFrame) NULL)
     (setf (goal-cache baseControlFrame) NULL)
     (setf (goal-bindings baseControlFrame) NULL)
     ;; allocate space for external variable return values:
     ;; tricky: we create pattern record only to overlay it with 
     ;;    another one (thereby losing the 'official' pointer to the
     ;;    bottom of the variable value stack):
     (setq externalVariables
           (allocate-collection-variables baseControlFrame description))
     (within-context (get-query-context)
      ;; we need to be in the query context because 'elaborate-instance'
      ;;   and 'elaborate-surrogates-in-proposition' expect it:
      ;; first, possibly bind variables to externally-derived input values:
      (when (defined? outsideBindings)
        (setf (initial-bindings queryIterator) outsideBindings)
        (when (> (length outsideBindings)
                 (length externalVariables))
	  ;; Arity mismatch:
	  (signal FAIL-EXCEPTION
                  "Arity mismatch between bindings " outsideBindings
		  " and external variables " externalVariables "."))
        (foreach arg in externalVariables
            as value in outsideBindings
            do (when (and (defined? value)
                          (not (bind-argument-to-value? arg value FALSE)))
                 (signal FAIL-EXCEPTION
                         "Binding of " arg " to " value " failed."))))
      ;; establish initial pattern:
      (overlay-with-pattern-frame?
       baseControlFrame description externalVariables))
     (setf (control-frame-priority-queue queryIterator)
           (new CONTROL-FRAME-PRIORITY-QUEUE))
     ;; initialize inference settings:
     (when (null? (maximum-depth queryIterator))
       (setf (maximum-depth queryIterator) *maximum-backtracking-depth*))
     (setf (augmented-goal-cache? queryIterator) FALSE)
     (clear (active-goal-caches queryIterator))
     (when (and *iterative-deepening-mode?*
                (not (test-query-option? queryIterator :ITERATIVE-DEEPENING?)))
       (setf (iterative-deepening? queryIterator) TRUE))
     ;; set initial depth for iterative deepening search:
     (setf (current-depth-cutoff queryIterator)
           (choose (iterative-deepening? queryIterator)
                   (min *initial-backtracking-depth*
                        (maximum-depth queryIterator))
                   (maximum-depth queryIterator)))
     (setf (triggered-depth-cutoff? queryIterator) FALSE)
     (setf (failed-to-find-duplicate-subgoal? queryIterator) FALSE)
     (setf (found-at-least-one-solution? queryIterator) FALSE)
     ;; initialize 'queryIterator':
     (setf (external-variables queryIterator) externalVariables)
     (return queryIterator) )))

(defmethod (query-proposition PROPOSITION) ((self QUERY-ITERATOR))
  ;; Return the top-level proposition queried by `self'.
  (return (proposition (base-control-frame self))))

(defmethod (query-description DESCRIPTION) ((self QUERY-ITERATOR))
  ;; Return the top-level description queried by `self'.
  (return (description (pattern-record (base-control-frame self)))))

(defmethod (query-is-true-false? BOOLEAN) ((self QUERY-ITERATOR))
  ;; Return true if `self' is a true/false query.
  (when (empty? (external-variables self))
    (return TRUE))
  (let ((patternRecord (pattern-record (base-control-frame self))))
    (return (forall ignored-arg in (external-arguments patternRecord)
              as bound? in (boolean-vector patternRecord)
              always bound?))))

(defmethod (query-is-partial? BOOLEAN) ((self QUERY-ITERATOR))
  ;; Return true if `self' is a partial query.
  (when (defined? (partial-match-strategy self))
    (return TRUE))
  (let ((matchMode (lookup-query-option self :MATCH-MODE)))
    (return (and (defined? matchMode)
                 (not (eql? matchMode :STRICT))))))

(defmethod (query-succeeded? BOOLEAN) ((self QUERY-ITERATOR))
  ;; Return true if `self' succeeded at least once.
  (return (non-empty? (solutions self))))

(defmethod (next? BOOLEAN) ((self QUERY-ITERATOR))
  ;; Execute another iteration of the subquery attached to 'self'.
  ;; If success, copy variable values plus various support information such as
  ;;    truth value, justifications, match score, etc. into a newly allocated
  ;;    QUERY-SOLUTION structure that will not get destructively modified upon
  ;;    the generation of the next solution (i.e., the caller can hold on to
  ;;    it without having to copy - this is different from the previous handling
  ;;    of the `value' vector).
  ;; Return TRUE if success.
  (when (exhausted? self)
    (return FALSE))
  (let ((baseFrame (base-control-frame self))
        (solution
         (new QUERY-SOLUTION
              :bindings (new VECTOR
                             :array-size (length (external-variables self)))
              :truth-value UNKNOWN-TRUTH-VALUE))
        (duplicate QUERY-SOLUTION NULL))
    (setf (slot-value self value) solution)
    (when (first-iteration? self)
      (setf (first-iteration? self) FALSE)
      ;; test this here, since for any query and partial match mode, this is
      ;;    the latest point at which  all options should have been processed:
      (let ((skippedOptions
             PROPERTY-LIST (lookup-query-option self :DEFERRED-OPTIONS)))
        (when (and (defined? skippedOptions)
                   (non-empty? skippedOptions))
          (signal-parsing-error "Illegal query option(s): " skippedOptions))))
    (loop
      (within-context (get-query-context)
       (safety 3 (not (deleted? *context*)) 
               "BUG: Query iterator points to deleted context.")
       (loop
         ;; reset solution slots:
         (clear (bindings solution))
         (setf (truth-value solution) UNKNOWN-TRUTH-VALUE)
         (setf (justification solution) NULL)
         (setf (match-score solution) NULL)
         ;; try to generate next solution:
         (when (not (execute-backward-chaining-proof? self))
           (break))
         ;; transfer bindings:
         (foreach ev in (external-variables self)
             as i in (interval 0 NULL)
             do (setf (nth (bindings solution) i) (value-of (bound-to ev))))
         (setf (found-at-least-one-solution? self) TRUE)
         (setf (truth-value solution)
           (first-defined (truth-value baseFrame) UNKNOWN-TRUTH-VALUE))
         (setf (justification solution) (justification baseFrame))
         (when (partial-match-mode?)
           (setf (match-score solution)
             (choose (defined-frame-partial-truth? baseFrame)
                     (positive-score (partial-match-frame baseFrame))
                     ;; keep supporting old-style partial match:
                     (latest-positive-score self))))
         (setq duplicate (lookup (solutions self) (bindings solution)))
         (when (and (defined? duplicate)
                    (or (not (partial-match-mode?))
                        (<= (match-score solution) (match-score duplicate))))
           ;; We found a duplicate solution that didn't improve anything:
           (continue))
         (when (and (holds-by-default? baseFrame)
                    ;; We might have used some defaults to derive the
                    ;;    last result; check for overrides and clashes:
                    (try-to-defeat-last-answer? self))
           (continue))
         ;; no defeat, restore the original truth value:
         (setf (truth-value baseFrame) (truth-value solution))
         (setf (justification baseFrame) (justification solution))
         (insert-at (solutions self) (bindings solution) solution)
         (return TRUE)))
      (cond
       ((timeout? self)
        (return FALSE))
       ((augmented-goal-cache? self)
        ;; reset and continue looping:
        (reset self))
       ((and (iterative-deepening? self)
             (triggered-depth-cutoff? self)
             (< (current-depth-cutoff self)
                (maximum-depth self)))
        ;; try again with increased depth cutoff:
        (setf (current-depth-cutoff self)
              (1+ (current-depth-cutoff self)))
        ;; reset and continue looping:
        (reset self))
       (otherwise
        (when (and (failed-to-find-duplicate-subgoal? self)
                   (not (found-at-least-one-solution? self)))
          (print "Failed to find a duplicate subgoal on one or more occurrences when" EOL
                 "   the depth cutoff " (current-depth-cutoff self)
                 " was exceeded.  Consider increasing the cutoff" EOL
                 "   (by setting the variable *maximum-backtracking-depth*)" EOL
              "   and trying again." EOL))
        ;; return failure:
        (setf (exhausted? self) TRUE)
        (return FALSE)))) ))

(defun (try-to-defeat-last-answer? BOOLEAN) ((self QUERY-ITERATOR))
  ;; Try to derive the negation of the most recent answer generated by `self'.
  ;; Return TRUE if a negative answer of equal or higher strength could
  ;;    be derived; return FALSE otherwise.
  (let ((negatedQuery
         (choose (query-is-true-false? self)
                 ;; For T/F queries we don't need a separate query:
                 self
                 (negated-query self)))
        (queryContext (query-context self))
        (strictPositiveAnswer? FALSE)
        (strictNegativeAnswer? FALSE)
        (defeated? FALSE))
    (cond 
     ((null? negatedQuery)
      ;; for non T/F queries, allocate second query iterator with variable
      ;;    bound to result of original query:
      (setq negatedQuery
            (create-query-iterator
             (query-description self)
             (bindings (value self))))
      (setf (query-context negatedQuery) queryContext))
     (otherwise
      (when (eql? self (negated-query negatedQuery))
        ;; We have a try-to-defeat loop:
        (return FALSE))
      ;; Reset the initial variable bindings to the new solution:
      (setf (initial-bindings negatedQuery) (bindings (value self)))))
    (setf (negated-query self) negatedQuery)
    ;; While we are trying to defeat, we back-link the negated query
    ;;    to avoid infinite try-to-defeat loops:
    (setf (negated-query negatedQuery) self)
    ;; NOTE: Using reverse polarity might not be powerful enough compared
    ;;    to building an explicit, normalized negation.  However, since
    ;;    we might also have to ask the positive query again, switching
    ;;    polarity is cheaper than allocating a third query.
    (setf (reverse-polarity? (base-control-frame negatedQuery)) TRUE)
    (reset negatedQuery)
    (trace-if :GOAL-TREE "Looking for conflicting default conclusion:" EOL)
    (when (next? negatedQuery)  ;; considers defaults
      ;; Check whether the negative answer was strict:
      (reset negatedQuery)
      (special ((*dontUseDefaultKnowledge?* TRUE))
        (trace-if :GOAL-TREE "Looking for conflicting strict conclusion:" EOL)
        (setq strictNegativeAnswer? (next? negatedQuery)))
      ;; Check whether the positive answer was strict:
      (setf (reverse-polarity? (base-control-frame negatedQuery)) FALSE)
      (reset negatedQuery)
      (special ((*dontUseDefaultKnowledge?* TRUE))
        (trace-if :GOAL-TREE "Looking for strict conclusion:" EOL)
        (setq strictPositiveAnswer? (next? negatedQuery)))
      (if strictPositiveAnswer?
        (cond
         (strictNegativeAnswer?
          ;; We have a hard contradiction, now what:
          (special ((*queryIterator* negatedQuery))
           (inform
            EOL "CONTRADICTION: Discovered strict arguments for" EOL
            "    " (proposition (base-control-frame negatedQuery))
            EOL "and its negation." EOL))
          (setq defeated? TRUE))
         (otherwise
          (setq defeated? FALSE)))
        (setq defeated? TRUE)))
    ;; Undo the loop-preventing back-link:
    (setf (negated-query negatedQuery) NULL)
    (return defeated?)))

(defmethod reset ((self QUERY-ITERATOR))
  ;; Reset query frames within 'self' so that the query can
  ;;    be re-executed from its initial state.
 (trace-if :GOAL-CACHES "------------- RESET -------------" EOL)
  (let ((initialFrame (base-control-frame self)))
    ;; pop all control frames but the artificial frame established
    ;;    prior to executing the query:
    (when (defined? (down initialFrame))
      (pop-frames-up-to (down initialFrame)))
    (let ((patternRecord (pattern-record initialFrame)))
      (setf (current-pattern-record self) patternRecord)
      (special ((*context* (get-query-context))
                (*queryIterator* self))
        (unbind-variables-beginning-at patternRecord 0)
        (when (defined? (initial-bindings self))
          (foreach arg in (external-variables self)
              as value in (initial-bindings self)
              where (defined? value)
              do (unless (bind-argument-to-value? arg value FALSE)
                   (signal FAIL-EXCEPTION "reset: binding of " arg " to " value " failed."))))
        (overlay-with-pattern-frame?
         initialFrame (description patternRecord) (external-arguments patternRecord))))
    (setf (exhausted? self) FALSE)
    (setf (timeout? self) FALSE)
    (setf (depth-cutoffs? self) FALSE)
    (clear (solutions self))
    (setf (truth-value initialFrame) NULL)
    (setf (augmented-goal-cache? self) FALSE)
    (setf (triggered-depth-cutoff? self) FALSE) ))

(defun (standardize-query-tree CONS) 
       ((ioVariables OBJECT) (queryBody OBJECT) (externalVariables CONS))
  ;; Return a standardized (prefix-stella) version of 'queryBody'.
  ;; If ioVariables' is NULL, 'queryBody' is assumed to be a
  ;;    fully ground proposition.
  ;; Otherwise, it is assumed to have the format of an EXISTS sentence,
  ;;    but without the quantifier, e.g.,
  ;;           "((?x Color) (= (color HOUSE-1) ?x))"
  (cond
   ((null? ioVariables)
    (setq ioVariables NIL))
   ((not (cons? ioVariables))
    (setq ioVariables (cons-list ioVariables))))
  (let ((standardizedTree CONS NULL)
        (allVariables CONS ioVariables))
    (foreach v in (reverse externalVariables)
             do (pushq allVariables v))
    (when (null? queryBody)
      (setq queryBody (quote TRUE)))
    (cond 
     ((nil? allVariables)
      (setq standardizedTree (bquote (KAPPA () & queryBody))))
     (otherwise
      (setq standardizedTree (bquote (EXISTS & allVariables & queryBody)))))
    (setq standardizedTree
      (standardize-logical-parse-tree standardizedTree))
    (setf (first standardizedTree) (quote KAPPA))
    (return standardizedTree) ))

(defun (make-query QUERY-ITERATOR) ((ioVariables OBJECT) (queryTree OBJECT) 
                                    (externalBindings CONS) (options OBJECT))
  ;; Convert 'queryTree' into a query iterator.
  (finalize-objects)
  ;; recheck propositions that failed a type check:
  (process-check-types-agenda)
  (let ((prefixQueryTree 
         (standardize-query-tree ioVariables queryTree NIL))
        (externalVector
         (only-if (non-empty? externalBindings)
                  (copy-list-to-arguments-vector (listify externalBindings))))
        (description DESCRIPTION NULL)
        (query (allocate-query-iterator)))
    ;; We want atomic singletons for the following query variable patterns:
    ;;   ?x   |   (?x TYPE)
    ;; but not for
    ;;   (?x ?y)  or (?x (?y TYPE))
    ;; Because the query has been standardized, types have been turned
    ;;   into the appropriate surrogates:
    (when (or (not (cons? ioVariables))
              (surrogate? (second (cast ioVariables CONS))))
      (setf (atomic-singletons? query) TRUE))
    (special ((*evaluationMode* :DESCRIPTION)
              (*logicVariableTable* NIL)
              (*termUnderConstruction* prefixQueryTree)
              ;; block variable bindings in case of nested calls:
              (*queryIterator* NULL))
      (within-module *module*       
        (setq description 
              (evaluate-DESCRIPTION-term prefixQueryTree FALSE))))
    ;; call this again to also check for any problems in the query description:
    (process-check-types-agenda)
    (when (defined? options)
      (process-query-options query options))
    (return (initialize-query-iterator query description externalVector))))

(defun (parse-query-and-options OBJECT OBJECT PROPERTY-LIST)
    ((query&Options CONS))
  ;; Parse the arguments given to an `ask' or `retrieve' command (or any of
  ;;    their partial match versions) and return three values:
  ;;    (1) a specification of IO variables (or NULL if no variables were given)
  ;;    (2) the query proposition (or NULL if no proposition was specified)
  ;;    (3) a list of query options specified as a property list
  ;;        (pre-query/non-keyword options such as ALL or the number of
  ;;        solutions desired will also be converted into proper options).
  ;;        This value will always be non-NULL for easier use and lookup.
  (when (or (null? query&Options)
            (empty? query&Options))
    (return NULL NULL (new PROPERTY-LIST)))
  (let ((firstArg (first query&Options))
        (variables OBJECT NULL)
        (proposition OBJECT NULL)
        (options (new PROPERTY-LIST))
        (handleNonMatchingVariables? FALSE)
        (freeVariables (LIST OF SYMBOL) NULL)
        (declaredVariables CONS NULL))
    (typecase firstArg
      (INTEGER-WRAPPER
       (insert-at options :HOW-MANY firstArg)
       (setq query&Options (rest query&Options)))
      ((SYMBOL KEYWORD)
       (cond
        ((string-equal? (symbol-name firstArg) "ALL")
         (insert-at options :HOW-MANY NULL-INTEGER)
         (setq query&Options (rest query&Options)))
        ((string-equal? (symbol-name firstArg) "BEST")
         (insert-at options :HOW-MANY NULL-INTEGER)
         (insert-at options :SORT-BY :SCORE)
         (setq query&Options (rest query&Options)))))
      (otherwise NULL))
    (when (not (keyword? (first query&Options)))
      (setq variables (first query&Options))
      (setq query&Options (rest query&Options)))
    (when (not (keyword? (first query&Options)))
      (setq proposition (first query&Options))
      (setq query&Options (rest query&Options)))
    (when (and (defined? variables)
               (null? proposition)
               (not (kif-variable-declaration? variables)))
      ;; we have a proposition without variable declarations:
      (setq proposition variables)
      (setq variables NULL))
    (when (cons? proposition)
      ;; determine free query variables:
      (setq freeVariables (new LIST))
      (cond ((null? variables)
             (setq declaredVariables NIL))
            ((not (cons? variables))
             (setq declaredVariables (cons variables NIL)))
            (otherwise
             (setq declaredVariables variables)))
      (setq declaredVariables
        (extract-variables-from-declarations declaredVariables))
      (collect-undeclared-variables proposition NIL freeVariables)
      (cond ((and (empty? declaredVariables)
                  (non-empty? freeVariables))
             (if (= (length freeVariables) 1)
                 ;; assume atomic singletons if no variables were declared:
                 (setq variables (first freeVariables))
               (setq variables (the-cons-list freeVariables))))
            ((and (empty? declaredVariables)
                  (empty? freeVariables))
             NULL)
            ((not (equivalent-sets? (the-cons-list freeVariables) declaredVariables))
             ;; we defer this until option parsing is comlete:
             (setq handleNonMatchingVariables? TRUE))))
    (while (non-empty? query&Options)
      (when (not (keyword? (first query&Options)))
        (signal-parsing-error "Illegal query option: " (first query&Options)))
      (when (null? (second query&Options))
        (signal-parsing-error "Missing value for option " (first query&Options)))
      (insert-at options (first query&Options) (second query&Options))
      (setq query&Options (rest (rest query&Options))))
    (when handleNonMatchingVariables?
      (if (coerce-to-boolean (first-defined (lookup options :check-variables?) FALSE))
          ;; we are required to report a mismatch:
          (signal-parsing-error
           "Declared query variables " declaredVariables " do not match" EOL
           "   the free variables " (the-cons-list freeVariables)
           " referenced in the query body." EOL
           "   To simply use the free variables, omit the declaration")
        ;; we simply quantify the free non-output variable with an exists:
        (setq proposition
          (bquote (pl-kernel/exists & (difference (the-cons-list freeVariables)
                                                  declaredVariables)
                                    & proposition)))))
    (return variables proposition options)))

(defun process-query-options ((query QUERY-ITERATOR) (options OBJECT))
  ;; Process the key/value pairs in `options' and modify `query' accordingly.
  ;; Record the legal and normalized options in `query's `options' slot.
  (let ((theOptions (vet-options options NULL))
        (deferredOptions PROPERTY-LIST NULL))
    (setf (options query) theOptions)
    (foreach (key value) in theOptions
        do (case key
             (:TIMEOUT
              (typecase value
                ((INTEGER FLOAT)
                 (setf (allotted-time query) value)
                 (insert-at theOptions key (allotted-time query)))
                (otherwise
                 (signal-parsing-error "Illegal :TIMEOUT value: " value)))
              (setf (timeout? query) FALSE))
             (:MOVEOUT
              (typecase value
                ((INTEGER FLOAT)
                 (setf (allotted-clock-ticks query) (floor value))
                 (insert-at theOptions key (floor value)))
                (otherwise
                 (signal-parsing-error "Illegal :MOVEOUT value: " value))))
             (:MAXIMUM-DEPTH
              (typecase value
                ((INTEGER FLOAT)
                 (insert-at theOptions key (floor value))
                 (setf (maximum-depth query)
                   (lookup-query-option query :MAXIMUM-DEPTH)))
                (otherwise
                 (signal-parsing-error
                  "Illegal :MAXIMUM-DEPTH value: " value))))
             (:INFERENCE-LEVEL
              (typecase value
                ((GENERALIZED-SYMBOL STRING-WRAPPER)
                 (insert-at theOptions key
                            (keywordify (coerce-to-string value)))
                 (setf (inference-level query)
                   (get-inference-level
                    (lookup-query-option query :INFERENCE-LEVEL))))
                (otherwise
                 (signal-parsing-error
                  "Illegal :INFERENCE-LEVEL value: " value))))
             (:THREE-VALUED?
              (setq value (coerce-to-boolean value))
              (insert-at theOptions key value))
             (:ITERATIVE-DEEPENING?
              (setq value (coerce-to-boolean value))
              (insert-at theOptions key value)
              (when (eql? value TRUE-WRAPPER)
                (setf (iterative-deepening? query) TRUE)))
             ((:SINGLETONS? :ATOMIC-SINGLETONS?) ;; Special option of `apply-cached-retrieve'
              (insert-at theOptions key (coerce-to-boolean value))
              (setf (atomic-singletons? query) (eql? value TRUE-WRAPPER)))
             (:DONT-OPTIMIZE?
              (setq value (coerce-to-boolean value))
              ;; handled later during initialization:
              (insert-at theOptions key value))
             (:ALL-PROOFS?
              (setq value (coerce-to-boolean value))
              ;; handled later during initialization:
              (insert-at theOptions key value))
             (:CHECK-VARIABLES?
              ;; we already looked at this option during query parsing:
              (setq value (coerce-to-boolean value))
              (insert-at theOptions key value))
             (:HOW-MANY
              (typecase value
                (INTEGER-WRAPPER NULL)
                (GENERALIZED-SYMBOL
                 (cond
                  ((string-eql? (symbol-name value) "ALL")
                   (insert-at theOptions key NULL-INTEGER))
                  (otherwise
                   (signal-parsing-error "Illegal :HOW-MANY value: " value))))
                (otherwise
                 (signal-parsing-error "Illegal :HOW-MANY value: " value))))
             (:SORT-BY
              (typecase value
                (GENERALIZED-SYMBOL
                 (cond
                  ((string-eql? (symbol-name value) "SCORE")
                   (insert-at theOptions key :SCORE))
                  ((string-eql? (symbol-name value) "VALUES")
                   (insert-at theOptions key :VALUES))
                  ((string-eql? (symbol-name value) "VALUES-DESCENDING")
                   (insert-at theOptions key :VALUES-DESCENDING))
                  ((string-eql? (symbol-name value) "VALUES-ASCENDING")
                   (insert-at theOptions key :VALUES-ASCENDING))
                  (otherwise
                   (signal-parsing-error "Illegal :SORT-BY value: " value))))
                (otherwise
                 (signal-parsing-error "Illegal :SORT-BY value: " value))))
             (:MATCH-MODE
              (typecase value
                ((GENERALIZED-SYMBOL STRING-WRAPPER)
                 ;; legal values are later checked by the partial matcher:
                 (if (string? value)
                     (insert-at theOptions key (keywordify value))
                   (insert-at theOptions key value)))
                (otherwise
                 (signal-parsing-error "Illegal :MATCH-MODE value: " value))))
             (:MINIMUM-SCORE
              (typecase value
                (INTEGER-WRAPPER
                 (insert-at theOptions key (cast (wrapper-value value) FLOAT)))
                (FLOAT-WRAPPER NULL)
                (otherwise
                 (signal-parsing-error "Illegal :MINIMUM-SCORE value: "
                                       value))))
             (:MAXIMIZE-SCORE?
              (insert-at theOptions key (coerce-to-boolean value)))
             (:MAXIMUM-UNKNOWNS
              (typecase value
                (INTEGER-WRAPPER NULL)
                (FLOAT-WRAPPER
                 (insert-at theOptions key
                            (cast (wrapper-value value) INTEGER)))
                (otherwise
                 (signal-parsing-error "Illegal :MAXIMUM-UNKNOWNS value: "
                                       value))))
             (otherwise
              ;; leave room for special options needed by partial match modes:
              (when (null? deferredOptions)
                (setq deferredOptions (new PROPERTY-LIST)))
              (insert-at deferredOptions key value))))
    (when (defined? deferredOptions)
      (insert-at theOptions :DEFERRED-OPTIONS deferredOptions))))

(defun (lookup-query-option OBJECT) ((queryOrOptions OBJECT) (key KEYWORD))
  ;; Lookup option `key' in `queryOrOptions' and return the result.
  (let ((options PROPERTY-LIST NULL))
    (typecase queryOrOptions
      (PROPERTY-LIST (setq options queryOrOptions))
      (QUERY-ITERATOR (setq options (options queryOrOptions))))
    (return (lookup options key))))

(defun (test-query-option? BOOLEAN) ((queryOrOptions OBJECT) (key KEYWORD))
  ;; Return true if option `key' in `queryOrOptions' is set to true.
  (return (eql? (lookup-query-option queryOrOptions key) TRUE-WRAPPER)))

(defun (lookup-deferred-query-option OBJECT) ((queryOrOptions OBJECT)
                                              (key KEYWORD)
                                              (coerceToType TYPE))
  ;; Lookup option `key' in the deferred options of `queryOrOptions'
  ;;    or `queryOrOptions' and return the result.
  ;; If `key' was a deferred option, remove it from that list.
  ;; If `coerceToType' is supplied, try to coerce the looked-up value
  ;;    to it or signal an error otherwise.
  (let ((options PROPERTY-LIST NULL)
        (deferredOptions PROPERTY-LIST NULL)
        (value OBJECT NULL)
        (coercedValue OBJECT NULL)
        (processedDeferredOption? FALSE))
    (typecase queryOrOptions
      (PROPERTY-LIST (setq options queryOrOptions))
      (QUERY-ITERATOR (setq options (options queryOrOptions))))
    (setq deferredOptions (lookup options :DEFERRED-OPTIONS))
    (when (defined? deferredOptions)
      (setq value (lookup deferredOptions key))
      (if (null? value)
          (setq value (lookup options key))
        (setq processedDeferredOption? TRUE))
      (when (defined? value)
        (when (defined? coerceToType)
          (setq coercedValue (coerce-option-value value coerceToType))
          (if (null? coercedValue)
              (signal-parsing-error "Illegal " key " value: " value)
            (setq value coercedValue)))
        (when processedDeferredOption?
          ;; move coerced value into query options:
          (remove-at deferredOptions key)
          (insert-at options key value))))
    (return value)))

(defun (lookup-how-many-solutions INTEGER) ((queryOrOptions OBJECT))
  ;; Lookup and decode the value of the :HOW-MANY option in `queryOrOptions'.
  (let ((howMany (lookup-query-option queryOrOptions :HOW-MANY)))
    ;; SLIGHTLY TRICKY: an undefined value means `1', while a (wrapped)
    ;;    NULL-INTEGER value means `ALL':
    (if (defined? howMany)
        (return howMany) ;; integer or NULL
      (return 1))))

(defun (run-yes-or-no-query? THREE-VALUED-BOOLEAN) ((query QUERY-ITERATOR))
  ;; Somewhat deprecated.  Use `call-ask' instead.
  ;; Run the query iterator, handle any exceptions, cleanup after, and
  ;;    return TRUE-WRAPPER, FALSE-WRAPPER or NULL (default truth values
  ;;    will be interpreted just like their strict counterparts).
  ;; CAUTION: SINCE THIS FUNCTION RETURNS NULL TO INDICATE
  ;;    "UNKNOWN", IT CAN NOT BE USED DIRECTLY IN BOOLEAN EXPRESSIONS
  ;;    WITHOUT GUARDING IT WITH A CALL TO `defined?'!!!
  (let ((truthValue (call-ask query)))
    (cond ((true-truth-value? truthValue)
           (return TRUE))
          ((false-truth-value? truthValue)
           (return FALSE))
          (otherwise
           (return NULL)))))

(defun (coerce-to-tree OBJECT) ((self OBJECT))
  ;; Helping function for top-level functions.
  ;; If 'self' is a string, unstringify it.  Otherwise, return 'self'.
  (typecase self
    (STRING-WRAPPER 
     (return (unstringify self)))
    (otherwise
     (return self))) )

(defun (create-ask-query QUERY-ITERATOR) ((query OBJECT))
  ;; Convert `query' into a QUERY-ITERATOR.  If it is already, simply return it.
  ;; If it is a CONS, assume it represents the arguments to an ASK (or one of
  ;;    its friends) and create and return an appropriate query object.
  ;; Otherwise, signal an error.
  (typecase query
    (QUERY-ITERATOR
     (return query))
    (PROPOSITION
     (return (create-ask-query (proposition-to-cons query))))
    (CONS
     (mv-bind (ioVariables proposition options)
         (parse-query-and-options query)
       (if (and (null? ioVariables)
                (defined? proposition))
           (return (make-query NIL proposition NIL options))
         (signal-parsing-error "Illegal ASK query: " query))))
    (otherwise
     (signal-parsing-error "Illegal ASK query: " query))))

(defun (call-ask TRUTH-VALUE) ((query OBJECT))
  :documentation "Callable version of `ask' (which see).  Accepts queries
specified by a query iterator, or specified as a CONS-list of arguments as they
would be supplied to `ask'.  Raises LOGIC-EXCEPTIONs in case of illegal
queries and logical expressions."
  :public? TRUE
  (special ((*queryIterator* (create-ask-query query))
            ;; initialize these for the sake of recursive queries:
            (*reversePolarity?* FALSE)
            (*inferenceLevel* (current-inference-level))
            (*generate-all-proofs?* FALSE))
    (let ((truthValue TRUTH-VALUE NULL)
          (threeValuedAsk?
           (test-query-option? *queryIterator* :THREE-VALUED?)))
      (when (null? *most-recent-query*)
        ;; only the top-level query commands handle nullification and use:
        (setq *most-recent-query* *queryIterator*))
      (next? *queryIterator*)
      (setq truthValue
        (first-defined (truth-value (base-control-frame *queryIterator*))
                       UNKNOWN-TRUTH-VALUE))
      (when (and threeValuedAsk? (unknown-truth-value? truthValue))
        (setf (reverse-polarity? (base-control-frame *queryIterator*)) TRUE)
        (reset *queryIterator*)
        (next? *queryIterator*)
        (setq truthValue
          (first-defined (truth-value (base-control-frame *queryIterator*))
                         UNKNOWN-TRUTH-VALUE)))
      (return truthValue))))

(defun (ask TRUTH-VALUE) (&rest (proposition&options PARSE-TREE))
  :public? TRUE :command? TRUE :evaluate-arguments? FALSE
  :documentation
  "Perform inference to determine whether the proposition specified in
`proposition&options' is true.  Return the truth-value found.  `ask'
will spend most of its effort to determine whether the proposition
is true and only a little effort via shallow inference strategies to
determine whether it is false.  To find out whether a proposition is
false with full inference effort `ask' its negation.

KIF example: `(ask (happy Fred))' will return TRUE if Fred was indeed
found to be happy.  Note, that for this query to run, the logic
constant `Fred' and the relation `happy' must already be defined (see
`assert').  Use `(set/unset-feature goal-trace)' to en/disable goal
tracing of the inference engine.

The `ask' command supports the following options: `:TIMEOUT' is an
integer or floating point time limit, specified in seconds.  For
example, the command `(ask (nervous Fred) :timeout 2.0)' will cease
inference after two seconds if a proof has not been found by then.
If the `:DONT-OPTIMIZE?' is given as TRUE, it tells PowerLoom to
not optimize the order of clauses in the query before evaluating it.
This is useful for cases where a specific evaluation order of the
clauses is required (or the optimizer doesn't do the right thing).
If `:THREE-VALUED?' is given as TRUE, PowerLoom will try to prove
the negation of the query with full effort in case the given query
returned UNKNOWN.  By default, PowerLoom uses full effort to prove
the query as stated and only a little opportunistic effort to see
whether it is actually false."
  ;; Enable recording of the top-level query for the benefit of `why':
  (setq *most-recent-query* NULL)
  (exception-case      
      (return (call-ask (coerce-&rest-to-cons proposition&options)))
    (LOGIC-EXCEPTION (e)
      (print-stream STANDARD-ERROR (exception-message e))
      (setq *most-recent-query* NULL)
      (return NULL))))

(defun (retrieve-bindings QUERY-ITERATOR) ((query OBJECT) (nofBindings INTEGER))
  ;; DEPRECATED, use `call-retrieve' instead.
  ;; Retrieve the next 'nofBindings' bindings for the variables of 'query' that
  ;;    satisfy its proposition and store them in the returned query iterator.
  ;; Return prematurely if no more bindings can be found.
  ;; If 'nofBindings' is NULL all possible bindings will be generated.
  ;; 'query' can be a query iterator, or a cons tree in the format of an EXISTS
  ;;    sentence, but without the quantifier.
  (let ((theQuery QUERY-ITERATOR NULL))
    (typecase query
      (QUERY-ITERATOR
       (setq theQuery query))
      (PROPOSITION
       (setq theQuery
             (make-query (consify (io-variables query))
                         (proposition-to-cons query)
                         NIL
                         (bquote (:how-many & nofbindings)))))
      (CONS
       (setq theQuery
         (make-query (first query) (second query) NIL (rest (rest query))))))
    (insert-at (options theQuery) :HOW-MANY nofBindings)
    (return (call-retrieve theQuery))))

(defun (create-retrieve-query QUERY-ITERATOR) ((query OBJECT))
  ;; Convert `query' into a QUERY-ITERATOR.  If it is already, simply return it.
  ;; If it is a CONS, assume it represents the arguments to a RETRIEVE (or one of
  ;;    its friends) and create and return an appropriate query object.
  ;; Otherwise, signal an error.
  (typecase query
    (QUERY-ITERATOR
     (return query))
    (PROPOSITION
     (return (create-retrieve-query (proposition-to-cons query))))
    (CONS
     (mv-bind (ioVariables queryProposition options)
         (parse-query-and-options query)
       (cond
        ((and (null? ioVariables)
              (null? queryProposition))
         (when (null? *most-recent-query*)
           (signal-parsing-error
            "No preceding context for follow-up retrieval"))
         (process-query-options *most-recent-query* options)
         (return *most-recent-query*))
        ((null? ioVariables)
         (signal-parsing-error
          "Missing IO-variable specification in retrieval query: " query))
        (otherwise
         (return
           (make-query ioVariables queryProposition NIL options))))))
    (otherwise
     (signal-parsing-error "Illegal retrieval query: " query))))

(defun (call-retrieve QUERY-ITERATOR) ((query OBJECT))
  :documentation "Callable version of `retrieve' (which see).  Accepts queries
specified by a query iterator, or specified as a CONS-list of arguments as they
would be supplied to `retrieve'.  Raises LOGIC-EXCEPTIONs in case of illegal
queries and logical expressions."
  :public? TRUE
  (let ((theQuery (create-retrieve-query query))
        (matchMode (lookup-query-option theQuery :MATCH-MODE)))
    (when (and (defined? matchMode)
               (not (string-equal? (coerce-to-string matchMode) "STRICT")))
      (return (call-retrieve-partial theQuery)))
    (special ((*queryIterator* theQuery)
              ;; initialize these for the sake of recursive queries:
              (*reversePolarity?* FALSE)
              (*inferenceLevel* (current-inference-level))
              (*generate-all-proofs?*
               (test-query-option? theQuery :ALL-PROOFS?)))
      (foreach i in (interval 1 (lookup-how-many-solutions *queryIterator*))
          as solution in *queryIterator*
          do (when (trace-keyword? :TRACE-SOLUTIONS)
               ;; trace solution generation; useful for expensive queries:
               (trace-solution *queryIterator* solution i)))
      (let ((sortOption KEYWORD (lookup-query-option theQuery :SORT-BY)))
        (case sortOption
          ((:VALUES :VALUES-ASCENDING)
           (sort (solutions theQuery)
                 (the-code :function query-solution-less-than?)))
          (:VALUES-DESCENDING
           (sort (solutions theQuery)
                 (the-code :function query-solution-greater-than?)))
          (otherwise NULL)))
      (return *queryIterator*))))

(defglobal *most-recent-query* QUERY-ITERATOR NULL)

(defun (retrieve QUERY-ITERATOR) (&rest (query PARSE-TREE))
  :public? TRUE :command? TRUE :evaluate-arguments? FALSE
  :documentation
  "Retrieve elements of a relation (tuples) that satisfy a proposition.
The accepted syntax is:
	 
  (retrieve [<integer> | all]
            [[{<vardecl> | (<vardecl>+)}]
            <proposition>])
	
The variables and proposition are similar to an `exists' sentence or
`kappa' term without the explicit quantifier.  If variables are declared,
they must match the free variables referenced by <proposition>.  Otherwise,
the free variables referenced in <proposition> will be used as the query
variables.  If <proposition> is omitted, the most recently asked query
will be continued.

A solution is a set of bindings for the listed variables for which
<proposition> is true.  The optional first argument controls how many
solutions should be generated before control is returned.  The keyword
`all' indicates that all solutions should be generated.  By default,
`retrieve' returns after it has found one new solution or if it cannot
find any more solutions.

`retrieve' returns an iterator which saves all the necessary state of
a query and stores all generated solutions.  When used interactively,
the returned iterator will print out with the set of solutions collected
so far.  Calling `retrieve' without any arguments (or only with the first
argument) will generate one (or more) solutions to the most recently
asked query.

KIF examples:
	 
  (retrieve (happy ?x))
	
will try to find one happy entity and store it in the returned 
query iterator.
	 
  (retrieve 10 (happy ?x))
	
will try to find 10 happy entities.
	 
  (retrieve 10)
	
will try to find the next 10 happy entities..
	 
  (retrieve all (happy ?x))
	
will find all happy entities.
	 
  (retrieve all (?x Person) (happy ?x))
	
will to find all happy people.  Here we used the optional retrieve variable
syntax to restrict the acceptable solutions.  The above is equivalent to
the following query:
	 
  (retrieve all (and (Person ?x) (happy ?x)))
	
Similarly,
	 
  (retrieve all (?x Person))
  (retrieve all (Person ?x))
  (retrieve all ?x (Person ?x))
	
will find all people.  Note that in the first case we only specify a query
variable and its type but omit the logic sentence which defaults to TRUE.  This
somewhat impoverished looking query can be paraphrased as \"retrieve all ?x of
type Person such that TRUE.\"
	 
  (retrieve ?x (or (happy ?x) (parent-of Fred ?x)))
	
will try to find a person that is happy or has Fred as a parent.
	 
  (retrieve (?y ?x) (parent-of ?x ?y))
	
will try to find the one pair of parent/child and return it in the order
of child/parent.
	 
  (retrieve all (?x Person)
            (exists (?y Person) (parent-of ?x ?y)))
	
will generate the set of all parents.  Note, that for these queries to run,
the class `Person', the relations `happy' and `parent-of', and the logic
constant `Fred' must already be defined (see `assert').

Use `(set/unset-feature trace-subgoals)' to en/disable goal tracing of the
inference engine."
  ;; Enable the recording of the top-level query for the benefit of `why':
  (exception-case
        (return
          (setq *most-recent-query* (call-retrieve (coerce-&rest-to-cons query))))
    (LOGIC-EXCEPTION (e)
      (print-stream STANDARD-ERROR (exception-message e))
      (return (setq *most-recent-query* NULL)))))

(defmethod (consify-current-solutions CONS) ((self QUERY-ITERATOR))
  :documentation
  "Collect the current solutions of `self' into a cons list
of result tuples.  If `:SINGLETONS? TRUE', collect a list of atoms rather than a
list of lists for tuples of arity=1."
  :public? TRUE
  (let ((solutions (solutions self))
        (listifiedSolutions NIL)
        (arity (arity (query-description self)))
	(atomicSingletons? (atomic-singletons? self)))
    (foreach solution in solutions
        collect (choose (and atomicSingletons?
                             (= arity 1))
                        (first (bindings solution))
                        (consify (bindings solution)))
        into listifiedSolutions)
    (return listifiedSolutions) ))

(defmethod (consify CONS) ((self QUERY-ITERATOR))
  :documentation
  "Generate all solutions for the query self, and collect them into a cons list
of result tuples.  If `:SINGLETONS? TRUE', collect a list of atoms rather than a
list of lists for tuples of arity=1."
  :public? TRUE
  (special ((*queryIterator* self)
	    ;; initialize this for the sake of recursive queries:
	    (*reversePolarity?* FALSE))
    (while (next? self)))
  (return (consify-current-solutions self)))

(defun (consify-query CONS) ((self QUERY-ITERATOR))
  ;; DEPRECATED, use `QUERY-ITERATOR.consify'.
  :globally-inline? TRUE
  (return (consify self)))

(defmethod (listify LIST) ((self QUERY-ITERATOR))
  :documentation "Just like `QUERY-ITERATOR.consify' but return a LIST instead."
  :public? TRUE
  (return (new LIST :the-cons-list (consify self))) )


  ;;
;;;;;; In-line queries
  ;;

;;; Note: we need an allocation scheme that can handle recursive calls
;;; of the same cached query with different arguments while the ones
;;; from earlier calls are still active.

(defglobal *inline-query-cache* (KEY-VALUE-MAP OF SYMBOL (LIST OF QUERY-ITERATOR))
           (new KEY-VALUE-MAP)
  :documentation "Caches queries used in-line by code, so that they don't have to
be reparsed and reoptimized each time they are invoked."
  :thread-local? TRUE)

(defun clear-inline-query-caches ()
  ;; Clear all cached queries (they will regenerate themselves).
  (clear *inline-query-cache*))

(defun (find-cached-query QUERY-ITERATOR) ((queryID SYMBOL))
  ;; If there are any cached queries available for `queryID',
  ;; return one of them and remove it from the cache.
  (let ((queries (lookup *inline-query-cache* queryID)))
    (if (defined? queries)
        (return (pop queries))
      (return NULL))))

(defglobal *max-cached-queries-per-id* INTEGER 10)

(defun free-cached-query ((query QUERY-ITERATOR) (queryID SYMBOL))
  ;; Return `query' to the query cache for `queryID'.
  (let ((queries (lookup *inline-query-cache* queryID)))
    (when (null? queries)
      (setq queries (new LIST))
      (insert-at *inline-query-cache* queryID queries))
    ;; guard against excessive consumption in case we have very deep recursion:
    (when (< (length queries) *max-cached-queries-per-id*)
      (push queries query))))

(defun (make-cached-query QUERY-ITERATOR)
       ((variables CONS) (queryBody CONS) (inputBindings CONS)
        (options OBJECT) (cacheID SYMBOL))
  ;; Make a cached query.
  ;; Called by 'apply-cached-retrieve' and 'apply-cached-ask'.
  :public? TRUE
  (let ((queryIterator (find-cached-query cacheID))
        (cursor inputBindings))
    (when (not (eql? (length variables)
                     (length inputBindings)))
      (inform "make-cached-query: number of variables does not equal number of input bindings.")
      (return NULL))
    (while (non-empty? cursor)
      (when (defined? (value cursor))
        (setf (value cursor) (value-of (value cursor))))
      (setq cursor (rest cursor)))
    (when (and (defined? queryIterator)
               (use-static-query-optimization?))
      ;; semi-tricky: if pattern of NULLs in 'inputBindings' has changed
      ;;    we need to re-optimize if the static optimizer is used:
      (foreach oldB in (initial-bindings queryIterator)
          as newB in inputBindings
          where (not (eql? (null? oldB) (null? newB)))
          do (setq queryIterator NULL)
             (break)))
    (if (null? queryIterator)
      (progn
        (exception-case
            (setq queryIterator
              (make-query (copy-cons-list variables)
                          (copy-cons-tree queryBody)
                          inputBindings
                          options))
         (LOGIC-EXCEPTION (e)
	   (print-stream STANDARD-ERROR (exception-message e))
           (return NULL))))
      (progn
        (foreach newB in inputBindings
            as i in (interval 0 NULL)
            do (setf (nth (initial-bindings queryIterator) i) newB))
        (reset queryIterator)))
    (when (defined? options)
      (process-query-options queryIterator options))
    (return queryIterator) ))

(defun (apply-cached-retrieve CONS CONS CONS)
    ((variables CONS) (queryBody CONS) (inputBindings CONS)
     (options OBJECT) (cacheID SYMBOL))
  :public? TRUE
  ;; Execute the query consisting of 'variables' and 'queryBody'.
  ;; Bind some of 'variables' to 'inputBindings'.
  ;; Return (1) a list of lists of bindings for the unbound variables,
  ;;            or a list of values if only one variable is unbound.
  ;;        (2) a list of corresponding truth values
  ;;        (3) a list of corresponding justifications, if enabled
  ;; Tricky: Uses 'cacheID' to index into a cache of queries.  Expansion
  ;;    of the macro 'apply-retrieve' creates a new gensym, so a new query
  ;;    gets generated each time an embedded call to 'apply-retrieve' is
  ;;    compiled.
  (let ((queryIterator QUERY-ITERATOR NULL)
        (bindingsCount 0)
        (outputBindings NIL)
        (truthValues NIL)
        (justifications NIL)
        (forceSingletonTuples? FALSE))
    (foreach it on inputBindings
        where (defined? (value it))
        do (++ bindingsCount))
    (setq queryIterator
      (make-cached-query variables queryBody inputBindings options cacheID))
    (when (null? queryIterator)
      (return NIL NIL NIL))
    ;; by default, we return singletons if there is only one variable,
    ;; but we can turn that off if we set :SINGLETONS? to FALSE:
    (when (or (eql? (lookup (options queryIterator) :SINGLETONS?) FALSE-WRAPPER)
              (eql? (lookup (options queryIterator) :ATOMIC-SINGLETONS?) FALSE-WRAPPER))
      (setq forceSingletonTuples? TRUE))
    (special ((*queryIterator* queryIterator)
              ;; initialize this for the sake of recursive queries:
              (*reversePolarity?* FALSE))
      ;; generate all solutions:
      (while (next? queryIterator)))
    (let ((tuple OBJECT NULL)
          (atomicSingletons? (and (eql? (length inputBindings) (1+ bindingsCount))
                                  (not forceSingletonTuples?))))
      (foreach s in (solutions queryIterator)
          do (if atomicSingletons?
                (foreach v in (bindings s)
                    as b in inputBindings
                    where (null? b)
                    do (setq tuple v))
              (let ((values NIL))
                (foreach v in (bindings s)
                    as b in inputBindings
                    where (null? b)
                    collect v into values)
                (setq tuple values)))
             (pushq outputBindings tuple)
             (pushq truthValues (truth-value s))
             (when (record-justifications?)
               (pushq justifications (justification s)))))
    (free-cached-query queryIterator cacheID)
    (return (reverse outputBindings) (reverse truthValues) (reverse justifications))))

(defun (apply-cached-ask BOOLEAN TRUTH-VALUE)
       ((inputVariables CONS) (queryBody CONS) (inputBindings CONS)
        (options OBJECT) (cacheID SYMBOL))
  :public? TRUE
  ;; Execute the query consisting of 'variables' and 'queryBody'.
  ;; Bind 'variables' to 'inputBindings'.
  ;; Return TRUE if the query can be proved, FALSE if could be disproved
  ;;    or is unknown.  Return the actual truth value as a second value.
  ;; Tricky: Uses 'cacheID' to index into a cache of queries.  Expansion
  ;;    of the macro 'apply-ask' creates a new gensym, so a new query
  ;;    gets generated each time an embedded call to 'apply-ask' is
  ;;    compiled.
  (let ((queryIterator
         (make-cached-query
          inputVariables queryBody inputBindings options cacheID)))
    (cond ((defined? queryIterator)
           (let ((truthValue (call-ask queryIterator)))
             (free-cached-query queryIterator cacheID)
             (return (true-truth-value? truthValue) truthValue)))
          (otherwise
           (return FALSE NULL)))))

        
  ;;
;;;;;; Subsumption queries
  ;;

(defun (get-prototype LOGIC-OBJECT) ((description DESCRIPTION))
  ;; Return a skolem that inherits the description 'description' together
  ;;    with constraints implies by membership in 'description'.
  ;; 'self' must be a CLASS description.
  :public? TRUE
  (when (null? description)
    (return NULL))
  (let ((prototype
         (access-binary-value description PL-KERNEL/@CONCEPT-PROTOTYPE)))
    (when (null? prototype)
      (setq prototype
        (first (apply-retrieve (?c ?p) (PL-KERNEL/concept-prototype ?c ?p)
                               (description NULL)))))
    (special ((*evaluationMode* :EXTENSIONAL-ASSERTION)
              (*queryIterator* NULL))
      (elaborate-meta-instance prototype)
      (return prototype))) )

(defun (unary-description-specializes-description? TRUTH-VALUE)
    ((sub DESCRIPTION) (super DESCRIPTION))
  ;; Try to prove that `sub' specializes `super' and return the result
  ;;    truth value of the query.
  ;; Tricky: DO NOT cache the result (the classifier might create too
  ;;    many redundant links if caching occurred).  SHOULD WE MEMOIZE?
  (when *reversePolarity?*
    (return UNKNOWN-TRUTH-VALUE))
  (when (description-implies-description? sub super)
    (return TRUE-TRUTH-VALUE))
  (special ((*printReadably?* TRUE))
    (trace-if :GOAL-TREE EOL "Prototype Subsumption Test:" EOL
              "   sub=" sub EOL "   super=" super EOL))
  (let ((result UNKNOWN-TRUTH-VALUE))
    (exception-case
        (within-meta-cache
         (setq result
           (call-ask
            (create-query-iterator super (vector (get-prototype sub))))))
      (LOGIC-EXCEPTION (e)
        (print-stream STANDARD-ERROR (exception-message e))))
    (trace-if :GOAL-TREE EOL)
    (return result)))

(defun (description-specializes-description? TRUTH-VALUE)
    ((sub DESCRIPTION) (super DESCRIPTION))
  ;; Try to prove that `sub' specializes `super' and return the result
  ;;    truth value of the query.
  ;; Tricky: DO NOT cache the result (the classifier might create too
  ;;    many redundant links if caching occurred).
  ;; WE NOW MEMOIZE `description-implies-description?', IS THAT A PROBLEM?
  :public? TRUE
  (unless (= (arity sub) (arity super))
    (if *reversePolarity?*
      (return TRUE-TRUTH-VALUE)
      (return FALSE-TRUTH-VALUE)))
  (when *reversePolarity?*
    (return UNKNOWN-TRUTH-VALUE))
  (when (description-implies-description? sub super)
    (return TRUE-TRUTH-VALUE))
  (when (= (arity super) 1)
    (return (unary-description-specializes-description? sub super)))
  (special ((*printReadably?* TRUE))
    (trace-if :GOAL-TREE EOL "Subsumption Test:" EOL
              "   sub=" sub EOL "   super=" super EOL))
  (let ((skolemsVector (new VECTOR :array-size (length (io-variables sub))))
        (result UNKNOWN-TRUTH-VALUE))
    (push-monotonic-world)
    (initialize-inference-world *context*)
    (foreach i in (interval 0 (1- (length skolemsVector)))
        do (setf (nth skolemsVector i)
             (create-hypothesized-instance "anonymous")))
    (exception-case
        (progn
          ;; Note: current `*queryIterator*' is visible here:
          (inherit-description skolemsVector sub FALSE)
          (setq result
            (call-ask (create-query-iterator super skolemsVector))))
      (LOGIC-EXCEPTION (e)
        (print-stream STANDARD-ERROR (exception-message e))))
    (pop-world)
    (trace-if :GOAL-TREE EOL)
    (return result)))

(defun (vector-satisfies-description? TRUTH-VALUE)
    ((vector VECTOR) (description DESCRIPTION))
  ;; Try to prove that that the values in `vector' satisfy `description' and
  ;;    return the result truth value of the query.
  :public? TRUE
  (unless (= (length vector) (arity description))
    (if *reversePolarity?*
      (return TRUE-TRUTH-VALUE)
      (return FALSE-TRUTH-VALUE)))
  (when *reversePolarity?*
    (return UNKNOWN-TRUTH-VALUE))
  (exception-case
      (when (forall value in vector
                    always (defined? value))
        (return (call-ask (create-query-iterator description vector))))
    (LOGIC-EXCEPTION (e)
      (print-stream STANDARD-ERROR (exception-message e))))
  (return UNKNOWN-TRUTH-VALUE))

(defun (instance-satisfies-description? TRUTH-VALUE)
    ((instance OBJECT) (description DESCRIPTION))
  ;; Try to prove that `instance' satisfies `description' and
  ;;    return the result truth value of the query.
  :public? TRUE
  (return (vector-satisfies-description? (vector instance) description)))


  ;;
;;;;;; Top level parametric queries
  ;;

(defun (coerce-to-description DESCRIPTION) ((self OBJECT) (original OBJECT))
  ;; Return the description associated with 'self'.
  (when (null? original)
    (setq original self))
  (when (null? self)
    (inform "Can't find a description for the object " original ".")
    (return NULL))
  (typecase self
    (DESCRIPTION (return self))
    (RELATION (return (get-description self)))
    (SURROGATE
     (return (coerce-to-description (surrogate-value self) original)))
    (SYMBOL
     (return
       (coerce-to-description
        (lookup-surrogate-in-module
         (symbol-name self) (interned-in self) FALSE)
        original)))
    (KEYWORD
     (return
       (coerce-to-description (lookup-surrogate (symbol-name self)) original)))
    (STRING-WRAPPER
     (return
       (coerce-to-description
        (lookup-surrogate (wrapper-value self)) original)))
    (otherwise
     ;; print warning message and then return NULL:
     (return (coerce-to-description NULL original)))) )

(defun (specializes? TRUTH-VALUE) ((subObject OBJECT) (superObject OBJECT))
  :documentation "Try to prove if the description associated with `subObject'
specializes the description for `superObject' and return the result truth
value of the query."
  :public? TRUE
  (let ((subDescription (coerce-to-description subObject NULL))
        (superDescription (coerce-to-description superObject NULL)))
    (finalize-objects)
    (within-meta-cache
     (when (and (defined? subDescription)
                (defined? superDescription))
       (return
         (description-specializes-description?
          subDescription superDescription))))
    (return UNKNOWN-TRUTH-VALUE)))

(defun (coerce-to-instance LOGIC-OBJECT) ((self OBJECT) (original OBJECT))
  :documentation "Return the logic instance referred to by 'self'."
  :public? TRUE
  (when (null? original)
    (setq original self))
  (when (null? self)
    (inform "Can't find a logic object " original ".")
    (return NULL))
  (typecase self
    (LOGIC-OBJECT (return self))
    (RELATION (return (get-description self)))
    (SURROGATE
     (let ((value (surrogate-value self))
           (store OBJECT-STORE NULL))
       (when (null? value)
         (setq store (home-object-store self))
         (when (defined? store)
           (setq value (fetch-instance store self))))
       (return (coerce-to-instance value original))))
    (SYMBOL (return (coerce-to-instance (symbol-to-surrogate self) original)))
    (KEYWORD
     (return
       (coerce-to-instance (lookup-surrogate (symbol-name self)) original)))
    (STRING-WRAPPER
     (return
       (coerce-to-instance (lookup-surrogate (wrapper-value self)) original)))
    (CONS
     (return (coerce-to-instance (evaluate-term self) original)))
    ;; print warning message and then return NULL:
    (otherwise (return (coerce-to-instance NULL original)))) )

(defun (coerce-to-instance-or-literal OBJECT) ((self OBJECT) (original OBJECT))
  :documentation
  "Return the logic instance referred to by `self', or `self' if it is a
literal (e.g., string or number) that can't be coerced."
  :public? TRUE
  (when (null? original)
    (if (defined? self)
        (setq original self)
      (return NULL))) ;; treat NULL like a literal
  (when (null? self)
    (cond ((wrapper? original)
           (return original))
          (otherwise
           (inform "Can't find a logic object " original ".")
           (return NULL))))
  (typecase self
    (LOGIC-OBJECT
     (return self))
    (RELATION
     (return (get-description self)))
    (SURROGATE
     (return (coerce-to-instance-or-literal (surrogate-value self) original)))
    (SYMBOL
     (return
       (coerce-to-instance-or-literal (symbol-to-surrogate self) original)))
    (KEYWORD
     (return
       (coerce-to-instance-or-literal
        (lookup-surrogate (symbol-name self)) original)))
    (STRING-WRAPPER
     (return
       (coerce-to-instance-or-literal
        (lookup-surrogate (wrapper-value self)) original)))
    ;; print warning message if necessary:
    (otherwise
     (return (coerce-to-instance-or-literal NULL original)))) )

(defun (coerce-to-vector VECTOR) ((self OBJECT))
  :documentation "Return a vector containing the elements in `self'.
Coerce each element of `self' to be a logic object or literal."
  :public? TRUE
  ;; ISSUE: IF A STRING ARGUMENT MATCHES AN EXISTING LOGIC OBJECT WE ALWAYS
  ;;        GET THE OBJECT EVEN IF WE WANTED THE LITERAL (E.G., AS ARGUMENT
  ;;        TO A `SATISFIES?' COMPUTATION).
  (let ((vector VECTOR NULL))
    (typecase self
      (VECTOR
       (setq vector self)
       (foreach m in self
           as i in (interval 0 NULL)
           do (setf (nth vector i) (coerce-to-instance-or-literal m NULL))))
      (LIST
       (setq vector (new VECTOR :array-size (length self)))
       (foreach m in self
           as i in (interval 0 NULL)
           do (setf (nth vector i) (coerce-to-instance-or-literal m NULL))))
      (CONS
       (setq vector (new VECTOR :array-size (length self)))
       (foreach m in self
           as i in (interval 0 NULL)
           do (setf (nth vector i) (coerce-to-instance-or-literal m NULL))))
      (otherwise
       (inform "Don't know how to coerce " self " of type "
               (primary-type self) EOL "   into a vector.")))
    (return vector) ))

(defun (satisfies? TRUTH-VALUE) ((instanceOrTuple OBJECT) (relationRef OBJECT))
  :documentation "Try to prove whether `instanceOrTuple' satisfies the
definition of the relation `relationRef' and return the result truth value
of the query.  `instanceOrTuple' can be a single object, the name or surrogate
of an object, or a collection (a list or vector) of objects.  `relationRef'
can be a relation, description, surrogate or relation name."
  :public? TRUE
  (let ((description (coerce-to-description relationRef NULL)))
    (when (defined? description)
      (finalize-objects)
      (within-context (get-query-context)
        (if (or (isa? instanceOrTuple STELLA/@COLLECTION)
                (cons? instanceOrTuple))
            (let ((vector (coerce-to-vector instanceOrTuple)))
              (when (defined? vector)
                (return (vector-satisfies-description? vector description))))
          (let ((instance (coerce-to-instance instanceOrTuple NULL)))
            (when (defined? instance)
              (return
                (instance-satisfies-description? instance description)))))))
    (return UNKNOWN-TRUTH-VALUE)))

;;; I THINK THIS SHOULD BE REMOVED OR RENAMED (HC):
(defun (apply-kappa? BOOLEAN) ((description DESCRIPTION) (vector VECTOR))
  :public? TRUE
  :documentation "Apply (inherit) the description 'description'
to members of the vector 'vector'.  Return TRUE if no clash was detected.
Constraint propagation happens only if it is enabled prior to calling
'apply-kappa?'."
  (exception-case
      (inherit-unnamed-description vector description FALSE)
    (CLASH (e)
      (print-stream STANDARD-ERROR (exception-message e) EOL)
      (return FALSE)))
  (return TRUE))


  ;;
;;;;;; Asserting/caching of query results
  ;;

;;; TO DO:
;;; - figure out how to do clipping here; inherit-proposition seems to work
;;;   differently in that respect than update-proposition

(defun (update-propositions-from-query (CONS OF PROPOSITION))
    ((query QUERY-ITERATOR)
     (description DESCRIPTION)
     (module MODULE)
     (updateMode KEYWORD)
     (recordJustifications? BOOLEAN))
  ;; For each solution in `query' build a corresponding proposition and
  ;;    assert or retract it in `module' according to `updateMode'.
  ;; If `description' is NULL, the proposition for each solution will be
  ;;    constructed by using the `query' proposition and substituting each
  ;;    output variable with the appropriate binding.
  ;; If `description' is supplied, its IO variables will be mapped onto
  ;;    `query's variables by position and instantiated with the bindings
  ;;    of each solution.  In this case the arity of the query proposition
  ;;    and `description' have to match (or be compatible for variable arity
  ;;    relations).
  (when (query-is-true-false? query)
    (signal-proposition-error
     "Can't yet assert/retract the result of a true/false query"))
  (let ((queryDescription (query-description query))
        (partial? (query-is-partial? query))
        (solutions (solutions query))
        (mapping (new ENTITY-MAPPING))
        (dontCheckDuplicates? FALSE)
        (proposition PROPOSITION NULL)
        (propositions NIL)
        ;; trace bookkeeping:
        (tenThousands 0)
        (terminateLine? FALSE))
    (cond ((defined? description)
           (when (and (not (= (arity description) (arity queryDescription)))
                      (or (not (variable-arity? description))
                          (< (arity queryDescription)
                             (length (io-variables description)))))
             (signal-proposition-error
              "Arity mismatch between query proposition and " description)))
          (otherwise
           (setq description queryDescription)))
    (when (null? module)
      (setq module *module*))
    (setq proposition (proposition description))

    (when (and (variable-arity? description)
               (> (arity queryDescription)
                  (length (io-variables description))))
      ;; we have to pad the proposition:
      (unless (or (eql? (kind proposition) :FUNCTION)
                  (eql? (kind proposition) :PREDICATE))
        (signal-proposition-error "Illegal variable arity description."))
      (setq proposition (shallow-copy-proposition proposition))
      (setf (arguments proposition) (copy (io-variables queryDescription)))
      ;; reset `description' so we'll pick up the proper variables below:
      (setq description queryDescription))
    
    (within-module module
      ;; not checking for duplicates can save a significant amount of time
      ;;    for large solution sets; here's a cheap way to figure out some
      ;;    cases where it's safe to do so; maybe there should be a user option:
      (setq dontCheckDuplicates?
        (and (named-description? description)
             (empty? (get-description-extension description FALSE))))
      (foreach solution in solutions
          as i in (interval 0 NULL)
          do (clear mapping)
             (cond ((= (mod i 10000) 9999)
                    (trace-if :UPDATE-FROM-QUERY (++ tenThousands))
                    (flush-output STANDARD-OUTPUT))
                   ((= (mod i 1000) 999)
                    (trace-if :UPDATE-FROM-QUERY ".")
                    (flush-output STANDARD-OUTPUT)
                    (setq terminateLine? TRUE)))
             (foreach var in (io-variables description)
                 as binding in (bindings solution)
                 do (insert-at mapping var binding))
             (foreach prop in (inherit-as-top-level-proposition
                               proposition mapping)
                 do (setf (descriptive? prop) FALSE)
                    (setq prop
                      (recursively-fasten-down-propositions
                       prop dontCheckDuplicates?))
                    (let ((thisUpdateMode updateMode)
                          (truthValue (truth-value solution))
                          (justification (justification solution))
                          (equivalence? (eql? (kind prop) :EQUIVALENT)))
                      (when (false-truth-value? truthValue)
                        (setq thisUpdateMode
                          (invert-update-mode thisUpdateMode)))
                      (when (default-truth-value? truthValue)
                        (setq thisUpdateMode
                          (defaultify-update-mode thisUpdateMode)))
                      (when equivalence?
                        (update-equivalence-proposition prop thisUpdateMode))
                      ;; always call this, since `update-equivalence-proposition'
                      ;; is a no-op if both arguments are skolems:
                      (update-proposition-truth-value prop thisUpdateMode)
                      (when partial?
                        ;; does update mode really matter here?
                        (setf (weight prop) (match-score solution)))
                      ;; We need to add this here to get the same automatic argument type
                      ;; assertions as we get with manual top-level assertions; however,
                      ;; just as at the top-level this is not fully correct and needs fixing:
                      (verify-argument-types-and-count prop)
                      (when (and recordJustifications?
                                 (defined? justification))
                        (let ((resultJustification
                               (new JUSTIFICATION
                                    :inference-rule :assert-from-query
                                    :proposition prop
                                    ;; TO DO: this is not quite done yet, we need to link in `proposition'
                                    ;; from the assertion pattern and also explain the substitutions somehow:
                                    :antecedents (cons justification NIL)
                                    :substitution (copy mapping)
                                    :truth-value truthValue)))
                          (add-forward-justifications prop resultJustification)))
                      (pushq propositions prop)))))
    (when terminateLine?
      (trace-if :UPDATE-FROM-QUERY EOL))
    (return (reverse propositions))))

(startup-time-progn
  (define-explanation-phrase :assert-from-query :technical
    "because it was asserted from a query")
  (define-explanation-phrase :assert-from-query :lay
    "because it was asserted from a query"))

(defun (get-query-iterator-from-command QUERY-ITERATOR) ((query CONS))
  ;; Evaluate the `query' command and return its associated query iterator.
  ;; This is slightly tricky for ASK commands, since those return truth values.
  ;; Signal an error if no query iterator could be determined (e.g., if the
  ;;    command wasn't a query).
  (let ((queryIterator (evaluate-logic-command query TRUE)))
    (when (and (not (isa? queryIterator @QUERY-ITERATOR))
               (symbol? (first query))
               (string-equal?
                (subsequence (symbol-name (cast (first query) SYMBOL)) 0 3)
                "ASK"))
      ;; kludge, since ASK commands don't return the iterator:
      (setq queryIterator *most-recent-query*))
    (when (not (isa? queryIterator @QUERY-ITERATOR))
      (signal-proposition-error "Couldn't generate a query iterator result from "
                                query))
    (return queryIterator)))

(defun (assert-from-query (CONS OF PROPOSITION)) ((query CONS)
                                                  &rest (options OBJECT))
  :documentation
  "Evaluate `query', instantiate the query proposition for each generated
solution and assert the resulting propositions.  The accepted syntax
is as follows:
	 
 (assert-from-query <query-command>
                    [:relation <relation-name>]
                    [:pattern <description-term>]
                    [:module <module-name>]
                    [:record-justifications? TRUE|FALSE])
	
<query-command> has to be a strict or partial retrieval command. If a
:relation option is supplied, <relation-name> is used as the relation
of the resulting propositions.  In this case the bindings of each
solution will become arguments to the specified relation in the order
of `query's output variables (the arities have to match).  The
:pattern option is a generalization of this mechanism that specifies
an arbitrary proposition pattern to be instantiated by the query's
solution.  In this case <description-term> has to be a SETOFALL or
KAPPA expression whose IO-variables will be bound in sequence to the
bindings of a query solution to generate the resulting proposition.
Finally, if a :module option is specified, the assertions will be
generated in that module.  Note that for this to work the relations
referenced in the query proposition or pattern have to be visible in
the module.  Also, instances will not be copied to the target module,
therefore, the resulting propositions might reference external
out-of-module objects in case they are not visible there.  If
:record-justifications? is TRUE, justifications will be recorded
for the query and the resulting justifications will be linked to
the asserted propositions.  Here are some examples:
	 
 (assert-from-query (retrieve all (foo ?x ?y)))
 (assert-from-query (retrieve all (?y ?x)
                             (exists ?z
                               (and (foo ?x ?z)
                                    (foo ?z ?y))))
                    :relation bar :module other)
 (assert-from-query
   (retrieve all (and (relation ?x) (symmetric ?x)))
   :pattern (kappa (?pred)
              (forall (?x ?y)
                (=> (holds ?pred ?x ?y)
                    (holds ?pred ?y ?x))))))
	
"
  :public? TRUE :command? TRUE :evaluate-arguments? FALSE
  (exception-case
      (let ((theOptions
             (parse-logic-command-options
              (coerce-&rest-to-cons options)
              (bquote (:module @MODULE
                       :relation @SYMBOL
                       :pattern @CONS
                       :record-justifications? @BOOLEAN))
              TRUE FALSE))
            (pattern DESCRIPTION NULL)
            (recordJustifications?
             (lookup-with-default theOptions :record-justifications? FALSE)))
        (when (defined? (lookup theOptions :pattern))
          (setq pattern (conceive-term (lookup theOptions :pattern))))
        (special ((*record-justifications?*
                   (or *record-justifications?*
                       recordJustifications?)))
          (return
            (update-propositions-from-query
             (get-query-iterator-from-command query)
             (coerce-to-description
               (first-defined pattern (lookup theOptions :relation)) NULL)
              (lookup theOptions :module)
             :ASSERT-TRUE
             recordJustifications?))))
    (LOGIC-EXCEPTION (e)
      (print-stream STANDARD-ERROR (exception-message e))))
  (return NULL))

(defun (retract-from-query (CONS OF PROPOSITION)) ((query CONS)
                                                   &rest (options OBJECT))
  :documentation
  "Evaluate `query' which has to be a strict or partial retrieval
command, instantiate the query proposition for each generated solution
and retract the resulting propositions.  See `assert-from-query' for
available command options."
  :public? TRUE :command? TRUE :evaluate-arguments? FALSE
  (exception-case
      (let ((theOptions
             (parse-logic-command-options
              (coerce-&rest-to-cons options)
              (bquote (:module @MODULE
                       :relation @SYMBOL
                       :pattern @CONS))
              TRUE FALSE))
            (queryIterator (get-query-iterator-from-command query))
            (pattern DESCRIPTION NULL))
        (when (defined? (lookup theOptions :pattern))
          (setq pattern (conceive-term (lookup theOptions :pattern))))
        (return
          (update-propositions-from-query
           queryIterator
           (coerce-to-description
             (first-defined pattern (lookup theOptions :relation)) NULL)
           (lookup theOptions :module)
           :RETRACT-TRUE
           FALSE)))
    (LOGIC-EXCEPTION (e)
      (print-stream STANDARD-ERROR (exception-message e))))
  (return NULL))


  ;;
;;;;;; "display-settings"
  ;;

(def-display-globals display-settings
  (*lazy-satellite-rules?*
   *cache-succeeded-goals?*
   *cache-failed-goals?*
   *cache-goal-quantum*
   *cache-inferable-subcollections?*
   *inferenceLevel*
   *maximum-backtracking-depth*
   *type-check-strategy*
   *duplicate-subgoal-strategy*
   *duplicate-goal-search-depth*
   *duplicate-rule-search-depth*
   *globally-closed-collections?*
   *default-maximum-depth*
   *initial-backtracking-depth*
   *iterative-deepening-mode?*
   *duplicateInstancesCacheCrossoverPoint*
   *classify-from-non-inferable-parents-only?*
   ))
#|
(display-settings)
|#

