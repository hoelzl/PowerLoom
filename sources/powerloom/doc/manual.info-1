This is manual.info, produced by makeinfo version 4.13 from manual.texi.

This file documents the knowledge representation and reasoning system.

   Copyright (C) 2010 University of Southern California, Information
Sciences Institute, 4676 Admiralty Way, Marina Del Rey, CA 90292, USA

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   PowerLoom is a registered trademark of the University of Southern
California.


File: manual.info,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

PowerLoom Manual
****************

This document describes the PowerLoom knowledge representation and
reasoning system.  PowerLoom is the successor to the Loom knowledge
representation system. It provides a language and environment for
constructing intelligent applications.

* Menu:

* Introduction::
* Conceptual Framework::
* Annotated Example::
* Communicating with PowerLoom::
* Commands::
* PowerLoom API::
* Built-In Relations::
* PowerLoom GUI::
* Ontosaurus::
* Installation::
* Miscellaneous::
* Glossary::
* PowerLoom Grammar::
* Function Index::
* Variable Index::
* Concept Index::


File: manual.info,  Node: Introduction,  Next: Conceptual Framework,  Prev: Top,  Up: Top

1 Introduction
**************

This document describes the PowerLoom knowledge representation and
reasoning system. PowerLoom is the successor to the Loom knowledge
representation system. It provides a language and environment for
constructing intelligent, knowledge-based applications. PowerLoom uses a
fully expressive, logic-based representation language (a variant of
KIF). It uses a natural deduction inference engine that combines forward
and backward chaining to derive what logically follows from the facts
and rules asserted in the knowledge base.  While PowerLoom is not a
description logic, it does have a description classifier which uses
technology derived from the Loom classifier to classify descriptions
expressed in full first order predicate calculus. PowerLoom uses modules
as a structuring device for knowledge bases, and ultra-lightweight
worlds to support hypothetical reasoning.

   To implement PowerLoom we developed a new programming language called
STELLA, which is a Strongly Typed, Lisp-like LAnguage that can be
translated into Lisp, Java, and C++. STELLA tries to preserve those
features of Lisp that facilitate symbolic programming and rapid
prototyping, while still allowing translation into readable as well as
efficient Java and C++ code. Because PowerLoom in written STELLA, we are
able to deliver it in all three languages.

* Menu:

* Powerloom Features::
* Powerloom History::
* Running PowerLoom::


File: manual.info,  Node: Powerloom Features,  Next: Powerloom History,  Prev: Introduction,  Up: Introduction

1.1 Powerloom Features
======================

PowerLoom is a full-function, logic-based knowledge representation and
reasoning system, that supports all aspects of knowledge-based
applications.  It allows the representation of complex knowledge in a
declarative, logic-based language, supports a variety of reasoning
mechanisms to make implicit knowledge explicit, has a powerful query
engine to retrieve what has been asserted and logically follows from
the KB, provides file-based and RDBMS-based storage of knowledge bases,
has a context and module system to effectively partition and organize
large knowledge bases, and has an extensive API in multiple language to
allow easy and effective integration into knowledge-based applications.

   PowerLoom's focus is on expressivity of its representation language
while still providing good scalability to large ontologies and
knowledge bases.  In general, PowerLoom takes a _pragmatic stance_
where usability is more important than theoretical "neatness" and
expressivity is more important than inferential completeness.  From our
point of view, there is nothing magical about logic, it is just another
programming language (with difficult to understand semantics), so it
should help you to solve the task at hand as best as possible and not
hinder you by forcing you to work around restrictions of the logic.  Of
course, PowerLoom cannot completely escape the straight-jacket of
logic, but it tries to push the boundaries as much as possible.

   * *Representation language*: PowerLoom uses the language of
     predicate logic to represent knowledge.  The syntax is KIF (the
     Knowledge Interchange Format) which is one of the supported
     syntaxes of the upcoming Common Logic standard.  PowerLoom adds a
     variety of convenient definitional constructs as well as
     extensions beyond traditional first-order logic such as type-level
     predicates, relation variables in `holds' sentences, modal
     assertions (sentences about sentences), cross-context assertions
     via `ist' to represent lifting axioms, defaults (still
     experimental), and others.  The goal is to provide a highly
     expressive representation language, since KR failures or awkward
     models are often due to "we could not express X in language L".
     The theoretical undecidability and intractability of such an
     expressive language is counteracted by providing limited,
     "pragmatic" reasoning services that cover commonly encountered
     situations.  For example, reasoning with second-order sentences
     that quantify over relations is undecidable and leads to very
     unfocused search; however, such sentences are very useful to
     describe axiom schemata that can be cheaply run in forward
     direction to create regular first-order rules (in a process not
     unlike macro expansion).

   * *Reasoning*: The primary reasoning mechanism is logical deduction
     which infers statements that logically follow from the asserted
     statements and rules.  Such statements can be asked about using
     PowerLoom's query commands `ask' (for true/false questions) and
     `retrieve' (for Wh-questions).  PowerLoom uses a natural deduction
     system to answer queries but also has a large number of specialized
     reasoning procedures to efficiently handle concept and relation
     hierarchies, sets, frame predicates, search control, etc.  The
     specialist architecture is extensible to allow users to plug-in
     their own reasoners or computed predicates.  PowerLoom also
     supports hypothetical reasoning, equality reasoning, arithmetic
     and reasoning with inequalities.  While *PowerLoom is not a
     description logic*, it does have a classifier that can classify
     concept and relation hierarchies and instances defined using the
     full expressive power of first-order logic.  The classifier does
     not provide any additional inferences, but allows PowerLoom to
     eagerly pre-compute and cache subsumption relationships which can
     then be utilized over and over without having to re-derive them.
     PowerLoom also provides some experimental abductive and
     partial-match reasoning to handle incomplete knowledge bases.

   * *Meta-representation and reasoning*: Concepts, relations,
     contexts, rules, queries, etc. are all first-class citizens in the
     domain of discourse.  Therefore, they can have assertions made
     about them as well as reasoned about.  This mechanism is commonly
     used by the system itself, e.g., to assert that a relation is
     single valued or transitive, that a concept is closed, etc.

   * *Explanation*: PowerLoom can explain its reasoning by recording
     inference trees and then rendering those into human-understandable
     explanations.  PowerLoom also has an experimental "WhyNot"
     facility to explain inference failures where no successful proof
     tree was found.

   * *Contexts and modules*: Contexts and modules provide separate name
     and assertion spaces with inheritance which implement a powerful
     structuring mechanism for KBs.  Contexts allow encapsulation and
     organization of knowledge, efficient inference (by separating
     irrelevant knowledge or by separating ontologies and assertion
     spaces from volatile inference worlds), truth maintenance (via
     inference cache contexts), scenarios and hypothetical reasoning,
     non-monotonic overrides in sub-contexts, etc.  PowerLoom's context
     mechanism is built-in at a very low level using a very efficient
     and light-weight implementation for maximum performance.

   * *Open and closed-world*: By default, PowerLoom makes an open-world
     assumption and returns `unknown' if it cannot prove or disprove a
     question.  However, concepts and relations can be selectively
     marked as closed to support selective closed-world reasoning.
     PowerLoom also has a `fail' predicate (in addition to true
     negation via `not') to implement closed-world negation-as-failure
     which can be useful in certain situations.

   * *Knowledge base management*: PowerLoom supports incremental
     monotonic and non-monotonic updates that extend or
     non-monotonically change the assertion base.  In PowerLoom one can
     effectively interleave definitions, re-definitions, assertions and
     retractions with retrieval and inference without having to reload
     large knowledge bases from scratch after every change.  Truth
     maintenance of cached inference results that might have been
     invalidated by updates is done via inference cache contexts.
     After a knowledge base has been loaded and changed by some
     updates, the changed state can be saved out to a file or an
     (experimental) persistent store built on top of a relational
     database.

   * *Scalability*: Despite its emphasis on expressive representation
     which usually has to be paid for with intractable and expensive
     reasoning procedures, PowerLoom is very scalable and comes with a
     variety of mechanisms to control search and handle large
     ontologies and knowledge bases.  For example, PowerLoom's
     reasoning specialists handle a wide variety of inferencing very
     effectively without having to go through any rule chaining.
     Search control annotations can be used to help the inference
     engine use rules more effectively.  For example, depending on
     fan-out, certain rules are run more effectively forwards than
     backwards (or vice versa), and a KB developer can tell the system
     when that's the case.  PowerLoom has resource-bounded depth-first
     or iterative deepening search which provides an any-time inference
     scheme for situations where resources are limited.  A
     "just-in-time" forward inference engine elaborates the assertion
     neighborhood of objects touched upon by inference.  This allows
     focused forward inference relevant to current inference goals,
     without having to run forward inference over a potentially very
     large KB to completion.  PowerLoom has a static and dynamic query
     optimizer, that, similar to optimizers used in database systems,
     orders conjunctive goals based on relation extension sizes and
     rule fan-out to minimize intermediate result sets and chaining.
     The dynamic optimizer does this for each conjunctive subgoal based
     on actual bindings.  Given this mechanism it is possible to run
     PowerLoom queries that return 100,000's of solutions.  PowerLoom
     also has a powerful relational database interface that allows it to
     utilize the power of databases for handling large assertion bases
     (soon to be released).  One application of this PowerLoom/RDBMS
     integration is used with ISI's Omega ontology.  It is also a
     crucial part of our KOJAK Link Discovery System.

   * *Tools and APIs*: PowerLoom has a host of associated tools and
     APIs (not all of which have been released yet).  It comes with an
     interactive command-line interface which is useful for developing
     ontologies and knowledge bases, an extensive programmatic interface
     called PLI with Lisp, C++ and Java bindings, and a Lisp-based Loom
     API to load legacy Loom KBs.  Starting with PowerLoom version 4.0
     Ontosaurus and a Java-based GUI have been released as part of
     PowerLoom.  Ontosaurus is a Web-based KB browser that dynamically
     generates HTML pages viewable in a standard Web browser.  The
     Java-based GUI provides a browse/edit/query environment for
     developing KBs.  The GUI uses a client/server architecture and can
     be used embedded or standalone against a PowerLoom server that
     might be hosted - among other options - in a Web server such as
     Tomcat.  A soon-to-be-released Protege plug-in allows export of
     Protege ontologies into PowerLoom format.  OntoMorph is a
     translation system that supports writing of KB translators and
     importers, e.g., to import ontologies written in other languages
     (for example, Flogic).

   * *Initial Semantic Web support*: Given PowerLoom's emphasis on
     expressive representation, we have not yet focused much on
     Semantic Web languages such as OWL, which restricts expressivity
     to gain decidability.  OWL also has other limitations such as
     restriction to binary relations and lack of support for arithmetic
     and inequalities which limits its usefulness for practical
     applications.  Nevertheless, given that people are starting to use
     these languages more and more, we've developed some initial import
     translators for RDF/RDFS and OWL which once they mature we will
     release as part of PowerLoom.

   * *Portability and integration*: Since PowerLoom is implemented in
     STELLA, it is available in Lisp, C++ and Java implementations and
     highly portable.  PowerLoom can be run in each of these languages
     under Unix (such as Linux, SunOS or MacOS X) as well as Windows
     2000 and XP.  Due to the availability in three main-stream
     languages, it can easily be integrated programmatically with most
     application software without having to use some complex
     integration framework.  The C++ and Java libraries for PowerLoom
     are also quite small and light-weight, for example, the necessary
     STELLA and PowerLoom jar files of the Java implementation are less
     than 2.5 Meg in size.


File: manual.info,  Node: Powerloom History,  Next: Running PowerLoom,  Prev: Powerloom Features,  Up: Introduction

1.2 Powerloom History
=====================

<to be written>


File: manual.info,  Node: Running PowerLoom,  Prev: Powerloom History,  Up: Introduction

1.3 Running PowerLoom
=====================

The easiest way to run PowerLoom on a variety of platforms is to use the
`powerloom' or `powerloom.bat' scripts in the top-level PowerLoom
directory.  If you have Java installed on your system, these scripts
should run out of the box without any further installation
requirements.  If you want to use the Lisp version of PowerLoom, simply
load the file `load-powerloom.lisp' into your Common Lisp.  If you want
to use the C++ version, you have to compile it first.  See the
Installation section in this manual for more details on how to install
the Lisp, C++ or Java version of PowerLoom *Note Installation::.

   Under Unix or MacOS X, open a shell window somewhere to run
PowerLoom.  For example,

     % powerloom
     Running Java version of PowerLoom...
     Initializing STELLA...
     Initializing PowerLoom...

         Welcome to PowerLoom 4.0.0

     Copyright (C) USC Information Sciences Institute, 1997-2010.
     PowerLoom comes with ABSOLUTELY NO WARRANTY!
     Type `(copyright)' for detailed copyright information.
     Type `(help)' for a list of available commands.
     Type `(demo)' for a list of example applications.
     Type `bye', `exit', `halt', `quit', or `stop', to exit.

     PL-USER |=

   Under Windows, you can do something similar by running a Command
Prompt window and executing the `powerloom.bat' script.  You can also
simply double click on the script which will run PowerLoom and bring up
a Command Prompt window for you.

   Once the `|=' prompt has come up you can type in PowerLoom commands
and see their results.  The string preceding the prompt indicates the
"current module" relative to which commands are interpreted.  For
example, type the `demo' command to see a menu of available demos.
Step through one or more of them to get familiar with PowerLoom.

   Starting with version 4.0 PowerLoom also ships with an experimental
PowerLoom GUI and the Ontosaurus browser which can additionally be used
to edit and browse knowledge bases.

* Menu:

* Command-Line Options::


File: manual.info,  Node: Command-Line Options,  Prev: Running PowerLoom,  Up: Running PowerLoom

1.3.1 Command-Line Options
--------------------------

There are a few command-line options that can be supplied to the
`powerloom' script.

     powerloom [--c++|--java|--gui|--gui-only]
               [{-e|--eval} STELLA-EXPRESSION]
               [--batch]
               [--help]
               [more options...]

   The first optional argument determines what version to run if both
C++ and Java versions are installed.  If no specific version is
specified, the C++ version will be run if it is installed, otherwise,
the Java version will be run (*note PowerLoom GUI:: for a description
of the GUI options).

`--eval STELLA-EXPRESSION'
`-e STELLA-EXPRESSION'
     Specifies a STELLA expression that should be run just before the
     PowerLoom command loop gets initialized.  This expression has to
     be a known command (such as the various PowerLoom commands), since
     the STELLA evaluator cannot (yet) evaluate arbitrary STELLA code.
     For example, `powerloom -e '(demo "equations" FALSE)'' will run a
     particular demo before anything else.  You will need to
     appropriately quote special characters interpreted by the shell or
     the Command Prompt window.

`--batch'
     Runs PowerLoom in batch mode without running an interactive command
     loop.  This can be useful in conjunction with the `--eval' option
     to execute a single command or load a PowerLoom script via the
     `load' command.

`--help'
     Prints a list of all currently supported command-line options.


File: manual.info,  Node: Conceptual Framework,  Next: Annotated Example,  Prev: Introduction,  Up: Top

2 Conceptual Framework
**********************

This chapter presents the fundamental conceptual building blocks that
are used to construct PowerLoom knowledge bases. The PowerLoom language
is based on KIF, which provides a syntax and a declarative semantics
for first-order predicate calculus expressions. KIF is a proposed ANSII
standard language used by a variety of knowledge representation
systems. Practical knowledge representation systems necessarily add a
procedural semantics that defines the interpretation of knowledge
structures when definitions and facts are retracted or modified.  This
chapter assumes that the reader has some familiarity with the semantics
of the predicate calculus, and instead focuses on aspects of the
semantics that go beyond the traditional (KIF) semantics.

   A PowerLoom knowledge base is constructed by first defining the
terminology (concepts and relations) for a domain, and then asserting
additional rules and facts about that domain. Facts can be asserted and
later retracted, so the answers returned by queries may change over
time. The knowledge structures are organized into logical containers
called "modules". The division into modules means that in general,
facts are not asserted globally, but instead hold only within a specific
context. For example, a logical proposition may evaluate as true within
one module, and evaluate as false within a different one.

   The discussion below uses some examples of actual PowerLoom syntax
to illustrate certain points.  However, we gloss over the fine points
of syntax, and instead focus on semantic issues.  The next chapter
reverses that emphasis, and presents a series of examples that
illustrate the breadth of syntactic constructs implemented for the
PowerLoom language.

* Menu:

* Terms and Propositions::
* Relation Definitions::
* Truth Values::
* Modules::


File: manual.info,  Node: Terms and Propositions,  Next: Relation Definitions,  Prev: Conceptual Framework,  Up: Conceptual Framework

2.1 Terms and Propositions
==========================

A knowledge base attempts to capture in abstract (machine interpretable)
form a useful representation of a physical or virtual world. The
entities in that world are modeled in the knowledge base by objects we
call _ terms_. Examples of terms are "Georgia" (denoting the U.S.,
state), "BenjaminFranklin" (denoting the historical person by that
name), the number three, the string "abc", and the concept "Person".
Unlike objects in an object-oriented programming language, the terms in
a PowerLoom knowledge base usually have distinct names (unless there are
sufficiently many that naming them all becomes impractical).

   Terms are categorized or related to one another by objects called
_relations_.  Examples of relations are "has age", "greater than", "is
married to", "plus".  Concepts such as "Person", "State", "Company",
and "Number" are considered a subcategory of relations.

   A _proposition_ is a logical sentence that has an associated truth
value. Examples are "Ben Franklin is a person", "Bill is married to
Hillary", "Two plus three equals six" (which is false). PowerLoom
follows KIF in adopting a prefix notation for the predicate calculus to
represent propositions. Possible representations of the three
propositions just mentioned are `(person ben-franklin)', `(married-to
Bill Hillary)', and `(= (+ 2 3) 6)'. These three propositions make
reference to relations named `person', `married-to', ` plus', and `='.

   The predicate calculus constructs complex sentences out of simpler
ones using the logical connectives `and', `or', `not', `<=', `=>', and
`<=>', and the quantifiers `exists' and `forall'. Some examples are
`(not (crook richard))' "Richard is not a crook", and `(forall ?p (=>
(person ?p) (exists ?m (has-mother ?p ?m))))' "every person has a
mother".


File: manual.info,  Node: Relation Definitions,  Next: Truth Values,  Prev: Terms and Propositions,  Up: Conceptual Framework

2.2 Definitions
===============

PowerLoom requires that relations are defined before they are used
within assertions and queries.  The commands `defconcept',
`defrelation', and `deffunction' are used to define concepts,
relations, and functions, respectively.  The definitions

     (defconcept person)
     (defrelation married-to ((?p1 person) (?p2 person))
     (deffunction + ((?n1 number) (?n2 number)) :-> (?sum number))

   declare that `person' is a concept, that `married-to' is a binary
relation that takes arguments of type `person', and that `+' is a
function that takes arguments of type `number'(1).  The requirement
that relations be defined before they are referenced can be
inconvenient at times.  For example, suppose we wish to define `parent'
as "a person who is the parent of another person" and we also wish to
state that the first argument to the `parent-of' relation has type
`parent':

     (defconcept parent (?p)
       :<=> (and (person ?p) (exists ?c (parent-of ?p ?c))))
     (defrelation parent-of ((?p parent) (?c person)))

   In this example, the first reference to `parent-of' occurs before it
is defined. PowerLoom permits circular references such as these as long
as they occur within definitions. It does so by deferring evaluation of
rules that occur within definitions. Here is a specification that is
logically equivalent, but is not legal because the `parent-of' relation
appears in an assertion before it is defined:

     (defconcept parent (?p))
     (assert (forall (?p) (<=> (parent ?p)
                               (and (person ?p) (exists ?c (parent-of ?p ?c))))))
     (defrelation parent-of ((?p parent) (?c person)))

   So when does the rule inside of the first `parent' definition get
defined?  All axioms (facts and rules) that appear within the boundaries
of a definition are evaluated just prior to the next occurrence of a
PowerLoom query.  Hence, in the example above where the rule occurred
_within_ the definition, there was no error because evaluation of that
rule occured sometime after the second definition (which defines the
otherwise problematic reference to `parent-of').

   One will sometimes see the command `(process-definitions)' appearing
at intervals within a file containing PowerLoom commands. Each such
appearance forces the definitions that preceed it to be fully-evaluated.
This is done so that the interval between a definition and its
evaluation not be too great; it can get confusing if PowerLoom reports
a semantic violation long after the origin of the conflict.

   PowerLoom definitions commands (those prefixed by "def") have one
other semantic property that distinguishes them from ordinary
assertions. Any axioms that appear within a definition are tied to that
definition.  If a definition is modified and then reevaluated, axioms
that don't survive the modification are retracted.  For example,
suppose we evaluate the following two commands.

     (defrelation parent-of ((?p1 person) (?p2 person))
       :=> (relative-of ?p1 ?p2))
     (defrelation parent-of ((?p1 person) (?p2 person)))

   The first definition defines `person' as a binary relation, and also
states a rule that "`parent-of' implies `relative-of'".  The second
definitions erases that rule, i.e., the cumulative effect is as if the
first definition did not appear.  In contrast, consider the following
commands:

     (defrelation parent-of ((?p1 person) (?p2 person)))
     (assert (=> (parent-of ?p1 ?p2) (relative-of ?p1 ?p2)))
     (defrelation parent-of ((?p1 person) (?p2 person)))

   The assertion in this latter sequence is logically equivalent to the
axiom introduced by the `:=>' keyword in the former sequence.  However,
at the end of this sequence, the "`parent-of' implies `relative-of'"
rule is still in effect, since it appeared on its own, outside of a
definition.

   ---------- Footnotes ----------

   (1) The function `+' and the concept `number' are predefined in
PowerLoom.


File: manual.info,  Node: Truth Values,  Next: Modules,  Prev: Relation Definitions,  Up: Conceptual Framework

2.3 Truth Values
================

A PowerLoom proposition is tagged with a truth value that has one of
five different settings--`true', `false', `default-true',
`default-false', or `unknown'. The most common setting is `true'; when
we make an assertion as in `(assert (Person Bill))', the proposition
`(Person Bill)' is assigned the truth value `true'. To assign the value
`false' to a proposition, one asserts that it is not true, e.g.,
`(assert (not (crook Richard)))'. The command `presume' is used to
assign a proposition the value `default-true', as in `(presume
(weather-in Los-Angeles Sunny))'. Presuming a negated proposition
assigns it the value `default-false'.

   The assignment of a truth value to a proposition via `assert' or
`presume' can upgrade the "strength" of a proposition, but it cannot
downgrade it. Hence, if a proposition currently has the value
`unknown', then it may be assigned any of the other four values. If the
value is `default-true' or `default-false', an assertion that assigns
the value `true' or `false' will overwrite the existing value. However,
if the truth value of a proposition is either `true' or `false',
assigning it the value `default-true' or `default-false' will have no
effect.

   If a proposition is asserted to be `true' and subsequently is
asserted to be `false' (or vice-versa), a _clash_ (or contradiction)
results. When a clash is detected by PowerLoom, a `clash-exception' is
thrown. The system's default behavior is for the exception to be caught
and ignored, with the result that an assertion that would otherwise
cause a clash never takes effect. Applications that execute commands
slightly below the top-level (i.e., below the clash exception catcher)
can catch the exception themselves and perform a specialized response.
PowerLoom's proof-by-contradiction specialist catches clashes to
determine that a contradiction has occurred.

   If a user or application wants to assign a proposition a truth value
that isn't stronger than the current value, it must first `retract' the
current value.  The PowerLoom `retract' operator has the effect of
undoing a prior assertion.  For example, if we assert that Mary is a
parent of Fred, and then retract that assertion, the value of the
proposition `(parent-of Mary Fred)' becomes `unknown'.  The proposition
can then be assigned any other truth value.

   We should note that executing a retraction does not necessarily
cause a proposition to cease being true.  Consider the following
sequence:

     (defconcept Person)
     (defconcept Employee (?e)
       :=> (Person ?e))
     (assert (Person Mary))
     (assert (Employee Mary))
     (retract (Person Mary))

   If we now ask PowerLoom whether or not Mary is a person, the answer
will be yes (TRUE) because Mary is asserted to be an employee, and
membership in `employee' implies membership in `person'.  In other
words, although the direct assertion that Mary is a person is not
present in the knowledge base, a logical proof exists that the
proposition "Mary is a person" is true.


File: manual.info,  Node: Modules,  Prev: Truth Values,  Up: Conceptual Framework

2.4 Modules
===========

The knowledge loaded into an executing PowerLoom system is divided into
logical partitions called "modules".  The modules are arranged into a
hierarchy; knowledge inherits down the hierarchy from parents to
children.  A convenient way to organize knowledge is to put
definitional knowledge higher up in the module hierarchy, and factual
knowledge lower down.  For example, suppose we want to build a
knowledge base that defines a business domain, and include a
substantial number of facts about individual companies. We might use
one or a few modules to define terminology that relates to the business
domain, and then places the set of facts about each company in its own
module.  If we were querying the knowledge base about one or a few
companies, it would not be necessary to load the modules for the
remaining companies into the system.

   Facts asserted within a module are not visible in sibling modules,
or in ancestor modules. Thus, if we enter into PowerLoom an assertion
that"Georgia is a state", we are not asserting that Georgia is a state
in all possible worlds, but that, from the vantage point of the current
module and those modules below, it is the case that Georgia is a state.
If we want the fact that Georgia is a state to be recognized as true in
many or most other modules, then we should make our assertion in a
module that is relatively high up in the hierarchy, so that is visible
to (inherited by) the other modules.

   The inheritance of facts is _not monotonic_--a child module can
retract or override facts inherited from its ancestors. For example,
suppose we have two modules, called `above' and `below' such that the
`below' module is below (inherits from) the `above' module. Next,
suppose we make an assertion within the `above' module that "Joel is a
duck", and then we shift to the `below' module and retract the
proposition that "Joel is a duck". From the vantage point of the
`below' module, if we now ask if Joel is a duck, we will get back the
value `unknown'.  However, if we switch to the `above' module and ask
the same question, we get back the answer `true' This occurs because
the effect of the retraction operation that was applied to the `below'
module is not "visible" to modules above it (or to any sibling
modules). Hence, when module hierarchies are involved, it is
oversimplifying to state that a retraction has the effect of erasing a
prior assertion.

   The PowerLoom execution process maintains a pointer to the current
module, and all asserions, queries, etc. are made relative to that
module.  Hence, when we talk about "switching" from one module to
another, we are speaking literally--a `change-module' command (or one
of its equivalents) is invoked to switch from one module to another.
(1)

   PowerLoom comes with some modules already built-in. The module named
`PL-KERNEL' contains a set of general-purpose concept and relation
definitions that collectively form the foundation for constructing
application-specific knowledge bases. PowerLoom attaches specialized
reasoners to many of the relations in `PL-KERNEL'. The command
interpreter starts up in a module named `PL-USER'. That module is
initially empty, and is intended as a convenient place to experiment
with PowerLoom.

   ---------- Footnotes ----------

   (1) Many of the Powerloom API procedures take a module argument that
causes a temporary switch to a different module within the scope of
that procedure.


File: manual.info,  Node: Annotated Example,  Next: Communicating with PowerLoom,  Prev: Conceptual Framework,  Up: Top

3 Annotated Example
*******************

The section presents a small example of a PowerLoom knowledge base.  It
introduces the fundamental PowerLoom modelling concepts and illustrates
the syntax of basic PowerLoom declarations, assertions, and commands.
This section can be read stand-alone, but readers who intend to use
PowerLoom to create their own models are encouraged to load the demo
file *???*, and run the examples "live".

   The conceptual terms introduced in this section include modules,
concepts, relations, functions, instances, propositions, assertions,
queries, retraction, positive and negative facts, clipping, rules, and
contexts.

* Menu:

* Using Modules::
* Concepts::
* Relations::
* Relation Hierarchies::
* Functions::
* Defined Concepts::
* Negation and Open and Closed World Semantics::
* Retraction::
* Clipping of Values::
* Rule-based Inference::
* Explanation::
* Contexts and Modules::
* Equality Reasoning::
* Classification::
* Truth Maintenance::
* Inference Control::
* Keyword Axioms::
* Cardinality/Type Reasoning with Frame Predicates::
* Loom-to-PowerLoom::
* Deviations from KIF::
* Differences from Loom::
* Defaults::
* Sets::


File: manual.info,  Node: Using Modules,  Next: Concepts,  Prev: Annotated Example,  Up: Annotated Example

3.1 Using Modules
=================

We begin by creating a PowerLoom "module", which is a logical container
that holds the term definitions, rules, facts, etc.  that make up all
or a portion of a domain model.  We will call our module `business'.
The `defmodule' command defines a new module.  The `:includes' option
within the `defmodule' tells PowerLoom that the `business' module
inherits all definitions and assertions present in the `PL-USER'
module, or in ancestor modules inherited by the `PL-USER' module.  In
particular, by inheriting `PL-USER', we indirectly inherit the
`PL-KERNEL' module that contains all of the built-in concepts and
relations.  The `in-module' command tells the PowerLoom system to make
`BUSINESS' the current module.  Until the current module is changed
again, all new introductions of terms and facts will be placed in the
`business' module.

     (defmodule "BUSINESS"
       :includes ("PL-USER"))
     (in-module "BUSINESS")

   The basic building blocks of a model are its concepts, relations, and
instances.(1)  A concept defines classes/categories of entities that
populate the domain model. A relation defines attributes and
relationships that allow the declaration of facts about an entity.
Instances are members of concepts. They appear as arguments to
propositional assertions.

   ---------- Footnotes ----------

   (1)  PowerLoom modules are case-insensitive by default.  This means,
for example, that a logical constant named "Foo" may be referenced by
any of the symbols 'FOO', 'foo', 'foO' etc.  You may create
case-sensitive modules, but if you do so, when inside that module all
PowerLoom commands and other symbols such as AND, EXISTS, etc.  will
need to be referred to using uppercase names, since no automatic
case-conversion will take place.


File: manual.info,  Node: Concepts,  Next: Relations,  Prev: Using Modules,  Up: Annotated Example

3.2 Concepts
============

Concepts are defined using the `defconcept' command.  Here we define
the concepts `company' and `corporation':

     (defconcept company)
     (defconcept corporation (?c company))

   The first definition tells the system that `company' is a concept
(in the `business' module).  The second definition defines a concept
`corporation'.  The type declaration `(?c company)' indicates that
`corporation' is a subconcept of `company', i.e., all instances of
`corporation' are also instances of `company'.  Let us now create a
couple of companies:

     (assert (company ACME-cleaners))
     (assert (corporation megasoft))

   These two assertions create two new entities denoted by the terms
`ACME-cleaners' and `megasoft'.  Both of these entities are members of
the concept `company'.  `megasoft' is also a member of the concept
`corporation'.  We can test this by executing some PowerLoom queries:

     (retrieve all ?x (company ?x))
     =>
     There are 2 solutions:
       #1: ?X=ACME-CLEANERS
       #2: ?X=MEGASOFT

     (retrieve all ?x (corporation ?x))
     =>
     There is 1 solution:
       #1: ?X=MEGASOFT


File: manual.info,  Node: Relations,  Next: Relation Hierarchies,  Prev: Concepts,  Up: Annotated Example

3.3 Relations
=============

So far, our two companies aren't very interesting. In order to say more
about them, we can define some relations and functions using the
declarations `defrelation' and `deffunction':

     (defrelation company-name ((?c company) (?name STRING)))

   This declaration defines a binary relation `company-name'.  The
first value in a `company-name' tuple must be an instance of type
`company', while the second value must be a string.  We can now give
our companies names, using the command `assert':

     (assert (company-name ACME-cleaners "ACME Cleaners, LTD"))
     (assert (company-name megasoft "MegaSoft, Inc."))

   We can retrieve pairs of companies and their names with the following
query (note that we omitted the optional retrieval variables in which
case they are determined by collecting the free variables in the query
expression):

     (retrieve all (company-name ?x ?y))
     =>
     There are 2 solutions:
       #1: ?X=MEGASOFT, ?Y="MegaSoft, Inc."
       #2: ?X=ACME-CLEANERS, ?Y="ACME Cleaners, LTD"

   Using retrieval variables is useful if we want to order the result
columns in a certain way, for example:

     (retrieve all (?y ?x) (company-name ?x ?y))
     =>
     There are 2 solutions:
       #1: ?Y="MegaSoft, Inc.", ?X=MEGASOFT
       #2: ?Y="ACME Cleaners, LTD", ?X=ACME-CLEANERS


File: manual.info,  Node: Relation Hierarchies,  Next: Functions,  Prev: Relations,  Up: Annotated Example

3.4 Relation Hierarchies
========================

PowerLoom permits the specification of hierarchies both for concepts and
relations.  Previously , we defined a small concept hierarchy with
`company' on top and `corporation' below it.  We now define a
subrelation of the relation `company-name' called
`fictitious-business-name':

     (defrelation fictitious-business-name ((?c company) (?name STRING))
       :=> (company-name ?c ?name))

   PowerLoom defines a subconcept/subrelation relationship between a
pair of concepts or a pair of relations by asserting an "implication"
relation between them.  The above implication expands into the assertion
"for all values of ?c and ?name, if the `fictitious-business-name'
relation holds for ?c and?name, then the `company-name' relation also
holds for ?c and ?name".  This is equivalent to the assertion

     (forall (?c ?name) (=> (fictitious-business-name ?c ?name)
                            (company-name ?c ?name)))

Since implication relationships occur very commonly, PowerLoom provides
several syntactic shortcuts for defining them.  We have seen one such
shortcut earlier; our definition of `corporation' included the clause
"`(c ?company)'", which specified that `corporation' is a subconcept of
`company'.  In our definition of `fictitious-business-name', the keyword
`:=>' introduces a similar shortcut, which tells us that
`fictitious-business-name' is a subrelation of `company-name'.  Let us
assert a fictious business name for MegaSoft:

     (assert (fictitious-business-name megasoft "MegaSoft"))

   If we query for the company names of MegaSoft, we get two names, one
of them asserted directly, and one of them infered by the subrelation
rule:

     (retrieve all (company-name megasoft ?x))
     =>
     There are 2 solutions:
       #1: ?X="MegaSoft, Inc."
       #2: ?X="MegaSoft"


File: manual.info,  Node: Functions,  Next: Defined Concepts,  Prev: Relation Hierarchies,  Up: Annotated Example

3.5 Functions
=============

This illustrates another point: A PowerLoom relation is by default
"multi-valued", which in the case of a binary relation means that a
single first value can be mapped by the relation to more than one second
value. In the present case, our model permits a `company' entity to
have more than one `company-name'. If a (binary) relation always maps
its first argument to exactly one value (i.e., if it it "single-valued")
we can specify it as a `function' instead of a `relation'.  For
example, we can use a function to indicate the number of employees for a
company:

     (deffunction number-of-employees ((?c company)) :-> (?n INTEGER))

   When defining a function, all arguments but the last appear just as
they do for a relation. The last argument (and its type) appears by
itself following the keyword `:->'. Defining a single-valued relation
as a function allows us to refer to it using a functional syntax within
a logical sentence, as in the following:

     (assert (= (number-of-employees ACME-cleaners) 8))
     (assert (= (number-of-employees megasoft) 10000))

   The functional syntax often results in shorter expressions than
equivalents that use relational syntax.  For example to retrieve all
companies with fewer than 50 employees, we can simply write:

     (retrieve all (and (company ?x) (< (number-of-employees ?x) 50)))
     =>
     There is 1 solution:
       #1: ?X=ACME-CLEANERS

   Using the syntax for relations, the same query would require the
introduction of an existential quantifier, as in:

     (retrieve all (and (company ?x)
                        (exists ?n
                          (and (number-of-employees ?x ?n)
                               (< ?n 50)))))
     =>
     There is 1 solution:
       #1: ?X=ACME-CLEANERS

   To repeat ourselves slightly, Powerloom allows users the choice of
using either relational or functional syntax when using a function in
predicate position. For example, if `f' is a function, then the
expressions `(f ?x ?y)' and `(= (f ?x) ?y)'  are equivalent.


File: manual.info,  Node: Defined Concepts,  Next: Negation and Open and Closed World Semantics,  Prev: Functions,  Up: Annotated Example

3.6 Defined Concepts
====================

If we find ourselves writing the same query (or subexpression)
repeatedly, we may wish to define a name for the concept embodying that
expression.  For example, below we define the term `small-company' to
represent the class of all companies with fewer than 50 employees:

     (defconcept small-company ((?c company))
       :<=> (and (Company ?c)
                 (< (number-of-employees ?c) 50)))

   Notice that we have used a new keyword, `:<=>'. This keyword defines
a bidirectional implication called "if-and-only-if".  Formally it is
equivalent to the following pair of assertions:

     (assert (forall ?c (=> (and (Company ?c)
                                 (< (number-of-employees ?c) 50))
                            (small-company ?c))))
     (assert (forall ?c (=> (small-company ?c)
                            (and (Company ?c)
                                 (< (number-of-employees ?c) 50)))))

   In other words, the `:<=>' keyword is a shortcut for an assertion
that uses the `<=>' relation, which itself is a shortcut representing
the conjunction of two single arrow implications. For example, `(<=> P
Q)' is equivalent to `(and (<= P Q) (=> P Q))', where the `<=' relation
is defined to be the inverse of the relation `=>'.

   Its not necessary that we exactly specify the number of employees in
a company.  Below, all we know about ZZ Productions is that they have
fewer than 20 employees:

     (assert (and (company zz-productions)
                  (< (number-of-employees zz-productions) 20)))

These facts are sufficient to classify ZZ Productions as a small
business:

     (retrieve all (small-company ?x))
     =>
     There are 2 solutions:
       #1: ?X=ZZ-PRODUCTIONS
       #2: ?X=ACME-CLEANERS


File: manual.info,  Node: Negation and Open and Closed World Semantics,  Next: Retraction,  Prev: Defined Concepts,  Up: Annotated Example

3.7 Negation and Open and Closed World Semantics
================================================

PowerLoom implements a three-valued logic--the truth value of each
proposition entered into a PowerLoom knowledge base is recorded as
being either true, false, or unknown.(1) Many other systems (e.g.,
relational DBMSs) implement a two-valued logic, wherein if a fact is
not asserted to be true, it is assumed to be false.  The PowerLoom
command `ask' returns one of three (five) values: `true' if it can
prove the truth of a proposition, `false' if it can _easily_ prove the
falsity of a proposition(2) and otherwise it returns `unknown'. (The
values `default-true' and `default-false' are also possible if defaults
are used).

   Below, PowerLoom knows nothing about a newly-introduced concept
`s-corporation', so `ask' returns `unknown' to both a positive query
and its negation:

     (defconcept s-corporation (?c corporation))
     (ask (s-corporation zz-productions))
     =>
     UNKNOWN
     (ask (not (s-corporation zz-productions)))
     =>
     UNKNOWN

   If we assert that ZZ Productions is not an S-corporation, then
PowerLoom knows that the proposition in question is false:

     (assert (not (s-corporation zz-productions)))
     (ask (s-corporation zz-productions))
     =>
     FALSE
     (ask (not (s-corporation zz-productions)))
     =>
     TRUE

After asserting that ZZ Productions is not an S-corporation, a repeat
of the query asking if it _is_ one will now return `false', because the
explicit assertion of the negation allows a quick disproof of the
positive query.

*Note*: PowerLoom uses all its effort to prove that the proposition in
question is true, and only uses some effort to prove that it is false.
Therefore, only falsities that are discovered "on the way" or with
shallow inference strategies will be found (which was the case above).
If you want to check whether a proposition is false with maximum
effort, simply ask the negated proposition by wrapping an explicit
`not' arount it.  The reason for this asymmetry is that checking for
truth and falsity really amounts to asking two separate and possibly
expensive queries, and the user or programmer should decide whether the
effort should be expended to ask both queries instead of just one.

   PowerLoom can sometimes infer a negative fact without the necessity
of a direct assertion.  For example:

     (ask (= (number-of-employees ACME-cleaners) 8))
     =>
     TRUE
     (ask (= (number-of-employees ACME-cleaners) 10))
     =>
     FALSE
     (ask (not (= (number-of-employees ACME-cleaners) 10)))
     =>
     TRUE

   PowerLoom can infer the second and third answers because it knows
that the function `number-of-employees' can return only one value, and
if that value is the number eight, it cannot also be something else (in
this case, ten).

   Many systems, in particular, database systems and Prolog, make the
assumptions that if a proposition cannot be proved true, then it must be
false. This is called the "closed world assumption". By default,
PowerLoom makes an open-world assumption, but for specific relations it
can be instructed to assume a closed world if a user wants closed world
semantics. For example, suppose we introduce a relation `works-for',
and we assume that all `works-for' facts have been entered in our
knowledge base:

     (defrelation works-for (?p (?c Company)))
     (assert (works-for shirly ACME-cleaners))
     (assert (works-for jerome zz-productions))

   If we ask PowerLoom whether Jerome does NOT work for MegaSoft, it
will return `unknown'.  But if we assert that the relation `works-for'
is `closed', then PowerLoom will assume that Jerome only works for ZZ
Productions:

     (ask (not (works-for jerome megasoft)))
     =>
     UNKNOWN

     (assert (closed works-for))
     (ask (not (works-for jerome megasoft)))
     =>
     TRUE

   The reasoning employed to achieve the above result (that Jerome does
not work for MegaSoft) is called "negation as failure", which means that
if a proof of a proposition fails, then one may assume that the
proposition is false. We can achieve a negation-as-failure result a
second way (i.e., other than by using a closed world assumption) by
employing the query operator `fail'.  Here we retract the closure
assumption for `works-for' and achieve the desired result using `fail':

     (retract (closed works-for))
     (ask (not (works-for jerome megasoft)))
     =>
     UNKNOWN

     (ask (fail (works-for jerome megasoft)))
     =>
     TRUE

   When you see the operator "not" in an SQL query or a Prolog program,
it really stands for "fail".

   ---------- Footnotes ----------

   (1) Actually, PowerLoom implements a _five-valued_ logic -- the
remaining two values are "default true" and "default false". However,
the present discussion defers the subject of default truth values.

   (2) Because proving negations can be very difficult, PowerLoom will
only conduct a very quick and shallow search for a disproof.  More
extensive reasoning is used if a negation is asked about explicitly,
thus PowerLoom may return `unknown' if asked about `P', but true if
asked about `(not P)'.


File: manual.info,  Node: Retraction,  Next: Clipping of Values,  Prev: Negation and Open and Closed World Semantics,  Up: Annotated Example

3.8 Retraction
==============

Below, we introduce a few new terms for defining geographic information.
We define a relation called `contains' to assert that one geographic
location (the second argument to `contains') is located within another:

     (defconcept geographic-location)
     (defconcept country (?l geographic-location))
     (defconcept state (?l geographic-location))
     (defconcept city (?l geographic-location))
     (defrelation contains ((?l1 geographic-location)
                            (?l2 geographic-location)))

   Now, we can assert some facts about U.S. geography (including one
deliberate mistake):

     (assert (and
              (country united-states)
              (geographic-location eastern-us)
              (contains united-states eastern-us)
              (state georgia) (contains eastern-us georgia)
              (city atlanta) (contains georgia atlanta)
              (geographic-location southern-us)
              (contains united-states southern-us)
              (state texas) (contains eastern-us texas)
              (city dallas) (contains texas dallas)
              (city austin) (contains texas austin)))

   We would like to repair the incorrect assertion `(contains
eastern-us texas)'.  The PowerLoom command `retract' allows us to erase
assertions that should not be true:

     (ask (contains eastern-us texas))
     =>
     TRUE

     (retract (contains eastern-us texas))
     (assert (contains southern-us texas))

     (ask (contains eastern-us texas))
     =>
     UNKNOWN

   Retraction should not be confused with assertion of negative
propositions.  For example, asserting that Texas is not a state would
not retract the assertion that it is (a state).  Instead, an evident
logical contradiction is detected as a "clash", and the clashing
proposition is disallowed:

     (assert (not (state texas)))
     =>
     Derived both TRUE and FALSE for the proposition `|P|(STATE TEXAS)'.
        Clash occurred in module ``|MDL|/PL-KERNEL-KB/business'.

     (ask (not (state texas)))
     =>
     UNKNOWN


File: manual.info,  Node: Clipping of Values,  Next: Rule-based Inference,  Prev: Retraction,  Up: Annotated Example

3.9 Clipping of Values
======================

Programmers are accustomed to changing the values of attributes for
program objects just by overwriting previous values.  PowerLoom
implements a similar semantics for the special case of functions and
single-valued relations.  When a second value is asserted for one of
these relations the previous value is automatically retracted.  We call
this _clipping_.

   To illustrate this behavior for both kinds of relations (a function
is considered a kind of relation), we will define a mapping from a
company to a city that contains its headquarters in two different ways:

     (deffunction headquarters ((?c company)) :-> (?city city))
     (defrelation headquartered-in ((?c company) (?city city))
       :axioms (single-valued headquartered-in))

   The clause "`:axioms (single-valued headquartered-in)'" tells
PowerLoom that the `headquartered-in' relation is single-valued, i.e.,
that it can map a company to at most one city.  This makes its behavior
similar to that of the function `headquarters'.  Here is an example of
clipping for the function `headquarters':

     (assert (= (headquarters zz-productions) atlanta))
     (retrieve all (= ?x (headquarters zz-productions)))
     =>
     There is 1 solution:
       #1: ?X=ATLANTA

     (assert (= (headquarters zz-productions) dallas))
     (retrieve all (= ?x (headquarters zz-productions)))
     =>
     There is 1 solution:
       #1: ?X=DALLAS

   Here is the same kind of clipping using a single-valued relation:

     (assert (headquartered-in megasoft atlanta))
     (retrieve all (headquartered-in megasoft ?x))
     =>
     There is 1 solution:
       #1: ?X=ATLANTA

     (assert (headquartered-in megasoft dallas))
     (retrieve all (headquartered-in megasoft ?x))
     =>
     There is 1 solution:
       #1: ?X=DALLAS


File: manual.info,  Node: Rule-based Inference,  Next: Explanation,  Prev: Clipping of Values,  Up: Annotated Example

3.10 Rule-based Inference
=========================

Suppose that we want to retrieve all geographic locations that are
contained in the Southern US, based on the set of assertions about
geography that we entered in earlier. The following query returns only
one of such location:

     (retrieve all (contains southern-us ?x))
     =>
     There is 1 solution:
       #1: ?X=TEXAS

   We would like the cities Austin and Dallas to be retrieved as well.
To do this, we can assert a `rule' that states that `contains' is a
transitive relation:

     (defrule transitive-contains
       (=> (and (contains ?l1 ?l2)
                (contains ?l2 ?l3))
           (contains ?l1 ?l3)))

   The `defrule' declaration does two things--it asserts a proposition,
and it associates a name with that proposition (in the above case, the
name is `transitive-contains'). This name is used by the system in
displaying traces of its inferencing. It also makes redefinition of the
proposition easier. If we wish to retract an unnamed proposition, it is
necessary to explicitly retract that proposition using a syntax
identical to the assertion(1) If on the other hand, a proposition has a
name, then a new `defrule' declaration that uses the same name will
automatically retract any existing proposition having the same name.

   Our transitive closure rule failed to include any logical quantifiers
for the variables `?l1', `?l2', and `?l3'.  When PowerLoom parses a
top-level proposition, it automatically supplies universal quantifiers
for any unquantified variables.  So, the above rule is equivalent to
the rule:

     (defrule transitive-contains
       (forall (?l1 ?l2 ?l3)
         (=> (and (contains ?l1 ?l2)
                  (contains ?l2 ?l3))
             (contains ?l1 ?l3))))

Note: Instead of defining a `transitive-contains' rule, we could have
achieved the same effect by asserting that the `contains' relation is
transitive, e.g., by stating `(assert (transitive contains))'.

   Now that we have told the system that our `contains' relation is
transitive, let us rerun our query:

     (retrieve all (contains southern-us ?x))
     =>
     There are 3 solutions:
       #1: ?X=TEXAS
       #2: ?X=AUSTIN
       #3: ?X=DALLAS

   ---------- Footnotes ----------

   (1) Actually, PowerLoom isn't quite as strict as just stated-its
search for an identical proposition can accomodate changes in the names
of variables.


File: manual.info,  Node: Explanation,  Next: Contexts and Modules,  Prev: Rule-based Inference,  Up: Annotated Example

3.11 Explanation
================

PowerLoom provides a command called `why' that you can use to get an
explanation of the logic behind one of its answers.  The `why' command
explains the last query entered into the system, i.e., it should
invoked after one has submitted a `retrieve' or an `ask' command.
Before asking a `why' command, you must enable the justifications
feature:

     (set-feature justifications)

   Queries execute a bit more slowly with jusifications enabled, which
is why it is disabled by default. Having enabled justifications, we
must (re)run a query.  Here is how we can ask why Dallas is contained
in the Southern US:

     (ask (contains southern-us dallas))
     =>
     TRUE
     (why)
     =>
     1 (CONTAINS SOUTHERN-US DALLAS)
         follows by Modus Ponens
         and substitution {?l3/DALLAS, ?l2/TEXAS, ?l1/SOUTHERN-US}
         since 1.1 ! (forall (?l1 ?l3)
                        (<= (CONTAINS ?l1 ?l3)
                            (exists (?l2)
                               (and (CONTAINS ?l1 ?l2)
                                    (CONTAINS ?l2 ?l3)))))
         and   1.2 ! (CONTAINS SOUTHERN-US TEXAS)
         and   1.3 ! (CONTAINS TEXAS DALLAS)

   The above explanation tells us that a rule (our transitivity rule)
was invoked during the proof, and that two ground assertions `(CONTAINS
SOUTHERN-US TEXAS)' and `(CONTAINS TEXAS DALLAS)' were accessed to
supply preconditions for the rule.  These combined assertions lead to
the conclusion `(CONTAINS SOUTHERN-US DALLAS)'.  Within an explanation,
directly asserted propositions are indicated with the prefix `!'.

   We can also ask `why' after a `retrieve' query. However, if the
query has multiple solutions, each one has a separate explanation. In
order to ask `why', we need to ask for one solution at a time. This can
be done by omitting the word `all' from the `retrieve' query, and
subsequently calling `(retrieve)' to obtain results one-at-a-time.  (1)

     (retrieve (contains southern-us ?x))
     =>
       #1: ?X=DALLAS
     (retrieve)
     =>
     There are 2 solutions so far:
       #1: ?X=DALLAS
       #2: ?X=TEXAS
     (retrieve)
     =>
     There are 3 solutions so far:
       #1: ?X=DALLAS
       #2: ?X=TEXAS
       #3: ?X=AUSTIN
     (why)
     =>
     1 (CONTAINS SOUTHERN-US AUSTIN)
         follows by Modus Ponens
         with substitution {?l1/SOUTHERN-US, ?l3/AUSTIN, ?l2/TEXAS}
         since 1.1 ! (FORALL (?l1 ?l3)
                        (<= (CONTAINS ?l1 ?l3)
                            (EXISTS (?l2)
                               (AND (CONTAINS ?l1 ?l2)
                                    (CONTAINS ?l2 ?l3)))))
         and   1.2 ! (CONTAINS SOUTHERN-US TEXAS)
         and   1.3 ! (CONTAINS TEXAS AUSTIN)

   The following query combines a variety of relations that have been
entered into the business modules.  It retrieves names of companies
whose headquarters are in the southern US.  Note that query variables
that do not appear in the output (i.e., variables not listed after the
`all'

     (retrieve ?name (exists (?city ?company)
                       (and (contains southern-us ?city)
                            (headquartered-in ?company ?city)
                            (company-name ?company ?name))))
     =>
     There is 1 solution so far:
       #1: ?NAME="MegaSoft, Inc."

     (why)
     =>
     1 (and (COMPANY-NAME MEGASOFT MegaSoft, Inc.)
            (HEADQUARTERED-IN MEGASOFT DALLAS)
            (CONTAINS SOUTHERN-US DALLAS))
         follows by And-Introduction
         since 1.1 ! (COMPANY-NAME MEGASOFT MegaSoft, Inc.)
         and   1.2 ! (HEADQUARTERED-IN MEGASOFT DALLAS)
         and   1.3   (CONTAINS SOUTHERN-US DALLAS)

     1.3 (CONTAINS SOUTHERN-US DALLAS)
         follows by Modus Ponens
         and substitution {?l3/DALLAS, ?l2/TEXAS, ?l1/SOUTHERN-US}
         since 1.3.1 ! (forall (?l1 ?l3)
                          (<= (CONTAINS ?l1 ?l3)
                              (exists (?l2)
                                 (and (CONTAINS ?l1 ?l2)
                                      (CONTAINS ?l2 ?l3)))))
         and   1.3.2 ! (CONTAINS SOUTHERN-US TEXAS)
         and   1.3.3 ! (CONTAINS TEXAS DALLAS)

   ---------- Footnotes ----------

   (1) The order of solutions will not necessarily be the same as shown
here.


File: manual.info,  Node: Contexts and Modules,  Next: Equality Reasoning,  Prev: Explanation,  Up: Annotated Example

3.12 Contexts and Modules
=========================

The final feature that we will illustrate in this section is the
PowerLoom context mechanism.  PowerLoom organizes its knowledge into a
hierarchy of logical containers called "contexts".  A PowerLoom context
is either a "module", a somewhat heavyweight object that includes its
own symbol table, or a "world", a very lightweight object designed for
fast switching from one world to another.  All contexts inherit from a
single root context.  The most important feature of a context is that a
fact asserted into it is inherited by all contexts below it.  However,
a "parent" context is unaware of any knowledge entered into one of its
descendants.

   Here we concern ourselves only with modules.  We first define a
second module, called `alternate-business', to be a subcontext of our
`business' module, and then we switch into the new module:

     (defmodule "ALTERNATE-BUSINESS"
       :includes "BUSINESS")
     (in-module "ALTERNATE-BUSINESS")

   Next, within the scope of the `alternate-business' module, we will
create a new company.  And just for good measure, we will change the
name of MegaSoft while we are at it:

     (assert (and (company web-phantoms)
                  (company-name web-phantoms "Web Phantoms, Inc.")))
     (retract (company-name megasoft "MegaSoft, Inc."))
     (assert (company-name megasoft "MegaZorch, Inc."))

   First, here are pairs of companies and company names from the vantage
point of the `Business' module:

     (in-module "BUSINESS")
     (retrieve all (company-name ?x ?y))
     =>
     There are 3 solutions:
       #1: ?X=ACME-CLEANERS, ?Y="ACME Cleaners, LTD"
       #2: ?X=MEGASOFT, ?Y="MegaSoft, Inc."
       #3: ?X=MEGASOFT, ?Y="MegaSoft"

   Now observe the same query executed from within the alternate
`Business' module:

     (in-module "ALTERNATE-BUSINESS")
     (retrieve all (company-name ?x ?y))
     =>
     There are 4 solutions:
       #1: ?X=ACME-CLEANERS, ?Y="ACME Cleaners, LTD"
       #2: ?X=MEGASOFT, ?Y="MegaZorch, Inc."
       #3: ?X=WEB-PHANTOMS, ?Y="Web Phantoms, Inc."
       #4: ?X=MEGASOFT, ?Y="MegaSoft"

   We see that all facts pertaining to company names have inherited down
from the Business to the Alternate Business module, except for the name
for MegaSoft that we explicitly retracted.  Also, the new facts
asserted within the Alternate Business module appear mixed in with the
inherited facts.


File: manual.info,  Node: Equality Reasoning,  Next: Classification,  Prev: Contexts and Modules,  Up: Annotated Example

3.13 Equality Reasoning
=======================

PowerLoom makes the _unique names assumption_, so every two different
named logic constants are assumed to be different.  For example:

     (assert (= Fred Joe))
     =>
     Derived both TRUE and FALSE for the proposition `|P#|FALSE'.
        Clash occurred in module `|MDL|/PL-KERNEL-KB/PL-USER'.

     (assert (= Fred Fred))
     =>
     |P|TRUE

   However, one can assert equality between skolems that represent
function terms as well as between a function term skolem and a regular
constant.  For example:

     (deffunction age (?x ?y))
     (assert (= (age Fred) (age Joe)))
     (assert (= (age Fred) 10))

     (retrieve (age Joe ?x))
     =>
     There is 1 solution so far:
       #1: ?X=10

   So, if one needs to model named individuals where equality might be
asserted (e.g., to model a person with an alias) one has to resort to
using function terms.  For example:

     (deffunction individual (?name ?i))
     (assert (= (age (individual A)) 12))
     (assert (= (individual A) (individual B)))

     (retrieve (age (individual B) ?a))
     =>
     There is 1 solution so far:
       #1: ?A=12


File: manual.info,  Node: Classification,  Next: Truth Maintenance,  Prev: Equality Reasoning,  Up: Annotated Example

3.14 Classification, Subsumption
================================


File: manual.info,  Node: Truth Maintenance,  Next: Inference Control,  Prev: Classification,  Up: Annotated Example

3.15 Truth Maintenance
======================


File: manual.info,  Node: Inference Control,  Next: Keyword Axioms,  Prev: Truth Maintenance,  Up: Annotated Example

3.16 Inference Control
======================


File: manual.info,  Node: Keyword Axioms,  Next: Cardinality/Type Reasoning with Frame Predicates,  Prev: Inference Control,  Up: Annotated Example

3.17 Keyword Axioms
===================


File: manual.info,  Node: Cardinality/Type Reasoning with Frame Predicates,  Next: Loom-to-PowerLoom,  Prev: Keyword Axioms,  Up: Annotated Example

3.18 Cardinality/Type Reasoning with Frame Predicates
=====================================================


File: manual.info,  Node: Loom-to-PowerLoom,  Next: Deviations from KIF,  Prev: Cardinality/Type Reasoning with Frame Predicates,  Up: Annotated Example

3.19 Loom-to-PowerLoom
======================


File: manual.info,  Node: Deviations from KIF,  Next: Differences from Loom,  Prev: Loom-to-PowerLoom,  Up: Annotated Example

3.20 Deviations from KIF
========================


File: manual.info,  Node: Differences from Loom,  Next: Defaults,  Prev: Deviations from KIF,  Up: Annotated Example

3.21 Differences from Loom
==========================


File: manual.info,  Node: Defaults,  Next: Sets,  Prev: Differences from Loom,  Up: Annotated Example

3.22 Defaults
=============


File: manual.info,  Node: Sets,  Prev: Defaults,  Up: Annotated Example

3.23 Sets, Lists, SETOFALL, KAPPA
=================================


File: manual.info,  Node: Communicating with PowerLoom,  Next: Commands,  Prev: Annotated Example,  Up: Top

4 Communicating with PowerLoom
******************************

There are a variety of modes users can choose from for interacting with
the PowerLoom system.  The simplest is to use the PowerLoom command
interpreter.  The interpreter supports a type-in window that allows
line-at-a-time entry of commands.  You can use the interpreter to load
files of PowerLoom declarations, to create and edit knowledge base
objects, to ask queries, and to modify settings in the execution
environment.

   A second mode of interaction involves writing an application that
makes calls to the PowerLoom API (*note PowerLoom API::). PowerLoom
implements an extensive list of procedures that can be called to
control the logic system. These procedures range from very specific
procedures to assert or query a single fact, to general procedures that
interpret arbitrary queries. The STELLA translator offers users a
choice of Common Lisp, Java, or C++ -based versions of the PowerLoom
system; users can choose whichever is the best match for their language
of choice for their applications.

   Starting with PowerLoom version 4.0, an experimental Java-based GUI
is available to browse, query and edit knowledge bases (*note PowerLoom
GUI::).  Additionally, the Ontosaurus Web Browser offers a convenient
way to view the contents of PowerLoom knowledge bases from a standard
Web browser (*note Ontosaurus::).

* Menu:

* Command Interpreter ::
* Persistent Knowledge Bases::


File: manual.info,  Node: Command Interpreter,  Next: Persistent Knowledge Bases,  Prev: Communicating with PowerLoom,  Up: Communicating with PowerLoom

4.1 Command Interpreter
=======================

Currently, the primary means for interacting with PowerLoom is its
command interpreter.  The command interpreter can be used either
interactively, or it can be invoked directly from a program to evaluate
individual commands.  All PowerLoom commands (*note Commands::) can be
evaluated using the command interpreter.

   The interactive command interpreter is invoked by calling the
function `powerloom' without any arguments.  In the Java versions of
PowerLoom, the interpreter in called by the `main' routine in the class
`PowerLoom' within the `logic' package.  In the C++ versions of
PowerLoom, `powerloom' is also called within the `main' routine.  In
the Lisp version, `(STELLA::powerloom)' has to be called explicitly.
However, in Lisp it is not really necessary to use the command
interpreter, since all commands can also be executed directly at the
Lisp top level(1).

   The interactive command interpreter functions as a simple
read/eval/print loop that prompts for input with a `|=' prompt, reads a
user command from standard input, evaluates it, and prints the result
to standard output.  To exit the command interpreter, type `quit' or
`stop'.

   To evaluate commands directly from a program, the PowerLoom API
provides the following evaluator functions:

 -- Function: evaluate ((command OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : OBJECT
     Evaluate the command COMMAND within MODULE and return the result.
     Currently, only the evaluation of (possibly nested) commands and
     global variables is supported.  Commands are simple to program in
     Common Lisp, since they are built into the language, and
     relatively awkward in Java and C++.  Users of either of those
     languages are more likely to want to call `s-evaluate'.

 -- Function: evaluate-string ((expression STRING)) : OBJECT
     Evaluate the expression represented by EXPRESSION and return the
     result.  This is equivalent to `(evaluate (unstringify
     expression))'.

   ---------- Footnotes ----------

   (1) If you are executing within a case sensitive module, then you
may see some differences in behavior between commands evaluated by the
command interpreter and commands invoked from the Lisp Listener.


File: manual.info,  Node: Persistent Knowledge Bases,  Prev: Command Interpreter,  Up: Communicating with PowerLoom

4.2 Persistent Knowledge Bases
==============================

Serious users of PowerLoom will want to construct knowledge bases that
persist between sessions.  PowerLoom's primary medium of persistence is
file-based; users construct their knowledge bases by entering PowerLoom
statements into ASCII-formatted files, and then using the `load'
command to load them into PowerLoom.  There is also a `save-module'
command that saves the current assertions of a module to a file.
Large-scale persistence via a backend database is currently under
development and will become available in one of the next releases.


File: manual.info,  Node: Commands,  Next: PowerLoom API,  Prev: Communicating with PowerLoom,  Up: Top

5 Commands
**********

This chapter lists all available PowerLoom commands alphabetically.
Each command is documented with its name, a (possibly empty) list of
parameters specified as `(<name> <type>)' pairs, its return type, and
its category ("Command").  Almost all of the commands implicitly quote
their arguments, meaning that when calling them, you don't need to add
any quotation yourself.  For example, the command `all-facts-of' is
defined as follows:

      -- Command: all-facts-of ((instanceRef NAME)) : (CONS OF
               PROPOSITION)
          Return a cons list of all definite (TRUE or FALSE)
          propositions that reference the instance INSTANCEREF.

   The `all-facts-of' command has one parameter called INSTANCEREF of
type _NAME_, and returns a STELLA _LIST_ containing zero or more
objects of type _PROPOSITION_ as its result.  The type NAME subsumes the
types SYMBOL, SURROGATE, STRING, and KEYWORD.  Unless you are in a
case-sensitive module, the following four commands are equivalent:

         (all-facts-of Merryweather)
         (all-facts-of :MERRYWEATHER)
         (all-facts-of "merryweather")
         (all-facts-of @MerryWeather)

   Commands can also have `&rest' parameters (similar to Lisp
functions).  These are either used to allow a variable number of
arguments, or to handle optional arguments, since STELLA does not
directly support optional arguments.

   Here is a list of important parameter types used in the command
specifications below:

   * _GENERALIZED-SYMBOL_: A generalized symbol is either a plain
     symbol (similar to a Lisp symbol) such as `Merryweather', a keyword
     (similar to a Lisp keyword) such as `:KIF', or a STELLA surrogate
     which is a symbol starting with an at-sign, e.g., `@CONS'.  STELLA
     surrogates are used as names for objects of arbitrary types.

   * _NAME_: Names can be either a string, or a _GENERALIZED-SYMBOL_
     (i.e., a symbol, a keyword, or a surrogate).  If a symbol is
     supplied, only its symbol-name is used.  Commands that take names
     as arguments usually coerce whatever argument is entered into a
     string, but by allowing a NAME they make it a little bit more
     convenient to type a name in an interactive invocation.(1)

   * _PARSE-TREE_: A parse tree is similar to a Lisp s-expression,
     i.e., it can either be an atom such as a symbol, number, or a
     string, or a list of zero or more parse trees.  For example, the
     expression `(happy Fred)' is a parse tree, and so are its
     components `happy' and `Fred'.

   Here is the list of all available PowerLoom commands:

 -- Command: add-load-path ((path STRING)) : (CONS OF STRING-WRAPPER)
     Append the directories listed in the |-separated PATH to the end
     of the STELLA load path.  Return the resulting load path.

 -- N-Command: all-facts-of ((instanceRef OBJECT)) : (CONS OF
          PROPOSITION)
     Return a cons list of all definite (TRUE or FALSE) propositions
     that reference the instance INSTANCEREF.  This includes
     propositions asserted to be true by default, but it does not
     include propositions that are found to be TRUE only by running the
     query engine.  Facts inferred to be TRUE by the forward chainer
     will be included.  Hence, the returned list of facts may be longer
     in a context where the forward chainer has been run then in one
     where it has not (see `run-forward-rules').  INSTANCEREF can be a
     regular name such as `fred' as well as a function term such as
     `(father fred)'.

 -- N-Command: ask (&rest (proposition&options PARSE-TREE)) :
          TRUTH-VALUE
     Perform inference to determine whether the proposition specified in
     PROPOSITION&OPTIONS is true.  Return the truth-value found.  `ask'
     will spend most of its effort to determine whether the proposition
     is true and only a little effort via shallow inference strategies
     to determine whether it is false.  To find out whether a
     proposition is false with full inference effort `ask' its negation.

     KIF example: `(ask (happy Fred))' will return TRUE if Fred was
     indeed found to be happy.  Note, that for this query to run, the
     logic constant `Fred' and the relation `happy' must already be
     defined (see `assert').  Use `(set/unset-feature goal-trace)' to
     en/disable goal tracing of the inference engine.

     The `ask' command supports the following options: `:TIMEOUT' is an
     integer or floating point time limit, specified in seconds.  For
     example, the command `(ask (nervous Fred) :timeout 2.0)' will cease
     inference after two seconds if a proof has not been found by then.
     If the `:DONT-OPTIMIZE?' is given as TRUE, it tells PowerLoom to
     not optimize the order of clauses in the query before evaluating
     it.  This is useful for cases where a specific evaluation order of
     the clauses is required (or the optimizer doesn't do the right
     thing).  If `:THREE-VALUED?' is given as TRUE, PowerLoom will try
     to prove the negation of the query with full effort in case the
     given query returned UNKNOWN.  By default, PowerLoom uses full
     effort to prove the query as stated and only a little
     opportunistic effort to see whether it is actually false.

 -- N-Command: assert ((proposition PARSE-TREE)) : OBJECT
     Assert the truth of PROPOSITION.  Return the asserted proposition
     object.  KIF example:  "(assert (happy Fred))" asserts that Fred
     is indeed happy.  Note that for this assertion to succeed, the
     relation `happy' must already be defined.  If the constant `Fred'
     has not yet been created, it is automatically created as a
     side-effect of calling `assert'.

 -- N-Command: assert-from-query ((query CONS) &rest (options OBJECT))
          : (CONS OF PROPOSITION)
     Evaluate QUERY, instantiate the query proposition for each
     generated solution and assert the resulting propositions.  The
     accepted syntax is as follows:

           (assert-from-query <query-command>
                              [:relation <relation-name>]
                              [:pattern <description-term>]
                              [:module <module-name>]
                              [:record-justifications? TRUE|FALSE])

     <query-command> has to be a strict or partial retrieval command.
     If a :relation option is supplied, <relation-name> is used as the
     relation of the resulting propositions.  In this case the bindings
     of each solution will become arguments to the specified relation
     in the order of QUERYs output variables (the arities have to
     match).  The :pattern option is a generalization of this mechanism
     that specifies an arbitrary proposition pattern to be instantiated
     by the query's solution.  In this case <description-term> has to
     be a SETOFALL or KAPPA expression whose IO-variables will be bound
     in sequence to the bindings of a query solution to generate the
     resulting proposition.  Finally, if a :module option is specified,
     the assertions will be generated in that module.  Note that for
     this to work the relations referenced in the query proposition or
     pattern have to be visible in the module.  Also, instances will
     not be copied to the target module, therefore, the resulting
     propositions might reference external out-of-module objects in
     case they are not visible there.  If :record-justifications? is
     TRUE, justifications will be recorded for the query and the
     resulting justifications will be linked to the asserted
     propositions.  Here are some examples:

           (assert-from-query (retrieve all (foo ?x ?y)))
           (assert-from-query (retrieve all (?y ?x)
                                       (exists ?z
                                         (and (foo ?x ?z)
                                              (foo ?z ?y))))
                              :relation bar :module other)
           (assert-from-query
             (retrieve all (and (relation ?x) (symmetric ?x)))
             :pattern (kappa (?pred)
                        (forall (?x ?y)
                          (=> (holds ?pred ?x ?y)
                              (holds ?pred ?y ?x))))))


 -- N-Command: assert-rule ((ruleName NAME)) : PROPOSITION
     Set the truth value of the rule named RULENAME to TRUE.  The
     proposition having the name RULENAME may be any arbitrary
     proposition, although we expect that it is probably a material
     implication.  (See `retract-rule').

 -- N-Command: cc (&rest (name NAME)) : CONTEXT
     Change the current context to the one named NAME.  Return the
     value of the new current context.  If no NAME is supplied, return
     the pre-existing value of the current context.  `cc' is a no-op if
     the context reference cannot be successfully evaluated.

 -- N-Command: classify-relations (&rest (options OBJECT)) :
     Classify relations visible in the module defined by the :module
     option (which defaults to the current module).  If :module was
     explicitly specified as NULL, classify relations in all modules.
     If `:local?' is specified as TRUE only classify relations that
     belong to the specified module but not any modules it inherits.
     For backwards compatibility, this command also supports the old
     <module> <local?> arguments specified without keywords.

     Conceptually, the classifier operates by comparing each concept or
     relation with all other concepts/relations, searching for a proof
     that a subsumption relation exists between each pair. Whenever a
     new subsumption relation is discovered, the classifier adds an
     `implication' link between members of the pair, thereby augmenting
     the structure of the concept or relation hierarchy. The
     implemented classification algorithm is relatively efficient - it
     works hard at limiting the number of concepts or relations that
     need to be checked for possible subsumption relationships.


 -- N-Command: classify-instances (&rest (options OBJECT)) :
     Classify instances visible in the module defined by the :module
     option (which defaults to the current module).  If :module was
     explicitly specified as NULL, classify instances in all modules.
     If `:local?' is specified as TRUE only classify instances that
     belong to the specified module but not any modules it inherits.
     For backwards compatibility, this command also supports the old
     <module> <local?> arguments specified without keywords.

     Conceptually, the classifier operates by comparing each instance
     with all concepts in the hierarchy, searching for a proof for each
     pairing indicating that the instance belongs to the concept.
     Whenever a new `is-a' relation is discovered, the classifier adds
     an `is-a' link between the instance and the concept, thereby
     recording an additional fact about the instance.  The implemented
     classification algorithm is relatively efficient - it works hard at
     limiting the number of concepts or relations that need to be
     checked for possible is-a relationships.


 -- Command: clear-caches () :
     Clear all query and memoization caches.

 -- N-Command: clear-instances (&rest (name NAME)) :
     Destroy all instances belonging to module NAME or any of its
     children.  Leave meta-objects, e.g., concepts and relations, alone.
     If no NAME is supplied, the current module will be cleared after
     confirming with the user.

 -- N-Command: clear-module (&rest (name NAME)) :
     Destroy all objects belonging to module NAME or any of its
     children.  If no NAME is supplied, the current module will be
     cleared after confirming with the user.  Important modules such as
     STELLA are protected against accidental clearing.

 -- N-Command: conceive ((formula PARSE-TREE)) : OBJECT
     Guess whether FORMULA represents a term or a sentence/proposition.
     If we are not sure, assume its a proposition.  If its, a term,
     return its internal representation.  If a proposition, construct a
     proposition for FORMULA without asserting its truth value.  Return
     the conceived proposition object.  KIF example: "(conceive (happy
     Fred))" builds the proposition expressing that Fred is happy
     without explictly asserting or denying it.  Note, that for this to
     succeed, the relation `happy' must already be defined (see
     `assert').  If the logic constant `Fred' has not yet been created,
     it is automatically created as a side-effect of calling `conceive'.

 -- Command: copyright () :
     Print detailed PowerLoom copyright information.

 -- N-Command: defconcept (&rest (args PARSE-TREE)) : NAMED-DESCRIPTION
     Define (or redefine) a concept.  The accepted syntax is:

           (defconcept <conceptconst> [(<var> <parent>*)]
              [:documentation <string>]
              [:<= <sentence>] | [:=> <sentence>] |
              [:<<= <sentence>] | [:=>> <sentence>] |
              [:<=> <sentence>] | [:<=>> <sentence>] | [:<<=> <sentence>] |
              [:<<=>> <sentence>] |
              [:axioms {<sentence> | (<sentence>+)}] |
              <keyword-option>*)

     Declaration of a concept variable `<var>' is optional, unless any
     implication (arrow) options are supplied that need to reference
     it.  A possibly empty list of concept names following `<var>' is
     taken as the list of parents of `<conceptconst>'.  Alternatively,
     parents can be specified via the `:=>' option.  If no parents are
     specified, the parent of `<conceptconst>' is taken to be THING.
     `<keyword-option>' represents a keyword followed by a value that
     states an assertion about `<conceptconst>'.  See `defrelation' for
     a description of `<keyword-option>'s.


 -- N-Command: deffunction (&rest (args PARSE-TREE)) : NAMED-DESCRIPTION
     Define (or redefine) a logic function.  The accepted syntax is:

           (deffunction <funconst> (<vardecl>+) [:-> <vardecl>]
              [:documentation <string>]
              [:<= <sentence>] | [:=> <sentence>] |
              [:<<= <sentence>] | [:=>> <sentence>] |
              [:<=> <sentence>] | [:<=>> <sentence>] |
              [:<<=> <sentence>] | [:<<=>> <sentence>] |
              [:axioms {<sentence> | (<sentence>+)}]
              [<keyword-option>*])

     Function parameters can be typed or untyped.  If the `:->' option
     is supplied, it specifies the output variable of the function.
     Otherwise, the last variable in the parameter list is used as the
     output variable.  See `defrelation' for a description of
     `<keyword-option>'s.


 -- N-Command: definstance (&rest (args PARSE-TREE)) : LOGIC-OBJECT
     Define (or redefine) a logic instance (`definstance' is an alias
     for `defobject' which see).

 -- N-Command: defmodule ((name NAME) &rest (options OBJECT)) :
     Define (or redefine) a module named NAME.  The accepted syntax is:

            (defmodule <module-name>
               [:documentation <docstring>]
               [:includes {<module-name> | (<module-name>*)}]
               [:uses {<module-name> | (<module-name>*)}]
               [:lisp-package <package-name-string>]
               [:java-package <package-specification-string>]
               [:cpp-namespace <namespace-name-string>]
               [:java-catchall-class
               [:api? {TRUE | FALSE}]
               [:case-sensitive? {TRUE | FALSE}]
               [:shadow (<symbol>*)]
               [:java-catchall-class <class-name-string>]
               [<other-options>*])

     NAME can be a string or a symbol.

     Modules include objects from other modules via two separate
     mechanisms: (1) they inherit from their parents specified via the
     `:includes' option and/or a fully qualified module name, and (2)
     they inherit from used modules specified via the `:uses' option.
     The main difference between the two mechanisms is that inheritance
     from parents is transitive, while uses-links are only followed one
     level deep.  I.e., a module A that uses B will see all objects of
     B (and any of B's parents) but not see anything from modules used
     by B.  Another difference is that only objects declared as public
     can be inherited via uses-links (this is not yet enforced).  Note
     that - contrary to Lisp - there are separate name spaces for
     classes, functions, and variables.  For example, a module could
     inherit the class `CONS' from the `STELLA' module, but shadow the
     function of the same name.

     The above discussion of `:includes' and `:uses' semantics keyed on
     the inheritance/visibility of symbols. The PowerLoom system makes
     another very important distinction: If a module `A' is inherited
     directly or indirectly via `:includes' specification(s) by a
     submodule `B', then all definitions and facts asserted in `A' are
     visible in `B'. This is not the cases for `:uses'; the `:uses'
     options does not impact inheritance of propositions at all.

     The list of modules specified in the `:includes' option plus (if
     supplied) the parent in the path used for NAME become the new
     module's parents. If no `:uses' option was supplied, the new
     module will use the `STELLA' module by default, otherwise, it will
     use the set of specified modules.

     If `:case-sensitive?' is supplied as TRUE, symbols in the module
     will be interned case-sensitively, otherwise (the default), they
     will be converted to uppercase before they get interned.  That
     means that any reference from inside a case-sensitive module to a
     non-case-sensitive module will have to use uppercase names for
     symbols in the non-case-sensitive module.  The standard system
     modules are all NOT case sensitive.

     Modules can shadow definitions of functions and classes inherited
     from parents or used modules. Shadowing is done automatically, but
     generates a warning unless the shadowed type or function name is
     listed in the `:shadow' option of the module definition .

     Examples:

            (defmodule "PL-KERNEL/PL-USER"
              :uses ("LOGIC" "STELLA")
              :package "PL-USER")

            (defmodule PL-USER/GENEALOGY)

     The remaining options are relevant only for modules that contain
     STELLA code.  Modules used only to contain knowledge base
     definitions and assertions have no use for them:

     The keywords `:lisp-package', `:java-package', and `:cpp-package'
     specify the name of a native package or name space in which
     symbols of the module should be allocated when they get translated
     into one of Lisp, Java, or C++. By default, Lisp symbols are
     allocated in the `STELLA' package, and C++ names are translated
     without any prefixes. The rules that the STELLA translator uses to
     attach translated Java objects to classes and packages are
     somewhat complex. Use :java-package option to specify a list of
     package names (separated by periods) that prefix the Java object
     in this module.  Use :java-catchall-class to specify the name of
     the Java class to contain all global & special variables,
     parameter-less functions and functions defined on arguments that
     are not classes in the current module.  The default value will be
     the name of the module.

     When set to TRUE, the :api? option tells the PowerLoom User Manual
     generator that all functions defined in this module should be
     included in the API section. Additionally, the Java translator
     makes all API functions `synchronized'.


 -- N-Command: defobject (&rest (args PARSE-TREE)) : LOGIC-OBJECT
     Define (or redefine) a logic instance.  The accepted syntax is:

           (defobject <constant>
              [:documentation <string>]
              [<keyword-option>*])

     `<keyword-option>' represents a keyword followed by a value that
     states an assertion about <constant>.  See `defrelation' for a
     description of `<keyword-option>'s.

     `defobject' provides a sugar-coated way to assert a collection of
     facts about a logic constant, but otherwise adds nothing in terms
     of functionality.


 -- N-Command: defproposition (&rest (args PARSE-TREE)) : PROPOSITION
     Define (or redefine) a named proposition.  The accepted syntax is:

           (defproposition <name> <sentence>
              [:documentation <string>]
              [:forward-only? {true | false}]
              [:backward-only? {true | false}]
              [:dont-optimize? {true | false}]
              [:confidence-level {:strict | :default}]
              [<keyword-option>*])

     <sentence> can be any sentence that is legal as a top-level
     assertion.  <name> can be a string or symbol and will be bound to
     the asserted proposition represented by <sentence>.  After this
     definition every occurrence of <name> will be replaced by the
     associated proposition.

     The options :forward-only? and :backward-only? can be used to tell
     the inference engine to only use the rule in forward or backward
     direction (this can also be achieved by using the `<<=' or `=>>'
     implication arrows).  :dont-optimize?  tells the inference engine
     to not rearrange the order of clauses in the antecedent of a rule
     and instead evaluate them in their original order.
     :confidence-level can be used to mark a proposition as default
     only.

     `<keyword-option>' represents a keyword followed by a value that
     states an assertion about the proposition <name>.  See
     `defrelation' for a description of `<keyword-option>'s.


 -- N-Command: defrelation (&rest (args PARSE-TREE)) : NAMED-DESCRIPTION
     Define (or redefine) a logic relation.  The accepted syntax is:

           (defrelation <relconst> (<vardecl>+)
              [:documentation <string>]
              [:<= <sentence>] | [:=> <sentence>] |
              [:<<= <sentence>] | [:=>> <sentence>] |
              [:<=> <sentence>] | [:<=>> <sentence>] |
              [:<<=> <sentence>] | [:<<=>> <sentence>] |
              [:axioms {<sentence> | (<sentence>+)}]
              [<keyword-option>*])

     Relation parameters can be typed or untyped.  `<keyword-option>'
     represents a keyword followed by a value that states an assertion
     about `<relconst>'.  For example, including the option `:foo bar'
     states that the proposition `(foo <relconst> bar)' is true.  `:foo
     (bar fum)' states that both `(foo <relconst> bar)' and `(foo
     <relconst> fum)' are true.  `:foo true' states that `(foo
     <relconst>)' is true, `:foo false' states that `(not (foo
     <relconst>))' is true.


 -- N-Command: defrule (&rest (args PARSE-TREE)) : PROPOSITION
     Define (or redefine) a named rule (`defrule' is an alias for
     `defproposition' which see).

 -- N-Command: delete-rules ((relation NAME)) :
     Delete the list of rules associated with RELATION.  This function
     is included mainly for debugging purposes, when a user wants to
     verify the behavior of different sets of rules.

 -- Command: demo (&rest (fileandpause OBJECT)) :
     Read logic commands from a file, echo them verbatimly to standard
     output, and evaluate them just as if they had been typed in
     interactively.  When called with no arguments, present a menu of
     example demos, otherwise, use the first argument as the name of
     the file to demo.  Pause for user confirmation after each
     expression has been read but before it is evaluated.  Pausing can
     be turned off by suppling FALSE as the optional second argument,
     or by typing `c' at the pause prompt.  Typing `?' at the pause
     prompt prints a list of available commands.

 -- N-Command: deny ((proposition PARSE-TREE)) : OBJECT
     Assert the falsity of PROPOSITION.  Return the asserted proposition
     object.  KIF example:  "(deny (happy Fred))" asserts that Fred is
     not happy, which could have been done equivalently by "(assert
     (not (happy Fred)))".  Note, that for this to succeed, the
     relation `happy' must already be defined (see `assert').

 -- N-Command: describe ((name OBJECT) &rest (mode OBJECT)) :
     Print a description of an object in :verbose, :terse, or :source
     modes.

 -- N-Command: destroy ((objectSpec PARSE-TREE)) : OBJECT
     Find an object or proposition as specified by OBJECTSPEC, and
     destroy all propositions and indices that reference it.
     OBJECTSPEC must be a name or a parse tree that evaluates to a
     proposition.  Return the deleted object, or NULL if no matching
     object was found.

 -- Command: drop-load-path ((path STRING)) : (CONS OF STRING-WRAPPER)
     Remove the directories listed in the |-separated PATH from the
     PowerLoom load path.

 -- Command: get-load-path () : (CONS OF STRING-WRAPPER)
     Return the current STELLA load path.

 -- N-Command: get-rules ((relation NAME)) : (CONS OF PROPOSITION)
     Return the list of rules associated with RELATION.

 -- N-Command: help (&rest (commands SYMBOL)) :
     Describe specific commands, or print a list of available commands.

 -- N-Command: in-module ((name NAME)) : MODULE
     Change the current module to the module named NAME.

 -- N-Command: list-inconsistent-propositions (&rest (options OBJECT))
          : (CONS OF PROPOSITION)
     Return a list of all currently known inconsistent proposition in
     the module defined by the :module option (which defaults to the
     current module).  If `:local?' is specified as TRUE only look in
     the specified module but not any modules it inherits.  Note, that
     this simply reports propositions that have been assigned an
     inconsistent truth value so far (e.g., in clash exceptions), it
     will not try to detect any new or all inconsistencies in a module.

 -- Command: list-modules ((kb-only? BOOLEAN)) : (CONS OF MODULE)
     Returns a cons of all modules defined in PowerLoom.  If KB-ONLY?
     is `true', then any modules which are code only or just namespaces
     are not returned.

 -- N-Command: list-unclassified-instances (&rest (options OBJECT)) :
          (CONS OF LOGIC-OBJECT)
     Collect all instances in the module defined by the :module option
     (which defaults to the current module) that were not (or will not
     be) classified due to their lack of non-inferable/primitive type
     assertions.  If :module was explicitly specified as NULL, look in
     all currently defined modules.  If `:local?' is specified as TRUE
     only look in the specified module but not any modules it inherits.
     For backwards compatibility, this command also supports the old
     <module> <local?> arguments specified without keywords.

 -- N-Command: list-unclassified-relations (&rest (options OBJECT)) :
          (CONS OF NAMED-DESCRIPTION)
     Collect all named description in the module defined by the :module
     option (which defaults to the current module) that were not (or
     will not be) classified due to their lack of
     non-inferable/primitive ancestor relations.  If :module was
     explicitly specified as NULL, look in all currently defined
     modules.  If `:local?' is specified as TRUE only look in the
     specified module but not any modules it inherits.  For backwards
     compatibility, this command also supports the old <module>
     <local?> arguments specified without keywords.

 -- N-Command: list-undefined-relations (&rest (options OBJECT)) :
          (CONS OF NAMED-DESCRIPTION)
     Return a list of as yet undefined concepts and relations in the
     module defined by the :module option (which defaults to the
     current module).  These relations were defined by the system,
     since they were referenced but have not yet been defined by the
     user.  If `:local?' is specified as TRUE only look in the
     specified module but not any modules it inherits.  For backwards
     compatibility, this command also supports the old <module>
     <local?> arguments specified without keywords.

 -- Command: load ((file STRING) &rest (options OBJECT)) :
     Read logic commands from FILE and evaluate them.  By default, this
     will check for each asserted proposition whether an equivalent
     proposition already exists and, if so, not assert the duplicate.
     These duplicate checks are somewhat expensive though and can be
     skipped by setting the option :check-duplicates? to false.  This
     can save time when loading large KBs where it is known that no
     duplicate assertions exist in a file.

     Also, by setting the option :module, the module in which the file
     contents will be loaded will be set.  This will only affect files
     that do NOT have an `in-module' declaration as part of the file.
     If this is not set, and no `in-module' declaration is in the file,
     then an error will be signaled.

 -- Command: load-file ((file STRING)) :
     Read STELLA commands from FILE and evaluate them.  The file should
     begin with an `in-module' declaration that specifies the module
     within which all remaining commands are to be evaluated The
     remaining commands are evaluated one-by-one, applying the function
     `evaluate' to each of them.

 -- Command: pop-load-path () : STRING
     Remove the first element from the STELLA load path and return the
     removed element.

 -- N-Command: presume ((proposition PARSE-TREE)) : OBJECT
     Presume the default truth of PROPOSITION.  Return the presumed
     proposition object.  KIF example:  "(presume (happy Fred))" states
     that Fred is most probably happy.  Note, that for this to succeed,
     the relation `happy' must already be defined (see `assert').

 -- Command: print-features () :
     Print the currently enabled and available PowerLoom environment
     features.

 -- N-Command: print-rules ((relation OBJECT)) :
     Print the list of true rules associated with RELATION.

 -- Command: process-definitions () :
     Finish processing all definitions and assertions that have been
     evaluated/loaded since that last call to `process-definitions'.
     PowerLoom defers complete processing of definitions to make it
     easier to support cyclic definitions.  Following finalization of
     definitions, this call performs semantic validation of any
     assertions evaluated since the last call to `process-definitions'.
     PowerLoom calls this function internally before each query; the
     primary reason to call it explicitly is to force the production of
     any diagnostic information that results from the processing and
     validation.

 -- N-Command: propagate-constraints (&rest (name NAME)) :
     Trigger constraint propagation over all propositions of module
     NAME.  If no NAME is supplied, the current module will be used.
     This also enables incremental constraint propagation for future
     monotonic updates to the module.  Once a non-monotonic update is
     performed, i.e., a retraction or clipping of a function value, all
     cached inferences will be discarded and constraint propagation
     will be turned off until this function is called again.

 -- Command: push-load-path ((path STRING)) : (CONS OF STRING-WRAPPER)
     Add the directories listed in the |-separated PATH to the front of
     the STELLA load path.  Return the resulting load path.

 -- N-Command: repropagate-constraints (&rest (name NAME)) :
     Force non-incremental constraint propagation over all propositions
     of module NAME.  If no NAME is supplied, the current module will
     be used.  This also enables incremental constraint propagation for
     future monotonic updates to the module similar to
     `propagate-constraints'.

 -- Command: reset-features () : (LIST OF KEYWORD)
     Reset the PowerLoom environment features to their default settings.

 -- Command: reset-powerloom () :
     Reset PowerLoom to its initial state.  CAUTION: This will destroy
     all loaded knowledge bases and might break other loaded STELLA
     systems if they do reference PowerLoom symbols in their code.

 -- N-Command: retract ((proposition PARSE-TREE)) : OBJECT
     Retract the truth of PROPOSITION.  Return the retracted proposition
     object.  KIF example:  "(retract (happy Fred))" retracts that Fred
     is happy.  Note that for this assertion to succeed, the relation
     `happy' must already be defined.  If the constant `Fred' has not
     yet been created, it is automatically created as a side-effect of
     calling `retract'.

 -- N-Command: retract-facts-of ((instanceRef OBJECT)) :
     Retract all definite (TRUE or FALSE) propositions that reference
     the instance INSTANCEREF.

 -- N-Command: retract-from-query ((query CONS) &rest (options OBJECT))
          : (CONS OF PROPOSITION)
     Evaluate QUERY which has to be a strict or partial retrieval
     command, instantiate the query proposition for each generated
     solution and retract the resulting propositions.  See
     `assert-from-query' for available command options.

 -- N-Command: retract-rule ((ruleName NAME)) : PROPOSITION
     If it is currently TRUE, set the truth value of the rule named
     RULENAME to UNKNOWN  This command may be used alternately with
     `assert-rule' to observe the effects of querying with or without a
     particular (named) rule being asserted within the current context.
     The proposition having the name RULENAME may be any arbitrary
     proposition, although we expect that it is probably a material
     implication.

 -- N-Command: retrieve (&rest (query PARSE-TREE)) : QUERY-ITERATOR
     Retrieve elements of a relation (tuples) that satisfy a
     proposition.  The accepted syntax is:

            (retrieve [<integer> | all]
                      [[{<vardecl> | (<vardecl>+)}]
                      <proposition>])

     The variables and proposition are similar to an `exists' sentence
     or `kappa' term without the explicit quantifier.  If variables are
     declared, they must match the free variables referenced by
     <proposition>.  Otherwise, the free variables referenced in
     <proposition> will be used as the query variables.  If
     <proposition> is omitted, the most recently asked query will be
     continued.

     A solution is a set of bindings for the listed variables for which
     <proposition> is true.  The optional first argument controls how
     many solutions should be generated before control is returned.
     The keyword `all' indicates that all solutions should be
     generated.  By default, `retrieve' returns after it has found one
     new solution or if it cannot find any more solutions.

     `retrieve' returns an iterator which saves all the necessary state
     of a query and stores all generated solutions.  When used
     interactively, the returned iterator will print out with the set
     of solutions collected so far.  Calling `retrieve' without any
     arguments (or only with the first argument) will generate one (or
     more) solutions to the most recently asked query.

     KIF examples:

            (retrieve (happy ?x))

     will try to find one happy entity and store it in the returned
     query iterator.

            (retrieve 10 (happy ?x))

     will try to find 10 happy entities.

            (retrieve 10)

     will try to find the next 10 happy entities..

            (retrieve all (happy ?x))

     will find all happy entities.

            (retrieve all (?x Person) (happy ?x))

     will to find all happy people.  Here we used the optional retrieve
     variable syntax to restrict the acceptable solutions.  The above
     is equivalent to the following query:

            (retrieve all (and (Person ?x) (happy ?x)))

     Similarly,

            (retrieve all (?x Person))
            (retrieve all (Person ?x))
            (retrieve all ?x (Person ?x))

     will find all people.  Note that in the first case we only specify
     a query variable and its type but omit the logic sentence which
     defaults to TRUE.  This somewhat impoverished looking query can be
     paraphrased as "retrieve all ?x of type Person such that TRUE."

            (retrieve ?x (or (happy ?x) (parent-of Fred ?x)))

     will try to find a person that is happy or has Fred as a parent.

            (retrieve (?y ?x) (parent-of ?x ?y))

     will try to find the one pair of parent/child and return it in the
     order of child/parent.

            (retrieve all (?x Person)
                      (exists (?y Person) (parent-of ?x ?y)))

     will generate the set of all parents.  Note, that for these
     queries to run, the class `Person', the relations `happy' and
     `parent-of', and the logic constant `Fred' must already be defined
     (see `assert').

     Use `(set/unset-feature trace-subgoals)' to en/disable goal
     tracing of the inference engine.

 -- Command: save-module ((name NAME) (file STRING)) :
     Save all definitions and assertions of module NAME to FILE.

 -- N-Command: set-feature (&rest (features NAME)) : (LIST OF KEYWORD)
     Enable the PowerLoom environment feature(s) named by FEATURES.
     Return the list of enabled features.  Calling `set-feature'
     without any arguments can be used to display the currently enabled
     features.  The following features are supported:

     `just-in-time-inference': Enables interleaving of forward chaining
     inference within backward chaining queries.

     `iterative-deepening': Tells the query processor to use iterative
     deepening instead of a depth-first search to find answers.  This
     is less efficient but necessary for some kinds of highly recursive
     queries.

     `trace-subgoals': Enables the generation of subgoaling trace
     information during backchaining inference.

     `trace-solutions': Prints newly found solutions during retrieval
     right when they are generated as opposed to when the query
     terminates.

     `trace-classifier': Tells the classifier to describe the
     inferences it draws.

     `justifications': Enables the generation of justifications during
     inference, which is a prerequiste for the generation of
     explanations with `(why)'.

     `emit-thinking-dots': Tells PowerLoom to annotate its inference
     progress by outputting characters indicating the completion of
     individual reasoning steps.

     By default, the features `emit-thinking-dots' and
     `just-in-time-inference' are enabled, and the others are disabled.


 -- Command: set-load-path ((path STRING)) : (CONS OF STRING-WRAPPER)
     Set the STELLA load path to the |-separated directories listed in
     PATH.  Return the resulting load path.

 -- N-Command: time-command ((command CONS)) : OBJECT
     Execute COMMAND, measure and report its CPU and elapsed time
     needed for its execution, and then return its result.

 -- N-Command: unset-feature (&rest (features NAME)) : (LIST OF KEYWORD)
     Disable the PowerLoom environment feature(s) named by FEATURES.
     Return the list of enabled features.  Calling `unset-feature'
     without any arguments can be used to display the currently enabled
     features.  See `set-feature' for a description of supported
     features.

 -- N-Command: why (&rest (args OBJECT)) :
     Print an explanation for the result of the most recent query.
     Without any arguments, `why' prints an explanation of the top level
     query proposition down to a maximum depth of 3.  `(why all)' prints
     an explanation to unlimited depth.  Alternatively, a particular
     depth can be specified, for example, `(why 5)' explains down to a
     depth of 5.  A proof step that was not explained explicitly (e.g.,
     due to a depth cutoff) can be explained by supplying the label of
     the step as the first argument to `why', for example, `(why 1.2.3
     5)' prints an explanation starting at 1.2.3 down to a depth of 5
     (which is counted relative to the depth of the starting point).
     The keywords `brief' and `verbose' can be used to select a
     particular explanation style.  In brief mode, explicitly asserted
     propositions are not further explained and indicated with a `!'
     assertion marker.  Additionally, relatively uninteresting proof
     steps such as AND-introductions are skipped.  This explanation
     style option is sticky and will affect future calls to `why' until
     it gets changed again.  The various options can be combined in any
     way, for example, `(why 1.2.3 brief 3)' explains starting from
     step 1.2.3 down to a depth of 3 in brief explanation mode.

   ---------- Footnotes ----------

   (1) Lisp programmers are typically spoiled, and find it inconvenient
to wrap double-quotes around their arguments.


File: manual.info,  Node: PowerLoom API,  Next: Built-In Relations,  Prev: Commands,  Up: Top

6 PowerLoom API
***************

This chapter lists functions that collectively define the PowerLoom
API.  The first section describes the API functions themselves.  The
signature is the basic Stella signature.  Information on how to
translate the names of the functions and their arguments into the
programming languages Common Lisp, C++ or Java is given in the Language
Specific Interface section.

* Menu:

* API Functions::
* Language Specific Interface::


File: manual.info,  Node: API Functions,  Next: Language Specific Interface,  Prev: PowerLoom API,  Up: PowerLoom API

6.1 API Functions
=================

Many of the functions take a `module' argument that causes the function
to be evaluated in the context of that module. Passing in a NULL value
for the module argument means that evaluation takes place in the
current module. The module argument is frequently followed by an
`environment' argument that specifies which inference environment
should be assumed during evaluation. Values for `environment' are
`ASSERTION-ENV', `TAXONOMIC-ENV', and `INFERENCE-ENV'.  `ASSERTION-ENV'
specifies that a knowledge base query or lookup should take into
account only explicitly asserted propositions. `TAXONOMIC-ENV'
specifies that a knowledge base query should take into account
explicitly-asserted propositions plus any rules that specify subsumption
relationships.   `INFERENCE-ENV' specifies that a knowledge base query
should take all relevant propositions into account, including those
generated during forward inferencing.  A NULL value for the
`environment' argument defaults to `TAXONOMIC-ENV'.

   Many of the functions that take PowerLoom or Stella objects as inputs
also have an analog version whose name starts with the prefix "s-" that
take strings as inputs.  This is provided as a convenience so that
programmers will not necessarily need to manipulate PowerLoom objects
directly.

 -- Function: ask ((query CONS) (module MODULE)
          (environment ENVIRONMENT)) : TRUTH-VALUE
     Returns a truth value for QUERY in MODULE and ENVIRONMENT.  QUERY
     has the same syntax as the PowerLoom `ask' command (which see) but
     with the `ask' operator omitted.  For example, here are some legal
     QUERY arguments:

              ((happy Fred))
              ((happy Fred) :inference-level :assertion)
              ((happy Fred) :inference-level :assertion :timeout 1.0)

     As a convenience, a QUERY argument whose first element is a symbol
     is interpreted as a sentence that is queried without any options.
     For example:

              (happy Fred)

     is a legal QUERY argument.  Note that for a sentence whose
     relation is a list itself, e.g., `((FruitFn BananaTree) MyBanana)'
     this shortcut is not available, that is, in that case an extra
     level of list nesting is always necessary.  The returned truth
     value represents the logical truth of the queried sentence as
     determined by PowerLoom.  It can be be tested via the functions
     `is-true', `is-false' and `is-unknown' (which see).

 -- Function: assert-binary-proposition ((relation LOGIC-OBJECT)
          (arg OBJECT) (value OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : PROPOSITION
     Assert that the proposition (RELATION ARG VALUE) is TRUE in
     MODULE.  Return the asserted proposition.

 -- Function: assert-nary-proposition ((relation-and-arguments OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : PROPOSITION
     Assert that the proposition represented by the list `
     relation-and-arguments' satisfies the relation `relation'.

 -- Function: assert-proposition ((proposition PROPOSITION)
          (module MODULE) (environment ENVIRONMENT)) : PROPOSITION
     Assert that the proposition PROPOSITION is true in MODULE.  Return
     the asserted proposition.

 -- Function: assert-unary-proposition ((relation LOGIC-OBJECT)
          (arg OBJECT) (module MODULE) (environment ENVIRONMENT)) :
          PROPOSITION
     Assert that the proposition (RELATION ARG) is TRUE in MODULE.
     Return the asserted proposition.

 -- Function: change-module ((module MODULE)) : MODULE
     Set the current module to MODULE and return it.  If MODULE is
     `null', then no switch is performed and the current module is
     returned.

 -- Function: clear-caches () :
     Clear all query and memoization caches.

 -- Function: clear-module ((module MODULE)) : MODULE
     Destroy the contents of the module MODULE as well as the contents
     of all of its children, recursively.

 -- Function: conceive ((sentence OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)
     Create one or more proposition objects from the sentence SENTENCE
     in the  module MODULE.  Return an iterator of the propositions.
     If any of the new propositions has the same structure as an
     already existing proposition, an automatic check for duplicates
     will return the pre-existing proposition.  Multiple propositions
     may be returned for a single sentence because of normalization of
     equivalences, conjunctions, etc.

     Signals a `Proposition-Error' if PowerLoom could not conceive
     SENTENCE.

 -- Function: cons-to-pl-iterator ((self CONS)) : PL-ITERATOR
     Convert a Stella cons list into an API iterator.

 -- Function: create-concept ((name STRING) (parent LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : LOGIC-OBJECT
     Create a concept named NAME in the designated MODULE, with the
     designated PARENT superconcept (which can be left undefined).
     Additional superconcepts can be added via assertions of the
     `subset-of' relation.  Note that a specified PARENT concept needs
     to be created separately.

     Note that because names in modules that are not case-sensitive are
     canonicalized, the name of the returned object may not match NAME
     exactly.

 -- Function: create-enumerated-list ((members CONS) (module MODULE)
          (environment ENVIRONMENT)) : LOGIC-OBJECT
     Create a logical term that denotes a list containing MEMBERS in
     MODULE using ENVIRONMENT.  Useful for passing lists as arguments
     to parameterized queries.

 -- Function: create-enumerated-set ((members CONS) (module MODULE)
          (environment ENVIRONMENT)) : LOGIC-OBJECT
     Create a logical term that denotes the enumerated set containing
     MEMBERS in MODULE using ENVIRONMENT.

 -- Function: create-function ((name STRING) (arity INTEGER)
          (module MODULE) (environment ENVIRONMENT)) : LOGIC-OBJECT
     Create a function named NAME with arity ARITY  in the designated
     MODULE.  Domain and range information can be added via assertions
     of `nth-domain' (or `domain' and `range') relations.

     Note that because names in modules that are not case-sensitive are
     canonicalized, the name of the returned object may not match NAME
     exactly.

 -- Function: create-module ((name STRING) (parent MODULE)
          (case-sensitive? BOOLEAN)) : MODULE
     Creates a new module NAME as a child of PARENT.  The flag
     CASE-SENSITIVE? controls whether names read in this module will be
     case sensitive or not.

 -- Function: create-object ((name STRING) (concept LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : LOGIC-OBJECT
     Create an object named NAME of type CONCEPT in the designated
     module.  Both NAME and CONCEPT can be `null'.  If NAME is `null'
     then an object will be created with a new, non-conflicting name
     based on the name of CONCEPT, or system-generated if no concept is
     specified.  If CONCEPT is `null', then the object will be of type
     THING.  It is an error to create an object with the same name as
     an existing object.

     Note that the string can be a qualified name, in which case the
     object will be created in the module specified, but with a name as
     determined by the qualified name.  Vertical bars in the name
     string are interpreted as Stella escape characters.

     Note that because names in modules that are not case-sensitive are
     canonicalized, the name of the returned object may not match NAME
     exactly.

     Return the object.

 -- Function: create-relation ((name STRING) (arity INTEGER)
          (module MODULE) (environment ENVIRONMENT)) : LOGIC-OBJECT
     Create a relation named NAME with arity ARITY in the designated
     module.  Domain and range information can be added via assertions
     of `nth-domain' (or `domain' and `range') relations.

     Note that because names in modules that are not case-sensitive are
     canonicalized, the name of the returned object may not match NAME
     exactly.

 -- Function: destroy-object ((object OBJECT)) :
     Delete the object OBJECT, retracting all facts attached to it.

 -- Method on PL-ITERATOR: empty? (self) : BOOLEAN
     Return TRUE if the iterator SELF has no more elements.

 -- Function: evaluate ((command OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : OBJECT
     Evaluate the command COMMAND within MODULE and return the result.
     Currently, only the evaluation of (possibly nested) commands and
     global variables is supported.  Commands are simple to program in
     Common Lisp, since they are built into the language, and
     relatively awkward in Java and C++.  Users of either of those
     languages are more likely to want to call `s-evaluate'.

 -- Function: generate-unique-name ((prefix STRING) (module MODULE)
          (environment ENVIRONMENT)) : STRING
     Generates a name based on PREFIX with a number appended that is
     not currently in use in `module.'  In a non-case-sensitive module,
     the returned name will be all upper case (This latter feature may
     change!)

 -- Function: get-arity ((relation LOGIC-OBJECT)) : INTEGER
     Return the arity of the relation RELATION.

 -- Function: get-binary-proposition ((relation LOGIC-OBJECT)
          (arg1 OBJECT) (arg2 OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : PROPOSITION
     Return a proposition such that (RELATION ARG1 ARG2) is true.  The
     RELATION argument must be bound to a relation.  One or both of the
     ARG1 and ARG2 arguments may be set to NULL, which is interpreted
     as a wildcard. If more than one proposition matches the input
     criteria, the selection is arbitrary.  This procedure is normally
     applied to single-valued relations or functions.

 -- Function: get-binary-propositions ((relation LOGIC-OBJECT)
          (arg1 OBJECT) (arg2 OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)
     Return propositions such that (RELATION ARG1 ARG2) is true.  The
     RELATION argument must be bound to a relation.  One or both of the
     ARG1 and ARG2 arguments may be set to NULL, which is interpreted
     as a wildcard.

 -- Function: get-child-modules ((module MODULE)) : (PL-ITERATOR OF
          MODULE)
     Return the modules that are immediate children of MODULE.

 -- Function: get-column-count ((obj OBJECT)) : INTEGER
     Return the number of columns in OBJ, which must be of type
     proposition, cons, vector or PL-iterator.  For a proposition, the
     number includes both the predidate and arguments. For the
     PL-iterator case,the number of columns is for the current value of
     the iterator.

     For a null item, the column count is zero.  For non sequence
     objects, the column count is one.

 -- Function: get-concept ((name STRING) (module MODULE)
          (environment ENVIRONMENT)) : LOGIC-OBJECT
     Return a class/concept named NAME that is local to or visible from
     the module MODULE.

 -- Function: get-concept-instance-matching-value
          ((concept LOGIC-OBJECT) (relation LOGIC-OBJECT)
          (value OBJECT) (module MODULE) (environment ENVIRONMENT)) :
          OBJECT
     Return a member of concept CONCEPT that has an attribute matching
     VALUE for the binary relation RELATION, i.e., `(relation <result>
     value)' holds.

 -- Function: get-concept-instances ((concept LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : PL-ITERATOR
     Return instances of the concept CONCEPT.  Include instances of
     subconcepts of CONCEPT.  Depending on CONCEPT, the return values
     could be (wrapped) literals.

 -- Function: get-concept-instances-matching-value
          ((concept LOGIC-OBJECT) (relation LOGIC-OBJECT)
          (value OBJECT) (module MODULE) (environment ENVIRONMENT)) :
          PL-ITERATOR
     Return members of concept CONCEPT that have an attribute matching
     VALUE for the binary relation RELATION, i.e., `(relation <result>
     value)' holds.

 -- Function: get-current-module ((environment ENVIRONMENT)) : MODULE
     Return the currently set module

 -- Function: get-direct-concept-instances ((concept LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : PL-ITERATOR
     Return instances of concept CONCEPT.  Exclude instances of
     subconcepts of CONCEPT.  Depending on CONCEPT, the return values
     could be (wrapped) literals.

 -- Function: get-direct-subrelations ((relation LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF
          LOGIC-OBJECT)
     Return relations that directly specialize RELATION.  Non-reflexive.

 -- Function: get-direct-superrelations ((relation LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF
          LOGIC-OBJECT)
     Return relations that directly generalize RELATION.  Non-reflexive.

 -- Function: get-direct-types ((object LOGIC-OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : (PL-ITERATOR OF LOGIC-OBJECT)
     Return most specific concepts that OBJECT belongs to.

 -- Function: get-domain ((relation LOGIC-OBJECT)) : LOGIC-OBJECT
     Return the type (a concept) for the first argument to the binary
     relation RELATION.

 -- Function: get-enumerated-collection-members ((collection OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : CONS
     Returns the members of an enumerated collection.  This works on
     all types of collection, i.e., sets and lists

 -- Function: get-home-module ((object LOGIC-OBJECT)) : MODULE
     Return the module in which OBJECT was created.

 -- Function: get-inferred-binary-proposition-values
          ((relation LOGIC-OBJECT) (arg OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : PL-ITERATOR
     Return all values `v' such that (RELATION ARG `v') has been
     asserted or can be inferred.

 -- Function: get-module ((name STRING) (environment ENVIRONMENT)) :
          MODULE
     Return a module named NAME.

 -- Function: get-modules ((kb-modules-only? BOOLEAN)) : (PL-ITERATOR
          OF MODULE)
     Return all modules currently loaded into PowerLoom.  If
     KB-MODULES-ONLY?  is `true', then Stella modules that are used
     only for program code are not included in the list.

 -- Function: get-name ((obj OBJECT)) : STRING
     Return the fully qualified name of OBJ, if it has one.  Otherwise
     return `null'.

 -- Function: get-nth-domain ((relation LOGIC-OBJECT) (n INTEGER)) :
          LOGIC-OBJECT
     Return the type (a concept) for the the nth argument of the
     relation RELATION.  Counting starts at zero.  NOTE: if there are
     multiple `nth-domain' propositions for RELATION, this arbitrarily
     returns one of them; it does not look for the most specific one
     (which might have to be created).

 -- Function: get-nth-float ((sequence OBJECT) (n INTEGER)
          (module MODULE) (environment ENVIRONMENT)) : FLOAT
     Return the floating point value in the `nth' column of SEQUENCE.
     Counting starts at zero.  SEQUENCE must be of type proposition,
     cons, vector or PL-iterator.  A zero column number returns a
     proposition's relational predicate.  For the PL-iterator case, the
     the current value pointed to by the iterator is used.  If this is
     not a floating point value, then an exception will be thrown.

     As a special case, a column number of zero will also return the
     floating point value of SEQUENCE itself if it is not one of the
     types enumerated above.  This allows the use of `get-nth-float' on
     PL-iterators with only a single return variable.    If  SEQUENCE
     cannot be turned into a floating point value, an exception will be
     thrown.

 -- Function: get-nth-integer ((sequence OBJECT) (n INTEGER)
          (module MODULE) (environment ENVIRONMENT)) : INTEGER
     Return an integer representation of the value in the `nth' column
     of SEQUENCE. Counting starts at zero.   Unless N is zero, SEQUENCE
     must be of type proposition, cons, vector or PL-iterator.  A zero
     column number returns a proposition's relational predicate.  For
     the PL-iterator case, the the current value pointed to by the
     iterator is used.  If this is not an integer value, then an
     exception will be thrown.

     As a special case, a column number of zero will also return the
     integer value of SEQUENCE itself if it is not one of the types
     enumerated above.   This allows the use of `get-nth-integer' on
     PL-iterators with only a single return variable.  If  SEQUENCE
     cannot be turned into an integer, an exception will be thrown.

 -- Function: get-nth-logic-object ((sequence OBJECT) (n INTEGER)
          (module MODULE) (environment ENVIRONMENT)) : LOGIC-OBJECT
     Return a logic object representation of the value in the `nth'
     column of SEQUENCE.  Counting starts at zero.   Unless N is zero,
     SEQUENCE must be of type proposition, cons, vector or PL-iterator.
     A zero column number returns a proposition's relational predicate.
     For the PL-iterator case, the the current value pointed to by the
     iterator is used.  A zero column number returns the proposition's
     relational predicate.  If the return value is not a LOGIC-OBJECT,
     an exception is thrown.

     As a special case, a column number of zero will also return
     SEQUENCE itself if it is not one of the types enumerated above.
     This is done to allow the use of `get-nth-value' on PL-iterators
     with only a single return variable.  If SEQUENCE is not a
     LOGIC-OBJECT, an exception is thrown.

 -- Function: get-nth-string ((sequence OBJECT) (n INTEGER)
          (module MODULE) (environment ENVIRONMENT)) : STRING
     Return a string representation of the value in the `nth' column of
     SEQUENCE. Counting starts at zero.   Unless N is zero, SEQUENCE
     must be of type proposition, cons, vector or PL-iterator.  A zero
     column number returns a proposition's relational predicate.  For
     the PL-iterator case, the the current value pointed to by the
     iterator is used.  This will always succeed, even if the `nth'
     value is not a string object.  In that case, a string
     reprensentation will be returned.

     As a special case, a column number of zero will also return
     SEQUENCE itself as a string if it is not one of the types
     enumerated above.  This is done to allow the use of
     `get-nth-string' on PL-iterators with only a single return
     variable.

 -- Function: get-nth-value ((sequence OBJECT) (n INTEGER)
          (module MODULE) (environment ENVIRONMENT)) : OBJECT
     Return the value in the `nth' column of SEQUENCE.  Counting starts
     at zero.  Unless N is zero, SEQUENCE must be of type proposition,
     cons, vector or PL-iterator.  A zero column number returns a
     proposition's relational predicate.  For the PL-iterator case, the
     number of columns is for the current value of the iterator.

     As a special case, a column number of zero will also return
     SEQUENCE itself if it is not one of the types enumerated above.
     This is done to allow the use of `get-nth-value' on PL-iterators
     with only a single return variable.

 -- Function: get-operator ((name STRING)) : SYMBOL
     Returns the logical operator object (a Stella SYMBOL) for NAME.
     If no such operator exists then a `no-such-object' exception is
     thrown.

 -- Function: get-object ((name STRING) (module MODULE)
          (environment ENVIRONMENT)) : OBJECT
     Look for an object named NAME that is local to or visible from the
     module MODULE.

 -- Function: get-parent-modules ((module MODULE)) : (PL-ITERATOR OF
          MODULE)
     Return the modules that are immediate parents of MODULE.

 -- Function: get-predicate ((prop PROPOSITION)) : LOGIC-OBJECT
     Return the concept or relation predicate for the proposition PROP.

 -- Function: get-proper-subrelations ((relation LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF
          LOGIC-OBJECT)
     Return relations that specialize RELATION.  Non-reflexive.

 -- Function: get-proper-superrelations ((relation LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF
          LOGIC-OBJECT)
     Return relations that generalize RELATION.  Non-reflexive.

 -- Function: get-proposition ((relation-and-arguments OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : PROPOSITION
     Return a proposition matching RELATION-AND-ARGUMENTS that has been
     asserted (or inferred by forward chaining).  RELATION-AND-ARGUMENTS
     is a sequence containing objects and nulls.  The first argument
     must be the name of a relation.  A null value acts like a wild
     card.  If more than one proposition matches the input criteria,
     the selection among satisficing propositions is arbitrary.  This
     procedure is normally applied to single-valued relations or
     functions.

 -- Function: get-propositions ((relation-and-arguments OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF
          PROPOSITION)
     Return propositions matching RELATION-AND-ARGUMENTS that have been
     asserted (or inferred by forward chaining).  RELATION-AND-ARGUMENTS
     is a sequence containing objects and nulls.  The first argument
     must be the name of a relation.  A null value acts like a wild
     card.

 -- Function: get-propositions-in-module ((module MODULE)
          (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)
     Return propositions that have been conceived in the module MODULE.

 -- Function: get-propositions-of ((object LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF
          PROPOSITION)
     Return all propositions that have OBJECT among their arguments,
     and that are TRUE in the scope of the module MODULE.

 -- Function: get-range ((relation LOGIC-OBJECT)) : LOGIC-OBJECT
     Return the type (a concept) for fillers of the binary relation
     RELATION.

 -- Function: get-relation ((name STRING) (module MODULE)
          (environment ENVIRONMENT)) : LOGIC-OBJECT
     Return a concept or relation named NAME that is local to or
     visible from the module MODULE.

 -- Function: get-relation-extension ((relation LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF
          PROPOSITION)
     Return propositions that satisfy RELATION.  Include propositions
     that satisfy subrelations of RELATION.

 -- Function: get-rules ((relation LOGIC-OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)
     Return rules attached to the concept/relation RELATION in either
     antecedent or consequent position.

 -- Function: get-types ((object LOGIC-OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : (PL-ITERATOR OF LOGIC-OBJECT)
     Return all named concepts that OBJECT belongs to.

 -- Function: initialize () :
     Initialize the PowerLoom logic system.  This function needs to be
     called by all applications before using PowerLoom.  If it is
     called more than once, every call after the first one is a no-op.

 -- Function: is-a ((object OBJECT) (concept LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : BOOLEAN
     Return TRUE if OBJECT is a member of the concept CONCEPT.

 -- Function: is-default ((tv TRUTH-VALUE)) : BOOLEAN
     Tests whether TV is a default truth value.

 -- Function: is-enumerated-collection ((obj OBJECT)) : BOOLEAN
     Test whether OBJ is an enumerated collection.  This subsumes both
     sets and lists.

 -- Function: is-enumerated-list ((obj OBJECT)) : BOOLEAN
     Test whether OBJ is an enumerated list

 -- Function: is-enumerated-set ((obj OBJECT)) : BOOLEAN
     Test whether OBJ is an enumerated set.

 -- Function: is-false ((tv TRUTH-VALUE)) : BOOLEAN
     Tests whether TV is a false truth value.  It can be false either
     absolutely or by default.

 -- Function: is-float ((obj OBJECT)) : BOOLEAN
     Test whether OBJ is of type FLOAT (double)

 -- Function: is-inconsistent ((tv TRUTH-VALUE)) : BOOLEAN
     Tests whether TV is an inconsistent truth value.

 -- Function: is-integer ((obj OBJECT)) : BOOLEAN
     Test whether OBJ is of type INTEGER

 -- Function: is-logic-object ((obj OBJECT)) : BOOLEAN
     Test whether OBJ is of type LOGIC-OBJECT

 -- Function: is-number ((obj OBJECT)) : BOOLEAN
     Test whether OBJ is of type NUMBER.  This can be either an integer
     or a floating point number.  One key characteristic is that
     `object-to-integer' and `object-to-float' will both work on it.

 -- Function: is-strict ((tv TRUTH-VALUE)) : BOOLEAN
     Tests whether TV is a strict (non-default) truth value.

 -- Function: is-string ((obj OBJECT)) : BOOLEAN
     Test whether OBJ is of type STRING

 -- Function: is-subrelation ((sub LOGIC-OBJECT) (super LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : BOOLEAN
     Return TRUE if SUB is a subconcept/subrelation of SUPER.

 -- Function: is-true ((tv TRUTH-VALUE)) : BOOLEAN
     Tests whether TV is a true truth value.  It can be true either
     absolutely or by default.

 -- Function: is-true-binary-proposition ((relation LOGIC-OBJECT)
          (arg OBJECT) (value OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : BOOLEAN
     Return TRUE if the proposition (RELATION ARG VALUE) has been
     asserted (or inferred by forward chaining).

 -- Function: is-true-proposition ((proposition PROPOSITION)
          (module MODULE) (environment ENVIRONMENT)) : BOOLEAN
     Return TRUE if PROPOSITION is  TRUE in the module MODULE.

 -- Function: is-true-unary-proposition ((relation LOGIC-OBJECT)
          (arg OBJECT) (module MODULE) (environment ENVIRONMENT)) :
          BOOLEAN
     Return TRUE if the proposition (RELATION ARG) has been asserted
     (or inferred by forward chaining).

 -- Function: is-unknown ((tv TRUTH-VALUE)) : BOOLEAN
     Tests whether TV is an unknown truth value.

 -- Function: iterator-to-pl-iterator ((self ITERATOR)) : PL-ITERATOR
     Convert an arbitrary Stella iterator into an API iterator.

 -- Method on PL-ITERATOR: length (self) : INTEGER
     Number of items remaining in SELF.  Non destructive.

 -- Function: list-to-pl-iterator ((self LIST)) : PL-ITERATOR
     Convert a Stella list into an API iterator.

 -- Function: load ((filename STRING) (environment ENVIRONMENT)) :
     Read logic commands from the file named FILENAME and evaluate them.
     The file should contain an `in-module' declaration that specifies
     the module within which all remaining commands are to be
     evaluated.  The remaining commands are evaluated one-by-one,
     applying the function `evaluate' to each of them.

 -- Function: load-stream ((stream INPUT-STREAM)
          (environment ENVIRONMENT)) :
     Read logic commands from the STELLA stream STREAM and evaluate
     them.  The stream should contain an `in-module' declaration that
     specifies the module within which all remaining commands are to be
     evaluated.  The remaining commands are evaluated one-by-one,
     applying the function `evaluate' to each of them.

 -- Function: load-native-stream ((stream NATIVE-INPUT-STREAM)
          (environment ENVIRONMENT)) :
     Read logic commands from the native input stream STREAM and
     evaluate them.  Assumes STREAM is a line-buffered stream which is
     a safe compromise but does not generate the best efficiency for
     block-buffered streams such as files.  The stream should begin
     with an `in-module' declaration that specifies the module within
     which all remaining commands are to be evaluated The remaining
     commands are evaluated one-by-one, applying the function
     `evaluate' to each of them.

 -- Method on PL-ITERATOR: next? (self) : BOOLEAN
     Advance the PL-Iterator SELF and return `true' if more elements
     are available, `false' otherwise.

 -- Function: object-to-float ((self OBJECT)) : FLOAT
     Coerce SELF to a float, or throw a Stella Exception if the
     coersion is not feasible.

 -- Function: object-to-integer ((self OBJECT)) : INTEGER
     Coerce SELF to an integer, or throw a Stella Exception if the
     coersion is not feasible.  Floating point values will be coerced
     by rounding.

 -- Function: object-to-parsable-string ((self OBJECT)) : STRING
     Return a string representing a printed representation of the
     object SELF.  Like `object-to-string', but puts escaped double
     quotes around strings.

 -- Function: object-to-string ((self OBJECT)) : STRING
     Return a printed representation of the term SELF as a string.

 -- N-Command: print-rules ((relation OBJECT)) :
     Print the list of true rules associated with RELATION.

 -- Function: reset-powerloom () :
     Reset PowerLoom to its initial state.  CAUTION: This will destroy
     all loaded knowledge bases and might break other loaded STELLA
     systems if they do reference PowerLoom symbols in their code.

 -- N-Command: retract ((proposition PARSE-TREE)) : OBJECT
     Retract the truth of PROPOSITION.  Return the retracted proposition
     object.  KIF example:  "(retract (happy Fred))" retracts that Fred
     is happy.  Note that for this assertion to succeed, the relation
     `happy' must already be defined.  If the constant `Fred' has not
     yet been created, it is automatically created as a side-effect of
     calling `retract'.

 -- Function: retract-binary-proposition ((relation LOGIC-OBJECT)
          (arg OBJECT) (value OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : PROPOSITION
     Retract that the proposition (RELATION ARG VALUE) is TRUE in
     MODULE.  Return the asserted proposition.

 -- Function: retract-nary-proposition ((relation-and-arguments OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : PROPOSITION
     Retract the proposition that `arguments' satisfies the relation
     `relation'.

 -- Function: retract-proposition ((proposition PROPOSITION)
          (module MODULE) (environment ENVIRONMENT)) : PROPOSITION
     Retract the truth of the proposition PROPOSITION in MODULE.
     Return the retracted proposition.

 -- Function: retract-unary-proposition ((relation LOGIC-OBJECT)
          (arg OBJECT) (module MODULE) (environment ENVIRONMENT)) :
          PROPOSITION
     Retract that the proposition (RELATION ARG) is TRUE in MODULE.
     Return the asserted proposition.

 -- Function: retrieve ((query CONS) (module MODULE)
          (environment ENVIRONMENT)) : PL-ITERATOR
     Returns an iterator of variable bindings that when substituted for
     the open variables in QUERY satisfy the query proposition.  The
     query is run in MODULE and relative to ENVIRONMENT.  QUERY has the
     same syntax as the PowerLoom `retrieve' command (which see) but
     with the `retrieve' operator omitted.    For example, here are
     some legal QUERY arguments:

              ((happy ?x))
              (10 (happy ?x))
              (all (happy ?x))
              (all ?x (happy ?x))
              (10 (happy ?x) :inference-level :assertion)
              (10 (happy ?x) :inference-level :assertion :timeout 1.0)

     If there is only a single output variable (as in all the examples
     above) each element generated by the returned iterator will be a
     binding for that variable - unless, the output variable was
     declared with a surrounding pair of parentheses.  For example:

              (all (?x) (happy ?x))

     In that case, the generated elements will be one-element lists.
     If there are multiple output variables, each element generated by
     the returned iterator will be a list of variable bindings that can
     be accessed using the various `get-nth-...' functions.  The list
     of output variables does not need to be declared in which case
     they are taken to be the open variables in the query proposition
     in the order in which they were encountered.  If order does matter
     or should be different from its default, it can be forced by
     declaring the set of output variables.

 -- Function: run-forward-rules ((module OBJECT) (force? BOOLEAN)) :
     Run forward inference rules in module MODULE.  If MODULE is NULL,
     the current module will be used.  If forward inferencing is
     already up-to-date in the designated module, no additional
     inferencing will occur, unless `force' is set to TRUE, in which
     case all forward rules are run or rerun.

     Calling `run-forward-rules' temporarily puts the module into a
     mode where future assertional (monotonic) updates will trigger
     additional forward inference.  Once a non-monotonic update is
     performed, i.e., a retraction or clipping of relation value, all
     cached forward inferences will be discarded and forward
     inferencing will be disabled until this function is called again.

 -- Function: s-ask ((query STRING) (module-name STRING)
          (environment ENVIRONMENT)) : TRUTH-VALUE
     Returns a truth value for QUERY in module MODULE-NAME and
     ENVIRONMENT.  QUERY has the same syntax as the PowerLoom `ask'
     command (which see) but with the `ask' operator omitted.
     Different from the PLI `ask' function, `s-ask' does not expect a
     top-level pair of parentheses.  For example, here are some legal
     QUERY arguments:

              "(happy Fred)"
              "(happy Fred) :inference-level :assertion"
              "(happy Fred) :inference-level :assertion :timeout 1.0"

     Names in QUERY will be interpreted relative to module MODULE-NAME.
     A null MODULE-NAME or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a STELLA `no-such-context-exception' is thrown.  The returned
     truth value represents the logical truth of the queried sentence
     as determined by PowerLoom.  It can be be tested via the functions
     `is-true', `is-false' and `is-unknown' (which see).

 -- Function: s-assert-proposition ((sentence STRING)
          (module-name STRING) (environment ENVIRONMENT)) :
          (PL-ITERATOR OF PROPOSITION)
     Assert that the logical sentence SENTENCE is true in the module
     named MODULE-NAME.  A module name of `null' or the empty string
     refers to the current module.  If no module can be found with the
     name MODULE-NAME, then a Stella `no-such-context-exception' is
     thrown.

     Return an iterator of the propositions resulting from sentence.

 -- Function: s-change-module ((name STRING) (environment ENVIRONMENT))
          : MODULE
     Set the current module to the module named NAME.  The return value
     is the module named NAME unless NAME is null or the empty string.
     In that case, the current module is returned.  If no module named
     NAME exists, a Stella `no-such-context-exception' is thrown.

 -- Function: s-clear-module ((name STRING) (environment ENVIRONMENT))
          : MODULE
     Destroy the contents of the module named NAME, as well as the
     contents of all of its children, recursively.  If no module named
     NAME exists, a Stella `no-such-context-exception' is thrown.

 -- Function: s-conceive ((sentence STRING) (module-name STRING)
          (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)
     Create one or more proposition objects from the sentence SENTENCE
     in the  module named MODULE-NAME.  Return an iterator of the
     propositions.  If any of the new propositions has the same
     structure as an already existing proposition, an automatic check
     for duplicates will return the pre-existing proposition.  Multiple
     propositions may be returned for a single sentence because of
     normalization of equivalences, conjunctions, etc.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `No-Such-Context-Exception' is thrown.

     Signals a `Proposition-Error' if PowerLoom could not conceive
     SENTENCE.

 -- Function: s-create-concept ((name STRING) (parent-name STRING)
          (module-name STRING) (environment ENVIRONMENT)) : LOGIC-OBJECT
     Create a concept named NAME in the designated module, with with
     the concept named PARENT-NAME as superconcept (which can be left
     undefined).  Additional superconcepts can be added via assertions
     of the `subset-of' relation.  Note that a specified parent concept
     needs to be created separately.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

     Note that because names in modules that are not case-sensitive are
     canonicalized, the name of the returned object may not match NAME
     exactly.

 -- Function: s-create-function ((name STRING) (arity INTEGER)
          (module-name STRING) (environment ENVIRONMENT)) : LOGIC-OBJECT
     Create a function named NAME with arity ARITY in the designated
     module.  Domain and range information can be added via assertions
     of `domain', `nth-domain' and `range' relations.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

     Note that because names in modules that are not case-sensitive are
     canonicalized, the name of the returned object may not match NAME
     exactly.

 -- Function: s-create-object ((name STRING) (concept-name STRING)
          (module-name STRING) (environment ENVIRONMENT)) : LOGIC-OBJECT
     Create an object named NAME of type CONCEPT-NAME in the designated
     module.  Both NAME and CONCEPT-NAME can be null strings.  If NAME
     is a null string then an object will be created with a new,
     non-conflicting name based on CONCEPT-NAME, or system-generated if
     no concept nameis specified.  If CONCEPT-NAME is the null string,
     then the object will be of type THING.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

     Note that because names in modules that are not case-sensitive are
     canonicalized, the name of the returned object may not match NAME
     exactly.

     Return the object.

 -- Function: s-create-module ((name STRING) (parent-name STRING)
          (case-sensitive? BOOLEAN) (environment ENVIRONMENT)) : MODULE
     Creates a new module NAME as a child of PARENT-NAME.  The flag
     CASE-SENSITIVE? controls whether names read in this module will be
     case sensitive or not.

 -- Function: s-create-relation ((name STRING) (arity INTEGER)
          (module-name STRING) (environment ENVIRONMENT)) : LOGIC-OBJECT
     Create a relation named NAME with arity ARITY in the designated
     module.  Domain and range information can be added via assertions
     of `nth-domain' (or `domain' and `range') relations.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

     Note that because names in modules that are not case-sensitive are
     canonicalized, the name of the returned object may not match NAME
     exactly.

 -- Function: s-destroy-object ((object-name STRING)
          (module-name STRING) (environment ENVIRONMENT)) :
     Delete the object named OBJECT-NAME, retracting all facts attached
     to it.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 -- Function: s-evaluate ((command STRING) (module-name STRING)
          (environment ENVIRONMENT)) : OBJECT
     Evaluate the command represented by the string COMMAND within
     `module' and return the result.  Currently, only the evaluation of
     (possibly nested) commands and global variables is supported.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 -- Function: s-get-arity ((relation-name STRING) (module-name STRING)
          (environment ENVIRONMENT)) : INTEGER
     Return the arity of the relation named RELATION-NAME.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 -- Function: s-get-child-modules ((name STRING)
          (environment ENVIRONMENT)) : (PL-ITERATOR OF MODULE)
     Return the modules that are immediate children of module NAME.  If
     no module named NAME exists, a Stella `no-such-context-exception'
     is thrown.

 -- Function: s-get-concept ((name STRING) (module-name STRING)
          (environment ENVIRONMENT)) : LOGIC-OBJECT
     Return a class/concept named NAME that is local to or visible from
     the module MODULE-NAME.  A module name of `null' or the empty
     string refers to the current module.  If no module can be found
     with the name MODULE-NAME, then a Stella
     `no-such-context-exception' is thrown.

 -- Function: s-get-concept-instances ((concept-name STRING)
          (module-name STRING) (environment ENVIRONMENT)) : PL-ITERATOR
     Return instances of concept CONCEPT-NAME.  Include instances of
     subconcepts of CONCEPT-NAME.  Depending on CONCEPT-NAME, the
     return values could be (wrapped) literals.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 -- Function: s-get-direct-concept-instances ((concept-name STRING)
          (module-name STRING) (environment ENVIRONMENT)) : PL-ITERATOR
     Return instances of concept CONCEPT-NAME.  Exclude instances of
     subconcepts of CONCEPT-NAME.  Depending on CONCEPT-NAME, the
     return values could be (wrapped) literals.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 -- Function: s-get-domain ((relation-name STRING) (module-name STRING)
          (environment ENVIRONMENT)) : LOGIC-OBJECT
     Return the type (concept) for the first argument to the binary
     relation RELATION-NAME.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 -- Function: s-get-inferred-binary-proposition-values
          ((relation-name STRING) (arg-name STRING)
          (module-name STRING) (environment ENVIRONMENT)) : PL-ITERATOR
     Return all values `v' such that (RELATION-NAME ARG-NAME `v') has
     been asserted or can be inferred.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 -- Function: s-get-nth-domain ((relation-name STRING) (n INTEGER)
          (module-name STRING) (environment ENVIRONMENT)) : LOGIC-OBJECT
     Return the type (a concept) for the nth argument of the relation
     named RELATION-NAME.  Counting starts at zero.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 -- Function: s-get-object ((name STRING) (module-name STRING)
          (environment ENVIRONMENT)) : OBJECT
     Look for an object named NAME that is local to or visible from the
     module MODULE-NAME.  A module name of `null' or the empty string
     refers to the current module.  If no module can be found with the
     name MODULE-NAME, then a Stella `no-such-context-exception' is
     thrown.

 -- Function: s-get-parent-modules ((name STRING)
          (environment ENVIRONMENT)) : (PL-ITERATOR OF MODULE)
     Return the modules that are immediate parents of module NAME.  If
     no module named NAME exists, a Stella `no-such-context-exception'
     is thrown.

 -- Function: s-get-parent-modules ((name STRING)
          (environment ENVIRONMENT)) : (PL-ITERATOR OF MODULE)
     Return the modules that are immediate parents of module NAME.  If
     no module named NAME exists, a Stella `no-such-context-exception'
     is thrown.

 -- Function: s-get-proposition ((relation-and-arguments STRING)
          (module-name STRING) (environment ENVIRONMENT)) : PROPOSITION
     Return a proposition matching RELATION-AND-ARGUMENTS that has been
     asserted (or inferred by forward chaining).  RELATION-AND-ARGUMENTS
     is a string that begins with a left parenthesis, followed by a
     relation name, one or more argument identifiers, and terminated by
     a right parenthesis.  Each argument identifier can be the name of
     a logical constant, a literal reference (e.g., a number), the null
     identifier, or a variable (an identifier that begins with a
     question mark). Each occurrence of a null or a variable acts like
     a wild card.  If more than one proposition matches the input
     criteria, the selection among satisficing propositions is
     arbitrary.  This procedure is normally applied to single-valued
     relations or functions.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 -- Function: s-get-propositions ((relation-and-arguments STRING)
          (module-name STRING) (environment ENVIRONMENT)) :
          (PL-ITERATOR OF PROPOSITION)
     Return propositions matching RELATION-AND-ARGUMENTS that have been
     asserted (or inferred by forward chaining).  RELATION-AND-ARGUMENTS
     is a string that begins with a left parenthesis, followed by a
     relation name, one or more argument identifiers, and terminated by
     a right parenthesis.  Each argument identifier can be the name of
     a logical constant, a literal reference (e.g., a number), the null
     identifier, or a variable (an identifier that begins with a
     question mark). Each occurrence of a null or a variable acts like
     a wild card.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 -- Function: s-get-propositions-of ((object-name STRING)
          (module-name STRING) (environment ENVIRONMENT)) :
          (PL-ITERATOR OF PROPOSITION)
     Return all propositions that have the object named OBJECT-NAME
     among their arguments, and that are TRUE in the scope of the
     module MODULE-NAME.  A module name of `null' or the empty string
     refers to the current module.  If no module can be found with the
     name MODULE-NAME, then a Stella `no-such-context-exception' is
     thrown.

 -- Function: s-get-range ((relation-name STRING) (module-name STRING)
          (environment ENVIRONMENT)) : LOGIC-OBJECT
     Return the type (a concept) for fillers of the binary relation
     RELATION-NAME.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 -- Function: s-get-relation ((name STRING) (module-name STRING)
          (environment ENVIRONMENT)) : LOGIC-OBJECT
     Return a concept or relation named NAME that is local to or
     visible from the module MODULE-NAME.  A module name of `null' or
     the empty string refers to the current module.  If no module can
     be found with the name MODULE-NAME, then a Stella
     `no-such-context-exception' is thrown.

 -- Function: s-get-relation-extension ((relation-name STRING)
          (module MODULE) (environment ENVIRONMENT)) : (PL-ITERATOR OF
          PROPOSITION)
     Return propositions that satisfy the relation named RELATION-NAME.
     Include propositions that satisfy subrelations of the relation.

 -- Function: s-get-rules ((relation-name STRING) (module-name STRING)
          (environment ENVIRONMENT)) : (PL-ITERATOR OF PROPOSITION)
     Return rules attached to the concept/relation named RELATION-NAME
     found in the module named MODULE-NAME.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `No-Such-Context-Exception' is thrown.

 -- Function: s-is-true-proposition ((relation-and-arguments STRING)
          (module-name STRING) (environment ENVIRONMENT)) : BOOLEAN
     Return TRUE if a proposition that prints as the string
     RELATION-AND-ARGUMENTS is true in the module named MODULE-NAME.  A
     module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 -- Function: s-print-rules ((name STRING) (stream OUTPUT-STREAM)
          (module-name STRING) (environment ENVIRONMENT)) :
     Print rules attached to the concept/relation named NAME.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 -- Function: s-retract-proposition ((sentence STRING)
          (module-name STRING) (environment ENVIRONMENT)) :
          (PL-ITERATOR OF PROPOSITION)
     Retract the truth of the logical sentence SENTENCE in the module
     named MODULE-NAME.  A module name of `null' or the empty string
     refers to the current module.  If no module can be found with the
     name MODULE-NAME, then a Stella `no-such-context-exception' is
     thrown.

     Return an iterator of the retracted propositions resulting from
     sentence.

 -- Function: s-retrieve ((query STRING) (module-name STRING)
          (environment ENVIRONMENT)) : PL-ITERATOR
     Returns an iterator of variable bindings that when substituted for
     the open variables in QUERY satisfy the query proposition.  The
     query is run in `module' and relative to ENVIRONMENT.  QUERY has
     the same syntax as the PowerLoom `retrieve' command (which see)
     but with the `retrieve' operator omitted.  Different from the PLI
     `retrieve' function, `s-retrieve' does not expect a top-level pair
     of parentheses.  For example, here are some legal QUERY arguments:

              "(happy ?x)"
              "10 (happy ?x)"
              "all (happy ?x)"
              "all ?x (happy ?x)"
              "10 (happy ?x) :inference-level :assertion"
              "10 (happy ?x) :inference-level :assertion :timeout 1.0"

     If there is only a single output variable (as in all the examples
     above) each element generated by the returned iterator will be a
     binding for that variable - unless, the output variable was
     declared with a surrounding pair of parentheses.  For example:

              "all (?x) (happy ?x)"

     In that case, the generated elements will be one-element lists.
     If there are multiple output variables, each element generated by
     the returned iterator will be a list of variable bindings that can
     be accessed using the various `get-nth-...' functions.  The list
     of output variables does not need to be declared in which case
     they are taken to be the open variables in the query proposition
     in the order in which they were encountered.  If order does matter
     or should be different from its default, it can be forced by
     declaring the set of output variables.

     Names in QUERY will be interpreted relative to module MODULE-NAME.
     A null MODULE-NAME or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a STELLA `no-such-context-exception' is thrown.

 -- Function: s-save-module ((module-name STRING) (filename STRING)
          (ifexists STRING) (environment ENVIRONMENT)) :
     Save the contents of the module MODULE-NAME into a file named
     FILENAME.  If a file named FILENAME already exists, then the
     action taken depends on the value of IFEXISTS.  Possible values
     are "ASK", "REPLACE", "WARN" and "ERROR":

     REPLACE => Means overwrite without warning.    WARN    => Means
     overwrite with a warning.    ERROR   => Means don't overwrite,
     signal an error instead.    ASK     => Ask the user whether to
     overwrite or not.  If not overwritten, an              exception
     is thrown.

     A module name of `null' or the empty string refers to the current
     module.  If no module can be found with the name MODULE-NAME, then
     a Stella `no-such-context-exception' is thrown.

 -- Function: save-module ((module MODULE) (filename STRING)
          (ifexists STRING) (environment ENVIRONMENT)) :
     Save the contents of the module `mod' into a file named FILENAME.
     If a file named FILENAME already exists, then the action taken
     depends on the value of IFEXISTS.  Possible values are "ASK",
     "REPLACE", "WARN" and "ERROR":

     REPLACE => Means overwrite without warning.    WARN    => Means
     overwrite with a warning.    ERROR   => Means don't overwrite,
     signal an error instead.    ASK     => Ask the user whether to
     overwrite or not.  If not overwritten, an              exception
     is thrown.

 -- Function: string-to-object ((string STRING) (type LOGIC-OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : OBJECT
     Evaluate STRING with respect to MODULE and ENVIRONMENT and return
     the corresponding logical term.  TYPE is a concept used to assist
     the correct interpretation of STRING.

     Currently TYPE only has an effect on the interpretation of literal
     types.


File: manual.info,  Node: Language Specific Interface,  Prev: API Functions,  Up: PowerLoom API

6.2 Language Specific Interface
===============================

This section contains the description of the programming language
specific aspects of using the PowerLoom API.  Each section describes the
naming conventions and namespace issues related to calling the API
functions from that programming language.

* Menu:

* Lisp API::
* C++ API::
* Java API::


File: manual.info,  Node: Lisp API,  Next: C++ API,  Prev: Language Specific Interface,  Up: Language Specific Interface

6.2.1 Lisp API
--------------

This section tells how to call the API functions in PowerLoom's Common
Lisp implementation from a Lisp program.  The function names are
identical to the Stella names in the PowerLoom API description *Note
PowerLoom API::.  They are exported from the `PLI' package.  Other
Stella symbols and names are in the `STELLA' package, but *currently
none of the Stella symbols are exported!*.

   PowerLoom can be used from Allegro Common Lisp, CMU Common Lisp,
LispWorks Common Lisp and Macintosh Common Lisp.  It may be possible to
use the system from other Common Lisp systems, but they have not been
tested.

* Menu:

* Initialization::
* Type Declarations::
* NULL Values::
* Wrapped Literal Values::
* Special Variables::
* CLOS Objects versus Structs::


File: manual.info,  Node: Initialization,  Next: Type Declarations,  Prev: Lisp API,  Up: Lisp API

6.2.1.1 Common Lisp Initialization
..................................

Loading the Common Lisp version of PowerLoom will normally initialize
the system as part of the loading process.  The Common Lisp version can
be loaded by loading the file `load-powerloom.lisp' from the top-level
`powerloom' directory.  This will make the system available for use.


File: manual.info,  Node: Type Declarations,  Next: NULL Values,  Prev: Initialization,  Up: Lisp API

6.2.1.2 Type Declarations
.........................

Stella is a typed language, and the Common Lisp translation uses the
type information for Common Lisp type declarations.  That means that
values specified as being of type INTEGER, STRING and FLOAT must have
the correct type.  In particular, integer values will not be coerced to
floating point values by the code.  The following native type
assignments are made:

         Stella      Common Lisp
         =======     ===========
         INTEGER     FIXNUM
         FLOAT       DOUBLE-FLOAT
         STRING      SIMPLE-STRING

   *For convenience, loading PowerLoom will set the default format for
reading floating point numbers in Common Lisp to be `double-float'.*

   Stella `CONS' objects are implmented as native Lisp conses.  Boolean
values can take on the values `stella::true' or `stella::false'.


File: manual.info,  Node: NULL Values,  Next: Wrapped Literal Values,  Prev: Type Declarations,  Up: Lisp API

6.2.1.3 NULL values
...................

One additional consequence of the strong typing of the language is that
there are specialized `NULL' values for numeric and string parameters.

       Stella Type   Null Value
       ===========   ===========
         INTEGER     stella::null-integer
         FLOAT       stella::null-float
         STRING      stella::null-string


File: manual.info,  Node: Wrapped Literal Values,  Next: Special Variables,  Prev: NULL Values,  Up: Lisp API

6.2.1.4 Wrapped Literal Values
..............................

Literal values (integers, floats, strings, etc.) that are used in
PowerLoom appear as wrapped values.  The PowerLoom API functions
`object-to-...' can be used to coerce the values into the appropriate
return type.

   <to be written:  wrapping values>


File: manual.info,  Node: Special Variables,  Next: CLOS Objects versus Structs,  Prev: Wrapped Literal Values,  Up: Lisp API

6.2.1.5 Special Variables
.........................

All Stella special variables are implemented as Common Lisp special
variables.  Binding of the values can be used normally.


File: manual.info,  Node: CLOS Objects versus Structs,  Prev: Special Variables,  Up: Lisp API

6.2.1.6 CLOS Objects versus Structs
...................................

PowerLoom can be translated in one of two ways for Common Lisp.  One
method uses CLOS objects as the basis for all Stella and PowerLoom
objects.  For faster execution, it is also possible to use a version in
which Stella and PowerLoom objects are implemented using Common Lisp
structs instead.  This is controlled by the special variable
`cl-user::*load-cl-struct-stella?*'.  If this is set to `cl:t', then
the struct version will be loaded.  This needs to be set before loading
the `load-powerloom.lisp' file.


File: manual.info,  Node: C++ API,  Next: Java API,  Prev: Lisp API,  Up: Language Specific Interface

6.2.2 C++ API
-------------

<to be written>


File: manual.info,  Node: Java API,  Prev: C++ API,  Up: Language Specific Interface

6.2.3 Java API
--------------

This section tells how to call the API functions in PowerLoom's Java
implementation from a Java program.  The Java translation is written for
Java version 1.2.  All of the PowerLoom Interface functions appear as
static methods of the class `edu.isi.powerloom.PLI'.

* Menu:

* Initializing PowerLoom::
* PowerLoom Java Conventions::
* Using the PLI Class::
* Using Stella Objects::
* PowerLoom and Threads::
* Setting and Restoring Global Variable Values::
* Java Character Mapping::
* Stella Exceptions in Java::
* Iteration in Java::
* Utility Classes for Java::


File: manual.info,  Node: Initializing PowerLoom,  Next: PowerLoom Java Conventions,  Prev: Java API,  Up: Java API

6.2.3.1 Initializing PowerLoom
..............................

PowerLoom needs to run initialization functions to set up its
environment for proper operation when it starts up.  The simplest method
for initializing PowerLoom is to use the static method call:

             PLI.initialize()

   This must be called before using any PowerLoom features and before
loading any PowerLoom knowledge bases.  It may be called more than once
without ill effect.


File: manual.info,  Node: PowerLoom Java Conventions,  Next: Using the PLI Class,  Prev: Initializing PowerLoom,  Up: Java API

6.2.3.2 PowerLoom Java Conventions
..................................

PowerLoom's Java code is automatically generated by a translator from
underlying Stella code.  The character set for legal Stella names is
larger than the character set for legal Java identifiers, so there is
some mapping involved.

   PowerLoom names are words separated by hyphen (-) characters.  For
Java, we have attempted to closely follow the Java conventions:

   * Class names begin with a capital letter and each word is
     capitalized.  The hyphens from the PowerLoom names are removed.
     Example:
                  string-wrapper   =>  StringWrapper
        Exceptions are made for class names that would otherwise
     conflict with    normal Java Classes.  In that case, the prefix
     "Stella_" is added to each    class name.  At the moment this
     applies only to the following exceptions:
                  object    =>  Stella_Object
                  class     =>  Stella_Class

   * Method and Function names begin with a lower case letter but each
     subsequent word is capitalized.  The hyphens from PowerLoom names
     are removed.  Example:
                  wrapper-value    =>  wrapperValue

   * Storage slots are implemented as Java fields.  The names begin
     with a lower case letter but each subsequent word is capitalized.
     The hyphens from PowerLoom names are removed.  Example:
                  dynamic-slots    =>  dynamicSlots

   * Global and Special variable names are written in all uppercase.
     The hyphens from PowerLoom are replaced by underscore (_)
     characters.  By convention, special variables are written in
     PowerLoom with surrounding asterisk (*) characters.  The asterisks
     are replaced by dollar signs ($).  Example:
                  *html-quoted-characters*  =>  $HTML_QUOTED_CHARACTERS$

   The most common non-alphanumeric characters are mapped as follows.  A
full set of mappings is in section *note Java Character Mapping::.
        ?  =>  P      (for Predicate)
        !  =>  X      (eXclamation)
        $  =>  B      (Buck)
        %  =>  R      (peRcent)
        &  =>  A      (Ampersand)
        *  =>  $      Special variable marker.

   The character mappings use uppercase characters if the basic
identifier uses mixed or lower case.  The mappings use lowercase
characters if the basic identifier uses upper case.

   Stella modules are mapped to Java packages.  The basic system
distribution includes the following package hierarchy:

       edu
          isi
             stella
                 javalib
             powerloom
                 logic
                 pl_kernel_kb
                     loom_api

   Basic system functionality and data structures such as Cons and List
objects are defined in stella.  PowerLoom's logic (concepts, relations,
rules, etc.) are defined in the logic package.  There is a set of
interface functions in the PLI class in the powerloom package.  They
are described in their own section below.

   We recommend the following import statements in Java files that use
PowerLoom:
             import edu.isi.stella.*;
             import edu.isi.stella.javalib.*;
             import edu.isi.powerloom.PLI;
             import edu.isi.powerloom.logic.*;

   Functions (in Java terms, static Methods) are translated as static
methods on the class of their first argument (as long as that argument
is not a primitive type and is in the same Stella module).  Functions
which take no arguments, those whose first argument is a primitive
type, and those whose first argument is a class not defined in the same
module are all placed into a class with the same name as the Stella
module in which it appers.  It will be in the package corresponding to
that Stella module.  Java constructors should not be called directly.
Instead, there will be a static method `new<ClassName>' (with the class
name in mixed case!) that should be used instead.

   Most of the functions of interest will be in the
edu.isi.stella.Stella, edu.isi.powerloom.PLI or
edu.isi.powerloom.logic.Logic classes.

   Methods typically refer to their first argument as "self".

   Methods which return more than one return value will take a final
argument which is an array of `Stella_Object', which will be used to
return the additional arguments.

   Primitive types in Stella have the following mapping in Java:
             Stella          Java
             ======          ====
             INTEGER         int
             FLOAT           double
             NUMBER          double
             CHARACTER       char
             BOOLEAN         boolean
             STRING          String
             MUTABLE-STRING  StringBuffer

       NATIVE-OUTPUT-STREAM  java.io.PrintStream
       NATIVE-INPUT-STREAM   java.io.PushbackInputStream  (May change!!!)

   Inside Stella/PowerLoom objects and collections, primitive types are
wrapped using Stella wrappers instead of Java's primitive classes.  So
integers will be wrapped as edu.isi.stella.IntegerWrapper rather than
java.lang.Integer.  Wrappers have a field called wrapperValue which
accesses the internal value.  Example of use:

         import edu.isi.stella.*;
         import edu.isi.stella.javalib.*;
         ...
         IntegerWrapper iWrap = IntegerWrapper.wrapInteger(42);
         ...
         int answer = iWrap.wrapperValue;
         ...


File: manual.info,  Node: Using the PLI Class,  Next: Using Stella Objects,  Prev: PowerLoom Java Conventions,  Up: Java API

6.2.3.3 Using the PLI Class
...........................

To make interoperability between PowerLoom and Java a little simpler, we
are providing a (PowerLoom Interface class named `PLI' which handles
synchronization issues, setting and restoring the reasoning context,
and the a more convenient use of some Java-native objects rather than
Stella objects.  Generally that means that strings are used for
PowerLoom expressions and return values rather than Stella `Cons'
objects.

   Details about the methods can be found in the section *note
PowerLoom API::.  The names of functions in that section will need to
be converted to their Java equivalents using the conventions described
in *note PowerLoom Java Conventions::.  We also provide javadoc
documentation for the `edu.isi.powerloom.PLI' class.  We recommend
using this method for accessing PowerLoom functionality.  We expect to
expand the range of PowerLoom interface functions that have an analog in
the `PLI' class over time.


File: manual.info,  Node: Using Stella Objects,  Next: PowerLoom and Threads,  Prev: Using the PLI Class,  Up: Java API

6.2.3.4 Using Stella Objects
............................

Stella objects can also be used directly.  The most common ones used by
PowerLoom users are `Module' and `LogicObject'.  Other potentially
useful Stella objects are `Cons', `Symbol', `Keyword' and `List'.
Except for `LogicObject', these are in the `edu.isi.stella' package.
`LogicObject' is in the `edu.isi.powerloom.logic' package.

   If one wishes to construct `Cons' objects (for example to create
objects to pass to interface functions, one would begin by building
items up using `Stella_Object.cons' static method, which takes a stella
object and a cons.  The empty cons is kept in the
`edu.isi.stella.Stella.NIL' static variable.  Another way to create
stella objects is to use `edu.isi.stella.Stella.unstringify' static
method.  This method takes a string representation of a stella object
and returns the object.  If passed a list, an object of type `Cons'
will be returned.

   As an alternative, one can also convert one and two dimensional
arrays of `Stella_Object' into `Cons' objects using the overloaded
function `edu.isi.stella.javalib.arrayToCons'.  These functions will
return `Cons' objects constructed from the input arrays.

   Keywords and symbols are objects that are stored in global static
variables.  The variable names are all in upper case and are constructed
by concatenating the tag SYM with the module name and the name of the
symbol or concatenating the tag KWD with the name of the keyword.  For
example, the symbol BACKWARD in the logic module would be stored in

             edu.isi.powerloom.logic.Logic.SYM_LOGIC_BACKWARD

   whereas the keyword :ERROR in the stella module would be in

             edu.isi.stella.Stella.KWD_ERROR


File: manual.info,  Node: PowerLoom and Threads,  Next: Setting and Restoring Global Variable Values,  Prev: Using Stella Objects,  Up: Java API

6.2.3.5 PowerLoom and Threads
.............................

The most important consideration when using PowerLoom in a threaded
environment is that the core of PowerLoom must not execute in
concurrently running threads.  The PLI class takes care of this for
interface functions that run through that class.  Other PowerLoom
functions that are called need to synchronize on a lock object

             edu.isi.powerloom.logic.Logic.$POWERLOOM_LOCK$

   for proper operation.  This is not needed for setting Special
Variables, since they are implemented on a per-thread basis.  The most
important special variable is the reasoning context.  *Note Setting and
Restoring Global Variable Values::.


File: manual.info,  Node: Setting and Restoring Global Variable Values,  Next: Java Character Mapping,  Prev: PowerLoom and Threads,  Up: Java API

6.2.3.6 Setting and Restoring Global Variable Values
....................................................

As noted above, special variables in Stella are implemented as static
fields in a catchall class named the same as the Stella module.  It will
be in the java package corresponding to that Stella module.  The values
of Special variables are stored in Java objects of the type
`StellaSpecialVariable', a subclass of Java's `InheritableThreadLocal'.
Any changes made to the values will not affect any other running
threads.  This means that the changes don't need to be synchronized.
Note that global (as opposed to special) variables don't use these
objects.

   Numbers and boolean values are stored in special variables using the
corresponding Java classes `Integer', `Double', `Boolean', etc.  The
naming convention is to have all upper case letters with a dollar sign
($) at the beginning and end of the name.

   To temporarily change the value of one of these variables, users will
need to be responsible for saving and restoring the old values.  Use of
the "`try ... finally ...'" construct is very useful for this, since it
guarantees that the restore of values will be done.  An example follows
of how to safely change modules.  Contexts should be changed using the
functions, although other global variables can be changed by using the
set method.  Note that we use variables of type Object to hold the
values, since that avoids the need to cast when extracting the current
value, since the only operation we do with the current value is save it
to restore it later.

        import edu.isi.stella.*;

        // CONTEXT CHANGE.
        Object savedModule = Stella.$MODULE$.get();
        Module newModule
           = Stella.getStellaModule(contextName, true);
        if (newModule == null) { // Handle missing module
        }
        try {
          Module.changeCurrentModule(newModule)
          // Code that uses the newModule

        } finally {
          Module.changeCurrentModule(savedModule);
        }


        // INTEGER VALUE CHANGE:
        Object savedValue = Stella.$SAFETY$.get();
        try {
          Stella.$SAFETY$.set(new Integer(3));
          // Code that uses the newModule

        } finally {
          Stella.$SAFETY$.set(savedValue);
        }


        // BOOLEAN VALUE CHANGE:
        Object savedValue = Stella.$PRINTREADABLY$.get();
        try {
          Stella.$PRINTREADABLY$.set(Boolean.TRUE);
          // Code that uses the newModule

        } finally {
          Stella.$PRINTREADABLY$.set(savedValue);
        }

   The need to change the module using this type of code can be largely
avoided by using the functions in the PLI interface package.  They take
a module argument and can handle the binding and restoration of the
module value themselves.


File: manual.info,  Node: Java Character Mapping,  Next: Stella Exceptions in Java,  Prev: Setting and Restoring Global Variable Values,  Up: Java API

6.2.3.7 Java Character Mapping
..............................

The full Stella to Java character mapping is the following. The
character mappings use uppercase characters if the basic identifier uses
mixed or lower case.  The mappings use lowercase characters if the basic
identifier uses upper case.

        Stella  Java     Mnemonic
        ======  ====     ========
          !   =>  X      (eXclamation)
          "   =>  _
          #   =>  H      (Hash)
          $   =>  B      (Buck)
          %   =>  R      (peRcent)
          &   =>  A      (Ampersand)
          '   =>  Q      (Quote)
          (   =>  _
          )   =>  _
          *   =>  $
          +   =>  I      (Increase)
          ,   =>  _
          -   =>  _
          .   =>  D      (Dot)
          /   =>  S      (Slash)
          :   =>  C      (Colon)
          ;   =>  _
          <   =>  L      (Less than)
          =   =>  E      (Equal)
          >   =>  G      (Greater than)
          ?   =>  P      (Predicate)
          @   =>  M      (Monkey tail)
          [   =>  J      (Arbitrary (array index?))
          \   =>  _
          ]   =>  K      (Arbitrary (array index?)
          ^   =>  U      (Up arrow)
          `   =>  _
          {   =>  Y      (Arbitrary (adjacent free letter))
          |   =>  V      (Vertical bar)
          }   =>  Z      (Arbitrary (adjacent free letter))
          ~   =>  T      (Tilde)
     <space>  => _


File: manual.info,  Node: Stella Exceptions in Java,  Next: Iteration in Java,  Prev: Java Character Mapping,  Up: Java API

6.2.3.8 Stella Exceptions in Java
.................................

Stella exceptions are implemented as a subtype of `java.lang.Exception'
(actually `RunTimeException') and may be caught normally.  All Stella
Exceptions belong to the `edu.isi.stella.StellaException' class or one
of its subclasses.  The more specfic PowerLoom exceptions belong to the
`edu.isi.powerloom.logic.LogicException' class or one of its subclasses.

   Exceptions thrown during I/O operations will not use the standard
Java exceptions.  Instead, they will descend from
`edu.isi.stella.InputOutputException'.  The most useful descendents are
`edu.isi.stella.NoSuchFileException' and
`edu.isi.stella.EndOfFileException'.


File: manual.info,  Node: Iteration in Java,  Next: Utility Classes for Java,  Prev: Stella Exceptions in Java,  Up: Java API

6.2.3.9 Iteration in Java
.........................

Iteration in Stella (and by extension) PowerLoom is organized a little
bit differently than in Java.  You can either use the Stella iterators
directly, or else use one of the wrapper classes described in the
section *note Utility Classes for Java::.  It will present a more
familiar Java interface.  Since the iteration models are a bit
different, it would be unwise to mix accesses between the iteration
models.

   Stella iterators do not compute any values until the next? method (in
Java: `nextP') is called.  This method will try to compute the next
value of the iterator and it will return a boolean value which is true
if more values are present.  Each time it is called, the iteration
advances.  Values can be read out of the value field of the iterator,
which will have type `Stella_Object'.  Some iterators will also have a
key field which can be read.

   The way one would normally use a Stella iterator is as follows, with
possible casting of the value field:

         Stella.Iterator iter = ...;

         while (iter.nextP()) {
             processValue(iter.value);
         }

   The PLI class also contains a number of functions for simplifying the
interaction with `PlIterator' objects that are returned by various API
functions.  These are the `getNth...' functions.  They work on
sequences and sequence-like objects such as `Proposition' and and the
value slot of `PlIterator' objects.  Note that they do not return
sequential elements of the iterator, but rather elements of the
implicit sequence that is the value of iterators that have more than
one return variable.  For convenience, they also work (with index = 0)
on the value of `PlIterator' objects that have only a single return
variable.  For example:

         // Get values of (object name age) in the iterator and then
         // print out a message with the name and age (position 1 & 2).
         // This skips the PowerLoom object bound to ?X in position 0.
         PlIterator iter =
             PLI.sRetrieve("all (and (name ?x ?name) (age ?x ?age))",
                           null,
                           null);

         while (iter.nextP()) {
             System.out.println(PLI.getNthString(iter, 1, null, null) + " is " +
                                PLI.getNthInteger(iter, 2, null, null ) + " years old.");
         }


File: manual.info,  Node: Utility Classes for Java,  Prev: Iteration in Java,  Up: Java API

6.2.3.10 Utility Classes for Java
.................................

To make interoperation of Stella and Java easier, there are several
convenience classes for wrapping Stella iterators and having them behave
like Java enumerations or iterators.  These convenience classes are in
the `edu.isi.stella.javalib' package:

       ConsEnumeration.java      Enumeration class for Cons objects
       ConsIterator.java         Iterator class for Cons objects
       StellaEnumeration.java    Enumeration interface to Stella's Iterator
       StellaIterator.java       Iterator interface to Stella's Iterator

   All of the iterators and enumerators return objects that are
actually of type `Stella_Object', but the signature specifies
`java.lang.Object' as required for compatibility with the standard Java
signature.  The `Cons...' classes take a `Cons' in their constructor.
The `Stella...' classes take a `edu.isi.stella.Iterator' object in
their constructor.


File: manual.info,  Node: Built-In Relations,  Next: PowerLoom GUI,  Prev: PowerLoom API,  Up: Top

7 Built-In Relations
********************

This chapter lists relations that come predefined in PowerLoom. They
are defined in the module `PL-KERNEL'; users can access them by
including or using the `PL-KERNEL' module within the declarations of
their own modules.

 -- Function: * ((?x NUMBER) (?y NUMBER)) :-> (?z NUMBER)
     Function that multiplies two numbers.

 -- Function: + ((?x NUMBER) (?y NUMBER)) :-> (?z NUMBER)
     Function that adds two numbers.

 -- Function: - ((?x NUMBER) (?y NUMBER)) :-> (?z NUMBER)
     Function that subtracts two numbers.

 -- Function: / ((?x NUMBER) (?y NUMBER)) :-> (?z NUMBER)
     Function that divides two numbers.

 -- Relation: < ((?x THING) (?y THING))
     True if ?x < ?y.

 -- Relation: =< ((?x THING) (?y THING))
     True if ?x <= ?y.

 -- Relation: > ((?x THING) (?y THING))
     True if ?x > ?y.

 -- Relation: >= ((?x THING) (?y THING))
     True if ?x >= ?y.

 -- Relation: ABSTRACT ((?r RELATION))
     True if there are no direct assertions made to the relation ?r.

 -- Concept: AGGREGATE ((?a AGGREGATE))
     ?a is an aggregate

 -- Relation: ANTISYMMETRIC ((?r RELATION))
     A binary relation ?r is antisymmetric if whenever (?r ?x ?y) is
     true (?r ?y ?x) is false unless ?x equals ?y.

 -- Function: ARITY ((?r RELATION)) :-> (?arity INTEGER)
     The number of arguments/domains of the relation ?R.

 -- Relation: ASSERTION-QUERY ((?prop PROPOSITION))
     Query ?prop with :inference-level set to :assertion.  Equivalent
     to `(query ?prop :inference-level :assertion)' but more efficient.

 -- Relation: BACKTRACKING-QUERY ((?prop PROPOSITION))
     Query ?prop with :inference-level set to :backtracking.
     Equivalent to `(query ?prop :inference-level :backtracking)' but
     more efficient.

 -- Concept: BINARY-RELATION ((?r RELATION))
     The class of binary relations.

 -- Relation: BOUND-VARIABLES ((?arguments THING))
     True if all arguments are bound.  The `bound-variables' predicate
     is used as a performance enhancer, to prevent other predicates
     from backchaining excessively while searching for bindings of
     certain of their arguments. Purists will shun the use of this
     predicate, but some rules are inherently inefficient without the
     addition of some kind of control logic.  Because evaluation of the
     `bound-variables' predicate evaluation of predicates being
     `guarded', using this predicate has the side-effect of locally
     disabling query optimization.  (See `collect-into-set' for an
     example that uses `bound-variables'.

 -- Function: CARDINALITY ((?c SET)) :-> (?card INTEGER)
     Function that returns the cardinality of a set.

 -- Relation: CLOSED ((?c COLLECTION))
     The collection ?c is closed if all of its members are known.
     Asserting that a relation is closed makes certain computations
     easier.  For example, suppose that the relation `happy' is closed,
     implying that all things that are happy will be asserted as such.
     To prove `(not (happy Fred))', PowerLoom can use a
     negation-as-failure proof strategy which returns TRUE if `Fred'
     cannot be proved to be happy.  Also, if the relation `children' is
     closed, then a value for the expression `(range-max-cardinality
     children Fred)' can be inferred merely by counting the number of
     fillers of the `children' role on `Fred'.

 -- Function: COLLECT-INTO-ASCENDING-SET ((?c COLLECTION)
          (?sortby RELATION)) :-> (?orderedset LIST)
     Collect elements of ?c into an ascending ?orderedSet where the
     position of each element is determined by the value computed for
     it by the ?sortBy relation.  Ordering is done via sorting (as
     opposed to using a comparison relation) similar to the :sort-by
     option to the `retrieve' command.  If ?sortBy is not
     single-valued, the position of an element is determined by its
     largest ?sortBy value.  Note that, similar to other
     `collect-into-...' functions, ?c can be a named concept, a
     `setofall' or an enumerated collection, and ?sortBy can be a named
     relation or a `kappa'.

 -- Function: COLLECT-INTO-DESCENDING-SET ((?c COLLECTION)
          (?sortby RELATION)) :-> (?orderedset LIST)
     Collect elements of ?c into a descending ?orderedSet where the
     position of each element is determined by the value computed for
     it by the ?sortBy relation.  Ordering is done via sorting (as
     opposed to using a comparison relation) similar to the :sort-by
     option to the `retrieve' command.  If ?sortBy is not
     single-valued, the position of an element is determined by its
     largest ?sortBy value.  Note that, similar to other
     `collect-into-...' functions, ?c can be a named concept, a
     `setofall' or an enumerated collection, and ?sortBy can be a named
     relation or a `kappa'.

 -- Function: COLLECT-INTO-LIST ((?c COLLECTION)) :-> (?l LIST)
     Infer as many members of ?c as possible and collect them into a
     list ?l.  This is similar to `collect-into-set' but collects
     members in the order they are encountered.  If a member is derived
     multiple times, all occurrences are kept.  This is useful, for
     example, to collect and then sum up number-valued attributes of
     objects.

 -- Function: COLLECT-INTO-ORDERED-SET ((?c COLLECTION)) :-> (?l LIST)
     This is similar to `collect-into-list', but if a member is derived
     multiple times, only the first occurrence is kept - hence, the
     name, even though ordered sets are represented as lists.

 -- Function: COLLECT-INTO-SET ((?c COLLECTION)) :-> (?l SET)
     Infer as many members of ?c as possible and collect them into a
     set ?l.  For example, here is a rule used to compute bindings for
     the `fillers' predicate:

            (<= (fillers ?r ?i ?members)
                (and (bound-variables ?r ?i)
                     (collect-into-set (setofall ?v (holds ?r ?i ?v)) ?members)))

     When `?r' and `?i' are bound, the term `(setofall ?v (holds ?r ?i
     ?v))' evaluates to a unary relation satisfied for each filler of
     the relation in `?r' applied to the instance in `?i'.
     `collect-into-set' causes the extension of this
     (dynamically-defined) unary relation to be computed.  Note the use
     of `bound-variables' to screen out unbound variables before they
     are passed to the `setofall' term.

 -- Class: COLLECTION : ABSTRACT-COLLECTION
     Not documented.

      -- Class Parameter of : any-value : OBJECT
          Not documented.

 -- Function: COLLECTIONOF ((?m THING)) :-> (?c COLLECTION)
     Abstract function existing to subsume `SETOF' and `LISTOF'.

 -- Relation: COMMENT ((?x THING) (?s STRING))
     ?s is a comment attached to ?x.  Comments are a generalization of
     other annotations such as `documentation' and `issue' strings.

 -- Relation: COMMUTATIVE ((?r RELATION))
     A relation ?r is commutative if its truth value is invariant with
     any permutation of its arguments.

 -- Concept: CONCEPT ((?x RELATION))
     The class of reified unary relations.  The Powerloom notion of
     `concept' corresponds to the object-oriented notion of `class'.
     From a logic standpoint, the notion of a concept is hard to
     distinguish from the notion of `unary relation'.  The conceptual
     distinction is best illustrated in the domain of linguistics,
     where concepts are identified with collective nouns while unary
     relations are identified with adjectives.  For example, `Rock' is
     a concept, while `rocky' is a unary relation.

 -- Function: CONCEPT-PROTOTYPE ((?c CONCEPT)) :-> (?i THING)
     Function that, given a concept, returns a prototypical instance
     that inherits all constraints that apply to any concept member,
     and has no additional constraints.

 -- Class: CONTEXT : THING
     Not documented.

      -- Slot of : child-contexts : (LIST OF CONTEXT)
          Not documented.

      -- Slot of : base-module : MODULE
          Not documented.

      -- Slot of : all-super-contexts : (CONS OF CONTEXT)
          Not documented.

      -- Slot of : context-number : INTEGER
          Not documented.

   #$(util/texinfo-insert-doc /PL-KERNEL/context-of)

 -- Relation: COVERING ((?c COLLECTION) (?cover SET))
     True if ?c is a subset of the union of all collections in the set
     ?cover (see `disjoint-covering').

 -- Relation: CUT ((?arguments THING))
     Prolog-like CUT.  Succeeds the first time and then fails.
     Side-effect:  Locally disables query optimization.

 -- Relation: DIRECT-SUBRELATION ((?r RELATION) (?sub RELATION))
     True iff ?sub is a direct subrelation of ?r; written in set
     notation, ?sub < ?r, and there is no ?s such that ?sub < ?s < ?r.
     This relation will generate bindings for at most one unbound
     argument.

 -- Relation: DIRECT-SUPERRELATION ((?r RELATION) (?super RELATION))
     True iff ?super is a direct superrelation of ?r; in set notation,
     ?super > ?r, and there is no ?s such that ?super > ?s > ?r.  This
     relation will generate bindings for at most one unbound argument.

 -- Relation: DISJOINT ((?c1 COLLECTION) (?c2 COLLECTION))
     True if the intersection of ?c1 and ?c2 is empty.

 -- Relation: DISJOINT-COVERING ((?c COLLECTION) (?disjointcover SET))
     True if ?c is covered by the collections in ?disjointCover and if
     the member sets in ?disjointCover are mutually-disjoint.  For
     example the concepts `Igneous-Rock', `Metamorphic-Rock', and
     `Sedimentary-Rock' together form a disjoint covering of the
     concept `Rock'.

 -- Relation: DOCUMENTATION ((?x THING) (?s STRING))
     ?s is a documentation string attached to ?x.  Some of the
     PowerLoom text processing tools look for documentation strings and
     import them into documents.

 -- Relation: DOMAIN ((?r RELATION) (?d COLLECTION))
     True if for any tuple `T' that satifies ?r, the first argument of
     `T' necessarily belongs to the concept ?d.  `domain' exists for
     convenience only and is defined in terms of `nth-domain'.  `domain'
     assertions should be avoided, since they create redundant
     `nth-domain' propositions (use `nth-domain' directly).

 -- Relation: DUPLICATE-FREE ((?c COLLECTION))
     ?c is duplicate-free if no two members denote the same object.

 -- Concept: DUPLICATE-FREE-COLLECTION ((?c COLLECTION))
     ?c is free of duplicates

 -- Relation: EMPTY ((?c COLLECTION))
     The collection ?c is empty if it has no members.  Note that for
     collections possessing open-world semantics, (e.g., most concepts)
     the fact that the collection has no known members does not
     necessarily imply that it is empty.

 -- Relation: EQUIVALENT-RELATION ((?r RELATION) (?equiv RELATION))
     True if ?r is equivalent to ?equiv; written in set notation, ?r =
     ?equiv.  This relation will generate bindings for at most one
     unbound argument.

 -- Relation: EXAMPLE ((?r RELATION) (?e THING))
     ?e is an example of (the use of) ?r.

 -- Function: FIFTH-ELEMENT ((?l COLLECTION)) :-> (?e THING)
     Return the fifth element ?e of ?l.

 -- Function: FILLERS ((?r RELATION) (?i THING)) :-> (?members SET)
     Given a relation ?r and instance ?i, returns a set of known
     fillers of ?r applied to ?i.  IMPORTANT: this also collects
     intensional fillers such as skolems that might be identical
     extensionally.

 -- Function: FIRST-ELEMENT ((?l COLLECTION)) :-> (?e THING)
     Return the first element ?e of ?l.

 -- Relation: FORK ((?test PROPOSITION) (?then PROPOSITION)
          (?else PROPOSITION))
     Fail-based conditional.  If ?test succeeds, evaluates ?then;
     otherwise evaluates ?else.

 -- Function: FOURTH-ELEMENT ((?l COLLECTION)) :-> (?e THING)
     Return the fourth element ?e of ?l.

 -- Concept: FRAME-PREDICATE ((?c RELATION))
     A frame predicate is a second-order relation that is used to
     describe constraints on the set of fillers for a binary relation
     applied to an instance.  Examples of frame predicates are
     `range-cardinality', `range-type', and `numeric-inclusive-minimum'.
     Frame predicates are typically used to capture the kinds of
     relations manipulated by description logics such as USC/ISI's Loom
     and W3C's OWL.

 -- Class: METHOD-SLOT : SLOT
     Not documented.

      -- Slot of : method-setter? : BOOLEAN
          Not documented.

      -- Slot of : method-parameter-names : (LIST OF SYMBOL)
          Not documented.

      -- Slot of : method-parameter-type-specifiers : (LIST OF
               TYPE-SPEC)
          Not documented.

      -- Slot of : method-return-type-specifiers : (LIST OF TYPE-SPEC)
          Not documented.

      -- Slot of : method-stringified-source : STRING
          Not documented.

      -- Slot of : method-code : METHOD-CODE
          Not documented.

      -- Slot of : function-code : FUNCTION-CODE
          Not documented.

      -- Slot of : method-function? : BOOLEAN
          Not documented.

 -- Relation: GOES-FALSE-DEMON ((?r RELATION)
          (?computation COMPUTED-PROCEDURE))
     Names a `computation' (a function) that is attached (logically) to
     ?r  Each time a proposition with predicate ?r becomes false, the
     function is applied to that proposition.

 -- Relation: GOES-TRUE-DEMON ((?r RELATION)
          (?computation COMPUTED-PROCEDURE))
     Names a `computation' (a function) that is attached (logically) to
     ?r  Each time a proposition with predicate ?r becomes true, the
     function is applied to that proposition.

 -- Relation: GOES-UNKNOWN-DEMON ((?r RELATION)
          (?computation COMPUTED-PROCEDURE))
     Names a `computation' (a function) that is attached (logically) to
     ?r  Each time a proposition with predicate ?r becomes unknown, the
     function is applied to that proposition.

 -- Relation: HOLDS ((?relation RELATION) (?arguments THING))
     True if the tuple ?ARGUMENTS is a member of the relation
     ?RELATION.  `holds' is a variable arity predicate that takes a
     relation as its first argument, and zero or more additional
     arguments.  It returns values equivalent to a subgoal that has the
     first argument as a predicate and the remaining arguments shifted
     one place to the left.  For `holds' to succeed, the (first)
     relation argument must be bound - PowerLoom will NOT cycle through
     all relations searching for ones that permit the proof to succeed.
     However, users can obtain the same effect if they choose by using
     other second-order predicates to generate relation bindings.  For
     example, the query

             (retrieve all ?x (and (Relation ?r)
                                   (holds ?r Fred ?x)))

     retrieves all constants for which there is some binary relation
     that relates `Fred' to that relation.

 -- Relation: IMAGE-URL ((?x THING) (?url STRING))
     ?url is a URL pointing to an image illustrating ?x.  The
     Ontosaurus browser looks for `image-url' values attached to
     objects it is presenting, and displays them prominently, thereby
     spiffing up its displays.

 -- Relation: INEQUALITY ((?x THING) (?y THING))
     Abstract superrelation of inequality relations.

 -- Function: INSERT-ELEMENT ((?l LIST) (?n INTEGER) (?e THING)) :->
          (?r LIST)
     Add ?e at position ?n (zero-based) to ?l to construct ?r  (shifts
     the remaining elements right).  Count from end of the list and
     shift left if ?n is  negative such that -1 inserts at the end of
     the list, -2 second to last, etc.

 -- Relation: INSTANCE-OF ((?x THING) (?c COLLECTION))
     True if ?x is an instance of ?c.  Can be used to generate concept
     values of ?c, given an instance ?x.

 -- Function: INVERSE ((?r BINARY-RELATION)) :->
          (?inverserelation THING)
     Function that returns the inverse relation for ?r.  PERFORMANCE
     NOTE: for best results there should be only one `(inverse R I)'
     assertion per relation pair `R' and `I'.  In that case `R' is
     viewed as the canonical relation and `I' simply provides a
     different access mechanism to the canonical relation.  In a
     logic-based KR paradigm inverse relations are redundant and do not
     add anything that couldn't be represented or queried without them,
     however, sometimes they can provide some extra convenience for
     users.  Asserting `(inverse I R)' also will not cause an error but
     can degrade backward inference performance due to the extra
     redundant rule that gets generated.  If domain rules will be
     written in terms of both `R' and `I' (as opposed to only `R'),
     `(inverse I R)' should be asserted also to get full inferential
     connectivity between the two relations.

 -- Relation: IRREFLEXIVE ((?r RELATION))
     A binary relation ?r is irreflexive if it is false when both of
     its arguments are identical.

 -- Relation: ISSUE ((?x THING) (?s STRING))
     ?s is an issue attached to ?x.  An issue string normally comments
     on a topic that has not been resolved to everyone's satisfaction.

 -- Relation: IST ((?context CONTEXT) (?p PROPOSITION))
     True if proposition ?P is true in context ?CONTEXT.  The `IST' (is
     true) relation allows one to evaluate a query or rule in more than
     one context.  A common use of `IST' is in defining `lifting axioms'
     that import knowledge from one context to another.  For example,
     below is a rule that accesses a `patient-record' relation in a
     module called `Medical-Kb', `lifts-out' the `age' column, and
     imports it into a `has-age' relation in the current context.

            (<= (has-age ?person ?age)
                (and (has-ssn ?person ?ssn)
                     (exists (?1 ?2 ?3 ?4)
                        (ist Medical-Kb (patient-record ?ssn ?1 ?2 ?age ?3 ?4)))))


 -- Function: LENGTH ((?x THING)) :-> (?z INTEGER)
     Function that returns the length of a string or a logical list.
     NOT YET IMPLEMENTED FOR LISTS.

 -- Relation: LENGTH-OF-LIST ((?l COLLECTION) (?length INTEGER))
     Computes the length of the list or set ?l.

 -- Relation: LEXEME ((?r THING) (?s STRING))
     ?s is a lexeme for the relation or individual ?r.  A relation or
     individual ?r can have zero or more lexemes, words that are
     natural langage equivalents of a logical constant.  The same
     lexeme may be attached to more than one constant.

 -- Class: LIST : SEQUENCE
     Not documented.

      -- Class Parameter of : any-value : OBJECT
          Not documented.

      -- Slot of : the-cons-list : (CONS OF (LIKE (ANY-VALUE SELF)))
          Not documented.

 -- Function: LIST-CONCATENATE ((?x COLLECTION) (?y COLLECTION)) :->
          (?r LIST)
     Concatenate lists ?x and ?y into ?r.  If ?x and/or ?y are not
     lists but sets or more general collections, the order of the
     elements in the result list ?r will be arbitrary.

 -- Function: LISTOF ((?m THING)) :-> (?c LIST)
     Term-forming function that defines an ordered list consisting of
     all function arguments.  Within logical expressions `listof' is
     most commonly used in conjunction with the `member-of' predicate.
     For example the query

            (retrieve ?x (member-of ?x (listof a b c)))

     returns the constants `a', `b', and `c' on successive iterations.

 -- Relation: MAXIMUM-ELEMENT ((?c COLLECTION) (?sortby RELATION)
          (?element THING))
     Find those ?element(s) of ?c with the maximum ?sortBy value, for
     example, `(retrieve (maximum-element relation arity ?x))' (see
     also `collect-into-descending-set').

 -- Relation: MAXIMUM-VALUE ((?l COLLECTION) (?max NUMBER))
     Binds ?max to the maximum of the numbers in the list ?l.

 -- Relation: MEAN-VALUE ((?l COLLECTION) (?mean NUMBER))
     Binds ?mean to the mean of the numbers in ?l.

 -- Relation: MEDIAN-VALUE ((?l COLLECTION) (?median NUMBER))
     Binds ?median to the median of the numbers in ?l.

 -- Relation: MEMBER-OF ((?x THING) (?c COLLECTION))
     TRUE if ?x is a member of collection ?c.  A common use of
     `member-of' is for binding a variable to successive members in a
     list or set (see `listof' and `setof').

 -- Relation: MINIMUM-ELEMENT ((?c COLLECTION) (?sortby RELATION)
          (?element THING))
     Find those ?element(s) of ?c with the minimum ?sortBy value, for
     example, `(retrieve (minimum-element relation arity ?x))' (see
     also `collect-into-ascending-set').

 -- Relation: MINIMUM-VALUE ((?l COLLECTION) (?min NUMBER))
     Binds ?min to the minimum of the numbers in the list ?l.

 -- Relation: MUTUALLY-DISJOINT-COLLECTION ((?s SET))
     True if the members of ?s are pair-wise disjoint.  Used most often
     to expresse disjointness constraints between concepts.  For example

             (mutually-disjoint-collection (setof MAN WOMAN))

     states that the concepts MAN and WOMAN are disjoint.


 -- Function: NAME-TO-OBJECT ((?n THING)) :-> (?o THING)
     Find or create the PowerLoom logic object ?o named by the name ?n
     in the current module.  We are interpreting the name ?n literally
     here, i.e., it is not a print name as assumed by PLI functions and
     an object with exactly that name will be looked up or created.  If
     ?n is not a string, this will coerce it to a string first.  We are
     intentionally using a separate function here (instead of folding
     this into `object-name'), since we might want to be able to look
     for an object with a certain name but not create one if it doesn't
     exist.

 -- Relation: NORMAL-QUERY ((?prop PROPOSITION))
     Query ?prop with :inference-level set to :normal.  Equivalent to
     `(query ?prop :inference-level :normal)' but more efficient.

 -- Relation: NTH-DOMAIN ((?r RELATION) (?i INTEGER) (?d COLLECTION))
     True if the nth value for a tuple T satisfying ?r must belong to
     the concept ?d.  Argument counting starts at zero.

 -- Function: NTH-ELEMENT ((?l COLLECTION) (?n INTEGER)) :-> (?e THING)
     Return the ?n-th element ?e of ?l (zero-based).  Count from end of
     the list if ?n is negative.  If ?n is unbound and ?e is bound,
     this computes the position of ?e.  If both are unbound, collection
     elements and their respective positions will be enumerated.

 -- Function: NTH-HEAD ((?l LIST) (?n INTEGER)) :-> (?h LIST)
     Return the ?n head elements ?h of ?l.  Count from end of the list
     if ?n is negative.

 -- Function: NTH-REST ((?l LIST) (?n INTEGER)) :-> (?r LIST)
     Return the ?n-th rest ?r of ?l (zero-based).  Count from end of
     the list if ?n is negative.

 -- Relation: NUMERIC-MAXIMUM ((?r RELATION) (?i THING) (?n NUMBER))
     Relation that specifies an upper bound ?N on any numeric value
     that can belong to the set of fillers of the relation ?r applied
     to ?i.

 -- Relation: NUMERIC-MINIMUM ((?r RELATION) (?i THING) (?n NUMBER))
     Relation that specifies a lower bound ?N on any numeric value that
     can belong to the set of fillers of the relation ?r applied to ?i.

 -- Concept: NUMERIC-SET ((?s COLLECTION))
     ?s is a set of numbers

 -- Function: OBJECT-NAME ((?x THING)) :-> (?c STRING)
     The name of the object ?X as a string.  This is just the name,
     with module prefixes NOT included.

 -- Relation: ORDERED ((?c COLLECTION))
     ?c is ordered if the ordering of its members is significant.
     Lists are ordered, while sets are not.

 -- Relation: PHRASE ((?r THING) (?s STRING))
     A phrase is a variablized sentence, a template, that is used to
     express individual axiomatic facts as natural language sentences.
     By convention, a phrase contains one or more occurrences of each
     variable in a relation or concept definition, it does not begin
     with a capital letter, and it has no concluding period.
     Systematic attachment of phrases to relations can be leveraged by
     tools that generate natural language paraphrases of logic
     sentences.

 -- Function: PROJECT-COLUMN ((?i INTEGER) (?c COLLECTION)) :->
          (?l LIST)
     Project elements in column ?i (zero-based) of the tuples of ?c and
     collect them into a list ?l.

 -- Relation: PROPER-SUBRELATION ((?r RELATION) (?sub RELATION))
     True iff ?sub is a proper subrelation of ?r; written in set
     notation, ?sub < ?r.  This relation will generate bindings for at
     most one unbound argument.

 -- Relation: PROPER-SUPERRELATION ((?r RELATION) (?super RELATION))
     True iff ?super is a proper superrelation of ?r; written in set
     notation, ?super > ?r.  This relation will generate bindings for
     at most one unbound argument.

 -- Class: PROPOSITION : CONTEXT-SENSITIVE-OBJECT, DYNAMIC-SLOTS-MIXIN,
          BACKLINKS-MIXIN
      -- Slot of : home-context : CONTEXT
          Not documented.

      -- Slot of : kind : KEYWORD
          Not documented.

      -- Slot of : truth-value : TRUTH-VALUE
          Not documented.

      -- Slot of : arguments : VECTOR
          Not documented.

      -- Slot of : operator : GENERALIZED-SYMBOL
          Not documented.

      -- Slot of : dependent-propositions : (NON-PAGING-INDEX OF
               PROPOSITION)
          Not documented.

 -- Function: PROPOSITION-ARGUMENT ((?p PROPOSITION) (?i INTEGER)) :->
          (?arg THING)
     Return the ?i-th ?arg of ?p (zero-based).

 -- Function: PROPOSITION-ARGUMENTS ((?p PROPOSITION)) :-> (?args LIST)
     Return all arguments of ?p as a list ?args.

 -- Function: PROPOSITION-ARITY ((?p PROPOSITION)) :-> (?arity INTEGER)
     Return the number of arguments in ?p.

 -- Function: PROPOSITION-RELATION ((?p PROPOSITION)) :-> (?op RELATION)
     Return the predicate operator ?op of ?p.

 -- Relation: QUERY ((?prop PROPOSITION) (?options THING))
     Search-control relation that allows one to prove or retrieve
     bindings for ?prop with modified search control ?options.  The list
     of accepted ?options is currently the same as are legal for a
     top-level `ask' or `retrieve' query.  The special option value
     :INHERIT inherits the option value from the parent or top-level
     query.  The option pair :INHERIT :ALL inherits all parent options
     which can then be further modified by additional individual option
     specifications.  At most how many solutions will be generated is
     controlled by the :HOW-MANY option (just like in the top level
     `retrieve').  The default is 1 which is again the same as for
     `retrieve' but different from how normal subgoals behave (those
     behave in a lazy all solutions mode).  The reason for this is that
     for partial match subqueries, solutions need to be generated
     eagerly, therefore, a default of generating all solutions is not
     desirable.

 -- Relation: RANGE ((?r RELATION) (?rng COLLECTION))
     True if for any tuple `T' that satifies ?r, the last argument of
     `T' necessarily belongs to the concept ?rng.  `range' exists for
     convenience only and is defined in terms of `nth-domain'.  `range'
     assertions should be avoided, since they create redundant
     `nth-domain' propositions (use `nth-domain' directly).

 -- Function: RANGE-CARDINALITY ((?r RELATION) (?i THING)) :->
          (?card INTEGER)
     Function that returns the cardinality of the set of fillers of the
     relation ?r applied to ?i.  The cardinality function returns a
     value only when the relations `range-min-cardinality' and
     `range-max-cardinality' compute identical values, i.e., when the
     best lower and upper bounds on the cardinality are equal.  Each of
     these bounding functions employs a variety of rules to try and
     compute a tight bound.

 -- Relation: RANGE-CARDINALITY-LOWER-BOUND ((?r RELATION) (?i THING)
          (?lb INTEGER))
     Relation that specifies a lower bound on the cardinality of the
     set of fillers of the relation ?r applied to ?i.  The difference
     between `range-cardinality-lower-bound' and
     `range-min-cardinality' is subtle but significant.   Suppose we
     state that nine is a lower bound on the number of planets in the
     solar system, and then ask if eight is (also) a lower bound:

             (assert (range-cardinality-lower-bound hasPlanets SolarSystem 9))
             (ask (range-cardinality-lower-bound hasPlanets SolarSystem 8))  ==> TRUE

     PowerLoom will return TRUE.  However if we ask if the minimum
     cardinality of the solar system's planets is eight, we get back
     UNKNOWN

             (ask (range-min-cardinality hasPlanets SolarSystem 8)) ==> UNKNOWN

     because eight is not the tightest lower bound.

 -- Relation: RANGE-CARDINALITY-UPPER-BOUND ((?r RELATION) (?i THING)
          (?ub INTEGER))
     Relation that specifies an upper bound on the cardinality of the
     set of fillers of the relation ?r applied to ?i. (see the
     discussion for `range-cardinality-lower-bound').

 -- Function: RANGE-MAX-CARDINALITY ((?r RELATION) (?i THING)) :->
          (?maxcard INTEGER)
     Returns the strictest computable upper bound on the cardinality of
     the set of fillers of the relation ?r applied to ?i.  (see the
     discussion for `range-cardinality-lower-bound').

 -- Function: RANGE-MIN-CARDINALITY ((?r RELATION) (?i THING)) :->
          (?mincard INTEGER)
     Returns the strictest computable lower bound on the cardinality of
     the set of fillers of the relation ?r applied to ?i.  (see the
     discussion for `range-cardinality-lower-bound').

 -- Relation: RANGE-TYPE ((?r RELATION) (?i THING) (?type COLLECTION))
     Relation that specifies a type/range of the relation ?r applied to
     ?i.  Multiple range types may be asserted for a single pair
     <?r,?i>.  Technically, a retrieval of types for a given pair
     should include all supertypes (superconcepts) of any type that is
     produced, but for utility's sake, only asserted or directly
     inferrable types are returned.

 -- Relation: REFLEXIVE ((?r RELATION))
     A binary relation ?r is reflexive if it is always true when both
     of its arguments are identical.

 -- Relation: REFUTATION-QUERY ((?prop PROPOSITION))
     Query ?prop with :inference-level set to :refutation.  Equivalent
     to `(query ?prop :inference-level :refutation)' but more efficient.

 -- Class: RELATION : MAPPABLE-OBJECT
     Not documented.

      -- Slot of : abstract? : BOOLEAN
          Not documented.

 -- Relation: RELATION-COMPUTATION ((?r RELATION)
          (?computation COMPUTED-PROCEDURE))
     Names a `computation' (a function) that evaluates an (atomic)
     relation proposition during query processing.  The function is
     passed a proposition for evaluation for which all arguments are
     bound.  The function returns a BOOLEAN if it represents a
     predicate, or some sort of value if it is a function.

 -- Relation: RELATION-CONSTRAINT ((?r RELATION)
          (?computation COMPUTED-PROCEDURE))
     Names a `computation' (a function) that evaluates an (atomic)
     relation proposition during query processing.  The function is
     passed a proposition for evaluation for which at most one argument
     is unbound.  The function returns a BOOLEAN if it represents a
     predicate, or some sort of value if it is a function.  If all
     arguments are bound the function computes whether the constraint
     holds.  If all but one argument is bound and the unbound argument
     is a pattern variable then the missing value is computed.

 -- Relation: RELATION-EVALUATOR ((?r RELATION)
          (?ev COMPUTED-PROCEDURE))
     Names an `evaluator' (a function) that evaluates an (atomic)
     relation proposition during constraint propagation.  This defines
     an extensible means for computing using auxiliary data structures.
     The function is passed a proposition for evaluation which might
     update the proposition, generate additional assertions or trigger
     further evaluations.  Evaluators have to check the truth-value of
     the passed-in proposition and perform their actions accordingly.
     An evaluated proposition might be true, false or even unknown in
     case the propositon was just newly constructed.

 -- Relation: RELATION-SPECIALIST ((?r RELATION)
          (?sp COMPUTED-PROCEDURE))
     Names a `specialist' (a function) that evaluates an (atomic)
     relation proposition during query processing.  This defines an
     extensible means for computing with the control stack.  The
     function is passed a CONTROL-FRAME that contains the proposition,
     and returns a keyword :FINAL-SUCCESS, :CONTINUING-SUCCESS,
     :FAILURE, or :TERMINAL-FAILURE that controls the result of the
     computation.

 -- Concept: SCALAR ((?x SCALAR))
     The class of scalar quantities.

 -- Concept: SCALAR-INTERVAL ((?x SCALAR))
     An interval of scalar quantities.

 -- Function: SECOND-ELEMENT ((?l COLLECTION)) :-> (?e THING)
     Return the second element ?e of ?l.

 -- Class: SET : LIST, SET-MIXIN
     Not documented.

      -- Class Parameter of : any-value : OBJECT
          Not documented.

 -- Function: SETOF ((?m THING)) :-> (?c SET)
     Term-forming function that defines an enumerated set consisting of
     all function arguments.  `setof' is like `listof' except that it
     removes duplicate values.

 -- Relation: SHALLOW-QUERY ((?prop PROPOSITION))
     Query ?prop with :inference-level set to :shallow.  Equivalent to
     `(query ?prop :inference-level :shallow)' but more efficient.

 -- Relation: SINGLE-VALUED ((?c RELATION))
     The relation ?c is single-valued if the value of its last argument
     is a function of all other arguments.  All functions are
     single-valued (see `function').

 -- Relation: SQUARE-ROOT ((?x NUMBER) (?y NUMBER))
     Relation that returns the positive and negative square roots: ?y =
     sqrt(?x).  For positive roots only see function SQRT.

 -- Relation: STANDARD-DEVIATION ((?l COLLECTION) (?sd NUMBER))
     Binds ?sd to the standard deviation of the numbers in ?l.

 -- Function: STRING-CONCATENATE ((?x THING) (?y THING)) :-> (?z STRING)
     Concatenate ?x and zero or more strings ?y (variable arity) and
     bind ?z to the result.  Coerces any type argument to a string if
     necessary.

 -- Function: STRING-MATCH ((?pattern STRING) (?object THING)
          (?start INTEGER) (?end INTEGER)) :-> (?match-position INTEGER)
     Match ?pattern against ?object between ?start and ?end
     (zero-based), and return the position of the first match or fail
     if no match exists.  Supplying -1 for ?end indicates the end of
     ?object.  ?object can be a named logic object or a string.
     ?pattern will eventually allow support regular expressions,
     currently it only handles string literals.  Apart from doing
     to-string coercion on ?object this is somewhat redundant, since
     `substring' can generate ?start/?end pairs if its string and
     substring arguments are bound.

 -- Function: STRING-MATCH-IGNORE-CASE ((?pattern STRING)
          (?object THING) (?start INTEGER) (?end INTEGER)) :->
          (?match-position INTEGER)
     Match ?pattern against ?object between ?start and ?end
     (zero-based), and return the position of the first match or fail
     if no match exists.  Supplying -1 for ?end indicates the end of
     ?object.  ?object can be a named logic object or a string.  This
     match compares the strings ignoring differences in letter case.

 -- Relation: SUBRELATION ((?r RELATION) (?sub RELATION))
     True iff ?sub is a subrelation of ?r; written in set notation,
     ?sub =< ?r.  This relation will generate bindings for at most one
     unbound argument.

 -- Relation: SUBSET-OF ((?sub COLLECTION) (?super COLLECTION))
     True if ?sub is a subset of ?super.  For performance reasons, the
     `subset-of' predicate refuses to search for bindings if both of
     its variables are unbound.  Implementation note: `subset-of' is
     treated specially internally to PowerLoom, and hence Powerloom
     does not permit the augmentation of `subset-of' with additional
     inference rules.  In otherwords, `subset-of' behaves semantically
     like an operator instead of a relation.

 -- Function: SUBSTRING ((?s STRING) (?start INTEGER) (?end INTEGER))
          :-> (?sub STRING)
     Generate the substring of ?s starting at position ?start
     (zero-based), ending just before position ?end and bind ?sub to
     the result.  This is the PowerLoom equivalent to the STELLA method
     `subsequence'.  In addition, this function can be used to locate
     substrings in strings by supplying values for ?s and ?sub and
     allowing ?start and ?end to be bound by the function specialist.
     In other words,       (retrieve all (?start ?end) (substring "foo"
     ?start ?end "o"))  ==>  ?start = 1, ?end = 2,       ?start = 2,
     ?end = 3.

 -- Relation: SUBSUMPTION-QUERY ((?prop PROPOSITION))
     Query ?prop with :inference-level set to :subsumption.  Equivalent
     to `(query ?prop :inference-level :subsumption)' but more
     efficient.

 -- Relation: SUM ((?l COLLECTION) (?sum NUMBER))
     Binds ?sum to the sum of the numbers in the list ?l.

 -- Relation: SUPERRELATION ((?r RELATION) (?super RELATION))
     True iff ?super is a superrelation of ?r; written in set notation,
     ?super >= ?r.  This relation will generate bindings for at most
     one unbound argument.

 -- Relation: SYMMETRIC ((?r RELATION))
     A binary relation ?r is symmetric if it is commutative.

 -- Relation: SYNONYM ((?term THING) (?synonym THING))
     Assert that ?SYNONYM is a synonym of ?TERM.  This causes all
     references to ?SYNONYM to be interpreted as references to ?TERM.
     Retraction eliminates a synonym relation.

 -- Class: THING : STANDARD-OBJECT, DYNAMIC-SLOTS-MIXIN
     Defines a class that must be inherited by any class that
     participates in the PowerLoom side of things.

      -- Slot of : surrogate-value-inverse : SURROGATE
          Not documented.

 -- Function: THIRD-ELEMENT ((?l COLLECTION)) :-> (?e THING)
     Return the third element ?e of ?l.

 -- Relation: TOTAL ((?r FUNCTION))
     True if the function ?R is defined for all combinations of inputs.
     By default, functions are not assumed to be total (unlike Prolog,
     which `does' make such an assumption.  For example, if we define a
     two-argument function `foo' and then retrieve its value applied to
     some random instances `a' and `b', we get nothing back:

             (deffunction foo (?x ?y) :-> ?z)
             (retrieve ?x (= ?x (foo a b)))

     However, if we assert that `foo' is total, then we get a skolem
     back when we execute the same retrieve:

             (assert (total foo))
             (retrieve ?x (= ?x (foo a b)))


 -- Relation: TRANSITIVE ((?r RELATION))
     A binary relation ?r is transitive if (?r ?x ?y) and (?r ?y ?z)
     implies that (?r ?x ?z).  Note that functions cannot be
     transitive, since their single-valuedness would not allow multiple
     different values such as (?r ?x ?y) and (?r ?x ?z) due to the
     Unique Names Assumption made by PowerLoom.

 -- Relation: TYPE-OF ((?c COLLECTION) (?x THING))
     True if ?x is a member of the concept ?c.

 -- Function: VALUE ((?function FUNCTION) (?arguments THING)) :->
          (?value THING)
     True if applying ?FUNCTION to ?ARGUMENTS yields the value
     `?value'.  The `value' predicate is the analog of `holds', except
     that it applies to functions instead of relations.

 -- Relation: VARIABLE-ARITY ((?r RELATION))
     Asserts that the relation ?r can take a variable number of
     arguments.

 -- Relation: VARIANCE ((?l COLLECTION) (?variance NUMBER))
     Binds ?variance to the variance of the numbers in ?l.


File: manual.info,  Node: PowerLoom GUI,  Next: Ontosaurus,  Prev: Built-In Relations,  Up: Top

8 PowerLoom GUI
***************

The PowerLoom GUI (or knowledge editor) is a Java-based graphical client
for PowerLoom.  The GUI is implemented as a Swing-based Java application
which communicates with an embedded or remote PowerLoom server using a
SOAP communication layer over HTTP.

   The architecture of the PowerLoom GUI most closely resembles the
traditional two-tier client/server model.  Since the GUI does not
contain a great deal of business logic (e.g., it does not know how to do
inferencing), it does not directly map onto the traditional notion of a
smart client.  Similarly, since PowerLoom is much "smarter" than a
typical DBMS, it does not cleanly map onto a traditional backend server.
However, since the GUI contains the presentation logic, it is more
similar to a 2-tier model than a 3-tier model where the presentation
logic resides in a middle tier.

   Communication between the GUI and PowerLoom is done via the XML-based
SOAP protocol.  In order to effectively communication via SOAP, a Web
service layer was built on top of PowerLoom.  This layer provides
support for marshaling and unmarshaling of PowerLoom objects to/from
XML, and also provides a PowerLoom API that is accessible as a web
service.  The Java client uses JAXM and the Castor framework (see
`http://www.castor.org') to support SOAP communication.

* Menu:

* Invoking the GUI::
* GUI Design Goals::
* GUI Overview::
* GUI Features::
* Future Work::


File: manual.info,  Node: Invoking the GUI,  Next: GUI Design Goals,  Prev: PowerLoom GUI,  Up: PowerLoom GUI

8.1 Invoking the GUI
====================

The PowerLoom GUI can be started in a variety of ways.  The easiest way
is to use the top-level `powerloom' script (*note Running PowerLoom::)
and supply the `--gui' option.  This will start the Java version of
PowerLoom, start a standalone embedded PowerLoom Web server, launch the
GUI application and connect from it to the PowerLoom server (using port
9090 by default):

     % powerloom --gui
     Running Java version of PowerLoom...
     Initializing STELLA...
     Initializing PowerLoom...
     Loading required system webtools
     Loading required system ontosaurus

         Welcome to PowerLoom 4.0.0

     Copyright (C) USC Information Sciences Institute, 1997-2010.
     PowerLoom is a trademark of the University of Southern California.
     PowerLoom comes with ABSOLUTELY NO WARRANTY!
     Type `(copyright)' for detailed copyright information.
     Type `(help)' for a list of available commands.
     Type `(demo)' for a list of example applications.
     Type `bye', `exit', `halt', `quit', or `stop', to exit.


     PL-USER |=

   Alternatively, PowerLoom can be started in its standard command loop
mode and then the GUI can be started with the `start-powerloom-gui'
command.  This is useful if the GUI becomes necessary at some point
during development or if a different port should be used.  For example:

     % powerloom
     Initializing STELLA...
     Initializing PowerLoom...

         Welcome to PowerLoom 3.2.52

     Copyright (C) USC Information Sciences Institute, 1997-2010.
     PowerLoom is a trademark of the University of Southern California.
     PowerLoom comes with ABSOLUTELY NO WARRANTY!
     Type `(copyright)' for detailed copyright information.
     Type `(help)' for a list of available commands.
     Type `(demo)' for a list of example applications.
     Type `bye', `exit', `halt', `quit', or `stop', to exit.


     PL-USER |= (start-powerloom-gui :port 9092)

     Loading required system webtools
     Loading required system ontosaurus

     PL-USER |=

   When the GUI is run against an embedded server as in the examples
above, it is run asynchronously and commands can be executed at the
PowerLoom command loop at any time.  Moreover, when the GUI is exited,
the command loop stays active until it is exited explicitly as well.

   The GUI can also be run standalone in which case the user needs to
connect to a running PowerLoom server.  For example:

     % powerloom --gui-only
     Running standalone PowerLoom GUI...

   Once the GUI is initialized, the user can connect to a server via the
`File -> Connect to Server' menu item.  After the first connection, the
host and port of the last used server will be remembered for the next
startup.  If during the next startup that server is not active anymore,
an error will be signaled and the user can connect to a different
server instead.

* Menu:

* Starting a PowerLoom Server::


File: manual.info,  Node: Starting a PowerLoom Server,  Prev: Invoking the GUI,  Up: Invoking the GUI

8.1.1 Starting a PowerLoom Server
---------------------------------

The GUI always connects to a PowerLoom server which can be embedded in
the same Java process (as in the examples above), or can be run in a
separate Lisp or Java process or as part of a Tomcat server (a C++ Web
server is not currently supported).  To start a PowerLoom server do the
following.  Start the Java version of PowerLoom via the `powerloom'
script or start a Lisp version of PowerLoom that supports a Web server
such as Allegro CL or a Lisp that supports Portable AServe.  Once
PowerLoom is up and running, issue the following command:

     PL-USER |= (start-powerloom-server)

     Loading required system webtools
     Loading required system ontosaurus

     PL-USER |=

   The command also accepts a `:port' option to make the server listen
to a different port.

   Alternatively, the PowerLoom Web Archive available in
     powerloom-x.y.z/native/java/lib/ploom.war
   can be deployed in an Apache Tomcat server by copying it into the
server installation's `webapps' directory.  The GUI can then connect to
it at the server port used by Tomcat.


File: manual.info,  Node: GUI Design Goals,  Next: GUI Overview,  Prev: Invoking the GUI,  Up: PowerLoom GUI

8.2 GUI Design Goals
====================

The choice of technology was driven by a number of design goals which
are summarized below.  Note that the most of the GUI code was developed
back in 2002 and is therefore somewhat outdated with respect to today's
Java and Web-based human interface technologies.

   *Visibility*: Knowledge Bases are complex and loosely structured
entities.  It is often desirable to simultaneously maintain multiple
views of a KB, and to simultaneously perform multiple complementary task
such as browsing, editing, querying, and searching a KB.  With Swing's
MDI (Multiple Document Interface) mode, many internal frames can be open
at the same time within a single "desktop" frame.  Swing also offers a
very rich set of components and UI mechanisms which facilitate efficient
use of screen real estate.

   We designed the GUI to take advantage of Swing's presentation
strengths.  We used the MDI mode, so browsers, editors, etc. can
coexist on the same desktop.  Additionally, multiple knowledge browsers
can be open at the same time to present different views of a KB.  The
Knowledge Browser itself consists of multiple collapsible and resizable
subpanes, which in turn are composed of scrollable lists and trees.
This allows a "birds-eye" view of a Powerloom KB, in which many
modules, concepts, relations, instances, propositions, and rules can be
displayed at the same time.

   *Navigability*: When exploring a KB, it is imperative that a user
interface allows easy navigation between related objects.  The PowerLoom
GUI has extensive navigation capabilities, which are as good or better
than browser based applications.  For example, a user may click on a
query result to instantly update the Knowledge Browser to display the
selected object.  Also, a user can right-click on a relation or argument
in a proposition, and navigate to the clicked-on object.

   *Responsiveness*: For the best possible user experience, a user
interface should be highly responsive to a user's input gestures.  For
example, (1) after initiating a gesture such as a mouse click or
keypress, there should be a minimal delay before the appliction performs
the intended action, and (2) "Power Users" should be able to perform
complex tasks with a minimum number of mouse clicks, key presses, etc.

   The PowerLoom GUI attempts to minimize network round-trips by caching
large amounts of data.  For example, when a user points the Knowledge
Browser to a module, a large chunk of the module is retrieved from the
server and cached in the client.  Hence, when the user expands a tree in
the browser, the GUI will not need to retrieve more data from the
server.  Also, the GUI takes full advantage of Swing's ability to
control the application via keyboard input.  For example, to create a
new instance named `newName', a user needs to simply type the key
sequence `Ctrl-I newName RET'.

   *Context Sensitivity*: For any given object that is displayed in a
user interface, there is a set of actions that can be performed on that
object.  Additionally, the actions that can be performed on an object
depend on where the object is displayed.  Therefore, the GUI
pervasively supports context-sensitive popup menus.  When users
right-click on an object, a list of appropriate actions will be
presented in a menu.  For example, when a user right-clicks on a concept
in the Knowledge Browser, the list of possible actions shown in *note
fig:context-menu:: is presented.

 [image src="../../../sources/powerloom-gui/doc/images/gui-context-menu.gif" ]

Figure 8.1: Context-specific menu of possible actions on a concept

   *Editability*: Applications that support text editing often need
capabilities above and beyond the baseline copy, cut and paste
capabilities that all text widgets support.  In particular, applications
that allow editing of text with a regular structure such as source code
or Lisp expressions may take advantage of special key bindings which
augment basic navigation and editing capabilities.

   The PowerLoom GUI makes use of Swing's powerful text components by
implementing a full set of Emacs-style keybindings.  These keybindings
allow a user to perform such operations as navigating up and down a
subexpression hierarchy, selecting entire subexpressions, and completing
incomplete symbols.  In addition, matching parenthesis are automatically
highlighted in the GUI's text components.

   *Extensibility*: While it is not easy to claim that Swing
applications are inherently more extensible than Web applications,
Swing's MDI architecture and pull-down menu framework allows new
features to be added with little disruption to the rest of the
application.  In particular, using modern GUI design tools that are part
of IDE's such as Netbeans or Eclipse, it is fairly easy to add new
components and functionality to the PowerLoom GUI.  It is also
conceivable that the GUI code could be used as the basis for a more
specific application which would have its own application-specific menus
and windows, but would retain the general-purpose browsing, querying,
and editing tools for direct manipulation of the knowledge base.


File: manual.info,  Node: GUI Overview,  Next: GUI Features,  Prev: GUI Design Goals,  Up: PowerLoom GUI

8.3 GUI Overview
================

An example screen shot of the PowerLoom GUI is shown in *note fig:gui::.
The main application frame consists of pull-down menus, a toolbar, and a
status bar.

 [image src="../../../sources/powerloom-gui/doc/images/gui.gif" ]

Figure 8.2: The PowerLoom GUI

   The menu bar contains the following menus:

   * KB - menu items for connecting to a server, loading, saving, and
     clearing KBs, and opening browser and console windows.

   * Edit - menu items for cutting, copying, pasting, and deleting, and
     also an item which opens a preferences dialog.

   * Objects - menu items for opening editors on various KB objects,
     including modules, concepts, relations, instances, and
     propositions.  This menu also contains an item to edit the
     currently selected object.

   * Query - menu items for querying the KB, searching the KB, and
     editing a relation's extension.

   * View - this menu contains various items for updating the
     appearance of the application, including a refresh item to bring
     the GUI up-to-date with the state of the KB on the server, and
     menu items for showing/hiding the application's toolbar and status
     bar.  This menu also contains items for changing the application's
     font, for example, the Demo Theme changes all fonts to a large
     bold font suitable for demo presentations.

   * Navigate - contains menu items for navigating backward and forward
     in a browser's selection history.

   * Window - contains a list of the currently open windows on the
     desktop. Selecting a window brings the window to the top of the
     window stack, and if the window is iconified, it is de-iconified.

   * Help - contains an item to open an HTML help browser, and an item
     to open an About box which contains information about the
     PowerLoom GUI.

   Most menu items have accelerator keys that allow an item to be
executed by a combination of keystrokes.  The toolbar contains several
buttons which provide shortcuts to menu items.  There are currently
toolbar buttons for cutting, copying, pasting, deleting, editing an
object, and opening a query dialog.  The toolbar may be undocked from
its default position by dragging it anywhere on the desktop.  It may
also be hidden and unhidden by selecting the `View -> Toolbar' menu
item.

   The status bar at the bottom of the application contains information
on the current status of the application.  The status bar is divided
into two sections.  The leftmost section displays the last module that
was selected by a user.  The application keeps track of the current
module in order to provide continuity between operations.  For example,
if a user opens a browser and browses the AIRCRAFT-KB, and then opens a
query dialog, it makes sense for the query dialog to use the
AIRCRAFT-KB module instead of some other module.

   The rightmost section of the status bar contains messages that
pertain to the current state of the application.  For example, if a user
selects a concept and then clicks the cut toolbar button, a message
will appear in the rightmost status bar prompting the user to select
another concept and perform a paste action.  The status bar may be
hidden and unhidden by selecting the `View -> Statusbar' menu item.

   *note Figure 8.2: fig:gui. shows a few internal frames that are
open.  The function of each frame is identified in the frame's title
bar, and each type of frame has a unique icon in it's upper left-hand
corner.  In this example, the three open frames are used to browse the
KB, query the KB, and edit an instance.

   A user typically follows a workflow cycle similar to the following
sequence:

  1. The user launches the GUI by executing the `powerloom' script,
     clicking on a desktop icon or on a hyperlink in a browser.

  2. The GUI is loaded on the user's machine.  If the GUI was launched
     via Java Web Start (not yet fully supported), the entire
     application may need to be downloaded or updated before execution
     begins.

  3. The GUI reads a preferences file stored in a default location on
     the user's local machine.  If this is the first time the
     application is being executed, a default preferences file is used.
     The preferences file includes among other things the PowerLoom
     server that was last accessed.

  4. If the preferences file contains the last-accessed server, the GUI
     attempts to connect to the server and query the server for a
     description of the server's capabilities.  If connection is
     successful, a browser window will open displaying the modules that
     are currently loaded in the server instance.

  5. The user selects any KB files (s)he wishes to load, and instructs
     the server to load the files.

  6. The user performs some browsing, querying, and editing of the
     loaded KB.

  7. If any changes were made, the user saves the KB to a new or
     existing file.

  8. The user repeats steps 5-7 as needed, and then exits the
     application.


File: manual.info,  Node: GUI Features,  Next: Future Work,  Prev: GUI Overview,  Up: PowerLoom GUI

8.4 GUI Features
================

This section provides a detailed description of the features that are
available in the GUI application.  We describe general application-wide
functionality as well as the functionality of specific components.

* Menu:

* Connect to Server::
* Edit Preferences::
* KB Load/Save::
* Browsing::
* Editing::
* Choosers::
* Extension Editor::
* Ask and Retrieve Queries::
* Search::
* Console::
* Cut/Copy/Paste/Delete::


File: manual.info,  Node: Connect to Server,  Next: Edit Preferences,  Prev: GUI Features,  Up: GUI Features

8.4.1 Connect to Server
-----------------------

The first time the GUI is started, it will not attempt to connect to any
server.  To establish a server connection, the user must select the `KB
-> Connect to Server' menu item.  This will open a dialog prompting for
a host name and port.  After the user enters this information, a
connection will be attempted.  If the connection is successful, the
server information will be stored in the preferences file and used next
time the application starts up.


File: manual.info,  Node: Edit Preferences,  Next: KB Load/Save,  Prev: Connect to Server,  Up: GUI Features

8.4.2 Edit Preferences
----------------------

A preferences dialog can be opened by selecting the `Edit -> Edit
Preferences' menu item.  Currently, the only preference that a user can
edit is whether or not to open a browser when the application is
started.  The dialog contains a checkbox asking whether or not the
preferences should be saved.  If the checkbox is not checked, the
preferences will remain in effect for the duration of the current
session, but will not be in effect when the application is restarted.


File: manual.info,  Node: KB Load/Save,  Next: Browsing,  Prev: Edit Preferences,  Up: GUI Features

8.4.3 KB Load/Save
------------------

In its standard configuration, PowerLoom stores knowledge bases via flat
files.  The user can load one or more KB files from the local file
system which will be transferred across the network and loaded into the
server instance via PowerLoom's `load' command.  Conversely, a modified
knowledge base can be saved to a local file on a per-module basis
(using a version of PowerLoom's `save-module' command).  Future
versions of PowerLoom will support more sophisticated persistence that
will go directly to a database or other persistent store.


File: manual.info,  Node: Browsing,  Next: Editing,  Prev: KB Load/Save,  Up: GUI Features

8.4.4 Browsing
--------------

The knowledge browser window, shown in *note fig:browser::, can be
opened by selecting the `KB -> Browse' menu item or typing `Ctrl-b'.
The browser provides a visual overview of all knowledge in the KB, and
is capable of launching specialized tools such as editors, search
dialogs, etc.

 [image src="../../../sources/powerloom-gui/doc/images/gui-knowledge-browser.gif" ]

Figure 8.3: Knowledge Browser

   The browser consists of several subpanes which we refer to as
navigation panes.  Each navigation pane consists of a title pane, a
toolbar, and a content pane.  The title pane contains a title
indicating what is displayed in the content pane.  The toolbar consists
of zero or more buttons which perform actions relevant to the
navigation pane.  Currently, two toolbar buttons are present: "Add" and
"Search".  "Add" (indicated by a +-sign icon) adds an object associated
with the type of navigation pane.  "Search" (indicated by a flashlight
icon) searches for objects associated with the type of navigation pane.
The content pane contains the actual knowledge to be displayed, such as
a list of instances or propositions.

   There is one navigation pane for each type of KB object: Modules,
Concepts, Relations, Instances, Rules, and Propositions.  Each internal
pane is resizable by dragging the movable divider between the panes.
Panes may be hidden completely by clicking the "Collapse" arrow on the
adjacent divider.  Clicking the "Expand" arrow will unhide the pane.

   *Visual Cues*: Navigation panes employ several visual cues to
enhance the identifiability of object attributes.  Object types are
indicated by an icon to the left of the object's name.  For example,
modules are represented by a blue `M', concepts by a red `C', etc.  The
status of propositions is also indicated visually.  An italicized
proposition indicates that the proposition was derived instead of
asserted.  Grey propositions indicate that their truth value is a
default value instead of a strict value.

   The main method for filling the contents of a navigation pane is to
select some object in a navigation pane that is to the left or above it.
This is discussed in more detail in the section below.  However, in some
cases, it is possible to modify the contents of a navigation pane
without performing a selection.  For example, in the instance navigation
pane, it is possible to show derived or inherited instances by
right-clicking on the instance list and selecting an appropriate menu
item.  Similarly, the relation navigation pane can toggle between direct
or inherited relations.  Propositions and rules are by default displayed
according to the module that is currently selected.  However, the
contents of the proposition or rule navigation pane can be updated by
selecting a more specific module in the View From Module combobox
contained in the navigation pane's title bar.

   *Selection*: When the browser is initially opened, a tree of modules
is displayed in the module navigation pane, and all other navigation
panes are empty.  When a module is selected, the remaining subpanes are
populated with knowledge that is contained in that module.  Similarly,
selecting a concept in the concept navigation pane populates the
relation, proposition, and instance panes with knowledge that is
relevant to the selected concept.  In general, selecting an object in a
given navigation pane may affect the contents of navigation panes to the
right and/or below it.  More specifically, the rules for object
selection are as follows:

   * Selecting a module populates the concept, relation, and instance
     subpanes with knowledge contained in the module.

   * Selecting a concept populates the relation subpane with relations
     that use the concept as a domain type, and populates the instance
     subpane with the concept's extension.  The proposition and rule
     subpanes are populated with propositions and rules associated with
     the concept.

   * Selecting a relation populates the proposition and rule subpanes
     with propositions and rules associated with the relation.

   * Selecting an instance with no selected relation populates the
     proposition subpane with propositions that refer to the selected
     instance.

   * Selecting an instance and a relation populates the proposition
     subpane with propositions that contain the relation as a
     predicate, and the instance as an argument.

   * De-selecting an object will update the state of the browser
     appropriately.  For example, after selecting a module and a
     concept, deselecting the concept will refresh the concept,
     relation, instance, proposition and rule subpanes to display the
     knowledge contained in the selected module.

   The title pane in each navigation pane displays a description of the
source of the subpane's contents.  For example, if both the relation
`WINGSPAN' and the instance `AGM-130' were selected, the proposition
subpane would contain the title "Propositions for WINGSPAN and AGM-130".

   Each selection event is recorded in a selection history which can be
rolled back and forward.  For example, assume the user selects the
`AIRCRAFT-KB' module and then selects the `GUIDANCE-TYPE' concept.  If
the user then selects the `Navigate -> Back' menu item, the selection
history will be rolled back so that only `AIRCRAFT-KB' is selected.  If
the user then selects `Navigate -> Forward', the selection history will
be rolled forward to its original state so that both `AIRCRAFT-KB' and
`GUIDANCE-TYPE' are selected.

   *Navigation*: Knowledge can be explored by expanding and collapsing
nodes in hierarchical navigation panes such as the concept and module
navigation panes.  If a tree or list is not fully visible, the user may
use the scrollbar on the navigation pane's right-hand side to scroll
through the contents of the pane.  Detailed views of objects such as
concepts and relations can be obtained by right-clicking the object and
selecting the `Edit' menu item.  To navigate to a constituent of a
proposition, the user can right-click the constituent and then select
the `Navigate to...' menu item.  For example, right-clicking on the
`GUIDANCE' argument in the proposition `(NTH-DOMAIN GUIDANCE 1
GUIDANCE-TYPE)' presents a popup menu which displays (among other items)
the item `Navigate to GUIDANCE'.  Selecting this menu item will cause
the browser to display and select the `GUIDANCE' relation.

   Actions external to the browser may also update the browser's
contents.  For example, clicking on an instance in a list of query
results will cause the browser to navigate to the selected instance.

   *Actions*: Right-clicking inside the browser will present a menu of
actions that is relevant to the subpane that contains the mouse
pointer.  The list of items will depend on whether the mouse is over a
specific item or if it is over the background of the subpane's list or
tree.  For example, when the mouse is over a specific concept, the menu
will contain items for cutting, pasting, instantiating, etc., but when
the mouse is over the background of the concept tree, the only menu
item presented will be to add a new concept.

   The set of actions available for each subpane are as follows:

   * Module - `Add Module', `Edit Module', `Load Module', `Save
     Module', `Clear Module', `Copy'.

   * Concept - `Add Concept', `Edit Concept', `Edit Extension',
     `Instantiate', `Cut', `Copy', `Paste', `Delete'. If multiple
     concepts are selected, selecting `Create New Concept' from the
     background menu will create a concept that contains the selected
     concepts as parents.

   * Relation - `Add Relation', `Edit Relation', `Edit Extension',
     `Copy', `Delete', `Show Inherited/Direct Relations'.

   * Instance - `Add Instance', `Edit Instance', `Copy', `Delete',
     `Show Direct/Derived Instances'.

   * Propositions - `Add Proposition', `Edit Proposition', `Copy',
     `Delete', `Navigate to Constituent', `Edit Constituent'.

   * Rules - `Add Rule', `Edit Rule', `Copy', `Delete', `Navigate to
     Constituent', `Edit Constituent'.


File: manual.info,  Node: Editing,  Next: Choosers,  Prev: Browsing,  Up: GUI Features

8.4.5 Editing
-------------

Objects may be edited by right-clicking them and selecting the
`Edit...' menu item in the popup menu.  Alternatively, an object may be
selected, and then the `Objects -> Edit Object' menu item or the the
edit toolbar button can be pressed.  Object editors do double-duty as
object viewers, since all relevant object information is present in
each editor.

   There are several common user actions that are available in edit
dialogs.  For example, hitting `RET' while the cursor is positioned in
the name field of the editor commits the concept.  Most editors have
`OK' and `Cancel' buttons at the bottom  to commit or abort edits.
Lists of items commonly have `+' and `--' buttons at the top that allow
one to add a new item or delete the selected item.  When the `+' button
is pressed, either a chooser dialog (*note Choosers::) or a specialized
editor will be opened.  Similar to the browser, list items can be
right-clicked to display a list of possible actions.  For example, a
superconcept can be clicked in a concept editor to immediately edit the
concept's parent.

 [image src="../../../sources/powerloom-gui/doc/images/gui-instance-editor.gif" ]

Figure 8.4: Instance Editor

   Each type of object has a specialized editor.  For example, an
instance editor is shown in *note Figure 8.4: fig:instedit.  There are
separate editors for modules, concepts, relations, instances, and
propositions/rules, which are described below.

   *Module Editor*: The module editor contains a number of fields and
components used to enter information relevant for a new or existing
module.  Examples of values that can be edited are a module's name, its
documentation and its includes (or supermodules) list.

   *Concept Editor*: The concept editor allows editing of concept
attributes such as a concept's supertypes, its name, its associated
propositions, etc.  In addition to the inherent attributes of a
concept, all relations which have the concept as a domain type are
displayed and may be edited.  Clicking the `+' button above the
relation list opens a new relation editor with default values filled
in.  Similarly, clicking the `+' button above the proposition list
opens a proposition editor.

   *Relation Editor*: The relation editor allows the user to enter a
list of variables and types for the relation's arguments, and allows
the setting of various relation attributes, e.g., whether the relation
is closed, functional, etc.  Similar to the concept editor,
propositions and rules associated with a relation can be edited.

   *Instance Editor*: The instance editor allows the user to input an
instance's name, documentation, and associated propositions.  If a
proposition uses the relation `image-url', an image will be retrieved
from the server and presented in the editor window.

   *Proposition editor*: The proposition editor, shown in *note
fig:propedit::, consists of a text field for entering the proposition,
and a set of buttons for performing actions on the proposition.  The
buttons allow a user to assert, deny, or retract the typed proposition.
There are several text-based facilities which support efficient editing
of propositions.  First, the editor supports many Emacs-style
keybindings which facilitate editing of Lisp-like expressions,
including selecting entire parenthesis-delimited subexpressions,
jumping backward and forward over subexpressions, and navigating up and
down expression trees.

 [image src="../../../sources/powerloom-gui/doc/images/gui-proposition-editor.gif" ]

Figure 8.5: Proposition Editor

   In addition to Emacs keybindings, the proposition editor has a
matching parenthesis highlighter.  When the cursor is placed before a
left parenthesis, the matching right parenthesis is highlighted, and
when the cursor is placed after a right parenthesis, the matching left
parenthesis is highlighted.

   The proposition editor also supports symbol completion.  The GUI uses
a predictive backtracking parser to analyze partial input of
propositions.  Based on the analysis, the parser is able to recommend
appropriate completions.  For example, if the user types `(f' and then
selects the completion action by typing `Ctrl-right', the parser will
recommend a list of completions including the `forall' symbol and all
concepts and relations that begin with the letter `f'.


File: manual.info,  Node: Choosers,  Next: Extension Editor,  Prev: Editing,  Up: GUI Features

8.4.6 Choosers
--------------

In a number of situations, an object of a specific type must be
selected.  For example, when selecting a superconcept in a concept
editor, the user should be presented with a list of existing concepts.
In these cases, a chooser dialog is presented to the user which
displays a filterable list of candidate objects.  As the user types a
name of the object in the name text field, the list of objects is
filtered so that only objects which begin with the typed prefix are
displayed.  Choosers are available for modules, concept, instances, and
relations.  A variable chooser allows the user to type a variable name
and select a type from a concept from a list.

 [image src="../../../sources/powerloom-gui/doc/images/gui-extension-editor.gif" ]

Figure 8.6: Extension Editor


File: manual.info,  Node: Extension Editor,  Next: Ask and Retrieve Queries,  Prev: Choosers,  Up: GUI Features

8.4.7 Extension Editor
----------------------

The extension editor, shown in *note Figure 8.6: fig:extedit, allows
editing of a concept or relation's extension.  It can be opened by
right-clicking on a concept or relation in the browser or by selecting
the `Query -> Edit Extension' menu item.  The extension editor presents
a relation's extension as a list of tuples in table format.  The user
may add new tuples by typing names of instances at the bottom of the
table, and may alter existing tuples by double-clicking on a table cell
and typing in a new value.  Instance name completion is available while
typing instance names by typing `Ctrl-right'.  A user may choose to
abort the edited extension by clicking the `Cancel' button.  If the
user clicks the `Commit' button, the relation's extension will be
updated by asserting and retracting appropriate propositions.


File: manual.info,  Node: Ask and Retrieve Queries,  Next: Search,  Prev: Extension Editor,  Up: GUI Features

8.4.8 Ask and Retrieve Queries
------------------------------

 [image src="../../../sources/powerloom-gui/doc/images/gui-query-dialog.gif" ]

Figure 8.7: Query Dialog

   The Query dialog, shown in *note Figure 8.7: fig:query, can be
opened by selecting the `Query -> Query' menu item, by typing `Ctrl-Q'
or by pressing the query toolbar button.  The Query dialog consists of a
text area for typing the query, a results table for displaying the
results of the query, a query list for saving and selecting pre-saved
queries, and an options subpane for configuring various query
parameters.

   The query input pane supports features similar to that of the
proposition editor, including Emacs key bindings, parenthesis matching
and completion.  Queries can be executed by typing `Ctrl-RET' or by
clicking on the `Execute' button at the bottom of the dialog.  After a
query has executed, results will be displayed in the results table or a
"No results found" indicator will flash.  The column headers for the
results will display the corresponding free variables in the query.
Results may be sorted by clicking on a column header.  Doing so will
sort the results by using the clicked column as an index.  Users may
toggle ascending/descending sort order by clicking the header multiple
times.

   If the query contains no free variables, it is effectively a
true/false `ASK' operation as opposed to a `RETRIEVE'.  In this case,
the result will be a truth value, and the column header will be labeled
`TRUTH-VALUE'.  If the query is the result of a partial retrieve
operation, an additional column containing the match score will be
displayed.

   If the user clicks on a cell in the results table, the topmost
browser will be updated to display the selected item.  Right-clicking
on a query result brings up a context menu which currently only
contains an `Explain result' menu item.  Selecting this will present an
HTML explanation in a separate window.  The displayed explanation may
contain hyperlinked objects.  Clicking on a hyperlinked object will
update the topmost browser to display the object.

   Users may save frequently-executed queries in a query list by
clicking the `Save' button at the top of the options panel which will
prompt them for a query name.  Saved queries will be stored in the
preferences file using an XML representation.  Saved queries are stored
in the combobox to the left of the save button.  Selection of a saved
query will prefill the query dialog with the query and all saved
parameters.

   Most important PowerLoom query options are controllable in the
options dialog, such as number of results to retrieve, inference control
options such as inference level, timeout, moveout and various others.


File: manual.info,  Node: Search,  Next: Console,  Prev: Ask and Retrieve Queries,  Up: GUI Features

8.4.9 Search
------------

Users may search for objects in the KB by entering strings which match
the name of the object.  A search dialog as shown in *note fig:search::
can be opened by selecting the `Query -> Search' menu item, by typing
`Ctrl-f', or by pushing a search toolbar button (marked by a flashlight
icon) inside the browser.  If the user activates a search toolbar
button inside a navigation pane, the search dialog will be configured
to search for objects associated with the type of object displayed in
that pane.  For example pushing the search button inside the concept
navigation pane will configure the search dialog to look for concept
objects only.

   Searches may be constrained in several ways.  First, the module may
be specified or the user may specify that the search should be across
all modules.  Second, the types of objects to be searched is
configurable.  For example, users may search for concepts and
instances, instances only, etc.  Finally, users may specify that an
object's name must match the beginning or end of the search string, or
match the search string exactly.

 [image src="../../../sources/powerloom-gui/doc/images/gui-search-dialog.gif" ]

Figure 8.8: Search Dialog

   When the user executes the search by hitting `RET' or selecting the
`OK' button, a list of results is presented.  These results are
provided in a table format where one column is the name of the
retrieved object, another column contains the module that the object
resides in, and the final column specifies the type of the object
(i.e., concept, instance, etc).  As is the case with query results,
clicking on a search result item will update the topmost browser to
display the selected object.


File: manual.info,  Node: Console,  Next: Cut/Copy/Paste/Delete,  Prev: Search,  Up: GUI Features

8.4.10 Console
--------------

The console window, as shown in *note fig:console::, can be opened by
selecting the `KB -> Open PowerLoom Console' menu item or by typing
`Ctrl-p'.  This opens an internal window, which allows PowerLoom
commands to be typed directly and sent to the PowerLoom server.  The
response generated by PowerLoom is sent back to the GUI and printed
below the prompt.  This functionality is similar to that of a LISP
listener.

 [image src="../../../sources/powerloom-gui/doc/images/gui-console.gif" ]

Figure 8.9: PowerLoom Console


File: manual.info,  Node: Cut/Copy/Paste/Delete,  Prev: Console,  Up: GUI Features

8.4.11 Cut/Copy/Paste/Delete
----------------------------

The PowerLoom GUI supports cut, copy, paste, and delete operations.
These operations can be used to edit text, and in some cases they can
be used to edit objects in lists or trees.  For example, the concept
hierarchy can be edited within the browser by selecting a concept,
executing a cut operation, selecting another concept, and then
executing paste.  This sequence of operations will delete the concept
from it's original position in the hierarchy, and make it a subconcept
of the concept that was selected when the paste operation was performed.

   The GUI implements a robust data transfer framework that is capable
of recognizing the types of objects that are being transferred, and the
types of potential transfer sources and destinations.  This allows the
application to prohibit nonsensical data transfers such as cutting a
concept in a concept navigation pane and then trying to paste it into a
module pane.  It also allows data transfer operations to be context
sensitive.  For example, cutting a concept in a concept navigation pane
means that a move operation is being initiated, while cutting a concept
in a concept editor's superconcept list means that the concept should
be removed from the list.  Additionally, copying an object such as a
concept, then executing a paste inside a text window will paste the
name of the object.

   As one would expect, text may be cut, copied and pasted between the
GUI and outside applications.


File: manual.info,  Node: Future Work,  Prev: GUI Features,  Up: PowerLoom GUI

8.5 Future Work
===============

There are many areas where further development and improvement is
needed, including:

* Menu:

* Large KBs::
* Undo::
* Drag and Drop::
* Scrapbook::
* Instance Cloning::
* Security::
* Multiple Users::


File: manual.info,  Node: Large KBs,  Next: Undo,  Prev: Future Work,  Up: Future Work

8.5.1 Large KBs
---------------

Currently, when a module is selected, the GUI attempts to retrieve all
concepts, relations, and instances that are contained in that module.
For large knowledge bases that might contain millions of objects and
assertions, this is clearly infeasible.  To handle such situations we
need to develop more sophisticated retrieval and caching strategies to
only materialize partial views of a KB in the GUI.  Scrolling down a
list, for example, might then trigger the retrieval and display of
additional objects on demand, while older, inactive objects are being
flushed from the cache.


File: manual.info,  Node: Undo,  Next: Drag and Drop,  Prev: Large KBs,  Up: Future Work

8.5.2 Undo
----------

There is currently no undo facility and changes to the KB are written
through to the server as soon as a user clicks `OK' in an editing
dialog.  To support this properly, we would need a snapshot mechanism
that would allow rollback to earlier states of the KB.


File: manual.info,  Node: Drag and Drop,  Next: Scrapbook,  Prev: Undo,  Up: Future Work

8.5.3 Drag and Drop
-------------------

Adding a drag and drop capability would make ontology editing easier
than is currently possible.  For example, one concept could be dragged
on top of another to move the object from its current position.  We
believe that the existing data transfer framework could be leveraged to
implement a robust drag and drop facility.


File: manual.info,  Node: Scrapbook,  Next: Instance Cloning,  Prev: Drag and Drop,  Up: Future Work

8.5.4 Scrapbook
---------------

In creating and editing ontologies, it is sometimes desirable to
maintain heterogeneous scraps of information.  We envision a scrapbook
feature where text and objects of various types could be dragged to and
organized visually for later use.


File: manual.info,  Node: Instance Cloning,  Next: Security,  Prev: Scrapbook,  Up: Future Work

8.5.5 Instance Cloning
----------------------

It is often useful to create new instances that are similar to existing
instances.  We would like to implement a cloning facility in which a
wizard-like series of dialogs would step the user through the process
of copying information from one object to a new object.  For example,
the dialogs would prompt the user for propositions to transfer from the
old instance to the new instance, and allow the user to modify the
propositions in the process of transferring them.


File: manual.info,  Node: Security,  Next: Multiple Users,  Prev: Instance Cloning,  Up: Future Work

8.5.6 Security
--------------

There is currently no authentication and access control mechanisms in
the PowerLoom GUI.  The GUI client assumes that is communicating with a
trusted host over a secure network.  Similarly, the PowerLoom server
assumes that it is communicating with a friendly client that has full
access to the server.  In the future, we need to add security
mechanisms which allow clients to be authenticated, and resources on
the server to be made accessible to authorized users only.  In
addition, we need to implement encryption mechanisms so that clear text
is not sent over insecure networks, potentially compromising sensitive
data.


File: manual.info,  Node: Multiple Users,  Prev: Security,  Up: Future Work

8.5.7 Multiple Users
--------------------

Although the client/server model allows multiple GUI clients to
concurrently share the same server, there is only very weak support for
synchronizing clients and ensuring that users don't accidentally step
on each other.  We need to improve our infrastructure to handle
notification of KB updates, add support for transactions and KB
locking, and improve our caching mechanisms to detect when the GUI
state is out of sync with respect to the server.


File: manual.info,  Node: Ontosaurus,  Next: Installation,  Prev: PowerLoom GUI,  Up: Top

9 Ontosaurus
************

Ontosaurus is a Web-based KB browser that offers a convenient way to
view the contents of PowerLoom knowledge bases from a standard Web
browser.  Whenever a user searches for an object or clicks on a
hyperlink, Ontosaurus dynamically generates HTML pages describing the
requested object and related information.  The description will itself
contain links to other relevant objects which the user can click on to
quickly "surf" through a knowledge base.

   Similar to the PowerLoom GUI (*note PowerLoom GUI::), Ontosaurus
relies on a PowerLoom server that can handle HTTP requests.  For this
reason, it is currently only supported in the Java version of PowerLoom
or in Lisp version that supports a Web server such as AServe or
Portable AServe (e.g., Allegro CL).

   To use Ontosaurus, do the following.  Start PowerLoom in Java or a
qualifying Lisp version.  Once  PowerLoom is up and running, issue the
following command:

     PL-USER |= (start-ontosaurus)

     Loading required system webtools
     Loading required system ontosaurus

     PL-USER |=

   The command also accepts a `:port' option to make the server listen
to a different port.  Once the Ontosaurus server is running, go to your
Web browser and enter the following URL:
`http://localhost:9090/ploom/ontosaurus/' Substitute a fully qualified
host name and different port if necessary.  Ontosaurus comes with a
short online help page and is otherwise self-explanatory.

   Alternatively, the PowerLoom Web Archive available in
     powerloom-x.y.z/native/java/lib/ploom.war

can be deployed in an Apache Tomcat server by copying it into the
server installation's `webapps' directory.  Ontosaurus can then connect
to it at the above URL at the server port used by Tomcat.


File: manual.info,  Node: Installation,  Next: Miscellaneous,  Prev: Ontosaurus,  Up: Top

10 Installation
***************

* Menu:

* System Requirements::
* Unpacking the Sources::
* Lisp Installation::
* C++ Installation::
* Java Installation::
* Removing Unneeded Files::
* Installing PowerLoom Patches::


File: manual.info,  Node: System Requirements,  Next: Unpacking the Sources,  Prev: Installation,  Up: Installation

10.1 System Requirements
========================

To install and use PowerLoom, you'll approximately need the following
amounts of disk space:

   * 16 MB for the tarred or zipped archive file

   * 70 MB for the untarred sources, tanslations, compiled Java files,
     and documentation

   * 16 MB to compile a Lisp version

   * 16 MB to compile the C++ version (without -g)

   * 5 MB to compile the Java version (already included)


   This means that you will need approximately 100 MB to work with one
Lisp, one C++ and one Java version of PowerLoom in parallel.  If you
also want to experiment with the Lisp translation variant that uses
structures instead of CLOS instances to implement STELLA objects, then
you will need an extra 16 MB to compile that.

   The full PowerLoom development tree is quite large, since for every
STELLA source file there are three to four translated versions and as
many or more compiled versions thereof.  The actual PowerLoom libraries
that you have to ship with an application, however, are quite small.
For example, the Java jar files `powerloom.jar' and `stella.jar' are
only 2.3 MB total (4 MB including Java sources).  The dynamic C++
libraries `libstella.so' and `liblogic.so' compiled on a Linux
platform, are about 8 MB total.  Additionally, if you don't need all
the different translations of PowerLoom, you can delete some of the
versions to keep your development tree smaller *Note Removing Unneeded
Files::.

   To run the Lisp version of PowerLoom, you will need an ANSI
Common-Lisp (or at least one that supports CLOS and logical pathnames).
We have successfully tested PowerLoom with Allegro-CL 4.2, 4.3, 5.0,
6.0 and 7.0, Macintosh MCL 3.0, 4.0 and 5.1, OpenMCL 1.0, SBCL 0.9.4,
CMUCL 19c, LispWorks 4.4.6, CLisp 2.37, Lucid CL 4.1 (plus the
necessary ANSI extensions and Mark Kantrowitz's logical pathnames
implementation), and various others.  Our main development platform is
Allegro CL running under Sun Solaris and Linux.  The closer your
environment is to ours, the higher are the chances that everything will
work right out of the box.  Lisp development under Windows should also
be no problem.

   To run the C++ version of PowerLoom, you will need a C++ compiler
(such as g++) that supports templates and exception handling.  We have
successfully compiled and run PowerLoom with g++ 3.2 and later under
Linux Redhat 8.0 & 9.0, SunOS and MacOS X, and with CygWin 5.0 and MinGW
5.0 under Windows 2000 and XP.  Both CygWin and MinGW provide a GNU Unix
environment, but MinGW can generate Windows executables that are fully
standalone.  We've also managed to compile PowerLoom under MS Visual
C++, however, we never got the Boehm garbage collector to work.  The GC
claims to be very portable, so this should be solvable for somebody with
good knowledge of MS Visual C++.

   For the Java version, you will need Java JDK 1.2 or later. To get
reasonable performance, you should use J2SDK 1.4 or 1.5.  We've run the
Java version of PowerLoom on a variety of platforms without any
problems.

   Any one of the Lisp, C++, or Java implementations of PowerLoom can be
used to develop your own PowerLoom-based applications.  Which one you
choose is primarily a matter of your application and programming
environment.  The Lisp and Java versions are comparable in speed, the
C++ version is usually a factor of 2-3 faster than Lisp or Java.


File: manual.info,  Node: Unpacking the Sources,  Next: Lisp Installation,  Prev: System Requirements,  Up: Installation

10.2 Unpacking the Sources
==========================

Uncompress and untar the file `powerloom-X.Y.Z.tar.gz' (or unzip the
file `powerloom-X.Y.Z.zip') in the parent directory of where you want
to install PowerLoom (`X.Y.Z' are place holders for the actual version
numbers).  This will create the PowerLoom tree in the directory
`powerloom-X.Y.Z/' (we will use Unix syntax for pathnames).  All
pathnames mentioned below will be relative to that directory which we
will usually refer to as the "PowerLoom directory".


File: manual.info,  Node: Lisp Installation,  Next: C++ Installation,  Prev: Unpacking the Sources,  Up: Installation

10.3 Lisp Installation
======================

To install the Lisp version of PowerLoom, startup Lisp and load the file
`load-powerloom.lisp' with:

     (CL:load "load-powerloom.lisp")

   The first time around, this will compile all Lisp-translated STELLA
files before they are loaded.  During subsequent sessions, the compiled
files will be loaded right away.

   By default, PowerLoom now uses the version that uses Lisp structs
instead of CLOS objects to implement STELLA objects.  If you do want to
use the CLOS-based version instead do the following:

     (CL:setq cl-user::*load-cl-struct-stella?* CL:nil)
     (CL:load "load-powerloom.lisp")

   Alternatively, you can edit the initial value of the variable
`*load-cl-struct-stella?*' in the file `load-powerloom.lisp'.  Using
structs instead of CLOS objects greatly improves slot access speed,
however, it may cause problems with incremental re-definition of STELLA
classes (this is only an issue if you are developing your application
code in the STELLA language.  In that case, it is recommended to only
use the struct option for systems that are in or near the production
stage).

   Once all the files are loaded, you should see a message similar to
this:

     PowerLoom 3.2.0 loaded.
     Type `(powerloom)' to get started.
     Type `(in-package "STELLA")' to run PowerLoom commands directly
        from the Lisp top level.
     USER(2):

   To reduce startup time, you might want to create a Lisp image that
has all of PowerLoom preloaded.

   Now type
     (in-package "STELLA")

   to enter the `STELLA' Lisp package where all the PowerLoom code
resides.  Alternatively, you can type

     (powerloom)

   which will bring up a PowerLoom listener that will allow you to
execute PowerLoom commands.

   *IMPORTANT*: All unqualified Lisp symbols in this document are
assumed to be in the `STELLA' Lisp package.  Moreover, the `STELLA'
package does *NOT* inherit anything from the `COMMON-LISP' package (see
the file `sources/stella/cl-lib/cl-setup.lisp' for the few exceptions).
Hence, you have to explicitly qualify every Lisp symbol you want to use
with `CL:'.  For example, to get the result of the previous evaluation,
you have to type `CL:*' instead of `*'.


File: manual.info,  Node: C++ Installation,  Next: Java Installation,  Prev: Lisp Installation,  Up: Installation

10.4 C++ Installation
=====================

To compile the C++ version of PowerLoom, change to the native C++
directory of PowerLoom and run `make' like this:

     % cd native/cpp/powerloom
     % make

   This will compile all PowerLoom and STELLA files as well as the C++
garbage collector.  It will then generate static or dynamic
`libstella', `liblogic' and other library files in the directory
`native/cpp/lib' which can be linked with your own C++-translated
PowerLoom (or other) code.  To test whether the compilation was
successful, you can run PowerLoom from the top-level PowerLoom
directory using the `powerloom' script (or `powerloom.bat' under a
Windows command prompt):

     % powerloom c++
     Running C++ version of PowerLoom...
     Initializing STELLA...
     Initializing PowerLoom...

         Welcome to PowerLoom 4.0.0

     Copyright (C) USC Information Sciences Institute, 1997-2010.
     PowerLoom comes with ABSOLUTELY NO WARRANTY!
     Type `(copyright)' for detailed copyright information.
     Type `(help)' for a list of available commands.
     Type `(demo)' for a list of example applications.
     Type `bye', `exit', `halt', `quit', or `stop', to exit.


     PL-USER |=

   This will run various PowerLoom startup code and then bring up a
PowerLoom command loop where you can execute commands.  The `c++'
argument tells the script to run the C++ version of PowerLoom (which is
also run by default as long as the C++ version was compiled).  If the
C++ version was not compiled or the `java' argument was given instead,
the Java version of PowerLoom will be run.

   Type

     (demo)

   to bring up a menu of available demos, type

     (run-powerloom-tests)

   to run the PowerLoom test suite, or type

     exit

   to exit PowerLoom.


File: manual.info,  Node: Java Installation,  Next: Removing Unneeded Files,  Prev: C++ Installation,  Up: Installation

10.5 Java Installation
======================

Nothing needs to be done to install the Java version.  Because Java
class files are platform independent, they are already shipped with the
PowerLoom distribution and can be found in the directory `native/java'
and its subdirectories.  Additionally, they have been collected into
the file `native/java/lib/powerloom.jar' in the PowerLoom directory.
To try out the Java version of PowerLoom, you can run PowerLoom from
the top-level PowerLoom directory using the `powerloom' script (or
`powerloom.bat' under a Windows command prompt):

     % powerloom java
     Running Java version of PowerLoom...
     Initializing STELLA...
     Initializing PowerLoom...

         Welcome to PowerLoom 4.0.0

     Copyright (C) USC Information Sciences Institute, 1997-2010.
     PowerLoom comes with ABSOLUTELY NO WARRANTY!
     Type `(copyright)' for detailed copyright information.
     Type `(help)' for a list of available commands.
     Type `(demo)' for a list of example applications.
     Type `bye', `exit', `halt', `quit', or `stop', to exit.


     PL-USER |=

   Similar to the C++ executable, this will run various PowerLoom
startup code and then bring up a PowerLoom command loop where you can
execute commands.  Type

     (demo)

   to bring up a menu of available demos, type

     (run-powerloom-tests)

   to run the PowerLoom test suite, or type

     exit

   to exit PowerLoom.


File: manual.info,  Node: Removing Unneeded Files,  Next: Installing PowerLoom Patches,  Prev: Java Installation,  Up: Installation

10.6 Removing Unneeded Files
============================

To save disk space, you can remove files that you don't need.  For
example, if you are not interested in the C++ version of PowerLoom, you
can delete the directory `native/cpp'.  Similarly, you can remove
`native/java' to eliminate all Java-related files.  You could do the
same thing for the Lisp directory `native/lisp', but (in our opinion)
that would make it less convenient for you to develop new PowerLoom
code that is written in STELLA.  Finally, if you don't need any of the
STELLA sources, you can delete the directory `sources/stella'.  If you
don't need local copies of the STELLA and PowerLoom documentation, you
can delete parts or all of the directories `sources/stella/doc' and
`sources/logic/doc'.


File: manual.info,  Node: Installing PowerLoom Patches,  Prev: Removing Unneeded Files,  Up: Installation

10.7 Installing PowerLoom Patches
=================================

If you already have an older version of PowerLoom installed, you can
upgrade to the latest patch level by downloading incremental sets of
patches instead of downloading the complete release.  Patch files are
usually significantly smaller than the complete release and patching an
existing installation can also preserve local additions, deletions, or
modifications.  PowerLoom patch files are available from the same
location as the full PowerLoom release.

   Patches are currently only available in Unix `diff' format which
requires the Unix `patch' utility to install them (the `patch' program
should be readily available on most Unix systems, otherwise, you can
get it for free from the Free Software Foundation).

   Patch files follow the following naming convention: Suppose the
current version of PowerLoom is 3.0.0.  Then the patch file to update
to the next patch level is called `powerloom-3.0.0-3.0.1.diff.gz'.

   *Important:* Patch files are strictly incremental.  Thus, to upgrade
from version 3.0.0 to 3.0.2, you will need two patch files: one to go
to version 3.0.1 and one to go from that to version 3.0.2; you will
have to apply them in that sequence.

   To find out the current version of your PowerLoom installation, look
at the version string displayed when the `powerloom' function is called
in Lisp, or when the C++ or Java program starts up.

   *Important:* Before you apply any patches, you should always make a
backup copy of your current PowerLoom installation to preserve any
local modifications you made, in case something goes wrong.

   To apply patches, copy the appropriate patch file to the top level of
your PowerLoom installation directory.  Suppose the patch file is called
`powerloom-3.0.0-3.0.1.diff.gz'.  You can apply the patches using the
following command:

     gunzip -qc powerloom-3.0.0-3.0.1.diff.gz | patch -p1

   If you deleted some native PowerLoom files to save space, you can
use the `-f' option to force `patch' to proceed even if files it needs
to patch do not exist anymore (this is somewhat dangerous in case
`patch' encounters some more serious problems).  For example:

     gunzip -qc powerloom-3.0.0-3.0.1.diff.gz | patch -p1 -f

   To keep patch files small, PowerLoom patch files do not contain
updated binary files that ship with the full release (such as Java
class files, jar files and PDF documents).  Those have to be
regenerated either manually or with help of available `Makefile's.  The
Lisp version of PowerLoom will automatically recompile the first time
the updated system is loaded.  To recompile the C++ installation follow
the installation instructions given above.  The Java version will need
to be recompiled manually (better patch recompilation support might
become available in the future).

