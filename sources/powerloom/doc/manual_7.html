<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Copyright C 2010
University of Southern California, Information Sciences Institute,
4676 Admiralty Way,
Marina Del Rey, CA 90292, USA

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

PowerLoom is a registered trademark of the University of Southern California.

 -->
<!-- Created on April 15, 2011 by texi2html 1.82
texi2html was written by: 
            Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>
-->
<head>
<title>PowerLoom Manual: 7. Built-In Relations</title>

<meta name="description" content="PowerLoom Manual: 7. Built-In Relations">
<meta name="keywords" content="PowerLoom Manual: 7. Built-In Relations">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.82">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.roman {font-family:serif; font-weight:normal;}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Built_002dIn-Relations"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="manual_6.html#Utility-Classes-for-Java" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="manual_8.html#PowerLoom-GUI" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="manual_6.html#PowerLoom-API" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="manual.html#Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="manual_8.html#PowerLoom-GUI" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="manual.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="manual_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="manual_14.html#Function-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="manual_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Built_002dIn-Relations-1"></a>
<h1 class="chapter">7. Built-In Relations</h1>

<p>This chapter lists relations that come predefined in PowerLoom. They
are defined in the module <code>PL-KERNEL</code>; users can access them by
including or using the <code>PL-KERNEL</code> module within the declarations
of their own modules.
</p>
<dl>
<dt><a name="index-_002a"></a><u>Function:</u> <b>*</b><i> ((?x <small>NUMBER</small>) (?y <small>NUMBER</small>)) :-&gt; (?z <small>NUMBER</small>)</i></dt>
<dd><p>Function that multiplies two numbers.
</p></dd></dl>

<dl>
<dt><a name="index-_002b"></a><u>Function:</u> <b>+</b><i> ((?x <small>NUMBER</small>) (?y <small>NUMBER</small>)) :-&gt; (?z <small>NUMBER</small>)</i></dt>
<dd><p>Function that adds two numbers.
</p></dd></dl>

<dl>
<dt><a name="index-_002d"></a><u>Function:</u> <b>-</b><i> ((?x <small>NUMBER</small>) (?y <small>NUMBER</small>)) :-&gt; (?z <small>NUMBER</small>)</i></dt>
<dd><p>Function that subtracts two numbers.
</p></dd></dl>

<dl>
<dt><a name="index-_002f"></a><u>Function:</u> <b>/</b><i> ((?x <small>NUMBER</small>) (?y <small>NUMBER</small>)) :-&gt; (?z <small>NUMBER</small>)</i></dt>
<dd><p>Function that divides two numbers.
</p></dd></dl>

<dl>
<dt><a name="index-_003c"></a><u>Relation:</u> <b>&lt;</b><i> ((?x <small>THING</small>) (?y <small>THING</small>))</i></dt>
<dd><p>True if ?x &lt; ?y.
</p></dd></dl>

<dl>
<dt><a name="index-_003d_003c"></a><u>Relation:</u> <b>=&lt;</b><i> ((?x <small>THING</small>) (?y <small>THING</small>))</i></dt>
<dd><p>True if ?x &lt;= ?y.
</p></dd></dl>

<dl>
<dt><a name="index-_003e"></a><u>Relation:</u> <b>&gt;</b><i> ((?x <small>THING</small>) (?y <small>THING</small>))</i></dt>
<dd><p>True if ?x &gt; ?y.
</p></dd></dl>

<dl>
<dt><a name="index-_003e_003d"></a><u>Relation:</u> <b>&gt;=</b><i> ((?x <small>THING</small>) (?y <small>THING</small>))</i></dt>
<dd><p>True if ?x &gt;= ?y.
</p></dd></dl>

<dl>
<dt><a name="index-ABSTRACT"></a><u>Relation:</u> <b>ABSTRACT</b><i> ((?r <small>RELATION</small>))</i></dt>
<dd><p>True if there are no direct assertions made
to the relation ?r.
</p></dd></dl>

<dl>
<dt><a name="index-AGGREGATE"></a><u>Concept:</u> <b>AGGREGATE</b><i> ((?a <small>AGGREGATE</small>))</i></dt>
<dd><p>?a is an aggregate
</p></dd></dl>

<dl>
<dt><a name="index-ANTISYMMETRIC"></a><u>Relation:</u> <b>ANTISYMMETRIC</b><i> ((?r <small>RELATION</small>))</i></dt>
<dd><p>A binary relation ?r is antisymmetric if whenever (?r ?x ?y)
is true (?r ?y ?x) is false unless ?x equals ?y.
</p></dd></dl>

<dl>
<dt><a name="index-ARITY"></a><u>Function:</u> <b>ARITY</b><i> ((?r <small>RELATION</small>)) :-&gt; (?arity <small>INTEGER</small>)</i></dt>
<dd><p>The number of arguments/domains of the relation <var>?r</var>.
</p></dd></dl>

<dl>
<dt><a name="index-ASSERTION_002dQUERY"></a><u>Relation:</u> <b>ASSERTION-QUERY</b><i> ((?prop <small>PROPOSITION</small>))</i></dt>
<dd><p>Query ?prop with :inference-level set to :assertion.
Equivalent to <code>(query ?prop :inference-level :assertion)</code> but more efficient.
</p></dd></dl>

<dl>
<dt><a name="index-BACKTRACKING_002dQUERY"></a><u>Relation:</u> <b>BACKTRACKING-QUERY</b><i> ((?prop <small>PROPOSITION</small>))</i></dt>
<dd><p>Query ?prop with :inference-level set to :backtracking.
Equivalent to <code>(query ?prop :inference-level :backtracking)</code> but more efficient.
</p></dd></dl>

<dl>
<dt><a name="index-BINARY_002dRELATION"></a><u>Concept:</u> <b>BINARY-RELATION</b><i> ((?r <small>RELATION</small>))</i></dt>
<dd><p>The class of binary relations.
</p></dd></dl>

<dl>
<dt><a name="index-BOUND_002dVARIABLES"></a><u>Relation:</u> <b>BOUND-VARIABLES</b><i> ((?arguments <small>THING</small>))</i></dt>
<dd><p>True if all arguments are bound.  The <code>bound-variables</code>
predicate is used as a performance enhancer, to prevent other predicates
from backchaining excessively while searching for bindings of certain of
their arguments. Purists will shun the use of this predicate, but some rules
are inherently inefficient without the addition of some kind of control logic.
Because evaluation of the <code>bound-variables</code> predicate evaluation of
predicates being <code>guarded</code>, using this predicate has the side-effect
of locally disabling query optimization.  (See <code>collect-into-set</code> for
an example that uses <code>bound-variables</code>.
</p></dd></dl>

<dl>
<dt><a name="index-CARDINALITY"></a><u>Function:</u> <b>CARDINALITY</b><i> ((?c <small>SET</small>)) :-&gt; (?card <small>INTEGER</small>)</i></dt>
<dd><p>Function that returns the cardinality of a set.
</p></dd></dl>

<dl>
<dt><a name="index-CLOSED"></a><u>Relation:</u> <b>CLOSED</b><i> ((?c <small>COLLECTION</small>))</i></dt>
<dd><p>The collection ?c is closed if all of its members are known.
Asserting that a relation is closed makes certain computations easier.
For example, suppose that the relation <code>happy</code> is closed,
implying that all things that are happy will be asserted as such.
To prove <code>(not (happy Fred))</code>, PowerLoom can use a negation-as-failure 
proof strategy which returns TRUE if <code>Fred</code> cannot be proved to be happy.
Also, if the relation <code>children</code> is closed, then a value for the expression
<code>(range-max-cardinality children Fred)</code> can be inferred merely by
counting the number of fillers of the <code>children</code> role on <code>Fred</code>.
</p></dd></dl>

<dl>
<dt><a name="index-COLLECT_002dINTO_002dASCENDING_002dSET"></a><u>Function:</u> <b>COLLECT-INTO-ASCENDING-SET</b><i> ((?c <small>COLLECTION</small>) (?sortby <small>RELATION</small>)) :-&gt; (?orderedset <small>LIST</small>)</i></dt>
<dd><p>Collect elements of ?c into an ascending ?orderedSet where the position of each
element is determined by the value computed for it by the ?sortBy relation.  Ordering is done via
sorting (as opposed to using a comparison relation) similar to the :sort-by option to the <code>retrieve</code>
command.  If ?sortBy is not single-valued, the position of an element is determined by its largest
?sortBy value.  Note that, similar to other <code>collect-into-...</code> functions, ?c can be a named concept,
a <code>setofall</code> or an enumerated collection, and ?sortBy can be a named relation or a <code>kappa</code>.
</p></dd></dl>

<dl>
<dt><a name="index-COLLECT_002dINTO_002dDESCENDING_002dSET"></a><u>Function:</u> <b>COLLECT-INTO-DESCENDING-SET</b><i> ((?c <small>COLLECTION</small>) (?sortby <small>RELATION</small>)) :-&gt; (?orderedset <small>LIST</small>)</i></dt>
<dd><p>Collect elements of ?c into a descending ?orderedSet where the position of each
element is determined by the value computed for it by the ?sortBy relation.  Ordering is done via
sorting (as opposed to using a comparison relation) similar to the :sort-by option to the <code>retrieve</code>
command.  If ?sortBy is not single-valued, the position of an element is determined by its largest
?sortBy value.  Note that, similar to other <code>collect-into-...</code> functions, ?c can be a named concept,
a <code>setofall</code> or an enumerated collection, and ?sortBy can be a named relation or a <code>kappa</code>.
</p></dd></dl>

<dl>
<dt><a name="index-COLLECT_002dINTO_002dLIST"></a><u>Function:</u> <b>COLLECT-INTO-LIST</b><i> ((?c <small>COLLECTION</small>)) :-&gt; (?l <small>LIST</small>)</i></dt>
<dd><p>Infer as many members of ?c as possible and
collect them into a list ?l.  This is similar to <code>collect-into-set</code>
but collects members in the order they are encountered.  If a member
is derived multiple times, all occurrences are kept.  This is
useful, for example, to collect and then sum up number-valued
attributes of objects.
</p></dd></dl>

<dl>
<dt><a name="index-COLLECT_002dINTO_002dORDERED_002dSET"></a><u>Function:</u> <b>COLLECT-INTO-ORDERED-SET</b><i> ((?c <small>COLLECTION</small>)) :-&gt; (?l <small>LIST</small>)</i></dt>
<dd><p>This is similar to <code>collect-into-list</code>, but if a
member is derived multiple times, only the first occurrence is kept
- hence, the name, even though ordered sets are represented as lists.
</p></dd></dl>

<dl>
<dt><a name="index-COLLECT_002dINTO_002dSET"></a><u>Function:</u> <b>COLLECT-INTO-SET</b><i> ((?c <small>COLLECTION</small>)) :-&gt; (?l <small>SET</small>)</i></dt>
<dd><p>Infer as many members of ?c as possible and
collect them into a set ?l.  For example, here is a rule
used to compute bindings for the <code>fillers</code> predicate:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">  (&lt;= (fillers ?r ?i ?members)
      (and (bound-variables ?r ?i)
           (collect-into-set (setofall ?v (holds ?r ?i ?v)) ?members)))
</pre></td></tr></table>

<p>When <code>?r</code> and <code>?i</code> are bound, the term <code>(setofall ?v (holds ?r ?i ?v))</code>
evaluates to a unary relation satisfied for each filler of the relation
in <code>?r</code> applied to the instance in <code>?i</code>.  <code>collect-into-set</code> causes
the extension of this (dynamically-defined) unary relation to be
computed.  Note the use of <code>bound-variables</code> to screen out unbound
variables before they are passed to the <code>setofall</code> term.
</p></dd></dl>

<dl>
<dt><a name="index-COLLECTION"></a><u>Class:</u> <b><small>COLLECTION</small></b><i> : <small>ABSTRACT-COLLECTION</small></i></dt>
<dd><p>Not documented.
</p><dl>
<dt><a name="index-any_002dvalue"></a><u>Class Parameter:</u> <b>any-value</b><i> : <small>OBJECT</small></i></dt>
<dd><p>Not documented.
</p></dd></dl>
</dd></dl>

<dl>
<dt><a name="index-COLLECTIONOF"></a><u>Function:</u> <b>COLLECTIONOF</b><i> ((?m <small>THING</small>)) :-&gt; (?c <small>COLLECTION</small>)</i></dt>
<dd><p>Abstract function existing to subsume <code>SETOF</code>
and <code>LISTOF</code>.
</p></dd></dl>

<dl>
<dt><a name="index-COMMENT"></a><u>Relation:</u> <b>COMMENT</b><i> ((?x <small>THING</small>) (?s <small>STRING</small>))</i></dt>
<dd><p>?s is a comment attached to ?x.  Comments are
a generalization of other annotations such as <code>documentation</code> and
<code>issue</code> strings.
</p></dd></dl>

<dl>
<dt><a name="index-COMMUTATIVE"></a><u>Relation:</u> <b>COMMUTATIVE</b><i> ((?r <small>RELATION</small>))</i></dt>
<dd><p>A relation ?r is commutative if its truth value is
invariant with any permutation of its arguments.
</p></dd></dl>

<dl>
<dt><a name="index-CONCEPT"></a><u>Concept:</u> <b>CONCEPT</b><i> ((?x <small>RELATION</small>))</i></dt>
<dd><p>The class of reified unary relations.  The Powerloom
notion of <code>concept</code> corresponds to the object-oriented notion of <code>class</code>.
From a logic standpoint, the notion of a concept is hard to distinguish
from the notion of <code>unary relation</code>.  The conceptual distinction is
best illustrated in the domain of linguistics, where concepts are
identified with collective nouns while unary relations are identified
with adjectives.  For example, <code>Rock</code> is a concept, while <code>rocky</code> is a
unary relation.
</p></dd></dl>

<dl>
<dt><a name="index-CONCEPT_002dPROTOTYPE"></a><u>Function:</u> <b>CONCEPT-PROTOTYPE</b><i> ((?c <small>CONCEPT</small>)) :-&gt; (?i <small>THING</small>)</i></dt>
<dd><p>Function that, given a concept, returns a prototypical
instance that inherits all constraints that apply to any concept member,
and has no additional constraints.
</p></dd></dl>

<dl>
<dt><a name="index-CONTEXT"></a><u>Class:</u> <b><small>CONTEXT</small></b><i> : <small>THING</small></i></dt>
<dd><p>Not documented.
</p><dl>
<dt><a name="index-child_002dcontexts"></a><u>Slot:</u> <b>child-contexts</b><i> : <small>(LIST OF CONTEXT)</small></i></dt>
<dd><p>Not documented.
</p></dd></dl>
<dl>
<dt><a name="index-base_002dmodule"></a><u>Slot:</u> <b>base-module</b><i> : <small>MODULE</small></i></dt>
<dd><p>Not documented.
</p></dd></dl>
<dl>
<dt><a name="index-all_002dsuper_002dcontexts"></a><u>Slot:</u> <b>all-super-contexts</b><i> : <small>(CONS OF CONTEXT)</small></i></dt>
<dd><p>Not documented.
</p></dd></dl>
<dl>
<dt><a name="index-context_002dnumber"></a><u>Slot:</u> <b>context-number</b><i> : <small>INTEGER</small></i></dt>
<dd><p>Not documented.
</p></dd></dl>
</dd></dl>

<p>#$(util/texinfo-insert-doc /PL-KERNEL/context-of)
</p><dl>
<dt><a name="index-COVERING"></a><u>Relation:</u> <b>COVERING</b><i> ((?c <small>COLLECTION</small>) (?cover <small>SET</small>))</i></dt>
<dd><p>True if ?c is a subset of the union of all
collections in the set ?cover (see <code>disjoint-covering</code>).
</p></dd></dl>

<dl>
<dt><a name="index-CUT"></a><u>Relation:</u> <b>CUT</b><i> ((?arguments <small>THING</small>))</i></dt>
<dd><p>Prolog-like CUT.  Succeeds the first time and
then fails.  Side-effect:  Locally disables query optimization.
</p></dd></dl>

<dl>
<dt><a name="index-DIRECT_002dSUBRELATION"></a><u>Relation:</u> <b>DIRECT-SUBRELATION</b><i> ((?r <small>RELATION</small>) (?sub <small>RELATION</small>))</i></dt>
<dd><p>True iff ?sub is a direct subrelation of ?r; written
in set notation, ?sub &lt; ?r, and there is no ?s such that ?sub &lt; ?s &lt; ?r.
This relation will generate bindings for at most one unbound argument.
</p></dd></dl>

<dl>
<dt><a name="index-DIRECT_002dSUPERRELATION"></a><u>Relation:</u> <b>DIRECT-SUPERRELATION</b><i> ((?r <small>RELATION</small>) (?super <small>RELATION</small>))</i></dt>
<dd><p>True iff ?super is a direct superrelation of ?r;
in set notation, ?super &gt; ?r, and there is no ?s such that ?super &gt; ?s &gt; ?r.
This relation will generate bindings for at most one unbound argument.
</p></dd></dl>

<dl>
<dt><a name="index-DISJOINT"></a><u>Relation:</u> <b>DISJOINT</b><i> ((?c1 <small>COLLECTION</small>) (?c2 <small>COLLECTION</small>))</i></dt>
<dd><p>True if the intersection of ?c1 and ?c2 is empty.
</p></dd></dl>

<dl>
<dt><a name="index-DISJOINT_002dCOVERING"></a><u>Relation:</u> <b>DISJOINT-COVERING</b><i> ((?c <small>COLLECTION</small>) (?disjointcover <small>SET</small>))</i></dt>
<dd><p>True if ?c is covered by the collections in ?disjointCover
and if the member sets in ?disjointCover are mutually-disjoint.  For
example the concepts <code>Igneous-Rock</code>, <code>Metamorphic-Rock</code>, and
<code>Sedimentary-Rock</code> together form a disjoint covering of the concept <code>Rock</code>.
</p></dd></dl>

<dl>
<dt><a name="index-DOCUMENTATION"></a><u>Relation:</u> <b>DOCUMENTATION</b><i> ((?x <small>THING</small>) (?s <small>STRING</small>))</i></dt>
<dd><p>?s is a documentation string attached to ?x.  Some
of the PowerLoom text processing tools look for documentation strings and 
import them into documents.
</p></dd></dl>

<dl>
<dt><a name="index-DOMAIN"></a><u>Relation:</u> <b>DOMAIN</b><i> ((?r <small>RELATION</small>) (?d <small>COLLECTION</small>))</i></dt>
<dd><p>True if for any tuple <code>T</code> that satifies ?r, the first
argument of <code>T</code> necessarily belongs to the concept ?d.  <code>domain</code> exists
for convenience only and is defined in terms of <code>nth-domain</code>.  <code>domain</code>
assertions should be avoided, since they create redundant <code>nth-domain</code>
propositions (use <code>nth-domain</code> directly).
</p></dd></dl>

<dl>
<dt><a name="index-DUPLICATE_002dFREE"></a><u>Relation:</u> <b>DUPLICATE-FREE</b><i> ((?c <small>COLLECTION</small>))</i></dt>
<dd><p>?c is duplicate-free if no two members
denote the same object.
</p></dd></dl>

<dl>
<dt><a name="index-DUPLICATE_002dFREE_002dCOLLECTION"></a><u>Concept:</u> <b>DUPLICATE-FREE-COLLECTION</b><i> ((?c <small>COLLECTION</small>))</i></dt>
<dd><p>?c is free of duplicates
</p></dd></dl>

<dl>
<dt><a name="index-EMPTY"></a><u>Relation:</u> <b>EMPTY</b><i> ((?c <small>COLLECTION</small>))</i></dt>
<dd><p>The collection ?c is empty if it has no members.  Note
that for collections possessing open-world semantics, (e.g., most concepts)
the fact that the collection has no known members does not necessarily
imply that it is empty.
</p></dd></dl>

<dl>
<dt><a name="index-EQUIVALENT_002dRELATION"></a><u>Relation:</u> <b>EQUIVALENT-RELATION</b><i> ((?r <small>RELATION</small>) (?equiv <small>RELATION</small>))</i></dt>
<dd><p>True if ?r is equivalent to ?equiv; written in set notation,
?r = ?equiv.  This relation will generate bindings for at most one unbound
argument.
</p></dd></dl>

<dl>
<dt><a name="index-EXAMPLE"></a><u>Relation:</u> <b>EXAMPLE</b><i> ((?r <small>RELATION</small>) (?e <small>THING</small>))</i></dt>
<dd><p>?e is an example of (the use of) ?r.
</p></dd></dl>

<dl>
<dt><a name="index-FIFTH_002dELEMENT"></a><u>Function:</u> <b>FIFTH-ELEMENT</b><i> ((?l <small>COLLECTION</small>)) :-&gt; (?e <small>THING</small>)</i></dt>
<dd><p>Return the fifth element ?e of ?l.
</p></dd></dl>

<dl>
<dt><a name="index-FILLERS"></a><u>Function:</u> <b>FILLERS</b><i> ((?r <small>RELATION</small>) (?i <small>THING</small>)) :-&gt; (?members <small>SET</small>)</i></dt>
<dd><p>Given a relation ?r and instance ?i, returns
a set of known fillers of ?r applied to ?i.  IMPORTANT: this also collects
intensional fillers such as skolems that might be identical extensionally.
</p></dd></dl>

<dl>
<dt><a name="index-FIRST_002dELEMENT"></a><u>Function:</u> <b>FIRST-ELEMENT</b><i> ((?l <small>COLLECTION</small>)) :-&gt; (?e <small>THING</small>)</i></dt>
<dd><p>Return the first element ?e of ?l.
</p></dd></dl>

<dl>
<dt><a name="index-FORK"></a><u>Relation:</u> <b>FORK</b><i> ((?test <small>PROPOSITION</small>) (?then <small>PROPOSITION</small>) (?else <small>PROPOSITION</small>))</i></dt>
<dd><p>Fail-based conditional.  If ?test succeeds, evaluates
?then; otherwise evaluates ?else.
</p></dd></dl>

<dl>
<dt><a name="index-FOURTH_002dELEMENT"></a><u>Function:</u> <b>FOURTH-ELEMENT</b><i> ((?l <small>COLLECTION</small>)) :-&gt; (?e <small>THING</small>)</i></dt>
<dd><p>Return the fourth element ?e of ?l.
</p></dd></dl>

<dl>
<dt><a name="index-FRAME_002dPREDICATE"></a><u>Concept:</u> <b>FRAME-PREDICATE</b><i> ((?c <small>RELATION</small>))</i></dt>
<dd><p>A frame predicate is a second-order relation that
is used to describe constraints on the set of fillers for a binary
relation applied to an instance.  Examples of frame predicates are
<code>range-cardinality</code>, <code>range-type</code>, and <code>numeric-inclusive-minimum</code>.
Frame predicates are typically used to capture the kinds of relations
manipulated by description logics such as USC/ISI&rsquo;s Loom and W3C&rsquo;s OWL.
</p></dd></dl>

<dl>
<dt><a name="index-METHOD_002dSLOT"></a><u>Class:</u> <b><small>METHOD-SLOT</small></b><i> : <small>SLOT</small></i></dt>
<dd><p>Not documented.
</p><dl>
<dt><a name="index-method_002dsetter_003f"></a><u>Slot:</u> <b>method-setter?</b><i> : <small>BOOLEAN</small></i></dt>
<dd><p>Not documented.
</p></dd></dl>
<dl>
<dt><a name="index-method_002dparameter_002dnames"></a><u>Slot:</u> <b>method-parameter-names</b><i> : <small>(LIST OF SYMBOL)</small></i></dt>
<dd><p>Not documented.
</p></dd></dl>
<dl>
<dt><a name="index-method_002dparameter_002dtype_002dspecifiers"></a><u>Slot:</u> <b>method-parameter-type-specifiers</b><i> : <small>(LIST OF TYPE-SPEC)</small></i></dt>
<dd><p>Not documented.
</p></dd></dl>
<dl>
<dt><a name="index-method_002dreturn_002dtype_002dspecifiers"></a><u>Slot:</u> <b>method-return-type-specifiers</b><i> : <small>(LIST OF TYPE-SPEC)</small></i></dt>
<dd><p>Not documented.
</p></dd></dl>
<dl>
<dt><a name="index-method_002dstringified_002dsource"></a><u>Slot:</u> <b>method-stringified-source</b><i> : <small>STRING</small></i></dt>
<dd><p>Not documented.
</p></dd></dl>
<dl>
<dt><a name="index-method_002dcode"></a><u>Slot:</u> <b>method-code</b><i> : <small>METHOD-CODE</small></i></dt>
<dd><p>Not documented.
</p></dd></dl>
<dl>
<dt><a name="index-function_002dcode"></a><u>Slot:</u> <b>function-code</b><i> : <small>FUNCTION-CODE</small></i></dt>
<dd><p>Not documented.
</p></dd></dl>
<dl>
<dt><a name="index-method_002dfunction_003f"></a><u>Slot:</u> <b>method-function?</b><i> : <small>BOOLEAN</small></i></dt>
<dd><p>Not documented.
</p></dd></dl>
</dd></dl>

<dl>
<dt><a name="index-GOES_002dFALSE_002dDEMON"></a><u>Relation:</u> <b>GOES-FALSE-DEMON</b><i> ((?r <small>RELATION</small>) (?computation <small>COMPUTED-PROCEDURE</small>))</i></dt>
<dd><p>Names a <code>computation</code> (a function) that is attached (logically)
to ?r  Each time a proposition with predicate ?r becomes
false, the function is applied to that proposition.
</p></dd></dl>

<dl>
<dt><a name="index-GOES_002dTRUE_002dDEMON"></a><u>Relation:</u> <b>GOES-TRUE-DEMON</b><i> ((?r <small>RELATION</small>) (?computation <small>COMPUTED-PROCEDURE</small>))</i></dt>
<dd><p>Names a <code>computation</code> (a function) that is attached (logically)
to ?r  Each time a proposition with predicate ?r becomes
true, the function is applied to that proposition.
</p></dd></dl>

<dl>
<dt><a name="index-GOES_002dUNKNOWN_002dDEMON"></a><u>Relation:</u> <b>GOES-UNKNOWN-DEMON</b><i> ((?r <small>RELATION</small>) (?computation <small>COMPUTED-PROCEDURE</small>))</i></dt>
<dd><p>Names a <code>computation</code> (a function) that is attached (logically)
to ?r  Each time a proposition with predicate ?r becomes
unknown, the function is applied to that proposition.
</p></dd></dl>

<dl>
<dt><a name="index-HOLDS"></a><u>Relation:</u> <b>HOLDS</b><i> ((?relation <small>RELATION</small>) (?arguments <small>THING</small>))</i></dt>
<dd><p>True if the tuple <var>?arguments</var> is a member of the
relation <var>?relation</var>.  <code>holds</code> is a variable arity predicate that takes
a relation as its first argument, and zero or more additional arguments.
It returns values equivalent to a subgoal that has the first argument
as a predicate and the remaining arguments shifted one place to the left.
For <code>holds</code> to succeed, the (first) relation argument must be bound &ndash;
PowerLoom will NOT cycle through all relations searching for ones that
permit the proof to succeed.  However, users can obtain the same effect
if they choose by using other second-order predicates to generate
relation bindings.  For example, the query
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">   (retrieve all ?x (and (Relation ?r)
                         (holds ?r Fred ?x)))
</pre></td></tr></table>

<p>retrieves all constants for which there is some binary relation that
relates <code>Fred</code> to that relation.
</p></dd></dl>

<dl>
<dt><a name="index-IMAGE_002dURL"></a><u>Relation:</u> <b>IMAGE-URL</b><i> ((?x <small>THING</small>) (?url <small>STRING</small>))</i></dt>
<dd><p>?url is a URL pointing to an image illustrating ?x.
The Ontosaurus browser looks for <code>image-url</code> values attached to
objects it is presenting, and displays them prominently, thereby spiffing
up its displays.
</p></dd></dl>

<dl>
<dt><a name="index-INEQUALITY"></a><u>Relation:</u> <b>INEQUALITY</b><i> ((?x <small>THING</small>) (?y <small>THING</small>))</i></dt>
<dd><p>Abstract superrelation of inequality relations.
</p></dd></dl>

<dl>
<dt><a name="index-INSERT_002dELEMENT"></a><u>Function:</u> <b>INSERT-ELEMENT</b><i> ((?l <small>LIST</small>) (?n <small>INTEGER</small>) (?e <small>THING</small>)) :-&gt; (?r <small>LIST</small>)</i></dt>
<dd><p>Add ?e at position ?n (zero-based) to ?l to construct ?r
 (shifts the remaining elements right).  Count from end of the list and shift
left if ?n is  negative such that -1 inserts at the end of the list, -2 second
to last, etc.
</p></dd></dl>

<dl>
<dt><a name="index-INSTANCE_002dOF"></a><u>Relation:</u> <b>INSTANCE-OF</b><i> ((?x <small>THING</small>) (?c <small>COLLECTION</small>))</i></dt>
<dd><p>True if ?x is an instance of ?c.  Can
be used to generate concept values of ?c, given an instance ?x.
</p></dd></dl>

<dl>
<dt><a name="index-INVERSE"></a><u>Function:</u> <b>INVERSE</b><i> ((?r <small>BINARY-RELATION</small>)) :-&gt; (?inverserelation <small>THING</small>)</i></dt>
<dd><p>Function that returns the inverse relation for ?r.
PERFORMANCE NOTE: for best results there should be only one <code>(inverse R I)</code>
assertion per relation pair <code>R</code> and <code>I</code>.  In that case <code>R</code> is viewed as the
canonical relation and <code>I</code> simply provides a different access mechanism to
the canonical relation.  In a logic-based KR paradigm inverse relations are
redundant and do not add anything that couldn&rsquo;t be represented or queried
without them, however, sometimes they can provide some extra convenience for
users.  Asserting <code>(inverse I R)</code> also will not cause an error but can degrade
backward inference performance due to the extra redundant rule that gets
generated.  If domain rules will be written in terms of both <code>R</code> and <code>I</code> (as
opposed to only <code>R</code>), <code>(inverse I R)</code> should be asserted also to get full
inferential connectivity between the two relations.
</p></dd></dl>

<dl>
<dt><a name="index-IRREFLEXIVE"></a><u>Relation:</u> <b>IRREFLEXIVE</b><i> ((?r <small>RELATION</small>))</i></dt>
<dd><p>A binary relation ?r is irreflexive if it is false when both
of its arguments are identical.
</p></dd></dl>

<dl>
<dt><a name="index-ISSUE"></a><u>Relation:</u> <b>ISSUE</b><i> ((?x <small>THING</small>) (?s <small>STRING</small>))</i></dt>
<dd><p>?s is an issue attached to ?x.  An issue string 
normally comments on a topic that has not been resolved to everyone&rsquo;s
satisfaction.
</p></dd></dl>

<dl>
<dt><a name="index-IST"></a><u>Relation:</u> <b>IST</b><i> ((?context <small>CONTEXT</small>) (?p <small>PROPOSITION</small>))</i></dt>
<dd><p>True if proposition <var>?p</var> is true in context <var>?context</var>.
The <code>IST</code> (is true) relation allows one to evaluate a query or rule in more
than one context.  A common use of <code>IST</code> is in defining <code>lifting axioms</code>
that import knowledge from one context to another.  For example, below is
a rule that accesses a <code>patient-record</code> relation in a module called
<code>Medical-Kb</code>, <code>lifts-out</code> the <code>age</code> column, and imports it into a
<code>has-age</code> relation in the current context.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">  (&lt;= (has-age ?person ?age)
      (and (has-ssn ?person ?ssn)
           (exists (?1 ?2 ?3 ?4)
              (ist Medical-Kb (patient-record ?ssn ?1 ?2 ?age ?3 ?4)))))
</pre></td></tr></table>


</dd></dl>

<dl>
<dt><a name="index-LENGTH"></a><u>Function:</u> <b>LENGTH</b><i> ((?x <small>THING</small>)) :-&gt; (?z <small>INTEGER</small>)</i></dt>
<dd><p>Function that returns the length of a string or a logical list.
NOT YET IMPLEMENTED FOR LISTS.
</p></dd></dl>

<dl>
<dt><a name="index-LENGTH_002dOF_002dLIST"></a><u>Relation:</u> <b>LENGTH-OF-LIST</b><i> ((?l <small>COLLECTION</small>) (?length <small>INTEGER</small>))</i></dt>
<dd><p>Computes the length of the list or set ?l.
</p></dd></dl>

<dl>
<dt><a name="index-LEXEME"></a><u>Relation:</u> <b>LEXEME</b><i> ((?r <small>THING</small>) (?s <small>STRING</small>))</i></dt>
<dd><p>?s is a lexeme for the relation or individual ?r.
A relation or individual ?r can have zero or more lexemes, words that are
natural langage equivalents of a logical constant.  The same lexeme may be
attached to more than one constant.
</p></dd></dl>

<dl>
<dt><a name="index-LIST"></a><u>Class:</u> <b><small>LIST</small></b><i> : <small>SEQUENCE</small></i></dt>
<dd><p>Not documented.
</p><dl>
<dt><a name="index-any_002dvalue-1"></a><u>Class Parameter:</u> <b>any-value</b><i> : <small>OBJECT</small></i></dt>
<dd><p>Not documented.
</p></dd></dl>
<dl>
<dt><a name="index-the_002dcons_002dlist"></a><u>Slot:</u> <b>the-cons-list</b><i> : <small>(CONS OF (LIKE (ANY-VALUE SELF)))</small></i></dt>
<dd><p>Not documented.
</p></dd></dl>
</dd></dl>

<dl>
<dt><a name="index-LIST_002dCONCATENATE"></a><u>Function:</u> <b>LIST-CONCATENATE</b><i> ((?x <small>COLLECTION</small>) (?y <small>COLLECTION</small>)) :-&gt; (?r <small>LIST</small>)</i></dt>
<dd><p>Concatenate lists ?x and ?y into ?r.  If ?x and/or ?y
are not lists but sets or more general collections, the order of the
elements in the result list ?r will be arbitrary.
</p></dd></dl>

<dl>
<dt><a name="index-LISTOF"></a><u>Function:</u> <b>LISTOF</b><i> ((?m <small>THING</small>)) :-&gt; (?c <small>LIST</small>)</i></dt>
<dd><p>Term-forming function that defines an ordered list
consisting of all function arguments.  Within logical expressions
<code>listof</code> is most commonly used in conjunction with the <code>member-of</code>
predicate.  For example the query
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">  (retrieve ?x (member-of ?x (listof a b c)))
</pre></td></tr></table>

<p>returns the constants <code>a</code>, <code>b</code>, and <code>c</code> on successive iterations.
</p></dd></dl>

<dl>
<dt><a name="index-MAXIMUM_002dELEMENT"></a><u>Relation:</u> <b>MAXIMUM-ELEMENT</b><i> ((?c <small>COLLECTION</small>) (?sortby <small>RELATION</small>) (?element <small>THING</small>))</i></dt>
<dd><p>Find those ?element(s) of ?c with the maximum ?sortBy value, for example,
<code>(retrieve (maximum-element relation arity ?x))</code> (see also <code>collect-into-descending-set</code>).
</p></dd></dl>

<dl>
<dt><a name="index-MAXIMUM_002dVALUE"></a><u>Relation:</u> <b>MAXIMUM-VALUE</b><i> ((?l <small>COLLECTION</small>) (?max <small>NUMBER</small>))</i></dt>
<dd><p>Binds ?max to the maximum of the numbers in the list ?l.
</p></dd></dl>

<dl>
<dt><a name="index-MEAN_002dVALUE"></a><u>Relation:</u> <b>MEAN-VALUE</b><i> ((?l <small>COLLECTION</small>) (?mean <small>NUMBER</small>))</i></dt>
<dd><p>Binds ?mean to the mean of the numbers in ?l.
</p></dd></dl>

<dl>
<dt><a name="index-MEDIAN_002dVALUE"></a><u>Relation:</u> <b>MEDIAN-VALUE</b><i> ((?l <small>COLLECTION</small>) (?median <small>NUMBER</small>))</i></dt>
<dd><p>Binds ?median to the median of the numbers in ?l.
</p></dd></dl>

<dl>
<dt><a name="index-MEMBER_002dOF"></a><u>Relation:</u> <b>MEMBER-OF</b><i> ((?x <small>THING</small>) (?c <small>COLLECTION</small>))</i></dt>
<dd><p>TRUE if ?x is a member of collection ?c.  A common use
of <code>member-of</code> is for binding a variable to successive members in a list
or set (see <code>listof</code> and <code>setof</code>).
</p></dd></dl>

<dl>
<dt><a name="index-MINIMUM_002dELEMENT"></a><u>Relation:</u> <b>MINIMUM-ELEMENT</b><i> ((?c <small>COLLECTION</small>) (?sortby <small>RELATION</small>) (?element <small>THING</small>))</i></dt>
<dd><p>Find those ?element(s) of ?c with the minimum ?sortBy value, for example,
<code>(retrieve (minimum-element relation arity ?x))</code> (see also <code>collect-into-ascending-set</code>).
</p></dd></dl>

<dl>
<dt><a name="index-MINIMUM_002dVALUE"></a><u>Relation:</u> <b>MINIMUM-VALUE</b><i> ((?l <small>COLLECTION</small>) (?min <small>NUMBER</small>))</i></dt>
<dd><p>Binds ?min to the minimum of the numbers in the list ?l.
</p></dd></dl>

<dl>
<dt><a name="index-MUTUALLY_002dDISJOINT_002dCOLLECTION"></a><u>Relation:</u> <b>MUTUALLY-DISJOINT-COLLECTION</b><i> ((?s <small>SET</small>))</i></dt>
<dd><p>True if the members of ?s are pair-wise disjoint.  Used
most often to expresse disjointness constraints between concepts.  For
example
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">   (mutually-disjoint-collection (setof MAN WOMAN))
</pre></td></tr></table>

<p>states that the concepts MAN and WOMAN are disjoint.
</p>
</dd></dl>

<dl>
<dt><a name="index-NAME_002dTO_002dOBJECT"></a><u>Function:</u> <b>NAME-TO-OBJECT</b><i> ((?n <small>THING</small>)) :-&gt; (?o <small>THING</small>)</i></dt>
<dd><p>Find or create the PowerLoom logic object ?o named by
the name ?n in the current module.  We are interpreting the name ?n literally
here, i.e., it is not a print name as assumed by PLI functions and an object
with exactly that name will be looked up or created.  If ?n is not a string,
this will coerce it to a string first.  We are intentionally
using a separate function here (instead of folding this into <code>object-name</code>),
since we might want to be able to look for an object with a certain name
but not create one if it doesn&rsquo;t exist.
</p></dd></dl>

<dl>
<dt><a name="index-NORMAL_002dQUERY"></a><u>Relation:</u> <b>NORMAL-QUERY</b><i> ((?prop <small>PROPOSITION</small>))</i></dt>
<dd><p>Query ?prop with :inference-level set to :normal.
Equivalent to <code>(query ?prop :inference-level :normal)</code> but more efficient.
</p></dd></dl>

<dl>
<dt><a name="index-NTH_002dDOMAIN"></a><u>Relation:</u> <b>NTH-DOMAIN</b><i> ((?r <small>RELATION</small>) (?i <small>INTEGER</small>) (?d <small>COLLECTION</small>))</i></dt>
<dd><p>True if the nth value for a tuple T satisfying
?r must belong to the concept ?d.  Argument counting starts at zero.
</p></dd></dl>

<dl>
<dt><a name="index-NTH_002dELEMENT"></a><u>Function:</u> <b>NTH-ELEMENT</b><i> ((?l <small>COLLECTION</small>) (?n <small>INTEGER</small>)) :-&gt; (?e <small>THING</small>)</i></dt>
<dd><p>Return the ?n-th element ?e of ?l (zero-based).
Count from end of the list if ?n is negative.  If ?n is unbound
and ?e is bound, this computes the position of ?e.  If both are
unbound, collection elements and their respective positions will
be enumerated.
</p></dd></dl>

<dl>
<dt><a name="index-NTH_002dHEAD"></a><u>Function:</u> <b>NTH-HEAD</b><i> ((?l <small>LIST</small>) (?n <small>INTEGER</small>)) :-&gt; (?h <small>LIST</small>)</i></dt>
<dd><p>Return the ?n head elements ?h of ?l.
Count from end of the list if ?n is negative.
</p></dd></dl>

<dl>
<dt><a name="index-NTH_002dREST"></a><u>Function:</u> <b>NTH-REST</b><i> ((?l <small>LIST</small>) (?n <small>INTEGER</small>)) :-&gt; (?r <small>LIST</small>)</i></dt>
<dd><p>Return the ?n-th rest ?r of ?l (zero-based).
Count from end of the list if ?n is negative.
</p></dd></dl>

<dl>
<dt><a name="index-NUMERIC_002dMAXIMUM"></a><u>Relation:</u> <b>NUMERIC-MAXIMUM</b><i> ((?r <small>RELATION</small>) (?i <small>THING</small>) (?n <small>NUMBER</small>))</i></dt>
<dd><p>Relation that specifies an upper bound <var>?n</var> on any numeric
value that can belong to the set of fillers of the relation ?r applied to ?i.
</p></dd></dl>

<dl>
<dt><a name="index-NUMERIC_002dMINIMUM"></a><u>Relation:</u> <b>NUMERIC-MINIMUM</b><i> ((?r <small>RELATION</small>) (?i <small>THING</small>) (?n <small>NUMBER</small>))</i></dt>
<dd><p>Relation that specifies a lower bound <var>?n</var> on any numeric
value that can belong to the set of fillers of the relation ?r applied to ?i.
</p></dd></dl>

<dl>
<dt><a name="index-NUMERIC_002dSET"></a><u>Concept:</u> <b>NUMERIC-SET</b><i> ((?s <small>COLLECTION</small>))</i></dt>
<dd><p>?s is a set of numbers
</p></dd></dl>

<dl>
<dt><a name="index-OBJECT_002dNAME"></a><u>Function:</u> <b>OBJECT-NAME</b><i> ((?x <small>THING</small>)) :-&gt; (?c <small>STRING</small>)</i></dt>
<dd><p>The name of the object ?X as a string.  This is just the
name, with module prefixes NOT included.
</p></dd></dl>

<dl>
<dt><a name="index-ORDERED"></a><u>Relation:</u> <b>ORDERED</b><i> ((?c <small>COLLECTION</small>))</i></dt>
<dd><p>?c is ordered if the ordering of its
members is significant.  Lists are ordered, while sets are not.
</p></dd></dl>

<dl>
<dt><a name="index-PHRASE"></a><u>Relation:</u> <b>PHRASE</b><i> ((?r <small>THING</small>) (?s <small>STRING</small>))</i></dt>
<dd><p>A phrase is a variablized sentence, a template, that
is used to express individual axiomatic facts as natural language
sentences.  By convention, a phrase contains one or more occurrences
of each variable in a relation or concept definition, it does not
begin with a capital letter, and it has no concluding period.
Systematic attachment of phrases to relations can be leveraged by
tools that generate natural language paraphrases of logic sentences.
</p></dd></dl>

<dl>
<dt><a name="index-PROJECT_002dCOLUMN"></a><u>Function:</u> <b>PROJECT-COLUMN</b><i> ((?i <small>INTEGER</small>) (?c <small>COLLECTION</small>)) :-&gt; (?l <small>LIST</small>)</i></dt>
<dd><p>Project elements in column ?i (zero-based) of the tuples
of ?c and collect them into a list ?l. 
</p></dd></dl>

<dl>
<dt><a name="index-PROPER_002dSUBRELATION"></a><u>Relation:</u> <b>PROPER-SUBRELATION</b><i> ((?r <small>RELATION</small>) (?sub <small>RELATION</small>))</i></dt>
<dd><p>True iff ?sub is a proper subrelation of ?r; written in
set notation, ?sub &lt; ?r.  This relation will generate bindings for at most
one unbound argument.
</p></dd></dl>

<dl>
<dt><a name="index-PROPER_002dSUPERRELATION"></a><u>Relation:</u> <b>PROPER-SUPERRELATION</b><i> ((?r <small>RELATION</small>) (?super <small>RELATION</small>))</i></dt>
<dd><p>True iff ?super is a proper superrelation of ?r; written in
set notation, ?super &gt; ?r.  This relation will generate bindings for at most
one unbound argument.
</p></dd></dl>

<dl>
<dt><a name="index-PROPOSITION"></a><u>Class:</u> <b><small>PROPOSITION</small></b><i> : <small>CONTEXT-SENSITIVE-OBJECT</small>, <small>DYNAMIC-SLOTS-MIXIN</small>, <small>BACKLINKS-MIXIN</small></i></dt>
<dd>
<dl>
<dt><a name="index-home_002dcontext"></a><u>Slot:</u> <b>home-context</b><i> : <small>CONTEXT</small></i></dt>
<dd><p>Not documented.
</p></dd></dl>
<dl>
<dt><a name="index-kind"></a><u>Slot:</u> <b>kind</b><i> : <small>KEYWORD</small></i></dt>
<dd><p>Not documented.
</p></dd></dl>
<dl>
<dt><a name="index-truth_002dvalue"></a><u>Slot:</u> <b>truth-value</b><i> : <small>TRUTH-VALUE</small></i></dt>
<dd><p>Not documented.
</p></dd></dl>
<dl>
<dt><a name="index-arguments"></a><u>Slot:</u> <b>arguments</b><i> : <small>VECTOR</small></i></dt>
<dd><p>Not documented.
</p></dd></dl>
<dl>
<dt><a name="index-operator"></a><u>Slot:</u> <b>operator</b><i> : <small>GENERALIZED-SYMBOL</small></i></dt>
<dd><p>Not documented.
</p></dd></dl>
<dl>
<dt><a name="index-dependent_002dpropositions"></a><u>Slot:</u> <b>dependent-propositions</b><i> : <small>(NON-PAGING-INDEX OF PROPOSITION)</small></i></dt>
<dd><p>Not documented.
</p></dd></dl>
</dd></dl>

<dl>
<dt><a name="index-PROPOSITION_002dARGUMENT"></a><u>Function:</u> <b>PROPOSITION-ARGUMENT</b><i> ((?p <small>PROPOSITION</small>) (?i <small>INTEGER</small>)) :-&gt; (?arg <small>THING</small>)</i></dt>
<dd><p>Return the ?i-th ?arg of ?p (zero-based).
</p></dd></dl>

<dl>
<dt><a name="index-PROPOSITION_002dARGUMENTS"></a><u>Function:</u> <b>PROPOSITION-ARGUMENTS</b><i> ((?p <small>PROPOSITION</small>)) :-&gt; (?args <small>LIST</small>)</i></dt>
<dd><p>Return all arguments of ?p as a list ?args.
</p></dd></dl>

<dl>
<dt><a name="index-PROPOSITION_002dARITY"></a><u>Function:</u> <b>PROPOSITION-ARITY</b><i> ((?p <small>PROPOSITION</small>)) :-&gt; (?arity <small>INTEGER</small>)</i></dt>
<dd><p>Return the number of arguments in ?p.
</p></dd></dl>

<dl>
<dt><a name="index-PROPOSITION_002dRELATION"></a><u>Function:</u> <b>PROPOSITION-RELATION</b><i> ((?p <small>PROPOSITION</small>)) :-&gt; (?op <small>RELATION</small>)</i></dt>
<dd><p>Return the predicate operator ?op of ?p.
</p></dd></dl>

<dl>
<dt><a name="index-QUERY"></a><u>Relation:</u> <b>QUERY</b><i> ((?prop <small>PROPOSITION</small>) (?options <small>THING</small>))</i></dt>
<dd><p>Search-control relation that allows one to prove or
retrieve bindings for ?prop with modified search control ?options.  The list
of accepted ?options is currently the same as are legal for a top-level <code>ask</code>
or <code>retrieve</code> query.  The special option value :INHERIT inherits the option
value from the parent or top-level query.  The option pair :INHERIT :ALL
inherits all parent options which can then be further modified by additional
individual option specifications.  At most how many solutions will be generated
is controlled by the :HOW-MANY option (just like in the top level <code>retrieve</code>).
The default is 1 which is again the same as for <code>retrieve</code> but different from
how normal subgoals behave (those behave in a lazy all solutions mode).
The reason for this is that for partial match subqueries, solutions need to be
generated eagerly, therefore, a default of generating all solutions is not
desirable.
</p></dd></dl>

<dl>
<dt><a name="index-RANGE"></a><u>Relation:</u> <b>RANGE</b><i> ((?r <small>RELATION</small>) (?rng <small>COLLECTION</small>))</i></dt>
<dd><p>True if for any tuple <code>T</code> that satifies ?r, the last
argument of <code>T</code> necessarily belongs to the concept ?rng.  <code>range</code> exists
for convenience only and is defined in terms of <code>nth-domain</code>.  <code>range</code>
assertions should be avoided, since they create redundant <code>nth-domain</code>
propositions (use <code>nth-domain</code> directly).
</p></dd></dl>

<dl>
<dt><a name="index-RANGE_002dCARDINALITY"></a><u>Function:</u> <b>RANGE-CARDINALITY</b><i> ((?r <small>RELATION</small>) (?i <small>THING</small>)) :-&gt; (?card <small>INTEGER</small>)</i></dt>
<dd><p>Function that returns the cardinality of the set
of fillers of the relation ?r applied to ?i.  The cardinality function
returns a value only when the relations <code>range-min-cardinality</code> and
<code>range-max-cardinality</code> compute identical values, i.e., when the
best lower and upper bounds on the cardinality are equal.  Each of
these bounding functions employs a variety of rules to try and
compute a tight bound.
</p></dd></dl>

<dl>
<dt><a name="index-RANGE_002dCARDINALITY_002dLOWER_002dBOUND"></a><u>Relation:</u> <b>RANGE-CARDINALITY-LOWER-BOUND</b><i> ((?r <small>RELATION</small>) (?i <small>THING</small>) (?lb <small>INTEGER</small>))</i></dt>
<dd><p>Relation that specifies a lower bound on the cardinality 
of the set of fillers of the relation ?r applied to ?i.  The difference
between <code>range-cardinality-lower-bound</code> and <code>range-min-cardinality</code> is
subtle but significant.   Suppose we state that nine is a lower bound
on the number of planets in the solar system, and then ask if eight is
(also) a lower bound:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">   (assert (range-cardinality-lower-bound hasPlanets SolarSystem 9))
   (ask (range-cardinality-lower-bound hasPlanets SolarSystem 8))  ==&gt; TRUE
</pre></td></tr></table>

<p>PowerLoom will return TRUE.  However if we ask if the minimum cardinality
of the solar system&rsquo;s planets is eight, we get back UNKNOWN
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">   (ask (range-min-cardinality hasPlanets SolarSystem 8)) ==&gt; UNKNOWN
</pre></td></tr></table>

<p>because eight is not the tightest lower bound.
</p></dd></dl>

<dl>
<dt><a name="index-RANGE_002dCARDINALITY_002dUPPER_002dBOUND"></a><u>Relation:</u> <b>RANGE-CARDINALITY-UPPER-BOUND</b><i> ((?r <small>RELATION</small>) (?i <small>THING</small>) (?ub <small>INTEGER</small>))</i></dt>
<dd><p>Relation that specifies an upper bound on the cardinality 
of the set of fillers of the relation ?r applied to ?i. (see the discussion
for <code>range-cardinality-lower-bound</code>).
</p></dd></dl>

<dl>
<dt><a name="index-RANGE_002dMAX_002dCARDINALITY"></a><u>Function:</u> <b>RANGE-MAX-CARDINALITY</b><i> ((?r <small>RELATION</small>) (?i <small>THING</small>)) :-&gt; (?maxcard <small>INTEGER</small>)</i></dt>
<dd><p>Returns the strictest computable upper bound on the
cardinality of the set of fillers of the relation ?r applied to ?i.
(see the discussion for <code>range-cardinality-lower-bound</code>).
</p></dd></dl>

<dl>
<dt><a name="index-RANGE_002dMIN_002dCARDINALITY"></a><u>Function:</u> <b>RANGE-MIN-CARDINALITY</b><i> ((?r <small>RELATION</small>) (?i <small>THING</small>)) :-&gt; (?mincard <small>INTEGER</small>)</i></dt>
<dd><p>Returns the strictest computable lower bound on the
cardinality of the set of fillers of the relation ?r applied to ?i.
(see the discussion for <code>range-cardinality-lower-bound</code>).
</p></dd></dl>

<dl>
<dt><a name="index-RANGE_002dTYPE"></a><u>Relation:</u> <b>RANGE-TYPE</b><i> ((?r <small>RELATION</small>) (?i <small>THING</small>) (?type <small>COLLECTION</small>))</i></dt>
<dd><p>Relation that specifies a type/range of the relation ?r applied to ?i.
Multiple range types may be asserted for a single pair &lt;?r,?i&gt;.  Technically,
a retrieval of types for a given pair should include all supertypes
(superconcepts) of any type that is produced, but for utility&rsquo;s sake,
only asserted or directly inferrable types are returned.
</p></dd></dl>

<dl>
<dt><a name="index-REFLEXIVE"></a><u>Relation:</u> <b>REFLEXIVE</b><i> ((?r <small>RELATION</small>))</i></dt>
<dd><p>A binary relation ?r is reflexive if it is always true when
both of its arguments are identical.
</p></dd></dl>

<dl>
<dt><a name="index-REFUTATION_002dQUERY"></a><u>Relation:</u> <b>REFUTATION-QUERY</b><i> ((?prop <small>PROPOSITION</small>))</i></dt>
<dd><p>Query ?prop with :inference-level set to :refutation.
Equivalent to <code>(query ?prop :inference-level :refutation)</code> but more efficient.
</p></dd></dl>

<dl>
<dt><a name="index-RELATION"></a><u>Class:</u> <b><small>RELATION</small></b><i> : <small>MAPPABLE-OBJECT</small></i></dt>
<dd><p>Not documented.
</p><dl>
<dt><a name="index-abstract_003f"></a><u>Slot:</u> <b>abstract?</b><i> : <small>BOOLEAN</small></i></dt>
<dd><p>Not documented.
</p></dd></dl>
</dd></dl>

<dl>
<dt><a name="index-RELATION_002dCOMPUTATION"></a><u>Relation:</u> <b>RELATION-COMPUTATION</b><i> ((?r <small>RELATION</small>) (?computation <small>COMPUTED-PROCEDURE</small>))</i></dt>
<dd><p>Names a <code>computation</code> (a function) that evaluates an (atomic) relation
proposition during query processing.  The function is passed a proposition
for evaluation for which all arguments are bound.  The function
returns a BOOLEAN if it represents a predicate, or some sort of value
if it is a function.
</p></dd></dl>

<dl>
<dt><a name="index-RELATION_002dCONSTRAINT"></a><u>Relation:</u> <b>RELATION-CONSTRAINT</b><i> ((?r <small>RELATION</small>) (?computation <small>COMPUTED-PROCEDURE</small>))</i></dt>
<dd><p>Names a <code>computation</code> (a function) that evaluates an (atomic) relation
proposition during query processing.  The function is passed a proposition
for evaluation for which at most one argument is unbound.  The function
returns a BOOLEAN if it represents a predicate, or some sort of value
if it is a function.  If all arguments are bound the function computes whether
the constraint holds.  If all but one argument is bound and the unbound
argument is a pattern variable then the missing value is computed.
</p></dd></dl>

<dl>
<dt><a name="index-RELATION_002dEVALUATOR"></a><u>Relation:</u> <b>RELATION-EVALUATOR</b><i> ((?r <small>RELATION</small>) (?ev <small>COMPUTED-PROCEDURE</small>))</i></dt>
<dd><p>Names an <code>evaluator</code> (a function) that evaluates an (atomic) relation
proposition during constraint propagation.  This defines an extensible
means for computing using auxiliary data structures.  The function is passed
a proposition for evaluation which might update the proposition, generate
additional assertions or trigger further evaluations.  Evaluators have to
check the truth-value of the passed-in proposition and perform their actions
accordingly.  An evaluated proposition might be true, false or even unknown
in case the propositon was just newly constructed.
</p></dd></dl>

<dl>
<dt><a name="index-RELATION_002dSPECIALIST"></a><u>Relation:</u> <b>RELATION-SPECIALIST</b><i> ((?r <small>RELATION</small>) (?sp <small>COMPUTED-PROCEDURE</small>))</i></dt>
<dd><p>Names a <code>specialist</code> (a function) that evaluates an (atomic) relation
proposition during query processing.  This defines an extensible
means for computing with the control stack.  The function is passed
a CONTROL-FRAME that contains the proposition, and returns a keyword
:FINAL-SUCCESS, :CONTINUING-SUCCESS, :FAILURE, or :TERMINAL-FAILURE
that controls the result of the computation.
</p></dd></dl>

<dl>
<dt><a name="index-SCALAR"></a><u>Concept:</u> <b>SCALAR</b><i> ((?x <small>SCALAR</small>))</i></dt>
<dd><p>The class of scalar quantities.
</p></dd></dl>

<dl>
<dt><a name="index-SCALAR_002dINTERVAL"></a><u>Concept:</u> <b>SCALAR-INTERVAL</b><i> ((?x <small>SCALAR</small>))</i></dt>
<dd><p>An interval of scalar quantities. 
</p></dd></dl>

<dl>
<dt><a name="index-SECOND_002dELEMENT"></a><u>Function:</u> <b>SECOND-ELEMENT</b><i> ((?l <small>COLLECTION</small>)) :-&gt; (?e <small>THING</small>)</i></dt>
<dd><p>Return the second element ?e of ?l.
</p></dd></dl>

<dl>
<dt><a name="index-SET"></a><u>Class:</u> <b><small>SET</small></b><i> : <small>LIST</small>, <small>SET-MIXIN</small></i></dt>
<dd><p>Not documented.
</p><dl>
<dt><a name="index-any_002dvalue-2"></a><u>Class Parameter:</u> <b>any-value</b><i> : <small>OBJECT</small></i></dt>
<dd><p>Not documented.
</p></dd></dl>
</dd></dl>

<dl>
<dt><a name="index-SETOF"></a><u>Function:</u> <b>SETOF</b><i> ((?m <small>THING</small>)) :-&gt; (?c <small>SET</small>)</i></dt>
<dd><p>Term-forming function that defines an enumerated set
consisting of all function arguments.  <code>setof</code> is like <code>listof</code> except
that it removes duplicate values.
</p></dd></dl>

<dl>
<dt><a name="index-SHALLOW_002dQUERY"></a><u>Relation:</u> <b>SHALLOW-QUERY</b><i> ((?prop <small>PROPOSITION</small>))</i></dt>
<dd><p>Query ?prop with :inference-level set to :shallow.
Equivalent to <code>(query ?prop :inference-level :shallow)</code> but more efficient.
</p></dd></dl>

<dl>
<dt><a name="index-SINGLE_002dVALUED"></a><u>Relation:</u> <b>SINGLE-VALUED</b><i> ((?c <small>RELATION</small>))</i></dt>
<dd><p>The relation ?c is single-valued if the value of its
last argument is a function of all other arguments.  All functions
are single-valued (see <code>function</code>).
</p></dd></dl>

<dl>
<dt><a name="index-SQUARE_002dROOT"></a><u>Relation:</u> <b>SQUARE-ROOT</b><i> ((?x <small>NUMBER</small>) (?y <small>NUMBER</small>))</i></dt>
<dd><p>Relation that returns the positive and negative square roots:
?y = sqrt(?x).  For positive roots only see function SQRT.
</p></dd></dl>

<dl>
<dt><a name="index-STANDARD_002dDEVIATION"></a><u>Relation:</u> <b>STANDARD-DEVIATION</b><i> ((?l <small>COLLECTION</small>) (?sd <small>NUMBER</small>))</i></dt>
<dd><p>Binds ?sd to the standard deviation of the numbers in ?l.
</p></dd></dl>

<dl>
<dt><a name="index-STRING_002dCONCATENATE"></a><u>Function:</u> <b>STRING-CONCATENATE</b><i> ((?x <small>THING</small>) (?y <small>THING</small>)) :-&gt; (?z <small>STRING</small>)</i></dt>
<dd><p>Concatenate ?x and zero or more strings ?y (variable arity)
and bind ?z to the result.  Coerces any type argument to a string if necessary.
</p></dd></dl>

<dl>
<dt><a name="index-STRING_002dMATCH"></a><u>Function:</u> <b>STRING-MATCH</b><i> ((?pattern <small>STRING</small>) (?object <small>THING</small>) (?start <small>INTEGER</small>) (?end <small>INTEGER</small>)) :-&gt; (?match-position <small>INTEGER</small>)</i></dt>
<dd><p>Match ?pattern against ?object between ?start and ?end (zero-based),
and return the position of the first match or fail if no match exists.
Supplying -1 for ?end indicates the end of ?object.  ?object can be a
named logic object or a string.  ?pattern will eventually allow
support regular expressions, currently it only handles string
literals.  Apart from doing to-string coercion on ?object this is
somewhat redundant, since <code>substring</code> can generate ?start/?end pairs
if its string and substring arguments are bound.
</p></dd></dl>

<dl>
<dt><a name="index-STRING_002dMATCH_002dIGNORE_002dCASE"></a><u>Function:</u> <b>STRING-MATCH-IGNORE-CASE</b><i> ((?pattern <small>STRING</small>) (?object <small>THING</small>) (?start <small>INTEGER</small>) (?end <small>INTEGER</small>)) :-&gt; (?match-position <small>INTEGER</small>)</i></dt>
<dd><p>Match ?pattern against ?object between ?start and ?end (zero-based),
and return the position of the first match or fail if no match exists.
Supplying -1 for ?end indicates the end of ?object.  ?object can be a
named logic object or a string.  This match compares the strings
ignoring differences in letter case.
</p></dd></dl>

<dl>
<dt><a name="index-SUBRELATION"></a><u>Relation:</u> <b>SUBRELATION</b><i> ((?r <small>RELATION</small>) (?sub <small>RELATION</small>))</i></dt>
<dd><p>True iff ?sub is a subrelation of ?r; written in set
notation, ?sub =&lt; ?r.  This relation will generate bindings for at most
one unbound argument.
</p></dd></dl>

<dl>
<dt><a name="index-SUBSET_002dOF"></a><u>Relation:</u> <b>SUBSET-OF</b><i> ((?sub <small>COLLECTION</small>) (?super <small>COLLECTION</small>))</i></dt>
<dd><p>True if ?sub is a subset of ?super.  For performance
reasons, the <code>subset-of</code> predicate refuses to search for bindings if
both of its variables are unbound.  Implementation note: <code>subset-of</code> 
is treated specially internally to PowerLoom, and hence Powerloom does not
permit the augmentation of <code>subset-of</code> with additional inference rules.
In otherwords, <code>subset-of</code> behaves semantically like an operator instead
of a relation.
</p></dd></dl>

<dl>
<dt><a name="index-SUBSTRING"></a><u>Function:</u> <b>SUBSTRING</b><i> ((?s <small>STRING</small>) (?start <small>INTEGER</small>) (?end <small>INTEGER</small>)) :-&gt; (?sub <small>STRING</small>)</i></dt>
<dd><p>Generate the substring of ?s starting at position ?start (zero-based),
ending just before position ?end and bind ?sub to the result.
This is the PowerLoom equivalent to the STELLA method <code>subsequence</code>.  In
addition, this function can be used to locate substrings in strings by
supplying values for ?s and ?sub and allowing ?start and ?end to be
bound by the function specialist.  In other words,
      (retrieve all (?start ?end) (substring &quot;foo&quot; ?start ?end &quot;o&quot;))
 ==&gt;  ?start = 1, ?end = 2,
      ?start = 2, ?end = 3.
</p></dd></dl>

<dl>
<dt><a name="index-SUBSUMPTION_002dQUERY"></a><u>Relation:</u> <b>SUBSUMPTION-QUERY</b><i> ((?prop <small>PROPOSITION</small>))</i></dt>
<dd><p>Query ?prop with :inference-level set to :subsumption.
Equivalent to <code>(query ?prop :inference-level :subsumption)</code> but more efficient.
</p></dd></dl>

<dl>
<dt><a name="index-SUM"></a><u>Relation:</u> <b>SUM</b><i> ((?l <small>COLLECTION</small>) (?sum <small>NUMBER</small>))</i></dt>
<dd><p>Binds ?sum to the sum of the numbers in the list ?l.
</p></dd></dl>

<dl>
<dt><a name="index-SUPERRELATION"></a><u>Relation:</u> <b>SUPERRELATION</b><i> ((?r <small>RELATION</small>) (?super <small>RELATION</small>))</i></dt>
<dd><p>True iff ?super is a superrelation of ?r; written in set
notation, ?super &gt;= ?r.  This relation will generate bindings for at most
one unbound argument.
</p></dd></dl>

<dl>
<dt><a name="index-SYMMETRIC"></a><u>Relation:</u> <b>SYMMETRIC</b><i> ((?r <small>RELATION</small>))</i></dt>
<dd><p>A binary relation ?r is symmetric if it is commutative.
</p></dd></dl>

<dl>
<dt><a name="index-SYNONYM"></a><u>Relation:</u> <b>SYNONYM</b><i> ((?term <small>THING</small>) (?synonym <small>THING</small>))</i></dt>
<dd><p>Assert that <var>?synonym</var> is a synonym of <var>?term</var>.  This
causes all references to <var>?synonym</var> to be interpreted as references
to <var>?term</var>.  Retraction eliminates a synonym relation.
</p></dd></dl>

<dl>
<dt><a name="index-THING"></a><u>Class:</u> <b><small>THING</small></b><i> : <small>STANDARD-OBJECT</small>, <small>DYNAMIC-SLOTS-MIXIN</small></i></dt>
<dd><p>Defines a class that must be inherited by any
class that participates in the PowerLoom side of things.
</p><dl>
<dt><a name="index-surrogate_002dvalue_002dinverse"></a><u>Slot:</u> <b>surrogate-value-inverse</b><i> : <small>SURROGATE</small></i></dt>
<dd><p>Not documented.
</p></dd></dl>
</dd></dl>

<dl>
<dt><a name="index-THIRD_002dELEMENT"></a><u>Function:</u> <b>THIRD-ELEMENT</b><i> ((?l <small>COLLECTION</small>)) :-&gt; (?e <small>THING</small>)</i></dt>
<dd><p>Return the third element ?e of ?l.
</p></dd></dl>

<dl>
<dt><a name="index-TOTAL"></a><u>Relation:</u> <b>TOTAL</b><i> ((?r <small>FUNCTION</small>))</i></dt>
<dd><p>True if the function <var>?r</var> is defined for all
combinations of inputs.  By default, functions are not assumed to
be total (unlike Prolog, which <code>does</code> make such an assumption.
For example, if we define a two-argument function <code>foo</code> and then retrieve
its value applied to some random instances <code>a</code> and <code>b</code>, we get nothing
back:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">   (deffunction foo (?x ?y) :-&gt; ?z)
   (retrieve ?x (= ?x (foo a b)))
</pre></td></tr></table>

<p>However, if we assert that <code>foo</code> is total, then we get a skolem back
when we execute the same retrieve:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">   (assert (total foo))
   (retrieve ?x (= ?x (foo a b)))
</pre></td></tr></table>


</dd></dl>

<dl>
<dt><a name="index-TRANSITIVE"></a><u>Relation:</u> <b>TRANSITIVE</b><i> ((?r <small>RELATION</small>))</i></dt>
<dd><p>A binary relation ?r is transitive if (?r ?x ?y)
and (?r ?y ?z) implies that (?r ?x ?z).  Note that functions cannot
be transitive, since their single-valuedness would not allow multiple
different values such as (?r ?x ?y) and (?r ?x ?z) due to the Unique
Names Assumption made by PowerLoom.
</p></dd></dl>

<dl>
<dt><a name="index-TYPE_002dOF"></a><u>Relation:</u> <b>TYPE-OF</b><i> ((?c <small>COLLECTION</small>) (?x <small>THING</small>))</i></dt>
<dd><p>True if ?x is a member of the concept ?c.
</p></dd></dl>

<dl>
<dt><a name="index-VALUE"></a><u>Function:</u> <b>VALUE</b><i> ((?function <small>FUNCTION</small>) (?arguments <small>THING</small>)) :-&gt; (?value <small>THING</small>)</i></dt>
<dd><p>True if applying <var>?function</var> to <var>?arguments</var>
yields the value <code>?value</code>.  The <code>value</code> predicate is the analog
of <code>holds</code>, except that it applies to functions instead of relations.
</p></dd></dl>

<dl>
<dt><a name="index-VARIABLE_002dARITY"></a><u>Relation:</u> <b>VARIABLE-ARITY</b><i> ((?r <small>RELATION</small>))</i></dt>
<dd><p>Asserts that the relation ?r can take a variable
number of arguments.
</p></dd></dl>

<dl>
<dt><a name="index-VARIANCE"></a><u>Relation:</u> <b>VARIANCE</b><i> ((?l <small>COLLECTION</small>) (?variance <small>NUMBER</small>))</i></dt>
<dd><p>Binds ?variance to the variance of the numbers in ?l.
</p></dd></dl>






<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="manual_6.html#PowerLoom-API" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="manual_8.html#PowerLoom-GUI" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="manual.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="manual_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="manual_14.html#Function-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="manual_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Hans Chalupsky</em> on <em>April 15, 2011</em> using <a href="http://www.nongnu.org/texi2html/"><em>texi2html 1.82</em></a>.
 </font>
 <br>

</p>
</body>
</html>
