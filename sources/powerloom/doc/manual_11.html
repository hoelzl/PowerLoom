<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Copyright C 2010
University of Southern California, Information Sciences Institute,
4676 Admiralty Way,
Marina Del Rey, CA 90292, USA

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

PowerLoom is a registered trademark of the University of Southern California.

 -->
<!-- Created on April 15, 2011 by texi2html 1.82
texi2html was written by: 
            Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>
-->
<head>
<title>PowerLoom Manual: 11. Miscellaneous</title>

<meta name="description" content="PowerLoom Manual: 11. Miscellaneous">
<meta name="keywords" content="PowerLoom Manual: 11. Miscellaneous">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.82">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.roman {font-family:serif; font-weight:normal;}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Miscellaneous"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="manual_10.html#Installing-PowerLoom-Patches" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="manual_12.html#Glossary" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="manual_10.html#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="manual.html#Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="manual_12.html#Glossary" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="manual.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="manual_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="manual_14.html#Function-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="manual_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Miscellaneous-1"></a>
<h1 class="chapter">11. Miscellaneous</h1>

<p>This is a catch-all section for documented functions, methods and
relations that haven&rsquo;t been categorized yet into any of the previous
sections.  They are in random order and many of them will never be part
of the official PowerLoom interface.  So beware!
</p>
<dl>
<dt><a name="index-2_005fd_005felement-on-2_005fD_005fARRAY"></a><u>Method on <small>2_D_ARRAY</small>:</u> <b>2_d_element</b><i> (array (row <small>INTEGER</small>) (column <small>INTEGER</small>)) : <small>(LIKE (ANY-VALUE SELF))</small></i></dt>
<dd><p>Return the element of <var>array</var> at position [<var>row</var>, <var>column</var>].
</p></dd></dl>

<dl>
<dt><a name="index-2_005fd_005felement-on-2_005fD_005fFLOAT_002dARRAY"></a><u>Method on <small>2_D_FLOAT-ARRAY</small>:</u> <b>2_d_element</b><i> (array (row <small>INTEGER</small>) (column <small>INTEGER</small>)) : <small>FLOAT</small></i></dt>
<dd><p>Return the element of <var>array</var> at position [<var>row</var>, <var>column</var>].
</p></dd></dl>

<dl>
<dt><a name="index-2_005fd_005felement_002dsetter-on-2_005fD_005fARRAY"></a><u>Method on <small>2_D_ARRAY</small>:</u> <b>2_d_element-setter</b><i> (array (value <small>OBJECT</small>) (row <small>INTEGER</small>) (column <small>INTEGER</small>)) : <small>(LIKE (ANY-VALUE SELF))</small></i></dt>
<dd><p>Set the element of <var>array</var> at position [<var>row</var>, <var>column</var>]
to <var>value</var> and return the result.
</p></dd></dl>

<dl>
<dt><a name="index-2_005fd_005felement_002dsetter-on-2_005fD_005fFLOAT_002dARRAY"></a><u>Method on <small>2_D_FLOAT-ARRAY</small>:</u> <b>2_d_element-setter</b><i> (array (value <small>FLOAT</small>) (row <small>INTEGER</small>) (column <small>INTEGER</small>)) : <small>(LIKE (ANY-VALUE SELF))</small></i></dt>
<dd><p>Set the element of <var>array</var> at position [<var>row</var>, <var>column</var>]
to <var>value</var> and return the result.
</p></dd></dl>

<dl>
<dt><a name="index-add_002dtesting_002dexample"></a><u>N-Command:</u> <b>add-testing-example</b><i> ((form <small>CONS</small>) (score <small>PARTIAL-MATCH-SCORE</small>)) :</i></dt>
<dd><p>Add a query and score pair to the master list of 
  testing examples
</p></dd></dl>

<dl>
<dt><a name="index-add_002dtraining_002dexample"></a><u>N-Command:</u> <b>add-training-example</b><i> ((form <small>CONS</small>) (score <small>PARTIAL-MATCH-SCORE</small>)) :</i></dt>
<dd><p>Add a query and score pair to the master list of 
  training examples
</p></dd></dl>

<dl>
<dt><a name="index-all_002dasserted_002dtypes"></a><u>Function:</u> <b>all-asserted-types</b><i> ((self <small>OBJECT</small>)) : <small>(CONS OF NAMED-DESCRIPTION)</small></i></dt>
<dd><p>Return a set of all of the types that are
asserted to be satisfied by <var>self</var>.
</p></dd></dl>

<dl>
<dt><a name="index-all_002dclass_002dinstances"></a><u>Function:</u> <b>all-class-instances</b><i> ((type <small>SURROGATE</small>)) : <small>CONS</small></i></dt>
<dd><p>Return a set of instances that belong to the class <var>type</var>.
</p></dd></dl>

<dl>
<dt><a name="index-all_002dcycles"></a><u>Function:</u> <b>all-cycles</b><i> ((module <small>MODULE</small>) (local? <small>BOOLEAN</small>)) : <small>(CONS OF CONS)</small></i></dt>
<dd><p>Return a list of lists of descriptions that are
provably co-extensional.
</p></dd></dl>

<dl>
<dt><a name="index-all_002ddirect_002dsubrelations"></a><u>Function:</u> <b>all-direct-subrelations</b><i> ((relation <small>NAMED-DESCRIPTION</small>) (removeEquivalents? <small>BOOLEAN</small>)) : <small>(CONS OF NAMED-DESCRIPTION)</small></i></dt>
<dd><p>Return a set of relations that immediately specialize
<var>relation</var>.  If <var>removeEquivalents?</var> (recommended), don&rsquo;t include any
relations equivalent to <var>relation</var>.
</p></dd></dl>

<dl>
<dt><a name="index-all_002ddirect_002dsuperrelations"></a><u>Function:</u> <b>all-direct-superrelations</b><i> ((relation <small>NAMED-DESCRIPTION</small>) (removeEquivalents? <small>BOOLEAN</small>)) : <small>(CONS OF NAMED-DESCRIPTION)</small></i></dt>
<dd><p>Return a set of relations that immediately subsume
<var>relation</var>.  If <var>removeEquivalents?</var> (recommended), don&rsquo;t include any
relations equivalent to <var>relation</var>.
</p></dd></dl>

<dl>
<dt><a name="index-all_002ddirect_002dtypes"></a><u>Function:</u> <b>all-direct-types</b><i> ((self <small>OBJECT</small>)) : <small>(CONS OF LOGIC-OBJECT)</small></i></dt>
<dd><p>Return a set of most specific types that are
satisfied by <var>self</var>.
</p></dd></dl>

<dl>
<dt><a name="index-all_002dequivalent_002drelations"></a><u>Function:</u> <b>all-equivalent-relations</b><i> ((relation <small>NAMED-DESCRIPTION</small>) (reflexive? <small>BOOLEAN</small>)) : <small>(CONS OF NAMED-DESCRIPTION)</small></i></dt>
<dd><p>Return a list of all relations equivalent to <var>relation</var>.
If <var>reflexive?</var>, include <var>relation</var> in the list.
</p></dd></dl>

<dl>
<dt><a name="index-all_002dfacts_002dof_002dinstance"></a><u>Function:</u> <b>all-facts-of-instance</b><i> ((self <small>OBJECT</small>) (includeunknownfacts? <small>BOOLEAN</small>) (elaborate? <small>BOOLEAN</small>)) : <small>(LIST OF PROPOSITION)</small></i></dt>
<dd><p>Return a list of all definite (TRUE or FALSE) propositions
attached to <var>self</var>.
</p></dd></dl>

<dl>
<dt><a name="index-all_002dfacts_002dof_002dn"></a><u>N-Command:</u> <b>all-facts-of-n</b><i> ((n <small>INTEGER</small>) &amp;rest (instanceRefs <small>NAME</small>)) : <small>(CONS OF PROPOSITION)</small></i></dt>
<dd><p>This is a generalization of <code>all-facts-of</code> (which see).  With <var>n</var> = 0
and only one instance this command behaves just like <code>all-facts-of</code>.
Otherwise, returns a cons list of all definite (TRUE or FALSE) propositions
that reference any of the instances listed in <var>instanceRefs</var>, plus if <var>n</var> &gt;= 1
all propositions that reference any instances that are arguments of
propositions collected in the previous step, plus if <var>n</var> &gt;= 2... and so on.
That is, if we only consider binary propositions, this can be viewed as
growing a graph with instances as its nodes and predicates as its arcs
starting from the set of seed <var>instanceRefs</var> to depth <var>n</var>-1.
Caution: with a fully connected KB and large enough <var>n</var> this could return
the whole knowledge base.
</p>
<p>The returned propositions include those asserted to be true or false by
default, but it does not include propositions that are found to be
true only by running the query engine.  Facts inferred to be true by
the forward chainer will be included.  Hence, the returned list of
facts may be longer in a context where the forward chainer has been
run then in one where it has not (see <code>run-forward-rules</code>).
</p></dd></dl>

<dl>
<dt><a name="index-all_002dinconsistent_002dpropositions"></a><u>Function:</u> <b>all-inconsistent-propositions</b><i> ((module <small>MODULE</small>) (local? <small>BOOLEAN</small>)) : <small>(ITERATOR OF PROPOSITION)</small></i></dt>
<dd><p>Iterate over all conceived propositions visible from <var>module</var>
that have an inconsistent truth value.  If <var>local?</var>, only return
inconsistent propositions conceived locally in <var>module</var>.
</p></dd></dl>

<dl>
<dt><a name="index-all_002dinstances"></a><u>Function:</u> <b>all-instances</b><i> ((module <small>MODULE</small>) (local? <small>BOOLEAN</small>)) : <small>(ITERATOR OF LOGIC-OBJECT)</small></i></dt>
<dd><p>Iterate over all instances (or individuals) visible from <var>module</var>.
Only instances that haven&rsquo;t been deleted will be considered.  If <var>local?</var>,
only return instances created locally in <var>module</var>.
</p></dd></dl>

<dl>
<dt><a name="index-all_002dnamed_002ddescriptions"></a><u>Function:</u> <b>all-named-descriptions</b><i> ((module <small>MODULE</small>) (local? <small>BOOLEAN</small>)) : <small>(ITERATOR OF NAMED-DESCRIPTION)</small></i></dt>
<dd><p>Iterate over all named descriptions visible from <var>module</var>.
If <var>local?</var>, return only named descriptions interned in <var>module</var>.
If <var>module</var> is null, return all named descriptions interned everywhere.
</p></dd></dl>

<dl>
<dt><a name="index-all_002dnamed_002dinstances"></a><u>Function:</u> <b>all-named-instances</b><i> ((module <small>MODULE</small>) (local? <small>BOOLEAN</small>)) : <small>(ITERATOR OF LOGIC-OBJECT)</small></i></dt>
<dd><p>Iterate over all named instances (or individuals) visible from <var>module</var>.
Only instances that haven&rsquo;t been deleted will be considered.  If <var>local?</var>,
only return instances created locally in <var>module</var>.
</p></dd></dl>

<dl>
<dt><a name="index-all_002dnamed_002dterms"></a><u>Function:</u> <b>all-named-terms</b><i> ((module <small>MODULE</small>) (local? <small>BOOLEAN</small>)) : <small>(ITERATOR OF OBJECT)</small></i></dt>
<dd><p>Iterate over all named terms visible from <var>module</var>.  A term can be an
instance (or individual) as well as a description.  Only terms that
haven&rsquo;t been deleted will be considered.  If <var>local?</var>, only return 
terms created locally in <var>module</var>.
</p></dd></dl>

<dl>
<dt><a name="index-all_002dpropositions"></a><u>Function:</u> <b>all-propositions</b><i> ((module <small>MODULE</small>) (local? <small>BOOLEAN</small>)) : <small>(ITERATOR OF PROPOSITION)</small></i></dt>
<dd><p>Iterate over all conceived propositions visible from <var>module</var>.
Only propositions that haven&rsquo;t been deleted will be considered.
If <var>local?</var>, only return propositions conceived locally in <var>module</var>.
</p></dd></dl>

<dl>
<dt><a name="index-all_002drelation_002dvalues"></a><u>Function:</u> <b>all-relation-values</b><i> ((relation <small>SURROGATE</small>) (nMinusOneArguments <small>CONS</small>)) : <small>CONS</small></i></dt>
<dd><p>Return a set of values that satisfy the relation
<var>relation</var> (a surrogate) applied to <var>nMinusOneArguments</var> plus that last value.
</p></dd></dl>

<dl>
<dt><a name="index-all_002dsentences_002dof"></a><u>Command:</u> <b>all-sentences-of</b><i> ((instanceRef <small>OBJECT</small>)) : <small>(CONS OF STRING-WRAPPER)</small></i></dt>
<dd><p>Return a list of sentences describing facts about <var>instanceRef</var>.
</p></dd></dl>

<dl>
<dt><a name="index-all_002dslot_002dvalue_002dtypes"></a><u>Function:</u> <b>all-slot-value-types</b><i> ((self <small>LOGIC-OBJECT</small>) (relation <small>SURROGATE</small>)) : <small>(CONS OF NAMED-DESCRIPTION)</small></i></dt>
<dd><p>Return a set of the most specific types for fillers
of the slot <var>relation</var> applied to <var>self</var>.
</p></dd></dl>

<dl>
<dt><a name="index-all_002dslot_002dvalues"></a><u>Function:</u> <b>all-slot-values</b><i> ((self <small>LOGIC-OBJECT</small>) (relation <small>SURROGATE</small>)) : <small>CONS</small></i></dt>
<dd><p>Return a set of values for the slot <var>relation</var> (a surrogate)
applied to <var>self</var> (an object).
</p></dd></dl>

<dl>
<dt><a name="index-all_002dsubrelations"></a><u>Function:</u> <b>all-subrelations</b><i> ((relation <small>NAMED-DESCRIPTION</small>) (removeequivalents? <small>BOOLEAN</small>)) : <small>(CONS OF NAMED-DESCRIPTION)</small></i></dt>
<dd><p>Return a set of all (named) relations that specialize
relation.
</p></dd></dl>

<dl>
<dt><a name="index-all_002dsuperrelations"></a><u>Function:</u> <b>all-superrelations</b><i> ((relation <small>NAMED-DESCRIPTION</small>) (removeequivalents? <small>BOOLEAN</small>)) : <small>(CONS OF NAMED-DESCRIPTION)</small></i></dt>
<dd><p>Return a set of all relations that subsume relation.
</p></dd></dl>

<dl>
<dt><a name="index-all_002dtaxonomic_002dtypes"></a><u>Function:</u> <b>all-taxonomic-types</b><i> ((self <small>OBJECT</small>)) : <small>(CONS OF NAMED-DESCRIPTION)</small></i></dt>
<dd><p>Return a set of all of the types that are
satisfied by <var>self</var>, using only assertions and upward
taxonomic reasoning.
</p></dd></dl>

<dl>
<dt><a name="index-all_002dterms"></a><u>Function:</u> <b>all-terms</b><i> ((module <small>MODULE</small>) (local? <small>BOOLEAN</small>)) : <small>(ITERATOR OF OBJECT)</small></i></dt>
<dd><p>Return a list of all terms visible from <var>module</var>.  A term can be an
instance (or individual) as well as a description.  Only terms that
haven&rsquo;t been deleted will be considered.  If <var>local?</var>, only return 
terms created locally in <var>module</var>.
</p></dd></dl>

<dl>
<dt><a name="index-all_002dtypes"></a><u>Function:</u> <b>all-types</b><i> ((self <small>OBJECT</small>)) : <small>(CONS OF NAMED-DESCRIPTION)</small></i></dt>
<dd><p>Return a set of all of the types that are
satisfied by <var>self</var>.
</p></dd></dl>

<dl>
<dt><a name="index-all_002dunnamed_002dterms"></a><u>Function:</u> <b>all-unnamed-terms</b><i> ((module <small>MODULE</small>) (local? <small>BOOLEAN</small>)) : <small>ITERATOR</small></i></dt>
<dd><p>Iterate over all unnamed terms visible from <var>module</var>.  A term can be
an instance (or individual) as well as a description.  Only terms that
haven&rsquo;t been deleted will be considered.  If <var>local?</var>, only return
terms created locally in <var>module</var>.
</p></dd></dl>

<dl>
<dt><a name="index-allocate_002dsupported_002dclosure_002diterator"></a><u>Function:</u> <b>allocate-supported-closure-iterator</b><i> ((startnode <small>CONS</small>) (allocateadjacencyiterator <small>FUNCTION-CODE</small>) (filterfunction <small>FUNCTION-CODE</small>)) : <small>SUPPORTED-CLOSURE-ITERATOR</small></i></dt>
<dd><p>Similar to <code>allocate-transitive-closure-iterator</code> (which see),
but return a SUPPORTED-CLOSURE-ITERATOR instead.
</p></dd></dl>

<dl>
<dt><a name="index-allocate_002dtransitive_002dclosure_002diterator"></a><u>Function:</u> <b>allocate-transitive-closure-iterator</b><i> ((startNode <small>OBJECT</small>) (allocateAdjacencyIterator <small>FUNCTION-CODE</small>) (filterFunction <small>FUNCTION-CODE</small>)) : <small>ITERATOR</small></i></dt>
<dd><p>Return an iterator that generates the transitive
closure of applying iterators generated by <var>allocateAdjacencyIterator</var>
to <var>startNode</var>.  If <var>filterFunction</var> is non-null, that function is applied
as a filter to each node generated (nodes filtered out still generate
descendants, but they don&rsquo;t get returned).
</p></dd></dl>

<dl>
<dt><a name="index-apply_002dask"></a><u>Macro:</u> <b>apply-ask</b><i> (&amp;body (body <small>CONS</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Execute a yes/no query composed of input-variables
<code>inputVariables</code> and body <code>queryBody</code>.  Before executing, bind variables
to <code>inputBindings</code> (in sequence).
  <code>(apply-ask inputVariables queryBody inputBindings)</code>
</p></dd></dl>

<dl>
<dt><a name="index-apply_002dkappa_003f"></a><u>Function:</u> <b>apply-kappa?</b><i> ((description <small>DESCRIPTION</small>) (vector <small>VECTOR</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Apply (inherit) the description <var>description</var>
to members of the vector <var>vector</var>.  Return TRUE if no clash was detected.
Constraint propagation happens only if it is enabled prior to calling
<code>apply-kappa?</code>.
</p></dd></dl>

<dl>
<dt><a name="index-apply_002dretrieve"></a><u>Macro:</u> <b>apply-retrieve</b><i> (&amp;body (body <small>CONS</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Execute a query composed of io-variables <code>variables</code>
and body <code>queryBody</code>.  Before executing, bind variables to <code>inputBindings</code>
(in sequence). If one variable is left unbound, returns a cons list of
bindings of that variable.  If two or more are unbound, returns
a cons list of cons lists of bindings.  Setting the option :singletons?
to FALSE always returns a list of lists.  Example call:
  <code>(apply-retrieve variables queryBody inputBindings)</code>
</p></dd></dl>

<dl>
<dt><a name="index-ask_002dpartial"></a><u>N-Command:</u> <b>ask-partial</b><i> (&amp;rest (proposition&amp;options <small>PARSE-TREE</small>)) : <small>FLOAT</small></i></dt>
<dd><p>Similar to <code>ask</code> (which see), but return the highest partial match score
for the supplied proposition instead of a truth value.  If the option
:MAXIMIZE-SCORE? is set to FALSE, return after the first partial match score
has been generated.
</p></dd></dl>

<dl>
<dt><a name="index-bottom_003f"></a><u>Function:</u> <b>bottom?</b><i> ((self <small>OBJECT</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>self</var> is the undefined individual BOTTOM.
</p></dd></dl>

<dl>
<dt><a name="index-call_002dall_002dfacts_002dof"></a><u>Command:</u> <b>call-all-facts-of</b><i> ((instanceRef <small>OBJECT</small>)) : <small>(LIST OF PROPOSITION)</small></i></dt>
<dd><p>Return a list of all definite (TRUE or FALSE) propositions
that reference the instance <var>instanceRef</var>.
</p></dd></dl>

<dl>
<dt><a name="index-call_002dask"></a><u>Function:</u> <b>call-ask</b><i> ((query <small>OBJECT</small>)) : <small>TRUTH-VALUE</small></i></dt>
<dd><p>Callable version of <code>ask</code> (which see).  Accepts queries
specified by a query iterator, or specified as a CONS-list of arguments as they
would be supplied to <code>ask</code>.  Raises LOGIC-EXCEPTIONs in case of illegal
queries and logical expressions.
</p></dd></dl>

<dl>
<dt><a name="index-call_002ddefconcept"></a><u>Function:</u> <b>call-defconcept</b><i> ((arguments <small>CONS</small>)) : <small>NAMED-DESCRIPTION</small></i></dt>
<dd><p>Callable version of the <code>defconcept</code> command (which see).
Expects the same arguments as <code>defconcept</code> but supplied as a list.
</p></dd></dl>

<dl>
<dt><a name="index-call_002ddeffunction"></a><u>Function:</u> <b>call-deffunction</b><i> ((arguments <small>CONS</small>)) : <small>NAMED-DESCRIPTION</small></i></dt>
<dd><p>Callable version of the <code>deffunction</code> command (which see).
Expects the same arguments as <code>deffunction</code> but supplied as a list.
</p></dd></dl>

<dl>
<dt><a name="index-call_002ddefobject"></a><u>Function:</u> <b>call-defobject</b><i> ((arguments <small>CONS</small>)) : <small>LOGIC-OBJECT</small></i></dt>
<dd><p>Callable version of the <code>defobject</code> command (which see).
Expects the same arguments as <code>defobject</code> but supplied as a list.
</p></dd></dl>

<dl>
<dt><a name="index-call_002ddefproposition"></a><u>Function:</u> <b>call-defproposition</b><i> ((arguments <small>CONS</small>)) : <small>PROPOSITION</small></i></dt>
<dd><p>Callable version of the <code>defproposition</code> command (which see).
Expects the same arguments as <code>defproposition</code> but supplied as a list.
</p></dd></dl>

<dl>
<dt><a name="index-call_002ddefrelation"></a><u>Function:</u> <b>call-defrelation</b><i> ((arguments <small>CONS</small>)) : <small>NAMED-DESCRIPTION</small></i></dt>
<dd><p>Callable version of the <code>defrelation</code> command (which see).
Expects the same arguments as <code>defrelation</code> but supplied as a list.
</p></dd></dl>

<dl>
<dt><a name="index-call_002dlist_002dundefined_002drelations"></a><u>Function:</u> <b>call-list-undefined-relations</b><i> ((module <small>MODULE</small>) (local? <small>BOOLEAN</small>)) : <small>CONS</small></i></dt>
<dd><p>Callable version of <code>list-undefined-relations</code> (which see).
</p></dd></dl>

<dl>
<dt><a name="index-call_002dpropagate_002dconstraints"></a><u>Function:</u> <b>call-propagate-constraints</b><i> ((context <small>CONTEXT</small>)) :</i></dt>
<dd><p>Trigger constraint propagation over all propositions
in the module or world <var>context</var>.
</p></dd></dl>

<dl>
<dt><a name="index-call_002dretrieve"></a><u>Function:</u> <b>call-retrieve</b><i> ((query <small>OBJECT</small>)) : <small>QUERY-ITERATOR</small></i></dt>
<dd><p>Callable version of <code>retrieve</code> (which see).  Accepts queries
specified by a query iterator, or specified as a CONS-list of arguments as they
would be supplied to <code>retrieve</code>.  Raises LOGIC-EXCEPTIONs in case of illegal
queries and logical expressions.
</p></dd></dl>

<dl>
<dt><a name="index-call_002dretrieve_002dpartial"></a><u>Function:</u> <b>call-retrieve-partial</b><i> ((query <small>OBJECT</small>)) : <small>QUERY-ITERATOR</small></i></dt>
<dd><p>Callable version of <code>retrieve-partial</code> (which see).  Accepts queries
specified by a query iterator, or specified as a CONS-list of arguments as they
would be supplied to <code>retrieve-partial</code>.  Raises LOGIC-EXCEPTIONs in case of
illegal queries and logical expressions.
</p></dd></dl>

<dl>
<dt><a name="index-call_002drun_002dforward_002drules"></a><u>Function:</u> <b>call-run-forward-rules</b><i> ((module <small>MODULE</small>) (force? <small>BOOLEAN</small>)) :</i></dt>
<dd><p>Run forward inference rules in module <var>module</var>. If <var>module</var>
is NULL, the current module will be used.  If forward inferencing is already
up-to-date in the designated module, no additional inferencing will occur,
unless <var>force?</var> is set to TRUE, in which case all forward rules are run or rerun.
</p></dd></dl>

<dl>
<dt><a name="index-call_002dset_002dinference_002dlevel"></a><u>Function:</u> <b>call-set-inference-level</b><i> ((levelKeyword <small>KEYWORD</small>) (module <small>MODULE</small>)) : <small>KEYWORD</small></i></dt>
<dd><p>Set the inference level of <var>module</var> to the level specified
by <var>levelKeyword</var>.  If <var>module</var> is NULL and we are inside a query, set the
level of the current query iterator.  Otherwise, set the level globally.
</p></dd></dl>

<dl>
<dt><a name="index-class_003f"></a><u>Function:</u> <b>class?</b><i> ((objectRef <small>OBJECT</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>objectRef</var> denotes a class.
</p></dd></dl>

<dl>
<dt><a name="index-coerce_002dto_002dinstance"></a><u>Function:</u> <b>coerce-to-instance</b><i> ((self <small>OBJECT</small>) (original <small>OBJECT</small>)) : <small>LOGIC-OBJECT</small></i></dt>
<dd><p>Return the logic instance referred to by <var>self</var>.
</p></dd></dl>

<dl>
<dt><a name="index-coerce_002dto_002dinstance_002dor_002dliteral"></a><u>Function:</u> <b>coerce-to-instance-or-literal</b><i> ((self <small>OBJECT</small>) (original <small>OBJECT</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Return the logic instance referred to by <var>self</var>, or <var>self</var> if it is a
literal (e.g., string or number) that can&rsquo;t be coerced.
</p></dd></dl>

<dl>
<dt><a name="index-coerce_002dto_002dvector"></a><u>Function:</u> <b>coerce-to-vector</b><i> ((self <small>OBJECT</small>)) : <small>VECTOR</small></i></dt>
<dd><p>Return a vector containing the elements in <var>self</var>.
Coerce each element of <var>self</var> to be a logic object or literal.
</p></dd></dl>

<dl>
<dt><a name="index-collection_003f"></a><u>Function:</u> <b>collection?</b><i> ((objectRef <small>OBJECT</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>objectRef</var> denotes a relation or a class.
</p></dd></dl>

<dl>
<dt><a name="index-conceive_002dterm"></a><u>Command:</u> <b>conceive-term</b><i> ((tree <small>OBJECT</small>)) : <small>OBJECT</small></i></dt>
<dd><p><var>tree</var> is a term expression (a string or an s-expression),
or is a class reference (a symbol or surrogate).  Return a (possibly 
newly-conceived) term representing the internalized representation of that term.
</p></dd></dl>

<dl>
<dt><a name="index-conjoin_002dtruth_002dvalues"></a><u>Function:</u> <b>conjoin-truth-values</b><i> ((tv1 <small>TRUTH-VALUE</small>) (tv2 <small>TRUTH-VALUE</small>)) : <small>TRUTH-VALUE</small></i></dt>
<dd><p>Return the logical conjunction of truth values <var>tv1</var> and <var>tv2</var>.
</p></dd></dl>

<dl>
<dt><a name="index-consify-on-JUSTIFICATION"></a><u>Method on <small>JUSTIFICATION</small>:</u> <b>consify</b><i> (self) : <small>CONS</small></i></dt>
<dd><p>Return a CONS tree representation of the proof <var>self</var>.
Each proof step is represented as a CONS tree of the form
  (&lt;proposition&gt; (&lt;key&gt; &lt;value&gt;...) &lt;antecedent&gt;...)
where each &lt;antecedent&gt; is a CONS tree representing a subproof.  The
consification follows the original proof structure literally, i.e., no
uninteresting nodes such as patterns or AND-introductions are suppressed.
</p></dd></dl>

<dl>
<dt><a name="index-consify-on-QUERY_002dITERATOR"></a><u>Method on <small>QUERY-ITERATOR</small>:</u> <b>consify</b><i> (self) : <small>CONS</small></i></dt>
<dd><p>Generate all solutions for the query self, and collect them into a cons list
of result tuples.  If <code>:SINGLETONS? TRUE</code>, collect a list of atoms rather than a
list of lists for tuples of arity=1.
</p></dd></dl>

<dl>
<dt><a name="index-consify-on-QUERY_002dSOLUTION_002dTABLE"></a><u>Method on <small>QUERY-SOLUTION-TABLE</small>:</u> <b>consify</b><i> (self) : <small>CONS</small></i></dt>
<dd><p>Collect all solutions of <var>self</var> into a cons list and return the result.
</p></dd></dl>

<dl>
<dt><a name="index-consify_002dcurrent_002dsolutions-on-QUERY_002dITERATOR"></a><u>Method on <small>QUERY-ITERATOR</small>:</u> <b>consify-current-solutions</b><i> (self) : <small>CONS</small></i></dt>
<dd><p>Collect the current solutions of <var>self</var> into a cons list
of result tuples.  If <code>:SINGLETONS? TRUE</code>, collect a list of atoms rather than a
list of lists for tuples of arity=1.
</p></dd></dl>

<dl>
<dt><a name="index-consify_002djustification"></a><u>Function:</u> <b>consify-justification</b><i> ((self <small>JUSTIFICATION</small>) (style <small>KEYWORD</small>)) : <small>CONS</small></i></dt>
<dd><p>Return a CONS tree representation of the proof <var>self</var>.
Each proof step is represented as a CONS tree of the form
  (&lt;proposition&gt; (&lt;key&gt; &lt;value&gt;...) &lt;antecedent&gt;...)
where each &lt;antecedent&gt; is a CONS tree representing a subproof.
<var>style</var> indicates what nodes in the proof tree should be suppressed.
:RAW preserves the original structure literally, :VERBOSE keeps AND-
introductions but suppresses all auxiliary (non-logical) nodes such as
pattern nodes, and :BRIEF additionally suppresses AND-introduction nodes.
</p></dd></dl>

<dl>
<dt><a name="index-constant_003f"></a><u>Function:</u> <b>constant?</b><i> ((objectRef <small>OBJECT</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>objectRef</var> denotes a literal or scalar.
</p></dd></dl>

<dl>
<dt><a name="index-copy-on-JUSTIFICATION"></a><u>Method on <small>JUSTIFICATION</small>:</u> <b>copy</b><i> (self) : <small>(LIKE SELF)</small></i></dt>
<dd><p>Return a copy of the proof starting at <var>self</var>.  Allocates
all new justification objects, but structure-shares other information such
as propositions and substitutions.
</p></dd></dl>

<dl>
<dt><a name="index-create"></a><u>N-Command:</u> <b>create</b><i> ((name <small>GENERALIZED-SYMBOL</small>) &amp;rest (type <small>GENERALIZED-SYMBOL</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Create a logic object with name <var>name</var> and return it.
If <var>type</var> is also supplied, assert that the object belongs to that type.
</p></dd></dl>

<dl>
<dt><a name="index-create_002d2_005fd_005farray"></a><u>Function:</u> <b>create-2_d_array</b><i> ((nof-rows <small>INTEGER</small>) (nof-columns <small>INTEGER</small>) &amp;rest (values <small>OBJECT</small>)) : <small>2_D_ARRAY</small></i></dt>
<dd><p>Create a two-dimensional array with <var>nof-rows</var> rows and
<var>nof-columns</var> columns, and initialize it in row-major-order from <var>values</var>.
Missing values will be padded with NULL, extraneous values will be ignored.
</p></dd></dl>

<dl>
<dt><a name="index-create_002d2_005fd_005ffloat_002darray"></a><u>Function:</u> <b>create-2_d_float-array</b><i> ((nof-rows <small>INTEGER</small>) (nof-columns <small>INTEGER</small>) &amp;rest (values <small>FLOAT</small>)) : <small>2_D_FLOAT-ARRAY</small></i></dt>
<dd><p>Create a two-dimensional array with <var>nof-rows</var> rows and
<var>nof-columns</var> columns, and initialize it in row-major-order from <var>values</var>.
Missing values will be padded with NULL, extraneous values will be ignored.
</p></dd></dl>

<dl>
<dt><a name="index-create_002dfloat_002dvector"></a><u>Function:</u> <b>create-float-vector</b><i> (&amp;rest (values <small>FLOAT</small>)) : <small>FLOAT-VECTOR</small></i></dt>
<dd><p>Return a vector containing <var>values</var>, in order.
</p></dd></dl>

<dl>
<dt><a name="index-create_002dmarker_002dstorage"></a><u>Function:</u> <b>create-marker-storage</b><i> ((supportRecall? <small>BOOLEAN</small>)) : <small>MARKER-TABLE</small></i></dt>
<dd><p>Return a new marker storage object, used to
remember with objects have been <code>marked</code>.  If <var>supportRecall?</var>
is set, then the iterator <code>recall-marked-objects</code> can be invoked
on the new marker storage object.
</p></dd></dl>

<dl>
<dt><a name="index-create_002dvector"></a><u>Function:</u> <b>create-vector</b><i> (&amp;rest (values <small>OBJECT</small>)) : <small>VECTOR</small></i></dt>
<dd><p>Return a vector containing <var>values</var>, in order.
</p></dd></dl>

<dl>
<dt><a name="index-current_002dinference_002dlevel"></a><u>Command:</u> <b>current-inference-level</b><i> () : <small>NORMAL-INFERENCE-LEVEL</small></i></dt>
<dd><p>Return the current inference level that is active in the
current query, the current module, or, otherwise, globally.
</p></dd></dl>

<dl>
<dt><a name="index-default_002dfalse_003f"></a><u>Function:</u> <b>default-false?</b><i> ((self <small>PROPOSITION</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return true if <var>self</var> is default false.
</p></dd></dl>

<dl>
<dt><a name="index-default_002dtrue_003f"></a><u>Function:</u> <b>default-true?</b><i> ((self <small>PROPOSITION</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return true if <var>self</var> is default true.
</p></dd></dl>

<dl>
<dt><a name="index-default_002dtruth_002dvalue_003f"></a><u>Function:</u> <b>default-truth-value?</b><i> ((self <small>TRUTH-VALUE</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>self</var> is a default truth value.
</p></dd></dl>

<dl>
<dt><a name="index-define_002darithmetic_002doperation_002don_002dwrappers"></a><u>Macro:</u> <b>define-arithmetic-operation-on-wrappers</b><i> ((name <small>SYMBOL</small>) (operation-name <small>SYMBOL</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Defines <var>name</var> as an arithmetic comparision operation using the
test <code>test-name</code>.  It will take two wrapped number parameters and
return a wrapped number.  The code will use the appropriate test
for the specific subtype of wrapped number actually passed in,
and return the appropriate subtype of wrapped number based on the
normal arithmetic contagion rules.
</p>  
<p>For example, if both input parameters are wrapped integers then
the output will be a wrapped integer.  If the inputs are a
wrapped integer and a wrapped float then the output will be a
wrapped float, etc.
</p></dd></dl>

<dl>
<dt><a name="index-define_002darithmetic_002dtest_002don_002dwrappers"></a><u>Macro:</u> <b>define-arithmetic-test-on-wrappers</b><i> ((name <small>SYMBOL</small>) (test-name <small>SYMBOL</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Defines <var>name</var> as an arithmetic comparision operation using the
test <var>test-name</var>.  It will take two wrapped number parameters and
return a <code>boolean</code>.  The code will use the appropriate test for
the specific subtype of wrapped number actually passed in.
</p></dd></dl>

<dl>
<dt><a name="index-define_002dcomputed_002dconstraint"></a><u>Macro:</u> <b>define-computed-constraint</b><i> ((name <small>SYMBOL</small>) (var-list <small>CONS</small>) (constraint-test <small>CONS</small>) &amp;body (position-computations <small>CONS</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Defines <var>name</var> to be a constraint computation which uses
<var>constraint-test</var> to determine if a fully bound set of variables
satisfies the constraint.  The forms in <var>position-computations</var>
are used to compute the value for each of the positions. All such
computations must set the variable <code>value</code> to be the result
computed for the missing position.  Setting <code>value</code> to <code>null</code> for
any such computation means that that particular argument cannot
be computed from the others.  The input variables in <var>var-list</var>
will be bound to the N arguments to the constraint.
  The generated function will return a Stella Object and take as 
inputs the values of the N arguments to the constraint.  A value
of <code>null</code> means that the value is not available.  If all
arguments are not <code>null</code>, then the return value will be a Stella
wrapped boolean indicating whether the constraint is satisified
or not.
  If more than one input value is <code>null</code>, then this constraint
code will not be called.
</p></dd></dl>

<dl>
<dt><a name="index-deobjectify_002dtree"></a><u>Function:</u> <b>deobjectify-tree</b><i> ((self <small>OBJECT</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Return a copy of <var>self</var> where all logic objects are
replaced by their <code>generated</code> parse-tree version.  This is useful to
convert the result of a retrieval query into a regular parse tree.
</p></dd></dl>

<dl>
<dt><a name="index-describe_002dobject-on-NAMED_002dDESCRIPTION"></a><u>Method on <small>NAMED-DESCRIPTION</small>:</u> <b>describe-object</b><i> (self (stream <small>OUTPUT-STREAM</small>) (mode <small>KEYWORD</small>)) :</i></dt>
<dd><p>Prints a description of <var>self</var> to stream <var>stream</var>.  <var>mode</var>
can be :terse, :verbose, or :source.  Used by <code>describe</code>.
</p></dd></dl>

<dl>
<dt><a name="index-description_002dname-on-NAMED_002dDESCRIPTION"></a><u>Method on <small>NAMED-DESCRIPTION</small>:</u> <b>description-name</b><i> (self) : <small>SYMBOL</small></i></dt>
<dd><p>Return the name of the description <var>self</var>.
</p></dd></dl>

<dl>
<dt><a name="index-description_002dname-on-DESCRIPTION"></a><u>Method on <small>DESCRIPTION</small>:</u> <b>description-name</b><i> (self) : <small>SYMBOL</small></i></dt>
<dd><p>Return the name of the description <var>self</var>, if it has one.
</p></dd></dl>

<dl>
<dt><a name="index-destroy_002dinstance"></a><u>Function:</u> <b>destroy-instance</b><i> ((self <small>OBJECT</small>)) :</i></dt>
<dd><p>Destroy all propositions that reference <var>self</var>,
and mark it as <code>deleted?</code>, thereby making it invisible within class
extensions.
</p></dd></dl>

<dl>
<dt><a name="index-destroy_002dobject-1"></a><u>Function:</u> <b>destroy-object</b><i> ((self <small>OBJECT</small>)) :</i></dt>
<dd><p>Destroy <var>self</var> which can be a term or a proposition.  Destroy all
propositions that reference <var>self</var> and mark it as <code>deleted?</code> (thereby
making it invisible within class extensions).
</p></dd></dl>

<dl>
<dt><a name="index-destroy_002dproposition"></a><u>Function:</u> <b>destroy-proposition</b><i> ((proposition <small>PROPOSITION</small>)) : <small>PROPOSITION</small></i></dt>
<dd><p>Retract and destroy the proposition <var>proposition</var>.
Recursively destroy all propositions that reference <var>proposition</var>.
Also, destroy all satellite propositions of <var>proposition</var>.
</p></dd></dl>

<dl>
<dt><a name="index-destroy_002dterm"></a><u>Function:</u> <b>destroy-term</b><i> ((self <small>LOGIC-OBJECT</small>)) :</i></dt>
<dd><p>Destroy all propositions that reference <var>self</var>,
and mark it as <code>deleted?</code>, thereby making it invisible within class
extensions.  Unlink descriptions from native relations.
</p></dd></dl>

<dl>
<dt><a name="index-direct_002dsuperrelations"></a><u>Function:</u> <b>direct-superrelations</b><i> ((self <small>RELATION</small>)) : <small>(ITERATOR OF (LIKE SELF))</small></i></dt>
<dd><p>Return direct super classes/slots of <var>self</var>.
</p></dd></dl>

<dl>
<dt><a name="index-disabled_002dpowerloom_002dfeature_003f"></a><u>Function:</u> <b>disabled-powerloom-feature?</b><i> ((feature <small>KEYWORD</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return true if the STELLA <var>feature</var> is currently disabled.
</p></dd></dl>

<dl>
<dt><a name="index-disjoin_002dtruth_002dvalues"></a><u>Function:</u> <b>disjoin-truth-values</b><i> ((tv1 <small>TRUTH-VALUE</small>) (tv2 <small>TRUTH-VALUE</small>)) : <small>TRUTH-VALUE</small></i></dt>
<dd><p>Return the logical disjunction of truth values <var>tv1</var> and <var>tv2</var>.
</p></dd></dl>

<dl>
<dt><a name="index-disjoint_002dterms_003f"></a><u>Function:</u> <b>disjoint-terms?</b><i> ((d1 <small>DESCRIPTION</small>) (d2 <small>DESCRIPTION</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>d1</var> and <var>d2</var> belong to disjoint partitions.
</p></dd></dl>

<dl>
<dt><a name="index-do_002dclear_002dinstances"></a><u>Function:</u> <b>do-clear-instances</b><i> ((module <small>MODULE</small>)) :</i></dt>
<dd><p>Function version of <code>clear-instances</code> that evaluates its argument.
</p></dd></dl>

<dl>
<dt><a name="index-do_002dsave_002dmodule"></a><u>Function:</u> <b>do-save-module</b><i> ((module <small>MODULE</small>) (store <small>OBJECT</small>)) :</i></dt>
<dd><p>Save <var>module</var> to the persistent store <var>store</var> which can
either be an output stream or a persistent OBJECT-STORE.
</p></dd></dl>

<dl>
<dt><a name="index-empty_003f-on-QUERY_002dSOLUTION_002dTABLE"></a><u>Method on <small>QUERY-SOLUTION-TABLE</small>:</u> <b>empty?</b><i> (self) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>self</var> has zero entries.
</p></dd></dl>

<dl>
<dt><a name="index-empty_003f-on-FLOAT_002dVECTOR"></a><u>Method on <small>FLOAT-VECTOR</small>:</u> <b>empty?</b><i> (self) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>self</var> has length 0.
</p></dd></dl>

<dl>
<dt><a name="index-enabled_002dpowerloom_002dfeature_003f"></a><u>Function:</u> <b>enabled-powerloom-feature?</b><i> ((feature <small>KEYWORD</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return true if the STELLA <var>feature</var> is currently enabled.
</p></dd></dl>

<dl>
<dt><a name="index-estimated_002dlength-on-PAGING_002dINDEX"></a><u>Method on <small>PAGING-INDEX</small>:</u> <b>estimated-length</b><i> (self) : <small>INTEGER</small></i></dt>
<dd><p>Return the estimated length of the sequences in <var>self</var>,
which could be too large if some of the members have been deleted.
</p></dd></dl>

<dl>
<dt><a name="index-evaluate_002dproposition"></a><u>Function:</u> <b>evaluate-proposition</b><i> ((self <small>PROPOSITION</small>)) :</i></dt>
<dd><p>Evaluate <var>self</var> against its arguments, possibly resulting in
the setting or changing of its truth value.
</p></dd></dl>

<dl>
<dt><a name="index-evaluation_002dstate"></a><u>Function:</u> <b>evaluation-state</b><i> ((proposition <small>PROPOSITION</small>)) : <small>KEYWORD</small></i></dt>
<dd><p>Return :POSTED if <var>proposition</var> is on the evaluation queue
for *context*, :EVALUATED if has been evaluated, or NULL if it has never been evaluated.
</p></dd></dl>

<dl>
<dt><a name="index-evaluation_002dstate_002dsetter"></a><u>Function:</u> <b>evaluation-state-setter</b><i> ((proposition <small>PROPOSITION</small>) (state <small>KEYWORD</small>)) :</i></dt>
<dd><p>Record the evaluation <var>state</var> of <var>proposition</var>.
</p></dd></dl>

<dl>
<dt><a name="index-explain_002dproposition"></a><u>Function:</u> <b>explain-proposition</b><i> ((prop <small>PROPOSITION</small>) (style <small>KEYWORD</small>) (maxdepth <small>INTEGER</small>) (stream <small>OUTPUT-STREAM</small>)) :</i></dt>
<dd><p>Print an explanation for <var>prop</var> if there is one.  This will only happen
for forward-chained propositions.
</p></dd></dl>

<dl>
<dt><a name="index-explain_002dwhy"></a><u>Function:</u> <b>explain-why</b><i> ((label <small>STRING</small>) (style <small>KEYWORD</small>) (maxdepth <small>INTEGER</small>) (stream <small>OUTPUT-STREAM</small>)) :</i></dt>
<dd><p>Programmer&rsquo;s interface to WHY function.
</p></dd></dl>

<dl>
<dt><a name="index-explain_002dwhynot"></a><u>Function:</u> <b>explain-whynot</b><i> ((label <small>STRING</small>) (style <small>KEYWORD</small>) (maxdepth <small>INTEGER</small>) (summary? <small>BOOLEAN</small>) (stream <small>OUTPUT-STREAM</small>)) :</i></dt>
<dd><p>Programmer&rsquo;s interface to the WHYNOT function.
</p></dd></dl>

<dl>
<dt><a name="index-false_002dtruth_002dvalue_003f"></a><u>Function:</u> <b>false-truth-value?</b><i> ((self <small>TRUTH-VALUE</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>self</var> represents some form of falsehood.
</p></dd></dl>

<dl>
<dt><a name="index-false_003f"></a><u>Function:</u> <b>false?</b><i> ((self <small>PROPOSITION</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return true if <var>self</var> is false (or default-false if we are
considering default assertions).
</p></dd></dl>

<dl>
<dt><a name="index-fetch_002dinstance-on-OBJECT_002dSTORE"></a><u>Method on <small>OBJECT-STORE</small>:</u> <b>fetch-instance</b><i> (store (name <small>OBJECT</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Fetch the instance identified by <var>name</var> (a string or symbol) from <var>store</var>
and return it as an appropriate logic object.  This needs to be appropriately
specialized on actual OBJECT-STORE implementations.
</p></dd></dl>

<dl>
<dt><a name="index-fetch_002drelation-on-OBJECT_002dSTORE"></a><u>Method on <small>OBJECT-STORE</small>:</u> <b>fetch-relation</b><i> (store (name <small>OBJECT</small>)) : <small>NAMED-DESCRIPTION</small></i></dt>
<dd><p>Fetch the relation identified by <var>name</var> (a string or symbol) from <var>store</var>
and return it as a named description.  This needs to be appropriately 
specialized on actual OBJECT-STORE implementations.
</p></dd></dl>

<dl>
<dt><a name="index-fill_002darray-on-2_005fD_005fARRAY"></a><u>Method on <small>2_D_ARRAY</small>:</u> <b>fill-array</b><i> (self &amp;rest (values <small>OBJECT</small>)) :</i></dt>
<dd><p>Fill the two-dimensional array <var>self</var> in row-major-order
from <var>values</var>.  Missing values will retain their old values, extraneous values
will be ignored.
</p></dd></dl>

<dl>
<dt><a name="index-fill_002darray-on-2_005fD_005fFLOAT_002dARRAY"></a><u>Method on <small>2_D_FLOAT-ARRAY</small>:</u> <b>fill-array</b><i> (self &amp;rest (values <small>FLOAT</small>)) :</i></dt>
<dd><p>Fill the two-dimensional array <var>self</var> in row-major-order
from <var>values</var>.  Missing values will retain their old values, extraneous values
will be ignored.
</p></dd></dl>

<dl>
<dt><a name="index-finalize_002dobjects"></a><u>Function:</u> <b>finalize-objects</b><i> () :</i></dt>
<dd><p>Finalize all currently unfinalized objects.
The user-level entry point for this is <code>(process-definitions)</code>.
</p></dd></dl>

<dl>
<dt><a name="index-find_002ddirect_002dsupers_002dand_002dsubs"></a><u>Function:</u> <b>find-direct-supers-and-subs</b><i> ((self <small>DESCRIPTION</small>) (onlysupers? <small>BOOLEAN</small>)) : <small>(CONS OF DESCRIPTION)</small> <small>(CONS OF DESCRIPTION)</small> <small>(CONS OF DESCRIPTION)</small></i></dt>
<dd><p>Classify <var>self</var> and return three values, its direct
supers, direct subs, and a list of equivalent descriptions.
Setting <code>supersOnly?</code> may speed up the computation (perhaps by a lot).
If <code>description</code> is nameless and has no dependent propositions, then
it is automatically removed from the hierarchy after classification.
</p></dd></dl>

<dl>
<dt><a name="index-find_002ddirect_002dsupers_002dof_002dinstance"></a><u>Function:</u> <b>find-direct-supers-of-instance</b><i> ((self <small>OBJECT</small>)) : <small>(CONS OF LOGIC-OBJECT)</small></i></dt>
<dd><p>Classify <var>self</var> and return a list of most specific 
named descriptions among all descriptions that it satisfies.
</p></dd></dl>

<dl>
<dt><a name="index-find_002dinstance"></a><u>N-Command:</u> <b>find-instance</b><i> ((instanceRef <small>OBJECT</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Return the nearest instance with name <var>instanceRef</var>
visible from the current module.  <var>instanceRef</var> can be a string, symbol,
or surrogate.  If <var>instanceRef</var> is a surrogate, the search originates
in the module the surrogate was interned in.
</p></dd></dl>

<dl>
<dt><a name="index-find_002drule"></a><u>N-Command:</u> <b>find-rule</b><i> ((ruleName <small>NAME</small>)) : <small>PROPOSITION</small></i></dt>
<dd><p>Search for a rule named <var>ruleName</var>.  Like <code>get-rule</code>,
but <code>find-rule</code> implicity quotes its input argument.
</p></dd></dl>

<dl>
<dt><a name="index-function_003f"></a><u>Function:</u> <b>function?</b><i> ((relationRef <small>OBJECT</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>relationRef</var> references a function.
</p></dd></dl>

<dl>
<dt><a name="index-generate_002dexpression"></a><u>Function:</u> <b>generate-expression</b><i> ((self <small>LOGIC-OBJECT</small>) (canonicalizevariablenames? <small>BOOLEAN</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Return an s-expression representing the source expression for <var>self</var>.
</p></dd></dl>

<dl>
<dt><a name="index-generate_002dspecialized_002dterm-on-LOGIC_002dTHING"></a><u>Method on <small>LOGIC-THING</small>:</u> <b>generate-specialized-term</b><i> (self) : <small>OBJECT</small></i></dt>
<dd><p>Method to generate a specialized term for <var>self</var>.  This is designed
to allow for extension of the term generation code to cover other
types of objects for the logic.  This particular method will signal
an error unless there is a surrogate-value-inverse link set.
</p></dd></dl>

<dl>
<dt><a name="index-get_002dclass"></a><u>Function:</u> <b>get-class</b><i> ((instanceRef <small>OBJECT</small>)) : <small>LOGIC-OBJECT</small></i></dt>
<dd><p>Return the nearest class with name <var>instanceRef</var>
visible from the current module.  <var>instanceRef</var> can be a string, symbol,
or surrogate.  If <var>instanceRef</var> is a surrogate, the search originates
in the module the surrogate was interned in.
</p></dd></dl>

<dl>
<dt><a name="index-get_002dforward_002djustifications"></a><u>Function:</u> <b>get-forward-justifications</b><i> ((proposition <small>PROPOSITION</small>)) : <small>(LIST OF JUSTIFICATION)</small></i></dt>
<dd><p>Return <var>proposition</var>s forward justifications.
</p></dd></dl>

<dl>
<dt><a name="index-get_002dinstance"></a><u>Function:</u> <b>get-instance</b><i> ((instanceRef <small>OBJECT</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Return the nearest instance with name <var>instanceRef</var>
visible from the current module.  <var>instanceRef</var> can be a string, symbol,
or surrogate.  If <var>instanceRef</var> is a surrogate, the search originates
in the module the surrogate was interned in.
</p></dd></dl>

<dl>
<dt><a name="index-get_002dmodule-1"></a><u>Function:</u> <b>get-module</b><i> ((moduleRef <small>OBJECT</small>)) : <small>MODULE</small></i></dt>
<dd><p>Return a module named <var>moduleRef</var>.
</p></dd></dl>

<dl>
<dt><a name="index-get_002drelation-1"></a><u>Function:</u> <b>get-relation</b><i> ((instanceRef <small>OBJECT</small>)) : <small>LOGIC-OBJECT</small></i></dt>
<dd><p>Return the nearest relation with name <var>instanceRef</var>
visible from the current module.  <var>instanceRef</var> can be a string, symbol,
or surrogate.  If <var>instanceRef</var> is a surrogate, the search originates
in the module the surrogate was interned in.
</p></dd></dl>

<dl>
<dt><a name="index-get_002dself_002dor_002dprototype"></a><u>Function:</u> <b>get-self-or-prototype</b><i> ((instanceRef <small>OBJECT</small>)) : <small>LOGIC-OBJECT</small></i></dt>
<dd><p>Used to convert a computation to reference so-called
<code>template</code> slots rather than <code>own</code> slots:  If <var>instanceRef</var> denotes a class,
return a prototype of that class.  Otherwise, return <var>instanceRef</var>.
</p></dd></dl>

<dl>
<dt><a name="index-get_002dslot_002dmaximum_002dcardinality"></a><u>Function:</u> <b>get-slot-maximum-cardinality</b><i> ((self <small>LOGIC-OBJECT</small>) (relation <small>SURROGATE</small>)) : <small>INTEGER</small></i></dt>
<dd><p>Return a maximum value for the number of fillers of relation
<var>relation</var> (a surrogate) applied to the instance <var>self</var> (an object).
</p></dd></dl>

<dl>
<dt><a name="index-get_002dslot_002dminimum_002dcardinality"></a><u>Function:</u> <b>get-slot-minimum-cardinality</b><i> ((self <small>LOGIC-OBJECT</small>) (relation <small>SURROGATE</small>)) : <small>INTEGER</small></i></dt>
<dd><p>Return a minimum value for the number of fillers of relation
<var>relation</var> (a surrogate) applied to the instance <var>self</var> (an object).
</p></dd></dl>

<dl>
<dt><a name="index-get_002dslot_002dvalue"></a><u>Function:</u> <b>get-slot-value</b><i> ((self <small>LOGIC-OBJECT</small>) (relation <small>SURROGATE</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Return a single value for the slot <var>relation</var> (a surrogate)
applied to <var>self</var> (an object).
</p></dd></dl>

<dl>
<dt><a name="index-get_002dslot_002dvalue_002dtype"></a><u>Function:</u> <b>get-slot-value-type</b><i> ((self <small>LOGIC-OBJECT</small>) (relation <small>SURROGATE</small>)) : <small>NAMED-DESCRIPTION</small></i></dt>
<dd><p>Return a most specific type for fillers of the slot <var>relation</var>
(a surrogate) applied to <var>self</var>. If there is more than one, pick one.
</p></dd></dl>

<dl>
<dt><a name="index-get_002dwhy_002djustification"></a><u>Function:</u> <b>get-why-justification</b><i> ((label <small>STRING</small>)) : <small>JUSTIFICATION</small></i></dt>
<dd><p>Returns the current WHY justification.  May also throw one of the
following subtypes of EXPLAIN-EXCEPTION:
   EXPLAIN-NO-QUERY-EXCEPTION
   EXPLAIN-NO-SOLUTION-EXCEPTION
   EXPLAIN-NO-MORE-SOLUTIONS-EXCEPTION
   EXPLAIN-NOT-ENABLED-EXCEPTION
   EXPLAIN-NO-SUCH-LABEL-EXCEPTION
   EXPLAIN-QUERY-TRUE-EXCEPTION
</p></dd></dl>

<dl>
<dt><a name="index-get_002dwhynot_002djustifications"></a><u>Function:</u> <b>get-whynot-justifications</b><i> ((query <small>QUERY-ITERATOR</small>) (label <small>STRING</small>) (mapping <small>EXPLANATION-MAPPING</small>)) : <small>(LIST OF JUSTIFICATION)</small></i></dt>
<dd><p>Programmer&rsquo;s interface to WHYNOT function.  Derive
justifications why <var>query</var> failed, or, if <var>label</var> was supplied as non-NULL,
lookup its justification relative to <var>mapping</var> and return the result.
</p></dd></dl>

<dl>
<dt><a name="index-has_002dforward_002djustifications_003f"></a><u>Function:</u> <b>has-forward-justifications?</b><i> ((proposition <small>PROPOSITION</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>proposition</var> has any forward justifications.
</p></dd></dl>

<dl>
<dt><a name="index-help_002dprint_002doutline-on-NAMED_002dDESCRIPTION"></a><u>Method on <small>NAMED-DESCRIPTION</small>:</u> <b>help-print-outline</b><i> (top (stream <small>OUTPUT-STREAM</small>) (current-depth <small>INTEGER</small>) (depth <small>INTEGER</small>) (named? <small>BOOLEAN</small>)) :</i></dt>
<dd><p>Helper function for <code>print-concept-outline</code>
</p></dd></dl>

<dl>
<dt><a name="index-help_002dprint_002doutline-on-DESCRIPTION"></a><u>Method on <small>DESCRIPTION</small>:</u> <b>help-print-outline</b><i> (top (stream <small>OUTPUT-STREAM</small>) (current-depth <small>INTEGER</small>) (depth <small>INTEGER</small>) (named? <small>BOOLEAN</small>)) :</i></dt>
<dd><p>Helper function for <code>print-concept-outline</code>
</p></dd></dl>

<dl>
<dt><a name="index-in_002ddialect"></a><u>N-Command:</u> <b>in-dialect</b><i> ((dialect <small>NAME</small>)) : <small>KEYWORD</small></i></dt>
<dd><p>Change the current logic dialect to <var>dialect</var>.
Currently supported dialects are <code>KIF</code>, <code>STELLA</code>, and <code>PREFIX-STELLA</code>.
The STELLA dialects are not recommended for the construction of knowledge
bases, they are mainly used internally by PowerLoom.
</p></dd></dl>

<dl>
<dt><a name="index-inconsistent_002dtruth_002dvalue_003f"></a><u>Function:</u> <b>inconsistent-truth-value?</b><i> ((self <small>TRUTH-VALUE</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>self</var> represents INCONSISTENT.
</p></dd></dl>

<dl>
<dt><a name="index-inconsistent_003f"></a><u>Function:</u> <b>inconsistent?</b><i> ((self <small>PROPOSITION</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return true if <var>self</var> is inconsistent (true and false).
</p></dd></dl>

<dl>
<dt><a name="index-insert_002dat-on-QUERY_002dSOLUTION_002dTABLE"></a><u>Method on <small>QUERY-SOLUTION-TABLE</small>:</u> <b>insert-at</b><i> (self (key <small>(LIKE (ANY-KEY SELF))</small>) (value <small>(LIKE (ANY-VALUE SELF))</small>)) :</i></dt>
<dd><p>Insert <var>value</var> identified by <var>key</var> into <var>self</var>.  If a solution
with that key already exists, destructively modify it with the slot values of
<var>value</var>.  This is necessary to preserve the order of solutions in <var>self</var>.
</p></dd></dl>

<dl>
<dt><a name="index-invert_002dtruth_002dvalue"></a><u>Function:</u> <b>invert-truth-value</b><i> ((self <small>TRUTH-VALUE</small>)) : <small>TRUTH-VALUE</small></i></dt>
<dd><p>Return the logical negation of <var>self</var>.
</p></dd></dl>

<dl>
<dt><a name="index-known_002dtruth_002dvalue_003f"></a><u>Function:</u> <b>known-truth-value?</b><i> ((self <small>TRUTH-VALUE</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>self</var> is a known truth value, that is
either TRUE or FALSE, but not UNKNOWN, INCONSISTENT, etc.
</p></dd></dl>

<dl>
<dt><a name="index-length-on-QUERY_002dSOLUTION_002dTABLE"></a><u>Method on <small>QUERY-SOLUTION-TABLE</small>:</u> <b>length</b><i> (self) : <small>INTEGER</small></i></dt>
<dd><p>Return the number of entries in <var>self</var>.
</p></dd></dl>

<dl>
<dt><a name="index-list_002dfeatures"></a><u>Command:</u> <b>list-features</b><i> () : <small>LIST</small></i></dt>
<dd><p>Return a list containing two lists, a list of currently enabled PowerLoom
features, and a list of all available PowerLoom features.
</p></dd></dl>

<dl>
<dt><a name="index-listify-on-QUERY_002dITERATOR"></a><u>Method on <small>QUERY-ITERATOR</small>:</u> <b>listify</b><i> (self) : <small>LIST</small></i></dt>
<dd><p>Just like <code>QUERY-ITERATOR.consify</code> but return a LIST instead.
</p></dd></dl>

<dl>
<dt><a name="index-load_002dcmd_002dline_002dfiles"></a><u>Command:</u> <b>load-cmd-line-files</b><i> () :</i></dt>
<dd><p>Loads all PowerLoom files specified on the command line.
If directories are listed, all PowerLoom files in those directories are loaded.
Since when this is called we might still have unprocessed command line args,
this only looks at files which are to the right of the last argument that
starts with a <code>-</code> character.
</p></dd></dl>

<dl>
<dt><a name="index-load_002ddirectory"></a><u>Command:</u> <b>load-directory</b><i> ((directory <small>STRING</small>)) :</i></dt>
<dd><p>Load all PowerLoom files (*.plm) in <var>directory</var> in alphabetic sort order.
</p></dd></dl>

<dl>
<dt><a name="index-load_002dstream-1"></a><u>Function:</u> <b>load-stream</b><i> ((stream <small>INPUT-STREAM</small>)) :</i></dt>
<dd><p>Read logic commands from <var>stream</var> and evaluate them.
</p></dd></dl>

<dl>
<dt><a name="index-load_002dstream_002din_002dmodule"></a><u>Function:</u> <b>load-stream-in-module</b><i> ((stream <small>INPUT-STREAM</small>) (default-module <small>MODULE</small>)) :</i></dt>
<dd><p>Read logic commands from <var>stream</var> and evaluate them.  If <var>default-module</var>
is not <code>null</code>, then any commands will be read into that module unless
an <code>in-module</code> declaration is encountered which will over-ride the default
value.  If noe <var>default-module</var> is specified, and the input stream does
not have an <code>in-module</code> form, an error is signaled.
</p></dd></dl>

<dl>
<dt><a name="index-logic_002dclass_003f"></a><u>Function:</u> <b>logic-class?</b><i> ((self <small>CLASS</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if the class <var>self</var> or one of its
supers supports indices that record extensions referenced by
the logic system. Also return true for literal classes.
</p></dd></dl>

<dl>
<dt><a name="index-logic_002dform_002dless_003f"></a><u>Function:</u> <b>logic-form-less?</b><i> ((o1 <small>OBJECT</small>) (o2 <small>OBJECT</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>A sorting predicate for objects <var>o1</var> and <var>o2</var> that can appear in logical
forms.  Performs a combined numeric and lexocographic sort that accounts
for lists, collections and propositions.  Numbers precede all other values,
<code>null</code> follows all other values.
</p></dd></dl>

<dl>
<dt><a name="index-logic_002dmodule_003f"></a><u>Function:</u> <b>logic-module?</b><i> ((self <small>MODULE</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>self</var> is a logic module, implying
that relations defined within it define a knowledge base.  A module
is a logic module iff it inherits the module <code>PL-KERNEL</code>.
</p></dd></dl>

<dl>
<dt><a name="index-lookup-on-QUERY_002dSOLUTION_002dTABLE"></a><u>Method on <small>QUERY-SOLUTION-TABLE</small>:</u> <b>lookup</b><i> (self (key <small>(LIKE (ANY-KEY SELF))</small>)) : <small>(LIKE (ANY-VALUE SELF))</small></i></dt>
<dd><p>Lookup the solution identified by <var>key</var> in <var>self</var> and
return its value, or NULL if no such solution exists.
</p></dd></dl>

<dl>
<dt><a name="index-lookup_002dnative_002dcomputation"></a><u>Function:</u> <b>lookup-native-computation</b><i> ((native-name <small>STRING</small>) (arity <small>INTEGER</small>)) : <small>FUNCTION-CODE</small></i></dt>
<dd><p>Returns the native funtion code for <var>native-name</var> if it exists
and the underlying programming languages supports such lookups.  It is looked up
using the signature of a computation function supported by the computation specialist.
</p></dd></dl>

<dl>
<dt><a name="index-lookup_002dnative_002dspecialist"></a><u>Function:</u> <b>lookup-native-specialist</b><i> ((native-name <small>STRING</small>)) : <small>FUNCTION-CODE</small></i></dt>
<dd><p>Returns the native funtion code for <var>native-name</var> if it exists
and the underlying programming languages supports such lookups.  Uses the signature
of a specialist function.
</p></dd></dl>

<dl>
<dt><a name="index-merge_002dtruth_002dvalues"></a><u>Function:</u> <b>merge-truth-values</b><i> ((tv1 <small>TRUTH-VALUE</small>) (tv2 <small>TRUTH-VALUE</small>)) : <small>TRUTH-VALUE</small></i></dt>
<dd><p>Merge two truth values that are describing the &quot;same&quot; logical
proposition.  This handles subordination of default to strict values, 
known over unknown and potential inconsistent values.
</p>
<p>In particular, this can be used to check for negated values by asking for
the truth of a proposition and its negation, inverting the negation and then
using merge to come up with an answer.
</p></dd></dl>

<dl>
<dt><a name="index-named_002ddescription_003f"></a><u>Function:</u> <b>named-description?</b><i> ((self <small>DESCRIPTION</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>self</var> is the description of a named class or relation.
</p></dd></dl>

<dl>
<dt><a name="index-natural_002ddeduction_002dmode_003f"></a><u>Function:</u> <b>natural-deduction-mode?</b><i> () : <small>BOOLEAN</small></i></dt>
<dd><p>True if normalization is governed by natural
deduction semantics.
</p></dd></dl>

<dl>
<dt><a name="index-non_002dempty_003f-on-QUERY_002dSOLUTION_002dTABLE"></a><u>Method on <small>QUERY-SOLUTION-TABLE</small>:</u> <b>non-empty?</b><i> (self) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>self</var> has at least 1 entry.
</p></dd></dl>

<dl>
<dt><a name="index-non_002dempty_003f-on-FLOAT_002dVECTOR"></a><u>Method on <small>FLOAT-VECTOR</small>:</u> <b>non-empty?</b><i> (self) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>self</var> has length &gt; 0.
</p></dd></dl>

<dl>
<dt><a name="index-nth-on-QUERY_002dSOLUTION_002dTABLE"></a><u>Method on <small>QUERY-SOLUTION-TABLE</small>:</u> <b>nth</b><i> (self (position <small>INTEGER</small>)) : <small>(LIKE (ANY-VALUE SELF))</small></i></dt>
<dd><p>Return the nth solution in <var>self</var>, or NULL if it is empty.
</p></dd></dl>

<dl>
<dt><a name="index-object_002dname"></a><u>Function:</u> <b>object-name</b><i> ((self <small>OBJECT</small>)) : <small>SYMBOL</small></i></dt>
<dd><p>Return the name symbol for the logic object <var>self</var>.
</p></dd></dl>

<dl>
<dt><a name="index-object_002dname_002dstring"></a><u>Function:</u> <b>object-name-string</b><i> ((self <small>OBJECT</small>)) : <small>STRING</small></i></dt>
<dd><p>Return the name string for the logic object <var>self</var>.
</p></dd></dl>

<dl>
<dt><a name="index-object_002dsurrogate"></a><u>Function:</u> <b>object-surrogate</b><i> ((self <small>OBJECT</small>)) : <small>SURROGATE</small></i></dt>
<dd><p>Return the surrogate naming the object <var>self</var>, which
may be a Stella class that is used in PowerLoom as well as
a more normal powerloom object.
</p></dd></dl>

<dl>
<dt><a name="index-object_002dsurrogate_002dsetter"></a><u>Function:</u> <b>object-surrogate-setter</b><i> ((self <small>OBJECT</small>) (name <small>SURROGATE</small>)) : <small>SURROGATE</small></i></dt>
<dd><p>Return the name of the logic object <var>self</var> to <var>name</var>.
</p></dd></dl>

<dl>
<dt><a name="index-pop-on-QUERY_002dSOLUTION_002dTABLE"></a><u>Method on <small>QUERY-SOLUTION-TABLE</small>:</u> <b>pop</b><i> (self) : <small>(LIKE (ANY-VALUE SELF))</small></i></dt>
<dd><p>Remove and return the first solution of <var>self</var> or NULL
if the table is empty.
</p></dd></dl>

<dl>
<dt><a name="index-post_002dfor_002devaluation"></a><u>Function:</u> <b>post-for-evaluation</b><i> ((self <small>PROPOSITION</small>) (world <small>CONTEXT</small>)) :</i></dt>
<dd><p>Push <var>self</var> onto the evaluation queue (unless it&rsquo;s already there).
</p></dd></dl>

<dl>
<dt><a name="index-powerloom"></a><u>Function:</u> <b>powerloom</b><i> () :</i></dt>
<dd><p>Run the PowerLoom listener.  Read logic commands from the
standard input, evaluate them, and print their results.  Exit if the user
entered <code>bye</code>, <code>exit</code>, <code>halt</code>, <code>quit</code>, or <code>stop</code>.
</p></dd></dl>

<dl>
<dt><a name="index-powerloom_002dgui_002dexit_002dhook"></a><u>Function:</u> <b>powerloom-gui-exit-hook</b><i> ((ignore <small>OBJECT</small>)) :</i></dt>
<dd><p>Exit hook to stop the PowerLoom GUI if it is running.
</p></dd></dl>

<dl>
<dt><a name="index-powerloom_002dinformation"></a><u>Command:</u> <b>powerloom-information</b><i> () : <small>STRING</small></i></dt>
<dd><p>Returns information about the current PowerLoom implementation.
Useful when reporting problems.
</p></dd></dl>

<dl>
<dt><a name="index-pretty_002dprint_002dlogical_002dform"></a><u>Function:</u> <b>pretty-print-logical-form</b><i> ((form <small>OBJECT</small>) (stream <small>OUTPUT-STREAM</small>)) :</i></dt>
<dd><p>Pretty-print the logical form <var>form</var> to <var>stream</var> according
to the current setting of <code>*logic-dialect*</code>.
</p></dd></dl>

<dl>
<dt><a name="index-print_002darray-on-2_005fD_005fARRAY"></a><u>Method on <small>2_D_ARRAY</small>:</u> <b>print-array</b><i> (self (stream <small>NATIVE-OUTPUT-STREAM</small>)) :</i></dt>
<dd><p>Print the array <var>self</var> to <var>stream</var>.
</p></dd></dl>

<dl>
<dt><a name="index-print_002darray-on-2_005fD_005fFLOAT_002dARRAY"></a><u>Method on <small>2_D_FLOAT-ARRAY</small>:</u> <b>print-array</b><i> (self (stream <small>NATIVE-OUTPUT-STREAM</small>)) :</i></dt>
<dd><p>Print the array <var>self</var> to <var>stream</var>.
</p></dd></dl>

<dl>
<dt><a name="index-print_002dextension_002dsizes"></a><u>Function:</u> <b>print-extension-sizes</b><i> ((module <small>MODULE</small>) (sizeCutoff <small>INTEGER</small>)) :</i></dt>
<dd><p>Print the extension sizes of concepts visible in <var>module</var>.
If <var>module</var> is NULL the current module is used.  Do not report extensions
with size less than <var>sizeCutoff</var> (default is 10).
</p></dd></dl>

<dl>
<dt><a name="index-print_002dfacts"></a><u>N-Command:</u> <b>print-facts</b><i> ((instanceref <small>OBJECT</small>)) :</i></dt>
<dd><p>Like <code>all-facts-of</code>, but sorts and prints each fact
on a separate line on the standard output stream.
</p></dd></dl>

<dl>
<dt><a name="index-print_002dgoal_002dstack"></a><u>Function:</u> <b>print-goal-stack</b><i> ((frame <small>CONTROL-FRAME</small>) (verbose? <small>BOOLEAN</small>)) :</i></dt>
<dd><p>Print stack of goals.  Assumes that query has been interrupted
with a full stack of control frames.
</p></dd></dl>

<dl>
<dt><a name="index-print_002dlogical_002dform"></a><u>Function:</u> <b>print-logical-form</b><i> ((form <small>OBJECT</small>) (stream <small>OUTPUT-STREAM</small>)) :</i></dt>
<dd><p>Print the logical form <var>form</var> to <var>stream</var> according to
the current setting of <code>*logic-dialect*</code>.  Pretty-printing is controlled
by the current setting of <code>*prettyPrintLogicalForms?*</code>.
</p></dd></dl>

<dl>
<dt><a name="index-print_002dlogical_002dform_002din_002ddialect"></a><u>Function:</u> <b>print-logical-form-in-dialect</b><i> ((self <small>OBJECT</small>) (dialect <small>KEYWORD</small>) (stream <small>OUTPUT-STREAM</small>)) :</i></dt>
<dd><p>Produce a stringified version of a logical representation
of <var>self</var> and write it to the stream <var>stream</var>.  Use the dialect <var>dialect</var>,
or use the current dialect if <var>dialect</var> is NULL.
</p></dd></dl>

<dl>
<dt><a name="index-print_002dunformatted_002dlogical_002dform"></a><u>Function:</u> <b>print-unformatted-logical-form</b><i> ((form <small>OBJECT</small>) (stream <small>OUTPUT-STREAM</small>)) :</i></dt>
<dd><p>Print the logical form <var>form</var> to <var>stream</var> according to
the current setting of <code>*logic-dialect*</code>.  Pretty-printing is explicitly
forced to be turned off.
</p></dd></dl>

<dl>
<dt><a name="index-print_002dwhynot_002djustification"></a><u>Function:</u> <b>print-whynot-justification</b><i> ((justification <small>JUSTIFICATION</small>) (stream <small>OUTPUT-STREAM</small>) (maxDepth <small>INTEGER</small>) (style <small>KEYWORD</small>) (summary? <small>BOOLEAN</small>)) :</i></dt>
<dd><p>Print a WHYNOT <var>justification</var> to <var>stream</var> according to
<var>maxDepth</var> and <var>style</var>.  Print a summary only if <var>summary?</var> is TRUE.
</p></dd></dl>

<dl>
<dt><a name="index-random_002dfloat"></a><u>Function:</u> <b>random-float</b><i> ((n <small>FLOAT</small>)) : <small>FLOAT</small></i></dt>
<dd><p>Generate a random integer in the interval [0..n-1].
<var>n</var> must be &lt;= 2^15.
</p></dd></dl>

<dl>
<dt><a name="index-recall_002dmarked_002dobjects-on-MARKER_002dTABLE"></a><u>Method on <small>MARKER-TABLE</small>:</u> <b>recall-marked-objects</b><i> (self) : <small>LIST-ITERATOR</small></i></dt>
<dd><p>Return an iterator that generates all marked objects
recorded in <var>self</var>.
</p></dd></dl>

<dl>
<dt><a name="index-record_002djustifications_003f"></a><u>Function:</u> <b>record-justifications?</b><i> () : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if every query records justifications to enable
the explanation of concluded results.
</p></dd></dl>

<dl>
<dt><a name="index-register_002dcomputation_002dfunction"></a><u>Function:</u> <b>register-computation-function</b><i> ((name <small>STRING</small>) (code <small>FUNCTION-CODE</small>) (arity <small>INTEGER</small>)) :</i></dt>
<dd><p>Creates a registration entry for <var>name</var> as a computation which
executes <var>code</var>.  Essentially just builds the Stella meta-information
tructure needed to funcall <var>name</var> as a computation function by the
computation specialist.  The function definition in <var>code</var> needs to
accept ARITY Stella OBJECTs as arguments and return a Stella OBJECT 
suitable for PowerLoom use.  (These are generally LOGIC-OBJECTs and the
literal wrappers FLOAT-WRAPPER, INTEGER-WRAPPER and STRING-WRAPPER.)
</p></dd></dl>

<dl>
<dt><a name="index-register_002dcomputation_002dfunction_002dname"></a><u>Command:</u> <b>register-computation-function-name</b><i> ((stella-name <small>STRING</small>) (native-name <small>STRING</small>) (arity <small>INTEGER</small>)) :</i></dt>
<dd><p>registers a computation function <var>stella-name</var> based on the <var>native-name</var>
for the particular programming language in question.  Use of this command makes
the resulting code or knowledge bases non-portable to other target languages.
</p></dd></dl>

<dl>
<dt><a name="index-register_002dlogic_002ddialect_002dprint_002dfunction"></a><u>Function:</u> <b>register-logic-dialect-print-function</b><i> ((dialect <small>KEYWORD</small>) (fn <small>FUNCTION-CODE-WRAPPER</small>)) :</i></dt>
<dd><p>Register <var>fn</var> as a logic-object print function for <var>dialect</var>.
Each function should have the signature <code>((self OBJECT) (stream OUTPUT-STREAM))</code>.
Any return values will be ignored.
</p></dd></dl>

<dl>
<dt><a name="index-register_002dspecialist_002dfunction"></a><u>Function:</u> <b>register-specialist-function</b><i> ((name <small>STRING</small>) (code <small>FUNCTION-CODE</small>)) :</i></dt>
<dd><p>Creates a registration entry for <var>name</var> as a specialist which
executes <var>code</var>.  Essentially just builds the Stella meta-information
tructure needed to funcall <var>name</var> as a specialist.  The function definition
in <var>code</var> needs to accept a CONTROL-FRAME and KEYWORD as arguments and
return a KEYWORD.  Side effects on elements of the proposition in the
control frame can be used to bind and thus return values.
</p></dd></dl>

<dl>
<dt><a name="index-register_002dspecialist_002dfunction_002dname"></a><u>Command:</u> <b>register-specialist-function-name</b><i> ((stella-name <small>STRING</small>) (native-name <small>STRING</small>)) :</i></dt>
<dd><p>registers a specialist function <var>stella-name</var> based on the <var>native-name</var>
for the particular programming language in question.  Use of this command makes
the resulting code or knowledge bases non-portable to other target languages.
</p></dd></dl>

<dl>
<dt><a name="index-relation_002dname"></a><u>Function:</u> <b>relation-name</b><i> ((self <small>NAMED-DESCRIPTION</small>)) : <small>STRING</small></i></dt>
<dd><p>Given a relation object, return it&rsquo;s name.
</p></dd></dl>

<dl>
<dt><a name="index-relation_003f"></a><u>Function:</u> <b>relation?</b><i> ((objectRef <small>OBJECT</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>objectRef</var> denotes a relation or a class.
</p></dd></dl>

<dl>
<dt><a name="index-remove_002dat-on-QUERY_002dSOLUTION_002dTABLE"></a><u>Method on <small>QUERY-SOLUTION-TABLE</small>:</u> <b>remove-at</b><i> (self (key <small>(LIKE (ANY-KEY SELF))</small>)) :</i></dt>
<dd><p>Remove the solution identified by <var>key</var> from <var>self</var>.
To preserve the solution ordering chain, the solution is marked as deleted
and will be completely removed upon the next iteration through <var>self</var>.
</p></dd></dl>

<dl>
<dt><a name="index-remove_002ddeleted_002dmembers-on-PAGING_002dINDEX"></a><u>Method on <small>PAGING-INDEX</small>:</u> <b>remove-deleted-members</b><i> (self) : <small>(LIKE SELF)</small></i></dt>
<dd><p>Destructively remove all deleted members of <var>self</var>.
</p></dd></dl>

<dl>
<dt><a name="index-reset_002dclash_002dexceptions"></a><u>Function:</u> <b>reset-clash-exceptions</b><i> () :</i></dt>
<dd><p>Resets the collection of clash exceptions
</p></dd></dl>

<dl>
<dt><a name="index-reset_002dquery_002dcaches"></a><u>Function:</u> <b>reset-query-caches</b><i> () :</i></dt>
<dd><p>Zero out all caches managed by the query optimizer,
so that it will reoptimize subgoal queries upon next invocation.
</p></dd></dl>

<dl>
<dt><a name="index-retract_002dfacts_002dof_002dinstance"></a><u>Function:</u> <b>retract-facts-of-instance</b><i> ((self <small>LOGIC-OBJECT</small>)) :</i></dt>
<dd><p>Retract all definite (TRUE or FALSE) propositions attached to <var>self</var>.
</p></dd></dl>

<dl>
<dt><a name="index-retrieve_002dpartial"></a><u>N-Command:</u> <b>retrieve-partial</b><i> (&amp;rest (tree <small>PARSE-TREE</small>)) : <small>QUERY-ITERATOR</small></i></dt>
<dd><p>Partial-match version of <code>retrieve</code> (which see) that generates scored
partial solutions based on the current partial match strategy.  By supplying
<code>BEST</code> instead of <code>ALL</code>, or by adding the option <code>:SORT-BY :SCORE</code>, the generated
solutions will be sorted so that solutions with higher scores come first.
Use the <code>:MATCH-MODE</code> option to override the global default setting established
by <code>set-partial-match-mode</code>, e.g., use <code>:MATCH-MODE :NN</code> to use the neural
net partial match mode.  The <code>:MINIMUM-SCORE</code> option can be used to only
retrieve solutions that have at least the specified minimum match score.
By default, <code>retrieve-partial</code> does not maximize the match scores of its returned
bindings.  To only get maximal scores use <code>:MAXIMIZE-SCORE? TRUE</code> (this is not
yet implemented - you can use <code>ask-partial</code> to maximize scores for individual
solutions by hand).
</p></dd></dl>

<dl>
<dt><a name="index-run_002dforward_002drules-1"></a><u>N-Command:</u> <b>run-forward-rules</b><i> (&amp;rest (options <small>OBJECT</small>)) :</i></dt>
<dd><p>Run forward inference rules in the module defined by the :module option (which
defaults to the current module).  If forward inferencing is already up-to-date
in the designated module, no additional inferencing will occur, unless the :force?
option is specified as TRUE, in which case all forward rules are run or rerun.
For backwards compatibility, this command also supports the old &lt;module&gt; :force
arguments specified with a non-standard keyword notation.
</p>
<p>Calling <code>run-forward-rules</code> temporarily puts the module into a mode where
future assertional (monotonic) updates will trigger additional forward
inference.  Once a non-monotonic update is performed, i.e., a retraction
or clipping of relation value, all cached forward inferences will be discarded
and forward inferencing will be disabled until this function is called again.
</p></dd></dl>

<dl>
<dt><a name="index-run_002dpowerloom_002dtests"></a><u>Command:</u> <b>run-powerloom-tests</b><i> () :</i></dt>
<dd><p>Run the PowerLoom test suite.  Currently this simply runs all demos and
echos commands and their results to standard output.  The output can then
be diffed with previously validated runs to find deviations.
</p></dd></dl>

<dl>
<dt><a name="index-satisfies_003f"></a><u>Function:</u> <b>satisfies?</b><i> ((instanceOrTuple <small>OBJECT</small>) (relationRef <small>OBJECT</small>)) : <small>TRUTH-VALUE</small></i></dt>
<dd><p>Try to prove whether <var>instanceOrTuple</var> satisfies the
definition of the relation <var>relationRef</var> and return the result truth value
of the query.  <var>instanceOrTuple</var> can be a single object, the name or surrogate
of an object, or a collection (a list or vector) of objects.  <var>relationRef</var>
can be a relation, description, surrogate or relation name.
</p></dd></dl>

<dl>
<dt><a name="index-save_002dall_002dneural_002dnetworks"></a><u>Command:</u> <b>save-all-neural-networks</b><i> ((file <small>STRING</small>)) :</i></dt>
<dd><p>Save all neural networks to <var>file</var> (if <var>file</var> is non-NULL).
If networks are saved periodically (see <code>set-save-network-cycle</code>) this file
name will be used to perform periodic saves.
</p></dd></dl>

<dl>
<dt><a name="index-select_002dproof_002dresult"></a><u>Function:</u> <b>select-proof-result</b><i> ((success? <small>BOOLEAN</small>) (continuing? <small>BOOLEAN</small>) (terminal? <small>BOOLEAN</small>)) : <small>KEYWORD</small></i></dt>
<dd><p>Helping function for specialists.   Return the appropriate
keyword indicating success or failure of a proof.
</p></dd></dl>

<dl>
<dt><a name="index-select_002dtest_002dresult"></a><u>Function:</u> <b>select-test-result</b><i> ((success? <small>BOOLEAN</small>) (terminal? <small>BOOLEAN</small>) (frame <small>CONTROL-FRAME</small>)) : <small>KEYWORD</small></i></dt>
<dd><p>Helping function for specialists testing the validity of a
fully bound inference frame.  Based on the test result <var>success?</var>
and <code>reversePolarity?*</code>, set the truth value of <var>frame</var> and return
an appropriate keyword.  The keyword will be either <code>:final-success</code>
<code>:terminal-failure</code> if <var>terminal?</var> is true.  Otherwise it will be
<code>:final-success</code> or <code>:failure</code>.
</p></dd></dl>

<dl>
<dt><a name="index-set_002derror_002dprint_002dcycle"></a><u>Command:</u> <b>set-error-print-cycle</b><i> ((i <small>INTEGER</small>)) :</i></dt>
<dd><p>Set number of cycles between which error rates are saved to
the file established by the last call to <code>save-all-neural-networks</code> appended
with extension <code>.err</code>.  A number &lt;= 0 (or NULL) turns off periodic saving.
</p></dd></dl>

<dl>
<dt><a name="index-set_002dinference_002dlevel"></a><u>N-Command:</u> <b>set-inference-level</b><i> ((level <small>NAME</small>) (module <small>NAME</small>)) : <small>KEYWORD</small></i></dt>
<dd><p>Set the inference level of <var>module</var> to the level specified
by <code>levelKeyword</code>.  If <var>module</var> is NULL, set the level globally.
</p></dd></dl>

<dl>
<dt><a name="index-set_002dmarker-on-MARKER_002dTABLE"></a><u>Method on <small>MARKER-TABLE</small>:</u> <b>set-marker</b><i> (self (object <small>OBJECT</small>)) :</i></dt>
<dd><p>Record membership of <var>object</var> in the marker
storage object <var>self</var>.
</p></dd></dl>

<dl>
<dt><a name="index-set_002dnum_002dneighbors"></a><u>Command:</u> <b>set-num-neighbors</b><i> ((d <small>INTEGER</small>)) :</i></dt>
<dd><p>Sets the number of nearest neighbors to predict from.
</p></dd></dl>

<dl>
<dt><a name="index-set_002dnum_002dtraining_002dper_002dcase"></a><u>Command:</u> <b>set-num-training-per-case</b><i> ((d <small>INTEGER</small>)) :</i></dt>
<dd><p>Sets the number of training examples for each case in the training set.
</p></dd></dl>

<dl>
<dt><a name="index-set_002dpowerloom_002dfeature"></a><u>Function:</u> <b>set-powerloom-feature</b><i> ((feature <small>KEYWORD</small>)) :</i></dt>
<dd><p>Enable the PowerLoom environment feature <var>feature</var>.
</p></dd></dl>

<dl>
<dt><a name="index-set_002dsave_002dnetwork_002dcycle"></a><u>Command:</u> <b>set-save-network-cycle</b><i> ((i <small>INTEGER</small>)) :</i></dt>
<dd><p>Set number of cycles between which networks are saved to the
file established by the last call to <code>save-all-neural-networks</code>.  A number &lt;= 0
or a NULL number turns off periodic saving.
</p></dd></dl>

<dl>
<dt><a name="index-sort-on-QUERY_002dSOLUTION_002dTABLE"></a><u>Method on <small>QUERY-SOLUTION-TABLE</small>:</u> <b>sort</b><i> (self (predicate <small>FUNCTION-CODE</small>)) : <small>(LIKE SELF)</small></i></dt>
<dd><p>Perform a stable, destructive sort of <var>self</var> according to
<var>predicate</var>, and return the result.  If <var>predicate</var> has a <code>&lt;</code> semantics, the
result will be in ascending order.
</p></dd></dl>

<dl>
<dt><a name="index-specializes_003f"></a><u>Function:</u> <b>specializes?</b><i> ((subObject <small>OBJECT</small>) (superObject <small>OBJECT</small>)) : <small>TRUTH-VALUE</small></i></dt>
<dd><p>Try to prove if the description associated with <var>subObject</var>
specializes the description for <var>superObject</var> and return the result truth
value of the query.
</p></dd></dl>

<dl>
<dt><a name="index-start_002dontosaurus"></a><u>Command:</u> <b>start-ontosaurus</b><i> (&amp;rest (options <small>OBJECT</small>)) :</i></dt>
<dd><p>Start the PowerLoom HTTP server at :port (defaults to 9090).  Loads
the required support systems in Lisp and Java if necessary (C++ is not yet supported).
</p></dd></dl>

<dl>
<dt><a name="index-start_002dpowerloom_002dgui"></a><u>Command:</u> <b>start-powerloom-gui</b><i> (&amp;rest (options <small>OBJECT</small>)) :</i></dt>
<dd><p>Start the PowerLoom server at :port (defaults to 9090) and launches
the GUI which will communicate with the server at that port.  If :host is specified,
the GUI will try to communicate with a server at <code>host:port</code> instead of the local
embedded server (note, you can always point the GUI manually to a different server
from its <code>Connect to Server</code> menu item).  Loads the required support systems if necessary.
Embedded calls to the GUI are currently only supported in Java; however, when the GUI is
run in standalone mode, it can communicate with any PowerLoom installation that supports
an HTTP server (currently Lisp and Java).
</p></dd></dl>

<dl>
<dt><a name="index-start_002dpowerloom_002dserver"></a><u>Command:</u> <b>start-powerloom-server</b><i> (&amp;rest (options <small>OBJECT</small>)) :</i></dt>
<dd><p>Start the PowerLoom HTTP server at :port (defaults to 9090).  Loads
the required support systems in Lisp and Java if necessary (C++ is not yet supported).
</p></dd></dl>

<dl>
<dt><a name="index-stop_002dontosaurus"></a><u>Command:</u> <b>stop-ontosaurus</b><i> () :</i></dt>
<dd><p>Stop the PowerLoom HTTP server and free up any bound ports.
This is a no-op if no server is running or the server is not supported.
</p></dd></dl>

<dl>
<dt><a name="index-stop_002dpowerloom_002dgui"></a><u>Command:</u> <b>stop-powerloom-gui</b><i> () :</i></dt>
<dd><p>Closes the PowerLoom GUI application if it is currently visible.
This is a no-op if the GUI is not running or if it is not supported.
</p></dd></dl>

<dl>
<dt><a name="index-stop_002dpowerloom_002dserver"></a><u>Command:</u> <b>stop-powerloom-server</b><i> () :</i></dt>
<dd><p>Stop the PowerLoom HTTP server and free up any bound ports.
This is a no-op if no server is running or the server is not supported.
</p></dd></dl>

<dl>
<dt><a name="index-strengthen_002dtruth_002dvalue"></a><u>Function:</u> <b>strengthen-truth-value</b><i> ((tv1 <small>TRUTH-VALUE</small>) (tv2 <small>TRUTH-VALUE</small>)) : <small>TRUTH-VALUE</small></i></dt>
<dd><p>If <var>tv2</var> has greater strength than <var>tv1</var>, adapt the strength of <var>tv1</var> (not
its value!) and return the result.  Otherwise, return <var>tv1</var> unmodified.
</p></dd></dl>

<dl>
<dt><a name="index-strict_002dtruth_002dvalue_003f"></a><u>Function:</u> <b>strict-truth-value?</b><i> ((self <small>TRUTH-VALUE</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>self</var> is a strict truth value.
</p></dd></dl>

<dl>
<dt><a name="index-stronger_002dtruth_002dvalue_003f"></a><u>Function:</u> <b>stronger-truth-value?</b><i> ((tv1 <small>TRUTH-VALUE</small>) (tv2 <small>TRUTH-VALUE</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Compare the two truth values and return <code>true</code> if <var>tv1</var> is strictly
stronger than <var>tv2</var>.  Stronger uses the following partial order:
  INCONSISTENT &gt; STRICT &gt; DEFAULT &gt; UNKNOWN.
Truth values at the same level are equal in strength.
</p></dd></dl>

<dl>
<dt><a name="index-termify"></a><u>Function:</u> <b>termify</b><i> ((self <small>OBJECT</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Convert <var>self</var> into an equivalent PowerLoom object
that can be passed as an argument wherever an instance is expected.
</p></dd></dl>

<dl>
<dt><a name="index-test_002dclosed_002dslot_003f"></a><u>Function:</u> <b>test-closed-slot?</b><i> ((relation <small>SURROGATE</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>relation</var> (a surrogate) is asserted to 
be closed or if the current module closes all relations.
</p></dd></dl>

<dl>
<dt><a name="index-test_002dfunction_002dslot_003f"></a><u>Function:</u> <b>test-function-slot?</b><i> ((relation <small>SURROGATE</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>relation</var> (a surrogate) is a function.
</p></dd></dl>

<dl>
<dt><a name="index-test_002dmarker_003f-on-MARKER_002dTABLE"></a><u>Method on <small>MARKER-TABLE</small>:</u> <b>test-marker?</b><i> (self (object <small>OBJECT</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>object</var> is stored (marked) in <var>self</var>.
</p></dd></dl>

<dl>
<dt><a name="index-test_002drelation_002don_002darguments_003f"></a><u>Function:</u> <b>test-relation-on-arguments?</b><i> ((relation <small>SURROGATE</small>) (arguments <small>CONS</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>relation</var> (a surrogate) is TRUE when
applied to <var>arguments</var>.
</p></dd></dl>

<dl>
<dt><a name="index-test_002dslot_002dvalue_003f"></a><u>Function:</u> <b>test-slot-value?</b><i> ((self <small>LOGIC-OBJECT</small>) (relation <small>SURROGATE</small>) (filler <small>OBJECT</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if the proposition <code>(&lt;relation&gt; &lt;self&gt; &lt;filler&gt;)</code>
is true.
</p></dd></dl>

<dl>
<dt><a name="index-test_002dspecial_002dmarker_002dtable_003f"></a><u>Function:</u> <b>test-special-marker-table?</b><i> ((self <small>OBJECT</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if the object <var>self</var> is stored (marked)
in the table pointed at by the special variable *specialMarkerTable*.
Designed for use by <code>remove-if</code>.
</p></dd></dl>

<dl>
<dt><a name="index-test_002dsubrelation_003f"></a><u>Function:</u> <b>test-subrelation?</b><i> ((subrelation <small>SURROGATE</small>) (superrelation <small>SURROGATE</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>subrelation</var> specializes <var>superrelation</var>.
</p></dd></dl>

<dl>
<dt><a name="index-test_002dtype_002don_002dinstance_003f"></a><u>Function:</u> <b>test-type-on-instance?</b><i> ((self <small>OBJECT</small>) (type <small>SURROGATE</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>self</var> satisfies <var>type</var>.
</p></dd></dl>

<dl>
<dt><a name="index-translate_002dloom_002dfile"></a><u>Command:</u> <b>translate-loom-file</b><i> ((input <small>FILE-NAME</small>) (output <small>FILE-NAME</small>)) :</i></dt>
<dd><p>Translate the Loom file <var>input</var> to PowerLoom and write the
translation to the file <var>output</var>.  Note that this will only
work for fairly vanilla Loom files that do not contain any
Lisp-isms.  It might require to clean the Loom file manually
before this translation will work.
</p></dd></dl>

<dl>
<dt><a name="index-true_002dtruth_002dvalue_003f"></a><u>Function:</u> <b>true-truth-value?</b><i> ((self <small>TRUTH-VALUE</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>self</var> represents some form of truth.
</p></dd></dl>

<dl>
<dt><a name="index-true_003f"></a><u>Function:</u> <b>true?</b><i> ((self <small>PROPOSITION</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return true if <var>self</var> is true (or default-true if we are
considering default assertions).
</p></dd></dl>

<dl>
<dt><a name="index-unassert"></a><u>N-Command:</u> <b>unassert</b><i> ((proposition <small>PARSE-TREE</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Retract the truth, falsity or inconsistency of <var>proposition</var>.  This is a
more general version of <code>retract</code> that also handles falsity.  For example, if
we assert the proposition &quot;(not (sad Fred))&quot;, and then execute the statement
&quot;(unassert (sad Fred))&quot;, the truth value of the proposition &quot;(sad Fred)&quot;
will be set to UNKNOWN.  If we had called <code>retract</code> in place of <code>unassert</code>,
the proposition &quot;(sad Fred)&quot; would remain set to FALSE.   Note that for this
unassertion to succeed, the logic constant <code>Fred</code> and the relation <code>sad</code> must
already be defined.
</p></dd></dl>

<dl>
<dt><a name="index-unassert_002dproposition"></a><u>Function:</u> <b>unassert-proposition</b><i> ((self <small>PROPOSITION</small>)) :</i></dt>
<dd><p>Retract the truth, falsity or inconsistency of the proposition <var>self</var>.
</p></dd></dl>

<dl>
<dt><a name="index-unknown_002dtruth_002dvalue_003f"></a><u>Function:</u> <b>unknown-truth-value?</b><i> ((self <small>TRUTH-VALUE</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if <var>self</var> represents UNKNOWN.
</p></dd></dl>

<dl>
<dt><a name="index-unknown_003f"></a><u>Function:</u> <b>unknown?</b><i> ((self <small>PROPOSITION</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return true if the truth of <var>self</var> is unknown.
</p></dd></dl>

<dl>
<dt><a name="index-unset_002dpowerloom_002dfeature"></a><u>Function:</u> <b>unset-powerloom-feature</b><i> ((feature <small>KEYWORD</small>)) :</i></dt>
<dd><p>Disable the PowerLoom environment feature <var>feature</var>.
</p></dd></dl>

<dl>
<dt><a name="index-upclassify_002dall_002ddescriptions"></a><u>Function:</u> <b>upclassify-all-descriptions</b><i> () :</i></dt>
<dd><p>Classify all named descriptions.
</p></dd></dl>

<dl>
<dt><a name="index-upclassify_002dall_002dinstances"></a><u>Function:</u> <b>upclassify-all-instances</b><i> () :</i></dt>
<dd><p>Classify all named instances.
</p></dd></dl>

<dl>
<dt><a name="index-upclassify_002dinstances"></a><u>Function:</u> <b>upclassify-instances</b><i> ((module <small>MODULE</small>) (local? <small>BOOLEAN</small>)) :</i></dt>
<dd><p>Classify instances local to <var>module</var> and inherited
by <var>module</var>.  If <var>local?</var>, don&rsquo;t classify inherited descriptions.  If
<var>module</var> is NULL, classify descriptions in all modules.
</p></dd></dl>

<dl>
<dt><a name="index-upclassify_002dnamed_002ddescriptions"></a><u>Function:</u> <b>upclassify-named-descriptions</b><i> ((module <small>MODULE</small>) (local? <small>BOOLEAN</small>)) :</i></dt>
<dd><p>Classify named descriptions local to <var>module</var> and inherited
by <var>module</var>.  If <var>local?</var>, don&rsquo;t classify inherited descriptions.  If
<var>module</var> is NULL, classify descriptions in all modules.
</p></dd></dl>

<dl>
<dt><a name="index-update_002dproposition_002din_002dstore-on-OBJECT_002dSTORE"></a><u>Method on <small>OBJECT-STORE</small>:</u> <b>update-proposition-in-store</b><i> (store (proposition <small>PROPOSITION</small>) (update-mode <small>KEYWORD</small>)) :</i></dt>
<dd><p>A module with <var>store</var> has had the truth value of <var>proposition</var>
change according to <var>update-mode</var>.  The default method does nothing.
</p></dd></dl>

<dl>
<dt><a name="index-update_002dtuple"></a><u>Function:</u> <b>update-tuple</b><i> ((relation <small>SURROGATE</small>) (arguments <small>(CONS OF OBJECT)</small>) (updatemode <small>KEYWORD</small>)) : <small>PROPOSITION</small></i></dt>
<dd><p>Assert or retract a proposition that applies <var>relation</var> to <var>arguments</var>.
</p></dd></dl>

<dl>
<dt><a name="index-weaken_002dtruth_002dvalue"></a><u>Function:</u> <b>weaken-truth-value</b><i> ((tv1 <small>TRUTH-VALUE</small>) (tv2 <small>TRUTH-VALUE</small>)) : <small>TRUTH-VALUE</small></i></dt>
<dd><p>If <var>tv2</var> has lesser strength than <var>tv1</var>, adapt the strength of <var>tv1</var> (not
its value!) and return the result.  Otherwise, return <var>tv1</var> unmodified.
</p></dd></dl>

<dl>
<dt><a name="index-with_002dlogic_002denvironment"></a><u>Macro:</u> <b>with-logic-environment</b><i> ((moduleForm <small>OBJECT</small>) (environment <small>OBJECT</small>) &amp;body (body <small>CONS</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Execute <var>body</var> within the module resulting from <var>moduleForm</var>.
<code>*module*</code> is an acceptable <var>moduleForm</var>.  It will locally rebind 
<code>*module*</code> and <code>*context*</code> and shield the outer bindings from changes.
</p></dd></dl>

<dl>
<dt><a name="index-within_002dclassification_002dsession"></a><u>Macro:</u> <b>within-classification-session</b><i> ((descriptionorinstance <small>KEYWORD</small>) &amp;body (body <small>CONS</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Used during classification.  Execute <var>body</var> within the indicated
classification session and inference world.
</p></dd></dl>

<dl>
<dt><a name="index-within_002dmeta_002dcache"></a><u>Macro:</u> <b>within-meta-cache</b><i> (&amp;body (body <small>CONS</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Execute <var>body</var> within the meta cache of the current module.
Set appropriate special variables.
</p></dd></dl>


<dl>
<dt><a name="index-create_002dkeyword"></a><u>Function:</u> <b>create-keyword</b><i> ((name <small>STRING</small>)) : <small>KEYWORD</small></i></dt>
<dd><p>Returns the Stella keyword <var>name</var>, creating it if
necessary.  <var>name</var> is treated case-sensitively.  This should
generally not be necessary to do.
</p></dd></dl>

<dl>
<dt><a name="index-create_002dsymbol"></a><u>Function:</u> <b>create-symbol</b><i> ((name <small>STRING</small>) (module <small>MODULE</small>) (environment <small>ENVIRONMENT</small>)) : <small>SYMBOL</small></i></dt>
<dd><p>Returns the Stella symbol <var>name</var> visible in <var>module</var>,
creating it if necessary.  <var>name</var> is ALWAYS treated case-sensitively,
even if <var>module</var> is case insensitive. This should generally not be
necessary to do.
</p></dd></dl>

<dl>
<dt><a name="index-get_002dinconsistent_002dpropositions"></a><u>Function:</u> <b>get-inconsistent-propositions</b><i> ((module <small>MODULE</small>) (environment <small>ENVIRONMENT</small>)) : <small>(PL-ITERATOR OF PROPOSITION)</small></i></dt>
<dd><p>Return inconsistent propositions visible in <var>module</var>.
</p></dd></dl>

<dl>
<dt><a name="index-get_002dkeyword"></a><u>Function:</u> <b>get-keyword</b><i> ((name <small>STRING</small>)) : <small>KEYWORD</small></i></dt>
<dd><p>Returns the Stella KEYWORD <var>name</var> if it exists.  Case sensitive.
</p></dd></dl>

<dl>
<dt><a name="index-get_002dname_002din_002dmodule"></a><u>Function:</u> <b>get-name-in-module</b><i> ((obj <small>OBJECT</small>) (module <small>MODULE</small>) (environment <small>ENVIRONMENT</small>)) : <small>STRING</small></i></dt>
<dd><p>Return the name, qualified as necessary, so that <var>obj</var> can be found from
<var>module</var>.  If there is no name for the object return <code>null</code>.
</p></dd></dl>

<dl>
<dt><a name="index-get_002dshort_002dname"></a><u>Function:</u> <b>get-short-name</b><i> ((obj <small>OBJECT</small>)) : <small>STRING</small></i></dt>
<dd><p>Return the short name of <var>obj</var>, if it has one.  Otherwise return <code>null</code>.
</p></dd></dl>

<dl>
<dt><a name="index-get_002dsymbol"></a><u>Function:</u> <b>get-symbol</b><i> ((name <small>STRING</small>) (module <small>MODULE</small>) (environment <small>ENVIRONMENT</small>)) : <small>SYMBOL</small></i></dt>
<dd><p>Returns the Stella SYMBOL <var>name</var> visible in <var>module</var> if it
exists.  <var>name</var> is ALWAYS treated case sensitively.
</p></dd></dl>

<dl>
<dt><a name="index-is_002dknown"></a><u>Function:</u> <b>is-known</b><i> ((tv <small>TRUTH-VALUE</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Tests whether <var>tv</var> is a known truth value (i.e., true or false).
</p></dd></dl>

<dl>
<dt><a name="index-is_002dtrue_002dproposition1"></a><u>Function:</u> <b>is-true-proposition1</b><i> ((relation-and-arguments <small>OBJECT</small>) (module <small>MODULE</small>) (environment <small>ENVIRONMENT</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Return TRUE if a proposition (<code>relation</code> <code>args</code>) has
been asserted (or inferred by forward chaining).
</p></dd></dl>

<dl>
<dt><a name="index-load_002din_002dmodule"></a><u>Function:</u> <b>load-in-module</b><i> ((filename <small>STRING</small>) (module <small>MODULE</small>) (environment <small>ENVIRONMENT</small>)) :</i></dt>
<dd><p>Read logic commands from the file named <var>filename</var> and evaluate them.
If the file does not have an <code>in-module</code> declaration that specifies the module
within which all remaining commands are to be evaluated, it will be loaded
in the <var>module</var> specified.  If no <var>module</var> is specified and the file does
not contain an <code>in-module</code> declaration, an error will be signaled.
The remaining commands are evaluated one-by-one, applying the function
<code>evaluate</code> to each of them.
</p></dd></dl>

<dl>
<dt><a name="index-load_002dnative_002dstream_002din_002dmodule"></a><u>Function:</u> <b>load-native-stream-in-module</b><i> ((stream <small>NATIVE-INPUT-STREAM</small>) (module <small>MODULE</small>) (environment <small>ENVIRONMENT</small>)) :</i></dt>
<dd><p>Read logic commands from the native input stream <var>stream</var> and evaluate them.
Assumes <var>stream</var> is a line-buffered stream which is a safe compromise but does
not generate the best efficiency for block-buffered streams such as files.
If the stream does not supply an <code>in-module</code> declaration that specifies the
module within which all remaining commands are to be evaluated, it will be
loaded in the <var>module</var> specified.  If no <var>module</var> is specified and the file 
does not supply an <code>in-module</code> declaration, an error will be signaled.
The remaining commands are evaluated one-by-one, applying the function
<code>evaluate</code> to each of them.
</p></dd></dl>

<dl>
<dt><a name="index-load_002dstream_002din_002dmodule-1"></a><u>Function:</u> <b>load-stream-in-module</b><i> ((stream <small>INPUT-STREAM</small>) (module <small>MODULE</small>) (environment <small>ENVIRONMENT</small>)) :</i></dt>
<dd><p>Read logic commands from the STELLA stream <var>stream</var> and evaluate them.
If the stream does not supply an <code>in-module</code> declaration that specifies the
module within which all remaining commands are to be evaluated, it will be
loaded in the <var>module</var> specified.  If no <var>module</var> is specified and the file 
does not supply an <code>in-module</code> declaration, an error will be signaled.
The remaining commands are evaluated one-by-one, applying the function
<code>evaluate</code> to each of them.
</p></dd></dl>

<dl>
<dt><a name="index-main"></a><u>Function:</u> <b>main</b><i> () :</i></dt>
<dd><p>Main PowerLoom entry point for your code in C++ and Java.
</p></dd></dl>

<dl>
<dt><a name="index-register_002dcomputation_002dfunction-1"></a><u>Function:</u> <b>register-computation-function</b><i> ((name <small>STRING</small>) (function-reference <small>FUNCTION-CODE</small>) (arity <small>INTEGER</small>) (module <small>MODULE</small>) (environment <small>ENVIRONMENT</small>)) :</i></dt>
<dd><p>Register <var>name</var> as a function name in <var>module</var> which will invoke the
native code procedure described by <code>function-reference.</code>  The <var>name</var>
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The function must conform
to the signature for computation functions used by the computation
specialist.  Arity specifies the number of arguments the computation
accepts.
</p>
<p>The exact form of <var>function-reference</var> depends on the underlying
programming language.  The following type mappings are used:
          C++:  cpp_function_code (a pointer to the function code)
  Common Lisp:  FUNCTION   (result of #&rsquo; or (FUNCTION ...))
         Java:  java.lang.reflect.Method
</p></dd></dl>

<dl>
<dt><a name="index-register_002dspecialist_002dfunction-1"></a><u>Function:</u> <b>register-specialist-function</b><i> ((name <small>STRING</small>) (function-reference <small>FUNCTION-CODE</small>) (module <small>MODULE</small>) (environment <small>ENVIRONMENT</small>)) :</i></dt>
<dd><p>Register <var>name</var> as a function name in <var>module</var> which will invoke the
native code procedure described by <code>function-reference.</code>  The <var>name</var>
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The function must conform
to the signature for specialist functions.
</p>
<p>The exact form of <var>function-reference</var> depends on the underlying
programming language.  The following type mappings are used:
          C++:  
  Common Lisp:  FUNCTION   (result of #&rsquo; or (FUNCTION ...))
         Java:  java.lang.reflect.Method
</p></dd></dl>

<dl>
<dt><a name="index-s_002dregister_002dcomputation_002dfunction"></a><u>Function:</u> <b>s-register-computation-function</b><i> ((name <small>STRING</small>) (native-name <small>STRING</small>) (arity <small>INTEGER</small>) (module-name <small>STRING</small>) (environment <small>ENVIRONMENT</small>)) :</i></dt>
<dd><p>Register <var>name</var> as a function name in the module named <var>module-name</var>.
This function will the native code named <var>native-name</var>.  The <var>name</var>
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The <var>native-name</var> will be
processed in a manner that depends on the underlying programming
language.  The following type mappings are used:
          C++:  Not available.  Error signaled.
  Common Lisp:  The native-name is read by READ-FROM-STRING and then
                the SYMBOL-FUNCTION is taken.
         Java:  A fully package-qualified name is required.  It is
                looked up using the Reflection tools.
The function found must conform to the signature for computation functions.
Arity specifies the number of arguments the computation accepts.
</p></dd></dl>

<dl>
<dt><a name="index-s_002dregister_002dspecialist_002dfunction"></a><u>Function:</u> <b>s-register-specialist-function</b><i> ((name <small>STRING</small>) (native-name <small>STRING</small>) (module-name <small>STRING</small>) (environment <small>ENVIRONMENT</small>)) :</i></dt>
<dd><p>Register <var>name</var> as a function name in the module named <var>module-name</var>.
This function will the native code named <var>native-name</var>.  The <var>name</var>
is a fully-qualified name which will be interpreted by the normal
rules for reading names in PowerLoom.  The <var>native-name</var> will be
processed in a manner that depends on the underlying programming
language.  The following type mappings are used:
          C++:  Not available.  Error signaled.
  Common Lisp:  The native-name is read by READ-FROM-STRING and then
                the SYMBOL-FUNCTION is taken.
         Java:  A fully package-qualified name is required.  It is
                looked up using the Reflection tools.
The function found must conform to the signature for specialist functions.
</p></dd></dl>

<dl>
<dt><a name="index-test_002denvironment_002dlevel_003f"></a><u>Function:</u> <b>test-environment-level?</b><i> ((env <small>ENVIRONMENT</small>) (level <small>STRING</small>)) : <small>BOOLEAN</small></i></dt>
<dd><p>Test if <var>env</var> has level set to <var>level</var>
</p></dd></dl>

<dl>
<dt><a name="index-consify-on-PL_002dITERATOR"></a><u>Method on <small>PL-ITERATOR</small>:</u> <b>consify</b><i> (self) : <small>CONS</small></i></dt>
<dd><p>Convert <var>self</var> into a Stella CONS.
</p></dd></dl>

<dl>
<dt><a name="index-listify-on-PL_002dITERATOR"></a><u>Method on <small>PL-ITERATOR</small>:</u> <b>listify</b><i> (self) : <small>LIST</small></i></dt>
<dd><p>Convert <var>self</var> into a Stella LIST.
</p></dd></dl>


<dl>
<dt><a name="index-initialize_002dkernel_002dkb"></a><u>Command:</u> <b>initialize-kernel-kb</b><i> () :</i></dt>
<dd><p>Bootstrap the PowerLoom built-in kernel KB.
</p></dd></dl>




<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="manual_10.html#Installation" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="manual_12.html#Glossary" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="manual.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="manual_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="manual_14.html#Function-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="manual_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Hans Chalupsky</em> on <em>April 15, 2011</em> using <a href="http://www.nongnu.org/texi2html/"><em>texi2html 1.82</em></a>.
 </font>
 <br>

</p>
</body>
</html>
