This is manual.info, produced by makeinfo version 4.13 from manual.texi.

This file documents the knowledge representation and reasoning system.

   Copyright (C) 2010 University of Southern California, Information
Sciences Institute, 4676 Admiralty Way, Marina Del Rey, CA 90292, USA

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   PowerLoom is a registered trademark of the University of Southern
California.


File: manual.info,  Node: Miscellaneous,  Next: Glossary,  Prev: Installation,  Up: Top

11 Miscellaneous
****************

This is a catch-all section for documented functions, methods and
relations that haven't been categorized yet into any of the previous
sections.  They are in random order and many of them will never be part
of the official PowerLoom interface.  So beware!

 -- Method on 2_D_ARRAY: 2_d_element (array (row INTEGER)
          (column INTEGER)) : (LIKE (ANY-VALUE SELF))
     Return the element of ARRAY at position [ROW, COLUMN].

 -- Method on 2_D_FLOAT-ARRAY: 2_d_element (array (row INTEGER)
          (column INTEGER)) : FLOAT
     Return the element of ARRAY at position [ROW, COLUMN].

 -- Method on 2_D_ARRAY: 2_d_element-setter (array (value OBJECT)
          (row INTEGER) (column INTEGER)) : (LIKE (ANY-VALUE SELF))
     Set the element of ARRAY at position [ROW, COLUMN] to VALUE and
     return the result.

 -- Method on 2_D_FLOAT-ARRAY: 2_d_element-setter (array (value FLOAT)
          (row INTEGER) (column INTEGER)) : (LIKE (ANY-VALUE SELF))
     Set the element of ARRAY at position [ROW, COLUMN] to VALUE and
     return the result.

 -- N-Command: add-testing-example ((form CONS)
          (score PARTIAL-MATCH-SCORE)) :
     Add a query and score pair to the master list of   testing examples

 -- N-Command: add-training-example ((form CONS)
          (score PARTIAL-MATCH-SCORE)) :
     Add a query and score pair to the master list of   training
     examples

 -- Function: all-asserted-types ((self OBJECT)) : (CONS OF
          NAMED-DESCRIPTION)
     Return a set of all of the types that are asserted to be satisfied
     by SELF.

 -- Function: all-class-instances ((type SURROGATE)) : CONS
     Return a set of instances that belong to the class TYPE.

 -- Function: all-cycles ((module MODULE) (local? BOOLEAN)) : (CONS OF
          CONS)
     Return a list of lists of descriptions that are provably
     co-extensional.

 -- Function: all-direct-subrelations ((relation NAMED-DESCRIPTION)
          (removeEquivalents? BOOLEAN)) : (CONS OF NAMED-DESCRIPTION)
     Return a set of relations that immediately specialize RELATION.
     If REMOVEEQUIVALENTS? (recommended), don't include any relations
     equivalent to RELATION.

 -- Function: all-direct-superrelations ((relation NAMED-DESCRIPTION)
          (removeEquivalents? BOOLEAN)) : (CONS OF NAMED-DESCRIPTION)
     Return a set of relations that immediately subsume RELATION.  If
     REMOVEEQUIVALENTS? (recommended), don't include any relations
     equivalent to RELATION.

 -- Function: all-direct-types ((self OBJECT)) : (CONS OF LOGIC-OBJECT)
     Return a set of most specific types that are satisfied by SELF.

 -- Function: all-equivalent-relations ((relation NAMED-DESCRIPTION)
          (reflexive? BOOLEAN)) : (CONS OF NAMED-DESCRIPTION)
     Return a list of all relations equivalent to RELATION.  If
     REFLEXIVE?, include RELATION in the list.

 -- Function: all-facts-of-instance ((self OBJECT)
          (includeunknownfacts? BOOLEAN) (elaborate? BOOLEAN)) : (LIST
          OF PROPOSITION)
     Return a list of all definite (TRUE or FALSE) propositions
     attached to SELF.

 -- N-Command: all-facts-of-n ((n INTEGER) &rest (instanceRefs NAME)) :
          (CONS OF PROPOSITION)
     This is a generalization of `all-facts-of' (which see).  With N = 0
     and only one instance this command behaves just like
     `all-facts-of'.  Otherwise, returns a cons list of all definite
     (TRUE or FALSE) propositions that reference any of the instances
     listed in INSTANCEREFS, plus if N >= 1 all propositions that
     reference any instances that are arguments of propositions
     collected in the previous step, plus if N >= 2... and so on.  That
     is, if we only consider binary propositions, this can be viewed as
     growing a graph with instances as its nodes and predicates as its
     arcs starting from the set of seed INSTANCEREFS to depth N-1.
     Caution: with a fully connected KB and large enough N this could
     return the whole knowledge base.

     The returned propositions include those asserted to be true or
     false by default, but it does not include propositions that are
     found to be true only by running the query engine.  Facts inferred
     to be true by the forward chainer will be included.  Hence, the
     returned list of facts may be longer in a context where the
     forward chainer has been run then in one where it has not (see
     `run-forward-rules').

 -- Function: all-inconsistent-propositions ((module MODULE)
          (local? BOOLEAN)) : (ITERATOR OF PROPOSITION)
     Iterate over all conceived propositions visible from MODULE that
     have an inconsistent truth value.  If LOCAL?, only return
     inconsistent propositions conceived locally in MODULE.

 -- Function: all-instances ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF LOGIC-OBJECT)
     Iterate over all instances (or individuals) visible from MODULE.
     Only instances that haven't been deleted will be considered.  If
     LOCAL?, only return instances created locally in MODULE.

 -- Function: all-named-descriptions ((module MODULE) (local? BOOLEAN))
          : (ITERATOR OF NAMED-DESCRIPTION)
     Iterate over all named descriptions visible from MODULE.  If
     LOCAL?, return only named descriptions interned in MODULE.  If
     MODULE is null, return all named descriptions interned everywhere.

 -- Function: all-named-instances ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF LOGIC-OBJECT)
     Iterate over all named instances (or individuals) visible from
     MODULE.  Only instances that haven't been deleted will be
     considered.  If LOCAL?, only return instances created locally in
     MODULE.

 -- Function: all-named-terms ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF OBJECT)
     Iterate over all named terms visible from MODULE.  A term can be an
     instance (or individual) as well as a description.  Only terms that
     haven't been deleted will be considered.  If LOCAL?, only return
     terms created locally in MODULE.

 -- Function: all-propositions ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF PROPOSITION)
     Iterate over all conceived propositions visible from MODULE.  Only
     propositions that haven't been deleted will be considered.  If
     LOCAL?, only return propositions conceived locally in MODULE.

 -- Function: all-relation-values ((relation SURROGATE)
          (nMinusOneArguments CONS)) : CONS
     Return a set of values that satisfy the relation RELATION (a
     surrogate) applied to NMINUSONEARGUMENTS plus that last value.

 -- Command: all-sentences-of ((instanceRef OBJECT)) : (CONS OF
          STRING-WRAPPER)
     Return a list of sentences describing facts about INSTANCEREF.

 -- Function: all-slot-value-types ((self LOGIC-OBJECT)
          (relation SURROGATE)) : (CONS OF NAMED-DESCRIPTION)
     Return a set of the most specific types for fillers of the slot
     RELATION applied to SELF.

 -- Function: all-slot-values ((self LOGIC-OBJECT)
          (relation SURROGATE)) : CONS
     Return a set of values for the slot RELATION (a surrogate) applied
     to SELF (an object).

 -- Function: all-subrelations ((relation NAMED-DESCRIPTION)
          (removeequivalents? BOOLEAN)) : (CONS OF NAMED-DESCRIPTION)
     Return a set of all (named) relations that specialize relation.

 -- Function: all-superrelations ((relation NAMED-DESCRIPTION)
          (removeequivalents? BOOLEAN)) : (CONS OF NAMED-DESCRIPTION)
     Return a set of all relations that subsume relation.

 -- Function: all-taxonomic-types ((self OBJECT)) : (CONS OF
          NAMED-DESCRIPTION)
     Return a set of all of the types that are satisfied by SELF, using
     only assertions and upward taxonomic reasoning.

 -- Function: all-terms ((module MODULE) (local? BOOLEAN)) : (ITERATOR
          OF OBJECT)
     Return a list of all terms visible from MODULE.  A term can be an
     instance (or individual) as well as a description.  Only terms that
     haven't been deleted will be considered.  If LOCAL?, only return
     terms created locally in MODULE.

 -- Function: all-types ((self OBJECT)) : (CONS OF NAMED-DESCRIPTION)
     Return a set of all of the types that are satisfied by SELF.

 -- Function: all-unnamed-terms ((module MODULE) (local? BOOLEAN)) :
          ITERATOR
     Iterate over all unnamed terms visible from MODULE.  A term can be
     an instance (or individual) as well as a description.  Only terms
     that haven't been deleted will be considered.  If LOCAL?, only
     return terms created locally in MODULE.

 -- Function: allocate-supported-closure-iterator ((startnode CONS)
          (allocateadjacencyiterator FUNCTION-CODE)
          (filterfunction FUNCTION-CODE)) : SUPPORTED-CLOSURE-ITERATOR
     Similar to `allocate-transitive-closure-iterator' (which see), but
     return a SUPPORTED-CLOSURE-ITERATOR instead.

 -- Function: allocate-transitive-closure-iterator ((startNode OBJECT)
          (allocateAdjacencyIterator FUNCTION-CODE)
          (filterFunction FUNCTION-CODE)) : ITERATOR
     Return an iterator that generates the transitive closure of
     applying iterators generated by ALLOCATEADJACENCYITERATOR to
     STARTNODE.  If FILTERFUNCTION is non-null, that function is applied
     as a filter to each node generated (nodes filtered out still
     generate descendants, but they don't get returned).

 -- Macro: apply-ask (&body (body CONS)) : OBJECT
     Execute a yes/no query composed of input-variables
     `inputVariables' and body `queryBody'.  Before executing, bind
     variables to `inputBindings' (in sequence).    `(apply-ask
     inputVariables queryBody inputBindings)'

 -- Function: apply-kappa? ((description DESCRIPTION) (vector VECTOR))
          : BOOLEAN
     Apply (inherit) the description DESCRIPTION to members of the
     vector VECTOR.  Return TRUE if no clash was detected.  Constraint
     propagation happens only if it is enabled prior to calling
     `apply-kappa?'.

 -- Macro: apply-retrieve (&body (body CONS)) : OBJECT
     Execute a query composed of io-variables `variables' and body
     `queryBody'.  Before executing, bind variables to `inputBindings'
     (in sequence). If one variable is left unbound, returns a cons
     list of bindings of that variable.  If two or more are unbound,
     returns a cons list of cons lists of bindings.  Setting the option
     :singletons?  to FALSE always returns a list of lists.  Example
     call:   `(apply-retrieve variables queryBody inputBindings)'

 -- N-Command: ask-partial (&rest (proposition&options PARSE-TREE)) :
          FLOAT
     Similar to `ask' (which see), but return the highest partial match
     score for the supplied proposition instead of a truth value.  If
     the option :MAXIMIZE-SCORE? is set to FALSE, return after the
     first partial match score has been generated.

 -- Function: bottom? ((self OBJECT)) : BOOLEAN
     Return TRUE if SELF is the undefined individual BOTTOM.

 -- Command: call-all-facts-of ((instanceRef OBJECT)) : (LIST OF
          PROPOSITION)
     Return a list of all definite (TRUE or FALSE) propositions that
     reference the instance INSTANCEREF.

 -- Function: call-ask ((query OBJECT)) : TRUTH-VALUE
     Callable version of `ask' (which see).  Accepts queries specified
     by a query iterator, or specified as a CONS-list of arguments as
     they would be supplied to `ask'.  Raises LOGIC-EXCEPTIONs in case
     of illegal queries and logical expressions.

 -- Function: call-defconcept ((arguments CONS)) : NAMED-DESCRIPTION
     Callable version of the `defconcept' command (which see).  Expects
     the same arguments as `defconcept' but supplied as a list.

 -- Function: call-deffunction ((arguments CONS)) : NAMED-DESCRIPTION
     Callable version of the `deffunction' command (which see).
     Expects the same arguments as `deffunction' but supplied as a list.

 -- Function: call-defobject ((arguments CONS)) : LOGIC-OBJECT
     Callable version of the `defobject' command (which see).  Expects
     the same arguments as `defobject' but supplied as a list.

 -- Function: call-defproposition ((arguments CONS)) : PROPOSITION
     Callable version of the `defproposition' command (which see).
     Expects the same arguments as `defproposition' but supplied as a
     list.

 -- Function: call-defrelation ((arguments CONS)) : NAMED-DESCRIPTION
     Callable version of the `defrelation' command (which see).
     Expects the same arguments as `defrelation' but supplied as a list.

 -- Function: call-list-undefined-relations ((module MODULE)
          (local? BOOLEAN)) : CONS
     Callable version of `list-undefined-relations' (which see).

 -- Function: call-propagate-constraints ((context CONTEXT)) :
     Trigger constraint propagation over all propositions in the module
     or world CONTEXT.

 -- Function: call-retrieve ((query OBJECT)) : QUERY-ITERATOR
     Callable version of `retrieve' (which see).  Accepts queries
     specified by a query iterator, or specified as a CONS-list of
     arguments as they would be supplied to `retrieve'.  Raises
     LOGIC-EXCEPTIONs in case of illegal queries and logical
     expressions.

 -- Function: call-retrieve-partial ((query OBJECT)) : QUERY-ITERATOR
     Callable version of `retrieve-partial' (which see).  Accepts
     queries specified by a query iterator, or specified as a CONS-list
     of arguments as they would be supplied to `retrieve-partial'.
     Raises LOGIC-EXCEPTIONs in case of illegal queries and logical
     expressions.

 -- Function: call-run-forward-rules ((module MODULE) (force? BOOLEAN))
          :
     Run forward inference rules in module MODULE. If MODULE is NULL,
     the current module will be used.  If forward inferencing is already
     up-to-date in the designated module, no additional inferencing
     will occur, unless FORCE? is set to TRUE, in which case all
     forward rules are run or rerun.

 -- Function: call-set-inference-level ((levelKeyword KEYWORD)
          (module MODULE)) : KEYWORD
     Set the inference level of MODULE to the level specified by
     LEVELKEYWORD.  If MODULE is NULL and we are inside a query, set the
     level of the current query iterator.  Otherwise, set the level
     globally.

 -- Function: class? ((objectRef OBJECT)) : BOOLEAN
     Return TRUE if OBJECTREF denotes a class.

 -- Function: coerce-to-instance ((self OBJECT) (original OBJECT)) :
          LOGIC-OBJECT
     Return the logic instance referred to by SELF.

 -- Function: coerce-to-instance-or-literal ((self OBJECT)
          (original OBJECT)) : OBJECT
     Return the logic instance referred to by SELF, or SELF if it is a
     literal (e.g., string or number) that can't be coerced.

 -- Function: coerce-to-vector ((self OBJECT)) : VECTOR
     Return a vector containing the elements in SELF.  Coerce each
     element of SELF to be a logic object or literal.

 -- Function: collection? ((objectRef OBJECT)) : BOOLEAN
     Return TRUE if OBJECTREF denotes a relation or a class.

 -- Command: conceive-term ((tree OBJECT)) : OBJECT
     TREE is a term expression (a string or an s-expression), or is a
     class reference (a symbol or surrogate).  Return a (possibly
     newly-conceived) term representing the internalized representation
     of that term.

 -- Function: conjoin-truth-values ((tv1 TRUTH-VALUE)
          (tv2 TRUTH-VALUE)) : TRUTH-VALUE
     Return the logical conjunction of truth values TV1 and TV2.

 -- Method on JUSTIFICATION: consify (self) : CONS
     Return a CONS tree representation of the proof SELF.  Each proof
     step is represented as a CONS tree of the form   (<proposition>
     (<key> <value>...) <antecedent>...)  where each <antecedent> is a
     CONS tree representing a subproof.  The consification follows the
     original proof structure literally, i.e., no uninteresting nodes
     such as patterns or AND-introductions are suppressed.

 -- Method on QUERY-ITERATOR: consify (self) : CONS
     Generate all solutions for the query self, and collect them into a
     cons list of result tuples.  If `:SINGLETONS? TRUE', collect a
     list of atoms rather than a list of lists for tuples of arity=1.

 -- Method on QUERY-SOLUTION-TABLE: consify (self) : CONS
     Collect all solutions of SELF into a cons list and return the
     result.

 -- Method on QUERY-ITERATOR: consify-current-solutions (self) : CONS
     Collect the current solutions of SELF into a cons list of result
     tuples.  If `:SINGLETONS? TRUE', collect a list of atoms rather
     than a list of lists for tuples of arity=1.

 -- Function: consify-justification ((self JUSTIFICATION)
          (style KEYWORD)) : CONS
     Return a CONS tree representation of the proof SELF.  Each proof
     step is represented as a CONS tree of the form   (<proposition>
     (<key> <value>...) <antecedent>...)  where each <antecedent> is a
     CONS tree representing a subproof.  STYLE indicates what nodes in
     the proof tree should be suppressed.  :RAW preserves the original
     structure literally, :VERBOSE keeps AND- introductions but
     suppresses all auxiliary (non-logical) nodes such as pattern
     nodes, and :BRIEF additionally suppresses AND-introduction nodes.

 -- Function: constant? ((objectRef OBJECT)) : BOOLEAN
     Return TRUE if OBJECTREF denotes a literal or scalar.

 -- Method on JUSTIFICATION: copy (self) : (LIKE SELF)
     Return a copy of the proof starting at SELF.  Allocates all new
     justification objects, but structure-shares other information such
     as propositions and substitutions.

 -- N-Command: create ((name GENERALIZED-SYMBOL)
          &rest (type GENERALIZED-SYMBOL)) : OBJECT
     Create a logic object with name NAME and return it.  If TYPE is
     also supplied, assert that the object belongs to that type.

 -- Function: create-2_d_array ((nof-rows INTEGER)
          (nof-columns INTEGER) &rest (values OBJECT)) : 2_D_ARRAY
     Create a two-dimensional array with NOF-ROWS rows and NOF-COLUMNS
     columns, and initialize it in row-major-order from VALUES.
     Missing values will be padded with NULL, extraneous values will be
     ignored.

 -- Function: create-2_d_float-array ((nof-rows INTEGER)
          (nof-columns INTEGER) &rest (values FLOAT)) : 2_D_FLOAT-ARRAY
     Create a two-dimensional array with NOF-ROWS rows and NOF-COLUMNS
     columns, and initialize it in row-major-order from VALUES.
     Missing values will be padded with NULL, extraneous values will be
     ignored.

 -- Function: create-float-vector (&rest (values FLOAT)) : FLOAT-VECTOR
     Return a vector containing VALUES, in order.

 -- Function: create-marker-storage ((supportRecall? BOOLEAN)) :
          MARKER-TABLE
     Return a new marker storage object, used to remember with objects
     have been `marked'.  If SUPPORTRECALL?  is set, then the iterator
     `recall-marked-objects' can be invoked on the new marker storage
     object.

 -- Function: create-vector (&rest (values OBJECT)) : VECTOR
     Return a vector containing VALUES, in order.

 -- Command: current-inference-level () : NORMAL-INFERENCE-LEVEL
     Return the current inference level that is active in the current
     query, the current module, or, otherwise, globally.

 -- Function: default-false? ((self PROPOSITION)) : BOOLEAN
     Return true if SELF is default false.

 -- Function: default-true? ((self PROPOSITION)) : BOOLEAN
     Return true if SELF is default true.

 -- Function: default-truth-value? ((self TRUTH-VALUE)) : BOOLEAN
     Return TRUE if SELF is a default truth value.

 -- Macro: define-arithmetic-operation-on-wrappers ((name SYMBOL)
          (operation-name SYMBOL)) : OBJECT
     Defines NAME as an arithmetic comparision operation using the test
     `test-name'.  It will take two wrapped number parameters and
     return a wrapped number.  The code will use the appropriate test
     for the specific subtype of wrapped number actually passed in, and
     return the appropriate subtype of wrapped number based on the
     normal arithmetic contagion rules.

     For example, if both input parameters are wrapped integers then
     the output will be a wrapped integer.  If the inputs are a wrapped
     integer and a wrapped float then the output will be a wrapped
     float, etc.

 -- Macro: define-arithmetic-test-on-wrappers ((name SYMBOL)
          (test-name SYMBOL)) : OBJECT
     Defines NAME as an arithmetic comparision operation using the test
     TEST-NAME.  It will take two wrapped number parameters and return
     a `boolean'.  The code will use the appropriate test for the
     specific subtype of wrapped number actually passed in.

 -- Macro: define-computed-constraint ((name SYMBOL) (var-list CONS)
          (constraint-test CONS) &body (position-computations CONS)) :
          OBJECT
     Defines NAME to be a constraint computation which uses
     CONSTRAINT-TEST to determine if a fully bound set of variables
     satisfies the constraint.  The forms in POSITION-COMPUTATIONS are
     used to compute the value for each of the positions. All such
     computations must set the variable `value' to be the result
     computed for the missing position.  Setting `value' to `null' for
     any such computation means that that particular argument cannot be
     computed from the others.  The input variables in VAR-LIST will be
     bound to the N arguments to the constraint.    The generated
     function will return a Stella Object and take as inputs the values
     of the N arguments to the constraint.  A value of `null' means
     that the value is not available.  If all arguments are not `null',
     then the return value will be a Stella wrapped boolean indicating
     whether the constraint is satisified or not.    If more than one
     input value is `null', then this constraint code will not be
     called.

 -- Function: deobjectify-tree ((self OBJECT)) : OBJECT
     Return a copy of SELF where all logic objects are replaced by
     their `generated' parse-tree version.  This is useful to convert
     the result of a retrieval query into a regular parse tree.

 -- Method on NAMED-DESCRIPTION: describe-object (self
          (stream OUTPUT-STREAM) (mode KEYWORD)) :
     Prints a description of SELF to stream STREAM.  MODE can be
     :terse, :verbose, or :source.  Used by `describe'.

 -- Method on NAMED-DESCRIPTION: description-name (self) : SYMBOL
     Return the name of the description SELF.

 -- Method on DESCRIPTION: description-name (self) : SYMBOL
     Return the name of the description SELF, if it has one.

 -- Function: destroy-instance ((self OBJECT)) :
     Destroy all propositions that reference SELF, and mark it as
     `deleted?', thereby making it invisible within class extensions.

 -- Function: destroy-object ((self OBJECT)) :
     Destroy SELF which can be a term or a proposition.  Destroy all
     propositions that reference SELF and mark it as `deleted?' (thereby
     making it invisible within class extensions).

 -- Function: destroy-proposition ((proposition PROPOSITION)) :
          PROPOSITION
     Retract and destroy the proposition PROPOSITION.  Recursively
     destroy all propositions that reference PROPOSITION.  Also,
     destroy all satellite propositions of PROPOSITION.

 -- Function: destroy-term ((self LOGIC-OBJECT)) :
     Destroy all propositions that reference SELF, and mark it as
     `deleted?', thereby making it invisible within class extensions.
     Unlink descriptions from native relations.

 -- Function: direct-superrelations ((self RELATION)) : (ITERATOR OF
          (LIKE SELF))
     Return direct super classes/slots of SELF.

 -- Function: disabled-powerloom-feature? ((feature KEYWORD)) : BOOLEAN
     Return true if the STELLA FEATURE is currently disabled.

 -- Function: disjoin-truth-values ((tv1 TRUTH-VALUE)
          (tv2 TRUTH-VALUE)) : TRUTH-VALUE
     Return the logical disjunction of truth values TV1 and TV2.

 -- Function: disjoint-terms? ((d1 DESCRIPTION) (d2 DESCRIPTION)) :
          BOOLEAN
     Return TRUE if D1 and D2 belong to disjoint partitions.

 -- Function: do-clear-instances ((module MODULE)) :
     Function version of `clear-instances' that evaluates its argument.

 -- Function: do-save-module ((module MODULE) (store OBJECT)) :
     Save MODULE to the persistent store STORE which can either be an
     output stream or a persistent OBJECT-STORE.

 -- Method on QUERY-SOLUTION-TABLE: empty? (self) : BOOLEAN
     Return TRUE if SELF has zero entries.

 -- Method on FLOAT-VECTOR: empty? (self) : BOOLEAN
     Return TRUE if SELF has length 0.

 -- Function: enabled-powerloom-feature? ((feature KEYWORD)) : BOOLEAN
     Return true if the STELLA FEATURE is currently enabled.

 -- Method on PAGING-INDEX: estimated-length (self) : INTEGER
     Return the estimated length of the sequences in SELF, which could
     be too large if some of the members have been deleted.

 -- Function: evaluate-proposition ((self PROPOSITION)) :
     Evaluate SELF against its arguments, possibly resulting in the
     setting or changing of its truth value.

 -- Function: evaluation-state ((proposition PROPOSITION)) : KEYWORD
     Return :POSTED if PROPOSITION is on the evaluation queue for
     *context*, :EVALUATED if has been evaluated, or NULL if it has
     never been evaluated.

 -- Function: evaluation-state-setter ((proposition PROPOSITION)
          (state KEYWORD)) :
     Record the evaluation STATE of PROPOSITION.

 -- Function: explain-why ((label STRING) (style KEYWORD)
          (maxdepth INTEGER) (stream OUTPUT-STREAM)) :
     Programmer's interface to WHY function.

 -- Function: explain-whynot ((label STRING) (style KEYWORD)
          (maxdepth INTEGER) (summary? BOOLEAN) (stream OUTPUT-STREAM))
          :
     Programmer's interface to the WHYNOT function.

 -- Function: false-truth-value? ((self TRUTH-VALUE)) : BOOLEAN
     Return TRUE if SELF represents some form of falsehood.

 -- Function: false? ((self PROPOSITION)) : BOOLEAN
     Return true if SELF is false (or default-false if we are
     considering default assertions).

 -- Method on OBJECT-STORE: fetch-instance (store (name OBJECT)) :
          OBJECT
     Fetch the instance identified by NAME (a string or symbol) from
     STORE and return it as an appropriate logic object.  This needs to
     be appropriately specialized on actual OBJECT-STORE
     implementations.

 -- Method on OBJECT-STORE: fetch-relation (store (name OBJECT)) :
          NAMED-DESCRIPTION
     Fetch the relation identified by NAME (a string or symbol) from
     STORE and return it as a named description.  This needs to be
     appropriately specialized on actual OBJECT-STORE implementations.

 -- Method on 2_D_ARRAY: fill-array (self &rest (values OBJECT)) :
     Fill the two-dimensional array SELF in row-major-order from
     VALUES.  Missing values will retain their old values, extraneous
     values will be ignored.

 -- Method on 2_D_FLOAT-ARRAY: fill-array (self &rest (values FLOAT)) :
     Fill the two-dimensional array SELF in row-major-order from
     VALUES.  Missing values will retain their old values, extraneous
     values will be ignored.

 -- Function: finalize-objects () :
     Finalize all currently unfinalized objects.  The user-level entry
     point for this is `(process-definitions)'.

 -- Function: find-direct-supers-and-subs ((self DESCRIPTION)
          (onlysupers? BOOLEAN)) : (CONS OF DESCRIPTION) (CONS OF
          DESCRIPTION) (CONS OF DESCRIPTION)
     Classify SELF and return three values, its direct supers, direct
     subs, and a list of equivalent descriptions.  Setting
     `supersOnly?' may speed up the computation (perhaps by a lot).  If
     `description' is nameless and has no dependent propositions, then
     it is automatically removed from the hierarchy after
     classification.

 -- Function: find-direct-supers-of-instance ((self OBJECT)) : (CONS OF
          LOGIC-OBJECT)
     Classify SELF and return a list of most specific named
     descriptions among all descriptions that it satisfies.

 -- N-Command: find-instance ((instanceRef OBJECT)) : OBJECT
     Return the nearest instance with name INSTANCEREF visible from the
     current module.  INSTANCEREF can be a string, symbol, or
     surrogate.  If INSTANCEREF is a surrogate, the search originates
     in the module the surrogate was interned in.

 -- N-Command: find-rule ((ruleName NAME)) : PROPOSITION
     Search for a rule named RULENAME.  Like `get-rule', but
     `find-rule' implicity quotes its input argument.

 -- Function: function? ((relationRef OBJECT)) : BOOLEAN
     Return TRUE if RELATIONREF references a function.

 -- Function: generate-expression ((self LOGIC-OBJECT)
          (canonicalizevariablenames? BOOLEAN)) : OBJECT
     Return an s-expression representing the source expression for SELF.

 -- Method on LOGIC-THING: generate-specialized-term (self) : OBJECT
     Method to generate a specialized term for SELF.  This is designed
     to allow for extension of the term generation code to cover other
     types of objects for the logic.  This particular method will signal
     an error unless there is a surrogate-value-inverse link set.

 -- Function: get-class ((instanceRef OBJECT)) : LOGIC-OBJECT
     Return the nearest class with name INSTANCEREF visible from the
     current module.  INSTANCEREF can be a string, symbol, or
     surrogate.  If INSTANCEREF is a surrogate, the search originates
     in the module the surrogate was interned in.

 -- Function: get-forward-justifications ((proposition PROPOSITION)) :
          (LIST OF JUSTIFICATION)
     Return PROPOSITIONs forward justifications.

 -- Function: get-instance ((instanceRef OBJECT)) : OBJECT
     Return the nearest instance with name INSTANCEREF visible from the
     current module.  INSTANCEREF can be a string, symbol, or
     surrogate.  If INSTANCEREF is a surrogate, the search originates
     in the module the surrogate was interned in.

 -- Function: get-module ((moduleRef OBJECT)) : MODULE
     Return a module named MODULEREF.

 -- Function: get-relation ((instanceRef OBJECT)) : LOGIC-OBJECT
     Return the nearest relation with name INSTANCEREF visible from the
     current module.  INSTANCEREF can be a string, symbol, or
     surrogate.  If INSTANCEREF is a surrogate, the search originates
     in the module the surrogate was interned in.

 -- Function: get-self-or-prototype ((instanceRef OBJECT)) :
          LOGIC-OBJECT
     Used to convert a computation to reference so-called `template'
     slots rather than `own' slots:  If INSTANCEREF denotes a class,
     return a prototype of that class.  Otherwise, return INSTANCEREF.

 -- Function: get-slot-maximum-cardinality ((self LOGIC-OBJECT)
          (relation SURROGATE)) : INTEGER
     Return a maximum value for the number of fillers of relation
     RELATION (a surrogate) applied to the instance SELF (an object).

 -- Function: get-slot-minimum-cardinality ((self LOGIC-OBJECT)
          (relation SURROGATE)) : INTEGER
     Return a minimum value for the number of fillers of relation
     RELATION (a surrogate) applied to the instance SELF (an object).

 -- Function: get-slot-value ((self LOGIC-OBJECT) (relation SURROGATE))
          : OBJECT
     Return a single value for the slot RELATION (a surrogate) applied
     to SELF (an object).

 -- Function: get-slot-value-type ((self LOGIC-OBJECT)
          (relation SURROGATE)) : NAMED-DESCRIPTION
     Return a most specific type for fillers of the slot RELATION (a
     surrogate) applied to SELF. If there is more than one, pick one.

 -- Function: get-why-justification ((label STRING)) : JUSTIFICATION
     Returns the current WHY justification.  May also throw one of the
     following subtypes of EXPLAIN-EXCEPTION:
     EXPLAIN-NO-QUERY-EXCEPTION    EXPLAIN-NO-SOLUTION-EXCEPTION
     EXPLAIN-NO-MORE-SOLUTIONS-EXCEPTION
     EXPLAIN-NOT-ENABLED-EXCEPTION    EXPLAIN-NO-SUCH-LABEL-EXCEPTION
     EXPLAIN-QUERY-TRUE-EXCEPTION

 -- Function: get-whynot-justifications ((query QUERY-ITERATOR)
          (label STRING) (mapping EXPLANATION-MAPPING)) : (LIST OF
          JUSTIFICATION)
     Programmer's interface to WHYNOT function.  Derive justifications
     why QUERY failed, or, if LABEL was supplied as non-NULL, lookup
     its justification relative to MAPPING and return the result.

 -- Function: has-forward-justifications? ((proposition PROPOSITION)) :
          BOOLEAN
     Return TRUE if PROPOSITION has any forward justifications.

 -- Method on NAMED-DESCRIPTION: help-print-outline (top
          (stream OUTPUT-STREAM) (current-depth INTEGER)
          (depth INTEGER) (named? BOOLEAN)) :
     Helper function for `print-concept-outline'

 -- Method on DESCRIPTION: help-print-outline (top
          (stream OUTPUT-STREAM) (current-depth INTEGER)
          (depth INTEGER) (named? BOOLEAN)) :
     Helper function for `print-concept-outline'

 -- N-Command: in-dialect ((dialect NAME)) : KEYWORD
     Change the current logic dialect to DIALECT.  Currently supported
     dialects are `KIF', `STELLA', and `PREFIX-STELLA'.  The STELLA
     dialects are not recommended for the construction of knowledge
     bases, they are mainly used internally by PowerLoom.

 -- Function: inconsistent-truth-value? ((self TRUTH-VALUE)) : BOOLEAN
     Return TRUE if SELF represents INCONSISTENT.

 -- Function: inconsistent? ((self PROPOSITION)) : BOOLEAN
     Return true if SELF is inconsistent (true and false).

 -- Method on QUERY-SOLUTION-TABLE: insert-at (self
          (key (LIKE (ANY-KEY SELF))) (value (LIKE (ANY-VALUE SELF)))) :
     Insert VALUE identified by KEY into SELF.  If a solution with that
     key already exists, destructively modify it with the slot values of
     VALUE.  This is necessary to preserve the order of solutions in
     SELF.

 -- Function: invert-truth-value ((self TRUTH-VALUE)) : TRUTH-VALUE
     Return the logical negation of SELF.

 -- Function: known-truth-value? ((self TRUTH-VALUE)) : BOOLEAN
     Return TRUE if SELF is a known truth value, that is either TRUE or
     FALSE, but not UNKNOWN, INCONSISTENT, etc.

 -- Method on QUERY-SOLUTION-TABLE: length (self) : INTEGER
     Return the number of entries in SELF.

 -- Command: list-features () : LIST
     Return a list containing two lists, a list of currently enabled
     PowerLoom features, and a list of all available PowerLoom features.

 -- N-Command: list-unclassified-instances ((module NAME)
          (local? BOOLEAN)) : (CONS OF LOGIC-OBJECT)
     Collect all instances in MODULE (or in any module if MODULE is
     NULL) that were not (or will not be) classified due to their lack
     of non-inferable/primitive type assertions.

 -- N-Command: list-unclassified-relations ((module NAME)
          (local? BOOLEAN)) : (CONS OF NAMED-DESCRIPTION)
     Collect all named description in MODULE (or in any module if MODULE
     is NULL) that were not (or will not be) classified due to their
     lack of non-inferable/primitive ancestor relations.

 -- N-Command: list-undefined-relations ((module NAME)
          (local? BOOLEAN)) : (CONS OF NAMED-DESCRIPTION)
     Return a list of as yet undefined concepts and relations in MODULE.
     These relations were defined by the system, since they were
     referenced but have not yet been defined by the user.  If MODULE
     is NULL look in the current module.  If LOCAL? only look in MODULE
     but not in any modules it inherits.

 -- Method on QUERY-ITERATOR: listify (self) : LIST
     Just like `QUERY-ITERATOR.consify' but return a LIST instead.

 -- Command: load-cmd-line-files () :
     Loads all PowerLoom files specified on the command line.  If
     directories are listed, all PowerLoom files in those directories
     are loaded.  Since when this is called we might still have
     unprocessed command line args, this only looks at files which are
     to the right of the last argument that starts with a `-' character.

 -- Command: load-directory ((directory STRING)) :
     Load all PowerLoom files (*.plm) in DIRECTORY in alphabetic sort
     order.

 -- Function: load-stream ((stream INPUT-STREAM)) :
     Read logic commands from STREAM and evaluate them.

 -- Function: load-stream-in-module ((stream INPUT-STREAM)
          (default-module MODULE)) :
     Read logic commands from STREAM and evaluate them.  If
     DEFAULT-MODULE is not `null', then any commands will be read into
     that module unless an `in-module' declaration is encountered which
     will over-ride the default value.  If noe DEFAULT-MODULE is
     specified, and the input stream does not have an `in-module' form,
     an error is signaled.

 -- Function: logic-class? ((self CLASS)) : BOOLEAN
     Return TRUE if the class SELF or one of its supers supports
     indices that record extensions referenced by the logic system.
     Also return true for literal classes.

 -- Function: logic-form-less? ((o1 OBJECT) (o2 OBJECT)) : BOOLEAN
     A sorting predicate for objects O1 and O2 that can appear in
     logical forms.  Performs a combined numeric and lexocographic sort
     that accounts for lists, collections and propositions.  Numbers
     precede all other values, `null' follows all other values.

 -- Function: logic-module? ((self MODULE)) : BOOLEAN
     Return TRUE if SELF is a logic module, implying that relations
     defined within it define a knowledge base.  A module is a logic
     module iff it inherits the module `PL-KERNEL'.

 -- Method on QUERY-SOLUTION-TABLE: lookup (self
          (key (LIKE (ANY-KEY SELF)))) : (LIKE (ANY-VALUE SELF))
     Lookup the solution identified by KEY in SELF and return its
     value, or NULL if no such solution exists.

 -- Function: lookup-native-computation ((native-name STRING)
          (arity INTEGER)) : FUNCTION-CODE
     Returns the native funtion code for NATIVE-NAME if it exists and
     the underlying programming languages supports such lookups.  It is
     looked up using the signature of a computation function supported
     by the computation specialist.

 -- Function: lookup-native-specialist ((native-name STRING)) :
          FUNCTION-CODE
     Returns the native funtion code for NATIVE-NAME if it exists and
     the underlying programming languages supports such lookups.  Uses
     the signature of a specialist function.

 -- Function: named-description? ((self DESCRIPTION)) : BOOLEAN
     Return TRUE if SELF is the description of a named class or
     relation.

 -- Function: natural-deduction-mode? () : BOOLEAN
     True if normalization is governed by natural deduction semantics.

 -- Method on QUERY-SOLUTION-TABLE: non-empty? (self) : BOOLEAN
     Return TRUE if SELF has at least 1 entry.

 -- Method on FLOAT-VECTOR: non-empty? (self) : BOOLEAN
     Return TRUE if SELF has length > 0.

 -- Method on QUERY-SOLUTION-TABLE: nth (self (position INTEGER)) :
          (LIKE (ANY-VALUE SELF))
     Return the nth solution in SELF, or NULL if it is empty.

 -- Function: object-name ((self OBJECT)) : SYMBOL
     Return the name symbol for the logic object SELF.

 -- Function: object-name-string ((self OBJECT)) : STRING
     Return the name string for the logic object SELF.

 -- Function: object-surrogate ((self OBJECT)) : SURROGATE
     Return the surrogate naming the object SELF, which may be a Stella
     class that is used in PowerLoom as well as a more normal powerloom
     object.

 -- Function: object-surrogate-setter ((self OBJECT) (name SURROGATE))
          : SURROGATE
     Return the name of the logic object SELF to NAME.

 -- Method on QUERY-SOLUTION-TABLE: pop (self) : (LIKE (ANY-VALUE SELF))
     Remove and return the first solution of SELF or NULL if the table
     is empty.

 -- Function: post-for-evaluation ((self PROPOSITION) (world CONTEXT)) :
     Push SELF onto the evaluation queue (unless it's already there).

 -- Function: powerloom () :
     Run the PowerLoom listener.  Read logic commands from the standard
     input, evaluate them, and print their results.  Exit if the user
     entered `bye', `exit', `halt', `quit', or `stop'.

 -- Function: powerloom-gui-exit-hook ((ignore OBJECT)) :
     Exit hook to stop the PowerLoom GUI if it is running.

 -- Command: powerloom-information () : STRING
     Returns information about the current PowerLoom implementation.
     Useful when reporting problems.

 -- Function: pretty-print-logical-form ((form OBJECT)
          (stream OUTPUT-STREAM)) :
     Pretty-print the logical form FORM to STREAM according to the
     current setting of `*logic-dialect*'.

 -- Method on 2_D_ARRAY: print-array (self
          (stream NATIVE-OUTPUT-STREAM)) :
     Print the array SELF to STREAM.

 -- Method on 2_D_FLOAT-ARRAY: print-array (self
          (stream NATIVE-OUTPUT-STREAM)) :
     Print the array SELF to STREAM.

 -- Function: print-extension-sizes ((module MODULE)
          (sizeCutoff INTEGER)) :
     Print the extension sizes of concepts visible in MODULE.  If
     MODULE is NULL the current module is used.  Do not report
     extensions with size less than SIZECUTOFF (default is 10).

 -- N-Command: print-facts ((instanceref OBJECT)) :
     Like ALL-FACTS-OF, but prints each fact on a separate line on the
     standard output stream.

 -- Function: print-goal-stack ((frame CONTROL-FRAME)
          (verbose? BOOLEAN)) :
     Print stack of goals.  Assumes that query has been interrupted
     with a full stack of control frames.

 -- Function: print-logical-form ((form OBJECT) (stream OUTPUT-STREAM))
          :
     Print the logical form FORM to STREAM according to the current
     setting of `*logic-dialect*'.  Pretty-printing is controlled by
     the current setting of `*prettyPrintLogicalForms?*'.

 -- Function: print-logical-form-in-dialect ((self OBJECT)
          (dialect KEYWORD) (stream OUTPUT-STREAM)) :
     Produce a stringified version of a logical representation of SELF
     and write it to the stream STREAM.  Use the dialect DIALECT, or
     use the current dialect if DIALECT is NULL.

 -- Function: print-unformatted-logical-form ((form OBJECT)
          (stream OUTPUT-STREAM)) :
     Print the logical form FORM to STREAM according to the current
     setting of `*logic-dialect*'.  Pretty-printing is explicitly
     forced to be turned off.

 -- Function: print-whynot-justification ((justification JUSTIFICATION)
          (stream OUTPUT-STREAM) (maxDepth INTEGER) (style KEYWORD)
          (summary? BOOLEAN)) :
     Print a WHYNOT JUSTIFICATION to STREAM according to MAXDEPTH and
     STYLE.  Print a summary only if SUMMARY? is TRUE.

 -- Function: random-float ((n FLOAT)) : FLOAT
     Generate a random integer in the interval [0..n-1].  N must be <=
     2^15.

 -- Method on MARKER-TABLE: recall-marked-objects (self) : LIST-ITERATOR
     Return an iterator that generates all marked objects recorded in
     SELF.

 -- Function: record-justifications? () : BOOLEAN
     Return TRUE if every query records justifications to enable the
     explanation of concluded results.

 -- Function: register-computation-function ((name STRING)
          (code FUNCTION-CODE) (arity INTEGER)) :
     Creates a registration entry for NAME as a computation which
     executes CODE.  Essentially just builds the Stella meta-information
     tructure needed to funcall NAME as a computation function by the
     computation specialist.  The function definition in CODE needs to
     accept ARITY Stella OBJECTs as arguments and return a Stella OBJECT
     suitable for PowerLoom use.  (These are generally LOGIC-OBJECTs
     and the literal wrappers FLOAT-WRAPPER, INTEGER-WRAPPER and
     STRING-WRAPPER.)

 -- Command: register-computation-function-name ((stella-name STRING)
          (native-name STRING) (arity INTEGER)) :
     registers a computation function STELLA-NAME based on the
     NATIVE-NAME for the particular programming language in question.
     Use of this command makes the resulting code or knowledge bases
     non-portable to other target languages.

 -- Function: register-logic-dialect-print-function ((dialect KEYWORD)
          (fn FUNCTION-CODE-WRAPPER)) :
     Register FN as a logic-object print function for DIALECT.  Each
     function should have the signature `((self OBJECT) (stream
     OUTPUT-STREAM))'.  Any return values will be ignored.

 -- Function: register-specialist-function ((name STRING)
          (code FUNCTION-CODE)) :
     Creates a registration entry for NAME as a specialist which
     executes CODE.  Essentially just builds the Stella meta-information
     tructure needed to funcall NAME as a specialist.  The function
     definition in CODE needs to accept a CONTROL-FRAME and KEYWORD as
     arguments and return a KEYWORD.  Side effects on elements of the
     proposition in the control frame can be used to bind and thus
     return values.

 -- Command: register-specialist-function-name ((stella-name STRING)
          (native-name STRING)) :
     registers a specialist function STELLA-NAME based on the
     NATIVE-NAME for the particular programming language in question.
     Use of this command makes the resulting code or knowledge bases
     non-portable to other target languages.

 -- Function: relation-name ((self NAMED-DESCRIPTION)) : STRING
     Given a relation object, return it's name.

 -- Function: relation? ((objectRef OBJECT)) : BOOLEAN
     Return TRUE if OBJECTREF denotes a relation or a class.

 -- Method on QUERY-SOLUTION-TABLE: remove-at (self
          (key (LIKE (ANY-KEY SELF)))) :
     Remove the solution identified by KEY from SELF.  To preserve the
     solution ordering chain, the solution is marked as deleted and
     will be completely removed upon the next iteration through SELF.

 -- Method on PAGING-INDEX: remove-deleted-members (self) : (LIKE SELF)
     Destructively remove all deleted members of SELF.

 -- Function: reset-query-caches () :
     Zero out all caches managed by the query optimizer, so that it
     will reoptimize subgoal queries upon next invocation.

 -- Function: retract-facts-of-instance ((self LOGIC-OBJECT)) :
     Retract all definite (TRUE or FALSE) propositions attached to SELF.

 -- N-Command: retrieve-partial (&rest (tree PARSE-TREE)) :
          QUERY-ITERATOR
     Partial-match version of `retrieve' (which see) that generates
     scored partial solutions based on the current partial match
     strategy.  By supplying `BEST' instead of `ALL', or by adding the
     option `:SORT-BY :SCORE', the generated solutions will be sorted
     so that solutions with higher scores come first.  Use the
     `:MATCH-MODE' option to override the global default setting
     established by `set-partial-match-mode', e.g., use `:MATCH-MODE
     :NN' to use the neural net partial match mode.  The
     `:MINIMUM-SCORE' option can be used to only retrieve solutions
     that have at least the specified minimum match score.  By default,
     `retrieve-partial' does not maximize the match scores of its
     returned bindings.  To only get maximal scores use
     `:MAXIMIZE-SCORE? TRUE' (this is not yet implemented - you can use
     `ask-partial' to maximize scores for individual solutions by hand).

 -- N-Command: run-forward-rules ((moduleRef NAME)
          &rest (force KEYWORD)) :
     Run forward inference rules in module MODULEREF. If MODULEREF is
     NULL, the current module will be used.  If forward inferencing is
     already up-to-date in the designated module, no additional
     inferencing will occur, unless the optional keyword `:force' is
     included, in which case all forward rules are run or rerun.

     Calling `run-forward-rules' temporarily puts the module into a
     mode where future assertional (monotonic) updates will trigger
     additional forward inference.  Once a non-monotonic update is
     performed, i.e., a retraction or clipping of relation value, all
     cached forward inferences will be discarded and forward
     inferencing will be disabled until this function is called again.

 -- Command: run-powerloom-tests () :
     Run the PowerLoom test suite.  Currently this simply runs all
     demos and echos commands and their results to standard output.
     The output can then be diffed with previously validated runs to
     find deviations.

 -- Function: satisfies? ((instanceOrTuple OBJECT)
          (relationRef OBJECT)) : TRUTH-VALUE
     Try to prove whether INSTANCEORTUPLE satisfies the definition of
     the relation RELATIONREF and return the result truth value of the
     query.  INSTANCEORTUPLE can be a single object, the name or
     surrogate of an object, or a collection (a list or vector) of
     objects.  RELATIONREF can be a relation, description, surrogate or
     relation name.

 -- Command: save-all-neural-networks ((file STRING)) :
     Save all neural networks to FILE (if FILE is non-NULL).  If
     networks are saved periodically (see `set-save-network-cycle')
     this file name will be used to perform periodic saves.

 -- Function: select-proof-result ((success? BOOLEAN)
          (continuing? BOOLEAN) (terminal? BOOLEAN)) : KEYWORD
     Helping function for specialists.   Return the appropriate keyword
     indicating success or failure of a proof.

 -- Function: select-test-result ((success? BOOLEAN)
          (terminal? BOOLEAN) (frame CONTROL-FRAME)) : KEYWORD
     Helping function for specialists testing the validity of a fully
     bound inference frame.  Based on the test result SUCCESS?  and
     `reversePolarity?*', set the truth value of FRAME and return an
     appropriate keyword.  The keyword will be either `:final-success'
     `:terminal-failure' if TERMINAL? is true.  Otherwise it will be
     `:final-success' or `:failure'.

 -- Command: set-error-print-cycle ((i INTEGER)) :
     Set number of cycles between which error rates are saved to the
     file established by the last call to `save-all-neural-networks'
     appended with extension `.err'.  A number <= 0 (or NULL) turns off
     periodic saving.

 -- N-Command: set-inference-level ((level NAME) (module NAME)) :
          KEYWORD
     Set the inference level of MODULE to the level specified by
     `levelKeyword'.  If MODULE is NULL, set the level globally.

 -- Method on MARKER-TABLE: set-marker (self (object OBJECT)) :
     Record membership of OBJECT in the marker storage object SELF.

 -- Command: set-num-neighbors ((d INTEGER)) :
     Sets the number of nearest neighbors to predict from.

 -- Command: set-num-training-per-case ((d INTEGER)) :
     Sets the number of training examples for each case in the training
     set.

 -- Function: set-powerloom-feature ((feature KEYWORD)) :
     Enable the PowerLoom environment feature FEATURE.

 -- Command: set-save-network-cycle ((i INTEGER)) :
     Set number of cycles between which networks are saved to the file
     established by the last call to `save-all-neural-networks'.  A
     number <= 0 or a NULL number turns off periodic saving.

 -- Method on QUERY-SOLUTION-TABLE: sort (self
          (predicate FUNCTION-CODE)) : (LIKE SELF)
     Perform a stable, destructive sort of SELF according to PREDICATE,
     and return the result.  If PREDICATE has a `<' semantics, the
     result will be in ascending order.

 -- Function: specializes? ((subObject OBJECT) (superObject OBJECT)) :
          TRUTH-VALUE
     Try to prove if the description associated with SUBOBJECT
     specializes the description for SUPEROBJECT and return the result
     truth value of the query.

 -- Command: start-ontosaurus (&rest (options OBJECT)) :
     Start the PowerLoom HTTP server at :port (defaults to 9090).  Loads
     the required support systems in Lisp and Java if necessary (C++ is
     not yet supported).

 -- Command: start-powerloom-gui (&rest (options OBJECT)) :
     Start the PowerLoom server at :port (defaults to 9090) and launches
     the GUI which will communicate with the server at that port.  If
     :host is specified, the GUI will try to communicate with a server
     at `host:port' instead of the local embedded server (note, you can
     always point the GUI manually to a different server from its
     `Connect to Server' menu item).  Loads the required support
     systems if necessary.  Embedded calls to the GUI are currently
     only supported in Java; however, when the GUI is run in standalone
     mode, it can communicate with any PowerLoom installation that
     supports an HTTP server (currently Lisp and Java).

 -- Command: start-powerloom-server (&rest (options OBJECT)) :
     Start the PowerLoom HTTP server at :port (defaults to 9090).  Loads
     the required support systems in Lisp and Java if necessary (C++ is
     not yet supported).

 -- Command: stop-ontosaurus () :
     Stop the PowerLoom HTTP server and free up any bound ports.  This
     is a no-op if no server is running or the server is not supported.

 -- Command: stop-powerloom-gui () :
     Closes the PowerLoom GUI application if it is currently visible.
     This is a no-op if the GUI is not running or if it is not
     supported.

 -- Command: stop-powerloom-server () :
     Stop the PowerLoom HTTP server and free up any bound ports.  This
     is a no-op if no server is running or the server is not supported.

 -- Function: strengthen-truth-value ((tv1 TRUTH-VALUE)
          (tv2 TRUTH-VALUE)) : TRUTH-VALUE
     If TV2 has greater strength than TV1, adapt the strength of TV1
     (not its value!) and return the result.  Otherwise, return TV1
     unmodified.

 -- Function: strict-truth-value? ((self TRUTH-VALUE)) : BOOLEAN
     Return TRUE if SELF is a strict truth value.

 -- Function: termify ((self OBJECT)) : OBJECT
     Convert SELF into an equivalent PowerLoom object that can be
     passed as an argument wherever an instance is expected.

 -- Function: test-closed-slot? ((relation SURROGATE)) : BOOLEAN
     Return TRUE if RELATION (a surrogate) is asserted to be closed or
     if the current module closes all relations.

 -- Function: test-function-slot? ((relation SURROGATE)) : BOOLEAN
     Return TRUE if RELATION (a surrogate) is a function.

 -- Method on MARKER-TABLE: test-marker? (self (object OBJECT)) :
          BOOLEAN
     Return TRUE if OBJECT is stored (marked) in SELF.

 -- Function: test-relation-on-arguments? ((relation SURROGATE)
          (arguments CONS)) : BOOLEAN
     Return TRUE if RELATION (a surrogate) is TRUE when applied to
     ARGUMENTS.

 -- Function: test-slot-value? ((self LOGIC-OBJECT)
          (relation SURROGATE) (filler OBJECT)) : BOOLEAN
     Return TRUE if the proposition `(<relation> <self> <filler>)' is
     true.

 -- Function: test-special-marker-table? ((self OBJECT)) : BOOLEAN
     Return TRUE if the object SELF is stored (marked) in the table
     pointed at by the special variable *specialMarkerTable*.  Designed
     for use by `remove-if'.

 -- Function: test-subrelation? ((subrelation SURROGATE)
          (superrelation SURROGATE)) : BOOLEAN
     Return TRUE if SUBRELATION specializes SUPERRELATION.

 -- Function: test-type-on-instance? ((self OBJECT) (type SURROGATE)) :
          BOOLEAN
     Return TRUE if SELF satisfies TYPE.

 -- Command: translate-loom-file ((input FILE-NAME) (output FILE-NAME))
          :
     Translate the Loom file INPUT to PowerLoom and write the
     translation to the file OUTPUT.  Note that this will only work for
     fairly vanilla Loom files that do not contain any Lisp-isms.  It
     might require to clean the Loom file manually before this
     translation will work.

 -- Function: true-truth-value? ((self TRUTH-VALUE)) : BOOLEAN
     Return TRUE if SELF represents some form of truth.

 -- Function: true? ((self PROPOSITION)) : BOOLEAN
     Return true if SELF is true (or default-true if we are considering
     default assertions).

 -- N-Command: unassert ((proposition PARSE-TREE)) : OBJECT
     Retract the truth, falsity or inconsistency of PROPOSITION.  This
     is a more general version of `retract' that also handles falsity.
     For example, if we assert the proposition "(not (sad Fred))", and
     then execute the statement "(unassert (sad Fred))", the truth
     value of the proposition "(sad Fred)" will be set to UNKNOWN.  If
     we had called `retract' in place of `unassert', the proposition
     "(sad Fred)" would remain set to FALSE.   Note that for this
     unassertion to succeed, the logic constant `Fred' and the relation
     `sad' must already be defined.

 -- Function: unassert-proposition ((self PROPOSITION)) :
     Retract the truth, falsity or inconsistency of the proposition
     SELF.

 -- Function: unknown-truth-value? ((self TRUTH-VALUE)) : BOOLEAN
     Return TRUE if SELF represents UNKNOWN.

 -- Function: unknown? ((self PROPOSITION)) : BOOLEAN
     Return true if the truth of SELF is unknown.

 -- Function: unset-powerloom-feature ((feature KEYWORD)) :
     Disable the PowerLoom environment feature FEATURE.

 -- Function: upclassify-all-descriptions () :
     Classify all named descriptions.

 -- Function: upclassify-all-instances () :
     Classify all named instances.

 -- Function: upclassify-instances ((module MODULE) (local? BOOLEAN)) :
     Classify instances local to MODULE and inherited by MODULE.  If
     LOCAL?, don't classify inherited descriptions.  If MODULE is NULL,
     classify descriptions in all modules.

 -- Function: upclassify-named-descriptions ((module MODULE)
          (local? BOOLEAN)) :
     Classify named descriptions local to MODULE and inherited by
     MODULE.  If LOCAL?, don't classify inherited descriptions.  If
     MODULE is NULL, classify descriptions in all modules.

 -- Method on OBJECT-STORE: update-proposition-in-store (store
          (proposition PROPOSITION) (update-mode KEYWORD)) :
     A module with STORE has had the truth value of PROPOSITION change
     according to UPDATE-MODE.  The default method does nothing.

 -- Function: update-tuple ((relation SURROGATE)
          (arguments (CONS OF OBJECT)) (updatemode KEYWORD)) :
          PROPOSITION
     Assert or retract a proposition that applies RELATION to ARGUMENTS.

 -- Function: weaken-truth-value ((tv1 TRUTH-VALUE) (tv2 TRUTH-VALUE))
          : TRUTH-VALUE
     If TV2 has lesser strength than TV1, adapt the strength of TV1 (not
     its value!) and return the result.  Otherwise, return TV1
     unmodified.

 -- Macro: with-logic-environment ((moduleForm OBJECT)
          (environment OBJECT) &body (body CONS)) : OBJECT
     Execute BODY within the module resulting from MODULEFORM.
     `*module*' is an acceptable MODULEFORM.  It will locally rebind
     `*module*' and `*context*' and shield the outer bindings from
     changes.

 -- Macro: within-classification-session
          ((descriptionorinstance KEYWORD) &body (body CONS)) : OBJECT
     Used during classification.  Execute BODY within the indicated
     classification session and inference world.

 -- Macro: within-meta-cache (&body (body CONS)) : OBJECT
     Execute BODY within the meta cache of the current module.  Set
     appropriate special variables.

 -- Function: create-keyword ((name STRING)) : KEYWORD
     Returns the Stella keyword NAME, creating it if necessary.  NAME
     is treated case-sensitively.  This should generally not be
     necessary to do.

 -- Function: create-symbol ((name STRING) (module MODULE)
          (environment ENVIRONMENT)) : SYMBOL
     Returns the Stella symbol NAME visible in MODULE, creating it if
     necessary.  NAME is ALWAYS treated case-sensitively, even if
     MODULE is case insensitive. This should generally not be necessary
     to do.

 -- Function: get-keyword ((name STRING)) : KEYWORD
     Returns the Stella KEYWORD NAME if it exists.  Case sensitive.

 -- Function: get-name-in-module ((obj OBJECT) (module MODULE)
          (environment ENVIRONMENT)) : STRING
     Return the name, qualified as necessary, so that OBJ can be found
     from MODULE.  If there is no name for the object return `null'.

 -- Function: get-short-name ((obj OBJECT)) : STRING
     Return the short name of OBJ, if it has one.  Otherwise return
     `null'.

 -- Function: get-symbol ((name STRING) (module MODULE)
          (environment ENVIRONMENT)) : SYMBOL
     Returns the Stella SYMBOL NAME visible in MODULE if it exists.
     NAME is ALWAYS treated case sensitively.

 -- Function: is-known ((tv TRUTH-VALUE)) : BOOLEAN
     Tests whether TV is a known truth value (i.e., true or false).

 -- Function: is-true-proposition1 ((relation-and-arguments OBJECT)
          (module MODULE) (environment ENVIRONMENT)) : BOOLEAN
     Return TRUE if a proposition (`relation' `args') has been asserted
     (or inferred by forward chaining).

 -- Function: load-in-module ((filename STRING) (module MODULE)
          (environment ENVIRONMENT)) :
     Read logic commands from the file named FILENAME and evaluate them.
     If the file does not have an `in-module' declaration that
     specifies the module within which all remaining commands are to be
     evaluated, it will be loaded in the MODULE specified.  If no
     MODULE is specified and the file does not contain an `in-module'
     declaration, an error will be signaled.  The remaining commands
     are evaluated one-by-one, applying the function `evaluate' to each
     of them.

 -- Function: load-native-stream-in-module
          ((stream NATIVE-INPUT-STREAM) (module MODULE)
          (environment ENVIRONMENT)) :
     Read logic commands from the native input stream STREAM and
     evaluate them.  Assumes STREAM is a line-buffered stream which is
     a safe compromise but does not generate the best efficiency for
     block-buffered streams such as files.  If the stream does not
     supply an `in-module' declaration that specifies the module within
     which all remaining commands are to be evaluated, it will be
     loaded in the MODULE specified.  If no MODULE is specified and the
     file does not supply an `in-module' declaration, an error will be
     signaled.  The remaining commands are evaluated one-by-one,
     applying the function `evaluate' to each of them.

 -- Function: load-stream-in-module ((stream INPUT-STREAM)
          (module MODULE) (environment ENVIRONMENT)) :
     Read logic commands from the STELLA stream STREAM and evaluate
     them.  If the stream does not supply an `in-module' declaration
     that specifies the module within which all remaining commands are
     to be evaluated, it will be loaded in the MODULE specified.  If no
     MODULE is specified and the file does not supply an `in-module'
     declaration, an error will be signaled.  The remaining commands
     are evaluated one-by-one, applying the function `evaluate' to each
     of them.

 -- Function: main () :
     Main PowerLoom entry point for your code in C++ and Java.

 -- Function: register-computation-function ((name STRING)
          (function-reference FUNCTION-CODE) (arity INTEGER)
          (module MODULE) (environment ENVIRONMENT)) :
     Register NAME as a function name in MODULE which will invoke the
     native code procedure described by `function-reference.'  The NAME
     is a fully-qualified name which will be interpreted by the normal
     rules for reading names in PowerLoom.  The function must conform
     to the signature for computation functions used by the computation
     specialist.  Arity specifies the number of arguments the
     computation accepts.

     The exact form of FUNCTION-REFERENCE depends on the underlying
     programming language.  The following type mappings are used:
        C++:  cpp_function_code (a pointer to the function code)
     Common Lisp:  FUNCTION   (result of #' or (FUNCTION ...))
     Java:  java.lang.reflect.Method

 -- Function: register-specialist-function ((name STRING)
          (function-reference FUNCTION-CODE) (module MODULE)
          (environment ENVIRONMENT)) :
     Register NAME as a function name in MODULE which will invoke the
     native code procedure described by `function-reference.'  The NAME
     is a fully-qualified name which will be interpreted by the normal
     rules for reading names in PowerLoom.  The function must conform
     to the signature for specialist functions.

     The exact form of FUNCTION-REFERENCE depends on the underlying
     programming language.  The following type mappings are used:
        C++:   Common Lisp:  FUNCTION   (result of #' or (FUNCTION ...))
             Java:  java.lang.reflect.Method

 -- Function: s-register-computation-function ((name STRING)
          (native-name STRING) (arity INTEGER) (module-name STRING)
          (environment ENVIRONMENT)) :
     Register NAME as a function name in the module named MODULE-NAME.
     This function will the native code named NATIVE-NAME.  The NAME is
     a fully-qualified name which will be interpreted by the normal
     rules for reading names in PowerLoom.  The NATIVE-NAME will be
     processed in a manner that depends on the underlying programming
     language.  The following type mappings are used:           C++:
     Not available.  Error signaled.    Common Lisp:  The native-name
     is read by READ-FROM-STRING and then                 the
     SYMBOL-FUNCTION is taken.           Java:  A fully
     package-qualified name is required.  It is                 looked
     up using the Reflection tools.  The function found must conform to
     the signature for computation functions.  Arity specifies the
     number of arguments the computation accepts.

 -- Function: s-register-specialist-function ((name STRING)
          (native-name STRING) (module-name STRING)
          (environment ENVIRONMENT)) :
     Register NAME as a function name in the module named MODULE-NAME.
     This function will the native code named NATIVE-NAME.  The NAME is
     a fully-qualified name which will be interpreted by the normal
     rules for reading names in PowerLoom.  The NATIVE-NAME will be
     processed in a manner that depends on the underlying programming
     language.  The following type mappings are used:           C++:
     Not available.  Error signaled.    Common Lisp:  The native-name
     is read by READ-FROM-STRING and then                 the
     SYMBOL-FUNCTION is taken.           Java:  A fully
     package-qualified name is required.  It is                 looked
     up using the Reflection tools.  The function found must conform to
     the signature for specialist functions.

 -- Function: test-environment-level? ((env ENVIRONMENT)
          (level STRING)) : BOOLEAN
     Test if ENV has level set to LEVEL

 -- Method on PL-ITERATOR: consify (self) : CONS
     Convert SELF into a Stella CONS.

 -- Method on PL-ITERATOR: listify (self) : LIST
     Convert SELF into a Stella LIST.

 -- Command: initialize-kernel-kb () :
     Bootstrap the PowerLoom built-in kernel KB.


File: manual.info,  Node: Glossary,  Next: PowerLoom Grammar,  Prev: Miscellaneous,  Up: Top

12 Glossary
***********

This glossary contains brief definitions for terms used in the PowerLoom
User's Manual and/or used by the knowledge representation community.  It
is impractical to give a logically precise definition for many of these
terms, because their interpretation varies quite a bit.  In this case,
the glossary attempts to indicate a range of interpretations consistent
with their use in PowerLoom.

*Assertion:* An assertion states that a particular proposition is
`True' or `False'.

*Backward and Forward Inference:* *???*

*BACKWARD RULE:* *???*

*Binary Relation:* A relation having two arguments (arity equals two),
often as a mapping from one concept domain to another.  This is by far
the most common form of relation.

*Classifier:* A classifier is a type of an inference engine that
implements efficient strategies for computing subsumption relations
between pairs of concepts, or for computing instance-of relations
between a concept an a set of instances.  PowerLoom implements a
classifier that can be explicitly invoked by an application program.

*Clipping:* If a function or single-valued binary relation maps an
instance to two or more other instances, a logical contradiction (a
clash) exists.  If clipping is enabled, PowerLoom will automatically
retract all assertions but the last that lead to a clash.  Clipping can
be toggled on or off; it is enabled by default.

*Closed-World Semantics:* Under closed-world semantics it is assumed
that "if proposition `P' cannot be proved `True', then assume that `P'
is `False'."  PowerLoom gives programmers the option to explicitly
declare that concept or a relation operates under the assumption of
closed-world semantics (See also Open-World Semantics).

*Concept:* A concept defines a category or class of individuals.
PowerLoom categorizes a concept as a special kind of relation.  The
distinction between a concept and a unary relation is subtle (some
logicians do not believe that there is any distinction(1)).  In
linguistics, the distinction is that between a noun and an adjective.
In logic, the test we favor is whether or not the relation has a domain
-- a unary relation has a domain, while a concept does not.  For
example, the relation `married' has domain `person', while the concept
`married-person' does not have a domain (or is its own domain).

*Constraint:* "Constraint" at its most general is a synonym for "rule".
Often a constraint is conceptualized as a rule that restricts the types
of the arguments that can appear within a tuple.

*Context:* *???*

*Default Rule:* A default rule expresses an conditional implication
that applies only when its consequent is consistent with current state
of the knowledge base.  In other words, the rule applies only when it
will not lead to a contradition.

*Definition:* A definition binds a name to a logical expression.
PowerLoom syntax defines several operators with names of the form
`defxxx' (e.g., `defconcept' and `defrule') that declare definitions
for various types of entities.

*Description:* A "description" is an expression that defines a
particular logical relation (e.g., the class of all three-legged black
cats).  In PowerLoom, the terms "concept" and "relation" generally
refer to `named' relations, while a description may or may not have a
name.  The KIF operators `kappa' and `setofall' are used to define
unnamed descriptions.

*Description Logic:* The term "description logic" refers to a logic
that focuses on descriptions as its principal means for expressing
logical expressions.  A description logic system emphasises the use of
classification and subsumption reasoning as its primary mode of
inference.  Loom and Classic were two early examples of knowledge
representation systems that implement description logics.

*Domain Model:* A collection of definitions, rules, and facts that
characterizes the possible states of some real or imagined world.  The
domain model specifies a terminology (of concepts and relations) that
is useful for describing objects in that world.  Often "domain model"
refers to that portion of a world's representation that does not change
over time.

*Extension:* Given a relation `R' with arity `N', the extension of `R'
is the set of ground propositions of the form `(R x1 ... xN)' whose
truth value is true.  If R is a concept, then its extension of often
considered to be, not a set of unary tuples, but the set of argument
fillers of those tuples, i.e., the set of instances that belong to the
concept.

*Fact:* A fact is a proposition that has been asserted to be either
`True' or `False'.  The term "fact" usually refers to a "ground
proposition", i.e., a proposition that can be represented as a
predicate applied to a sequence of instances or literals.

*Filler:* The second argument to a binary tuple is often refered to as
its "filler".  When a multiple-valued binary relation maps an instance
to a set of values, these values are also called "fillers".

*Forward Rule:* *???*

*Function:* Formally, a function is a relation such that the   value of
the last (nth) argument of a relational tuple is a function of the
values of the first n-1 arguments.  This definition coincides with the
notion of a "single-valued relation".  PowerLoom (and KIF) support
specialized syntax that allows functions that have been defined using
the operator `deffunction' to appear in term expressions (e.g., `(= (f
?x) 42))').

*Instance:* An instance denotes an entity within a domain model, a
member of the concept _Thing_.  Depending on ones interpretation, this
could include almost everything.  Often the term "instance" is used
more narrowly, to exclude literals and other objects whose properties
do not change over time.  PowerLoom assumes that concepts and relations
are instances.

*KIF:* Short for "Knowledge Interchange Format",  KIF is a language
that defines a Lisp-like syntax for the predicate calculus.  There is
an ANSII-standard that defines the KIF syntax and semantics.  PowerLoom
adopts KIF as its representation language, and adds a few extensions.

*Knowledge Base:* A knowledge base attempts to capture in abstract
(machine interpretable) form a useful representation of a physical or
virtual world. The entities in that world are modeled in the knowledge
base by objects we call _ terms_. Examples of terms are "Georgia"
(denoting the U.S., state), "BenjaminFranklin" (denoting the historical
person by that name), the number three, the string "abc", and the
concept "Person".

*Literal:* A logically static constant.  Examples are numbers, strings,
quantities, and truth values.

*Module:* *???*

*Open-World Semantics:* PowerLoom assumes an open-world semantics,
unless a user explicitly specifies that it use closed-world semantics.
Under this assumption, if PowerLoom cannot prove or disprove a
proposition, then it assigns that proposition the value `Unknown' (See
also Closed-World Semantics).

*Predicate:*.  The term _predicate_ is a syntactic notion that refers
to the zeroth arguments of a proposition.  Predicates denote relations
and properties, i.e., sets.

*Proposition:*.  A logical sentence whose truth value can be evaluated
with respect to some context.  Each PowerLoom assertion assigns the
value `True' or `False' to some proposition.

*Primitive Relation:* `P' is a primitive concept or relation if and
only if a proof that `(P x1 ... xn)' is true exists only for the case
that there exists an explicit assertion of a proposition `(Q x1 ...
xn)' and either `Q' equals `P' or `Q' is a proper subrelation of `P'.
In otherwords, the only rules that imply membership in `P' are those
that relate `P' to one of its (proper) subconcepts or subrelations.

*Query:* A query probes the informational state of a knowledge base.
An `ask' query test the truth of its propositional argument.  A
`retrieve' asks for sets of constants (bindings) that make its
propositional argument true when the constants are substituted in place
of its variables.  The propositional argument to `ask' and `retrieve'
arbitrary expression in the first-order predicate calculus.  Because of
constraints imposed either by resource limitations or inherent
undecidability, PowerLoom cannot guarantee the completeness of its
inferences.

*Relation:* *???*

*Retraction:* A retraction changes the truth value of a proposition
from either `True' or `False' to the value `Unknown'.  Retraction is a
procedural (non-declarative) operation.

*Rule:* A "rule" is any universally-quantified proposition, i.e., a
proposition of the form `(forall (?x1 ... ?xn) <logical sentence with
free variables ?x1 ... ?xn)'.  PowerLoom supports several different
syntactic constructs for defining rules.  (See also Forward Rule and
Backward Rule).

*Subsumption:* A subsumption relation specifies the relative generality
of two concepts.  A concept `A' subsumes a concept `B' if the
definitions of `A' and `B' logically imply that members of `B' must
also be members of `A'.

*Truth-Maintenance:* *???*

*Type:* Often used a synonym for the term _concept_.  The phrase "a
type of an instance" generally refers to (one of) the concepts that the
instance belongs to.  The phrase "nth domain type" refers to a concept
that contains all instances of the nth column of a relation.

*World:* *???*

   ---------- Footnotes ----------

   (1) but they are mistaken :).


File: manual.info,  Node: PowerLoom Grammar,  Next: Function Index,  Prev: Glossary,  Up: Top

13 PowerLoom Grammar
********************

The syntax of PowerLoom is described below using a modified BNF notation
adapted from the KIF specification.

* Menu:

* Alphabet::
* Grammar::


File: manual.info,  Node: Alphabet,  Next: Grammar,  Prev: PowerLoom Grammar,  Up: PowerLoom Grammar

13.1 Alphabet
=============

We distinguish between terminals, which are part of the language, and
nonterminals. All nonterminals are bracketed as follows
`<nonterminal>'. Squared brackets means zero or one instances of the
enclosed expression; `<nonterminal>*' means zero or more occurrences
and `<nonterminal>+' means one or more occurrences of `<nonterminal>'.
The notation `<nonterminal1> - <nonterminal2>' refers to all of the
members of `<nonterminal1>' except for those in `<nonterminal2>'.

   A word is a contiguous sequence of characters, which include all
upper case letters, lower case letters, digits and alpha characters
(ASCII character set from 93 to 128) excluding some special characters
like white spaces, single and double quotes and brackets.

   `<word> ::=' A PRIMITIVE SYNTACTIC OBJECT

   Special words are those who refer to a variable. All variables are
preceded by a question mark.

   `<indvar> ::=' A WORD BEGINNING WITH THE CHARACTER `?'

   A string `<string>' is a character sequence including words plus all
special charcters (except double quotes) enclosed in double quotes.  A
double quote can be included in a string if it is preceeded by the
escape character '`\''.


File: manual.info,  Node: Grammar,  Prev: Alphabet,  Up: PowerLoom Grammar

13.2 Grammar
============

Legal expressions in PowerLoom are forms, which are either a statement
or a definition, described in more detail below.

   `<form> ::= <statement> | <definition>'

* Menu:

* Constants and Typed Variables::
* Terms::
* Sentences::
* Definitions::


File: manual.info,  Node: Constants and Typed Variables,  Next: Terms,  Prev: Grammar,  Up: Grammar

13.2.1 Constants and Typed Variables
------------------------------------

The language consists of several groups of operators, defined as
follows:

   `<termop> ::= listof | setof | the | setofall | kappa'

   ` <sentop> ::= = | /= | not | and | or | forall | exists
| <= | => | <=> |<<= | =>> | <~ | ~> | <<~ | ~>> '

   ` <defop> ::= defconcept | deffunction | defrelation | defrule |
:documentation | :-> |
:<= | :=> | :<<= | :=>> |
:<=> | :<=>> :<<=> | :<<=>> | := |
:axioms '

   `<operator> ::= <termop> | <sentop> | <defop>'

   All other words are constants (words which are not operators or
variables):

   `<constant> ::= <word> - <indvar> - <operator>'

   Semantically, there are different categories of constants --
_Concept_ constants `<conceptconst>', _Function_ constants
`<funconst>', _Relation_ constants `<relconst>', _Rule_ constants
`<ruleconst>' and _Logical_ constants `<logconst>'. The differences
between these categories are entirely semantic. However, some operators
will only accept specific constants.

   In contrast to the specification of KIF3.0, PowerLoom supports a
typed syntax. Therefore, variables in quantified terms and sentences
can appear either typed or untyped, as follows:

   `<vardecl> ::= (<indvar> <constant>) | <indvar>'


File: manual.info,  Node: Terms,  Next: Sentences,  Prev: Constants and Typed Variables,  Up: Grammar

13.2.2 Terms
------------

Terms are used to denote objects in the world being described:

   ` <term> ::= <indvar> | <constant> | <funterm> | <listterm> |
<setterm> |
<quanterm>'

   `<listterm> ::= (listof <term>*)'

   `<setterm> ::= (setof <term>*)'

   `<funterm> ::= (<funconst> <term>+)'

   Note: Zero arguments are allowed for `<funterm>' in KIF3.0: `<term>*'

   ` <quanterm> ::= (the <vardecl> <sentence>) |
(setofall <vardecl> <sentence>) |
(kappa {<vardecl> | (<vardecl>+)} <sentence>) |
(lambda {<vardecl> | (<vardecl>+)} <term>) '

   Note: KIF3.0 allows `<term>' instead of `<vardecl>' for `setofall'.
No `<quanterm>' as well as no `<setterm>' in core of KIF as a result of
descision 95-3 (March 1995).


File: manual.info,  Node: Sentences,  Next: Definitions,  Prev: Terms,  Up: Grammar

13.2.3 Sentences
----------------

Sentences are used to express propositions about the world:

   ` <sentence> ::= <constant> | <equation> | <inequality> |
<relsent> | <logsent> | <quantsent> '

   `<equation> ::= (= <term> <term>)'

   `<inequality> ::= (/= <term> <term>)'

   `<relsent> ::= (<constant> <term>+)'

   Note: Zero arguments allowed in KIF3.0 for `<relsent>' (`<term>*').
`<funconst>' is currently not allowed in PowerLoom (use `(= <funterm>
<term>)' instead).

   ` <logsent> ::= (not <sentence>) |
(and <sentence>*) |
(or <sentence>*) |
(=> <sentence>* <sentence>) | (=>> <sentence>* <sentence>) |
(<= <sentence> <sentence>*) | (<<= <sentence> <sentence>*) |
(~> <sentence>* <sentence>) | (~>> <sentence>* <sentence>) |
(<~ <sentence> <sentence>*) | (<<~ <sentence> <sentence>*) '

   ` <quantsent> ::= (forall {<vardecl> | (<vardecl>+)} <sentence>) |
(forall {<vardecl> | (<vardecl>+)} <sentence> <sentence>) |
(exists {<vardecl> | (<vardecl>+)} <sentence>) '


File: manual.info,  Node: Definitions,  Prev: Sentences,  Up: Grammar

13.2.4 Definitions
------------------

PowerLoom supports two distinct categories of definitions -- relation
definitions (including concept and function definitions) and rule
definitions.  A relation definition introduces a new logical constant,
and states some facts about that constant (e.g., who its parents are in
a subsumption taxonomy).  A rule definitions binds a new constant to a
proposition (so that the constant _denotes_ the proposition) and
asserts the truth of that proposition.  Usually, the proposition
asserted by a `defrule' is an implication.  The assertional truth of a
proposition defined by a rule can be altered by asserting or retracting
the constant that denotes the proposition.

     <keyword-option> ::= <keyword> <word>
     <definition> ::= <reldefinition> | <objdefinition> | <ruledefinition>

     <reldefinition> ::=
      (defconcept <conceptconst> <vardecl>
         [:documentation <string>]
         [:<= <sentence>] | [:=> <sentence>] |
         [:<<= <sentence>] | [:=>> <sentence>] |
         [:<=> <sentence>] | [:<=>> <sentence>] | [:<<=> <sentence>] |
         [:<<=>> <sentence>] |
         [:axioms {<sentence> | (<sentence>+)}] |
         [<keyword-option>*])
      |
      (deffunction <funconst> (<vardecl>+)
         [:documentation <string>]
         [:-> <vardecl>]
         [:<= <sentence>] | [:=> <sentence>] |
         [:<<= <sentence>] | [:=>> <sentence>] |
         [:<=> <sentence>] | [:<=>> <sentence>] | [:<<=> <sentence>] |
         [:<<=>> <sentence>] |
         [:axioms {<sentence> | (<sentence>+)}]
         [<keyword-option>*])
      |
      (defrelation <relconst> (<vardecl>+)
         [:documentation <string>]
         [:<= <sentence>] | [:=> <sentence>] |
         [:<<= <sentence>] | [:=>> <sentence>] |
         [:<=> <sentence>] | [:<=>> <sentence>] | [:<<=> <sentence>] |
         [:<<=>> <sentence>] |
         [:axioms {<sentence> | (<sentence>+)}]
         [<keyword-option>*])

     <objdefinition> ::= (defobject <constant>
                            [:documentation <string>]
                            [<keyword-option>*])

     <ruledefinition> ::= (defrule <constant> <sentence>
                            [:documentation <string>]
                            [<keyword-option>*])

   `<ruledefinition> ::= (defrule <ruleconst> <sentence>)'


File: manual.info,  Node: Function Index,  Next: Variable Index,  Prev: PowerLoom Grammar,  Up: Top

Function Index
**************

 [index ]
* Menu:

* *:                                     Built-In Relations. (line   12)
* +:                                     Built-In Relations. (line   15)
* -:                                     Built-In Relations. (line   18)
* /:                                     Built-In Relations. (line   21)
* 2_d_element on 2_D_ARRAY:              Miscellaneous.      (line   13)
* 2_d_element on 2_D_FLOAT-ARRAY:        Miscellaneous.      (line   17)
* 2_d_element-setter on 2_D_ARRAY:       Miscellaneous.      (line   21)
* 2_d_element-setter on 2_D_FLOAT-ARRAY: Miscellaneous.      (line   26)
* <:                                     Built-In Relations. (line   24)
* =<:                                    Built-In Relations. (line   27)
* >:                                     Built-In Relations. (line   30)
* >=:                                    Built-In Relations. (line   33)
* ABSTRACT:                              Built-In Relations. (line   36)
* add-load-path:                         Commands.           (line   60)
* add-testing-example:                   Miscellaneous.      (line   31)
* add-training-example:                  Miscellaneous.      (line   35)
* AGGREGATE:                             Built-In Relations. (line   39)
* all-asserted-types:                    Miscellaneous.      (line   40)
* all-class-instances:                   Miscellaneous.      (line   44)
* all-cycles:                            Miscellaneous.      (line   48)
* all-direct-subrelations:               Miscellaneous.      (line   53)
* all-direct-superrelations:             Miscellaneous.      (line   59)
* all-direct-types:                      Miscellaneous.      (line   64)
* all-equivalent-relations:              Miscellaneous.      (line   68)
* all-facts-of:                          Commands.           (line   16)
* all-facts-of-instance:                 Miscellaneous.      (line   74)
* all-facts-of-n:                        Miscellaneous.      (line   79)
* all-inconsistent-propositions:         Miscellaneous.      (line  102)
* all-instances:                         Miscellaneous.      (line  108)
* all-named-descriptions:                Miscellaneous.      (line  114)
* all-named-instances:                   Miscellaneous.      (line  120)
* all-named-terms:                       Miscellaneous.      (line  127)
* all-propositions:                      Miscellaneous.      (line  134)
* all-relation-values:                   Miscellaneous.      (line  140)
* all-sentences-of:                      Miscellaneous.      (line  145)
* all-slot-value-types:                  Miscellaneous.      (line  149)
* all-slot-values:                       Miscellaneous.      (line  154)
* all-subrelations:                      Miscellaneous.      (line  159)
* all-superrelations:                    Miscellaneous.      (line  163)
* all-taxonomic-types:                   Miscellaneous.      (line  167)
* all-terms:                             Miscellaneous.      (line  172)
* all-types:                             Miscellaneous.      (line  178)
* all-unnamed-terms:                     Miscellaneous.      (line  182)
* allocate-supported-closure-iterator:   Miscellaneous.      (line  190)
* allocate-transitive-closure-iterator:  Miscellaneous.      (line  196)
* ANTISYMMETRIC:                         Built-In Relations. (line   42)
* apply-ask:                             Miscellaneous.      (line  203)
* apply-kappa?:                          Miscellaneous.      (line  210)
* apply-retrieve:                        Miscellaneous.      (line  216)
* ARITY:                                 Built-In Relations. (line   46)
* ask <1>:                               API Functions.      (line   30)
* ask:                                   Commands.           (line   78)
* ask-partial:                           Miscellaneous.      (line  226)
* assert:                                Commands.           (line  106)
* assert-binary-proposition:             API Functions.      (line   56)
* assert-from-query:                     Commands.           (line  115)
* assert-nary-proposition:               API Functions.      (line   61)
* assert-proposition:                    API Functions.      (line   66)
* assert-rule:                           Commands.           (line  161)
* assert-unary-proposition:              API Functions.      (line   72)
* ASSERTION-QUERY:                       Built-In Relations. (line   49)
* BACKTRACKING-QUERY:                    Built-In Relations. (line   53)
* BINARY-RELATION:                       Built-In Relations. (line   58)
* bottom?:                               Miscellaneous.      (line  232)
* BOUND-VARIABLES:                       Built-In Relations. (line   61)
* call-all-facts-of:                     Miscellaneous.      (line  236)
* call-ask:                              Miscellaneous.      (line  240)
* call-defconcept:                       Miscellaneous.      (line  246)
* call-deffunction:                      Miscellaneous.      (line  250)
* call-defobject:                        Miscellaneous.      (line  254)
* call-defproposition:                   Miscellaneous.      (line  258)
* call-defrelation:                      Miscellaneous.      (line  263)
* call-list-undefined-relations:         Miscellaneous.      (line  268)
* call-propagate-constraints:            Miscellaneous.      (line  271)
* call-retrieve:                         Miscellaneous.      (line  275)
* call-retrieve-partial:                 Miscellaneous.      (line  282)
* call-run-forward-rules:                Miscellaneous.      (line  290)
* call-set-inference-level:              Miscellaneous.      (line  298)
* CARDINALITY:                           Built-In Relations. (line   73)
* cc:                                    Commands.           (line  167)
* change-module:                         API Functions.      (line   76)
* class?:                                Miscellaneous.      (line  304)
* classify-instances:                    Commands.           (line  190)
* classify-relations:                    Commands.           (line  173)
* clear-caches <1>:                      API Functions.      (line   81)
* clear-caches:                          Commands.           (line  207)
* clear-instances:                       Commands.           (line  210)
* clear-module <1>:                      API Functions.      (line   84)
* clear-module:                          Commands.           (line  216)
* CLOSED:                                Built-In Relations. (line   76)
* coerce-to-instance:                    Miscellaneous.      (line  308)
* coerce-to-instance-or-literal:         Miscellaneous.      (line  312)
* coerce-to-vector:                      Miscellaneous.      (line  316)
* COLLECT-INTO-ASCENDING-SET:            Built-In Relations. (line   89)
* COLLECT-INTO-DESCENDING-SET:           Built-In Relations. (line  102)
* COLLECT-INTO-LIST:                     Built-In Relations. (line  114)
* COLLECT-INTO-ORDERED-SET:              Built-In Relations. (line  122)
* COLLECT-INTO-SET:                      Built-In Relations. (line  127)
* collection?:                           Miscellaneous.      (line  320)
* COLLECTIONOF:                          Built-In Relations. (line  150)
* COMMENT:                               Built-In Relations. (line  153)
* COMMUTATIVE:                           Built-In Relations. (line  157)
* conceive <1>:                          API Functions.      (line   89)
* conceive:                              Commands.           (line  222)
* conceive-term:                         Miscellaneous.      (line  323)
* CONCEPT:                               Built-In Relations. (line  161)
* CONCEPT-PROTOTYPE:                     Built-In Relations. (line  171)
* conjoin-truth-values:                  Miscellaneous.      (line  330)
* cons-to-pl-iterator:                   API Functions.      (line  101)
* consify on JUSTIFICATION:              Miscellaneous.      (line  333)
* consify on PL-ITERATOR:                Miscellaneous.      (line 1417)
* consify on QUERY-ITERATOR:             Miscellaneous.      (line  341)
* consify on QUERY-SOLUTION-TABLE:       Miscellaneous.      (line  346)
* consify-current-solutions on QUERY-ITERATOR: Miscellaneous.
                                                             (line  350)
* consify-justification:                 Miscellaneous.      (line  356)
* constant?:                             Miscellaneous.      (line  366)
* copy on JUSTIFICATION:                 Miscellaneous.      (line  369)
* copyright:                             Commands.           (line  234)
* COVERING:                              Built-In Relations. (line  193)
* create:                                Miscellaneous.      (line  375)
* create-2_d_array:                      Miscellaneous.      (line  380)
* create-2_d_float-array:                Miscellaneous.      (line  387)
* create-concept:                        API Functions.      (line  105)
* create-enumerated-list:                API Functions.      (line  117)
* create-enumerated-set:                 API Functions.      (line  123)
* create-float-vector:                   Miscellaneous.      (line  393)
* create-function:                       API Functions.      (line  128)
* create-keyword:                        Miscellaneous.      (line 1273)
* create-marker-storage:                 Miscellaneous.      (line  397)
* create-module:                         API Functions.      (line  138)
* create-object:                         API Functions.      (line  144)
* create-relation:                       API Functions.      (line  165)
* create-symbol:                         Miscellaneous.      (line 1279)
* create-vector:                         Miscellaneous.      (line  403)
* current-inference-level:               Miscellaneous.      (line  406)
* CUT:                                   Built-In Relations. (line  197)
* default-false?:                        Miscellaneous.      (line  410)
* default-true?:                         Miscellaneous.      (line  413)
* default-truth-value?:                  Miscellaneous.      (line  416)
* defconcept:                            Commands.           (line  237)
* deffunction:                           Commands.           (line  260)
* define-arithmetic-operation-on-wrappers: Miscellaneous.    (line  420)
* define-arithmetic-test-on-wrappers:    Miscellaneous.      (line  434)
* define-computed-constraint:            Miscellaneous.      (line  442)
* definstance:                           Commands.           (line  279)
* defmodule:                             Commands.           (line  283)
* defobject:                             Commands.           (line  377)
* defproposition:                        Commands.           (line  393)
* defrelation:                           Commands.           (line  424)
* defrule:                               Commands.           (line  446)
* delete-rules:                          Commands.           (line  450)
* demo:                                  Commands.           (line  455)
* deny:                                  Commands.           (line  466)
* deobjectify-tree:                      Miscellaneous.      (line  460)
* describe:                              Commands.           (line  473)
* describe-object on NAMED-DESCRIPTION:  Miscellaneous.      (line  466)
* description-name on DESCRIPTION:       Miscellaneous.      (line  473)
* description-name on NAMED-DESCRIPTION: Miscellaneous.      (line  470)
* destroy:                               Commands.           (line  477)
* destroy-instance:                      Miscellaneous.      (line  476)
* destroy-object <1>:                    Miscellaneous.      (line  480)
* destroy-object:                        API Functions.      (line  174)
* destroy-proposition:                   Miscellaneous.      (line  486)
* destroy-term:                          Miscellaneous.      (line  491)
* DIRECT-SUBRELATION:                    Built-In Relations. (line  201)
* DIRECT-SUPERRELATION:                  Built-In Relations. (line  207)
* direct-superrelations:                 Miscellaneous.      (line  497)
* disabled-powerloom-feature?:           Miscellaneous.      (line  500)
* disjoin-truth-values:                  Miscellaneous.      (line  504)
* DISJOINT:                              Built-In Relations. (line  212)
* DISJOINT-COVERING:                     Built-In Relations. (line  215)
* disjoint-terms?:                       Miscellaneous.      (line  508)
* do-clear-instances:                    Miscellaneous.      (line  511)
* do-save-module:                        Miscellaneous.      (line  514)
* DOCUMENTATION:                         Built-In Relations. (line  222)
* DOMAIN:                                Built-In Relations. (line  227)
* drop-load-path:                        Commands.           (line  484)
* DUPLICATE-FREE:                        Built-In Relations. (line  234)
* DUPLICATE-FREE-COLLECTION:             Built-In Relations. (line  237)
* EMPTY:                                 Built-In Relations. (line  240)
* empty? on FLOAT-VECTOR:                Miscellaneous.      (line  521)
* empty? on PL-ITERATOR:                 API Functions.      (line  177)
* empty? on QUERY-SOLUTION-TABLE:        Miscellaneous.      (line  518)
* enabled-powerloom-feature?:            Miscellaneous.      (line  524)
* EQUIVALENT-RELATION:                   Built-In Relations. (line  246)
* estimated-length on PAGING-INDEX:      Miscellaneous.      (line  527)
* evaluate <1>:                          API Functions.      (line  181)
* evaluate:                              Command Interpreter.
                                                             (line   33)
* evaluate-proposition:                  Miscellaneous.      (line  531)
* evaluate-string:                       Command Interpreter.
                                                             (line   41)
* evaluation-state:                      Miscellaneous.      (line  535)
* evaluation-state-setter:               Miscellaneous.      (line  541)
* EXAMPLE:                               Built-In Relations. (line  251)
* explain-why:                           Miscellaneous.      (line  545)
* explain-whynot:                        Miscellaneous.      (line  550)
* false-truth-value?:                    Miscellaneous.      (line  553)
* false?:                                Miscellaneous.      (line  556)
* fetch-instance on OBJECT-STORE:        Miscellaneous.      (line  561)
* fetch-relation on OBJECT-STORE:        Miscellaneous.      (line  568)
* FIFTH-ELEMENT:                         Built-In Relations. (line  254)
* fill-array on 2_D_ARRAY:               Miscellaneous.      (line  573)
* fill-array on 2_D_FLOAT-ARRAY:         Miscellaneous.      (line  578)
* FILLERS:                               Built-In Relations. (line  257)
* finalize-objects:                      Miscellaneous.      (line  583)
* find-direct-supers-and-subs:           Miscellaneous.      (line  589)
* find-direct-supers-of-instance:        Miscellaneous.      (line  598)
* find-instance:                         Miscellaneous.      (line  602)
* find-rule:                             Miscellaneous.      (line  608)
* FIRST-ELEMENT:                         Built-In Relations. (line  263)
* FORK:                                  Built-In Relations. (line  267)
* FOURTH-ELEMENT:                        Built-In Relations. (line  271)
* FRAME-PREDICATE:                       Built-In Relations. (line  274)
* function?:                             Miscellaneous.      (line  612)
* generate-expression:                   Miscellaneous.      (line  616)
* generate-specialized-term on LOGIC-THING: Miscellaneous.   (line  619)
* generate-unique-name:                  API Functions.      (line  190)
* get-arity:                             API Functions.      (line  196)
* get-binary-proposition:                API Functions.      (line  201)
* get-binary-propositions:               API Functions.      (line  211)
* get-child-modules:                     API Functions.      (line  218)
* get-class:                             Miscellaneous.      (line  625)
* get-column-count:                      API Functions.      (line  221)
* get-concept:                           API Functions.      (line  232)
* get-concept-instance-matching-value:   API Functions.      (line  239)
* get-concept-instances:                 API Functions.      (line  245)
* get-concept-instances-matching-value:  API Functions.      (line  253)
* get-current-module:                    API Functions.      (line  258)
* get-direct-concept-instances:          API Functions.      (line  262)
* get-direct-subrelations:               API Functions.      (line  269)
* get-direct-superrelations:             API Functions.      (line  274)
* get-direct-types:                      API Functions.      (line  278)
* get-domain:                            API Functions.      (line  281)
* get-enumerated-collection-members:     API Functions.      (line  286)
* get-forward-justifications:            Miscellaneous.      (line  632)
* get-home-module:                       API Functions.      (line  290)
* get-inferred-binary-proposition-values: API Functions.     (line  295)
* get-instance:                          Miscellaneous.      (line  635)
* get-keyword:                           Miscellaneous.      (line 1285)
* get-load-path:                         Commands.           (line  488)
* get-module <1>:                        Miscellaneous.      (line  641)
* get-module:                            API Functions.      (line  300)
* get-modules:                           API Functions.      (line  304)
* get-name:                              API Functions.      (line  309)
* get-name-in-module:                    Miscellaneous.      (line 1289)
* get-nth-domain:                        API Functions.      (line  314)
* get-nth-float:                         API Functions.      (line  322)
* get-nth-integer:                       API Functions.      (line  338)
* get-nth-logic-object:                  API Functions.      (line  354)
* get-nth-string:                        API Functions.      (line  371)
* get-nth-value:                         API Functions.      (line  388)
* get-object:                            API Functions.      (line  406)
* get-operator:                          API Functions.      (line  400)
* get-parent-modules:                    API Functions.      (line  411)
* get-predicate:                         API Functions.      (line  414)
* get-proper-subrelations:               API Functions.      (line  419)
* get-proper-superrelations:             API Functions.      (line  424)
* get-proposition:                       API Functions.      (line  428)
* get-propositions:                      API Functions.      (line  440)
* get-propositions-in-module:            API Functions.      (line  448)
* get-propositions-of:                   API Functions.      (line  453)
* get-range:                             API Functions.      (line  457)
* get-relation <1>:                      Miscellaneous.      (line  644)
* get-relation:                          API Functions.      (line  462)
* get-relation-extension:                API Functions.      (line  468)
* get-rules <1>:                         API Functions.      (line  473)
* get-rules:                             Commands.           (line  491)
* get-self-or-prototype:                 Miscellaneous.      (line  651)
* get-short-name:                        Miscellaneous.      (line 1293)
* get-slot-maximum-cardinality:          Miscellaneous.      (line  657)
* get-slot-minimum-cardinality:          Miscellaneous.      (line  662)
* get-slot-value:                        Miscellaneous.      (line  667)
* get-slot-value-type:                   Miscellaneous.      (line  672)
* get-symbol:                            Miscellaneous.      (line 1298)
* get-types:                             API Functions.      (line  478)
* get-why-justification:                 Miscellaneous.      (line  676)
* get-whynot-justifications:             Miscellaneous.      (line  686)
* GOES-FALSE-DEMON:                      Built-In Relations. (line  312)
* GOES-TRUE-DEMON:                       Built-In Relations. (line  318)
* GOES-UNKNOWN-DEMON:                    Built-In Relations. (line  324)
* has-forward-justifications?:           Miscellaneous.      (line  692)
* help:                                  Commands.           (line  494)
* help-print-outline on DESCRIPTION:     Miscellaneous.      (line  702)
* help-print-outline on NAMED-DESCRIPTION: Miscellaneous.    (line  697)
* HOLDS:                                 Built-In Relations. (line  329)
* IMAGE-URL:                             Built-In Relations. (line  348)
* in-dialect:                            Miscellaneous.      (line  705)
* in-module:                             Commands.           (line  497)
* inconsistent-truth-value?:             Miscellaneous.      (line  711)
* inconsistent?:                         Miscellaneous.      (line  714)
* INEQUALITY:                            Built-In Relations. (line  354)
* initialize:                            API Functions.      (line  481)
* initialize-kernel-kb:                  Miscellaneous.      (line 1423)
* insert-at on QUERY-SOLUTION-TABLE:     Miscellaneous.      (line  718)
* INSERT-ELEMENT:                        Built-In Relations. (line  358)
* INSTANCE-OF:                           Built-In Relations. (line  364)
* INVERSE:                               Built-In Relations. (line  369)
* invert-truth-value:                    Miscellaneous.      (line  724)
* IRREFLEXIVE:                           Built-In Relations. (line  385)
* is-a:                                  API Functions.      (line  487)
* is-default:                            API Functions.      (line  490)
* is-enumerated-collection:              API Functions.      (line  493)
* is-enumerated-list:                    API Functions.      (line  497)
* is-enumerated-set:                     API Functions.      (line  500)
* is-false:                              API Functions.      (line  503)
* is-float:                              API Functions.      (line  507)
* is-inconsistent:                       API Functions.      (line  510)
* is-integer:                            API Functions.      (line  513)
* is-known:                              Miscellaneous.      (line 1302)
* is-logic-object:                       API Functions.      (line  516)
* is-number:                             API Functions.      (line  519)
* is-strict:                             API Functions.      (line  524)
* is-string:                             API Functions.      (line  527)
* is-subrelation:                        API Functions.      (line  531)
* is-true:                               API Functions.      (line  534)
* is-true-binary-proposition:            API Functions.      (line  540)
* is-true-proposition:                   API Functions.      (line  545)
* is-true-proposition1:                  Miscellaneous.      (line 1306)
* is-true-unary-proposition:             API Functions.      (line  550)
* is-unknown:                            API Functions.      (line  554)
* ISSUE:                                 Built-In Relations. (line  389)
* IST:                                   Built-In Relations. (line  393)
* iterator-to-pl-iterator:               API Functions.      (line  557)
* known-truth-value?:                    Miscellaneous.      (line  727)
* LENGTH:                                Built-In Relations. (line  408)
* length on PL-ITERATOR:                 API Functions.      (line  560)
* length on QUERY-SOLUTION-TABLE:        Miscellaneous.      (line  731)
* LENGTH-OF-LIST:                        Built-In Relations. (line  412)
* LEXEME:                                Built-In Relations. (line  415)
* LIST-CONCATENATE:                      Built-In Relations. (line  431)
* list-features:                         Miscellaneous.      (line  734)
* list-modules:                          Commands.           (line  500)
* list-to-pl-iterator:                   API Functions.      (line  563)
* list-unclassified-instances:           Miscellaneous.      (line  739)
* list-unclassified-relations:           Miscellaneous.      (line  745)
* list-undefined-relations:              Miscellaneous.      (line  751)
* listify on PL-ITERATOR:                Miscellaneous.      (line 1420)
* listify on QUERY-ITERATOR:             Miscellaneous.      (line  758)
* LISTOF:                                Built-In Relations. (line  436)
* load <1>:                              API Functions.      (line  566)
* load:                                  Commands.           (line  505)
* load-cmd-line-files:                   Miscellaneous.      (line  761)
* load-directory:                        Miscellaneous.      (line  768)
* load-file:                             Commands.           (line  520)
* load-in-module:                        Miscellaneous.      (line 1311)
* load-native-stream:                    API Functions.      (line  582)
* load-native-stream-in-module:          Miscellaneous.      (line 1323)
* load-stream <1>:                       Miscellaneous.      (line  772)
* load-stream:                           API Functions.      (line  574)
* load-stream-in-module:                 Miscellaneous.      (line  776)
* logic-class?:                          Miscellaneous.      (line  784)
* logic-form-less?:                      Miscellaneous.      (line  789)
* logic-module?:                         Miscellaneous.      (line  795)
* lookup on QUERY-SOLUTION-TABLE:        Miscellaneous.      (line  801)
* lookup-native-computation:             Miscellaneous.      (line  806)
* lookup-native-specialist:              Miscellaneous.      (line  813)
* main:                                  Miscellaneous.      (line 1346)
* MAXIMUM-ELEMENT:                       Built-In Relations. (line  447)
* MAXIMUM-VALUE:                         Built-In Relations. (line  452)
* MEAN-VALUE:                            Built-In Relations. (line  455)
* MEDIAN-VALUE:                          Built-In Relations. (line  458)
* MEMBER-OF:                             Built-In Relations. (line  461)
* MINIMUM-ELEMENT:                       Built-In Relations. (line  467)
* MINIMUM-VALUE:                         Built-In Relations. (line  472)
* MUTUALLY-DISJOINT-COLLECTION:          Built-In Relations. (line  475)
* NAME-TO-OBJECT:                        Built-In Relations. (line  484)
* named-description?:                    Miscellaneous.      (line  818)
* natural-deduction-mode?:               Miscellaneous.      (line  822)
* next? on PL-ITERATOR:                  API Functions.      (line  592)
* non-empty? on FLOAT-VECTOR:            Miscellaneous.      (line  828)
* non-empty? on QUERY-SOLUTION-TABLE:    Miscellaneous.      (line  825)
* NORMAL-QUERY:                          Built-In Relations. (line  495)
* nth on QUERY-SOLUTION-TABLE:           Miscellaneous.      (line  832)
* NTH-DOMAIN:                            Built-In Relations. (line  499)
* NTH-ELEMENT:                           Built-In Relations. (line  503)
* NTH-HEAD:                              Built-In Relations. (line  509)
* NTH-REST:                              Built-In Relations. (line  513)
* NUMERIC-MAXIMUM:                       Built-In Relations. (line  517)
* NUMERIC-MINIMUM:                       Built-In Relations. (line  522)
* NUMERIC-SET:                           Built-In Relations. (line  526)
* object-name:                           Miscellaneous.      (line  835)
* OBJECT-NAME:                           Built-In Relations. (line  529)
* object-name-string:                    Miscellaneous.      (line  838)
* object-surrogate:                      Miscellaneous.      (line  841)
* object-surrogate-setter:               Miscellaneous.      (line  847)
* object-to-float:                       API Functions.      (line  596)
* object-to-integer:                     API Functions.      (line  600)
* object-to-parsable-string:             API Functions.      (line  605)
* object-to-string:                      API Functions.      (line  610)
* ORDERED:                               Built-In Relations. (line  533)
* PHRASE:                                Built-In Relations. (line  537)
* pop on QUERY-SOLUTION-TABLE:           Miscellaneous.      (line  850)
* pop-load-path:                         Commands.           (line  527)
* post-for-evaluation:                   Miscellaneous.      (line  854)
* powerloom:                             Miscellaneous.      (line  857)
* powerloom-gui-exit-hook:               Miscellaneous.      (line  862)
* powerloom-information:                 Miscellaneous.      (line  865)
* presume:                               Commands.           (line  531)
* pretty-print-logical-form:             Miscellaneous.      (line  870)
* print-array on 2_D_ARRAY:              Miscellaneous.      (line  875)
* print-array on 2_D_FLOAT-ARRAY:        Miscellaneous.      (line  879)
* print-extension-sizes:                 Miscellaneous.      (line  883)
* print-facts:                           Miscellaneous.      (line  888)
* print-features:                        Commands.           (line  537)
* print-goal-stack:                      Miscellaneous.      (line  893)
* print-logical-form:                    Miscellaneous.      (line  898)
* print-logical-form-in-dialect:         Miscellaneous.      (line  904)
* print-rules <1>:                       API Functions.      (line  613)
* print-rules:                           Commands.           (line  541)
* print-unformatted-logical-form:        Miscellaneous.      (line  910)
* print-whynot-justification:            Miscellaneous.      (line  917)
* process-definitions:                   Commands.           (line  544)
* PROJECT-COLUMN:                        Built-In Relations. (line  548)
* propagate-constraints:                 Commands.           (line  556)
* PROPER-SUBRELATION:                    Built-In Relations. (line  552)
* PROPER-SUPERRELATION:                  Built-In Relations. (line  557)
* PROPOSITION-ARGUMENT:                  Built-In Relations. (line  584)
* PROPOSITION-ARGUMENTS:                 Built-In Relations. (line  587)
* PROPOSITION-ARITY:                     Built-In Relations. (line  590)
* PROPOSITION-RELATION:                  Built-In Relations. (line  593)
* push-load-path:                        Commands.           (line  565)
* QUERY:                                 Built-In Relations. (line  596)
* random-float:                          Miscellaneous.      (line  921)
* RANGE:                                 Built-In Relations. (line  613)
* RANGE-CARDINALITY:                     Built-In Relations. (line  621)
* RANGE-CARDINALITY-LOWER-BOUND:         Built-In Relations. (line  631)
* RANGE-CARDINALITY-UPPER-BOUND:         Built-In Relations. (line  651)
* RANGE-MAX-CARDINALITY:                 Built-In Relations. (line  657)
* RANGE-MIN-CARDINALITY:                 Built-In Relations. (line  663)
* RANGE-TYPE:                            Built-In Relations. (line  668)
* recall-marked-objects on MARKER-TABLE: Miscellaneous.      (line  925)
* record-justifications?:                Miscellaneous.      (line  929)
* REFLEXIVE:                             Built-In Relations. (line  676)
* REFUTATION-QUERY:                      Built-In Relations. (line  680)
* register-computation-function:         Miscellaneous.      (line  934)
* register-computation-function-name:    Miscellaneous.      (line  945)
* register-logic-dialect-print-function: Miscellaneous.      (line  952)
* register-specialist-function:          Miscellaneous.      (line  958)
* register-specialist-function-name:     Miscellaneous.      (line  968)
* RELATION-COMPUTATION:                  Built-In Relations. (line  691)
* RELATION-CONSTRAINT:                   Built-In Relations. (line  699)
* RELATION-EVALUATOR:                    Built-In Relations. (line  710)
* relation-name:                         Miscellaneous.      (line  974)
* RELATION-SPECIALIST:                   Built-In Relations. (line  722)
* relation?:                             Miscellaneous.      (line  977)
* remove-at on QUERY-SOLUTION-TABLE:     Miscellaneous.      (line  981)
* remove-deleted-members on PAGING-INDEX: Miscellaneous.     (line  986)
* repropagate-constraints:               Commands.           (line  569)
* reset-features:                        Commands.           (line  576)
* reset-powerloom <1>:                   API Functions.      (line  616)
* reset-powerloom:                       Commands.           (line  579)
* reset-query-caches:                    Miscellaneous.      (line  989)
* retract <1>:                           API Functions.      (line  621)
* retract:                               Commands.           (line  584)
* retract-binary-proposition:            API Functions.      (line  631)
* retract-facts-of:                      Commands.           (line  592)
* retract-facts-of-instance:             Miscellaneous.      (line  993)
* retract-from-query:                    Commands.           (line  597)
* retract-nary-proposition:              API Functions.      (line  636)
* retract-proposition:                   API Functions.      (line  641)
* retract-rule:                          Commands.           (line  603)
* retract-unary-proposition:             API Functions.      (line  647)
* retrieve <1>:                          API Functions.      (line  652)
* retrieve:                              Commands.           (line  612)
* retrieve-partial:                      Miscellaneous.      (line  997)
* run-forward-rules <1>:                 Miscellaneous.      (line 1014)
* run-forward-rules:                     API Functions.      (line  684)
* run-powerloom-tests:                   Miscellaneous.      (line 1028)
* s-ask:                                 API Functions.      (line  699)
* s-assert-proposition:                  API Functions.      (line  721)
* s-change-module:                       API Functions.      (line  731)
* s-clear-module:                        API Functions.      (line  738)
* s-conceive:                            API Functions.      (line  744)
* s-create-concept:                      API Functions.      (line  761)
* s-create-function:                     API Functions.      (line  777)
* s-create-module:                       API Functions.      (line  810)
* s-create-object:                       API Functions.      (line  791)
* s-create-relation:                     API Functions.      (line  816)
* s-destroy-object:                      API Functions.      (line  830)
* s-evaluate:                            API Functions.      (line  839)
* s-get-arity:                           API Functions.      (line  849)
* s-get-child-modules:                   API Functions.      (line  857)
* s-get-concept:                         API Functions.      (line  863)
* s-get-concept-instances:               API Functions.      (line  871)
* s-get-direct-concept-instances:        API Functions.      (line  881)
* s-get-domain:                          API Functions.      (line  891)
* s-get-inferred-binary-proposition-values: API Functions.   (line  901)
* s-get-nth-domain:                      API Functions.      (line  910)
* s-get-object:                          API Functions.      (line  919)
* s-get-parent-modules:                  API Functions.      (line  927)
* s-get-proposition:                     API Functions.      (line  939)
* s-get-propositions:                    API Functions.      (line  959)
* s-get-propositions-of:                 API Functions.      (line  976)
* s-get-range:                           API Functions.      (line  985)
* s-get-relation:                        API Functions.      (line  994)
* s-get-relation-extension:              API Functions.      (line 1003)
* s-get-rules:                           API Functions.      (line 1008)
* s-is-true-proposition:                 API Functions.      (line 1017)
* s-print-rules:                         API Functions.      (line 1025)
* s-register-computation-function:       Miscellaneous.      (line 1382)
* s-register-specialist-function:        Miscellaneous.      (line 1399)
* s-retract-proposition:                 API Functions.      (line 1034)
* s-retrieve:                            API Functions.      (line 1045)
* s-save-module:                         API Functions.      (line 1084)
* satisfies?:                            Miscellaneous.      (line 1035)
* save-all-neural-networks:              Miscellaneous.      (line 1043)
* save-module <1>:                       API Functions.      (line 1101)
* save-module:                           Commands.           (line  700)
* SCALAR:                                Built-In Relations. (line  731)
* SCALAR-INTERVAL:                       Built-In Relations. (line  734)
* SECOND-ELEMENT:                        Built-In Relations. (line  737)
* select-proof-result:                   Miscellaneous.      (line 1049)
* select-test-result:                    Miscellaneous.      (line 1054)
* set-error-print-cycle:                 Miscellaneous.      (line 1062)
* set-feature:                           Commands.           (line  703)
* set-inference-level:                   Miscellaneous.      (line 1069)
* set-load-path:                         Commands.           (line  739)
* set-marker on MARKER-TABLE:            Miscellaneous.      (line 1073)
* set-num-neighbors:                     Miscellaneous.      (line 1076)
* set-num-training-per-case:             Miscellaneous.      (line 1079)
* set-powerloom-feature:                 Miscellaneous.      (line 1083)
* set-save-network-cycle:                Miscellaneous.      (line 1086)
* SETOF:                                 Built-In Relations. (line  746)
* SHALLOW-QUERY:                         Built-In Relations. (line  751)
* SINGLE-VALUED:                         Built-In Relations. (line  755)
* sort on QUERY-SOLUTION-TABLE:          Miscellaneous.      (line 1092)
* specializes?:                          Miscellaneous.      (line 1098)
* SQUARE-ROOT:                           Built-In Relations. (line  760)
* STANDARD-DEVIATION:                    Built-In Relations. (line  764)
* start-ontosaurus:                      Miscellaneous.      (line 1103)
* start-powerloom-gui:                   Miscellaneous.      (line 1108)
* start-powerloom-server:                Miscellaneous.      (line 1120)
* stop-ontosaurus:                       Miscellaneous.      (line 1125)
* stop-powerloom-gui:                    Miscellaneous.      (line 1129)
* stop-powerloom-server:                 Miscellaneous.      (line 1134)
* strengthen-truth-value:                Miscellaneous.      (line 1139)
* strict-truth-value?:                   Miscellaneous.      (line 1144)
* STRING-CONCATENATE:                    Built-In Relations. (line  767)
* STRING-MATCH:                          Built-In Relations. (line  773)
* STRING-MATCH-IGNORE-CASE:              Built-In Relations. (line  786)
* string-to-object:                      API Functions.      (line 1114)
* SUBRELATION:                           Built-In Relations. (line  793)
* SUBSET-OF:                             Built-In Relations. (line  798)
* SUBSTRING:                             Built-In Relations. (line  808)
* SUBSUMPTION-QUERY:                     Built-In Relations. (line  819)
* SUM:                                   Built-In Relations. (line  824)
* SUPERRELATION:                         Built-In Relations. (line  827)
* SYMMETRIC:                             Built-In Relations. (line  832)
* SYNONYM:                               Built-In Relations. (line  835)
* termify:                               Miscellaneous.      (line 1147)
* test-closed-slot?:                     Miscellaneous.      (line 1151)
* test-environment-level?:               Miscellaneous.      (line 1414)
* test-function-slot?:                   Miscellaneous.      (line 1155)
* test-marker? on MARKER-TABLE:          Miscellaneous.      (line 1159)
* test-relation-on-arguments?:           Miscellaneous.      (line 1163)
* test-slot-value?:                      Miscellaneous.      (line 1168)
* test-special-marker-table?:            Miscellaneous.      (line 1172)
* test-subrelation?:                     Miscellaneous.      (line 1178)
* test-type-on-instance?:                Miscellaneous.      (line 1182)
* THIRD-ELEMENT:                         Built-In Relations. (line  847)
* time-command:                          Commands.           (line  743)
* TOTAL:                                 Built-In Relations. (line  850)
* TRANSITIVE:                            Built-In Relations. (line  867)
* translate-loom-file:                   Miscellaneous.      (line 1186)
* true-truth-value?:                     Miscellaneous.      (line 1193)
* true?:                                 Miscellaneous.      (line 1196)
* TYPE-OF:                               Built-In Relations. (line  874)
* unassert:                              Miscellaneous.      (line 1200)
* unassert-proposition:                  Miscellaneous.      (line 1211)
* unknown-truth-value?:                  Miscellaneous.      (line 1215)
* unknown?:                              Miscellaneous.      (line 1218)
* unset-feature:                         Commands.           (line  747)
* unset-powerloom-feature:               Miscellaneous.      (line 1221)
* upclassify-all-descriptions:           Miscellaneous.      (line 1224)
* upclassify-all-instances:              Miscellaneous.      (line 1227)
* upclassify-instances:                  Miscellaneous.      (line 1230)
* upclassify-named-descriptions:         Miscellaneous.      (line 1236)
* update-proposition-in-store on OBJECT-STORE: Miscellaneous.
                                                             (line 1242)
* update-tuple:                          Miscellaneous.      (line 1248)
* VALUE:                                 Built-In Relations. (line  878)
* VARIABLE-ARITY:                        Built-In Relations. (line  883)
* VARIANCE:                              Built-In Relations. (line  887)
* weaken-truth-value:                    Miscellaneous.      (line 1252)
* why:                                   Commands.           (line  754)
* with-logic-environment:                Miscellaneous.      (line 1258)
* within-classification-session:         Miscellaneous.      (line 1265)
* within-meta-cache:                     Miscellaneous.      (line 1269)


File: manual.info,  Node: Variable Index,  Next: Concept Index,  Prev: Function Index,  Up: Top

Variable Index
**************

 [index ]
* Menu:

* abstract?:                             Built-In Relations.  (line 687)
* all-super-contexts:                    Built-In Relations.  (line 185)
* any-value:                             Built-In Relations.  (line 147)
* arguments:                             Built-In Relations.  (line 573)
* base-module:                           Built-In Relations.  (line 182)
* child-contexts:                        Built-In Relations.  (line 179)
* context-number:                        Built-In Relations.  (line 188)
* dependent-propositions:                Built-In Relations.  (line 580)
* function-code:                         Built-In Relations.  (line 305)
* home-context:                          Built-In Relations.  (line 564)
* kind:                                  Built-In Relations.  (line 567)
* method-code:                           Built-In Relations.  (line 302)
* method-function?:                      Built-In Relations.  (line 308)
* method-parameter-names:                Built-In Relations.  (line 289)
* method-parameter-type-specifiers:      Built-In Relations.  (line 293)
* method-return-type-specifiers:         Built-In Relations.  (line 296)
* method-setter?:                        Built-In Relations.  (line 286)
* method-stringified-source:             Built-In Relations.  (line 299)
* operator:                              Built-In Relations.  (line 576)
* surrogate-value-inverse:               Built-In Relations.  (line 844)
* the-cons-list:                         Built-In Relations.  (line 427)
* truth-value:                           Built-In Relations.  (line 570)


File: manual.info,  Node: Concept Index,  Prev: Variable Index,  Up: Top

Concept Index
*************

 [index ]
* Menu:

