<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Copyright C 2010
University of Southern California, Information Sciences Institute,
4676 Admiralty Way,
Marina Del Rey, CA 90292, USA

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

PowerLoom is a registered trademark of the University of Southern California.

 -->
<!-- Created on September 20, 2011 by texi2html 1.82
texi2html was written by: 
            Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>
-->
<head>
<title>PowerLoom Manual: 5. Commands</title>

<meta name="description" content="PowerLoom Manual: 5. Commands">
<meta name="keywords" content="PowerLoom Manual: 5. Commands">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.82">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.roman {font-family:serif; font-weight:normal;}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Commands"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="manual_4.html#Persistent-Knowledge-Bases" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="manual_6.html#PowerLoom-API" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="manual_4.html#Communicating-with-PowerLoom" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="manual.html#Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="manual_6.html#PowerLoom-API" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="manual.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="manual_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="manual_14.html#Function-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="manual_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Commands-1"></a>
<h1 class="chapter">5. Commands</h1>

<p>This chapter lists all available PowerLoom commands alphabetically.
Each command is documented with its name, a (possibly empty) list of
parameters specified as <code>(&lt;name&gt; &lt;type&gt;)</code> pairs, its return
type, and its category (<em>Command</em>).  Almost all of the commands implicitly
quote their arguments, meaning that when calling them, you don&rsquo;t need
to add any quotation yourself.  For example, the command
<code>all-facts-of</code> is defined as follows:
</p>
<blockquote><dl>
<dt><a name="index-all_002dfacts_002dof"></a><u>Command:</u> <b>all-facts-of</b><i> ((instanceRef <small>NAME</small>)) : <small>(CONS OF PROPOSITION)</small></i></dt>
<dd><p>Return a cons list of all definite (TRUE or FALSE) propositions
that reference the instance <var>instanceRef</var>.
</p></dd></dl>
</blockquote>

<p>The <code>all-facts-of</code> command has one parameter called
<var>instanceRef</var> of type <em><small>NAME</small></em>, and returns a STELLA
<em><small>LIST</small></em> containing zero or more objects of type
<em><small>PROPOSITION</small></em> as its result.  The type <small>NAME</small> subsumes the
types <small>SYMBOL</small>, <small>SURROGATE</small>, <small>STRING</small>, and <small>KEYWORD</small>.
Unless you are in a case-sensitive module, the following four commands
are equivalent:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">&nbsp;&nbsp;&nbsp;&nbsp;(all-facts-of Merryweather)
&nbsp;&nbsp;&nbsp;&nbsp;(all-facts-of :MERRYWEATHER)
&nbsp;&nbsp;&nbsp;&nbsp;(all-facts-of &quot;merryweather&quot;)
&nbsp;&nbsp;&nbsp;&nbsp;(all-facts-of @MerryWeather)
</pre></td></tr></table>

<p>Commands can also have <code>&amp;rest</code> parameters (similar to Lisp
functions).  These are either used to allow a variable number of
arguments, or to handle optional arguments, since STELLA does not
directly support optional arguments.
</p>
<p>Here is a list of important parameter types used in the
command specifications below:
</p>
<ul>
<li> <em><small>GENERALIZED-SYMBOL</small></em>: A generalized symbol is either a plain
symbol (similar to a Lisp symbol) such as <code>Merryweather</code>, a keyword
(similar to a Lisp keyword) such as <code>:KIF</code>, or a STELLA surrogate
which is a symbol starting with an at-sign, e.g., <code>@CONS</code>.  STELLA
surrogates are used as names for objects of arbitrary types.

</li><li> <em><small>NAME</small></em>: Names can be either a string, or a
<em><small>GENERALIZED-SYMBOL</small></em> (i.e., a symbol, a keyword, or a
surrogate).  If a symbol is supplied, only its symbol-name is used.
Commands that take names as arguments usually coerce whatever argument
is entered into a string, but by allowing a <small>NAME</small> they make it a
little bit more convenient to type a name in an interactive
invocation.<a name="DOCF9" href="manual_fot.html#FOOT9">(9)</a>
</li><li> <em><small>PARSE-TREE</small></em>: A parse tree is similar to a Lisp s-expression,
i.e., it can either be an atom such as a symbol, number, or a string, or
a list of zero or more parse trees.  For example, the expression
<code>(happy Fred)</code> is a parse tree, and so are its components
<code>happy</code> and <code>Fred</code>.
</li></ul>

<p>Here is the list of all available PowerLoom commands:
</p>

<dl>
<dt><a name="index-add_002dload_002dpath"></a><u>Command:</u> <b>add-load-path</b><i> ((path <small>STRING</small>)) : <small>(CONS OF STRING-WRAPPER)</small></i></dt>
<dd><p>Append the directories listed in the |-separated
<var>path</var> to the end of the STELLA load path.  Return the resulting
load path.
</p></dd></dl>

<dl>
<dt><a name="index-all_002dfacts_002dof-1"></a><u>N-Command:</u> <b>all-facts-of</b><i> ((instanceRef <small>OBJECT</small>)) : <small>(CONS OF PROPOSITION)</small></i></dt>
<dd><p>Return a cons list of all definite (TRUE or FALSE) propositions
that reference the instance <var>instanceRef</var>.  This includes propositions
asserted to be true by default, but it does not include propositions
that are found to be TRUE only by running the query engine.  Facts
inferred to be TRUE by the forward chainer will be included.
Hence, the returned list of facts may be longer in a context where the
forward chainer has been run then in one where it has not (see
<code>run-forward-rules</code>).  <var>instanceRef</var> can be a regular name such as
<code>fred</code> as well as a function term such as <code>(father fred)</code>.
</p></dd></dl>

<dl>
<dt><a name="index-ask"></a><u>N-Command:</u> <b>ask</b><i> (&amp;rest (proposition&amp;options <small>PARSE-TREE</small>)) : <small>TRUTH-VALUE</small></i></dt>
<dd><p>Perform inference to determine whether the proposition specified in
<var>proposition&amp;options</var> is true.  Return the truth-value found.  <code>ask</code>
will spend most of its effort to determine whether the proposition
is true and only a little effort via shallow inference strategies to
determine whether it is false.  To find out whether a proposition is
false with full inference effort <code>ask</code> its negation.
</p>
<p>KIF example: <code>(ask (happy Fred))</code> will return TRUE if Fred was indeed
found to be happy.  Note, that for this query to run, the logic
constant <code>Fred</code> and the relation <code>happy</code> must already be defined (see
<code>assert</code>).  Use <code>(set/unset-feature goal-trace)</code> to en/disable goal
tracing of the inference engine.
</p>
<p>The <code>ask</code> command supports the following options: <code>:TIMEOUT</code> is an
integer or floating point time limit, specified in seconds.  For
example, the command <code>(ask (nervous Fred) :timeout 2.0)</code> will cease
inference after two seconds if a proof has not been found by then.
If the <code>:DONT-OPTIMIZE?</code> is given as TRUE, it tells PowerLoom to
not optimize the order of clauses in the query before evaluating it.
This is useful for cases where a specific evaluation order of the
clauses is required (or the optimizer doesn&rsquo;t do the right thing).
If <code>:THREE-VALUED?</code> is given as TRUE, PowerLoom will try to prove
the negation of the query with full effort in case the given query
returned UNKNOWN.  By default, PowerLoom uses full effort to prove
the query as stated and only a little opportunistic effort to see
whether it is actually false.
</p></dd></dl>

<dl>
<dt><a name="index-assert"></a><u>N-Command:</u> <b>assert</b><i> ((proposition <small>PARSE-TREE</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Assert the truth of <var>proposition</var>.  Return the asserted proposition object.
KIF example:  &quot;(assert (happy Fred))&quot; asserts that Fred is indeed happy.
Note that for this assertion to succeed, the relation <code>happy</code> must already
be defined.  If the constant <code>Fred</code> has not yet been created, it is
automatically created as a side-effect of calling <code>assert</code>.
</p></dd></dl>

<dl>
<dt><a name="index-assert_002dfrom_002dquery"></a><u>N-Command:</u> <b>assert-from-query</b><i> ((query <small>CONS</small>) &amp;rest (options <small>OBJECT</small>)) : <small>(CONS OF PROPOSITION)</small></i></dt>
<dd><p>Evaluate <var>query</var>, instantiate the query proposition for each generated
solution and assert the resulting propositions.  The accepted syntax
is as follows:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example"> (assert-from-query &lt;query-command&gt;
                    [:relation &lt;relation-name&gt;]
                    [:pattern &lt;description-term&gt;]
                    [:module &lt;module-name&gt;]
                    [:record-justifications? TRUE|FALSE])
</pre></td></tr></table>

<p>&lt;query-command&gt; has to be a strict or partial retrieval command. If a
:relation option is supplied, &lt;relation-name&gt; is used as the relation
of the resulting propositions.  In this case the bindings of each
solution will become arguments to the specified relation in the order
of <var>query</var>s output variables (the arities have to match).  The
:pattern option is a generalization of this mechanism that specifies
an arbitrary proposition pattern to be instantiated by the query&rsquo;s
solution.  In this case &lt;description-term&gt; has to be a SETOFALL or
KAPPA expression whose IO-variables will be bound in sequence to the
bindings of a query solution to generate the resulting proposition.
Finally, if a :module option is specified, the assertions will be
generated in that module.  Note that for this to work the relations
referenced in the query proposition or pattern have to be visible in
the module.  Also, instances will not be copied to the target module,
therefore, the resulting propositions might reference external
out-of-module objects in case they are not visible there.  If
:record-justifications? is TRUE, justifications will be recorded
for the query and the resulting justifications will be linked to
the asserted propositions.  Here are some examples:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example"> (assert-from-query (retrieve all (foo ?x ?y)))
 (assert-from-query (retrieve all (?y ?x)
                             (exists ?z
                               (and (foo ?x ?z)
                                    (foo ?z ?y))))
                    :relation bar :module other)
 (assert-from-query
   (retrieve all (and (relation ?x) (symmetric ?x)))
   :pattern (kappa (?pred)
              (forall (?x ?y)
                (=&gt; (holds ?pred ?x ?y)
                    (holds ?pred ?y ?x))))))
</pre></td></tr></table>


</dd></dl>

<dl>
<dt><a name="index-assert_002drule"></a><u>N-Command:</u> <b>assert-rule</b><i> ((ruleName <small>NAME</small>)) : <small>PROPOSITION</small></i></dt>
<dd><p>Set the truth value of the rule named <var>ruleName</var> to 
TRUE.  The proposition having the name <var>ruleName</var> may be
any arbitrary proposition, although we expect that it is probably
a material implication.  (See <code>retract-rule</code>).
</p></dd></dl>

<dl>
<dt><a name="index-cc"></a><u>N-Command:</u> <b>cc</b><i> (&amp;rest (name <small>NAME</small>)) : <small>CONTEXT</small></i></dt>
<dd><p>Change the current context to the one named <var>name</var>.  Return the
value of the new current context.  If no <var>name</var> is supplied, return
the pre-existing value of the current context.  <code>cc</code> is a no-op if the
context reference cannot be successfully evaluated.
</p></dd></dl>

<dl>
<dt><a name="index-classify_002drelations"></a><u>N-Command:</u> <b>classify-relations</b><i> (&amp;rest (options <small>OBJECT</small>)) :</i></dt>
<dd><p>Classify relations visible in the module defined by the :module option (which
defaults to the current module).  If :module was explicitly specified as NULL,
classify relations in all modules.  If <code>:local?</code> is specified as TRUE only classify
relations that belong to the specified module but not any modules it inherits.  For
backwards compatibility, this command also supports the old &lt;module&gt; &lt;local?&gt;
arguments specified without keywords.
</p>
<p>Conceptually, the classifier operates by comparing each concept or relation
with all other concepts/relations, searching for a proof that a
subsumption relation exists between each pair. Whenever a new subsumption
relation is discovered, the classifier adds an <code>implication</code> link between
members of the pair, thereby augmenting the structure of the
concept or relation hierarchy. The implemented classification algorithm is
relatively efficient &ndash; it works hard at limiting the number of concepts
or relations that need to be checked for possible subsumption
relationships.
</p>
</dd></dl>

<dl>
<dt><a name="index-classify_002dinstances"></a><u>N-Command:</u> <b>classify-instances</b><i> (&amp;rest (options <small>OBJECT</small>)) :</i></dt>
<dd><p>Classify instances visible in the module defined by the :module option (which
defaults to the current module).  If :module was explicitly specified as NULL,
classify instances in all modules.  If <code>:local?</code> is specified as TRUE only classify
instances that belong to the specified module but not any modules it inherits.  For
backwards compatibility, this command also supports the old &lt;module&gt; &lt;local?&gt;
arguments specified without keywords.
</p>
<p>Conceptually, the classifier operates by comparing each instance with all
concepts in the hierarchy, searching for a proof for each pairing indicating
that the instance belongs to the concept.  Whenever a new <code>is-a</code> relation is
discovered, the classifier adds an <code>is-a</code> link between the instance and the
concept, thereby recording an additional fact about the instance.  The
implemented classification algorithm is relatively efficient &ndash; it works hard at
limiting the number of concepts or relations that need to be checked for
possible is-a relationships.
</p>
</dd></dl>

<dl>
<dt><a name="index-clear_002dcaches"></a><u>Command:</u> <b>clear-caches</b><i> () :</i></dt>
<dd><p>Clear all query and memoization caches.
</p></dd></dl>

<dl>
<dt><a name="index-clear_002dinstances"></a><u>N-Command:</u> <b>clear-instances</b><i> (&amp;rest (name <small>NAME</small>)) :</i></dt>
<dd><p>Destroy all instances belonging to module <var>name</var> or any of its children.
Leave meta-objects, e.g., concepts and relations, alone.
If no <var>name</var> is supplied, the current module will be cleared after
confirming with the user.
</p></dd></dl>

<dl>
<dt><a name="index-clear_002dmodule"></a><u>N-Command:</u> <b>clear-module</b><i> (&amp;rest (name <small>NAME</small>)) :</i></dt>
<dd><p>Destroy all objects belonging to module <var>name</var> or any of its children.
If no <var>name</var> is supplied, the current module will be cleared after
confirming with the user.  Important modules such as STELLA are protected
against accidental clearing.
</p></dd></dl>

<dl>
<dt><a name="index-conceive"></a><u>N-Command:</u> <b>conceive</b><i> ((formula <small>PARSE-TREE</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Guess whether <var>formula</var> represents a term or a sentence/proposition.
If we are not sure, assume its a proposition.
If its, a term, return its internal representation.  If a proposition,
construct a proposition for <var>formula</var> without asserting its truth value.
Return the conceived proposition object.  KIF example: &quot;(conceive (happy Fred))&quot;
builds the proposition expressing that Fred is happy without explictly asserting
or denying it.  Note, that for this to succeed, the relation <code>happy</code> must already
be defined (see <code>assert</code>).  If the logic constant <code>Fred</code> has not yet been
created, it is automatically created as a side-effect of calling <code>conceive</code>.
</p></dd></dl>

<dl>
<dt><a name="index-copyright"></a><u>Command:</u> <b>copyright</b><i> () :</i></dt>
<dd><p>Print detailed PowerLoom copyright information.
</p></dd></dl>

<dl>
<dt><a name="index-defconcept"></a><u>N-Command:</u> <b>defconcept</b><i> (&amp;rest (args <small>PARSE-TREE</small>)) : <small>NAMED-DESCRIPTION</small></i></dt>
<dd><p>Define (or redefine) a concept.  The accepted syntax is:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example"> (defconcept &lt;conceptconst&gt; [(&lt;var&gt; &lt;parent&gt;*)]
    [:documentation &lt;string&gt;]
    [:&lt;= &lt;sentence&gt;] | [:=&gt; &lt;sentence&gt;] |
    [:&lt;&lt;= &lt;sentence&gt;] | [:=&gt;&gt; &lt;sentence&gt;] | 
    [:&lt;=&gt; &lt;sentence&gt;] | [:&lt;=&gt;&gt; &lt;sentence&gt;] | [:&lt;&lt;=&gt; &lt;sentence&gt;] |
    [:&lt;&lt;=&gt;&gt; &lt;sentence&gt;] |
    [:axioms {&lt;sentence&gt; | (&lt;sentence&gt;+)}] |
    &lt;keyword-option&gt;*)
</pre></td></tr></table>

<p>Declaration of a concept variable <code>&lt;var&gt;</code> is optional, unless any
implication (arrow) options are supplied that need to reference it.  A
possibly empty list of concept names following <code>&lt;var&gt;</code> is taken as the list
of parents of <code>&lt;conceptconst&gt;</code>.  Alternatively, parents can be specified
via the <code>:=&gt;</code> option.  If no parents are specified, the parent of
<code>&lt;conceptconst&gt;</code> is taken to be THING.  <code>&lt;keyword-option&gt;</code> represents a
keyword followed by a value that states an assertion about <code>&lt;conceptconst&gt;</code>.
See <code>defrelation</code> for a description of <code>&lt;keyword-option&gt;</code>s.
</p>
</dd></dl>

<dl>
<dt><a name="index-deffunction"></a><u>N-Command:</u> <b>deffunction</b><i> (&amp;rest (args <small>PARSE-TREE</small>)) : <small>NAMED-DESCRIPTION</small></i></dt>
<dd><p>Define (or redefine) a logic function.  The accepted syntax is:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example"> (deffunction &lt;funconst&gt; (&lt;vardecl&gt;+) [:-&gt; &lt;vardecl&gt;]
    [:documentation &lt;string&gt;]
    [:&lt;= &lt;sentence&gt;] | [:=&gt; &lt;sentence&gt;] |
    [:&lt;&lt;= &lt;sentence&gt;] | [:=&gt;&gt; &lt;sentence&gt;] | 
    [:&lt;=&gt; &lt;sentence&gt;] | [:&lt;=&gt;&gt; &lt;sentence&gt;] |
    [:&lt;&lt;=&gt; &lt;sentence&gt;] | [:&lt;&lt;=&gt;&gt; &lt;sentence&gt;] |
    [:axioms {&lt;sentence&gt; | (&lt;sentence&gt;+)}]
    [&lt;keyword-option&gt;*])
</pre></td></tr></table>

<p>Function parameters can be typed or untyped.  If the <code>:-&gt;</code> option is
supplied, it specifies the output variable of the function.  Otherwise,
the last variable in the parameter list is used as the output variable.
See <code>defrelation</code> for a description of <code>&lt;keyword-option&gt;</code>s.
</p>
</dd></dl>

<dl>
<dt><a name="index-definstance"></a><u>N-Command:</u> <b>definstance</b><i> (&amp;rest (args <small>PARSE-TREE</small>)) : <small>LOGIC-OBJECT</small></i></dt>
<dd><p>Define (or redefine) a logic instance (<code>definstance</code> is an alias
for <code>defobject</code> which see).
</p></dd></dl>

<dl>
<dt><a name="index-defmodule"></a><u>N-Command:</u> <b>defmodule</b><i> ((name <small>NAME</small>) &amp;rest (options <small>OBJECT</small>)) :</i></dt>
<dd><p>Define (or redefine) a module named <var>name</var>.
The accepted syntax is:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">  (defmodule &lt;module-name&gt;
     [:documentation &lt;docstring&gt;]
     [:includes {&lt;module-name&gt; | (&lt;module-name&gt;*)}]
     [:uses {&lt;module-name&gt; | (&lt;module-name&gt;*)}]
     [:lisp-package &lt;package-name-string&gt;]
     [:java-package &lt;package-specification-string&gt;]
     [:cpp-namespace &lt;namespace-name-string&gt;]
     [:java-catchall-class
     [:api? {TRUE | FALSE}]
     [:case-sensitive? {TRUE | FALSE}]
     [:shadow (&lt;symbol&gt;*)]
     [:java-catchall-class &lt;class-name-string&gt;]
     [&lt;other-options&gt;*])
</pre></td></tr></table>

<p><var>name</var> can be a string or a symbol.
</p>
<p>Modules include objects from other modules via two separate mechanisms:
(1) they inherit from their parents specified via the <code>:includes</code> option
and/or a fully qualified module name, and (2) they inherit from used
modules specified via the <code>:uses</code> option.  The main difference between
the two mechanisms is that inheritance from parents is transitive, while
uses-links are only followed one level deep.  I.e., a module A that uses
B will see all objects of B (and any of B&rsquo;s parents) but not see anything
from modules used by B.  Another difference is that only objects declared
as public can be inherited via uses-links (this is not yet enforced).
Note that - contrary to Lisp - there are separate name spaces for classes,
functions, and variables.  For example, a module could inherit the class
<code>CONS</code> from the <code>STELLA</code> module, but shadow the function of the same name.
</p>
<p>The above discussion of <code>:includes</code> and <code>:uses</code> semantics keyed on the
inheritance/visibility of symbols. The PowerLoom system makes another
very important distinction: If a module <code>A</code> is inherited directly or
indirectly via <code>:includes</code> specification(s) by a submodule <code>B</code>, then all
definitions and facts asserted in <code>A</code> are visible in <code>B</code>. This is not the
cases for <code>:uses</code>; the <code>:uses</code> options does not impact inheritance of
propositions at all.
</p>
<p>The list of modules specified in the
<code>:includes</code> option plus (if supplied) the parent in the path used for
<var>name</var> become the new module&rsquo;s parents. If no <code>:uses</code> option was
supplied, the new module will use the <code>STELLA</code> module by default,
otherwise, it will use the set of specified modules.
</p>
<p>If <code>:case-sensitive?</code> is supplied as TRUE, symbols in the module
will be interned case-sensitively, otherwise (the default), they
will be converted to uppercase before they get interned.  That
means that any reference from inside a case-sensitive module to a
non-case-sensitive module will have to use uppercase names for
symbols in the non-case-sensitive module.  The standard system
modules are all NOT case sensitive.
</p>
<p>Modules can shadow definitions of functions and classes inherited
from parents or used modules. Shadowing is done automatically,
but generates a warning unless the shadowed type or function name
is listed in the <code>:shadow</code> option of the module definition .
</p>
<p>Examples:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">  (defmodule &quot;PL-KERNEL/PL-USER&quot;
    :uses (&quot;LOGIC&quot; &quot;STELLA&quot;)
    :package &quot;PL-USER&quot;)

  (defmodule PL-USER/GENEALOGY)
</pre></td></tr></table>

<p>The remaining options are relevant only for modules that contain STELLA
code.  Modules used only to contain knowledge base definitions and assertions
have no use for them:
</p>
<p>The keywords <code>:lisp-package</code>, <code>:java-package</code>, and <code>:cpp-package</code> specify
the name of a native package or name space in which symbols of the module
should be allocated when they get translated into one of Lisp, Java, or
C++. By default, Lisp symbols are allocated in the <code>STELLA</code> package, and
C++ names are translated without any prefixes. The rules that the STELLA
translator uses to attach translated Java objects to classes and packages
are somewhat complex. Use :java-package option to specify a list of
package names (separated by periods) that prefix the Java object in this
module.  Use :java-catchall-class to specify the name of the Java class to
contain all global &amp; special variables, parameter-less functions and functions 
defined on arguments that are not classes in the current module.
The default value will be the name of the module.
</p>
<p>When set to TRUE, the :api? option tells the PowerLoom User Manual
generator that all functions defined in this module should be included in
the API section. Additionally, the Java translator makes all API
functions <code>synchronized</code>.
</p>
</dd></dl>

<dl>
<dt><a name="index-defobject"></a><u>N-Command:</u> <b>defobject</b><i> (&amp;rest (args <small>PARSE-TREE</small>)) : <small>LOGIC-OBJECT</small></i></dt>
<dd><p>Define (or redefine) a logic instance.  The accepted syntax is:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example"> (defobject &lt;constant&gt;
    [:documentation &lt;string&gt;]
    [&lt;keyword-option&gt;*])
</pre></td></tr></table>

<p><code>&lt;keyword-option&gt;</code> represents a keyword followed by a value
that states an assertion about &lt;constant&gt;.  See <code>defrelation</code> for a
description of <code>&lt;keyword-option&gt;</code>s.
</p>
<p><code>defobject</code> provides a sugar-coated way to assert a collection of facts
about a logic constant, but otherwise adds nothing in terms of functionality.
</p>
</dd></dl>

<dl>
<dt><a name="index-defproposition"></a><u>N-Command:</u> <b>defproposition</b><i> (&amp;rest (args <small>PARSE-TREE</small>)) : <small>PROPOSITION</small></i></dt>
<dd><p>Define (or redefine) a named proposition.  The accepted syntax is:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example"> (defproposition &lt;name&gt; &lt;sentence&gt;
    [:documentation &lt;string&gt;]
    [:forward-only? {true | false}]
    [:backward-only? {true | false}]
    [:dont-optimize? {true | false}]
    [:confidence-level {:strict | :default}]
    [&lt;keyword-option&gt;*])
</pre></td></tr></table>

<p>&lt;sentence&gt; can be any sentence that is legal as a top-level assertion.
&lt;name&gt; can be a string or symbol and will be bound to the asserted
proposition represented by &lt;sentence&gt;.  After this definition every
occurrence of &lt;name&gt; will be replaced by the associated proposition.
</p>
<p>The options :forward-only? and :backward-only? can be used to tell the
inference engine to only use the rule in forward or backward direction
(this can also be achieved by using the <code>&lt;&lt;=</code> or <code>=&gt;&gt;</code> implication
arrows).  :dont-optimize?  tells the inference engine to not rearrange
the order of clauses in the antecedent of a rule and instead evaluate
them in their original order.  :confidence-level can be used to mark a
proposition as default only.
</p>
<p><code>&lt;keyword-option&gt;</code> represents a keyword followed by a value
that states an assertion about the proposition &lt;name&gt;.  See <code>defrelation</code>
for a description of <code>&lt;keyword-option&gt;</code>s.
</p>
</dd></dl>

<dl>
<dt><a name="index-defrelation"></a><u>N-Command:</u> <b>defrelation</b><i> (&amp;rest (args <small>PARSE-TREE</small>)) : <small>NAMED-DESCRIPTION</small></i></dt>
<dd><p>Define (or redefine) a logic relation.  The accepted syntax is:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example"> (defrelation &lt;relconst&gt; (&lt;vardecl&gt;+)
    [:documentation &lt;string&gt;]
    [:&lt;= &lt;sentence&gt;] | [:=&gt; &lt;sentence&gt;] |
    [:&lt;&lt;= &lt;sentence&gt;] | [:=&gt;&gt; &lt;sentence&gt;] | 
    [:&lt;=&gt; &lt;sentence&gt;] | [:&lt;=&gt;&gt; &lt;sentence&gt;] |
    [:&lt;&lt;=&gt; &lt;sentence&gt;] | [:&lt;&lt;=&gt;&gt; &lt;sentence&gt;] |
    [:axioms {&lt;sentence&gt; | (&lt;sentence&gt;+)}]
    [&lt;keyword-option&gt;*])
</pre></td></tr></table>

<p>Relation parameters can be typed or untyped.
<code>&lt;keyword-option&gt;</code> represents a keyword followed by a value that states an
assertion about <code>&lt;relconst&gt;</code>.  For example, including the option <code>:foo bar</code>
states that the proposition <code>(foo &lt;relconst&gt; bar)</code> is true.  <code>:foo (bar fum)</code>
states that both <code>(foo &lt;relconst&gt; bar)</code> and <code>(foo &lt;relconst&gt; fum)</code> are true.
<code>:foo true</code> states that <code>(foo &lt;relconst&gt;)</code> is true, <code>:foo false</code> states that
<code>(not (foo &lt;relconst&gt;))</code> is true.
</p>
</dd></dl>

<dl>
<dt><a name="index-defrule"></a><u>N-Command:</u> <b>defrule</b><i> (&amp;rest (args <small>PARSE-TREE</small>)) : <small>PROPOSITION</small></i></dt>
<dd><p>Define (or redefine) a named rule (<code>defrule</code> is an alias
for <code>defproposition</code> which see).
</p></dd></dl>

<dl>
<dt><a name="index-delete_002drules"></a><u>N-Command:</u> <b>delete-rules</b><i> ((relation <small>NAME</small>)) :</i></dt>
<dd><p>Delete the list of rules associated with <var>relation</var>.
This function is included mainly for debugging purposes, when
a user wants to verify the behavior of different sets of rules.
</p></dd></dl>

<dl>
<dt><a name="index-demo"></a><u>Command:</u> <b>demo</b><i> (&amp;rest (fileandpause <small>OBJECT</small>)) :</i></dt>
<dd><p>Read logic commands from a file, echo them verbatimly to standard output,
and evaluate them just as if they had been typed in interactively.
When called with no arguments, present a menu of example demos, otherwise,
use the first argument as the name of the file to demo.
Pause for user confirmation after each expression has been read but
before it is evaluated.  Pausing can be turned off by suppling FALSE
as the optional second argument, or by typing <code>c</code> at the pause prompt.
Typing <code>?</code> at the pause prompt prints a list of available commands.
</p></dd></dl>

<dl>
<dt><a name="index-deny"></a><u>N-Command:</u> <b>deny</b><i> ((proposition <small>PARSE-TREE</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Assert the falsity of <var>proposition</var>.  Return the asserted proposition
object.  KIF example:  &quot;(deny (happy Fred))&quot; asserts that Fred is not happy,
which could have been done equivalently by &quot;(assert (not (happy Fred)))&quot;.
Note, that for this to succeed, the relation <code>happy</code> must already be defined
(see <code>assert</code>).
</p></dd></dl>

<dl>
<dt><a name="index-describe"></a><u>N-Command:</u> <b>describe</b><i> ((name <small>OBJECT</small>) &amp;rest (mode <small>OBJECT</small>)) :</i></dt>
<dd><p>Print a description of an object in :verbose, :terse,
or :source modes.
</p></dd></dl>

<dl>
<dt><a name="index-destroy"></a><u>N-Command:</u> <b>destroy</b><i> ((objectSpec <small>PARSE-TREE</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Find an object or proposition as specified by <var>objectSpec</var>, and destroy all
propositions and indices that reference it.  <var>objectSpec</var> must be a name or
a parse tree that evaluates to a proposition.  Return the deleted object, or
NULL if no matching object was found.
</p></dd></dl>

<dl>
<dt><a name="index-drop_002dload_002dpath"></a><u>Command:</u> <b>drop-load-path</b><i> ((path <small>STRING</small>)) : <small>(CONS OF STRING-WRAPPER)</small></i></dt>
<dd><p>Remove the directories listed in the |-separated
<var>path</var> from the PowerLoom load path.
</p></dd></dl>

<dl>
<dt><a name="index-get_002dload_002dpath"></a><u>Command:</u> <b>get-load-path</b><i> () : <small>(CONS OF STRING-WRAPPER)</small></i></dt>
<dd><p>Return the current STELLA load path.
</p></dd></dl>

<dl>
<dt><a name="index-get_002drules"></a><u>N-Command:</u> <b>get-rules</b><i> ((relation <small>NAME</small>)) : <small>(CONS OF PROPOSITION)</small></i></dt>
<dd><p>Return the list of rules associated with <var>relation</var>.
</p></dd></dl>

<dl>
<dt><a name="index-help"></a><u>N-Command:</u> <b>help</b><i> (&amp;rest (commands <small>SYMBOL</small>)) :</i></dt>
<dd><p>Describe specific commands, or print a list of available commands.
</p></dd></dl>

<dl>
<dt><a name="index-in_002dmodule"></a><u>N-Command:</u> <b>in-module</b><i> ((name <small>NAME</small>)) : <small>MODULE</small></i></dt>
<dd><p>Change the current module to the module named <var>name</var>.
</p></dd></dl>

<dl>
<dt><a name="index-list_002dinconsistent_002dpropositions"></a><u>N-Command:</u> <b>list-inconsistent-propositions</b><i> (&amp;rest (options <small>OBJECT</small>)) : <small>(CONS OF PROPOSITION)</small></i></dt>
<dd><p>Return a list of all currently known inconsistent proposition in the module defined
by the :module option (which defaults to the current module).  If <code>:local?</code> is specified
as TRUE only look in the specified module but not any modules it inherits.  Note, that
this simply reports propositions that have been assigned an inconsistent truth value so
far (e.g., in clash exceptions), it will not try to detect any new or all inconsistencies
in a module.
</p></dd></dl>

<dl>
<dt><a name="index-list_002dmodules"></a><u>Command:</u> <b>list-modules</b><i> ((kb-only? <small>BOOLEAN</small>)) : <small>(CONS OF MODULE)</small></i></dt>
<dd><p>Returns a cons of all modules defined in PowerLoom.  If <var>kb-only?</var>
is <code>true</code>, then any modules which are code only or just namespaces are not returned.
</p></dd></dl>

<dl>
<dt><a name="index-list_002dunclassified_002dinstances"></a><u>N-Command:</u> <b>list-unclassified-instances</b><i> (&amp;rest (options <small>OBJECT</small>)) : <small>(CONS OF LOGIC-OBJECT)</small></i></dt>
<dd><p>Collect all instances in the module defined by the :module option (which defaults
to the current module) that were not (or will not be) classified due to their lack of
non-inferable/primitive type assertions.  If :module was explicitly specified as NULL,
look in all currently defined modules.  If <code>:local?</code> is specified as TRUE only look
in the specified module but not any modules it inherits.  For backwards compatibility,
this command also supports the old &lt;module&gt; &lt;local?&gt; arguments specified without keywords.
</p></dd></dl>

<dl>
<dt><a name="index-list_002dunclassified_002drelations"></a><u>N-Command:</u> <b>list-unclassified-relations</b><i> (&amp;rest (options <small>OBJECT</small>)) : <small>(CONS OF NAMED-DESCRIPTION)</small></i></dt>
<dd><p>Collect all named description in the module defined by the :module option (which defaults
to the current module) that were not (or will not be) classified due to their lack of
non-inferable/primitive ancestor relations.  If :module was explicitly specified as NULL,
look in all currently defined modules.  If <code>:local?</code> is specified as TRUE only look
in the specified module but not any modules it inherits.  For backwards compatibility,
this command also supports the old &lt;module&gt; &lt;local?&gt; arguments specified without keywords.
</p></dd></dl>

<dl>
<dt><a name="index-list_002dundefined_002drelations"></a><u>N-Command:</u> <b>list-undefined-relations</b><i> (&amp;rest (options <small>OBJECT</small>)) : <small>(CONS OF NAMED-DESCRIPTION)</small></i></dt>
<dd><p>Return a list of as yet undefined concepts and relations in the module defined
by the :module option (which defaults to the current module).  These relations were
defined by the system, since they were referenced but have not yet been defined by
the user.  If <code>:local?</code> is specified as TRUE only look in the specified module but
not any modules it inherits.  For backwards compatibility, this command also supports
the old &lt;module&gt; &lt;local?&gt; arguments specified without keywords.
</p></dd></dl>

<dl>
<dt><a name="index-load"></a><u>Command:</u> <b>load</b><i> ((file <small>STRING</small>) &amp;rest (options <small>OBJECT</small>)) :</i></dt>
<dd><p>Read logic commands from <var>file</var> and evaluate them.
By default, this will check for each asserted proposition whether an
equivalent proposition already exists and, if so, not assert the
duplicate.  These duplicate checks are somewhat expensive though and
can be skipped by setting the option :check-duplicates? to false.
This can save time when loading large KBs where it is known that no
duplicate assertions exist in a file.
</p>
<p>Also, by setting the option :module, the module in which the file
contents will be loaded will be set.  This will only affect files
that do NOT have an <code>in-module</code> declaration as part of the file.
If this is not set, and no <code>in-module</code> declaration is in the file,
then an error will be signaled.
</p></dd></dl>

<dl>
<dt><a name="index-load_002dfile"></a><u>Command:</u> <b>load-file</b><i> ((file <small>STRING</small>)) :</i></dt>
<dd><p>Read STELLA commands from <var>file</var> and evaluate them.
The file should begin with an <code>in-module</code> declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
<code>evaluate</code> to each of them.
</p></dd></dl>

<dl>
<dt><a name="index-pop_002dload_002dpath"></a><u>Command:</u> <b>pop-load-path</b><i> () : <small>STRING</small></i></dt>
<dd><p>Remove the first element from the STELLA load path
and return the removed element.
</p></dd></dl>

<dl>
<dt><a name="index-presume"></a><u>N-Command:</u> <b>presume</b><i> ((proposition <small>PARSE-TREE</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Presume the default truth of <var>proposition</var>.  Return the presumed
proposition object.  KIF example:  &quot;(presume (happy Fred))&quot; states that Fred
is most probably happy.  Note, that for this to succeed, the relation
<code>happy</code> must already be defined (see <code>assert</code>).
</p></dd></dl>

<dl>
<dt><a name="index-print_002dfeatures"></a><u>Command:</u> <b>print-features</b><i> () :</i></dt>
<dd><p>Print the currently enabled and available PowerLoom environment features.
</p></dd></dl>

<dl>
<dt><a name="index-print_002drules"></a><u>N-Command:</u> <b>print-rules</b><i> ((relation <small>OBJECT</small>)) :</i></dt>
<dd><p>Print the list of true rules associated with <var>relation</var>.
</p></dd></dl>

<dl>
<dt><a name="index-process_002ddefinitions"></a><u>Command:</u> <b>process-definitions</b><i> () :</i></dt>
<dd><p>Finish processing all definitions and assertions that have
been evaluated/loaded since that last call to <code>process-definitions</code>.
PowerLoom defers complete processing of definitions to make it easier
to support cyclic definitions.  Following finalization of definitions,
this call performs semantic validation of any assertions evaluated since
the last call to <code>process-definitions</code>.  PowerLoom calls this function
internally before each query; the primary reason to call it explicitly
is to force the production of any diagnostic information that results from
the processing and validation.
</p></dd></dl>

<dl>
<dt><a name="index-propagate_002dconstraints"></a><u>N-Command:</u> <b>propagate-constraints</b><i> (&amp;rest (name <small>NAME</small>)) :</i></dt>
<dd><p>Trigger constraint propagation over all propositions of module <var>name</var>.
If no <var>name</var> is supplied, the current module will be used.  This also
enables incremental constraint propagation for future monotonic updates to
the module.  Once a non-monotonic update is performed, i.e., a retraction
or clipping of a function value, all cached inferences will be discarded
and constraint propagation will be turned off until this function is
called again.
</p></dd></dl>

<dl>
<dt><a name="index-push_002dload_002dpath"></a><u>Command:</u> <b>push-load-path</b><i> ((path <small>STRING</small>)) : <small>(CONS OF STRING-WRAPPER)</small></i></dt>
<dd><p>Add the directories listed in the |-separated
<var>path</var> to the front of the STELLA load path.  Return the
resulting load path.
</p></dd></dl>

<dl>
<dt><a name="index-repropagate_002dconstraints"></a><u>N-Command:</u> <b>repropagate-constraints</b><i> (&amp;rest (name <small>NAME</small>)) :</i></dt>
<dd><p>Force non-incremental constraint propagation over all propositions of
module <var>name</var>.  If no <var>name</var> is supplied, the current module will be used.
This also enables incremental constraint propagation for future monotonic
updates to the module similar to <code>propagate-constraints</code>.
</p></dd></dl>

<dl>
<dt><a name="index-reset_002dfeatures"></a><u>Command:</u> <b>reset-features</b><i> () : <small>(LIST OF KEYWORD)</small></i></dt>
<dd><p>Reset the PowerLoom environment features to their default settings.
</p></dd></dl>

<dl>
<dt><a name="index-reset_002dpowerloom"></a><u>Command:</u> <b>reset-powerloom</b><i> () :</i></dt>
<dd><p>Reset PowerLoom to its initial state.
CAUTION: This will destroy all loaded knowledge bases and might break other
loaded STELLA systems if they do reference PowerLoom symbols in their code.
</p></dd></dl>

<dl>
<dt><a name="index-retract"></a><u>N-Command:</u> <b>retract</b><i> ((proposition <small>PARSE-TREE</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Retract the truth of <var>proposition</var>.  Return the retracted proposition
object.  KIF example:  &quot;(retract (happy Fred))&quot; retracts that Fred is
happy.  Note that for this assertion to succeed, the relation <code>happy</code> must already
be defined.  If the constant <code>Fred</code> has not yet been created, it is
automatically created as a side-effect of calling <code>retract</code>.
</p></dd></dl>

<dl>
<dt><a name="index-retract_002dfacts_002dof"></a><u>N-Command:</u> <b>retract-facts-of</b><i> ((instanceRef <small>OBJECT</small>)) :</i></dt>
<dd><p>Retract all definite (TRUE or FALSE) propositions
that reference the instance <var>instanceRef</var>.
</p></dd></dl>

<dl>
<dt><a name="index-retract_002dfrom_002dquery"></a><u>N-Command:</u> <b>retract-from-query</b><i> ((query <small>CONS</small>) &amp;rest (options <small>OBJECT</small>)) : <small>(CONS OF PROPOSITION)</small></i></dt>
<dd><p>Evaluate <var>query</var> which has to be a strict or partial retrieval
command, instantiate the query proposition for each generated solution
and retract the resulting propositions.  See <code>assert-from-query</code> for
available command options.
</p></dd></dl>

<dl>
<dt><a name="index-retract_002drule"></a><u>N-Command:</u> <b>retract-rule</b><i> ((ruleName <small>NAME</small>)) : <small>PROPOSITION</small></i></dt>
<dd><p>If it is currently TRUE, set the truth value 
of the rule named <var>ruleName</var> to UNKNOWN  This
command may be used alternately with <code>assert-rule</code> to
observe the effects of querying with or without a particular (named) rule
being asserted within the current context. The proposition having the name
<var>ruleName</var> may be any arbitrary proposition, although we expect that it is
probably a material implication.
</p></dd></dl>

<dl>
<dt><a name="index-retrieve"></a><u>N-Command:</u> <b>retrieve</b><i> (&amp;rest (query <small>PARSE-TREE</small>)) : <small>QUERY-ITERATOR</small></i></dt>
<dd><p>Retrieve elements of a relation (tuples) that satisfy a proposition.
The accepted syntax is:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">  (retrieve [&lt;integer&gt; | all]
            [[{&lt;vardecl&gt; | (&lt;vardecl&gt;+)}]
             &lt;proposition&gt;
             [&lt;option-keyword&gt; &lt;option-value&gt;]])
</pre></td></tr></table>

<p>The variables and proposition are similar to an <code>exists</code> sentence or
<code>kappa</code> term without the explicit quantifier.  If variables are declared,
they must match the free variables referenced by &lt;proposition&gt;.  Otherwise,
the free variables referenced in &lt;proposition&gt; will be used as the query
variables.  If &lt;proposition&gt; is omitted, the most recently asked query
will be continued.
</p>
<p>A solution is a set of bindings for the listed variables for which
&lt;proposition&gt; is true.  The optional first argument controls how many
solutions should be generated before control is returned.  The keyword
<code>all</code> indicates that all solutions should be generated.  By default,
<code>retrieve</code> returns after it has found one new solution or if it cannot
find any more solutions.
</p>
<p><code>retrieve</code> returns an iterator which saves all the necessary state of
a query and stores all generated solutions.  When used interactively,
the returned iterator will print out with the set of solutions collected
so far.  Calling <code>retrieve</code> without any arguments (or only with the first
argument) will generate one (or more) solutions to the most recently
asked query.
</p>
<p><code>retrieve</code> supports the following options:
  :TIMEOUT Time limit on query effort in seconds.
  :MAXIMUM-DEPTH Inference depth cutoff in goal depth.
  :INFERENCE-LEVEL Level of inference to use.  The values in order of effort
     and power are ASSERTION, SHALLOW, SUBSUMPTION, BACKTRACKING, NORMAL
     and REFUTATION. Default is NORMAL.
  :FOUR-VALUED? Will attempt to disprove values and find conflicts.
  :ITERATIVE-DEEPENING? Controls whether the search strategy will use
     depth-first or breadth-first search.
  :DONT-OPTIMIZE? Option to disable re-arrangement of clauses by the query
     optimizer.  If TRUE, then use the order of clauses as given in the query.
  :SORT-BY one of SCORE, VALUES, VALUES-DESCENDING, VALUES-ASCENDING.  
     SCORE is only meaningful for partial match mode.  The value sorting
     is done by values in order in the tuple.  Default is ascending.
  :MATCH-MODE Allows choice of matching mode.  One of STRICT, INCREMENTAL, 
     NEURAL-NETWORK, or other plug-in partial-match mode.
     The default is STRICT.
  :MINIMUM-SCORE The minimum score to return.  Only useful in partial match
    mode.
  :MAXIMUM-UNKNOWNS The maximum number of unknown values to allow.  Only useful
    for whynot matching.
</p>
<p>KIF examples:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">  (retrieve (happy ?x))
</pre></td></tr></table>

<p>will try to find one happy entity and store it in the returned 
query iterator.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">  (retrieve 10 (happy ?x))
</pre></td></tr></table>

<p>will try to find 10 happy entities.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">  (retrieve 10)
</pre></td></tr></table>

<p>will try to find the next 10 happy entities..
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">  (retrieve all (happy ?x))
</pre></td></tr></table>

<p>will find all happy entities.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">  (retrieve all (?x Person) (happy ?x))
</pre></td></tr></table>

<p>will to find all happy people.  Here we used the optional retrieve variable
syntax to restrict the acceptable solutions.  The above is equivalent to
the following query:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">  (retrieve all (and (Person ?x) (happy ?x)))
</pre></td></tr></table>

<p>Similarly,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">  (retrieve all (?x Person))
  (retrieve all (Person ?x))
  (retrieve all ?x (Person ?x))
</pre></td></tr></table>

<p>will find all people.  Note that in the first case we only specify a query
variable and its type but omit the logic sentence which defaults to TRUE.  This
somewhat impoverished looking query can be paraphrased as &quot;retrieve all ?x of
type Person such that TRUE.&quot;
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">  (retrieve ?x (or (happy ?x) (parent-of Fred ?x)))
</pre></td></tr></table>

<p>will try to find a person that is happy or has Fred as a parent.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">  (retrieve (?y ?x) (parent-of ?x ?y))
</pre></td></tr></table>

<p>will try to find the one pair of parent/child and return it in the order
of child/parent.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">  (retrieve all (?x Person)
            (exists (?y Person) (parent-of ?x ?y)))
</pre></td></tr></table>

<p>will generate the set of all parents.  Note, that for these queries to run,
the class <code>Person</code>, the relations <code>happy</code> and <code>parent-of</code>, and the logic
constant <code>Fred</code> must already be defined (see <code>assert</code>).
</p>
<p>Use <code>(set/unset-feature trace-subgoals)</code> to en/disable goal tracing of the
inference engine.
</p></dd></dl>

<dl>
<dt><a name="index-save_002dmodule"></a><u>Command:</u> <b>save-module</b><i> ((name <small>NAME</small>) (file <small>STRING</small>)) :</i></dt>
<dd><p>Save all definitions and assertions of module <var>name</var> to <var>file</var>.
</p></dd></dl>

<dl>
<dt><a name="index-set_002dfeature"></a><u>N-Command:</u> <b>set-feature</b><i> (&amp;rest (features <small>NAME</small>)) : <small>(LIST OF KEYWORD)</small></i></dt>
<dd><p>Enable the PowerLoom environment feature(s) named by <var>features</var>.
Return the list of enabled features.  Calling <code>set-feature</code> without any
arguments can be used to display the currently enabled features.
The following features are supported:
</p>
<p><code>just-in-time-inference</code>: Enables interleaving of forward chaining inference
within backward chaining queries.
</p>
<p><code>iterative-deepening</code>: Tells the query processor to use iterative deepening
instead of a depth-first search to find answers.  This is less efficient
but necessary for some kinds of highly recursive queries.
</p>
<p><code>trace-subgoals</code>: Enables the generation of subgoaling trace information during
backchaining inference.
</p>
<p><code>trace-solutions</code>: Prints newly found solutions during retrieval right when they
are generated as opposed to when the query terminates.
</p>
<p><code>trace-classifier</code>: Tells the classifier to describe the inferences it draws.
</p>
<p><code>justifications</code>: Enables the generation of justifications during inference,
which is a prerequiste for the generation of explanations with <code>(why)</code>.
</p>
<p><code>emit-thinking-dots</code>: Tells PowerLoom to annotate its inference progress by
outputting characters indicating the completion of individual reasoning steps.
</p>
<p>By default, the features <code>emit-thinking-dots</code> and <code>just-in-time-inference</code>
are enabled, and the others are disabled.
</p>
</dd></dl>

<dl>
<dt><a name="index-set_002dload_002dpath"></a><u>Command:</u> <b>set-load-path</b><i> ((path <small>STRING</small>)) : <small>(CONS OF STRING-WRAPPER)</small></i></dt>
<dd><p>Set the STELLA load path to the |-separated
directories listed in <var>path</var>.  Return the resulting load path.
</p></dd></dl>

<dl>
<dt><a name="index-time_002dcommand"></a><u>N-Command:</u> <b>time-command</b><i> ((command <small>CONS</small>)) : <small>OBJECT</small></i></dt>
<dd><p>Execute <var>command</var>, measure and report its CPU and elapsed time
needed for its execution, and then return its result.
</p></dd></dl>

<dl>
<dt><a name="index-unset_002dfeature"></a><u>N-Command:</u> <b>unset-feature</b><i> (&amp;rest (features <small>NAME</small>)) : <small>(LIST OF KEYWORD)</small></i></dt>
<dd><p>Disable the PowerLoom environment feature(s) named by <var>features</var>.
Return the list of enabled features.  Calling <code>unset-feature</code> without any
arguments can be used to display the currently enabled features.
See <code>set-feature</code> for a description of supported features.
</p></dd></dl>

<dl>
<dt><a name="index-why"></a><u>N-Command:</u> <b>why</b><i> (&amp;rest (args <small>OBJECT</small>)) :</i></dt>
<dd><p>Print an explanation for the result of the most recent query.
Without any arguments, <code>why</code> prints an explanation of the top level
query proposition down to a maximum depth of 3.  <code>(why all)</code> prints
an explanation to unlimited depth.  Alternatively, a particular depth
can be specified, for example, <code>(why 5)</code> explains down to a depth of 5.
A proof step that was not explained explicitly (e.g., due to a depth
cutoff) can be explained by supplying the label of the step as the
first argument to <code>why</code>, for example, <code>(why 1.2.3 5)</code> prints an explanation
starting at 1.2.3 down to a depth of 5 (which is counted relative to the
depth of the starting point).  The keywords <code>brief</code> and <code>verbose</code> can be
used to select a particular explanation style.  In brief mode, explicitly
asserted propositions are not further explained and indicated with a
<code>!</code> assertion marker.  Additionally, relatively uninteresting proof steps
such as AND-introductions are skipped.  This explanation style option is
sticky and will affect future calls to <code>why</code> until it gets changed again.
The various options can be combined in any way, for example,
<code>(why 1.2.3 brief 3)</code> explains starting from step 1.2.3 down to a depth
of 3 in brief explanation mode.
</p></dd></dl>



<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="manual_4.html#Communicating-with-PowerLoom" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="manual_6.html#PowerLoom-API" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="manual.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="manual_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="manual_14.html#Function-Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="manual_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Hans Chalupsky</em> on <em>September 20, 2011</em> using <a href="http://www.nongnu.org/texi2html/"><em>texi2html 1.82</em></a>.
 </font>
 <br>

</p>
</body>
</html>
