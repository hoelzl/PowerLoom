;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;; BEGIN LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
; Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          ;
;                                                                            ;
; The contents of this file are subject to the Mozilla Public License        ;
; Version 1.1 (the "License"); you may not use this file except in           ;
; compliance with the License. You may obtain a copy of the License at       ;
; http://www.mozilla.org/MPL/                                                ;
;                                                                            ;
; Software distributed under the License is distributed on an "AS IS" basis, ;
; WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   ;
; for the specific language governing rights and limitations under the       ;
; License.                                                                   ;
;                                                                            ;
; The Original Code is the STELLA Programming Language.                      ;
;                                                                            ;
; The Initial Developer of the Original Code is                              ;
; UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          ;
; 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               ;
;                                                                            ;
; Portions created by the Initial Developer are Copyright (C) 1996-2010      ;
; the Initial Developer. All Rights Reserved.                                ;
;                                                                            ;
; Contributor(s):                                                            ;
;                                                                            ;
; Alternatively, the contents of this file may be used under the terms of    ;
; either the GNU General Public License Version 2 or later (the "GPL"), or   ;
; the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   ;
; in which case the provisions of the GPL or the LGPL are applicable instead ;
; of those above. If you wish to allow use of your version of this file only ;
; under the terms of either the GPL or the LGPL, and not to allow others to  ;
; use your version of this file under the terms of the MPL, indicate your    ;
; decision by deleting the provisions above and replace them with the notice ;
; and other provisions required by the GPL or the LGPL. If you do not delete ;
; the provisions above, a recipient may use your version of this file under  ;
; the terms of any one of the MPL, the GPL or the LGPL.                      ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; END LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; Version: collections.ste,v 1.43 2010/09/08 20:47:48 hans Exp

;;; Procedures that implement sets, hash tables, arrays, etc.

(in-package "STELLA")

(in-module "/STELLA")


  ;;
;;;;;; Collections
  ;;

(defmethod (member? BOOLEAN) ((self COLLECTION) (object OBJECT))
  :documentation
  "Return true iff `object' is a member of the collection `self'."
  :public? TRUE
  (foreach i in self
      where (eql? i object)
      do (return TRUE))
  (return FALSE) )

(defmethod (remove-duplicates (LIKE self)) ((self COLLECTION))
  :documentation "Return `self' with duplicates removed.  Preserves the
original order of the remaining members."
  :public? TRUE :abstract? TRUE)

  ;;
;;;;;; Collection predicates (properties)
  ;;

;;; RENAMED TO `stella-collection?' TO AVOID A SHADOWING PROBLEM WITH A SIMILAR
;;; POWERLOOM FUNCTION.  ONCE WE FIX TRANSLATION OF SHADOWED NAMES (AND IF WE
;;; EVER REALLY CARE ABOUT THESE STELLA PREDICATES) WE SHOULD RENAME IT BACK.

(defun (stella-collection? BOOLEAN) ((self OBJECT))
  :public? TRUE
  :documentation "Return `true' if `self' is a native collection."
  (return (isa? self @COLLECTION)) )

(defmethod (no-duplicates? BOOLEAN) ((self COLLECTION))
  :public? TRUE
  :documentation
  "Return `true' if the collection `self' forbids duplicate values."
  (return FALSE) )

(defmethod (no-duplicates? BOOLEAN) ((self SET))
  :public? TRUE
  (return TRUE) )

(defmethod (ordered? BOOLEAN) ((self COLLECTION))
  :public? TRUE
  :documentation "Return `true' if the collection `self' is ordered."
  (return FALSE) )

(defmethod (ordered? BOOLEAN) ((self SEQUENCE))
  :public? TRUE
  (return TRUE) )

(defmethod (ordered? BOOLEAN) ((self SET))
  :public? TRUE
  (return FALSE) )


  ;;
;;;;;; Simple Sets
  ;;

;;; These are just like regular LISTs but with a few methods overridden
;;; to not allow insertion of duplicate elements.  Note, that elements
;;; can still be set destructively (e.g., via `(setf (first set) ...)')
;;; which would still potentially allow one to insert duplicates.

(defmethod insert ((self SET) (value (LIKE (any-value self))))
  :public? TRUE
  :documentation "Add `value' to the set `self' unless it is already a member."
  (when (not (member? self value))
    (setf (the-cons-list self) (cons value (the-cons-list self)))))

(defmethod push ((self SET) (value (LIKE (any-value self))))
  :public? TRUE
  :documentation
  "Add `value' to the front of set `self' unless it is already a member."
  (when (not (member? self value))
    (setf (the-cons-list self) (cons value (the-cons-list self)))))

(defmethod insert-last ((self SET) (value (LIKE (any-value self))))
  :documentation
  "Add `value' to the end of set `self' unless it is already a member."
  :public? TRUE
  (when (not (member? self value))
    (let ((cursor (the-cons-list self))
          (lastCons (cons value NIL)))
      (if (empty? cursor)
          (setf (the-cons-list self) lastCons)
        (add-cons-to-end-of-cons-list cursor lastCons)))))

(defmethod (remove-duplicates (LIKE self)) ((self SET))
  (return self))

(defmethod (substitute (LIKE self)) ((self SET) (new OBJECT) (old OBJECT))
  :documentation "Destructively replace `old' with `new' in the set `self'
unless `new' is already a member."
  :public? TRUE
  (when (not (member? self new))
    (setf (the-cons-list self) (substitute (the-cons-list self) new old)))
  (return self))

(defmethod (concatenate SET) ((set1 SET) (set2 LIST) &rest (otherSets LIST))
  :documentation "Union `set2' and all `otherSets' onto the end of `set1'.
The operation is destructive wrt `set1', but leaves all other sets intact.
The two mandatory parameters allow us to optimize the common binary case by
not relying on the somewhat less efficient variable arguments mechanism."
  :public? TRUE
  (let ((resultSet (the-cons-list set1)))
    (foreach elt in set2
        where (not (member? resultSet elt))
        collect elt into resultSet)
    (when (> (length otherSets) 0)
      (foreach oSet in otherSets
          do (foreach elt in oSet
                 where (not (member? resultSet elt))
                 collect elt into resultSet)))
    (setf (the-cons-list set1) resultSet)
    (return set1)))

(defmethod (object-equal? BOOLEAN) ((x SET) (y OBJECT))
  :documentation "Return TRUE iff `x' and `y' are SET's with equivalent members.
Uses `equal?' to test equality of elements.  This is more general than
`equivalent-sets?', since that only uses an `eql?' test."
  :public? TRUE
  (typecase y
    (SET
     (return
       (and (= (length x) (length y))
            (forall eltX in x
                always (exists eltY in y
                           where (equal? eltX eltY))))))
    (otherwise NULL))
  (return FALSE))

(defmethod (equal-hash-code INTEGER) ((self SET))
  :documentation "Return an `equal?' hash code for `self'.  Note that this
is O(N) in the number of elements of `self'."
  :public? TRUE
  (let ((cursor (the-cons-list self))
        (code 95880665)) ;; result of (hash-string "SET" 0)
    (loop
      (when (empty? cursor)
        (break))
      ;; exploits the fact that `XOR' is commutative:
      (setq code (logxor code (safe-equal-hash-code (value cursor))))
      (setq cursor (rest cursor)))
    (return code)))

(defun (set SET) (&rest (values OBJECT))
  :documentation "Return a set containing `values', in order."
  :public? TRUE
  (let ((set (new SET)))
    (foreach v in values
        where (not (member? set v))
        collect v into set)
    (return set) ))


  ;;
;;;;;; VECTORS, EXTENSIBLE-VECTORs and VECTOR-SEQUENCEs
  ;;

(defmethod print-vector ((self VECTOR) (stream NATIVE-OUTPUT-STREAM))
  (if (eq? (length self) 0)
      (print-native-stream stream "|i|[]")
    (let ((i 0)
          (limit 9))
      (print-native-stream stream "|i|[")
      (foreach element in self
               do
               (print-native-stream stream element)
               (++ i)
               (when (> i limit) (break))
               (when (< i (length self))
                 (print-native-stream stream " ")))
      (if (or (<= i limit)
              (eq? i (length self)))
          (print-native-stream stream "]")
        (print-native-stream stream " ...]")))))

(defmethod (empty? BOOLEAN) ((self VECTOR))
  :documentation "Return `true' if `self' has length 0."
  :public? TRUE ;:globally-inline? TRUE ;; now shadowed by VSEQ
  (return (eql? (array-size self) 0)) )

(defmethod (non-empty? BOOLEAN) ((self VECTOR))
  :documentation "Return `true' if `self' has length > 0."
  :public? TRUE ;:globally-inline? TRUE ;; now shadowed by VSEQ
  (return (> (array-size self) 0)) )

(defmethod (first (LIKE (any-value self))) ((self VECTOR))
  :public? TRUE
  :globally-inline? TRUE
  (return (nth self 0)))

(defmethod (second (LIKE (any-value self))) ((self VECTOR))
  :public? TRUE
  :globally-inline? TRUE
  (return (nth self 1)))

(defmethod (third (LIKE (any-value self))) ((self VECTOR))
  :public? TRUE
  :globally-inline? TRUE
  (return (nth self 2)))

(defmethod (fourth (LIKE (any-value self))) ((self VECTOR))
  :public? TRUE
  :globally-inline? TRUE
  (return (nth self 3)))

(defmethod (fifth (LIKE (any-value self))) ((self VECTOR))
  :public? TRUE
  :globally-inline? TRUE
  (return (nth self 4)))

(defmethod (nth (LIKE (any-value self))) ((self VECTOR) (position INTEGER))
  :public? TRUE
  :globally-inline? TRUE
  (return (nth (the-array self) position)))

(defmethod (last (LIKE (any-value self))) ((self VECTOR))
  :public? TRUE
  :documentation "Return the last item in the vector `self'."
  (return (nth self (1- (array-size self)))) )

(defmethod (first-setter (LIKE (any-value self)))
    ((self VECTOR) (value (LIKE (any-value self))))
  :public? TRUE
  :globally-inline? TRUE
  (return (setf (nth self 0) value)))

(defmethod (second-setter (LIKE (any-value self)))
    ((self VECTOR) (value (LIKE (any-value self))))
  :public? TRUE
  :globally-inline? TRUE
  (return (setf (nth self 1) value)))

(defmethod (third-setter (LIKE (any-value self)))
    ((self VECTOR) (value (LIKE (any-value self))))
  :public? TRUE
  :globally-inline? TRUE
  (return (setf (nth self 2) value)))

(defmethod (fourth-setter (LIKE (any-value self)))
    ((self VECTOR) (value (LIKE (any-value self))))
  :public? TRUE
  :globally-inline? TRUE
  (return (setf (nth self 3) value)))

(defmethod (fifth-setter (LIKE (any-value self)))
    ((self VECTOR) (value (LIKE (any-value self))))
  :public? TRUE
  :globally-inline? TRUE
  (return (setf (nth self 4) value)))

(defmethod (nth-setter (LIKE (any-value self)))
    ((self VECTOR) (value (LIKE (any-value self))) (position INTEGER))
  :public? TRUE
  :globally-inline? TRUE
  (return (setf (nth (the-array self) position) value)))

(defmethod (last-setter (LIKE (any-value self)))
    ((self VECTOR) (value (LIKE (any-value self))))
  :public? TRUE
  (return (setf (nth self (1- (array-size self))) value)))

(defmethod (length INTEGER) ((self VECTOR))
  :public? TRUE
  ;;:globally-inline? `true' ;; can't inline, since VECTOR-SEQUENCE shadows it
  (return (array-size self)))

(defmethod (member? BOOLEAN) ((self VECTOR) (object OBJECT))
  :public? TRUE
  (let ((array (the-array self)))
    (foreach i in (interval 0 (1- (length self)))
             where (eql? (nth array i) object)
             do (return TRUE))
    (return FALSE) ))

(defmethod (position INTEGER) ((self VECTOR) (object OBJECT) (start INTEGER))
  :documentation "Return the position of `object' within the vector
`self' (counting from zero); or return `null' if `object' does not occur within 
`self' (uses an `eql?' test).  If `start' was supplied as non-`null', only 
consider the portion starting at `start', however, the returned position 
will always be relative to the entire vector."
  :public? TRUE
  (when (null? start)
    (setq start 0))
  (foreach i in (interval start (1- (length self)))
           where (eql? (nth self i) object)
           do (return i))
  (return NULL))

(defmethod (last-position INTEGER) ((self VECTOR) (object OBJECT) (end INTEGER))
  :documentation "Return the position of `object' within the vector
`self' (counting from zero); or return `null' if `object' does not occur within 
`self' (uses an `eql?' test).  If `end' was supplied as non-`null', only 
consider the portion ending at index `end', however, the returned position 
will always be relative to the entire vector."
  :public? TRUE
  (when (null? end)
    (setq end (1- (length self))))
  (foreach i in (reverse (interval 0 end))
           where (eql? (nth self i) object)
           do (return i))
  (return NULL))

(defmethod insert-at ((self VECTOR) (offset INTEGER)
                      (value (LIKE (any-value self))))
  (when (>= offset (array-size self))
    (error "Out-of-bounds array access"))
  (setf (nth self offset) value))

(defmethod (copy (VECTOR OF (LIKE (any-value self)))) ((self VECTOR))
  :documentation "Return a copy of the vector `self'."
  :public? TRUE
  (let ((size (array-size self))
        (sourceArray (the-array self))
        (copy (new VECTOR :array-size size))
        (copyArray (the-array copy)))
    (foreach i in (interval 0 (1- size))
        do (setf (nth copyArray i) (nth sourceArray i)))
    (return copy)))

(defmethod clear ((self VECTOR))
  :public? TRUE
  (let ((size (array-size self))
        (array (the-array self)))
    (foreach i in (interval 0 (1- size))
        do (setf (nth array i) NULL))))

(defun (vector VECTOR) (&rest (values OBJECT))
  :documentation "Return a vector containing `values', in order."
  :public? TRUE
  (let ((vector (new VECTOR :array-size (length values))))
    (foreach v in values
        as i in (interval 0 NULL)
        do (setf (nth vector i) v))
    (return vector)))

(startup-time-progn
  ;; handle conflict with STL function:
  (register-native-name (quote vector) :cpp :function))

(defmethod (object-equal? BOOLEAN) ((x VECTOR) (y OBJECT))
  :documentation "Return TRUE iff the vectors `x' and `y' are structurally
equivalent.  Uses `equal?' to test equality of elements."
  :public? TRUE
  (typecase y
    (VECTOR
     (when (= (array-size x) (array-size y))
       (foreach eltX in x
           as eltY in y
           where (not (equal? eltX eltY))
           do (return FALSE))
       (return TRUE)))
    (otherwise NULL))
  (return FALSE))

(defmethod (equal-hash-code INTEGER) ((self VECTOR))
  :documentation "Return an `equal?' hash code for `self'."
  :public? TRUE
  (let ((cursor (length self))
        (code 66435053)) ;; result of (hash-string "VECTOR" 0)
    (loop
      (if (= cursor 0)
          (break)
        (-- cursor))
      (setq code (logxor code (safe-equal-hash-code (nth self cursor))))
      ;; rotate right to take element ordering into account:
      (setq code (rotate-hash-code code)))
    (return code)))

(defmethod insert-at ((self EXTENSIBLE-VECTOR) (offset INTEGER)
                      (value (LIKE (any-value self))))
  :public? TRUE
  (when (>= offset (array-size self))
    (let ((size (array-size self)))
      (while (>= offset size) (setq size (* 2 size)))
      (resize-vector self size)))
  (setf (nth self offset) value))

(defmethod insert-at ((self EXTENSIBLE-SYMBOL-ARRAY) (offset INTEGER)
                      (value (LIKE (any-value self))))
  :public? TRUE
  (when (>= offset (array-size self))
    (let ((size (array-size self)))
      (while (>= offset size) (setq size (* 2 size)))
      (resize-vector self size)))
  (setf (nth self offset) value)
  (when (> offset (top-symbol-offset self))
    (setf (top-symbol-offset self) offset)) )


(defmethod (empty? BOOLEAN) ((self VECTOR-SEQUENCE))
  :documentation "Return `true' if `self' has length 0."
  :public? TRUE :globally-inline? TRUE
  (return (eql? (length self) 0)) )

(defmethod (non-empty? BOOLEAN) ((self VECTOR-SEQUENCE))
  :documentation "Return `true' if `self' has length > 0."
  :public? TRUE :globally-inline? TRUE
  (return (> (length self) 0)) )

(defmethod (length INTEGER) ((self VECTOR-SEQUENCE))
  :public? TRUE :globally-inline? TRUE
  (return (sequence-length self)) )

(defmethod (last (LIKE (any-value self))) ((self VECTOR-SEQUENCE))
  :public? TRUE
  :documentation "Return the last item in the vector `self'."
  (return (nth self (1- (length self)))) )

(defmethod (last-setter (LIKE (any-value self)))
    ((self VECTOR-SEQUENCE) (value (LIKE (any-value self))))
  :public? TRUE
  (return (setf (nth self (1- (length self))) value)))

(defmethod insert ((self VECTOR-SEQUENCE) (value (LIKE (any-value self))))
  :documentation "Append `value' to the END of the sequence `self'.  
Resize the array if necessary."
  :public? TRUE
  (let ((oldLength (sequence-length self)))
    (when (eq? oldLength (array-size self))
      (resize-vector self (* (array-size self) 2)))
    (setf (nth self oldLength) value)
    (setf (sequence-length self) (1+ oldLength)) ))

(defmethod insert ((self CUSTOM-VECTOR-SEQUENCE) (value (LIKE (any-value self))))
  :documentation "Append `value' to the END of the sequence `self'.  
Resize the array if necessary."
  :public? TRUE
  (let ((oldLength (sequence-length self)))
    (when (eq? oldLength (array-size self))
      (safety 1 (> (resize-factor self) 1.0)
              "CUSTOM-VECTOR-SEQUENCE.insert: resize factor needs to be > 1")
      (resize-vector self (* (array-size self) (resize-factor self))))
    (setf (nth self oldLength) value)
    (setf (sequence-length self) (1+ oldLength)) ))

(defmethod (remove VECTOR-SEQUENCE)
    ((self VECTOR-SEQUENCE) (value (LIKE (any-value self))))
  :documentation "Remove `value' from the sequence `self', and left shift
the values after it to close the gap."
  :public? TRUE
  (let ((array (the-array self))
        (firstShiftOffset -1)           ; initialize to impossible value
        (lastShiftOffset (- (sequence-length self) 1)))
    (foreach i in (interval 0 lastShiftOffset)
        do (when (eql? (nth array i) value)
             (setq firstShiftOffset (1+ i))
             (break)))
    (when (eq? firstShiftOffset -1)     ; exit if `value' not found
      (return self))
    (when (<= firstShiftOffset lastShiftOffset)
      (foreach j in (interval firstShiftOffset lastShiftOffset)
               do (setf (nth array (1- j)) (nth array j))))
    (setf (nth array lastShiftOffset) NULL)        ; clear last offset
    (setf (sequence-length self) lastShiftOffset)
    (return self)))

(defmethod (reverse (LIKE self)) ((self VECTOR-SEQUENCE))
  :documentation "Reverse the order of elements in the active portion of `self'."
  :public? TRUE
  (let ((array (the-array self))
        (bottom 0)
        (top (1- (sequence-length self)))
        (elt OBJECT NULL))
    (while (< bottom top)
      (setq elt (nth array bottom))
      (setf (nth array bottom) (nth array top))
      (setf (nth array top) elt)
      (++ bottom)
      (-- top))
    (return self)))

(defun copy-vector-sequence ((source VECTOR-SEQUENCE) (copy VECTOR-SEQUENCE))
  ;; Copy the active portion of `source' into `copy'.
  (let ((sourceArray (the-array source))
        (copyArray (the-array copy))
        (length (sequence-length source)))
    (setf (sequence-length copy) length)
    (foreach i in (interval 0 (1- length))
        do (setf (nth copyArray i) (nth sourceArray i)))))

(defmethod (copy (VECTOR-SEQUENCE OF (LIKE (any-value self)))) ((self VECTOR-SEQUENCE))
  :documentation "Return a copy of the vector sequence `self'."
  :public? TRUE
  (let ((copy (new VECTOR-SEQUENCE :array-size (array-size self))))
    (copy-vector-sequence self copy)
    (return copy)))

(defmethod (copy (CUSTOM-VECTOR-SEQUENCE OF (LIKE (any-value self))))
    ((self CUSTOM-VECTOR-SEQUENCE))
  :documentation "Return a copy of the vector sequence `self'."
  :public? TRUE
  (let ((copy (new CUSTOM-VECTOR-SEQUENCE :array-size (array-size self))))
    (setf (resize-factor copy) (resize-factor self))
    (copy-vector-sequence self copy)
    (return copy)))

(defmethod clear ((self VECTOR-SEQUENCE))
  :documentation "Clear `self' by setting its active length to zero."
  :public? TRUE
  (setf (sequence-length self) 0))

(defmethod (object-equal? BOOLEAN) ((x VECTOR-SEQUENCE) (y OBJECT))
  :documentation "Return TRUE iff the sequences `x' and `y' are structurally
equivalent.  Uses `equal?' to test equality of elements."
  :public? TRUE
  (typecase y
    (VECTOR-SEQUENCE
     (when (= (length x) (length y))
       (foreach eltX in x
           as eltY in y
           where (not (equal? eltX eltY))
           do (return FALSE))
       (return TRUE)))
    (otherwise NULL))
  (return FALSE))


;;; Iteration over VECTORs

(defmethod (allocate-iterator (ITERATOR OF (LIKE (any-value self))))
    ((self VECTOR))
  (let ((iterator (new ALL-PURPOSE-ITERATOR)))
    (setf (iterator-object iterator) self)
    (setf (iterator-integer iterator) 0)
    (setf (iterator-second-integer iterator) (length self))
    (setf (iterator-next-code iterator)
      (the-code :function vector-next?))
    (return iterator)))

(defun (vector-next? BOOLEAN) ((self ALL-PURPOSE-ITERATOR))
  ;; Iterates over all elements of a vector stored within `self'.
  (let ((cursor (iterator-integer self)))
    (when (< cursor (iterator-second-integer self))
      (setf (slot-value self value)
        (nth (safe-cast (iterator-object self) VECTOR) cursor))
      (setf (iterator-integer self) (+ cursor 1))
      (return TRUE))
    (return FALSE)))

(defmethod (but-last (ITERATOR OF (LIKE (any-value self)))) ((self VECTOR))
  :documentation "Generate all but the last element of the vector `self'."
  :public? TRUE
  (let ((iterator (new ALL-PURPOSE-ITERATOR)))
    (setf (iterator-object iterator) self)
    (setf (iterator-integer iterator) 0)
    (setf (iterator-second-integer iterator) (1- (array-size self)))
    (setf (iterator-next-code iterator)
      (the-code :function vector-next?))
    (return iterator)))


;;; Sorting:

(defmethod (sort (VECTOR OF (LIKE (any-value self))))
    ((self VECTOR) (predicate FUNCTION-CODE))
  :public? TRUE
  :documentation "Perform a destructive sort of `self' according to
`predicate', and return the result.  If `predicate' has a '<' semantics, the
result will be in ascending order.  If `predicate' is `null', a
suitable '<' predicate is chosen depending on the first element of `self',
and it is assumed that all elements of `self' have the same type (supported
element types are GENERALIZED-SYMBOL, STRING, INTEGER, and FLOAT)."
  (let ((length (length self)))
    (cond ((= length 0)
           (return self))
          ((null? predicate)
           (setq predicate (choose-sort-predicate (nth self 0)))))
    ;; note: using `length' here will make this work for VECTOR-SEQUENCEs, etc. as well:
    (heap-sort-native-vector (the-array self) (length self) predicate)
    (return self)))

(defun heap-sort-native-vector ((vector NATIVE-VECTOR)
                                (size INTEGER)
                                (predicate FUNCTION-CODE))
  (heap-sort-heapify vector size predicate) ;; generate max heap
  (let ((end (1- size))
        (aux OBJECT NULL))
    (while (> end 0)
      ;; swap the root (the max value) with the last element of the heap:
      (setq aux (nth vector 0))
      (setf (nth vector 0) (nth vector end))
      (setf (nth vector end) aux)
      (-- end)
      ;; put the remaining heap back in max heap order:
      (heap-sort-sift-down vector 0 end predicate))))

(defun heap-sort-heapify ((vector NATIVE-VECTOR) (size INTEGER) (predicate FUNCTION-CODE))
  (let ((start (1- (shift-right size 1)))) ;; index of the last parent node
    (while (>= start 0)
      ;; sift down node at start to the proper place such that all
      ;; nodes below start are in heap order:
      (heap-sort-sift-down vector start (1- size) predicate)
      (-- start))))

(defun heap-sort-sift-down
    ((vector NATIVE-VECTOR) (start INTEGER) (end INTEGER) (predicate FUNCTION-CODE))
  (let ((root start)
        (child 0)
        (aux OBJECT NULL))
    (loop
      (setq child (1+ (shift-left root 1))) ;; left child
      (when (> child end)
        ;; root has no children:
        (break))
      ;; If the child has a sibling and is smaller than the sibling:
      (when (and (< child end)
                 (funcall predicate (nth vector child) (nth vector (1+ child))))
        ;; point to the right child instead:
        (++ child))
      (cond ((funcall predicate (nth vector root) (nth vector child))
             ;; out of max-heap order:
             (setq aux (nth vector root))
             (setf (nth vector root) (nth vector child))
             (setf (nth vector child) aux)
             (setq root child))
            (otherwise
             (return))))))

;;; Here is a quick sort which does a stable sort; unfortunately, it does very
;;; badly if we have long runs of equal elements (there is probably a way to fix this).

(defun (quick-sort-pick-split-element OBJECT)
    ((vector NATIVE-VECTOR) (start INTEGER) (end INTEGER) (predicate FUNCTION-CODE))
  ;; Try to pick a good split element for sorting `vector' by finding the middle of
  ;; the first, middle and last elements.  Assumes that the length of `vector' is >= 3.
  ;; This performs between two and three comparisons.  We could also use `random' here.
  ;; TO DO: WE SHOULD USE THIS FOR THE CONS-SORT AS WELL.
  (let ((splitElement (nth vector start))
        (middle (shift-right (+ start end) 1)))
    (-- end)
    (if (funcall predicate splitElement (nth vector middle))
        ;; s < m
        (cond ((funcall predicate (nth vector middle) (nth vector end))
               ;; s < m < e
               (setq splitElement (nth vector middle))
               (setf (nth vector middle) (nth vector start)))
              ((funcall predicate splitElement (nth vector end))
               ;; s < e < m
               (setq splitElement (nth vector end))
               (setf (nth vector end) (nth vector start)))
              (otherwise
               ;; e < s < m
               NULL))
      ;; m < s
      (cond ((funcall predicate splitElement (nth vector end))
             ;; m < s < e
             NULL)
            ((funcall predicate (nth vector middle) (nth vector end))
             ;; m < e < s
             (setq splitElement (nth vector end))
             (setf (nth vector end) (nth vector start)))
            (otherwise
             ;; e < m < s
             (setq splitElement (nth vector middle))
             (setf (nth vector middle) (nth vector start)))))
    (return splitElement)))
                      
(defun quick-sort-native-vector
    ((vector NATIVE-VECTOR) (start INTEGER) (end INTEGER) (predicate FUNCTION-CODE))
  ;; Use Quick Sort to sort `vector' between `start' and `end' according to `predicate'.
  (loop
    (let ((length (- end start))
          (splitElement OBJECT NULL)
          (element OBJECT NULL)
          (lowCursor start)
          (highCursor end))
      (cond ((<= length 1)
             (return))
            ((>= length 10)  ;; not sure what the optimum choice is here
             (setq splitElement (quick-sort-pick-split-element vector start end predicate)))
            (otherwise       ;; we could use an insertion sort for small vectors
             (setq splitElement (nth vector start))))
      (while (< lowCursor highCursor)
        (while (< lowCursor highCursor)
          (-- highCursor)
          (setq element (nth vector highCursor))
          (when (funcall predicate element splitElement)
            (setf (nth vector lowCursor) element)
            (break)))
        (while (< lowCursor highCursor)
          (++ lowCursor)
          (setq element (nth vector lowCursor))
          (when (funcall predicate splitElement element)
            (setf (nth vector highCursor) element)
            (break))))
      (setf (nth vector highCursor) splitElement)
      ;; recurse on the shorter partition and handle the other one in-line via iteration:
      (cond ((< (shift-right (+ start end) 1) highCursor)
             ;; split-point is above half:
             (quick-sort-native-vector vector (1+ highCursor) end predicate)
             (setq end highCursor))
            (otherwise
             (quick-sort-native-vector vector start highCursor predicate)
             (setq start (1+ highCursor)))))))


  ;;
;;;;;; HEAPs
  ;;

(defclass HEAP (VECTOR)
  :documentation "Implements a Min or Max heap depending on the semantics
of `predicate' (Min if `predicate' has a `<' semantics).  This is useful
for in-place sorting (even though we have specialzed sort routines for that)
or to maintain top-N lists with log(N) insertion time.  We place this under
VECTOR instead of VECTOR-SEQUENCE for now, since sequential order isn't
really maintained or accessible until we sort the heap."
  :public? TRUE
  :parameters ((any-value :type OBJECT))
  :slots ((predicate :type FUNCTION-CODE :required? true)
          (fill-pointer :type INTEGER :initially 0))
  :initializer initialize-heap)

(defmethod initialize-heap ((self HEAP))
  ;; Forcing a non-empty heap array makes some of the top-level
  ;; functions below simpler, since they don't have to test for
  ;; this not very useful case.
  (let ((size (array-size self)))
    (safety 1 (> size 0) "Trying to create an empty heap")))

(defmethod clear ((self HEAP))
  :documentation "Clear `self' by setting its active length to zero."
  :public? TRUE
  (setf (fill-pointer self) 0))

(defmethod (length INTEGER) ((self HEAP))
  :documentation "Return the length of the currently filled portion of `self'."
  :public? TRUE
  (return (fill-pointer self)))

(defmethod (empty? BOOLEAN) ((self HEAP))
  :documentation "Return TRUE if `self' is empty."
  :public? TRUE
  (return (= (fill-pointer self) 0)))

(defmethod (heap-root (LIKE (any-value self))) ((self HEAP))
  :documentation "Return the root of `self' (NULL if `self' is empty)."
  :public? TRUE
  (return (choose (empty? self) NULL (nth self 0))))

(defmethod (fast-heap-root (LIKE (any-value self))) ((self HEAP))
  :documentation "Return the root of `self' which is assumed to be non-empty."
  :public? TRUE :globally-inline? TRUE
  (return (nth self 0)))

(defun heap-sift-up ((heap NATIVE-VECTOR)
                     (start INTEGER)
                     (end INTEGER)
                     (value (LIKE (any-value self)))
                     (predicate FUNCTION-CODE))
  ;; Min-heap inserter/up-sifter (if `predicate' has `<' semantics) for a
  ;; `heap' array of values between `start' and `end'.  Insert `value'
  ;; at `heap[end]' (assumed to be a free and valid array element) and
  ;; restore the heap property up to `start'.
  (let ((parent INTEGER NULL)
        (child end))
    (setf (nth heap end) value)
    (while (> child start)
      (if (= (logand child 1) 0) ;; even?
          (setq parent (shift-right (- child 2) 1))
        (setq parent (shift-right (1- child) 1)))
      (cond ((funcall predicate value (nth heap parent))
             (setf (nth heap child) (nth heap parent))
             (setf (nth heap parent) value)
             (setq child parent))
            (otherwise
             (break))))))

(defun heap-sift-down ((heap NATIVE-VECTOR)
                       (start INTEGER)
                       (end INTEGER)
                       (value (LIKE (any-value self)))
                       (predicate FUNCTION-CODE))
  ;; Min-heap down-sifter (if `predicate' has `<' semantics) for a
  ;; `heap' array of values between `start' and `end'.  Destructively
  ;; replace `heap[start]' (assumed to be a valid array element) with
  ;; `value' and restore the heap property down to `end'.
  (let ((parent start)
        (child INTEGER NULL)
        (leftChild OBJECT NULL)
        (rightChild OBJECT NULL))
    (setf (nth heap start) value)
    (-- end) ;; point at last element
    (loop
      (setq child (1+ (shift-left parent 1)))
      (cond ((> child end)
             ;; no more children to check:
             (break))
            ((= child end)
             ;; we only have a left child; swap if child < value:
             (unless (funcall predicate (nth heap child) value)
               (break)))
            (otherwise
             ;; we have two children, determine which one to swap:
             (setq leftChild (nth heap child))
             (setq rightChild (nth heap (1+ child)))
             (cond ((funcall predicate leftChild value)
                    ;; swap, but test whether right child is the correct choice:
                    (when (and (funcall predicate rightChild value)
                               (funcall predicate rightChild leftChild))
                      ;; right child is smaller than both:
                      (++ child)))
                   ((funcall predicate rightChild value)
                    ;; only right child is smaller than `value':
                    (++ child))
                   (otherwise
                    (break)))))
      (setf (nth heap parent) (nth heap child))
      (setf (nth heap child) value)
      (setq parent child))))

(defmethod insert ((self HEAP) (value (LIKE (any-value self))))
  :documentation "Insert `value' into `self' and restore the heap property.
Signal an error if there is no more room in `self'.  Maintains `self' as
a Min-heap if `self's `predicate' has `<' semantics; otherwise as a Max-heap."
  :public? TRUE
  (let ((values (the-array self))
        (fillPointer (fill-pointer self))
        (predicate (predicate self)))
    (cond ((< fillPointer (array-size self))
           (heap-sift-up values 0 fillPointer value predicate)
           (setf (fill-pointer self) (1+ fillPointer)))
          ;; in case we want to implement extensible heaps, this is the
          ;; only method we need to override:
          ;((extensible-heap? self)
          ; (resize-vector self (* (array-size self) (resize-increment self)))
          ; (heap-sift-up values 0 fillPointer value predicate))
          (otherwise
           (error "HEAP.insert: heap overflow, can't insert new value: " value)))))

(defmethod replace-heap-root ((self HEAP) (value (LIKE (any-value self))))
  :documentation "Replace the current root of `self' with `value' and restore
the heap property.  Signal an error if `self' is empty.  Maintains `self' as
a Min-heap if `self's `predicate' has `<' semantics; otherwise as a Max-heap."
  :public? TRUE
  (let ((values (the-array self))
        (fillPointer (fill-pointer self))
        (predicate (predicate self)))
    (if (= fillPointer 0)
        (error "HEAP.replace-heap-root: can't replace root of an empty heap")
      (heap-sift-down values 0 fillPointer value predicate))))

(defmethod insert-if-better ((self HEAP) (value (LIKE (any-value self))))
  :documentation "Insert `value' into `self' and restore the heap property.
If `self' has available room, simply insert `value'.  If the heap is full, only
insert `value' if it is better than the current root (i.e., the minimum of `self'
if `self's `predicate' has `<' semantics).  In that case, replace the root of
`self' and restore the heap property.  This is useful to build and maintain a
heap with some top-N elements (relative to `predicate') where the root (or
minimum) of `self' is the currently weakest element at the end of the list."
  :public? TRUE
  (let ((values (the-array self))
        (fillPointer (fill-pointer self))
        (predicate (predicate self)))
    ;; Note that we enforce non-empty heap arrays, which means `(nth
    ;; self 0)' will be defined if the heap is full and there will be
    ;; a free element to insert into if it isn't:
    (cond ((= fillPointer (array-size self))
           (when (funcall predicate (nth self 0) value)
             (heap-sift-down values 0 fillPointer value predicate)))
          (otherwise
           (heap-sift-up values 0 fillPointer value predicate)
           (setf (fill-pointer self) (1+ fillPointer))))))

(defmethod heapify ((self HEAP))
  :documentation "Restore the heap property of `self' according to its
`predicate'.  Normally, this is not needed, since insert operations
preserve the heap property.  However, this can be useful after bulk
insertion of values or if `predicate' has been changed."
  :public? TRUE
  (let ((values (the-array self))
        (fillPointer (fill-pointer self))
        (predicate (predicate self)))
    (foreach i in (interval 0 (1- fillPointer))
        do (heap-sift-up values 0 i (nth values i) predicate))))

(defmethod (sort (HEAP OF (LIKE (any-value self)))) ((self HEAP)
                                                     (predicate FUNCTION-CODE))
  :documentation "Sort the heap `self' according to `predicate' (in
ascending order if `predicate' has `<' semantics).  If `predicate'
is NULL simply use `self's internal predicate (the normal case).
If it is different from `self's internal predicate, heapify `self' first
according to the new predicate, store the new predicate in `self' and
then sort the heap.  Note that a sorted array automatically satisfies
the heap property.  This is slightly different than a regular heap
sort due to the way HEAP's are maintained; however, the complexity is
the same."
  :public? TRUE
  (let ((values (the-array self))
        (cursor (fill-pointer self))
        (value OBJECT NULL))
    (cond ((null? predicate)
           (setq predicate (predicate self))) 
          ((not (eql? predicate (predicate self)))
           (setf (predicate self) predicate)
           (heapify self)))
    (while (> cursor 0)
      ;; move the current minimum to the end:
      (-- cursor)
      (setq value (nth values cursor))
      (setf (nth values cursor) (nth values 0))
      ;; sift down the replaced value:
      (heap-sift-down values 0 cursor value predicate))
    ;; now reverse the order - in a specialized heap sort we wouldn't
    ;; have to do that, since we'd construct the heap in the proper way:
    (setq cursor (fill-pointer self))
    (foreach i in (interval 0 NULL)
        do (-- cursor)
           (when (>= i cursor)
             (break))
           (setq value (nth values i))
           (setf (nth values i) (nth values cursor))
           (setf (nth values cursor) value))
    (return self)))


#|
;;; Old stuff, but maybe we'll resurrect it some time:

  ;;
;;;;;; Tables with built-in caches
  ;;

(defclass TABLE-WITH-UNIT-CACHE (DICTIONARY)
  :documentation "Implements a key-value table with a cache of the
last key and value retrieved.  For the case when the same object
may be repeatedly searched in the table."
  :parameters ((any-value :type OBJECT))
  :slots ((the-hash-table :type HASH-TABLE)
          (the-cache-key :type ANYTHING)
          (the-cache-value :type OBJECT))
  :initializer initialize-table
  )

(defmethod initialize-table ((self TABLE-WITH-UNIT-CACHE))
  ;; Create a hash table and store it in `self'.
  (setf (the-hash-table (new HASH-TABLE))) )

(defmethod (lookup (LIKE (any-value self)))
           ((self TABLE-WITH-UNIT-CACHE) (key (LIKE (any-key self))))
  ;; Use the unit cache to accelerate lookup.
  (when (eql? key (the-cache-key self))
    (return (the-cache-value self)))
  (let ((value (lookup (the-hash-table self) key)))
    (setf (the-cache-key self) key)
    (setf (the-cache-value self) value)
    (return value) ))

(defmethod insert-at ((self TABLE-WITH-UNIT-CACHE) (key (LIKE (any-key self)))
                      (value (LIKE (any-value self))))
  ;; Insert <key, value> into a hash table and into the unit cache.
  (insert-at (the-hash-table self) key value) )

(defmethod remove-at ((self TABLE-WITH-UNIT-CACHE) (key (LIKE (any-key self))))
  ;; Remove the entry at <key> from the hash table and the unit cache.
  (remove-at (the-hash-table self) key)
  (when (eql? key (the-cache-key self))
    (setf (the-cache-key self) NULL)
    (setf (the-cache-value self) NULL)) )
|#

  ;;
;;;;;; STELLA implementation of hash tables
  ;;

;;; TO DO:
;;; - optimize literal types (avoid wrapping if possible)
;;; - optimize usage of `hash-code' vs. `object-hash-code'
;;; - optimize usage of `eq?' vs. `eql?'
;;; + implement iteration
;;; - implement shrinking if we deleted lots of entries?

;;; They are not yet used by default (see methods in `primal.ste'):
(defglobal *use-stella-hash-tables?* BOOLEAN
  (verbatim
    :common-lisp "CL-USER::*use-stella-hash-tables?*"
    :cpp "
#ifndef HAVE_SGI_HASH_MAPS
  TRUE
#else
  FALSE
#endif
"
    :otherwise FALSE))

(defclass STELLA-HASH-TABLE (ABSTRACT-HASH-TABLE)
  :parameters ((any-key :type OBJECT) (any-value :type OBJECT))
  :slots ((the-table :type (ARRAY () OF KV-CONS))
          (size :type INTEGER)
          (initial-size :type INTEGER :initially 50 :public? TRUE
                        :documentation "If supplied, the initial hash table
will be sized to hold at least that many elements.")
          (free-elements :type INTEGER)
          (equal-test? :type BOOLEAN :initially FALSE :public? TRUE
                       :documentation "If true use `equal?' as the
equality test and `equal-hash-code' as the hash function, otherwise,
use `eql?' and `hash-code' (the default).")))

(defglobal *stella-hash-table-avg-bucket-length* FLOAT 1.0)

(defun initialize-stella-hash-table ((self STELLA-HASH-TABLE))
  ;; Initialize the (assumed to be) uninitialized hash table `self'.
  (let ((size (pick-hash-table-size-prime
               (floor (/ (initial-size self)
                         *stella-hash-table-avg-bucket-length*))))
        (table (new (ARRAY () OF KV-CONS) :size size)))
    (foreach i in (interval 0 (1- size))
        do (setf (aref table i) NULL))
    (setf (the-table self) table)
    (setf (size self) size)
    (setf (free-elements self)
      (floor (* size *stella-hash-table-avg-bucket-length*)))))

(defmethod initialize-hash-table ((self STELLA-HASH-TABLE))
  :documentation "Initialize the STELLA hash table `self'.  This is a
no-op and primarily exists to shadow the standard initializer inherited
from ABSTRACT-HASH-TABLE.  STELLA hash tables are initialized at the
first insertion operation."
  NULL)

(defun rehash-stella-hash-table ((self STELLA-HASH-TABLE) (newSize INTEGER))
  ;; Rehash `self' into a table of `newSize' and adjust `self's
  ;;    `free-elements' accordingly.
  ;; `newSize' can be smaller than the current size of `self' in which
  ;;    case there should be sufficient `free-elements' available to
  ;;    allow the size reduction without generating long collision chains.
  (when (null? (the-table self))
    (initialize-stella-hash-table self)
    (return))
  (let ((size (size self))
        (table (the-table self))
        (newTable (new (ARRAY () OF KV-CONS) :size newSize))
        (newBucketIndex 0)
        (newBucket KV-CONS NULL)
        (cursor KV-CONS NULL)
        (current KV-CONS NULL)
        (equalTest? (equal-test? self)))
    (foreach i in (interval 0 (1- newSize))
        do (setf (aref newTable i) NULL))
    (foreach i in (interval 0 (1- size))
        do (setq cursor (aref table i))
           (while (defined? cursor)
             (if equalTest?
                 (setq newBucketIndex
                   (hashmod (equal-hash-code (key cursor)) newSize))
               (setq newBucketIndex
                 (hashmod (hash-code (key cursor)) newSize)))
             (setq newBucket (aref newTable newBucketIndex))
             (setq current cursor)
             (setq cursor (rest cursor))
             (cond ((defined? newBucket)
                    ;; insert destructively to avoid another array access:
                    (setf (rest current) (rest newBucket))
                    (setf (rest newBucket) current))
                   (otherwise
                    (setf (aref newTable newBucketIndex) current)
                    (setf (rest current) NULL)))))
    (setf (the-table self) newTable)
    (setf (size self) newSize)
    (setf (free-elements self)
      (max (+ (free-elements self)
              ;; free elements we gain/lose from the size change:
              (floor (* (- newSize size)
                        *stella-hash-table-avg-bucket-length*)))
           0))))

(defun stella-hash-table-insert-at ((self STELLA-HASH-TABLE)
                                    (key OBJECT)
                                    (value OBJECT))
  ;; Insert `value' at `key' into self.  If using an `eql?' test this
  ;;    does the appropriate thing for wrappers by using `hash-code'.
  (let ((table (the-table self))
        (free (free-elements self))
        (bucketIndex 0)
        (bucket KV-CONS NULL)
        (equalTest? (equal-test? self)))
    (when (null? table)
      (initialize-stella-hash-table self)
      (setq table (the-table self))
      (setq free (free-elements self)))
    (when (= free 0)
      (rehash-stella-hash-table
       self (pick-hash-table-size-prime (1+ (size self)))) ;; pick next prime
      (setq table (the-table self))
      (setq free (free-elements self)))
    (if equalTest?
        (setq bucketIndex (hashmod (equal-hash-code key) (size self)))
      (setq bucketIndex (hashmod (hash-code key) (size self))))
    (setq bucket (aref table bucketIndex))
    (cond ((null? bucket)
           (setf (aref table bucketIndex)
             (new KV-CONS :key key :value value))
           (setf (free-elements self) (1- free)))
          (otherwise
           (let ((cursor bucket))
             (cond (equalTest?
                    (while (and (defined? cursor)
                         (not (equal? (key cursor) key)))
                      (setq cursor (rest cursor))))
                   (otherwise
                    (while (and (defined? cursor)
                                (not (eql? (key cursor) key)))
                      (setq cursor (rest cursor)))))
             (cond ((defined? cursor)
                    (setf (value cursor) value))
                   (otherwise
                    ;; insert destructively to avoid another array access:
                    (setf (rest bucket)
                      (new KV-CONS :key key :value value :rest (rest bucket)))
                    (setf (free-elements self) (1- free)))))))))

(defun stella-hash-table-remove-at ((self STELLA-HASH-TABLE) (key OBJECT))
  ;; Remove the entry for `key' from self.  If using an `eql?' test this
  ;;    does the appropriate thing for wrappers by using `hash-code'.
  (let ((table (the-table self))
        (bucketIndex 0)
        (bucket KV-CONS NULL)
        (equalTest? (equal-test? self)))
    (when (null? table)
      (return))
    (if equalTest?
        (setq bucketIndex (hashmod (equal-hash-code key) (size self)))
      (setq bucketIndex (hashmod (hash-code key) (size self))))
    (setq bucket (aref table bucketIndex))
    (cond ((null? bucket)
           (return))
          ((and (not equalTest?)
                (eql? (key bucket) key))
           (setf (aref table bucketIndex) (rest bucket))
           (++ (free-elements self))
           (return))
          ((and equalTest?
                (equal? (key bucket) key))
           (setf (aref table bucketIndex) (rest bucket))
           (++ (free-elements self))
           (return))
          (otherwise
           (let ((trailer bucket))
             (setq bucket (rest bucket))
             (while (defined? bucket)
               (cond ((and (not equalTest?)
                           (eql? (key bucket) key))
                      (setf (rest trailer) (rest bucket))
                      (++ (free-elements self))
                      (return))
                     ((and equalTest?
                           (equal? (key bucket) key))
                      (setf (rest trailer) (rest bucket))
                      (++ (free-elements self))
                      (return))
                     (otherwise
                      (setq trailer bucket)
                      (setq bucket (rest bucket))))))))))

(defun (stella-hash-table-lookup (LIKE (any-value self)))
    ((self STELLA-HASH-TABLE) (key OBJECT))
  ;; Lookup the value of `key' from self.  If using an `eql?' test this
  ;;    does the appropriate thing for wrappers by using `hash-code'.
  (let ((table (the-table self))
        (bucket KV-CONS NULL))
    (when (null? table)
      (return NULL))
    (cond ((equal-test? self)
           (setq bucket (aref table (hashmod (equal-hash-code key) (size self))))
           (while (defined? bucket)
             (if (equal? (key bucket) key)
                 (return (value bucket))
               (setq bucket (rest bucket)))))
          (otherwise
           (setq bucket (aref table (hashmod (hash-code key) (size self))))
           (while (defined? bucket)
             (if (eql? (key bucket) key)
                 (return (value bucket))
               (setq bucket (rest bucket))))))
    (return NULL)))

(defun (stella-string-hash-table-lookup (LIKE (any-value self)))
    ((self STELLA-HASH-TABLE) (key STRING))
  ;; Lookup the value of `key' from the string hash table `self'.
  ;; Assumes each key in `self' is a STRING-WRAPPER.
  (let ((table (the-table self))
        (bucket KV-CONS NULL))
    (when (null? table)
      (return NULL))
    (setq bucket (aref table (hashmod (hash-code key) (size self))))
    (while (defined? bucket)
      (if (eql? (wrapper-value (cast (key bucket) STRING-WRAPPER)) key)
          (return (value bucket))
        (setq bucket (rest bucket))))
    (return NULL)))

;; Top-level method linkage:

(defmethod (lookup (LIKE (any-value self)))
    ((self STELLA-HASH-TABLE) (key (LIKE (any-key self))))
  :documentation "Lookup the entry identified by `key' in `self' and
return its value, or NULL if no such entry exists.    Uses an `eql?'
test by default or `equal?' if `equal-test?' of `self' is TRUE."
  :public? TRUE
  (return (stella-hash-table-lookup self key)))

(defmethod insert-at ((self STELLA-HASH-TABLE) (key (LIKE (any-key self)))
                      (value (LIKE (any-value self))))
  :documentation "Set the value of the entry identified by `key' in `self'
to `value' or add a new entry if no entry with `key' exists yet.  Uses an
`eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  :public? TRUE
  (stella-hash-table-insert-at self key value)
  (return))

(defmethod remove-at ((self STELLA-HASH-TABLE) (key (LIKE (any-key self))))
  :documentation "Remove the entry identified by `key' from `self'.  Uses an
`eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  :public? TRUE
  (stella-hash-table-remove-at self key)
  (return))

(defmethod (length INTEGER) ((self STELLA-HASH-TABLE))
  :documentation "Return the number of entries in `self'."
  :public? TRUE
  (if (null? (the-table self))
      (return 0)
    (return (- (size self) (free-elements self)))))

(defmethod (empty? BOOLEAN) ((self STELLA-HASH-TABLE))
  :documentation "Return TRUE if `self' has zero entries."
  :public? TRUE
  (return (= (length self) 0)))

(defmethod (non-empty? BOOLEAN) ((self STELLA-HASH-TABLE))
  :documentation "Return TRUE if `self' has at least 1 entry."
  :public? TRUE
  (return (> (length self) 0)))

(defmethod (copy (LIKE self)) ((self STELLA-HASH-TABLE))
  :documentation "Return a copy of the hash table `self'.  The bucket table
and buckets are freshly allocated, however, the keys and values of entries
are not copied themselves (similar to what we do for lists, etc.)."
  :public? TRUE
  (let ((size (size self))
        (copy (new STELLA-HASH-TABLE
                   :size size
                   :initial-size (initial-size self)
                   :free-elements (free-elements self)
                   :equal-test? (equal-test? self)))
        (table (the-table self))
        (tableCopy table)
        (bucket KV-CONS NULL))
    (when (defined? table)
      (setq tableCopy (new (ARRAY () OF KV-CONS) :size size))
      (setf (the-table copy) tableCopy)
      (foreach i in (interval 0 (1- size))
          do (setq bucket (aref table i))
             (if (defined? bucket)
                 (setf (aref tableCopy i) (copy-kv-cons-list bucket))
               (setf (aref tableCopy i) NULL))))
    (return copy)))

(defmethod clear ((self STELLA-HASH-TABLE))
  :documentation "Remove all entries from `self'.  This will result in a
re-initialization of the table upon the first insertion into `self'."
  :public? TRUE
  (setf (the-table self) NULL)
  (setf (size self) NULL)
  (setf (free-elements self) NULL))

(defmethod (consify (CONS OF CONS)) ((self STELLA-HASH-TABLE))
  :documentation "Collect all entries of `self' into a cons list of
`(<key> <value>)' pairs and return the result."
  :public? TRUE
  (let ((result NIL))
    (foreach (key value) in self
        collect (cons key (cons value NIL)) into result)
    (return result)))

(defmethod (object-equal? BOOLEAN) ((x STELLA-HASH-TABLE) (y OBJECT))
  :documentation
  "Return TRUE if `x' and `y' represent the same set of key/value pairs."
  :public? TRUE
  (typecase y
    (STELLA-HASH-TABLE
     (when (= (length x) (length y))
       (foreach (key value) in x
           where (not (equal? value (lookup y key)))
           do (return FALSE))
       (return TRUE)))
    (otherwise NULL))
  (return FALSE))

(defmethod (equal-hash-code INTEGER) ((self STELLA-HASH-TABLE))
  :documentation "Return an `equal?' hash code for `self'.  Note that this
is O(N) in the number of entries of `self'."
  :public? TRUE
  (let ((code 36273463)) ;; result of (hash-string "STELLA-HASH-TABLE" 0)
    (foreach (key value) in self
        ;; exploits the fact that `XOR' is commutative
        ;; (minor bug: doesn't distinguish between keys and values):
        do (setq code (logxor code (equal-hash-code key)))
           (setq code (logxor code (equal-hash-code value))))
    (return code)))


;; Iteration:

(defclass STELLA-HASH-TABLE-ITERATOR (DICTIONARY-ITERATOR)
  :documentation "Iterator class for STELLA-HASH-TABLE's.  The only modifying
operations allowed during iteration are removal of the current element or
changing its value.  All other removal or insertion operations might lead
to corruption or undefined results."
  :slots ((size :type INTEGER)
          (bucket-table :type (ARRAY () OF KV-CONS))
          (bucket-index :type INTEGER :initially 0)
          (bucket-cursor :type KV-CONS)))

(defmethod (allocate-iterator (STELLA-HASH-TABLE-ITERATOR OF
                               (LIKE (any-key self))
                               (LIKE (any-value self))))
    ((self STELLA-HASH-TABLE))
  :documentation "Allocate an iterator for `self'."
  :public? TRUE
  (return
    (new STELLA-HASH-TABLE-ITERATOR
         :size (size self)
         :bucket-table (the-table self)
         :bucket-index 0
         :bucket-cursor NULL)))

(defmethod (next? BOOLEAN) ((self STELLA-HASH-TABLE-ITERATOR))
  (let ((cursor (bucket-cursor self)))
    (cond ((first-iteration? self)
           (setf (first-iteration? self) FALSE))
          ((defined? cursor)
           (setq cursor (rest cursor))))
    (when (null? cursor)
      (let ((table (bucket-table self))
            (index (bucket-index self))
            (size (size self)))
        (when (null? table)
          (return FALSE))
        (while (and (null? cursor)
                    (< index size))
          (setq cursor (aref table index))
          (++ index))
        (setf (bucket-index self) index)
        (setf (bucket-cursor self) cursor)))
    (cond ((defined? cursor)
           (setf (slot-value self key) (key cursor))
           (setf (slot-value self value) (value cursor))
           ;; point to current item so we can set its value:
           (setf (bucket-cursor self) cursor)
           (return TRUE))
          (otherwise
           (return FALSE)))))

(defmethod (value-setter (LIKE (any-value self)))
    ((self STELLA-HASH-TABLE-ITERATOR) (value (LIKE (any-value self))))
  (let ((cursor (bucket-cursor self)))
    (when (defined? cursor)
      (setf (value cursor) value))
    (setf (slot-value self value) value)
    (return value)))

(defmethod (key-setter (LIKE (any-key self)))
    ((self STELLA-HASH-TABLE-ITERATOR) (key (LIKE (any-key self))))
  (error "Cannot change the key of a STELLA-HASH-TABLE item"))


(defglobal *key-value-map-crossover-point* INTEGER
           *remove-duplicates-crossover-point*
  :documentation "Point where we switch from using a KV-CONS table
representation to a STELLA hash table to preserve O(1) access.")

;;; Storage requirements per entry (for table with 1000 entries
;;; not counting storage required for key and value objects):
;;; in Lisp (using structs): 6.5 slots per entry (extra hash-code slot)
;;; C++ and Java:            5.5 slots per entry
;;; KEY-VALUE-LIST (Lisp):   5.0 slots per entry
;;; C++, Java:               4.0 slots per entry

(defclass KEY-VALUE-MAP (DICTIONARY)
  :documentation "Full-featured dictionary class that supports `eql?' or
`equal?' equality tests, O(1) access operations even for large numbers
of entries by using a hash table, light-weight KV-CONS representation for
small tables and iteration even if the dictionary is represented by a
hash table."
  :public? TRUE
  :slots ((the-map :type OBJECT) ;; either KV-CONS or STELLA-HASH-TABLE
          (equal-test? :type BOOLEAN :initially FALSE :public? TRUE
                       :documentation "If true use `equal?' as the
equality test (and `equal-hash-code' as the hash function), otherwise,
use `eql?' (and `hash-code') (the default).")
          (initial-size :type INTEGER
                        :initially *key-value-map-crossover-point*
                        :public? TRUE
                        :documentation "If supplied, the initial table
will be sized to hold at least that many elements.")
          (crossover-point :type INTEGER
                           :initially *key-value-map-crossover-point*)))

(defmethod (lookup (LIKE (any-value self))) ((self KEY-VALUE-MAP)
                                             (key (LIKE (any-key self))))
  :documentation "Lookup the entry identified by `key' in `self' and
return its value, or NULL if no such entry exists.    Uses an `eql?'
test by default or `equal?' if `equal-test?' of `self' is TRUE."
  :public? TRUE
  (let ((map (the-map self))
        (crossover (crossover-point self)))
    (cond ((= crossover 0)
           ;; we are using a hash table already:
           (return (stella-hash-table-lookup map key)))
          (otherwise
           (let ((cursor KV-CONS map))
             (if (equal-test? self)
                 (while (defined? cursor)
                   (when (equal? (key cursor) key)
                     (return (value cursor)))
                   (setq cursor (rest cursor)))
               (while (defined? cursor)
                 (when (eql? (key cursor) key)
                   (return (value cursor)))
                 (setq cursor (rest cursor))))
             (return NULL))))))

(defmethod insert-at ((self KEY-VALUE-MAP) (key (LIKE (any-key self)))
                      (value (LIKE (any-value self))))
  :documentation "Set the value of the entry identified by `key' in `self'
to `value' or add a new entry if no entry with `key' exists yet.  Uses an
`eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  :public? TRUE
  (let ((map (the-map self))
        (crossover (crossover-point self)))
    (when (null? map)
      (cond ((> (initial-size self) *key-value-map-crossover-point*)
             (setq map
               (new STELLA-HASH-TABLE
                    :initial-size (initial-size self)
                    :equal-test? (equal-test? self)))
             (setf (the-map self) map)
             (setq crossover 0))
            (otherwise
             (setq crossover *key-value-map-crossover-point*)))
      (setf (crossover-point self) crossover))
    (cond ((= crossover 0)
           ;; we are using a hash table already:
           (stella-hash-table-insert-at map key value))
          (otherwise
           (let ((cursor KV-CONS map))
             (if (equal-test? self)
                 (while (defined? cursor)
                   (when (equal? (key cursor) key)
                     (setf (value cursor) value)
                     (return))
                   (setq cursor (rest cursor)))
               (while (defined? cursor)
                 (when (eql? (key cursor) key)
                   (setf (value cursor) value)
                   (return))
                 (setq cursor (rest cursor))))
             (setq cursor (kv-cons key value map))
             (setf (the-map self) cursor)
             ;; we actually added an item:
             (-- crossover)
             (setf (crossover-point self) crossover)
             (when (= crossover 0)
               (setq map (new STELLA-HASH-TABLE
                              :equal-test? (equal-test? self)))
               (setf (the-map self) map)
               (foreach (key value) in cursor
                   do (stella-hash-table-insert-at map key value))))))))

(defmethod remove-at ((self KEY-VALUE-MAP) (key (LIKE (any-key self))))
  :documentation "Remove the entry identified by `key' from `self'.  Uses an
`eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  :public? TRUE
  (let ((map (the-map self))
        (crossover (crossover-point self)))
    (cond ((= crossover 0)
           ;; we are using a hash table already:
           (stella-hash-table-remove-at map key))
          (otherwise
           (let ((cursor KV-CONS map)
                 (trailer KV-CONS map))
             (if (equal-test? self)
                 (while (defined? cursor)
                   (when (equal? (key cursor) key)
                     (break))
                   (setq trailer cursor)
                   (setq cursor (rest cursor)))
               (while (defined? cursor)
                 (when (eql? (key cursor) key)
                   (break))
                 (setq trailer cursor)
                 (setq cursor (rest cursor))))
             (cond ((null? cursor)
                    ;; no matching item:
                    (return))                    
                   ((eql? cursor trailer)
                    ;; we removed the first element:
                    (setf (the-map self) (rest cursor)))
                   (otherwise
                    (setf (rest trailer) (rest cursor))))
             (setf (crossover-point self) (1+ crossover)))))))

(defmethod (length INTEGER) ((self KEY-VALUE-MAP))
  :documentation "Return the number of entries in `self'."
  :public? TRUE
  (let ((map (the-map self)))
    (cond ((null? map)
           (return 0))
          ((= (crossover-point self) 0)
           (return (length (cast map STELLA-HASH-TABLE))))
          (otherwise
           (return (length (cast map KV-CONS)))))))

(defmethod (empty? BOOLEAN) ((self KEY-VALUE-MAP))
  :documentation "Return TRUE if `self' has zero entries."
  :public? TRUE
  (let ((map (the-map self)))
    (cond ((null? map)
           (return TRUE))
          ((= (crossover-point self) 0)
           (return (= (length (cast map STELLA-HASH-TABLE)) 0)))
          (otherwise
           (return FALSE)))))

(defmethod (non-empty? BOOLEAN) ((self KEY-VALUE-MAP))
  :documentation "Return TRUE if `self' has at least 1 entry."
  :public? TRUE
  (let ((map (the-map self)))
    (cond ((null? map)
           (return FALSE))
          ((= (crossover-point self) 0)
           (return (> (length (cast map STELLA-HASH-TABLE)) 0)))
          (otherwise
           (return TRUE)))))

(defmethod (copy (LIKE self)) ((self KEY-VALUE-MAP))
  :documentation "Return a copy of the map `self'.  All entries are freshly
allocated, however, the keys and values of entries are not copied themselves
 (similar to what we do for lists, etc.)."
  :public? TRUE
  (let ((copy (new KEY-VALUE-MAP
                   :equal-test? (equal-test? self)
                   :initial-size (initial-size self)
                   :crossover-point (crossover-point self)))
        (map (the-map self)))
    (if (= (crossover-point self) 0)
        (setf (the-map copy) (copy (cast map STELLA-HASH-TABLE)))
      (setf (the-map copy) (copy-kv-cons-list map)))
    (return copy)))
  
(defmethod clear ((self KEY-VALUE-MAP))
  :documentation "Reset `self' to have zero entries."
  :public? TRUE
  (setf (the-map self) NULL)
  (setf (crossover-point self) *key-value-map-crossover-point*))

(defmethod (allocate-iterator (DICTIONARY-ITERATOR OF
                                (LIKE (any-key self))
                                (LIKE (any-value self))))
    ((self KEY-VALUE-MAP))
  :documentation "Allocate an iterator for `self'.  The only modifying
operations allowed during iteration are removal of the current element or
changing its value.  All other removal or insertion operations might lead
to corruption or undefined results."
  :public? TRUE
  (let ((map (the-map self)))
    (cond ((= (crossover-point self) 0)
           (return
             (allocate-iterator (cast map STELLA-HASH-TABLE))))
          (otherwise
           (return
             (allocate-iterator (new KEY-VALUE-LIST :the-kv-list map)))))))

(defmethod (consify CONS) ((self KEY-VALUE-MAP))
  :documentation "Collect all entries of `self' into a cons list of
`(<key> <value>)' pairs and return the result."
  :public? TRUE
  ;; NOTE: we can't use (CONS OF CONS) as a return type here, since that
  ;;    would be incompatible with the signature of `HASH-SET.consify'.
  (let ((result NIL))
    (foreach (key value) in self
        collect (cons key (cons value NIL)) into result)
    (return result)))

(defmethod (object-equal? BOOLEAN) ((x KEY-VALUE-MAP) (y OBJECT))
  :documentation
  "Return TRUE if `x' and `y' represent the same set of key/value pairs."
  :public? TRUE
  (typecase y
    (KEY-VALUE-MAP
     (when (= (length x) (length y))
       (foreach (key value) in x
           where (not (equal? value (lookup y key)))
           do (return FALSE))
       (return TRUE)))
    (otherwise NULL))
  (return FALSE))

(defmethod (equal-hash-code INTEGER) ((self KEY-VALUE-MAP))
  :documentation "Return an `equal?' hash code for `self'.  Note that this
is O(N) in the number of entries of `self'."
  :public? TRUE
  (let ((code 2137005)) ;; random number
    (foreach (key value) in self
        ;; exploits the fact that `XOR' is commutative
        ;; (minor bug: doesn't distinguish between keys and values):
        do (setq code (logxor code (equal-hash-code key)))
           (setq code (logxor code (equal-hash-code value))))
    (return code)))

#|
(defun (test-key-value-map KEY-VALUE-MAP) ((n INTEGER) (equal? BOOLEAN))
  (let ((table (new KEY-VALUE-MAP
                    :equal-test? equal?
                    :initial-size n)))
    (print "Printing empty table..." EOL)
    (foreach (key value) in table
        do (print key value EOL))
    (foreach i in (interval 1 n)
        do (insert-at table (vector i) i))
    (print "Printing full table..." EOL)
    (foreach (key value) in table
        do (print key value EOL))
    (foreach (key value) in table
        where (odd? value)
        do (remove-at table key))
    (print "Printing odds removed table..." EOL)
    (foreach (key value) in table
        do (print key value EOL))
    (foreach it on table
        where (> (value it) (/ n 2))
        do (setf (value it) (- (value it))))
    (print "Printing value modified table..." EOL)
    (foreach (key value) in table
        do (print key value EOL))
    (return table)))

(defun print-key-value-map-stats ((map KEY-VALUE-MAP))
  ;; Performance debugging aid.
  ;; So far, this only prints the size of the biggest bucket.
  (let ((theMap (the-map map))
        (bucket KV-CONS NULL)
        (maxLength 0))
    (typecase theMap
      (STELLA-HASH-TABLE
       (foreach i in (interval 0 (1- (size theMap)))
           do (setq bucket (aref (the-table theMap) i))
              (when (and (defined? bucket)
                         (> (length bucket) maxLength))
                (setq maxLength (length bucket)))))
      (KV-CONS
       (setq maxLength 1))
      (otherwise NULL))
    (print maxLength)))
|#

;;; TO DO: FIX THIS TO ONLY TAKE AN any-value PARAMETER!!!
(defclass HASH-SET (KEY-VALUE-MAP SET-MIXIN)
  :documentation "Full-featured set class that supports `eql?' or `equal?'
equality tests, O(1) insert and `member?' operations & O(N) `intersection'
etc. operations even for large numbers of entries by using a hash table,
light-weight KV-CONS representation for small sets and iteration even if the
set is represented by a hash table.  The only minor drawback right now is that
this wastes a value slot per entry, since we piggy-back off KEY-VALUE-MAP's,
however, that wastes at most 25% space."
  :public? TRUE)

(defun (hash-set HASH-SET) (&rest (values OBJECT))
  :documentation "Return an `eql?' HASH-SET containing `values'."
  :public? TRUE
  (let ((set (new HASH-SET)))
    (foreach v in values
        do (insert-at set v v))
    (return set)))

(defun (coerce-to-hash-set HASH-SET) ((self OBJECT) (equalTest? BOOLEAN))
  :documentation "Coerce the collection `self' into a HASH-SET.  Use an
equal test if `equalTest?' is TRUE (`equalTest?' will be ignored if `self'
already is a HASH-SET)."
  :public? TRUE
  (let ((theSet HASH-SET
         (choose (isa? self @HASH-SET)
                 self
                 (new HASH-SET :equal-test? equalTest?))))
    (typecase self
      (HASH-SET NULL)
      ((CONS LIST VECTOR COLLECTION)
       (foreach elt in self
           do (insert-at theSet elt elt)))
      (otherwise
       (error "coerce-to-hash-set: don't know how to coerce a "
              (primary-type self) " into a hash-set")))
    (return theSet)))

(defmethod (member? BOOLEAN) ((self HASH-SET) (object OBJECT))
  :documentation "Return TRUE iff `object' is a member of the set `self'.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  :public? TRUE
  (return (defined? (lookup self object))))

(defmethod insert ((self HASH-SET) (value (LIKE (any-value self))))
  :documentation "Add `value' to the set `self' unless it is already a member.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  :public? TRUE
  (insert-at self value value))

(defmethod (remove (LIKE self)) ((self HASH-SET) (value (LIKE (any-value self))))
  :documentation
  "Destructively remove `value' from the set `self' if it is a member and
return `self'.  Uses an `eql?' test by default or `equal?' if `equal-test?' of
`self' is TRUE."
  :public? TRUE
  (remove-at self value)
  (return self))

(defmethod (remove-if (LIKE self)) ((self HASH-SET) (test? FUNCTION-CODE))
  :documentation "Destructively remove all elements of the set `self' for which
'test?' evaluates to TRUE.  `test?' takes a single argument of type OBJECT and
returns TRUE or FALSE.  Returns `self'."
  :public? TRUE
  (foreach element in self
      where (funcall test? element)
      do (remove-at self element))
  (return self))

(defmethod (pop (LIKE (any-value self))) ((self HASH-SET))
  :documentation "Remove and return an arbitrary element of the set `self'.
Return NULL if the set is empty.  Performance note: for large sets implemented
via hash tables it takes O(N) to empty out the set with repeated calls to `pop',
since the emptier the table gets, the longer it takes to find an element.
Therefore, it is usually better to use iteration with embedded removals for
such cases."
  :public? TRUE
  (let ((element OBJECT NULL)
        (setMap (the-map self)))
    (when (defined? setMap)
      (cond ((= (crossover-point self) 0)
             (let ((map STELLA-HASH-TABLE setMap)
                   (table (the-table map))
                   (bucket KV-CONS NULL))
               (when (defined? table)
                 (foreach i in (interval 0 (1- (size map)))
                     do (setq bucket (aref table i))
                        (when (defined? bucket)
                          (setq element (key bucket))
                          (break))))))
            (otherwise
             (let ((map (cast (the-map self) KV-CONS)))
               (when (defined? map)
                 (setq element (key map)))))))
    (when (defined? element)
      (remove-at self element))
    (return element)))

(defmethod (substitute (LIKE self)) ((self HASH-SET) (new OBJECT) (old OBJECT))
  :documentation "Destructively replace `old' with `new' in the set `self'
unless `new' is already a member.  Uses an `eql?' test by default or `equal?'
if `equal-test?' of `self' is TRUE."
  :public? TRUE
  (when (not (member? self new))
    (remove-at self old)
    (insert-at self new new))
  (return self))

(defmethod (copy (LIKE self)) ((self HASH-SET))
  :documentation "Return a copy of the set `self'.  All entries are freshly
allocated, however, the values are not copied themselves (similar to what we
do for lists, etc.)."
  :public? TRUE
  (let ((copy (new HASH-SET
                   :equal-test? (equal-test? self)
                   :initial-size (initial-size self)
                   :crossover-point (crossover-point self)))
        (map (the-map self)))
    (if (= (crossover-point self) 0)
        (setf (the-map copy) (copy (cast map STELLA-HASH-TABLE)))
      (setf (the-map copy) (copy-kv-cons-list map)))
    (return copy)))

(defmethod (consify (CONS OF (LIKE (any-value self)))) ((self HASH-SET))
  :documentation
  "Collect all entries of `self' into a cons list and return the result."
  :public? TRUE
  (let ((result NIL))
    (foreach value in self
        collect value into result)
    (return result)))

(defmethod (subset? BOOLEAN) ((self HASH-SET) (otherSet HASH-SET))
  :documentation
  "Return true if every element of `self' also occurs in `otherSet'.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  :public? TRUE
  (return
    (and (<= (length self) (length otherSet))
         (forall elt in self
             always (defined? (lookup otherSet elt)))))) ; hand-inline `member?'
  
(defmethod (equivalent-sets? BOOLEAN) ((self HASH-SET) (otherSet HASH-SET))
  :documentation
  "Return true if every element of `self' occurs in `otherSet' and vice versa.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  :public? TRUE
  (return
    (and (= (length self) (length otherSet))
         (forall elt in self
             always (defined? (lookup otherSet elt)))))) ; hand-inline `member?'

(defmethod (intersection HASH-SET) ((self HASH-SET) (otherSet HASH-SET))
  :documentation
  "Return the set intersection of `self' and `otherSet' as a new set.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  :public? TRUE
  (let ((result (new HASH-SET :equal-test? (equal-test? self)))
        (aux self))
    (when (> (length self) (length otherSet))
      (setq self otherSet)
      (setq otherSet aux))
    (foreach elt in self
        where (defined? (lookup otherSet elt)) ; hand-inline `member?'
        do (insert-at result elt elt))
    (return result)))

(defmethod (union HASH-SET) ((self HASH-SET) (otherSet HASH-SET))
  :documentation
  "Return the set union of `self' and `otherSet' as a new set.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE."
  :public? TRUE
  (let ((result HASH-SET NULL)
        (aux self))
    (when (< (length self) (length otherSet))
      (setq self otherSet)
      (setq otherSet aux))
    (setq result (copy self))
    (foreach elt in otherSet
        do (insert-at result elt elt))
    (return result)))

(defmethod (difference HASH-SET) ((self HASH-SET) (otherSet HASH-SET))
  :documentation
  "Return the set difference of `self' and `otherSet' as a new set (i.e.,
all elements that are in `self' but not in `otherSet').  Uses an `eql?' test
by default or `equal?' if `equal-test?' of `self' is TRUE."
  :public? TRUE
  (let ((result HASH-SET NULL))
    (cond ((> (length self) (* (length otherSet) 2))
           ;; optimization: at least half of `self' will survive; so do a
           ;; quick copy and then remove any elements also found in `otherSet':
           (setq result (copy self))
           (foreach elt in otherSet
               where (defined? (lookup result elt)) ; hand-inline `member?'
               do (remove-at result elt)))
          (otherwise
           (setq result (new HASH-SET :equal-test? (equal-test? self)))
           (foreach elt in self
               where (not (defined? (lookup otherSet elt)))
               do (insert-at result elt elt))))
    (return result)))

(defmethod (subtract HASH-SET) ((self HASH-SET) (otherSet HASH-SET))
  :documentation
  "Return the set difference of `self' and `otherSet' by destructively
removing elements from `self' that also occur in `otherSet'.  Uses an `eql?'
test by default or `equal?' if `equal-test?' of `self' is TRUE."
  :public? TRUE
  (foreach elt in self
      where (defined? (lookup otherSet elt)) ; hand-inline `member?'
      do (remove-at self elt))
  (return self))

(defmethod (object-equal? BOOLEAN) ((x HASH-SET) (y OBJECT))
  :documentation
  "Return TRUE iff sets `x' and `y' are HASH-SET's with equivalent members.
Uses an `eql?' test by default or `equal?' if `equal-test?' of `self' is TRUE.
This is equivalent to calling `equivalent-sets?'."
  :public? TRUE
  (typecase y
    (HASH-SET
     (return (equivalent-sets? x y)))
    (otherwise NULL))
  (return FALSE))

(defmethod (equal-hash-code INTEGER) ((self HASH-SET))
  :documentation "Return an `equal?' hash code for `self'.  Note that this
is O(N) in the number of elements of `self'."
  :public? TRUE
  (let ((code 7971569)) ;; random number
    (foreach elt in self
        ;; exploits the fact that `XOR' is commutative:
        do (setq code (logxor code (equal-hash-code elt))))
    (return code)))


  ;;
;;;;;; Dimensional arrays
  ;;

;;; TO DO:
;;; + problem 1: globally-inline? gives us problems on mixin methods, since during
;;;   the expansion we get variables that have a mixin class type
;;; + problem 2: calls to fill-array don't translate right; somehow the anchored
;;;   type doesn't get handled properly during the varargs call.
;;; - problem 2b: translating the `fill-array' method breaks the Java translator
;;;   during the varargs foreach so the method is commented for now.
;;; + problem 3: we don't seem to generate appropriate startup code to generate
;;;   mixin method objects; probably because they have unknown types and are not
;;;   defined inside the class as some others in hierarchy.ste
;;; - Need to inform the AREF walker to translate into these accessors if indicated.
;;;   Think about that some more, this would mean that we'd lose some of the
;;;   dimensionality checking at translation time, since the walker would translate
;;;   into 1d-aref, 2d-aref, etc. depending on how many dimensions were supplied,
;;;   which could lead to strange bugs if one forgot to include a dimension.
;;; - update neural-network.ste to use the new array data structures

;;; This is an attempt to have multidimensional arrays in STELLA that can be fully
;;; dynamic, i.e., where none of their dimensions has to be known at translation
;;; time.  In Lisp and Java this is already supported, but for C++ we can only leave
;;; one dimension open.  The current ARRAY data type caters to this lowest common
;;; denominator which gives us maximum native array access speed.  However, it seems
;;; very uncommon to have multidimensional arrays where one dimension can be fixed,
;;; and the workarounds are kind of ugly (e.g., use a vector of vectors often with
;;; wrapped element types).  So here we have a STELLA type implementation that does
;;; the trick.  Actually, it is kind of nifty and might become a template for other
;;; similar situations, where we specify a set of template operations with an
;;; UNKNOWN value type on a mixin class and then instantiate that class multiple
;;; times with different element types.  The inheriting down of mixin methods then
;;; gives us the equivalent of template instantiation and allows us to easily handle
;;; literal element types such as float or integer without wrapping.

;;; Alternatively, we could try to write some native support in C++ (or as Tom
;;; suggested use some existing C++ array library) and simply wrap this functionality
;;; in STELLA.  This would most definitely require template syntax in C++ (or we'd
;;; have to work with void pointers and casting); additionally, if we ever go this
;;; route, we'd want to ensure that the resulting type is a subtype of OBJECT, so
;;; we can easily stick it into other containers.  What we have here for now was
;;; easier and also still gives us the option of maximum access speed on the native
;;; array without any address arithmetic.

(defclass DIMENSIONAL-ARRAY-MIXIN ()
  :mixin? TRUE
  :parameters ((any-value :type UNKNOWN))
  :slots ((dim1 :type INTEGER :required? TRUE)
          (the-array :type (ARRAY () OF (LIKE (any-value self)))))
  :initializer initialize-dimensional-array)

(defmethod initialize-dimensional-array ((self DIMENSIONAL-ARRAY-MIXIN))
  (setf (the-array self)
    (new (ARRAY () OF (LIKE (any-value self))) :size (length self))))

(defmethod (length INTEGER) ((self DIMENSIONAL-ARRAY-MIXIN))
  :documentation "Return the total number of elements in `self'."
  :public? TRUE
  (return (dim1 self)))

(defmethod initialize-array ((self DIMENSIONAL-ARRAY-MIXIN)
                             (initialValue (LIKE (any-value self))))
  :documentation "Initialize the elements of `self' with `initialValue'."
  :public? TRUE
  (let ((array (the-array self)))
    (foreach i in (interval 0 (1- (length self)))
        do (setf (aref array i) initialValue))))

;(defmethod fill-array ((self DIMENSIONAL-ARRAY-MIXIN) &rest (values (LIKE (any-value self))))
;  :documentation "Fill the array `self' in row-major-order from `values'.
;Missing values will retain their old values, extraneous values will be ignored."
;  :public? TRUE
;  (let ((array (the-array self)))
;    (foreach i in (interval 0 (1- (length self)))
;        as value in values
;        do (setf (aref array i) value))))

;; unfortunately, this doesn't work, since `create-object' can't initialize required literal slots:
;(defmethod (copy (LIKE self)) ((self DIMENSIONAL-ARRAY-MIXIN))
;  (let ((copy self)) ;; tricky: this gets us the right type without using a mixin type
;    (setq copy (create-object (primary-type self) :dim1 (dim1 self)))
;    (let ((selfArray (the-array self))
;          (copyArray (the-array copy)))
;      (foreach i in (interval 0 (1- (length self)))
;          do (setf (aref copyArray i) (aref selfArray i)))
;      (return copy))))

(defmethod (1D-aref (LIKE (any-value self))) ((self DIMENSIONAL-ARRAY-MIXIN)
                                              (i INTEGER))
  :documentation "Return the element of `self' at position `[i]'."
  :public? TRUE :globally-inline? TRUE
  (return (aref (the-array self) i)))

(defmethod (1D-aref-setter (LIKE (any-value self))) ((self DIMENSIONAL-ARRAY-MIXIN)
                                                     (value (LIKE (any-value self)))
                                                     (i INTEGER))
  :documentation "Set the element of `self' at position `[i]' to `value'
and return the result."
  :public? TRUE :globally-inline? TRUE
  (return (setf (aref (the-array self) i) value)))

(defmethod (1D-aref-address INTEGER) ((self DIMENSIONAL-ARRAY-MIXIN) (i INTEGER))
  :documentation "Return the 1D address of the element at position `[i]'.
This is useful for fast element-wise iteration that doesn't need arithmetic."
  :public? TRUE :globally-inline? TRUE
  (return i))


(defclass 2-DIMENSIONAL-ARRAY-MIXIN (DIMENSIONAL-ARRAY-MIXIN)
  :mixin? TRUE :public? TRUE
  :slots ((dim2 :type INTEGER :required? TRUE)))

(defmethod (length INTEGER) ((self 2-DIMENSIONAL-ARRAY-MIXIN))
  :documentation "Return the total number of elements in `self'."
  :public? TRUE
  (return (* (dim1 self) (dim2 self))))

(defmethod (2D-aref (LIKE (any-value self))) ((self 2-DIMENSIONAL-ARRAY-MIXIN)
                                              (i INTEGER)
                                              (j INTEGER))
  :documentation "Return the element of `self' at position `[i, j]'."
  :public? TRUE :globally-inline? TRUE
  (return (aref (the-array self) (+ (* i (dim2 self)) j))))

(defmethod (2D-aref-setter (LIKE (any-value self))) ((self 2-DIMENSIONAL-ARRAY-MIXIN)
                                                     (value (LIKE (any-value self)))
                                                     (i INTEGER)
                                                     (j INTEGER))
  :documentation "Set the element of `self' at position `[i, j]' to `value'
and return the result."
  :public? TRUE :globally-inline? TRUE
  (return (setf (aref (the-array self) (+ (* i (dim2 self)) j)) value)))

(defmethod (2D-aref-address INTEGER) ((self 2-DIMENSIONAL-ARRAY-MIXIN) (i INTEGER) (j INTEGER))
  :documentation "Return the 1D address of the element at position `[i, j]'.
This is useful for fast element-wise iteration that doesn't need arithmetic."
  :public? TRUE :globally-inline? TRUE
  (return (+ (* i (dim2 self)) j)))


;;; Instantiate mixins on a set of common element types:

(defclass ABSTRACT-DIMENSIONAL-ARRAY (ABSTRACT-COLLECTION)
  :documentation "Array objects that are aware of their dimensions."
  :public? TRUE :abstract? TRUE
  :parameters ((any-value :type UNKNOWN)))

(defclass 1D-ARRAY (ABSTRACT-DIMENSIONAL-ARRAY DIMENSIONAL-ARRAY-MIXIN)
  :documentation "1-dimensional array with OBJECT values.  This is more or
less equivalent to VECTOR (fewer methods) but kept here for symmetry."
  :public? TRUE
  :synonyms (OBJECT-ARRAY)
  :parameters ((any-value :type OBJECT)))

(defclass 1D-FLOAT-ARRAY (ABSTRACT-DIMENSIONAL-ARRAY DIMENSIONAL-ARRAY-MIXIN)
  :documentation "1-dimensional array with float values."
  :public? TRUE
  :synonyms (FLOAT-ARRAY)
  :parameters ((any-value :type FLOAT)))

(defclass 2D-ARRAY (ABSTRACT-DIMENSIONAL-ARRAY 2-DIMENSIONAL-ARRAY-MIXIN)
  :documentation "2-dimensional array with object values."
  :public? TRUE
  :parameters ((any-value :type OBJECT)))

(defclass 2D-FLOAT-ARRAY (ABSTRACT-DIMENSIONAL-ARRAY 2-DIMENSIONAL-ARRAY-MIXIN)
  :documentation "2-dimensional array with float values."
  :public? TRUE
  :parameters ((any-value :type FLOAT)))

#|
(defun test-2d-float-array ()
  :command? TRUE
  (let ((array (new 2D-FLOAT-ARRAY :dim1 3 :dim2 4)))
    (initialize-array array 0.0)
    (foreach i in (interval 0 2)
        do (foreach j in (interval 0 3)
               do (setf (2d-aref array i j) (* (1+ i) (1+ j) -1))))
    ;(fill-array array 1 2 3 4 5 6 7 8 9 10)
    (foreach i in (interval 0 2)
        do (foreach j in (interval 0 3)
               as idx in (interval (2d-aref-address array i 0) NULL)
               do (print (2d-aref array i j) " " (1d-aref array idx) EOL)))
    ))
|#
