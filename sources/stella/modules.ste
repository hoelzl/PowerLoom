;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;; BEGIN LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
; Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          ;
;                                                                            ;
; The contents of this file are subject to the Mozilla Public License        ;
; Version 1.1 (the "License"); you may not use this file except in           ;
; compliance with the License. You may obtain a copy of the License at       ;
; http://www.mozilla.org/MPL/                                                ;
;                                                                            ;
; Software distributed under the License is distributed on an "AS IS" basis, ;
; WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   ;
; for the specific language governing rights and limitations under the       ;
; License.                                                                   ;
;                                                                            ;
; The Original Code is the STELLA Programming Language.                      ;
;                                                                            ;
; The Initial Developer of the Original Code is                              ;
; UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          ;
; 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               ;
;                                                                            ;
; Portions created by the Initial Developer are Copyright (C) 1996-2006      ;
; the Initial Developer. All Rights Reserved.                                ;
;                                                                            ;
; Contributor(s):                                                            ;
;                                                                            ;
; Alternatively, the contents of this file may be used under the terms of    ;
; either the GNU General Public License Version 2 or later (the "GPL"), or   ;
; the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   ;
; in which case the provisions of the GPL or the LGPL are applicable instead ;
; of those above. If you wish to allow use of your version of this file only ;
; under the terms of either the GPL or the LGPL, and not to allow others to  ;
; use your version of this file under the terms of the MPL, indicate your    ;
; decision by deleting the provisions above and replace them with the notice ;
; and other provisions required by the GPL or the LGPL. If you do not delete ;
; the provisions above, a recipient may use your version of this file under  ;
; the terms of any one of the MPL, the GPL or the LGPL.                      ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; END LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; Version: modules.ste,v 1.82 2006/05/09 20:30:47 hans Exp

;;; Contexts, Modules, and Worlds.

(in-package "STELLA")

(in-module "STELLA")


;; TO DO: CHANGE DEFAULT TO :clear ONCE 'clear-context' HAS BEEN
;;    IMPLEMENTED:
(defglobal *subcontext-revision-policy* KEYWORD :clear
  :documentation "Controls actions reflexive transitive closure of
   subcontexts when a context is revised.
   Values are ':destroy' -- destroy subcontexts;
   ':clear' -- clear contents of subcontexts;
   ':preserve' -- don't disturb subcontexts.")

  ;;
;;;;;; Qualified pathnames
  ;;

;;; see also `qualified-stella-name?' in read.ste

(defmethod (parent-contexts (ITERATOR OF CONTEXT)) ((self CONTEXT))
  ;; Dummy to make sure there is a method on the abstract class 'CONTEXT'.
  ;:abstract? TRUE ;; C++ doesn't know how to handle those yet
  (return NULL))

(defmethod (parent-contexts (ITERATOR OF CONTEXT)) ((self MODULE))
  ;; Return an iterator over the parents of 'self'.
  :public? TRUE
  (return (allocate-iterator (parent-modules self))) )

(defmethod (parent-contexts (ITERATOR OF CONTEXT)) ((self WORLD))
  ;; Return an iterator over the parents of 'self'.
  :public? TRUE
  (return (allocate-destructive-list-iterator
           (cast (cons (parent-context self) NIL)
                 (CONS OF CONTEXT)))))

(defun (compute-context-or-module-from-pathname CONTEXT INTEGER)
    ((pathName STRING) (module? BOOLEAN) (symbolName? BOOLEAN))
  ;; Return the context (or module if 'module?' is TRUE) indicated by the
  ;;    path 'pathName'.
  ;; 'pathName' is assumed to contain one or more module separator characters.
  ;; If 'symbolName?' is TRUE, 'pathName' is assumed to be a symbol
  ;;    and the last component will be ignored.  In this case the
  ;;    second return value indicates the start of the last component.
  ;; NOTE: the pathname/symbol splitting logic of this function is somewhat
  ;;    obsolete and superseded by `parse-stella-name'.  This means this
  ;;    could be somewhat simplified and become a pure module name parser
  ;;    and lookup function.
  (let ((context (choose (eql? (nth pathName 0) MODULE-SEPARATOR-CHARACTER)
                         *root-module*
                         NULL))
        (componentEnd (choose (defined? context) 0 -1))
        (componentStart INTEGER NULL)
        (lastCharPos (1- (length pathName))))
    (while (< componentEnd lastCharPos)
      (setq componentStart (1+ componentEnd))
      (setq componentEnd componentStart)
      (foreach i in (interval componentStart lastCharPos)
          do (if (not (eql? (nth pathName i) MODULE-SEPARATOR-CHARACTER))
                 (++ componentEnd)
               (break)))
      (when (and symbolName?
                 (> componentEnd lastCharPos))
        (return (choose (defined? context)
                        context
                        ;; we had a quoted `/' as in the symbol `!/=':
                        (choose module? *module* *context*))
                componentStart))
      (cond
       ((null? context)
        ;; First time through with relative path.  Look everywhere
        ;;    for a context matching the first name in `pathName':
        (let ((startString
               (subsequence pathName componentStart componentEnd)))
          (setq context (get-stella-context-slowly startString))))
       (otherwise
        (setq context
              (some child in (child-contexts context)
                    where
                    (and (or (not module?)
                             (isa? child @MODULE))
                         (or (component-match?
                              (choose module?
                                      (module-name (cast child MODULE))
                                      (context-name (cast child CONTEXT)))
                              pathName
                              componentStart componentEnd)
                             (and module?
                                  (defined? (nicknames (cast child MODULE)))
                                  (exists nickName 
                                          in (nicknames (cast child MODULE))
                                          where
                                          (component-match?
                                           nickname pathName
                                           componentStart componentEnd)))))))))
      (when (null? context)
        (break)))
    (if (null? context)
      (signal NO-SUCH-CONTEXT-EXCEPTION "No context with name " pathName)
      (return context NULL))))

(defun (component-match? BOOLEAN)
    ((component STRING) (string STRING) (start INTEGER) (end INTEGER))
  ;; Return TRUE if 'component' exactly matches the portion of
  ;;    'string' between 'start' and 'end'.
  ;; 'start' and 'end' are assumed to be legal (non-NULL) indices
  ;;    of 'string'.
  (return
    (and (eq? (length component) (- end start))
         (forall char in component
             as i in (interval start NULL)
             always (eql? char (nth string i))))))

(defun (compute-module-and-bare-name MODULE STRING) ((name STRING))
  :documentation "Compute the module indicated by the STELLA name
`name' and return it.  Return the bare symbol name as the second
value.  `name' does not necessarily have to be qualified in which
case the current module is returned.  `name' is assumed to be the
printed representation of a STELLA symbol, surrogate or keyword."
  :public? TRUE
  (let ((module *module*))
    (mv-bind (bareName moduleName kind)
        (parse-stella-name name FALSE)
      (when (defined? moduleName)
        (setq module (get-stella-module moduleName TRUE)))
      (case kind
        (:SYMBOL (return module bareName))
        (:SURROGATE (return module (concatenate "@" bareName)))
        (:KEYWORD (return module (concatenate ":" bareName)))))))


  ;;
;;;;;; get-stella-context, change-context
  ;;

(defun (help-get-stella-context-or-module CONTEXT) ((pathName STRING) (module? BOOLEAN))
  ;; Helping function for `get-stella-context' and `get-stella-module'
  (if (qualified-stella-name? pathName)
    (return 
      (compute-context-or-module-from-pathname pathName module? FALSE))
    (return (get-stella-context-slowly pathName))))

(defun (get-stella-context CONTEXT) ((pathName STRING) (error? BOOLEAN))
  :documentation "Return the context located at `pathName', or `null'
if no such context exists.  If `error?' is `true', throw an exception
if no context is found, otherwise silently return `null'."
  :public? TRUE
  (if error?
    (return (help-get-stella-context-or-module pathName FALSE))
    (exception-case 
	(return (help-get-stella-context-or-module pathName FALSE))
    (NO-SUCH-CONTEXT-EXCEPTION ()
      (return NULL)))))

(defun (get-stella-module MODULE) ((pathName STRING) (error? BOOLEAN))
  :documentation "Return the module located at `pathName', or `null'
if no such module exists.  The search looks at ancestors and top-most
 (cardinal) modules.  If `error?' is `true', throw an exception if no
 module is found."
  :public? TRUE
  (let ((wrappedPathName (make STRING-WRAPPER))
        (module MODULE NULL))
    ;; hand-generate wrapper for speed:
    (setf (wrapper-value wrappedPathName) pathName)
    (setq module
      (memoize (wrappedPathName)
               :timestamps :MODULE-UPDATE :max-values 100
               (help-get-stella-module pathName FALSE)))
    (when (and (null? module)
               error?)
      ;; recall it to generate exception:
      (help-get-stella-module pathName TRUE))
    (return module)))
  
(defun (help-get-stella-module MODULE) ((pathName STRING) (error? BOOLEAN))
  :documentation "Return the module located at `pathName', or `null'
if no such module exists.  The search looks at ancestors and top-most
 (cardinal) modules.  If `error?' is `true', throw an exception if no
 module is found."
  :public? TRUE 
  (when (eql? pathName (module-full-name *module*))
    (return *module*))
  (let ((context CONTEXT NULL))
    (if error?
      (setq context (help-get-stella-context-or-module pathName TRUE))
      (exception-case 
	  (setq context (help-get-stella-context-or-module pathName TRUE))
	(NO-SUCH-CONTEXT-EXCEPTION ()
	  (return NULL))))
    (cond ((isa? context @MODULE)
	   (return context))
	  (error?
	   (signal NO-SUCH-CONTEXT-EXCEPTION 
		   "Context " context " is not a MODULE!"))
	  (otherwise
	   (return NULL))) ))

(deftype NAME OBJECT)

(defun (coerce-to-module-name STRING) ((nameSpec NAME) (warn? BOOLEAN))
  ;; Helper function for commands that take module name arguments.
  ;; Return a module name derived from `nameSpec', which can be a
  ;;    generalized symbol, or a string wrapper.
  ;; Return NULL if `nameSpec' didn't match any of the above categories,
  ;;    and print a warning if `warn?' was TRUE.
  ;; QUESTION: Should this be called `coerce-to-qualified-name'?
  (typecase nameSpec
      ((STRING-WRAPPER MUTABLE-STRING-WRAPPER)
       (return (wrapper-value nameSpec)))
      (KEYWORD
       (return (symbol-name nameSpec)))
      ((SYMBOL SURROGATE)
       (let ((module (interned-in nameSpec)))
         (cond ((null? module)
                (return (symbol-name nameSpec)))
;; USUALLY THIS MAKES THINGS WORSE RATHER THAN BETTER: -rmm
;              ((eql? module *root-module*)
;                (return (concatenate "/" (symbol-name nameSpec))))
               ;; This won't be right all the time, but it is impossible
               ;;    to determine the module component with which a symbol
               ;;    was specified. E.g., in the LOGIC the symbol '/STELLA/BAR'
               ;;    will have 'BAR' as its visible name; on the other hand,
               ;;    we can't compute the full name, since then the symbol
               ;;    'BAR' will expand into '/STELLA/BAR' which is wrong too:
               (otherwise
                (return (visible-name nameSpec))))))
      (otherwise
       (when warn?
         (warn "Illegal module name: " nameSpec))
       (return NULL))))

(defun (coerce-to-module MODULE) ((object OBJECT) (warn? BOOLEAN))
  :public? TRUE
  ;; Helper function for commands that take module arguments.
  ;; If `object' is NULL, return `*module*'.
  ;; If `object' is already a module, return it.
  ;; Otherwise, assume `object' is a module name, coerce it into
  ;;    a proper module name and return the named module.
  ;; If `warn?' print a warning for illegal names or if a module
  ;;    with the supplied name could not be found.
  (when (null? object)
    (return *module*))
  (typecase object
    (MODULE (return object))
    (otherwise
     (let ((moduleName (coerce-to-module-name object warn?)))
       (when (defined? moduleName)
         (when (qualified-stella-name? moduleName)
           (return (get-stella-module moduleName warn?)))
         ;; Name is unqualified:
         (return (get-stella-module moduleName warn?)))
       (return NULL)))))

(defun (find-or-create-module MODULE) ((pathName STRING))
  :documentation "Return a module located at `pathname' if one exists,
  otherwise create one"
  (let ((module (get-stella-module pathName FALSE)))
    (unless (defined? module)
      (setq module (define-module pathName NIL)))
    (return module)))

(defun (change-current-module MODULE) ((module MODULE))
  ;; Change the current module to 'module'.
  (setq *module* module)
  (setq *context* module)
  (run-hooks *change-module-hooks* module)
  (return module) )

(defun (change-current-context CONTEXT) ((context CONTEXT))
  ;; Change the current context to 'context'.  If 'context' is not
  ;;    a subcontext of the current module, change the current module
  ;;    as well.
  (when (not (eql? (base-module context) *module*))
    (change-current-module (base-module context)))
  (setq *context* context)
  (return context) )

(defmethod (change-context CONTEXT) ((context CONTEXT))
  :documentation "Change the current context to be the context
'context'."
  :public? TRUE
  (if (eql? context *context*)
    (return context)
    (return (change-current-context context))) )

(defmethod (change-context CONTEXT) ((contextName STRING))
  :documentation "Change the current context to be the context named
'contextName'."
  :public? TRUE
  (let ((context (get-stella-context contextName TRUE)))
    (if (null? context)
      (return *context*)
      (return (change-current-context context))) ))

(defmethod (change-module MODULE) ((module MODULE))
  :documentation "Change the current module to be the module
'module'."
  :public? TRUE
  (return (change-current-module module)) )

(defmethod (change-module MODULE) ((moduleName STRING))
  :documentation "Change the current module to be the module named
'moduleName'."
  :public? TRUE
  (let ((module (get-stella-module moduleName TRUE)))
    (if (null? module)
      (return *module*)
      (return (change-current-module module))) ))


  ;;
;;;;;; Finalizing a context or module
  ;;

(defmethod (multiple-parents? BOOLEAN) ((self CONTEXT))
  ;; Dummy to make sure there is a method on the abstract class 'CONTEXT'.
  ;:abstract? TRUE ;; C++ doesn't know how to handle those yet
  (return FALSE))

(defmethod (multiple-parents? BOOLEAN) ((module MODULE))
  :documentation "Return TRUE if 'module' has more than one parent."
  (return (non-empty? (rest (parent-modules module)))) )

(defun normalize-parent-modules ((self MODULE))
  ;; Replace '(parent-modules self)' with the most-specific direct
  ;;    ancestors of 'module' (don't include modules that are ancestors
  ;;    of other direct super modules).
  ;; Generate a warning if the original parents are not all most
  ;;    specific.
  (when (not (multiple-parents? self))
    (return))
  (let ((parents (parent-modules self)))
    ;; remove direct supers that are not most specific:
    (foreach superModule in parents
        do (foreach othersuperModule in parents
               where (not (eq? othersuperModule superModule))
               do (when (member? (all-super-contexts superModule)
                                 otherSuperModule)
                    ;; Don't generate a warning here to support information
                    ;;    hiding.  For example, one should be able to define
                    ;;    a module that inherits various parents that define
                    ;;    relevant things without having to know the whole
                    ;;    module super structure of each parent.
                    (remove parents otherSuperModule))))))


(defmethod inherit-supercontexts ((context CONTEXT))
  ;:abstract? TRUE ;; C++ doesn't know how to handle those yet
  NULL)

(defmethod inherit-supercontexts ((world WORLD))
  (let ((parent (parent-context world)))
    (if (defined? parent)
      ;; structure share with parent list:
      (setf (all-super-contexts world)
            (cons parent (all-super-contexts parent)))
      (setf (all-super-contexts world) NIL))))

(defmethod inherit-supercontexts ((module MODULE))
  ;; Fill the slot 'all-super-contexts' with a list of all
  ;;    superContexts of 'module', ordered such that more specific
  ;;    contexts always precede more general ones.
  ;; Assumes that 'all-super-contexts' has been computed for all parents
  ;;    of 'class'.
  ;; Storage note: If 'class' has a single parent, then the 'all-super-contexts'
  ;;    list shares structure with that parent's 'all-super-contexts' list.
  (when (not (multiple-parents? module))
    (let ((onlyParent (first (parent-modules module))))
      (when (defined? onlyParent)
        ;; structure share with parent list:
        (setf (all-super-contexts module)
          (cons onlyParent (all-super-contexts onlyParent)))
        (return))))
  ;; multiple parents; compute all super contexts precedence list:
  (let ((allSuperContexts NIL)
        (sublist CONS NULL))
    (normalize-parent-modules module)
    ;; do right union of reversed ancestors list:
    (reverse (parent-modules module))
    (foreach parent in (parent-modules module) ; reverse order traversal
        do
          (setq sublist NIL)
          (foreach ancestor in (all-super-contexts parent)
              where (not (member? allSuperContexts ancestor))
              collect ancestor into sublist)
          (pushq sublist parent)
          (setq allSuperContexts (concatenate sublist allSuperContexts)))
    ;; store the result:
    (setf (all-super-contexts module) allSuperContexts)
    ;; unreverse parents:
    (reverse (parent-modules module))))

(defmethod uninherit-supercontexts ((context CONTEXT))
  ;; Clear 'all-super-contexts'.
  (setf (all-super-contexts context) NIL))

(defun inherit-used-modules ((module MODULE))
  ;; Compute the actual set of modules used by 'module'.
  ;; There are three cases:
  ;; (1) 'module's uses-list contains itself, which indicates that the module
  ;;     was defined with ':uses ()', thus, the uses-list needs to be empty.
  ;; (2) 'module's uses-list is otherwise non-empty, which means it will use
  ;;     exactly the list of modules specified in its :uses specification.
  ;; (3) 'module's uses-list is empty, in which case a default set is computed;
  ;;     by default, top-level modules use the STELLA module, and non-top-level
  ;;     module use the union of modules used by their parents.  This allows
  ;;     submodules to see all symbols visible from any of their parents
  ;;     without having to know what modules are explicitly used by their
  ;;     parent modules (e.g., handy for children of PL-USER).
  (let ((usees (uses module)))
    (cond 
     ((empty? usees)
      ;; No :uses specified, compute modules that are used by default:
      (cond
       ((empty? (parent-modules module))
        ;; Use /STELLA by default:
        (push usees *stella-module*)
        (insert-new (used-by *stella-module*) module))
       (otherwise
        ;; Use everything the parents of 'module' use:
        (foreach parent in (parent-modules module)
            do (foreach parentUsees in (uses parent)
                   do (insert-new usees parentUsees)
                      (insert-new (used-by parentUsees) module)))
        (reverse usees))))
     ((member? usees module)
      ;; Kludge: remove module -- placed there to prevent default usees:
      (remove usees module))
     (otherwise
      ;; explicit :uses specification, use it as is:
      NULL))))

(defun uninherit-used-modules ((module MODULE))
  ;; Revert any computation performed by 'inherit-used-modules'.
  (let ((usees (uses module)))
    (cond 
     ((empty? usees)
      ;; Prevent default usees:
      (push usees module))
     ((null?
       ;; This test is a bit cheesy, since the documentation string might
       ;;    contain the substring we are looking for, but hey:
       (string-search (stringified-options module) ":USES " 0))
      ;; Remove default usees:
      (foreach usee in usees
          do (remove (used-by usee) module))
      (clear usees)))))

(defspecial *shadowedSurrogates* (CONS OF SYMBOL) NULL
  :documentation "Holds list of symbols representing surrogates
to be shadowed during module finalization.")

(defun finalize-module ((self MODULE))
  ;; Compute 'all-super-contexts'; allocate a context number;
  ;;   compute default value for '(uses self)'; shadow surrogates.
  (inherit-supercontexts self)
  (inherit-used-modules self)
  (setq *context-number-counter* (+ *context-number-counter* 2))
  (setf (context-number self) *context-number-counter*)
  (setf (cardinal-module self) 
        (choose (null? (parent-module self))
                self
                (cardinal-module (parent-module self))))
  (setf (symbol-offset-table self) (new STRING-TO-INTEGER-HASH-TABLE))
  (setf (surrogate-offset-table self) (new STRING-TO-INTEGER-HASH-TABLE))
  ;; now that 'module' is UP, we can shadow any surrogates that need
  ;;    shadowing:
  (when (non-empty? *shadowedSurrogates*)
    (setf (shadowed-surrogates self) (new (LIST OF SURROGATE)))
    (special ((*module* self))
      (foreach sym in *shadowedSurrogates*
	  do (insert-last  (shadowed-surrogates self)
			   (shadow-surrogate (symbol-name sym)))))))

(defun finalize-world ((self WORLD))
  ;; Compute 'all-super-contexts'.
  ;; Allocate a context number.
  (let ((parentContext (parent-context self)))
    (setf (all-super-contexts self)
          (cons parentContext (all-super-contexts parentContext)))
    (setq *context-number-counter* (+ *context-number-counter* 2))
    (setf (context-number self) *context-number-counter*) ))

(defmethod unfinalize-module ((self MODULE))
  ;; Garbage collect conses in '(all-super-contexts self)'.
  ;; Unlink 'self' from parent(s).
  ;; Decrement the context number, marking 'self' as discarded.
  (uninherit-supercontexts self)
  (uninherit-used-modules self)
  (if (cardinal-module? self)
    (remove (child-contexts *root-module*) self)
    (foreach parent in (parent-modules self)
             do (remove (child-contexts parent) self)))
  (clear (parent-modules self))
  ;; guard against decrementing NULL-INTEGER, since `self' might not yet be
  ;;    finalized (e.g., if we discovered an identical redefinition):
  (when (defined? (context-number self))
    (setf (context-number self) (1- (context-number self))))
  (setf (module-full-name self) NULL)
  (setf (cardinal-module self) NULL)
  (setf (symbol-offset-table self) NULL)
  (setf (surrogate-offset-table self) NULL))

(defmethod unfinalize-world ((self WORLD))
  ;; Unlink "self" from parent, mark "self" as discarded.
  (remove (child-contexts (parent-context self)) self)
  ;; markd "self" as discarded:
  (setf (context-number self) (1- (context-number self)))
  ;; for gc safety only:
  (setf (all-super-contexts self) NULL)
  (setf (parent-context self) NULL) )


  ;;
;;;;;; Context destruction
  ;;

(defun destroy-module ((self MODULE))
  :documentation "Destroy the module 'self', and recursively destroy
all contexts that inherit 'self'."
  :public? TRUE
  (when (or (eql? self *root-module*)
            (eql? self *stella-module*))
    (warn "Can't destroy the root module or the STELLA module.")
    (return))
  (clear-context self)
  (help-destroy-module self))

(defun help-destroy-module ((self MODULE))
  ;; Helper function for `destroy-module' which avoids unnecessary calls
  ;;    to `clear-context'.
  ;; Destroy bottom-up:
  (foreach child in (copy (child-contexts self))
      do (typecase child
           (MODULE (help-destroy-module child))
           (otherwise (destroy-context child))))
  (let ((parentModule (parent-module self)))
    (run-hooks *destroy-context-hooks* self)
    (when (null? parentModule)
      (setq parentModule (cardinal-module self)))
    (when (null? parentModule)
      (setq parentModule *stella-module*))
    (unfinalize-module self)
    (bump-memoization-timestamp :MODULE-UPDATE)
    (when (eq? self *module*)
      (change-module parentModule))) )

(defun destroy-world ((self WORLD))
  ;; CAUTION: Destroy bottom-up so that the 'all-super-concepts'
  ;;    links get gc'd correctly.
  :public? TRUE
  (safety 3 (not (deleted? self)) "Tried to destroy already deleted world.")
  (when (non-empty? (child-contexts self))
    (foreach child in (copy (child-contexts self))
             where (not (deleted? child))
             do (destroy-world child)))
  (let ((parentContext (parent-context self)))
    (run-hooks *destroy-context-hooks* self)
    (unfinalize-world self)
    (when (eq? self *context*)
      (setq *context* parentContext))) )

(defmethod destroy-context ((self MODULE))
  :documentation "Destroy the context 'self', and recursively destroy
all contexts that inherit 'self'."
  :public? TRUE
  (destroy-module self) )

(defmethod destroy-context ((self WORLD))
  :documentation "Destroy the context 'self', and recursively destroy
all contexts that inherit 'self'."
  :public? TRUE
  (destroy-world self) )

(defmethod destroy-context ((self STRING))
  :documentation "Destroy the context 'self', and recursively destroy
all contexts that inherit 'self'."
  :public? TRUE
  (let ((context (get-stella-context self TRUE)))
    (unless (null? context)
      (destroy-context context)) ))

(defmethod destroy-context ((self CONTEXT))
  :public? TRUE
  :documentation "Make the translator happy."
  NULL )


  ;;
;;;;;; Defining a context or module
  ;;

(defun link-to-parent-module
       ((self MODULE) (parent MODULE) (insert-first? BOOLEAN))
  ;; Doubly-link the module 'self' to its 'parent'.
  ;; Exception: Cardinal modules don't point to the root module.
  (when (and (not (eql? parent *root-module*))
             (not (member? (parent-modules self) parent)))
    (if insert-first?
      (insert (parent-modules self) parent)
      (insert-last (parent-modules self) parent)))
  (insert-new (child-contexts parent) self) )

(defun incorporate-module-name ((module MODULE) (name STRING))
  ;; Called by 'define-module'.
  ;; Parse 'name' and fill in the name and full name of 'module'.
  ;; If the name is qualified, also link 'module' to its parent.
  (let ((parentModule MODULE NULL)
        (bareName STRING NULL))
    (if (qualified-stella-name? name)
      (progn
        (mv-setq (parentModule bareName) (compute-module-and-bare-name name))
        (when (null? parentModule)
          (warn "Bad path name " name " when defining the module " bareName)
          (return))
        ;; link "module" to "parentModule" ahead of included modules:
        (if (or (and (eql? parentModule *root-module*)
                     (non-empty? (parent-modules module)))
                (exists includedModule in (parent-modules module)
                    where (and (not (eql? includedModule parentModule))
                               (subcontext? includedModule parentModule))))
            (warn "Bad path name " name " when defining the module " bareName ","
                  EOL "   since it points to a parent of an included module.")
          (link-to-parent-module module parentModule TRUE)))
      (progn
        (when (empty? (parent-modules module))
          (link-to-parent-module module *root-module* TRUE))
        (setq bareName name)))
    (setf (module-name module) bareName)
    (setf (module-full-name module)
          (compute-full-name "" module)) ))

(defun incorporate-includes-modules ((module MODULE) (includees OBJECT))
  ;; Helping function for 'incorporate-module-options'.
  ;; Insert the modules named in 'includees' into '(includes module)'.
  (typecase includees
   (CONS
    (foreach name in includees do (incorporate-includes-modules module name)))
   ((STRING SYMBOL)
    (let ((includeeModule (coerce-to-module includees TRUE)))
      (when (defined? includeeModule)
        (when (not (member? (parent-modules module) includeeModule))
          (insert-last (parent-modules module) includeeModule))
        (insert-new (child-contexts includeeModule) module))))
   (otherwise
    (walk-error "Illegal argument to ':includes' option" includees))) )

(defun incorporate-uses-modules ((module MODULE) (usees OBJECT))
  ;; Helping function for 'incorporate-module-options'.
  ;; Insert the modules named in 'usees' into '(uses module)'.
  (typecase usees
   (CONS
    (foreach name in usees do (incorporate-uses-modules module name))
    (when (empty? (uses module))
      ;; kludge: have "module" use itself to indicate that the default
      ;;    uses module should not be included.  Finalization removes
      ;;    the bogus usee:
      (insert (uses module) module)))
   ((STRING SYMBOL)
    (let ((useeModule (coerce-to-module usees TRUE)))
      (when (defined? useeModule)
        (when (not (member? (uses module) useeModule))
          (insert-last (uses module) useeModule))
        (insert-new (used-by useeModule) module))))
   (otherwise
    (walk-error "Illegal argument to ':uses' option "))) )

(defun (true-option? boolean) ((value OBJECT))
  ;; Helping function for option reading.  Returns TRUE if `value' is
  ;; either the symbol TRUE or the TRUE-BOOLEAN-WRAPPER.
  ;; Tricky:  Since this could be read in any module*, there is no guarantee
  ;;          that we would get the STELLA TRUE symbol, so we also test
  ;;          for string equality.
  ;; * See the comment in DEFINE-MODULE about parsing options.
  :globally-inline? TRUE
  (return (or (eql? value (quote TRUE))
              (eql? value TRUE-WRAPPER)
	      (and (isa? value @SYMBOL) 
		   (string-equal? (symbol-name (cast value SYMBOL)) "TRUE")))))

(defun incorporate-module-options ((self MODULE) (options CONS))
  ;; Called by 'define-module'.  Incorporate each of the options into 'self'.
  ;; Note: Modules point directly at parents and children, but they point
  ;;    at required modules, component modules, etc. indirectly through
  ;;    their names.
  (let ((plist 
         (vet-options 
          (new PROPERTY-LIST :the-plist options)
          (quote (:nickname :includes :uses :documentation
		  :shadow :case-sensitive?
		  :lisp-package :cpp-package :java-package
		  ;; Sets the name of the Java class for flotsam functions:
		  :java-catchall-class
		  ;; special API handling
		  :api?
                  ;; prevents accidental wiping out of module:
                  :clearable?
                  ;; prevents cleared modules from wiping out
                  ;;    surrogates and symbols embedded in code:
                  :protect-surrogates?
                  ;; prevents creation of KB objects where they don't belong:
                  :code-only?
                  :namespace?)))))
    (foreach (key value) in plist
      do (case (cast key KEYWORD)
	   (:includes (incorporate-includes-modules self value))
	   (:uses (incorporate-uses-modules self value))
	   (:shadow
	    ;; can't create surrogates before finalization; hold list
	    ;;    of symbols in special variable:
	    (setq *shadowedSurrogates* value))
	   (otherwise
	    (setq value (permanent-copy value))
	    (case (cast key KEYWORD)
	      (:documentation 
	       (setf (documentation self) (unwrap-string value)))
	      (:case-sensitive?
	       (setf (case-sensitive? self) (true-option? value)))
	      (:api? 
	       (setf (api? self) (true-option? value)))
	      (:lisp-package 
	       (setf (module-lisp-package self) (unwrap-string value)))
	      (:cpp-package
	       (setf (module-cpp-package self) (unwrap-string value)))
	      (:java-package
	       (setf (java-package self) (unwrap-string value)))
	      (:java-catchall-class
	       (setf (java-flotsam-class self) (unwrap-string value)))
	      (:nickname
	       (when (null? (nicknames self))
		 (setf (nicknames self) (new LIST)))
	       (insert (nicknames self) (cast value STRING-WRAPPER)))
	      (:clearable? 
	       (setf (clearable? self) (true-option? value)))
	      (:protect-surrogates?
	       (setf (protect-surrogates? self) (true-option? value)))
	      (:code-only?
	       (setf (code-only? self) (true-option? value)))
	      (:namespace?
	       (setf (namespace? self) (true-option? value)))
	      (:requires 
	       (setf (requires self) value))
	      ))))
    (free plist) ))

(defun undefine-module ((oldModule MODULE) (newModule MODULE))
  ;; 'oldModule' has been redefined as 'newModule'.
  ;; Detach 'oldModule' from parent and child contexts.
  ;; Apply the subcontext revision policy to 'oldModule' and its descendants.
  (inform "Redefining the module " (context-name oldModule))
  (case *subcontext-revision-policy*
    (:destroy
     (destroy-context oldModule)
     (return))
    (:preserve NULL)
    (:clear
     (foreach c in (all-subcontexts oldModule :preorder)
              do (clear-context c))))
  ;; detach parent contexts:
  (if (cardinal-module? oldModule)
    (remove (child-contexts *root-module*) oldModule)
    (foreach p in (parent-modules oldModule)
             do (remove (child-contexts p) oldModule)))
  ;; relink child contexts to 'newModule':
  (foreach c in (child-contexts oldModule)
           do
           (typecase c
             (MODULE
              (substitute 
               (the-cons-list (parent-modules c)) newModule oldModule))
             (WORLD (setf (parent-context c) newModule))))
  (setf (the-cons-list (child-contexts newModule))
        (the-cons-list (child-contexts oldModule)))
  (setf (the-cons-list (child-contexts oldModule)) NIL)
  (setf (surrogate-value-inverse oldModule) NULL)
  (unfinalize-module oldModule)
  (free oldModule) )

(defglobal *define-module-hooks* HOOK-LIST (new HOOK-LIST)
  :documentation "HOOK-LIST called by 'define-module', applied to a
'module' argument.")

;; NOTE:  Must use BQUOTE and not QUOTE here for bootstrap reasons:
(defglobal *MODULE-NON-STRUCTURAL-OPTIONS* (CONS OF KEYWORD) (BQUOTE (:DOCUMENTATION))
	   :public? FALSE
	   :documentation "List of non-structural options for Module definitions.
Used in testing for module changes and in updating non-structurally changed
modules.")

(defun (define-module MODULE) ((name STRING) (options CONS))
  :documentation "Define or redefine a module named 'name' having the
options 'options'.  Return the new module."
  :public? TRUE :constructor? TRUE
  (special ((*shadowedSurrogates* NIL))
    (let ((module MODULE NULL)
	  (stringifiedOptions (stringify options))
          (oldModule MODULE NULL))
      ;; check for old module definition:
      (setq oldModule (get-stella-module name FALSE))
      (when (and (defined? oldModule)
                 (identical-module-structure? oldModule NULL stringifiedOptions))
        ;; no change -- don't redefine module, just update any
	;; non-structural parts
	(update-non-structural-module-options oldModule NULL stringifiedOptions)
        (return oldModule))
      (setq module (new MODULE))
      ;; tricky: because option values are strings (and lists of strings)
      ;;    we don't have to change modules to parse the options:
      (setf (stringified-options module) stringifiedOptions)
      ;; parse options:
      (incorporate-module-options module options)
      ;; incorporate module name AFTER linking to included parents:
      (incorporate-module-name module name)
      (setf (base-module module) module)          ; point at self
      (when (defined? oldModule)
        ;; Check again for identical module redefinition, since we can
        ;;    define the same module with different syntaxes, e.g.,
        ;;    `(defmodule "/A/B")' vs. `(defmodule "B" :includes ("A"))'.
        ;;    The latter case requires option processing to determine
        ;;    the full name of the module:
        (when (identical-module-structure? oldModule module NULL)
          ;; no change -- don't redefine module, just update any 
	  ;; non-structural parts
	  (update-non-structural-module-options oldModule module NULL)
          (unfinalize-module module)
          (return oldModule))
        ;; Catch error condition:
        (when (eql? oldModule *module*)
          (warn "Can't define a module inside of itself.")
          (print "Skipping redefinition of module " name "." EOL)
          (unfinalize-module module)
          (return oldModule))
        (undefine-module oldModule module))
      (finalize-module module)
      (when (defined? oldModule)	; A redefinition
	;; And for redefinitions of existing modules with children,
	;; we go through and re-finalize them as well.  This needs
	;; to be done after the finalization of `module'.
	(foreach c in (all-subcontexts module :topdown)
	   ;; TO DO: Should these finalize-xyz calls be methods with a single name?
	   do (typecase c
		(MODULE 
		 (when (empty? (uses c)) ; Restore empty list kludge
		   (setf (uses c) (list c)))
		 (finalize-module c))
		(WORLD
		 (finalize-world c)))))
      (bump-memoization-timestamp :MODULE-UPDATE)
      (run-hooks *define-module-hooks* module)
      (return module) )))

(defun update-non-structural-module-options ((oldModule MODULE) (newModule MODULE)
					     (newOptions STRING))
  ;; Update the changed non-structural options of `oldModule' from `newModule'.
  ;; Maybe change the stringified source.
  ;; The newModule will be discarded shortly.
  ;; See also function `identical-module-structure?'.
  (when (null? newOptions)
    (setq newOptions (stringified-options newModule)))
  (let ((oldPlist (new PROPERTY-LIST :the-plist (unstringify (stringified-options oldModule))))
	(newPlist (new PROPERTY-LIST :the-plist (unstringify newOptions)))
	(oldValue OBJECT NULL)
	(newValue OBJECT NULL)
	(changed-values NIL))
    ;; Tricky.  If the newValue from the lookup is NULL, then we copy the
    ;;    default value out of the corresponding slot in "newModule", which
    ;;    will have been initialized at creation time.
    (foreach option in *MODULE-NON-STRUCTURAL-OPTIONS*
       do (setq oldValue (lookup oldPlist option))
          (setq newValue (lookup newPlist option))
	  (unless (eql? oldValue newValue)
	    (if (defined? newValue)
		(pushq changed-values newValue)
		(progn
		  (when (null? newModule) (setq newModule (new MODULE)))
		  (pushq changed-values 
			 (read-slot-value newModule (lookup-slot-from-option-keyword
						     (primary-type newModule) option)))))
	    (pushq changed-values option)))
    (when (non-empty? changed-values)
      (inform "Updating module " oldModule)
      (incorporate-module-options oldModule changed-values)
      (setf (stringified-options oldModule) newOptions))))

(defun (identical-module-structure? BOOLEAN)
    ((oldModule MODULE) (newModule MODULE) (newOptions STRING))
  ;; Return TRUE if `oldModule' and `newModule' have identical structure, i.e.,
  ;;    they were defined with the same full name and structural options.
  ;; Currently structural options include all options except for :DOCUMENTATION
  ;;    although this list should be expanded in the future.  See also
  ;;    function `update-non-structural-module-options'
  ;; If `newModule' is NULL, the test is performed against the option string
  ;;    `newOptions' of a module about to be created, assuming that their
  ;;    full names will match.
  ;; TO DO: EXPAND NON-STRUCTURAL-OPTIONS
  (when (and (defined? newModule)
             (not (eql? (module-full-name oldModule)
                        (module-full-name newModule))))
    (return FALSE))
  ;; If `newModule' is null, we assume that the names match:
  (let ((oldOptions (stringified-options oldModule)))
    (setq newOptions
      (choose (null? newModule)
              newOptions
              (stringified-options newModule)))
    (when (null? newOptions)
      (return FALSE))
    (when (eql-except-in-whitespace? oldOptions newOptions)
      (return TRUE))
    ;; Huh?
    (when (and (null? (string-search oldOptions ":INCLUDES" 0))
               (null? (string-search newOptions ":INCLUDES" 0)))
      (return FALSE))
    (when (and (defined? newModule)
               (equal-cons-trees?
                (the-cons-list (parent-modules oldModule))
                (the-cons-list (parent-modules newModule))))
      (let ((oldPlist (new PROPERTY-LIST :the-plist (unstringify oldOptions)))
            (newPlist (new PROPERTY-LIST :the-plist (unstringify newOptions))))
        (remove-at oldPlist :INCLUDES)
        (remove-at newPlist :INCLUDES)
	;; Run through each list separately to make sure we haven't added 
	;; or removed a structural option.
        (foreach (key value) in oldPlist
    	    where (not (member? *MODULE-NON-STRUCTURAL-OPTIONS* key))
	    do (unless (equal-cons-trees? value (lookup newPlist key))
                 (return FALSE)))
	(foreach (key value) in newPlist
    	    where (not (member? *MODULE-NON-STRUCTURAL-OPTIONS* key))
	    do (unless (equal-cons-trees? value (lookup oldPlist key))
                 (return FALSE)))
        (return TRUE)))
    (return FALSE)))

(defun (define-module-from-stringified-source MODULE) 
    ((name STRING) (stringifiedOptions STRING))
  :public? TRUE :constructor? TRUE
  ;; Define a stella module given a stringified definition
  (return (define-module name (unstringify stringifiedOptions))))

(defun (yield-define-module CONS) ((module MODULE))
  "Return a cons tree that (when evaluated) constructs a Stella module
object."
  (safety 2 (defined? (stringified-options module)))
  ;; build new module object by unstringifying source and parsing the
  ;;    result:
  (return
    (bquote (define-module-from-stringified-source
		& (wrap-literal (module-full-name module))
                & (yield-string-constant-tree
		   (stringified-options module))))))

(defun defmodule ((name NAME) &rest (options OBJECT))
  :public? TRUE :command? TRUE :evaluate-arguments? FALSE
  :documentation "Define (or redefine) a module named `name'.
The accepted syntax is:
	 
  (defmodule <module-name>
     [:documentation <docstring>]
     [:includes {<module-name> | (<module-name>*)}]
     [:uses {<module-name> | (<module-name>*)}]
     [:lisp-package <package-name-string>]
     [:java-package <package-specification-string>]
     [:cpp-namespace <namespace-name-string>]
     [:java-catchall-class
     [:api? {TRUE | FALSE}]
     [:case-sensitive? {TRUE | FALSE}]
     [:shadow (<symbol>*)]
     [:java-catchall-class <class-name-string>]
     [<other-options>*])
	
`name' can be a string or a symbol.

Modules include objects from other modules via two separate mechanisms:
(1) they inherit from their parents specified via the `:includes' option
and/or a fully qualified module name, and (2) they inherit from used
modules specified via the `:uses' option.  The main difference between
the two mechanisms is that inheritance from parents is transitive, while
uses-links are only followed one level deep.  I.e., a module A that uses
B will see all objects of B (and any of B's parents) but not see anything
from modules used by B.  Another difference is that only objects declared
as public can be inherited via uses-links (this is not yet enforced).
Note that - contrary to Lisp - there are separate name spaces for classes,
functions, and variables.  For example, a module could inherit the class
`CONS' from the `STELLA' module, but shadow the function of the same name.

The above discussion of `:includes' and `:uses' semantics keyed on the
inheritance/visibility of symbols. The PowerLoom system makes another
very important distinction: If a module 'A' is inherited directly or
indirectly via `:includes' specification(s) by a submodule 'B', then all
definitions and facts asserted in 'A' are visible in 'B'. This is not the
cases for `:uses'; the `:uses' options does not impact inheritance of
propositions at all.

The list of modules specified in the
`:includes' option plus (if supplied) the parent in the path used for
`name' become the new module's parents. If no `:uses' option was
supplied, the new module will use the `STELLA' module by default,
otherwise, it will use the set of specified modules.
If `:case-sensitive?' is supplied as TRUE, symbols in the module will be
interned case-sensitively, otherwise (the default), they will be
converted to uppercase before they get interned. Modules can shadow
definitions of functions and classes inherited from parents or used
modules. Shadowing is done automatically, but generates a warning unless
the shadowed type or function name is listed in the `:shadow' option of
the module definition .

Examples:
	 
  (defmodule \"PL-KERNEL/PL-USER\"
    :uses (\"LOGIC\" \"STELLA\")
    :package \"PL-USER\")

  (defmodule PL-USER/GENEALOGY)
	
The remaining options are relevant only for modules that contain STELLA
code.  Modules used only to contain knowledge base definitions and assertions
have no use for them:

The keywords `:lisp-package', `:java-package', and `:cpp-package' specify
the name of a native package or name space in which symbols of the module
should be allocated when they get translated into one of Lisp, Java, or
C++. By default, Lisp symbols are allocated in the `STELLA' package, and
C++ names are translated without any prefixes. The rules that the STELLA
translator uses to attach translated Java objects to classes and packages
are somewhat complex. Use :java-package option to specify a list of
package names (separated by periods) that prefix the Java object in this
module.  Use :java-catchall-class to specify the name of the Java class to
contain all global & special variables, parameter-less functions and functions 
defined on arguments that are not classes in the current module.
The default value will be the name of the module.

When set to TRUE, the :api? option tells the PowerLoom User Manual
generator that all functions defined in this module should be included in
the API section. Additionally, the Java translator makes all API
functions `synchronized'.
"
  (let ((moduleName (coerce-to-module-name name TRUE)))
    (when (defined? moduleName)
      (define-module moduleName (coerce-&rest-to-cons options)))))

(defun (in-module MODULE) ((name NAME))
  :public? TRUE :command? TRUE :evaluate-arguments? FALSE :lisp-macro? TRUE
  :documentation "Change the current module to the module named `name'."
  (let ((moduleName (coerce-to-module-name name TRUE))
        (module (choose (defined? moduleName)
                        (get-stella-module moduleName FALSE)
                        NULL)))
    (cond ((defined? module)
           (setq *module* module)
           (setq *context* module))
          (otherwise
           (error "Illegal or undefined module: " name)))
    (return *module*)))

  ;;
;;;;;; Worlds
  ;;

(defun (create-world WORLD) ((parentContext CONTEXT) (name STRING))
  :documentation "Create a new world below the world or module 'parentContext'.
Optionally, specify a name."
  :public? TRUE
  :inline finalize-world
  (let ((world (new WORLD)))
    (when (defined? name)
      (setf (world-name world) name)
      ;; check for sibling with same name
      (when (exists sibling in (child-contexts parentContext)
                    where (string-eql? (context-name sibling) name))
        (warn "Can't create a world named " name
              " because a sibling already has that name.")
        (return NULL)))
    (setf (parent-context world) parentContext)
    (insert (child-contexts parentContext) world)
    (setf (base-module world) (base-module parentContext))
    (finalize-world world)
    (return world) ))

(defmethod (multiple-parents? BOOLEAN) ((world WORLD))
  :documentation "Return FALSE always, since worlds never have more than one parent."
  (return FALSE) )

  ;;
;;;;;; Push and pop world
  ;;

(defun (push-world WORLD) ()
  :documentation "Spawn a new world that is a child of the current context,
and change the current context to the new world."
  :public? TRUE
  (return (setq *context* (create-world *context* NULL))) )

(defun (pop-world CONTEXT) ()
  :documentation "Destroy the current world and change the current
context to be its parent.  Return the current context. Nothing happens
if there is no current world."
  :public? TRUE
  ;; tricky test to see if *context* is a module:
  (when (not (eql? *context* *module*))
    (let ((world WORLD *context*))
      (setq *context* (parent-context world))
      (destroy-world world)))
  (return *context*) )


  ;;
;;;;;; Navigation functions
  ;;

(defun (all-subcontexts (ALL-PURPOSE-ITERATOR OF CONTEXT)) ((context CONTEXT)
                                                            (traversal KEYWORD))
  :documentation "Return an iterator that generates all subcontexts of
'self' (not including 'self') in the order specified by 'traversal' (one
of :preorder, :inorder, :postorder or :topdown)."
  (let ((contextsIterator (new ALL-PURPOSE-ITERATOR))
        (subContexts NIL))
    (foreach child in (child-contexts context)
      collect child into subContexts)
    (when (eql? traversal :postorder)
      (setq subContexts (reverse subContexts)))
    (setf (iterator-cons-list contextsIterator) subContexts)
    (if (eql? traversal :topdown)
      (progn 
        (setf (iterator-object contextsIterator) context)
        (setf (iterator-next-code contextsIterator)
              (the-code :function all-topdown-subcontexts-next?)))
      (progn
        (setf (iterator-object contextsIterator) traversal)
        (setf (iterator-next-code contextsIterator)
              (the-code :function all-subcontexts-next?))))
    (return contextsIterator) ))

#|
;; Test code:
(eval (foreach k in (quote (:preorder :inorder :postorder :topdown))
          do (print EOL K EOL)
             (foreach sub in (all-subcontexts (get-stella-context "PL-KERNEL-KB" TRUE) k)
               do (print "  " sub eol))))
|#

(defun (all-subcontexts-next? BOOLEAN) ((self ALL-PURPOSE-ITERATOR))
  ;; 'next?' function for the 'all-subcontexts' iterator.
  (let ((traversal KEYWORD (iterator-object self))
        (remainingContexts (iterator-cons-list self))
        (thisContext CONTEXT NULL)
        (subContexts NIL)
        (beenThere HASH-SET (iterator-second-object self)))
    (when (empty? remainingContexts)
      (setf (slot-value self value) NULL)
      (return FALSE))
    (when (null? beenThere)
      ;; first time around, initialize the `beenThere' list, don't do it in
      ;;    `all-subcontexts' since `all-contexts' hacks the initialization:
      (setq beenThere (new HASH-SET))
      (setf (iterator-second-object self) beenThere)
      (foreach ctxt in remainingContexts
          do (insert beenThere ctxt)))
    (setq thisContext (first remainingContexts))
    (setq remainingContexts (rest remainingContexts))
    (foreach child in (child-contexts thisContext)
        ;; Avoid duplicates due to multiple inheritance:
        where (not (member? beenThere child))
        do (insert beenThere child)
        collect child into subContexts)
    (if (empty? subContexts)
      (setf (iterator-cons-list self) remainingContexts)
      (case traversal
        (:preorder
         (setf (rest (last-cons subContexts)) remainingContexts)
         (setf (iterator-cons-list self) subContexts))
        (:postorder
         (setq subContexts (reverse subContexts))
         (setf (rest (last-cons subContexts)) remainingContexts)
         (setf (iterator-cons-list self) subContexts))
        (:inorder
         (cond ((empty? remainingContexts)
                (setf (iterator-cons-list self) subContexts))
               (otherwise
                (setf (rest (last-cons remainingContexts)) subContexts)
                (setf (iterator-cons-list self) remainingContexts))))))
    (setf (slot-value self value) thisContext)
    (return TRUE)))

(defun (all-topdown-subcontexts-next? BOOLEAN) ((self ALL-PURPOSE-ITERATOR))
  ;; alternate 'next?' function for the 'all-subcontexts' iterator.
  (let ((remainingContexts (iterator-cons-list self))
        (thisContext CONTEXT NULL)
        (subContexts NIL)
        (beenThere HASH-TABLE (iterator-second-object self)))
    (when (empty? remainingContexts)
      (setf (slot-value self value) NULL)
      (return FALSE))
    (when (null? beenThere)
      ;; first time around, initialize the `beenThere' list, don't do it in
      ;;    `all-subcontexts' since `all-contexts' hacks the initialization:
      (setq beenThere (new HASH-TABLE))
      (setf (iterator-second-object self) beenThere)
      ;; For topdown traversal, we initially get the start context as
      ;; the sole item in remainingContexts.  We initialize the visited
      ;; table to FALSE-WRAPPER for all subs, and then make sure that 
      ;; all parents of any context we return have either been visited
      ;; (and have a TRUE-WRAPPER value) or they are outside the initial
      ;; subtree (and have a NULL value).
      (foreach sub in (all-subcontexts (iterator-object self) :preorder)
        do (insert-at beenThere sub FALSE-WRAPPER)))
    (while (non-empty? remainingContexts)
      (setq thisContext (first remainingContexts))
      ;; Tricky:  Test this before moving down the list so that
      ;;    after we exit the loop, we can test for exhausted values
      (when (forall p in (parent-contexts thisContext)
                    always (not (eql? (lookup beenThere p) FALSE-WRAPPER)))
        (break))
      (setq remainingContexts (rest remainingContexts)))
    (if (empty? remainingContexts)
      (progn                            ; None found, so punt.
        (setf (slot-value self value) NULL)
        (return FALSE))
      (setq remainingContexts (rest remainingContexts)))
    (insert-at beenThere thisContext TRUE-WRAPPER)
    (foreach child in (child-contexts thisContext)
      collect child into subContexts)
    (cond ((empty? remainingContexts)
           (setf (iterator-cons-list self) subContexts))
          ((empty? subContexts)
           (setf (iterator-cons-list self) remainingContexts))
          (otherwise
           (setf (rest (last-cons remainingContexts)) subContexts)
           (setf (iterator-cons-list self) remainingContexts)))
    (setf (slot-value self value) thisContext)
    (return TRUE)))

(defun (all-contexts (ITERATOR OF CONTEXT)) ()
  :public? TRUE
  :documentation "Return an iterator that generates all contexts."
  (let ((iterator ALL-PURPOSE-ITERATOR
                  (all-subcontexts *root-module* :preorder)))
    ;; This uses knowledge about the internals of the 'all-subcontexts'
    ;; iterator to make it start with *root-module* instead of its children:
    (setf (iterator-cons-list iterator) (cons *root-module* NIL))
    (return iterator)))

(defun (filter-module? BOOLEAN) ((self OBJECT) (iterator ALL-PURPOSE-ITERATOR))
  ;; Assumes that the class MODULE is final.
  (ignore iterator)
  (return (eql? (primary-type self) @MODULE)) )

(defun (all-modules (ITERATOR OF MODULE)) ()
  :public? TRUE
  :documentation "Return an iterator that generates all modules."
  (let ((contextsIterator (all-contexts))
        (iterator (new ALL-PURPOSE-ITERATOR)))
    (setf (first-iteration? iterator) TRUE)
    (setf (iterator-nested-iterator iterator) contextsIterator)
    (setf (iterator-next-code iterator)
          (the-code :function filtered-nested-iterator-next?))
    (setf (iterator-filter-code iterator)
          (the-code :function filter-module?))
    (return iterator)))

(defun (list-modules (CONS OF MODULE)) ((kb-only? BOOLEAN))
  :public? TRUE
  :command? TRUE
  :documentation "Returns a cons of all modules defined in PowerLoom.  If `kb-only?'
is `true', then any modules which are code only or just namespaces are not returned."
  (if kb-only?
    (return (collect m in (all-modules) where (and (not (code-only? m))
                                                   (not (namespace? m)))))
    (return (collect m in (all-modules)))))

(defun (all-included-modules (ITERATOR OF MODULE)) ((self MODULE))
  :public? TRUE
  :documentation "Generate a sequence of all modules included
by 'self', inclusive, starting from the highest ancestor and working
down to 'self' (which is last)."
  (let ((copy (copy-cons-list
               (cast (all-super-contexts self) (CONS OF MODULE)))))
    (pushq copy self)
    (return
     (allocate-destructive-list-iterator (reverse copy))) ))

(defun (visible-modules (CONS OF MODULE)) ((from MODULE))
  :documentation
  "Return a list of all modules visible from module `from' (or `*module*'
if `from' is NULL.  The generated modules are generated from most to
least-specific and will start with the module `from'."
  :public? TRUE
  (when (null? from)
    (setq from *module*))
  (return
    ;; for top-level code modules the memoization doesn't buy us much:
    (memoize (from)
             :timestamps :MODULE-UPDATE :max-values 50
             (help-memoize-visible-modules from))))

(defun (help-memoize-visible-modules (CONS OF MODULE)) ((from MODULE))
  ;; Helper function for `visible-modules' that does all the work.
  (let ((visibleModules (CONS OF MODULE) NIL))
    (pushq visibleModules from)
    (foreach super in (all-super-contexts from)
        do (pushq visibleModules super))
    (foreach usee in (uses from)
        do (when (not (memb? visibleModules usee))
             (pushq visibleModules usee))
           (foreach useeSuper in (all-super-contexts usee)
               ;; Avoid duplicates (e.g., if siblings use each other):
               where (not (memb? visibleModules useeSuper))
               do (pushq visibleModules useeSuper)))
    (return (reverse visibleModules))))


  ;;
;;;;;; Inheritance
  ;;

(defun (cardinal-module? BOOLEAN) ((self MODULE))
  ;; Return TRUE if 'self' is a direct child of the ROOT module.
  (return (eql? (cardinal-module self) self)) )

(defun (visible-from? BOOLEAN) ((viewedContext CONTEXT) (fromContext CONTEXT))
  :public? TRUE
  ;; Return TRUE if 'viewedContext' is inherited by or used by 'fromContext'.
  (return
    (or (eql? viewedContext fromContext)
        (memb? (all-super-contexts fromContext) viewedContext)
        (exists usesModule in (choose (isa? fromContext @MODULE)
                                      (uses (cast fromContext MODULE))
                                      (uses (base-module fromContext)))
            where (or (eql? viewedContext usesModule)
                      (memb? (all-super-contexts usesModule)
                             viewedContext))))))


  ;;
;;;;;; "clear-context"
  ;;

(startup-time-progn
  (setf (clearable? *root-module*) FALSE)
  (setf (clearable? *stella-module*) FALSE)
  (setf (clearable? *common-lisp-module*) FALSE))

(defun clear-one-context ((self CONTEXT))
  ;; Destroy all objects belonging to the context 'self'.
  (typecase self
    (MODULE
     (when (not (clearable? self))
       (warn "Module " (module-full-name self) " cannot be cleared!")
       (return))
     (run-hooks *clear-module-hooks* self)
     (foreach function in (all-functions self TRUE)
         do (destroy-function function))
     (foreach variable in (all-variables self TRUE)
         do (destroy-variable variable))
     (foreach class in (all-classes self TRUE)
         do (destroy-class class))
     (foreach surrogate in (all-surrogates self TRUE)
         do (if (protect-surrogates? self)
                (setf (surrogate-value surrogate) NULL)
              (unintern-surrogate surrogate)))
     ;; if we are protecting surrogates, then we protect symbols as well:
     (unless (protect-surrogates? self)
       (foreach symbol in (all-symbols self TRUE)
           do (unintern-symbol symbol)))
     (special ((*module* self))
       (foreach it on (shadowed-surrogates self)
	   do (setf (value it) (shadow-surrogate (symbol-name (value it))))))
     (bump-memoization-timestamp :MODULE-UPDATE))
    (otherwise NULL)))

(defun help-clear-context ((self CONTEXT))
  ;; Destroy objects bottom up:
  (foreach child in (child-contexts self)
           do (help-clear-context child))
  (clear-one-context self) )

(defun clear-context ((self CONTEXT))
  :public? TRUE
  :documentation
  "Destroy all objects belonging to 'self' or any of its subcontexts."
  ;; Destroy objects bottom up:
  (help-clear-context self)
  (finalize-classes-and-slots))

(defun call-clear-module (&rest (name NAME))
  :public? TRUE :command? TRUE :evaluate-arguments? TRUE :lisp-macro? FALSE
  :documentation
  "Destroy all objects belonging to module `name' or any of its children.
If no `name' is supplied, the current module will be cleared after
confirming with the user.  Important modules such as STELLA are protected
against accidental clearing."
  (let ((arglist (coerce-&rest-to-cons name))
        (module (coerce-to-module (first arglist) TRUE)))
    (when (defined? module)
      (when (or (non-empty? arglist)
                (y-or-n? (concatenate
                           "Really clear module "
                           (concatenate (module-full-name module) "? "))))
        (clear-context module)))))

(defun clear-module (&rest (name NAME))
  :public? TRUE :command? TRUE :evaluate-arguments? FALSE
  :documentation
  "Destroy all objects belonging to module `name' or any of its children.
If no `name' is supplied, the current module will be cleared after
confirming with the user.  Important modules such as STELLA are protected
against accidental clearing."
  (if (= (length name) 0)
      (call-clear-module)
    (call-clear-module (first (coerce-&rest-to-cons name)))))
