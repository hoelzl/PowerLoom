;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;; BEGIN LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
; Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          ;
;                                                                            ;
; The contents of this file are subject to the Mozilla Public License        ;
; Version 1.1 (the "License"); you may not use this file except in           ;
; compliance with the License. You may obtain a copy of the License at       ;
; http://www.mozilla.org/MPL/                                                ;
;                                                                            ;
; Software distributed under the License is distributed on an "AS IS" basis, ;
; WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   ;
; for the specific language governing rights and limitations under the       ;
; License.                                                                   ;
;                                                                            ;
; The Original Code is the STELLA Programming Language.                      ;
;                                                                            ;
; The Initial Developer of the Original Code is                              ;
; UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          ;
; 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               ;
;                                                                            ;
; Portions created by the Initial Developer are Copyright (C) 1996-2006      ;
; the Initial Developer. All Rights Reserved.                                ;
;                                                                            ;
; Contributor(s):                                                            ;
;                                                                            ;
; Alternatively, the contents of this file may be used under the terms of    ;
; either the GNU General Public License Version 2 or later (the "GPL"), or   ;
; the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   ;
; in which case the provisions of the GPL or the LGPL are applicable instead ;
; of those above. If you wish to allow use of your version of this file only ;
; under the terms of either the GPL or the LGPL, and not to allow others to  ;
; use your version of this file under the terms of the MPL, indicate your    ;
; decision by deleting the provisions above and replace them with the notice ;
; and other provisions required by the GPL or the LGPL. If you do not delete ;
; the provisions above, a recipient may use your version of this file under  ;
; the terms of any one of the MPL, the GPL or the LGPL.                      ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; END LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; Version: methods.ste,v 1.88 2006/05/11 07:06:18 hans Exp

;;; Procedures that define Stella method objects (method-slots).

(in-package "STELLA")

(in-module "/STELLA")


  ;;
;;;;;; "apply"
  ;;

(defun (apply OBJECT) ((code FUNCTION-CODE) (arguments (CONS OF OBJECT)))
  :documentation "Apply `code' to `arguments', returning a value of type
OBJECT."
  :public? TRUE
  (case (length arguments)
    (0 (return (funcall code)))
    (1 (return (funcall code (first arguments))))
    (2 (return (funcall code (first arguments) (second arguments))))
    (3 (return (funcall code (first arguments) (second arguments)
                        (nth arguments 2))))
    (4 (return (funcall code (first arguments) (second arguments)
               (nth arguments 2) (nth arguments 3))))
    (5 (return (funcall code (first arguments) (second arguments)
                        (nth arguments 2) (nth arguments 3)
                        (nth arguments 4))))
    (otherwise
     (error "Too many function arguments in `apply'.  Max is 5."))))

;;; TO DO: CLEANUP THE UGLY HANDLING OF METHOD CODE AND LITERAL RETURN TYPES

(defun (apply-method OBJECT)
       ((code METHOD-CODE) (arguments (CONS OF OBJECT)))
  :documentation "Apply `code' to `arguments', returning a value of type
OBJECT."
  :public? TRUE
  (case (length arguments)
    (0 (error "Can't call method code on 0 arguments."))
    (1 (return (funcall code (first arguments))))
    (2 (return (funcall code (first arguments) (second arguments))))
    (3 (return (funcall code (first arguments) (second arguments)
                        (nth arguments 2))))
    (4 (return (funcall code (first arguments) (second arguments)
                        (nth arguments 2) (nth arguments 3))))
    (5 (return (funcall code (first arguments) (second arguments)
                        (nth arguments 2) (nth arguments 3)
                        (nth arguments 4))))
    (otherwise
     (error "Too many function arguments in `apply'.  Max is 5."))))

(defun (apply-integer-method INTEGER)
       ((code METHOD-CODE) (arguments (CONS OF OBJECT)))
  :documentation "Apply `code' to `arguments', returning a value of type
INTEGER."
  :public? TRUE
  (case (length arguments)
    (0 (error "Can't call method code on 0 arguments."))
    (1 (return (funcall code (first arguments))))
    (2 (return (funcall code (first arguments) (second arguments))))
    (3 (return (funcall code (first arguments) (second arguments)
                        (nth arguments 2))))
    (4 (return (funcall code (first arguments) (second arguments)
                        (nth arguments 2) (nth arguments 3))))
    (5 (return (funcall code (first arguments) (second arguments)
                        (nth arguments 2) (nth arguments 3)
                        (nth arguments 4))))
    (otherwise
     (error "Too many function arguments in `apply'.  Max is 5."))))

(defun (apply-string-method STRING) ((code METHOD-CODE) (arguments (CONS OF OBJECT)))
  :documentation "Apply `code' to `arguments', returning a value of type
STRING."
  :public? TRUE
  (case (length arguments)
    (0 (error "Can't call method code on 0 arguments."))
    (1 (return (funcall code (first arguments))))
    (2 (return (funcall code (first arguments) (second arguments))))
    (3 (return (funcall code (first arguments) (second arguments)
                        (nth arguments 2))))
    (4 (return (funcall code (first arguments) (second arguments)
                        (nth arguments 2) (nth arguments 3))))
    (5 (return (funcall code (first arguments) (second arguments)
                        (nth arguments 2) (nth arguments 3)
                        (nth arguments 4))))
    (otherwise
     (error "Too many function arguments in `apply'.  Max is 5."))))

(defun (apply-boolean-method BOOLEAN) ((code METHOD-CODE) (arguments (CONS OF OBJECT)))
  :documentation "Apply `code' to `arguments', returning a value of type
BOOLEAN."
  :public? TRUE
  (case (length arguments)
    (0 (error "Can't call method code on 0 arguments."))
    (1 (return (funcall code (first arguments))))
    (2 (return (funcall code (first arguments) (second arguments))))
    (3 (return (funcall code (first arguments) (second arguments)
                        (nth arguments 2))))
    (4 (return (funcall code (first arguments) (second arguments)
                        (nth arguments 2) (nth arguments 3))))
    (5 (return (funcall code (first arguments) (second arguments)
                        (nth arguments 2) (nth arguments 3)
                        (nth arguments 4))))
    (otherwise
     (error "Too many function arguments in `apply'.  Max is 5."))))

(defun (apply-float-method FLOAT) ((code METHOD-CODE) (arguments (CONS OF OBJECT)))
  :documentation "Apply `code' to `arguments', returning a value of type
FLOAT."
  :public? TRUE
  (case (length arguments)
    (0 (error "Can't call method code on 0 arguments."))
    (1 (return (funcall code (first arguments))))
    (2 (return (funcall code (first arguments) (second arguments))))
    (3 (return (funcall code (first arguments) (second arguments)
                        (nth arguments 2))))
    (4 (return (funcall code (first arguments) (second arguments)
                        (nth arguments 2) (nth arguments 3))))
    (5 (return (funcall code (first arguments) (second arguments)
                        (nth arguments 2) (nth arguments 3)
                        (nth arguments 4))))
    (otherwise
     (error "Too many function arguments in `apply'.  Max is 5."))))


  ;;
;;;;;; 'define-stella-method-slot'
  ;;

(defun (defined-type? BOOLEAN) ((type TYPE))
  ;; Return TRUE if 'type' was defined with '(deftype ...)'.
  :public? TRUE
  (let ((value (surrogate-value type))
        (valueType TYPE NULL))
    (when (defined? value)
      ;; Tiny kludge to make things work during bootstrap:
      (setq valueType (primary-type value))
      (return (or (eql? @SURROGATE valueType)
                  (eql? @PARAMETRIC-TYPE-SPECIFIER valueType)
                  (eql? @ANCHORED-TYPE-SPECIFIER valueType))))
    (return FALSE)))

(defun (real-type-specifier TYPE-SPEC) ((type TYPE))
  ;; Return the real type-specifier represented by 'type', i.e., if
  ;;   'type' is a defined type resulting from a '(deftype ...)'
  ;;   declaration, return its definition.  Otherwise return 'type'.
  (let ((value (surrogate-value type)))
    (if (defined-type? type)
        (if (type? value)
            ;; This follows chains all the way to the end:
            (return (real-type-specifier value))
          (return value))
      (return type))))

(defun (canonical-type TYPE) ((type TYPE))
  ;; Dereference synonyms and return the canonical version of 'type'.
  (let ((class (type-class type)))
    (if (defined? class)
        (return (class-type class))
      (return type))))

;;; Defined types are immediately replaced with their primitive
;;; definitions, thus, we implement structural type equivalence.

(defmethod (yield-type-specifier TYPE-SPEC) ((typeSpecTree TYPE))
  ;; Return a TYPE-SPEC entity containing the type information in the
  ;;    parse tree 'typeSpecTree'.
  (return (real-type-specifier typeSpecTree)))

(defmethod (yield-type-specifier TYPE-SPEC) ((typeSpecTree SYMBOL))
  ;; Return a TYPE-SPEC entity containing the type information in the
  ;;    parse tree 'typeSpecTree'.
  (return (real-type-specifier (typify typeSpecTree))))

(defmethod (yield-type-specifier TYPE-SPEC)
    ((typeSpecTree PARAMETRIC-TYPE-SPECIFIER))
  ;; Return a TYPE-SPEC entity containing the type information in the
  ;;    parse tree 'typeSpecTree'.
  (return typeSpecTree))

(defmethod (yield-type-specifier TYPE-SPEC)
    ((typeSpecTree ANCHORED-TYPE-SPECIFIER))
  ;; Return a TYPE-SPEC entity containing the type information in the
  ;;    parse tree 'typeSpecTree'.
  (return typeSpecTree))

(defmethod (yield-type-specifier TYPE-SPEC) ((typeSpecTree OBJECT))
  (continuable-error "Illegal type specification " typeSpecTree)
  (return @OBJECT) )

(defmethod (yield-type-specifier TYPE-SPEC) ((typeSpecTree CONS))
  (cond
   ((empty? typeSpecTree) (return @VOID))
   ((eq? (value typeSpecTree) (quote LIKE))
    (return (yield-anchored-type-specifier typeSpecTree)))
   (otherwise
    (return (yield-parametric-type-specifier typeSpecTree)))) )

(defun (verify-type TYPE) ((self TYPE)))        ; forward declaration

(defun (yield-parametric-type-specifier PARAMETRIC-TYPE-SPECIFIER)
    ((typeSpecTree CONS))
  ;; Called by 'CONS.yield-type-specifier'.
  (let ((typeSpec (new PARAMETRIC-TYPE-SPECIFIER))
        (parameterTypeSpec TYPE-SPEC NULL)
        (cursor typeSpecTree)
        (baseType (typify (popq cursor)))
        (realBaseTypeSpec (real-type-specifier baseType))
        (definedBaseType? (not (eql? baseType realBaseTypeSpec)))
        (operator (popq cursor))
        (arrayType? FALSE))
    (when definedBaseType?
      (setq baseType (type-spec-to-base-type realBaseTypeSpec)))
    (setf (specifier-base-type typeSpec) (verify-type baseType))
    (when (array-type-specifier? typeSpec)
      (when (eql? operator (quote SIZE))
       (setq operator (popq cursor)))
      (setq arrayType? TRUE)
      (setf (specifier-dimensions typeSpec)
        (parse-array-dimensions-spec operator))
      (setq operator (popq cursor)))
    (when (and arrayType?
               (null? (specifier-dimensions typeSpec)))
      (walk-error "Illegal array type specifier dimensions: " typeSpecTree)
      (return (yield-parametric-type-specifier (bquote (UNKNOWN OF)))))
    (when (not (eql? operator (quote OF)))
      (walk-error "Bad type specifier " typeSpecTree)
      (return (yield-parametric-type-specifier (bquote (UNKNOWN OF)))))
    (foreach p in cursor
        do (setq parameterTypeSpec (yield-type-specifier p))
           (when (array-type-specifier? parameterTypeSpec)
             (walk-error "Illegal nested array type specifier: " EOL
                         "   " typeSpecTree EOL
                         "   Use multi-dimensional arrays instead")
             (return (yield-parametric-type-specifier (bquote (UNKNOWN OF)))))
        collect parameterTypeSpec
        into (specifier-parameter-types typeSpec))
    (when definedBaseType?
      (typecase realBaseTypeSpec
        (PARAMETRIC-TYPE-SPECIFIER
         ;; check whether the parameter types are compatible:
         (unless (and (= (length (specifier-parameter-types realBaseTypeSpec))
                         (length (specifier-parameter-types typeSpec)))
                      (forall parType in (specifier-parameter-types typeSpec)
                        as rParType in (specifier-parameter-types realBaseTypeSpec)
                        ;; use less stringent test here to deal with class finalization
                        ;; issues; we can't check later, since we can't record that
                        ;; we expanded a defined base type:
                        always (optimistic-subtype-of?
                                (type-spec-to-base-type parType)
                                (type-spec-to-base-type rParType))))
           (walk-error "Parameter types of " typeSpecTree " are incompatible " EOL
                       " with parameter types of defined type "
                       (first typeSpecTree))
           (return (yield-parametric-type-specifier (bquote (UNKNOWN OF))))))
        (otherwise NULL)))
    (return typeSpec) ))

(defun (parse-array-dimensions-spec (LIST OF INTEGER-WRAPPER))
    ((dimensionsSpec OBJECT))
  ;; Parse an array dimensions specification, i.e., the object following the
  ;;    `SIZE' keyword in a parametric array type specification, and return
  ;;    the list of parsed dimensions.
  ;; The length of the list indicates the number of array dimensions;
  ;;    unspecified dimensions will be NULL.
  ;; Return NULL in case of an illegal dimension specification.
  ;; The following are legal dimension specifications:
  ;;
  ;;    (ARRAY SIZE () OF INTEGER)        1-dimensional, unspecified size
  ;;    (ARRAY () OF INTEGER)             ditto (the SIZE keyword is optional)
  ;;    (ARRAY (()) OF INTEGER)           ditto
  ;;    (ARRAY (NULL) OF INTEGER)         ditto
  ;;    (ARRAY ((NULL)) OF INTEGER)       ditto
  ;;
  ;;    (ARRAY 10 OF INTEGER)             1-dimensional, size 10
  ;;    (ARRAY (10) OF INTEGER)           ditto
  ;;    (ARRAY (() ()) OF INTEGER)        2-dimensional, unspecified size
  ;;    (ARRAY (NULL NULL) OF INTEGER)    ditto
  ;;    (ARRAY (10 20) OF INTEGER)        2-dimensional, 10 rows, 20 cols
  ;;    (ARRAY ((10)(20)) OF INTEGER)     2-dimensional, 10 rows, 20 cols
  ;;    (ARRAY (() 10 () 20) OF INTEGER)  4-dimensional, ? x 10 x ? x 20
  ;;
  ;;    The `()' or `(()(20))' syntax is preferred because of its similarity
  ;;    with the C++ and Java array syntax.
  (let ((dimensions (new (LIST OF INTEGER-WRAPPER))))
    (when (null? dimensionsSpec)
      ;; a dimension specification is mandatory:
      (return NULL))
    (unless (and (cons? dimensionsSpec)
                 (not (eql? dimensionsSpec NIL)))
      (setq dimensionsSpec (cons dimensionsSpec NIL)))
    (foreach dimSpec in (cast dimensionsSpec CONS)
        do (when (cons? dimSpec)
             (setq dimSpec (first (cast dimSpec CONS))))
           (cond ((or (eql? dimSpec NULL)
                      (eql? dimSpec (quote NULL)))
                  (setq dimSpec NULL))
                 ((integer? dimSpec) NULL)
                 (otherwise
                  ;; illegal dimension specification:
                  (return NULL)))
        collect dimSpec into dimensions)
    (return dimensions)))

(defun (yield-array-dimensions-tree CONS) ((arrayType PARAMETRIC-TYPE-SPECIFIER))
  ;; Inverse to `parse-array-dimensions-spec'.
  ;; Take the parsed dimensions specification stored in `arrayType' and return
  ;;    a parse tree that would parse into an equivalent specification.
  (let ((dimensions (specifier-dimensions arrayType))
        (result (CONS OF CONS) NIL))
    (when (null? dimensions)
      (return NULL))
    (foreach dim in dimensions
        collect (choose (null? dim) NIL (cons dim NIL)) into result)
    (if (= (length result) 1)
        (return (first result))
      (return result))))

(defun (array-type-specifier? BOOLEAN) ((typeSpec TYPE-SPEC))
  ;; Return TRUE if `typeSpec' is an array type specifier.
  (typecase typeSpec
    (PARAMETRIC-TYPE-SPECIFIER
     (let ((baseType (specifier-base-type typeSpec)))
       (when (or (eql? baseType @ARRAY)
                 ;(eql? baseType @ARRAY-WRAPPER) ;; not yet
                 )
         (return TRUE))))
    (otherwise NULL))
  (return FALSE))

(defun (array-type-rank INTEGER) ((arrayType PARAMETRIC-TYPE-SPECIFIER))
  ;; Return the number of dimensions of the array specified by `arrayType'.
  (let ((dimensions (specifier-dimensions arrayType)))
    (if (null? dimensions)
        (return NULL)
      (return (length dimensions)))))

(defun (array-type-dimensions (LIST OF INTEGER-WRAPPER))
    ((arrayType PARAMETRIC-TYPE-SPECIFIER))
  ;; Return the dimensions of the array specified by `arrayType'.
  ;; NOTE: We keep the `specifier-dimensions' type more general, in case
  ;;    we'll ever need it for things other than arrays - very unlikely.
  (return (cast (specifier-dimensions arrayType) (LIST OF INTEGER-WRAPPER))))

(defun (indefinite-array-type? BOOLEAN)
    ((arrayType PARAMETRIC-TYPE-SPECIFIER))
  ;; Return TRUE if one or more dimensions of `arrayType' are left unspecified.
  (let ((dimensions (specifier-dimensions arrayType)))
    (if (null? dimensions)
        (return TRUE)
      (foreach dim in dimensions
          where (null? dim)
          do (return TRUE)))
    (return FALSE)))
       
(defun (yield-anchored-type-specifier ANCHORED-TYPE-SPECIFIER)
       ((typeSpecTree CONS))
  ;; Called by 'CONS.yield-type-specifier'.
  (let ((typeSpec (new ANCHORED-TYPE-SPECIFIER))
        (likeArgument OBJECT (second typeSpecTree)))        
    (when (not (eq? likeArgument (quote SELF)))
      ;; 'likeArgument' has the form '(<slotName> self)':
      (setf (specifier-parameter-name typeSpec) 
            (permanentify (first (cast likeArgument CONS)))))
    (return typeSpec) ))

(defun incorporate-input-parameters ((method METHOD-SLOT) (parameters CONS))
  ;; Called by 'define-stella-method-slot'.
  (when (empty? parameters)
    (return))
  (let ((name SYMBOL NULL)
        (ts TYPE-SPEC NULL)
        (direction SYMBOL NULL)
        (variableArgs? FALSE))
    (setf (method-parameter-names method) (new LIST))
    (setf (method-parameter-type-specifiers method) (new LIST))
    (foreach p in parameters
             do
             (typecase p
               (CONS
                (case (length p)
                  (2 (setq direction (quote IN)))
                  ;; Handle directions for IDL methods:
                  (3 (cond ((or (eql? (first p) (quote IN))
                                (eql? (first p) (quote OUT))
                                (eql? (first p) (quote INOUT)))
                            (setq direction (first p))
                            ;; Create a directions list if we have at least
                            ;;    one explicitly specified direction:
                            (when (null-list?
                                   (method-parameter-directions method))
                              (setf (method-parameter-directions method)
                                (new LIST))
                              ;; Store implicit IN directions from previous
                              ;;    parameters:
                              (foreach par in parameters
                                       do
                                       (if (eql? par p)
                                           (break)
                                         (insert (method-parameter-directions
                                                  method)
                                                 (quote IN))))))
                           (otherwise
                            (walk-error
                             "Illegal direction for method parameter: " p)
                            (setq direction (quote IN))))
                     (setq p (rest p)))
                  (otherwise
                   (walk-error "Illegal method parameter: " p)
                   ;; skip parameter:
                   (continue)))
                (if variableArgs? ;; change the type of the &rest arg:
                    (let ((varArgType
                           (bquote (ARGUMENT-LIST OF & (second p)))))
                      (setq name (first p))
                      (setq ts (yield-type-specifier varArgType)))
                  (progn
                    (when (not (and (symbol? (first p))
                                    (or (symbol? (second p))
                                        (surrogate? (second p))
                                        (cons? (second p)))))
                      (walk-error "Illegal method parameter: " p)
                      ;; skip parameter:
                      (continue))
                    (setq name (first p))
                    (setq ts (yield-type-specifier (second p))))))
               (SYMBOL
                (cond ((eq? p (quote &rest))
                       (setf (method-variable-arguments? method) TRUE)
                       (setq variableArgs? TRUE)
                       (continue))
                      ((eq? p (quote &body))
                       (setf (method-body-argument? method) TRUE)
                       (continue))
                      (otherwise
                       (walk-error "Untyped parameter in parameter list: "
                                   parameters)
                       (setq name p)
                       (setq ts @UNKNOWN))))
               (otherwise
                (walk-error "Illegal parameter list: " parameters)
                (continue)))
             ;; Multiple collect clauses would be nice here:
             (insert (method-parameter-type-specifiers method) ts)
             ;; Should we use string wrappers instead of symbols here?
             (insert (method-parameter-names method) (permanentify name))
             ;; We had at least one explicitly directionalized parameter:
             (when (defined-list? (method-parameter-directions method))
               (insert (method-parameter-directions method) direction)))
    (reverse (method-parameter-names method))
    (reverse (method-parameter-type-specifiers method))
    (reverse (method-parameter-directions method))))

(defun incorporate-first-input-parameter ((method METHOD-SLOT))
  ;; Helping function for 'define-stella-method-slot'.
  ;; Incorporate type of first argument into '(slot-owner method)'.
  ;; Check for illegal first argument to a method slot.
  (let ((parameterTypeSpecs (method-parameter-type-specifiers method))
        (firstArgType (first parameterTypeSpecs)))
    (when (not (method-function? method))
      (cond
       ((empty? parameterTypeSpecs)
        (walk-error
         "Method has no input parameters, converting it into a function")
        (setf (method-function? method) TRUE)
        (return))
       ((and (defined? firstArgType)
             (not (type? firstArgType)))
        (walk-error
         "Illegal complex argument type for the first method parameter: "
         EOL "   " firstArgType)
        (when (anchored-type-specifier? firstArgType)
          (setf (first (method-parameter-type-specifiers method)) @UNKNOWN)
          (setq firstArgType @UNKNOWN)))))
    (setf (slot-owner method)
      (choose (defined? firstArgType)
              (type-spec-to-base-type firstArgType)
              NULL))))

(defun (define-stella-method-slot METHOD-SLOT)
       ((inputName SYMBOL) (returnTypes CONS) 
        (function? BOOLEAN) (inputParameters CONS)
        (options KEYWORD-KEY-VALUE-LIST))
  :documentation "Define a new Stella method object (a slot), and attach it
to the class identified by the first parameter in 'inputParameters'."
  (let ((newMethod (new METHOD-SLOT))
        ;; make name a permanent symbol:
        (name (permanentify inputName)))
    (setf (slot-name newMethod) name)
    ;; record method function?:
    (setf (method-function? newMethod) function?)
    ;; extract input parameters
    (incorporate-input-parameters newMethod inputParameters)
    ;; do extra processing on first parameter:
    (incorporate-first-input-parameter newMethod)
    ;; merge alternate definitions of return types:
    (when (empty? returnTypes)
      (cond
       ((defined? (lookup options :type))
        (setq returnTypes (cons (lookup options :type) NIL)))
       ((defined? (lookup options :return-types))
        (setq returnTypes (cons (lookup options :return-types) NIL)))))
    ;; extract first return type:
    (let ((typeSpec (choose (empty? returnTypes)
                            @VOID
                            (yield-type-specifier (first returnTypes)))))
      (if (type? typeSpec)
          (setf (slot-base-type newMethod) typeSpec)
        (setf (slot-type-specifier newMethod) typeSpec)))
    ;; store all return types:
    (unless (empty? returnTypes)
      (setf (method-return-type-specifiers newMethod) (new LIST)))
    (foreach ts in returnTypes
             collect (yield-type-specifier ts)
             into (method-return-type-specifiers newMethod))
    (foreach (key value) in options
             do
             (case (cast key KEYWORD)
               (:public?
                (setf (slot-public? newMethod)
                  (wrapper-value (cast value BOOLEAN-WRAPPER))))
               (:abstract?
                (setf (abstract? newMethod)
                  (wrapper-value (cast value BOOLEAN-WRAPPER))))
               (:native?
                (setf (method-native? newMethod)
                  (wrapper-value (cast value BOOLEAN-WRAPPER))))
	       (:constructor?
                (setf (method-constructor? newMethod)
                  (wrapper-value (cast value BOOLEAN-WRAPPER))))
               (:globally-inline?
                (setf (method-globally-inline? newMethod)
                  (wrapper-value (cast value BOOLEAN-WRAPPER))))
               (:inline
                (when (empty? (method-inlined-functions newMethod))
                  (setf (method-inlined-functions newMethod) (new LIST)))
                (typecase value
                  (CONS (foreach fnName in value
                                 do (insert
                                     (method-inlined-functions newMethod)
                                     fnName)))
                  (SYMBOL (insert
                           (method-inlined-functions newMethod) value))
                  (otherwise (warn "Illegal :inline argument: " value))))
               (:auxiliary?
                (setf (method-auxiliary? newMethod)
                  (wrapper-value (cast value BOOLEAN-WRAPPER))))
               (:documentation
                (setf (method-documentation newMethod)
                  (wrapper-value (cast value STRING-WRAPPER))))
               ((:type :returns)        ; handled already
                NULL)
               (:storage-slot
                (setf (method-storage-slot newMethod) 
                  (permanentify (cast value SYMBOL))))
               (:inherits-through
                (setf (method-inherits-through newMethod)
                  (permanentify (cast value SYMBOL))))
               (:properties
                (setf (properties newMethod) (cast value LIST)))
               (:meta-attributes
                (setf (meta-attributes newMethod) (cast value KEY-VALUE-LIST)))
               (:command?
                (setf (method-command? newMethod)
                  (wrapper-value (cast value BOOLEAN-WRAPPER))))
               (:lisp-macro?
                (setf (method-lisp-macro? newMethod)
                  (wrapper-value (cast value BOOLEAN-WRAPPER))))
               (:evaluate-arguments?
                (setf (method-evaluate-arguments? newMethod)
                  (wrapper-value (cast value BOOLEAN-WRAPPER))))
               (otherwise
                (unless (run-option-handler? newMethod key value)
                  (walk-warn "Skipping invalid method option " key EOL
                             "in the definition of method "
                             (slot-owner newMethod) "." name)))))
    (return newMethod)))

(defun (attach-method-slot-to-owner METHOD-SLOT) ((newMethod METHOD-SLOT))
  ;; Called by 'evaluate-defmethod-tree' and 'walk-defmethod-tree'.
  ;; Add 'newMethod' to the list of local slots on its owner.
  ;; Return NULL if the old method is a storage slot and hence can't
  ;;    be redefined.
  (when (method-function? newMethod)
    (return (attach-function newMethod)))
  ;; avoid breaking on bad input:
  (when (null? (surrogate-value (slot-owner newMethod)))
    (return newMethod))
  (when (not (undefine-conflicting-definitions? newMethod))
    (return NULL))
  (return (attach-slot-to-owner newMethod)) )

(defglobal *maximum-string-constant-size* INTEGER 4000
  :documentation "Maximum size for a string constant in the target language.")

(defun (yield-string-constant-tree OBJECT) ((string STRING))
  ;; Return a parse tree that evaluates to 'string'.
  ;; This is a kludge that tries to deal with the fact that some compilers
  ;;    arbitrarily restrict the maximum size for string constants.
  ;; If 'string' is longer than '*maximum-string-constant-size*', it will
  ;;    be cut up into bite-size chunks and constructed at run time via a
  ;;    possibly nested 'concatenate'.
  ;; TO DO: This kludge will hopefully go away once we don't store sources
  ;;    as strings anymore.  In the unlikely case that it doesn't go away,
  ;;    it should be optimized to avoid string copying as much as possible.
  (let ((length (length string))
        (chunks NIL)
        (start 0)
        (stringTree OBJECT NULL))
    (when (<= length *maximum-string-constant-size*)
      (return (wrap-literal string)))
    ;; Cut up the string and create a nested 'concatenate' to reconstruct it
    ;; (using a binary version of 'concatenate' creates wasteful intermediate
    ;; copies, but since this handles only rare cases anyway, we don't care):
    (while (< (+ start *maximum-string-constant-size*) length)
      (pushq chunks
             (wrap-literal
              (subsequence
               string start (+ start *maximum-string-constant-size*))))
      (setq start (+ start *maximum-string-constant-size*)))
    (when (< start length)
      (pushq chunks (wrap-literal (subsequence string start length))))
    (setq stringTree (first chunks))
    (foreach chunk in (rest chunks)
             do (setq stringTree
                  (bquote (concatenate & chunk & stringTree))))
    (return stringTree)))

(defun (yield-define-stella-method-object CONS)
    ((method METHOD-SLOT) (codeMethod METHOD-SLOT) (wrapperMethod METHOD-SLOT))
  ;; Yield a parse tree that defines a method object for `method' at startup time.
  ;; If `codeMethod' is non-NULL, the `function/method-code' slot of `method'
  ;;    will be initialized with `codeMethod's code (`codeMethod' is usually
  ;;    identical to `method').
  ;; If `wrapperMethod' is non-NULL, the `evaluator-wrapper-code' slot of `method'
  ;;    will be initialized with `wrapperMethod's code.
  (safety 2 (defined? (method-stringified-source method)))
  (let ((name (stringify (slot-name method))))
    (cond ((method-function? method)
           (return
             (bquote
              ;; This will define the method object lazily, i.e., the actual
              ;;    object generation will be deferred until its first lookup:
              (define-function-object
               & (choose (eql? name (symbol-name (slot-name method)))
                         name
                         ;; indicate to `define-function-object' that this is a
                         ;;    complex name that needs to be unstringified:
                         (concatenate " " name))
               & (yield-string-constant-tree (method-stringified-source method))
               & (choose (defined? codeMethod)
                         (bquote (the-code :function & (slot-name codeMethod)))
                         (quote NULL))
               & (choose (defined? wrapperMethod)
                         (bquote (the-code :function
                                           & (slot-name wrapperMethod)
                                           & wrapperMethod))
                         (quote NULL))))))
          (otherwise
           (return
             (bquote
              (define-method-object
               & (yield-string-constant-tree (method-stringified-source method))
               & (choose (defined? codeMethod)
                         (bquote (the-code :method
                                           & (slot-owner codeMethod)
                                           & (slot-name codeMethod)))
                         (quote NULL))
               ;; methods are not yet evaluable:
               NULL)))))))

  ;;
;;;;;; Method slot finalization
  ;;

;;; Finalization of a method slot applies some consistency checks,
;;;    computes type vectors, and may free up some type specifier records.

(defun (yield-class-parameter-types (CONS OF TYPE)) ((class CLASS))
  (let ((types NIL))
    (foreach pname in (parameters class)
             collect (slot-base-type (lookup-slot class pname)) into types)
    (return types) ))

(defun (optimistic-subtype-of? BOOLEAN) ((subType TYPE) (superType TYPE))
  ;; Compute a 'subtype-of' computation after verifying that both
  ;;    surrogates have non-null values.
  ;; Return TRUE otherwise.
  (if (and (defined? (type-class subType))
	   (defined? (type-class superType))
	   (class-finalized? (type-class subType)))
    (return (subtype-of? subType superType))
    (return TRUE)) )

(defun warn-of-parameter-mismatch
       ((self PARAMETRIC-TYPE-SPECIFIER) (message STRING))
  (let ((inheritedTypes 
         (yield-class-parameter-types (type-class (specifier-base-type self)))))
; (print "BREAKING TO SEE IF WE ARE INSIDE THE WALKER OR OUTSIDE" EOL)
; (print "IF INSIDE, CALL 'walk-inform' INSTEAD:" EOL)
; (CL:break)
    (special ((*printReadably?* TRUE))
             (warn message EOL
                   "Type " (specifier-base-type self) 
                   " takes parameters of type " EOL
                   inheritedTypes
                   " but was modified by a list of types "
                   (the-cons-list (specifier-parameter-types self))))))

(defun (validate-type-specifier TYPE) 
       ((self TYPE-SPEC) (anchorClass CLASS) (skipAnchoredType? BOOLEAN))
  ;; Check validity of parametric type spec 'self' and return its base type.
  (typecase self
    (PARAMETRIC-TYPE-SPECIFIER
     (when (null? (type-class (specifier-base-type self)))
       ;; quick exit if the class for the base type is not yet defined:
       (return @UNKNOWN))
     (let ((parameterDifferential
            (- (length (specifier-parameter-types self))
               (length (parameters (type-class (specifier-base-type self)))))))
       (cond
        ((> parameterDifferential 0)
         (warn-of-parameter-mismatch 
          self "Too many parameters in type specification."))
        ((< parameterDifferential 0)
         (warn-of-parameter-mismatch
          self "Not enough parameters in type specification."))
        (otherwise
         (let ((baseClass (type-class (type-spec-to-base-type self))))
           (when (class-slots-finalized? baseClass)
             (let ((inheritedTypes (yield-class-parameter-types baseClass)))
               (foreach
                superType in inheritedTypes
                as subTypeSpec in (specifier-parameter-types self)
                ;; avoid trying to figure out anchored type test:
                where (and (not (anchored-type-specifier? subTypeSpec))
                           ;; This makes things like (ARGUMENT-LIST OF STRING)
                           ;;    legal; should we be more restrictive here?
                           (not (eql? superType @UNKNOWN))
                           (not (optimistic-subtype-of?
                                 (type-spec-to-base-type subTypeSpec)
                                 superType)))
                do
                (warn-of-parameter-mismatch
                 self "Parametric subtype(s) don't specialize supertype(s)")))))))
       (return (specifier-base-type self))))
    (ANCHORED-TYPE-SPECIFIER
     (when skipAnchoredType?
       (return NULL))
     (when (null? anchorClass)
       ;; handle problem passed on by 'finalize-slot-type-computations':
       (warn "Illegal use of anchored type for function that has no first
argument (and hence nothing to anchor onto).")
       (return NULL))
     (let ((slotName (specifier-parameter-name self))
           (anchorSlot SLOT NULL))
       (when (null? slotName)           ; anchored to 'self'
         (return (class-type anchorClass)))
       (unless (setq? anchorSlot (lookup-slot anchorClass slotName))
         (continuable-error
          "Can't find a slot named " slotName " on the class "
          (class-name anchorClass)))
       (return (slot-base-type anchorSlot))))
    (TYPE
     (return self))
    (otherwise
     (error "validate-type-specifier: Not defined on " self))))

;;; The :inherits-through option specifies that a method computes
;;;    a return value as follows:
;;;    (1) When the storage slot has a non-null value, return it.
;;;    (2) Otherwise, recursively follow the inherits-through slot
;;;        looking for a non-null storage slot value.
;;;    (3) Otherwise, return the default value for the storage slot.
;;; If :inherits-through specifies a collection-valued slot, 
;;;    inheritance runs up the first (left-most) link.
;;;    Conceptually, this results in a semi-non-deterministic
;;;    inheritance scheme.  A BETTER, but SLOWER scheme would
;;;    compute the most-specific inherited storage slot value.

(defun (synthesize-method-body CONS) ((method METHOD-SLOT))
  ;; Generate parse tree code that realizes the :inherits-through
  ;;    option specified for 'method'.
  ;; Mild bug: Assumes that the first parameter is named 'self'.
  (when (null? (type-class @BOOLEAN))      ; bootstrap kludge
    (return NIL))
  (let ((storageSlotName (method-storage-slot method))
        (inheritanceSlotName (method-inherits-through method))
        (storageSlot STORAGE-SLOT NULL)
        (inheritanceSlot SLOT NULL)
        (defaultValue OBJECT NULL))
    (case inheritanceSlotName ;; convert artificial links to real links:
      (super-classes
       (setq inheritanceSlotName (quote class-all-super-classes)))
      (equivalent-slot
       (setq inheritanceSlotName (quote slot-direct-equivalent)))
      (otherwise NULL))
    (setq storageSlot (safe-lookup-slot 
                (type-class (slot-owner method)) storageSlotName))
    (when (null? storageSlot)
      (warn ":storage-slot references non-existent slot "
            storageSlotName " on the class " (slot-owner method))
      (return NIL))
    (setq inheritanceSlot (safe-lookup-slot 
                (type-class (slot-owner method)) inheritanceSlotName))
    (when (null? inheritanceSlot)
      (warn ":inherits-through references non-existent slot "
            inheritanceSlotName " on the class " (slot-owner method))
      (return NIL))
    (setq defaultValue (system-default-value storageSlot))
    (return
     (bquote
      ((let ((cursor self)
             ;; tricky: using 'slot-value' avoids retrieving default value:
             (value (slot-value cursor & storageSlotName)))
         (loop
           (when && (choose (subtype-of? (type storageSlot) @BOOLEAN)
                            (bquote (value))
                            (bquote ((defined? value))))
             (return value))
           (setq cursor 
                 & (choose (or (subtype-of? (type inheritanceSlot) @COLLECTION)
                               (subtype-of? (type inheritanceSlot) @CONS))
                     (bquote (first (& inheritanceSlotName cursor)))
                     (bquote (& inheritanceSlotName cursor))))
           (if (defined? cursor)
             (setq value (slot-value cursor & storageSlotName)) ;; continue loop
             (return & (choose (defined? defaultValue)
                               defaultValue
                               (quote NULL)))))))))))

(defmethod finalize-slot-type-computations ((self METHOD-SLOT))
  ;; Helping function for 'METHOD-SLOT.help-finalize-local-slot' and 'attach-function'.
  ;; Finish type computations that are common to both methods and functions.
  (let ((ownerClass (only-if (defined? (slot-owner self))
                      (type-class (slot-owner self)))))
    (foreach ts in (method-parameter-type-specifiers self)
             do (validate-type-specifier ts ownerClass FALSE))
    ;; finish computation of 'slot-base-type':
    (when (defined? (slot-type-specifier self))
      (setf (slot-base-type self)
            (validate-type-specifier 
             (slot-type-specifier self) ownerClass FALSE)))
    ;; validate type-specifiers for the remaining return values:
    (foreach ts in (rest (method-return-type-specifiers self))
             do (validate-type-specifier ts ownerClass FALSE)) ))

(defmethod help-finalize-local-slot ((self METHOD-SLOT))
  ;; Called by 'finalize-class-and-subclasses' and 'attach-slot-to-owner'.
  ;; Do finalization stuff specific to method and function slots.
  ;; NOTE: Doesn't do anything anymore, since method synthesization
  ;;       is now only done in the walker (which avoids regenerating the
  ;;       same definition over and over again due to slot refinalizations).
  NULL)

(defmethod unfinalize-local-slot ((self METHOD-SLOT))
  ;; NOTE: see above
  NULL)

(defun undefine-external-slots ((name SYMBOL))
  ;; Undefine all external slots with name `name'.
  (let ((slots NIL))
    (foreach module in (all-modules)
        do (foreach slot in (all-slots module TRUE)
               where (and (eql? (slot-name slot) name)
                          (slot-external? slot))
               collect slot into slots))
    ;; Defer destruction, since surgery on local-slots lists
    ;;    interferes with the `all-slots' iterator.
    (foreach slot in slots
        do (destroy-external-slot slot))))

(defun destroy-external-slot ((self SLOT))
  ;; Remove the external slot `self' from all indices and destroy it.
  (unless (or (deleted? self)
              (bad? self)
              (not (slot-external? self)))
    (let ((ownerClass (type-class (slot-owner self))))
      (when (defined? ownerClass)
        (remove (class-local-slots ownerClass) self)
        (unfinalize-class-slots ownerClass)
        (setf (deleted? self) TRUE)))))

(defun destroy-method ((self METHOD-SLOT))
  ;; Remove method `self' from all indices and destroy it.
  (destroy-external-slot self))

  ;;
;;;;;; Method computed slots used by the walker:
  ;;

(defmethod (method-argument-count INTEGER) ((self SLOT))
  (error "method-argument-count: Not defined on " self)
  ; (return NULL)
  )

(defmethod (method-argument-count INTEGER) ((self STORAGE-SLOT))
  (return 1) )

(defmethod (method-argument-count INTEGER) ((self METHOD-SLOT))
  (return (length (method-parameter-names self))) )

(defmethod (method-argument-count INTEGER) ((self TABLE))
  ;; Called by 'create-description-for-relation' to avoid
  ;;    dealing with methods that return multiple values.
  ;; For TABLEs, this is a rather awful kludge.
  (return (1- (length (tuple-domains self)))) )

(defmethod (method-variable-arguments? BOOLEAN) ((self STORAGE-SLOT))
  (return FALSE) )

(defmethod (method-body-argument? BOOLEAN) ((self STORAGE-SLOT))
  (return FALSE) )

(defmethod (arity INTEGER) ((self STORAGE-SLOT))
  :public? TRUE
  (return 2))

(defmethod (arity INTEGER) ((self METHOD-SLOT))
  :public? TRUE
  (when (method-variable-arguments? self)
    (return NULL))
  (let ((returnTypeCount (length (method-return-type-specifiers self)))
        (result (+ (length (method-parameter-type-specifiers self))
                   returnTypeCount)))
    (case returnTypeCount
      (1 (if (eql? (first (method-return-type-specifiers self)) @BOOLEAN)
           (return (1- result))
           (return result)))
      (0 (return result))
      (otherwise
       (if (eql? (last (method-return-type-specifiers self)) @BOOLEAN)
           (return (1- result))
           (return result)))) ))

(defmethod (arity INTEGER) ((self TABLE))
  :public? TRUE
  (if (variable-arity-table? self)
    (return NULL)
    (return (length (tuple-domains self)))) )


  ;;
;;;;;; Type inference routines used by the walker
  ;;

;;; Note: The walker should never pass an anchored type specifier as an
;;;    argument to 'type-spec-to-base-type':

(defun (type-spec-to-base-type TYPE) ((self TYPE-SPEC))
  :public? TRUE
  (typecase self
    (TYPE
     (return self))
    (PARAMETRIC-TYPE-SPECIFIER
     (return (specifier-base-type self)))
    (otherwise
     (error "type-spec-to-base-type: Not defined on " self))))

(defun (base-type-to-type-spec TYPE-SPEC) ((self TYPE-SPEC))
  ;; Inverse to `type-spec-to-base-type', in particular, if `self' is a
  ;;    simple type and its class is parameterized, return a parametric
  ;;    type specifier with the default parameter types unless any of
  ;;    them are unknown.
  (typecase self
    (TYPE
     (let ((class (type-class self))
           (parameters (parameters class))
           (parameterType TYPE-SPEC NULL)
           (parameterTypes LIST NULL))
       (when (non-empty? parameters)
         (setq parameterTypes (new LIST))
         (foreach parameter in parameters
             do (setq parameterType
                  (compute-return-type-spec (lookup-slot class parameter) self))
                (when (unknown-type? parameterType)
                  (return self))
             collect parameterType into parameterTypes)
         (return
           (new PARAMETRIC-TYPE-SPECIFIER
                :specifier-base-type self
                :specifier-parameter-types parameterTypes)))
       (return self)))
    (PARAMETRIC-TYPE-SPECIFIER
     (return self))
    (otherwise
     (error "base-type-to-type-spec: Not defined on " self))))

(defun (type-spec-to-class CLASS) ((self TYPE-SPEC))
  :public? TRUE
  (return (type-class (type-spec-to-base-type self))))

(defun (compatible-parameter-types? BOOLEAN)
    ((subType TYPE-SPEC) (superType TYPE-SPEC))
  :public? TRUE
  ;; Return TRUE if the parameter types of 'subType' and 'superType'
  ;;    are compatible.
  ;; NOTE: Right now we have a shortcut where a simple type is assumed to
  ;;    have unspecified parameters that are compatible with everything.
  ;;    E.g., this makes CONS compatible with (CONS OF SLOT), even though
  ;;    CONS really is (CONS OF OBJECT), which in turn might conceal type
  ;;    problems that will only surface at runtime. However, if we disable
  ;;    the shortcut, empty collections might signal type errors when they
  ;;    shouldn't, e.g.,  NIL would become incompatible with (CONS OF SLOT).
  (when (or (type? subType) (type? superType))
    ;; TO DO: Remove this shortcut once we figure out the correct strategy.
    (return TRUE))
  (let ((subClass CLASS NULL)
        (superClass CLASS NULL))
    (typecase subType
      (TYPE
       (setq subClass (type-class subType)))
      (PARAMETRIC-TYPE-SPECIFIER
       (setq subClass (type-class (specifier-base-type subType)))))
    (typecase superType
      (TYPE
       (setq superClass (type-class superType)))
      (PARAMETRIC-TYPE-SPECIFIER
       (setq superClass (type-class (specifier-base-type superType)))))
    ;; Check that for each parameter in 'superClass' there is a parameter
    ;; in 'subClass' with a matching name and equal or narrower type.
    ;; 'subClass' can have extra parameters that do not exist in 'superClass'.
    (foreach
        supPar in (parameters superClass)
        do (unless (exists subPar in (parameters subClass)
                       where (eq? supPar subPar))
             (return FALSE))
           (let ((subParType (extract-parameter-type subType supPar))
                 (supParType (extract-parameter-type superType supPar)))
             (when (eql? subParType supParType)
               (continue))
             ;; Check whether parameter types are defined; recursive calls
             ;;    will check more deeply nested parameters:
             (when (and (not (anchored-type-specifier? subParType))
                        (null? (type-class (type-spec-to-base-type subParType))))
               (walk-error "Parameter type " (type-spec-to-base-type subParType)
                           " of " subType " is not yet defined")
               (return FALSE))
             (when (and (not (anchored-type-specifier? supParType))
                        (null? (type-class (type-spec-to-base-type supParType))))
               (walk-error "Parameter type " (type-spec-to-base-type supParType)
                           " of " superType " is not yet defined")
               (return FALSE))
             (unless (sub-type-spec-of? subParType supParType)
               (return FALSE))))
    (return TRUE)))

(defun (sub-type-spec-of? BOOLEAN) ((subType TYPE-SPEC) (superType TYPE-SPEC))
  (when (eql? subType superType)
    (return TRUE))
  (typecase subType
    (TYPE
     (typecase superType
       (TYPE
        (return (and (subtype-of? subType superType)
                     (compatible-parameter-types? subType superType))))
       (PARAMETRIC-TYPE-SPECIFIER
        (return (and (subtype-of? subType (specifier-base-type superType))
                     (compatible-parameter-types? subType superType))))
       (otherwise
        (return FALSE))))
    (PARAMETRIC-TYPE-SPECIFIER
     (typecase superType
       (TYPE
        (return (and (subtype-of? (specifier-base-type subType) superType)
                     (compatible-parameter-types? subType superType))))
       ;; 'superType' must be a parametric type spec:
       (PARAMETRIC-TYPE-SPECIFIER
        (return (and (subtype-of? (specifier-base-type subType)
                                  (specifier-base-type superType))
                     (compatible-parameter-types? subType superType))))
       (otherwise
        (return FALSE))))
    
    (ANCHORED-TYPE-SPECIFIER
     (return (and (anchored-type-specifier? superType)
                  (eq? (specifier-parameter-name subType)
                       (specifier-parameter-name
                        (cast superType ANCHORED-TYPE-SPECIFIER))))))
    (otherwise
     (error "sub-type-spec-of?: Not defined on " subType))))
    
(defun (void? BOOLEAN) ((type TYPE-SPEC))
  :public? TRUE
  (return (eq? type @VOID)) )

(defun (extract-parameter-type TYPE-SPEC BOOLEAN)
    ((self TYPE-SPEC) (parameter SYMBOL))
  :public? TRUE
  ;; Return the type corresponding to the parameter named 'parameter'
  ;;    on the parametric type 'self'.
  ;; The second return value is TRUE if 'parameter' actually existed on
  ;;    'self', or FALSE if the default value @OBJECT was used.
  (typecase self
    (TYPE
     (let ((slot (lookup-slot (type-class self) parameter)))
       (if (defined? slot)
           (return (type slot) TRUE)
         (return @OBJECT FALSE))))
    (PARAMETRIC-TYPE-SPECIFIER
     (foreach pName in (parameters (type-class (specifier-base-type self)))
              as pType in (specifier-parameter-types self)
              where (eq? pName parameter)
              do (return pType TRUE))
     (return @OBJECT FALSE))
    (otherwise
     (error "extract-parameter-type: Not defined on " self))))

(defun (compute-anchored-type-spec TYPE-SPEC)
    ((ownerType TYPE-SPEC) (relType ANCHORED-TYPE-SPECIFIER))
  ;; Called by 'compute-relative-type-spec'.
  ;; Return the type of the anchored type specifier 'relType' relative
  ;;    to 'ownerType'.
  (typecase ownerType
    (TYPE
     (when (null? (specifier-parameter-name relType)) ; LIKE 'SELF'
       (return ownerType))
     (let ((slot (lookup-slot 
                  (type-class ownerType) (specifier-parameter-name relType))))
       (when (null? slot)
         (walk-error "Missing :parameter named " (specifier-parameter-name relType) EOL
               "   for the class " ownerType EOL)
         (return @OBJECT))
       (return (slot-base-type slot))))
    (PARAMETRIC-TYPE-SPECIFIER
     (when (null? (specifier-parameter-name relType)) ; LIKE 'SELF'
       (return ownerType))
     (foreach pName in (parameters
                        (type-class (specifier-base-type ownerType)))
              as pType in (specifier-parameter-types ownerType)
              where (eq? pName (specifier-parameter-name relType))
              do (return pType))        ; LIKE <pName>
     ;; otherwise, LIKE non-parametric slot:
     (return (compute-anchored-type-spec
              (specifier-base-type ownerType) relType)))
    (otherwise
     (error "compute-anchored-type-spec: Not defined on " ownerType))))

(defun (compute-relative-type-spec TYPE-SPEC)
       ((relativeType TYPE-SPEC) (ownerType TYPE-SPEC))
  ;; Return the type of 'relativeType' relative to 'ownerType'.
  ;; This is the same as 'relativeType' unless one or more of the
  ;;   parameters contains an anchored type.
  (typecase relativeType
    (PARAMETRIC-TYPE-SPECIFIER
     (when (forall ts in (specifier-parameter-types relativeType)
                   always (type? ts))
       (return relativeType))
     (let ((typesList (new LIST))
           (relativeTS TYPE-SPEC NULL)
           (foundRelativisticType? FALSE))
       (foreach ts in (specifier-parameter-types relativeType)
                do
                (setq relativeTS (compute-relative-type-spec ts ownerType))
                (when (not (eq? relativeTS ts))
                  (setq foundRelativisticType? TRUE))
                collect relativeTS
                into typesList)
       (if foundRelativisticType?
         ;; create new parametric type structure:
         (let ((newTS (new PARAMETRIC-TYPE-SPECIFIER)))
           (setf (specifier-base-type newTS)
                 (specifier-base-type relativeType))
           (setf (specifier-parameter-types newTS) typesList)
           (return newTS))
         (progn
           (free typesList)
           (return relativeType)))))
    (ANCHORED-TYPE-SPECIFIER
     (return (compute-anchored-type-spec ownerType relativeType)))
    (TYPE
     (return relativeType))
    (otherwise
     (error "compute-relative-type-spec: Not defined on " relativeType))))

(defmethod (compute-return-type-spec TYPE-SPEC)
           ((self SLOT) (firstArgType TYPE-SPEC))
  (ignore firstArgType)
  (error "compute-return-type-spec: Not defined on " self)
  ; (return NULL)
  )
  
(defmethod (compute-return-type-spec TYPE-SPEC)
           ((self METHOD-SLOT) (firstArgType TYPE-SPEC))
  ;; Return a type spec returned by the method 'self' when passed a
  ;;    first argument of type 'firstArgType'.
  ;; BUG: DOESN'T WORK FOR MULTIPLE RETURN VALUES.
  (if (null? (slot-type-specifier self))
    (return (slot-base-type self))
    (return 
     (compute-relative-type-spec (slot-type-specifier self) firstArgType))) )

(defmethod (compute-return-type-spec TYPE-SPEC)
           ((self STORAGE-SLOT) (firstArgType TYPE-SPEC))
  ;; Return a type spec returned by the storage slot 'self' when passed a
  ;;    first argument of type 'firstArgType'.
  (if (null? (slot-type-specifier self))
    (return (type self))
    (return 
     (compute-relative-type-spec (slot-type-specifier self) firstArgType))) )


  ;;
;;;;;; Describing type specs
  ;;

(defun (yield-type-spec-tree OBJECT) ((self TYPE-SPEC))
  ;; Return a type expression that parses into 'self'.
  (typecase self
    (TYPE
     ;; In this case, 'self' is converted to a symbol, since that is how
     ;;    base types appear in type expressions.
     (return (type-to-symbol self)))
    (PARAMETRIC-TYPE-SPECIFIER
     (let ((listOfTypes NIL))
       (foreach ts in (specifier-parameter-types self)
                collect (yield-type-spec-tree ts) into listOfTypes)
       (return
         (bquote (& (type-to-symbol (specifier-base-type self))
                    && (choose (array-type-specifier? self)
                               (bquote
                                (SIZE & (yield-array-dimensions-tree self)))
                               NIL)
                    OF
                    && listOfTypes)))))
    (ANCHORED-TYPE-SPECIFIER
     (if (defined? (specifier-parameter-name self))
         (return (bquote (LIKE (& (specifier-parameter-name self) SELF))))
       (return (bquote (LIKE SELF)))))
    (otherwise
     (error "validate-type-specifier: Not defined on " self))))


  ;;
;;;;;; Functions
  ;;

;; We use `STANDARD-OBJECT' as the value type to accommodate function
;;    objects as well as stubs:
(defglobal *function-lookup-table* (HASH-TABLE OF SYMBOL STANDARD-OBJECT)
  (new (HASH-TABLE OF SYMBOL FUNCTION))
  :documentation "Lookup table for functions.")

(defun (attach-function METHOD-SLOT) ((newFunction METHOD-SLOT))
  ;; Called by 'attach-method-slot-to-owner'.
  ;; Add 'newFunction' to the *function-lookup-table* and finalize it.
  ;;    If an old function exists with the same name and matching
  ;;    input types, remove it.
  ;; TO DO:  ADD CHECK THAT FUNCTION *SHADOWS* OLD DEFINITION.
  (let ((name (slot-name newFunction))
        (oldFunction (lookup-function name)))
    (when (not (undefine-conflicting-definitions? newFunction))
      (return NULL))
    (insert-at *function-lookup-table* name newFunction)
    (unregister-slot-name newFunction)
    ;; set this for functions also so `home-module' will do the right thing:
    (setf (slot-external? newFunction) TRUE)
    (finalize-slot-type-computations newFunction)
    (when (defined? oldFunction)
      (run-hooks *redefine-relation-hooks* (list oldFunction newFunction))
      (free oldFunction))
    (return newFunction)) )

(defun (lookup-function FUNCTION) ((functionSymbol SYMBOL))
  :documentation "Return the function defined for 'functionSymbol', if it exists."
  :public? TRUE
  (setq functionSymbol (soft-permanentify functionSymbol))
  (let ((function (lookup *function-lookup-table* functionSymbol)))
    (when (and (defined? function)
               (eql? (primary-type function) @VECTOR))
      ;; We have a stub definition generated by `define-function-object'.
      ;;    Parse the stub and replace it with the actual object:
      (let ((record VECTOR function)
            (definition STRING (first record))
            (oldFunction METHOD-SLOT (second record))
            (moduleName STRING (third record))
            (code FUNCTION-CODE
                  (choose (defined? (fourth record))
                          (fourth record)
                          NULL))
            (wrapperCode FUNCTION-CODE
                         (choose (>= (length record) 5)
                                 (fifth record)
                                 NULL)))
        ;; avoid infinite recursion by pointing to a non-stub
        ;;    (possibly NULL) function object now:
        (insert-at *function-lookup-table* functionSymbol oldFunction)
        (within-module (get-stella-module moduleName TRUE)
          ;; if we had an old definition, this will properly handle redefinition:
          (setq function
            (define-method-from-stringified-source
                (symbol-name functionSymbol) NULL definition)))
        (when (defined? function)
          (when (defined? code)
            (setf (function-code (cast function METHOD-SLOT)) code))
          (when (defined? wrapperCode)
            (setf (evaluator-wrapper-code (cast function METHOD-SLOT))
              wrapperCode)))))
    (return function)))

(defun (lookup-function-by-name FUNCTION) ((name STRING))
  :documentation
  "Return a function with name 'name' visible from the current module.
Scan all visible symbols looking for one that has a function defined for it."
  :public? TRUE
  (let ((function FUNCTION NULL)
        (symbol SYMBOL NULL))
    (foreach module in (visible-modules *module*)
        do (when (and (setq? symbol (lookup-symbol-in-module name module TRUE))
                      (setq? function (lookup-function symbol)))
             (return function)))
    (return NULL)))

(defun (lookup-function-or-stella-function FUNCTION) ((functionSymbol SYMBOL))
  ;; OBSOLETE! NOT SURE WHY THIS WAS EVER NEEDED.
  :globally-inline? TRUE
  (return (lookup-function functionSymbol)))

(defun (lookup-function-home-module MODULE) ((functionSymbol SYMBOL))
  ;; Compute the home module of the function named by `functionSymbol'
  ;;    but without expanding stubs (needed by `all-functions' to avoid
  ;;    expanding all stubs in the universe).
  (setq functionSymbol (soft-permanentify functionSymbol))
  (let ((function (lookup *function-lookup-table* functionSymbol)))
    (when (null? function)
      (return NULL))
    (case (primary-type function)
      (@VECTOR
       ;; We have a stub definition generated by `define-function-object':
       (return (get-stella-module (third (cast function VECTOR)) TRUE)))
      (@METHOD-SLOT
       (return (home-module function)))
      (otherwise
       (return NULL)))))

(defun undefine-function ((name SYMBOL))
  ;; If `name' had a function definition, remove it.
  (let ((function (lookup-function name)))
    (when (defined? function)
      (destroy-function function))))

(defun destroy-function ((function METHOD-SLOT))
  ;; Remove 'function' from all indices and destroy it.
  (let ((functionName (slot-name function))
        (slotRef (slot-slotRef function))
        (realFunction (lookup-function functionName)))
    (when (eql? function realFunction)
      (remove-at *function-lookup-table* functionName))
    (when (and (defined? slotRef)
               (eql? function (slotRef-slot slotRef)))
      (setf (slotRef-slot slotRef) NULL))
    (setf (deleted? function) TRUE)
    (free function)))

(defun (undefine-conflicting-definitions? BOOLEAN) ((newSlot METHOD-SLOT))
  ;; Undefine any preexisting function/methods/macro whose definition
  ;;    conflicts with the about-to-be-defined `newSlot'.
  ;; Return TRUE if undefinition was successful (or unnecessary).
  ;; TO DO: WHAT ABOUT CONFLICTING STORAGE SLOTS?
  (cond ((method-function? newSlot)
         (when (warn-about-function-shadowing-slots? newSlot)
           (unless (y-or-n?
                    "Do you want to remove the conflicting method definitions? ")
             (return FALSE))
           (undefine-external-slots (slot-name newSlot))
           (unregister-slot-name newSlot))
         (cond ((defined? (lookup-macro (slot-name newSlot)))
                ;; old definition is a macro:
                (if (not (method-macro? newSlot))
                    (walk-warn
                     "Function " newSlot
                     " redefines an exisiting macro of the same name")
                  ;; KLUDGE: we had a macro redefinition, try to re-use the old
                  ;;    expander function to catch cases where somebody only
                  ;;    changed the macro's docstring, etc.  If the macro was
                  ;;    completely redefined, a complete incremental eval
                  ;;    in Lisp will assign the new expansion function:
                  (unless (defined? (function-code newSlot))
                    (setf (function-code newSlot)
                      (function-code (lookup-macro (slot-name newSlot)))))))
               ((defined? (lookup-function (slot-name newSlot)))
                ;; Old definition is a function:
                (when (method-macro? newSlot)
                  (walk-warn
                   "Macro " newSlot
                   " redefines an exisiting function of the same name")))))
        (otherwise
         (when (warn-about-slot-shadowed-by-a-function? newSlot)
           (inform " Removing the preexisting function definition.")
           (undefine-function (slot-name newSlot)))))
  (return TRUE))

(defun define-function-object ((name STRING) (definition STRING)
                               (code FUNCTION-CODE) (wrapperCode FUNCTION-CODE))
  ;; Define a STELLA function object for the function defined in the
  ;;    `definition' string, and assign `code' and `wrapperCode' to the
  ;;    appropriate code slots of the generated objects.
  ;; This defines the function object lazily (in concert with `lookup-function')
  ;;    to defer parsing of `definition' and function object generation to the
  ;;    point where the object is actually needed.
  ;; To allow insertion of a stub into the function lookup table without having
  ;;    to parse `definition', we pass the `name' of the function in a separate
  ;;    argument.
  (let ((nameSymbol
         (choose (eql? (nth name 0) #\space)
                 ;; `yield-define-stella-method-object' tells us that we
                 ;;     have a complex name, use the reader to parse it:
                 (read-s-expression-from-string name)
                 ;; otherwise, intern it directly:
                 (intern-symbol-in-module name NULL FALSE)))
        (oldFunction (lookup *function-lookup-table* nameSymbol))
        (record (new VECTOR :array-size (choose (defined? wrapperCode) 5 4))))
    (when (and (defined? oldFunction)
               (eql? (primary-type oldFunction) @VECTOR))
      (setq oldFunction NULL))
    (setf (first record) definition)
    (setf (second record) oldFunction)
    ;; we have to store module information, since the stub
    ;;    might get expanded while we are in a different module:
    (setf (third record) (module-full-name *module*))
    (when (defined? code)
      (setf (fourth record) code))
    (when (defined? wrapperCode)
      (setf (fifth record) wrapperCode))
    (insert-at *function-lookup-table* nameSymbol record)))

  ;;
;;;;;; Global variables
  ;;

(defglobal *global-variable-lookup-table*
    (HASH-TABLE OF SYMBOL GLOBAL-VARIABLE)
  (new (HASH-TABLE OF SYMBOL GLOBAL-VARIABLE))
  :documentation "Lookup table for global variables." :public? TRUE)

(defun (intern-global-variable GLOBAL-VARIABLE) ((global GLOBAL-VARIABLE))
  ;; Find or create a table entry for the global variable 'global', and
  ;;    point it at 'global'.
  ;; Return an identical global variable if one already exists.
  (let ((name (variable-name global))
        (oldGlobal (lookup-global-variable name)))
    (when (defined? oldGlobal)
      (cond
       ((string-eql? (variable-stringified-source global)
                     (variable-stringified-source oldGlobal))
        ;; old global is identical, and has been 'finalized':
        (free global)
        (return oldGlobal))
       (otherwise
        (inform "Redefining the global variable " (variable-name global))
        (free oldGlobal))))     ; discard old version of same global variable
    (insert-at *global-variable-lookup-table* name global)
    (return global) ))

(defmethod (lookup-global-variable GLOBAL-VARIABLE) ((self GENERALIZED-SYMBOL))
  :public? TRUE
  :documentation "Return a global variable with name 'self'."
  (return (lookup *global-variable-lookup-table* self)))

(defmethod (lookup-global-variable GLOBAL-VARIABLE) ((self SURROGATE))
  :public? TRUE
  :documentation "Return a global variable with name 'self'."
  (let ((symbol SYMBOL
                (lookup-rigid-symbol-wrt-module
                 (symbol-name self) (interned-in self) SYMBOL-SYM)))
    (if (defined? symbol)
      (return (lookup-global-variable symbol))
      (return NULL))))

(defmethod (lookup-global-variable GLOBAL-VARIABLE) ((self STRING))
  :public? TRUE
  :documentation "Return a global variable with name 'self'."
  (let ((symbol (lookup-symbol self)))
    (if (defined? symbol)
      (return (lookup-global-variable symbol))
      (return NULL))))

(defun (global-variable-type-spec TYPE-SPEC) ((global GLOBAL-VARIABLE))
  :documentation "Return the type spec for the global variable `global'."
  :public? TRUE
  (let ((type (variable-type-specifier global)))
    (if (defined? type)
        (return type)
      (return (variable-type global)))))

(defun (lookup-global-variable-type TYPE-SPEC) ((name SYMBOL))
  :public? TRUE
  ;; Return the type spec for the global variable or constant with name
  ;;    'name', or NULL if no global exists with that name.
  (let ((global (lookup-global-variable name)))
    (if (defined? global)
        (return (global-variable-type-spec global))
      (return NULL))))

(defun (define-stella-global-variable-from-parse-tree GLOBAL-VARIABLE OBJECT)
       ((tree CONS) (stringifiedSource STRING))
  ;; Return a global variable object filled in from 'tree'.
  ;; As a second value, the extracted initial value tree is returned
  ;;    (extracting the initial value tree requires some parsing, since
  ;;    specials are not required to have one, though they could have
  ;;    other definition options such as :documentation).
  (let ((typeTree (third tree))
        (initialValueTree (fourth tree))
        (optionsTree (nth-rest tree 4))
        (special? (eq? (first tree) (quote DEFSPECIAL)))
        (constant? (eq? (first tree) (quote DEFCONSTANT)))
        (noInitialValue? FALSE)  ;; NULL is a legal initial value
        (global GLOBAL-VARIABLE (new GLOBAL-VARIABLE))
        (internedGlobal GLOBAL-VARIABLE NULL))
    (when (or (<= (length tree) 3)
              (and (member? (quote (:documentation :public? :auxiliary?))
                            initialValueTree)
                   (odd? (length optionsTree))))
      (setq noInitialValue? TRUE)
      (setq initialValueTree (choose special? :UNBOUND-SPECIAL-VARIABLE NULL))
      (setq optionsTree (nth-rest tree 3)))
    (setf (variable-name global) (permanentify (second tree)))
    (setf (variable-stringified-source global) stringifiedSource)
    (setq internedGlobal (intern-global-variable global))
    (record-variable-home-module internedGlobal)
    (when (and noInitialValue?
               (not special?))
      (if constant?
          (walk-error "Missing value in constant declaration")
        (walk-error "Missing initial value in variable declaration"))
      (return internedGlobal initialValueTree))
    (when (not (eq? global internedGlobal))
      ;; quick exit if an identical global variable or conflicting object already
      ;;    exists.  Tricky, this quick exit preserves the 'get-variable-code' and
      ;;    'set-variable-code' computations performed on an identical version.
      (return internedGlobal initialValueTree))
    (setq typeTree (yield-type-specifier typeTree))
    (validate-type-specifier typeTree NULL TRUE)
    (if (type? typeTree)
      (setf (variable-type global) typeTree)
      (progn
        (setf (variable-type-specifier global) typeTree)
        (setf (variable-type global) (type-spec-to-base-type typeTree))))
    (setf (variable-special? global) special?)
    (setf (variable-constant? global) constant?)
    (when (non-empty? optionsTree)
      (let ((options (allocate PROPERTY-LIST)))
        (setf (the-plist options) optionsTree)
        (foreach
          (key value) in options
          do
          (case (cast key KEYWORD)
            (:documentation
             (setf (variable-documentation global)
                   (wrapper-value (cast value STRING-WRAPPER))))
            (:public?
             (setf (variable-public? global) (coerce-to-boolean value)))
            (:auxiliary?
             (setf (variable-auxiliary? global) (coerce-to-boolean value)))))
        (setf (the-plist options) NULL)))   ; avoid premature gc
    (return global initialValueTree) ))

(defun define-stella-global-variable-from-stringified-source
       ((stringifiedSource STRING))
  :public? TRUE
  ;; Define a stella global variable using a parse tree derived from
  ;;    'stringifiedSource'.
  (define-stella-global-variable-from-parse-tree
      (unstringify-stella-source stringifiedSource NULL)
      stringifiedSource))

(defun (record-variable-home-module MODULE) ((self GLOBAL-VARIABLE))
  ;; Determine the home module of `self', record it in `variable-home-module'
  ;;    if it differs from the module of slot's `name' (this is exploited
  ;;    by the associated `home-module' method), and return the result.
  ;; If a global was defined with an unqualified name its home module is
  ;;    identical to the module within which it was defined.  If the
  ;;    name was explicitly qualified, the home module is the one indicated
  ;;    by the qualification.
  ;; A better way to record this is to change the name symbol to the proper
  ;;    module, but that would require upgrading our variable lookup, since
  ;;    forward references to the variable name might not be resolvable then.
  (let ((name (variable-name self))
        (nameModule (interned-in name))
        (definitionModule *module*)
        (homeModule nameModule))
    (if (explicitly-qualified-name? name definitionModule)
        (setq homeModule nameModule)
      (setq homeModule definitionModule))
    (unless (eql? homeModule nameModule)
      (setf (variable-home-module self) homeModule))
    (return homeModule)))

(defun (get-global-value OBJECT) ((self SURROGATE))
  :documentation "Return the (possibly-wrapped) value of the global
variable for the surrogate 'self'."
  :public? TRUE
  (return
   (funcall (variable-get-value-code (lookup-global-variable self)))) )

(defun (set-global-value OBJECT) ((self SURROGATE) (value OBJECT))
  :documentation "Set the value of the global variable for the surrogate
'self' to 'value'."
  :public? TRUE
  (return
   (funcall (variable-set-value-code (lookup-global-variable self))
            value)) )

(defun destroy-variable ((variable GLOBAL-VARIABLE))
  ;; Remove 'variable' from all indices and destroy it.
  (let ((variableName (variable-name variable))
        (realVariable (lookup-global-variable variableName)))
    (when (eql? variable realVariable)
      (remove-at *global-variable-lookup-table* variableName))
    (setf (deleted? variable) TRUE)
    (free variable)))

  ;;
;;;;;; Type definitions
  ;;

(defun (define-stella-type-from-parse-tree TYPE) ((tree CONS))
  :public? TRUE
  ;; Create and return a new surrogate to represent the type defined by 'tree',
  ;;    and set its surrogate-value to the type specified by the definition.
  ;; NOTE: 'tree' might contain keywords such as :documentation, but they
  ;;    are currently ignored.  If we decide to represent defined types
  ;;    by defined classes then they can be stored in the class object.
  (let ((typeName (second tree))
        (typeDefinition (yield-type-specifier (third tree)))
        (type TYPE NULL))
    (typecase typeName
      (SYMBOL
       (setq type (typify typeName))
       (when (and (not (defined-type? type))
                  (defined? (surrogate-value type)))
         (walk-error "Cannot define type " typeName ", since " type EOL
                     "   already points to " (surrogate-value type))
         (return NULL))
       (setf (surrogate-value type) typeDefinition)
       (return type))
      (otherwise
       (walk-error "Illegal type name: " typeName)
       (return NULL)))))

(defun define-stella-type-from-stringified-source ((stringifiedSource STRING))
  :public? TRUE
  ;; Define a type using a parse tree derived from 'stringifiedSource'.
  (define-stella-type-from-parse-tree
      (unstringify-stella-source stringifiedSource NULL)))
