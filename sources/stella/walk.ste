;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;; BEGIN LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
; Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          ;
;                                                                            ;
; The contents of this file are subject to the Mozilla Public License        ;
; Version 1.1 (the "License"); you may not use this file except in           ;
; compliance with the License. You may obtain a copy of the License at       ;
; http://www.mozilla.org/MPL/                                                ;
;                                                                            ;
; Software distributed under the License is distributed on an "AS IS" basis, ;
; WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   ;
; for the specific language governing rights and limitations under the       ;
; License.                                                                   ;
;                                                                            ;
; The Original Code is the STELLA Programming Language.                      ;
;                                                                            ;
; The Initial Developer of the Original Code is                              ;
; UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          ;
; 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               ;
;                                                                            ;
; Portions created by the Initial Developer are Copyright (C) 1996-2010      ;
; the Initial Developer. All Rights Reserved.                                ;
;                                                                            ;
; Contributor(s):                                                            ;
;                                                                            ;
; Alternatively, the contents of this file may be used under the terms of    ;
; either the GNU General Public License Version 2 or later (the "GPL"), or   ;
; the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   ;
; in which case the provisions of the GPL or the LGPL are applicable instead ;
; of those above. If you wish to allow use of your version of this file only ;
; under the terms of either the GPL or the LGPL, and not to allow others to  ;
; use your version of this file under the terms of the MPL, indicate your    ;
; decision by deleting the provisions above and replace them with the notice ;
; and other provisions required by the GPL or the LGPL. If you do not delete ;
; the provisions above, a recipient may use your version of this file under  ;
; the terms of any one of the MPL, the GPL or the LGPL.                      ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; END LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; Version: walk.ste,v 1.300 2010/09/20 21:27:34 hans Exp

;;; Stella code walker.

(in-package "STELLA")

(in-module "/STELLA")


  ;;
;;;;;; STELLA Features
  ;;

(defglobal *available-stella-features* (LIST OF KEYWORD)
  (list :warn-about-undefined-methods
        :warn-about-missing-methods
        :suppress-warnings
        :use-hardcoded-symbols
        :use-common-lisp-structs
        ;:use-common-lisp-vector-structs
        :use-common-lisp-conses
        :use-cpp-garbage-collector
	:minimize-java-prefixes
        :translate-with-copyright-header)
  :documentation "List of available STELLA features."
  :public? TRUE)

(defspecial *current-stella-features* (LIST OF KEYWORD) (list)
  :documentation "List of currently enabled STELLA features."
  :public? TRUE)

(defglobal *default-stella-features* (LIST OF KEYWORD)
  (list :warn-about-undefined-methods
        :warn-about-missing-methods
        :use-cpp-garbage-collector
        :use-common-lisp-conses
	:minimize-java-prefixes)
  :documentation
  "List of STELLA features enabled by default and after resetting them
with `reset-stella-features'."
  :public? TRUE)

(defun print-stella-features ()
  :documentation "Print the list of enabled and disabled STELLA features."
  :public? TRUE :command? TRUE
  (print "Enabled STELLA features:" EOL)
  (foreach feature in *current-stella-features*
      do (print "  :" (string-downcase (symbol-name feature)) EOL))
  (print EOL "Disabled STELLA features:" EOL)
  (foreach feature in *available-stella-features*
      where (not (member? *current-stella-features* feature))
      do (print "  :" (string-downcase (symbol-name feature)) EOL)))

(defun set-stella-feature (&rest (features KEYWORD))
  :documentation "Enable all listed STELLA `features'."
  :public? TRUE :command? TRUE
  (foreach f in features
      do (case f
           ;; should have an entry here for each valid feature:
           (:warn-about-undefined-methods NULL)
           (:warn-about-missing-methods NULL)
           (:suppress-warnings NULL)
           (:use-hardcoded-symbols NULL)
           (:use-common-lisp-structs
            (remove *current-stella-features* :use-common-lisp-vector-structs))
           ;(:use-common-lisp-vector-structs
           ; ;; Vector structs imply CL-structs:
           ; (insert-new *current-stella-features* :use-common-lisp-structs))
           (:use-common-lisp-conses NULL)
           (:use-cpp-garbage-collector NULL)
	   (:minimize-java-prefixes NULL)
           (:translate-with-copyright-header NULL)
           (otherwise
            (if (member? *available-stella-features* f)
                (error "STELLA feature " f " is valid but not yet implemented")
              (warn "Invalid STELLA feature: " f))
            (continue)))
         (insert-new *current-stella-features* f)))

(defun unset-stella-feature (&rest (features KEYWORD))
  :documentation "Disable all listed STELLA `features'."
  :public? TRUE :command? TRUE
  (foreach f in features
      do (case f
           ;; should have an entry here for each valid feature:
           (:warn-about-undefined-methods NULL)
           (:warn-about-missing-methods NULL)
           (:suppress-warnings NULL)
           (:use-hardcoded-symbols NULL)
           (:use-common-lisp-structs NULL)
           ;(:use-common-lisp-vector-structs
           ; (remove *current-stella-features* :use-common-lisp-structs))
           (:use-common-lisp-conses NULL)
           (:use-cpp-garbage-collector NULL)
	   (:minimize-java-prefixes NULL)
           (:translate-with-copyright-header NULL)
           (otherwise
            (if (member? *available-stella-features* f)
                (error "STELLA feature " f
                       " is valid but not yet implemented")
              (warn "Invalid STELLA feature: " f))
            (continue)))
         (remove *current-stella-features* f)))

(defun reset-stella-features ()
  :documentation "Reset STELLA features to their default settings."
  :public? TRUE :command? TRUE
  (foreach f in *current-stella-features*
      where (not (member? *default-stella-features* f))
      do (unset-stella-feature f))
  (foreach f in *default-stella-features*
      where (not (member? *current-stella-features* f))
      do (set-stella-feature f)))

(defun (enabled-stella-feature? BOOLEAN) ((feature KEYWORD))
  :documentation "Return true if the STELLA `feature' is currently enabled."
  :public? TRUE :globally-inline? TRUE
  (return (memb? *current-stella-features* feature)))

(defun (disabled-stella-feature? BOOLEAN) ((feature KEYWORD))
  :documentation "Return true if the STELLA `feature' is currently disabled."
  :public? TRUE :globally-inline? TRUE
  (return (not (memb? *current-stella-features* feature))))

(startup-time-progn :globals
  (reset-stella-features))

  ;;
;;;;;; Debugging, tracing
  ;;

;; For the case of no traced keywords we set this list to `null' instead of
;;    the empty list to optimize that case in the expansion of a 'trace-if':
(defglobal *traced-keywords* (LIST OF KEYWORD) NULL :public? TRUE)

(defmacro trace-if ((keyword OBJECT) &body (body CONS))
  :documentation
  "If `keyword' is a trace keyword that has been enabled with `add-trace'
print all the elements in `body' to standard output.  Otherwise, do nothing.
`keyword' can also be a list of keywords in which case printing is done if
one or more of them are trace enabled."
  :public? TRUE
  (let ((test NIL)
        (elements (copy-cons-list body)))
    (typecase keyword
      (CONS
       (foreach kwd in keyword
           collect (bquote (memb? *traced-keywords* & kwd)) into test)
       (case (length test)
         (0 (walk-error "Missing `trace-if' keyword")
            (return (walk-dont-call-me-tree NIL @VOID)))
         (1 (setq test (first test)))
         (otherwise
          (setq test (cons (quote OR) test)))))
      (otherwise
       (setq test (bquote (memb? *traced-keywords* & keyword)))))
    (return
      (bquote
       (when (and (defined? *traced-keywords*)
                  & test)
             (print && (copy-cons-list elements))
             && (choose (or (eql? (last elements) (quote EOL))
                            ;; CL already does a `force-output':
                            (eql? (translator-output-language) :COMMON-LISP))
                        NIL
                        (bquote ((flush-output STANDARD-OUTPUT)))))))))

(defun (trace-keyword? BOOLEAN) ((keyword OBJECT))
  :public? TRUE
  (return
    (and (defined? *traced-keywords*)
         (choose (cons? keyword)
                 (exists kwd in (cast keyword CONS)
                         where (memb? *traced-keywords* kwd))
                 (memb? *traced-keywords* keyword)))) )

(defun (add-trace LIST) (&rest (keywords GENERALIZED-SYMBOL))
  :command? TRUE :public? TRUE :evaluate-arguments? FALSE
  :documentation
  "Enable trace messages identified by any of the listed `keywords'.  After
calling (`add-trace' <keyword>) code guarded by (`trace-if' <keyword> ...)
will be executed when it is encountered."
  (when (null? *traced-keywords*)
    (setq *traced-keywords* (list)))
  (foreach k in keywords
      do (insert-new *traced-keywords* (keywordify (symbol-name k))))
  (return *traced-keywords*) )

(defun (drop-trace LIST) (&rest (keywords GENERALIZED-SYMBOL))
  :command? TRUE :public? TRUE :evaluate-arguments? FALSE
  :documentation
  "Disable trace messages identified by any of the listed `keywords'.  After
calling (`drop-trace' <keyword>) code guarded by (`trace-if' <keyword> ...)
will not be executed when it is encountered."
  (when (defined? *traced-keywords*)
    (foreach k in keywords
        do (remove *traced-keywords* (keywordify (symbol-name k))))
    (when (empty? *traced-keywords*)
      (setq *traced-keywords* NULL)))
  (return *traced-keywords*) )

(defun clear-trace ()
  :command? TRUE :public? TRUE
  :documentation
  "Disable all tracing previously enabled with `add-trace'."
  (clear *traced-keywords*) )

  ;;
;;;;;; Translation switches for optimization, etc.
  ;;

(defspecial *safety* INTEGER 3
  :documentation "Integer between 0 and 3.  Higher levels call more
safety checks.")

(defspecial *debugLevel* INTEGER 3
  :documentation "Integer between 0 and 3.  Higher levels generate more
code to aid debugging.")

(defspecial *optimizeSpeedLevel* INTEGER 3
  :documentation "Integer between 0 and 3.  Higher levels optimize for
greater execution speed.")

(defspecial *optimizeSpaceLevel* INTEGER 3
  :documentation "Integer between 0 and 3.  Higher levels optimize for
less code size and memory consumption.")

(defun set-optimization-levels
    ((safety INTEGER) (debug INTEGER) (speed INTEGER) (space INTEGER))
  :documentation "Set optimization levels for the qualities `safety', `debug',
`speed', and `space'."
  :public? TRUE
  ;; NOTE: Not sure whether this is the best interface to steer optimization.
  ;;    Apart from `safety' each combination of levels turns certain switches
  ;;    on and others off.  Maybe they should  also be controllable via
  ;;    environment features, however, then that mechanism would need to
  ;;    take care of mutual constraints.
  (when (and (defined? safety) (>= safety 0) (<= safety 3))
    (setq *safety* safety))
  (when (and (defined? debug) (>= debug 0) (<= debug 3))
    (setq *debugLevel* debug))
  (when (and (defined? speed) (>= speed 0) (<= speed 3))
    (setq *optimizeSpeedLevel* speed))
  (when (and (defined? space) (>= space 0) (<= space 3))
    (setq *optimizeSpaceLevel* space)))

(defun (preserve-tail-merge-optimizability? BOOLEAN) ()
  ;; Return `true' if tail merge optimizability should be preserved when
  ;;    translating to Common Lisp.  This avoids unnecessary `return-from's
  ;;    which seems to trip up the tail merge optimizer of Allegro-CL.
  (return (and (>= *optimizeSpeedLevel* 3)
               (<= *debugLevel* 0))))

(defun (method-call-inlining-enabled? BOOLEAN) ()
  ;; Return `true' if inlinable functions and methods should be open-coded
  ;;    if possible (i.e., they will be translated as if they were macros).
  (return (and (>= *optimizeSpeedLevel* 3)
               (<= *debugLevel* 1))))

(defun (optimize-boolean-tests? BOOLEAN) ()
  ;; Return `true' if various target-languge specific optimizations for
  ;;    boolean tests should be performed.
  ;; For example, fold explicit negation into comparison operators
  ;;    (if possible), optimize EQ? in Common Lisp, etc.
  (return (and (>= *optimizeSpeedLevel* 2)
               (<= *debugLevel* 2))))

(defun (check-for-illegal-return? BOOLEAN) ()
  ;; Return `true' if safety code should be added that triggers an error
  ;;    if a function that does return one or more values returns without
  ;;    actually executing a `return' statement.
  ;; Java Note:  Java enforces this already, and adding the explicit code
  ;;    causes compiler errors, since it can introduce code beyond any
  ;;    (possibly conditionalized) return statements.
  (return (and (>= *safety* 3)
	       (not (eq? (translator-output-language) :java))
               (not (preserve-tail-merge-optimizability?)))))

  ;;
;;;;;; Quote
  ;;

;;; Quoted cons trees (cons tree constants) are stored in a memoization
;;; table indexed by their stringified representation.  On first
;;; lookup the name gets unstringified and the result stored in the
;;; table.  Further lookups retrieve the unstringified version
;;; directly.  Since quoted trees are not used very often, using
;;; a hashtable lookup scheme seems to be sufficient.  If a quoted
;;; tree is used in a loop, it should probably be stored in a local
;;; variable to avoid unnecessary lookups.

(defun (name-quoted-tree STRING) ((tree CONS))
  ;; Return a string that can serve as a name for the quoted 'tree'.
  (let ((nameTree
         (bquote (& tree & (wrap-literal (module-full-name *module*)))))
        (name (stringify nameTree)))
    (return name)))

(defun (get-quoted-tree CONS) ((tree-name STRING) (moduleName STRING))
  :documentation "Return the quoted tree with name `tree-name'."
  :public? TRUE
  (return
    (memoize (tree-name)
             ;; keyed in on module updates, so we'll regenerate
             ;; in case somebody cleared a module:
             :timestamps :MODULE-UPDATE :max-values 200
             (permanentify-form
              (first
               (cast
                (unstringify-in-module
                 tree-name
                 (get-stella-module moduleName TRUE))
                CONS))))))


  ;;
;;;;;; Real 'translate'
  ;;

;;; Translation is accomplished in three phases:  In the first phase,
;;; top level declarations are parsed and converted into a list of
;;; translation units which hold Stella objects (classes, methods, etc.).
;;; In the second phase, the Stella objects are finalized.  
;;; In the third phase, parse tree code is generated for each translation
;;; unit generated in the first phase, and additional translation units
;;; are added to hold auxiliary definitions and startup-time code.
;;; Finally, the information stored in each translation unit is translated
;;; into a code tree for the target language.

(defclass TRANSLATION-UNIT (STANDARD-OBJECT)
  :public? TRUE
  :public-slots
  (;; Module in which the object of the translation unit is encountered
   ;; This is needed for Java translation, where the translation is not
   ;; completed in the same context as the initial reading and walking.
   (tu-home-module :type MODULE :option-keyword :tu-home-module)
   ;; A Stella object or a parse tree:
   (the-object :type OBJECT)
   ;; The category of the object, which must be one of CLASS, SLOT, 
   ;; METHOD, PRINT-METHOD, GLOBAL-VARIABLE, TYPE,
   ;; STARTUP-TIME-PROGN, or VERBATIM:
   (category :type SYMBOL)
   ;; A string that can be used to annotate the translation:
   (annotation :type STRING)
   ;; Is this a user-defined or auxiliary object:
   (auxiliary? :type BOOLEAN)
   ;; A register to store temporary or additional code:
   (code-register :type OBJECT)
   ;; Holds a translated parse tree for the target language:
   (translation :type OBJECT)
   ;; Cross-reference data:
   (referenced-globals :type (LIST OF GLOBAL-VARIABLE)
		       :allocation :embedded :component? TRUE)
   )
  :public-methods 
  ((home-module ((self TRANSLATION-UNIT)) :type MODULE
     (return (tu-home-module self))))
  ;:recycle-method :free-list
  :print-form (print-translation-unit self stream))

(defun clear-translation-unit ((self TRANSLATION-UNIT))
  ;; Reset all important slots of `self' to `null'.
  ;; This is a leftover from the time where we recycled translation units,
  ;;    since the unit terminator cleared all the slots and some translation
  ;;    logic still depends on that (e.g., forward declarations - methods
  ;;    without a body - need to make `walk-phase-one-unit' return a unit with a
  ;;    `null' method object).
  (setf (tu-home-module self) NULL)
  (setf (the-object self) NULL)
  (setf (category self) NULL)
  (setf (code-register self) NULL)
  (setf (translation self) NULL))

(defun print-translation-unit ((self TRANSLATION-UNIT)
                               (stream NATIVE-OUTPUT-STREAM))
  (print-native-stream stream "|TU|[" (category self))
  (case (category self)
    ((CLASS METHOD GLOBAL-VARIABLE)
     (print-native-stream stream " " (the-object self)))
    (otherwise NULL))
  (print-native-stream stream "]"))

(defspecial *translationUnits* (LIST OF TRANSLATION-UNIT) NULL
  :public? TRUE
  :documentation "List of objects representing partially walked
top-level definitions and auxiliary code.")

(defspecial *currentTranslationUnit* TRANSLATION-UNIT NULL
  :public? TRUE
  :documentation "The translation unit currently operated on.")

(defspecial *translationPhase* KEYWORD NULL
  :public? TRUE
  :documentation "Indicates the current translation phase which is one of
:DEFINE, :FINALIZE, :WALK, or :TRANSLATE.")

(defspecial *translationVerbosityLevel* INTEGER 1
  :public? TRUE
  :documentation "The higher the level, the more progress annotations are
generated during the translation of Stella declarations.")

(defspecial *useHardcodedSymbols?* BOOLEAN FALSE)

(defun (use-hardcoded-symbols? BOOLEAN) ()
  (return (or (member? *current-stella-features* :use-hardcoded-symbols)
              *useHardcodedSymbols?*)))


;;; Translator selection

(defspecial *translatorOutputLanguage* KEYWORD
            (running-in-language)
  :documentation "Specifies the current translator output language; either
:common-lisp, :idl, :java, :cpp, or :cpp-standalone.  The initial value
points to the native implementation language of this STELLA instance.")

(defun (translator-output-language KEYWORD) ()
  ;; Return :common-lisp or :java or :cpp :idl, indicating the output language.
  :globally-inline? TRUE
  (return *translatorOutputLanguage*) )

(defun (translator-output-language-name STRING) ()
  ;; Return a readable string representation of the current output language.
  (case (translator-output-language)
    (:common-lisp (return "Common Lisp"))
    (:cpp (return "C++"))
    (:java (return "Java"))
    (:cpp-standalone (return "standalone-C++"))
    (:idl (return "IDL"))
    (otherwise
     (return (symbol-name (translator-output-language))))))

(defun (set-translator-output-language KEYWORD) ((new-language KEYWORD))
  :documentation "Set output language to `new-language'.  Return previous language."
  :command? TRUE :public? TRUE
  (let ((oldLanguage (translator-output-language)))
    (unless (member? (bquote (:cpp :cpp-standalone :common-lisp :java :idl)) 
		     new-language)
      (warn new-language " is not a legal translation language"))
    (setq *translatorOutputLanguage* new-language)
    (return oldLanguage) ))

(defun (translate-to-common-lisp? BOOLEAN) ()
  :documentation "Return `true' if current output language is Common-Lisp."
  (return (eql? *translatorOutputLanguage* :common-lisp)) )

(defun (translate-to-cpp? BOOLEAN) ()
  :documentation "Return `true' if current output language is C++"
  (return (eql? *translatorOutputLanguage* :CPP)) )

(defun (translate-to-java? BOOLEAN) ()
  :documentation "Return `true' if current output language is Java"
  (return (eql? *translatorOutputLanguage* :java)) )

(defun (translate-to-single-inheritance-language? BOOLEAN) ()
  ;; Return `true' if we are translating to a single-inheritance language.
  ;; We force single inheritance even for languages that allow multiple
  ;;    inheritance to ensure STELLA code uniformity and portability.
  (case (translator-output-language)
    ((:common-lisp :cpp :java)
     (return TRUE))
    (otherwise
     (return FALSE))))

(defun (toggle-output-language KEYWORD) ()
  :documentation "Switch between Common Lisp and C++ as output languages."
  (cond ((translate-to-common-lisp?)
	 (setq *translatorOutputLanguage* :cpp)
	 (return :CPP))
	((translate-to-cpp?)
	 (setq *translatorOutputLanguage* :java)
	 (return :JAVA))
	(otherwise
	 (setq *translatorOutputLanguage* :common-lisp)
	 (return :COMMON-LISP))) )

(defun (use-bootstrap-translator? BOOLEAN) ()
  ;; Obsolete.
  (return FALSE))

(defun (toggle-translators KEYWORD) ()
  ;; Obsolete.
  (return NULL))


;;; Translation of top-level forms

(defun (declaration-operator? BOOLEAN) ((operator SYMBOL))
  ;; Return `true' if 'operator' signifies a (top level) declaration.
  ;; Declaration operators are not allowed to appear nested inside
  ;;    other Stella code.
  (return (member? (quote (defclass defslot defmethod defun deftype
                            defglobal defspecial defconstant
                            defmacro defmodule startup-time-progn))
                   operator)) )

(defun (declaration-tree? BOOLEAN) ((tree CONS))
  :public? TRUE
  ;; Return `true' if 'tree' is a (top level) declaration.
  ;; Declaration trees are not allowed to appear nested inside
  ;;    other Stella code.
  ;; This is a generalized version of 'declaration-operator?' that
  ;;    mimics part of the functionality of 'walk-top-level-tree'.
  ;;    Using it, 'incrementally-translate' can be clever about
  ;;    what translation mode to use which is crucial to make
  ;;    automatically generated Lisp macros work.
  (let ((operator (value tree)))
    (when (declaration-operator? operator)
      (return TRUE))
    (when (eql? operator (quote PROGN))
      (return
        (exists subTree in (rest tree)
                where (and (cons? subTree)
                           (declaration-tree? subTree)))))
    (when (defined? (lookup-macro operator))
      (let ((expansion (expand-macro (copy-cons-list tree))))
        ;; We need to destructively modify 'tree' with the expansion
        ;;    to avoid another expansion during the translation, since
        ;;    - even though that's bad - macros can have side-effects:
        (cond ((defined? expansion)
               (typecase expansion
                 (CONS
                  (setf (value tree) (value expansion))
                  (setf (rest tree) (rest expansion))
                  (return (declaration-tree? tree)))
                 (otherwise
                  ;; Pity, but for atomic expansions we can't use this trick:
                  (return FALSE))))
              (otherwise
               (setf (value tree) (quote PROGN))
               (setf (rest tree) NIL)
               (return FALSE)))))
    (return FALSE)))

(defun (create-annotation STRING) ((top-level-tree CONS))
  ;; Creates an annotation string for 'top-level-tree'.
  (return
    (concatenate "("
      (concatenate (symbol-name (cast (first top-level-tree) SYMBOL))
        (concatenate " "
          (concatenate (stringify (second top-level-tree)) " ...)"))))))

(defun walk-top-level-tree ((tree CONS) (createAnnotation? BOOLEAN))
  :public? TRUE
  ;; Walk the parse tree 'tree' representing a top level form (either
  ;;    a declaration or a STARTUP-TIME-PROGN).
  ;; Push a new translation unit representing the object defined by
  ;;    the top-level form onto '*translationUnits*'.  Each of the
  ;;    'walk-xxx-tree' functions used below defines such a unit
  ;;    as a side-effect.
  ;; Multiple units might be pushed if 'tree' was a 'PROGN'.
  ;; This function performs phase one of the translation process.
  (special ((*currentTranslationUnit* NULL))
    (let ((annotation STRING NULL))
      (when createAnnotation?
        (setq annotation (create-annotation tree))
        (when (>= *translationVerbosityLevel* 2)
          (inform "Defining " annotation)))
      (case (first tree)
        (DEFCLASS (walk-defclass-tree tree))
        (DEFSLOT (walk-defslot-tree tree))
        ((DEFMETHOD DEFUN DEFOPERATOR)
         (when (eq? (first tree) (quote DEFOPERATOR))
           (setf (first tree) (quote DEFMETHOD)))
         (walk-defmethod-tree tree))
        ((DEFGLOBAL DEFSPECIAL DEFCONSTANT) (walk-defglobal-tree tree))
        (DEFTYPE (walk-deftype-tree tree))
        (DEFMODULE (walk-defmodule-tree tree))
        (DEFMACRO (walk-defmacro-tree tree))
        (STARTUP-TIME-PROGN (walk-startup-time-progn-tree tree))
        (VERBATIM (walk-verbatim-definition-tree tree))
        (PROGN
         (foreach form in (rest tree)
             do (walk-top-level-tree form createAnnotation?))
         (return))
        (otherwise
         (cond
          ((defined? (lookup-macro (first tree)))
           (let ((expansion (expand-macro tree)))
             ;; If a top-level macro detects errors, it should return `null':
             (when (defined? expansion)
               (walk-top-level-tree expansion createAnnotation?))))
          (otherwise
           (when (not (or (incremental-translation?)
                          (defined? (lookup-command (first tree)))))
             (walk-warn "Illegal top-level statement:" EOL "   " tree EOL
                        " Wrapping it into a 'startup-time-progn'"))
           (setq tree (bquote (startup-time-progn & tree)))
           (walk-top-level-tree tree FALSE)))
         (return)))
      ;; A syntax error might keep '*currentTranslationUnit*' undefined:
      (when (defined? *currentTranslationUnit*)
        (push *translationUnits* *currentTranslationUnit*)
        (setf (annotation *currentTranslationUnit*) annotation)))))

(defun (walk-top-level-expression OBJECT) ((tree OBJECT))
  ;; Called by "incrementally-translate".  Catches VRLET
  ;;    expressions that percolate to the top level.
  ;; Wraps VRLETs with a PROGN, which eliminates return values but
  ;;    allows for side-effects.
  (special ((*localVariableTypeTable* (allocate KEY-VALUE-LIST)))
    (let ((oTree (walk-without-type-tree tree)))
      (when (vrlet-expression? oTree)
        (return (walk-without-type-tree (bquote (progn & oTree)))))
      (return oTree) )))

(defun walk-phase-one-unit ((unit TRANSLATION-UNIT))
  ;; Walk a translation 'unit' representing a class, method, global, etc.
  ;; object generated during phase one.  Fill in any missing information
  ;; and generate any additional units that might be necessary for the
  ;; translation of 'unit'.  'unit' and all its auxiliary units will
  ;; be pushed onto '*translationUnits*'.  All units completed and generated
  ;; in this step can easily be converted into C++ or Common Lisp code.
  (special ((*localVariableTypeTable* (allocate KEY-VALUE-LIST))
            (*currentTranslationUnit* unit))
    (case (category unit)
      ;; Every 'walk-xxx-unit' pushes its unit and all additionally
      ;; necessary auxiliary units onto '*translationUnits*':
      (GLOBAL-VARIABLE (walk-global-unit unit))
      (MODULE (walk-module-unit unit))
      (TYPE (walk-type-unit unit))
      ((METHOD PRINT-METHOD) (walk-method-unit unit))
      (CLASS (walk-class-unit unit))
      (SLOT (walk-slot-unit unit))
      (STARTUP-TIME-PROGN
       (walk-startup-time-progn-unit unit))
      (VERBATIM
       (walk-verbatim-unit unit)))))

(defun walk-auxiliary-tree ((tree CONS))
  ;; Walk the parse 'tree' representing an auxiliary definition
  ;;    needed for the translation of some top level form.
  ;; Assumes that phases one and two of the translation process have
  ;;    been completed, and pushes as many translation units onto
  ;;    '*translationUnits*' as are necessary to translate 'tree'.
  (help-walk-auxiliary-tree tree TRUE))

(defun (help-walk-auxiliary-tree TRANSLATION-UNIT)
    ((tree CONS) (finalize? BOOLEAN))
  ;; Walk the parse 'tree' representing an auxiliary definition
  ;;    needed for the translation of some top level form.
  ;; Assumes that phases one and two of the translation process have
  ;;    been completed, and pushes as many translation units onto
  ;;    '*translationUnits*' as are necessary to translate 'tree'.
  ;; Finalize any new objects if 'finalize?' is `true'.
  ;; Return the "principal" unit defined by 'tree'.
  ;; CAREFUL: Currently, this assumes that 'tree' defines exactly
  ;;    one unit, i.e., it can not be a 'PROGN', and it must be
  ;;    syntactically correct.
  (unless (member? (quote (DEFCLASS DEFMETHOD DEFUN DEFMACRO
                            DEFGLOBAL DEFSPECIAL DEFCONSTANT
                            STARTUP-TIME-PROGN VERBATIM))
                   (first tree))
    (error "OOPS, illegal auxiliary statement:" EOL "   " tree))
  ;; Create a phase-one unit just like for a top-level tree:
  (walk-top-level-tree tree FALSE)
  (when finalize?
    ;; Make sure everything is finalized before we walk the new object:
    (finalize-classes-and-slots))
  ;; Now we pop the unit generated above and walk it to fill in everything
  ;; that's missing and generate any additional units that might be needed:
  (let ((unit (pop *translationUnits*)))
    (setf (auxiliary? unit) TRUE)
    (walk-phase-one-unit unit)
    ;; Return the unit for the sake of functions that need to do
    ;;    some post-processing on the generated object:
    (return unit)))

(defun walk-all-phase-one-units ()
  ;; Walks all phase-one units currently stored in '*translationUnits*'.
  ;;    After that '*translationUnits*' will contain additional units
  ;;    for auxiliary definitions and startup code.  The relative order of
  ;;    phase-one units is preserved, but each of them is immediately
  ;;    followed by its "personal" auxiliary units.
  (let ((phaseOneUnits *translationUnits*))
    (setq *translationUnits* (new (LIST OF TRANSLATION-UNIT)))
    (foreach unit in phaseOneUnits
             do
             (when (and (>= *translationVerbosityLevel* 2)
                        (defined? (annotation unit)))
               (inform "Walking " (annotation unit)))
             (walk-phase-one-unit unit))
    (create-finalization-units)
    (create-startup-function-units)
    (clear phaseOneUnits)
    (reverse *translationUnits*)))

(defun translate-all-units ()
  ;; Translates all current '*translationUnits*' into parse trees
  ;; for the target language, and stores the translations in the units.
  (foreach unit in *translationUnits*
      do (special ((*currentTranslationUnit* unit))
	   (when (and (>= *translationVerbosityLevel* 2)
		      (defined? (annotation unit)))
	     (inform "Translating " (annotation unit)))
	   (case (translator-output-language)
	     (:common-lisp
	      (setf (translation unit) (cl-translate-unit unit)))
	     (:idl
	      (setf (translation unit) (idl-translate-unit unit)))
	     ((:java :java-standalone)
	      (when (null? (translation unit))
		(setf (translation unit) (java-translate-unit unit))))
	     ((:cpp :cpp-standalone)
	      (setf (translation unit) (cpp-translate-unit unit)))))))

(defun (unit-included-in-other-units? BOOLEAN) ((unit TRANSLATION-UNIT))
  (let ((method METHOD-SLOT NULL))
    (if (not (eq? (category unit) (quote METHOD)))
	(return FALSE)
      (progn 
	(setq method (the-object unit))
	(cond ((method-constructor? method)
	       ;; A constructor that returns CLASS.
	       (foreach other-unit in *translationUnits*
		   where (and (eq? (category other-unit) (quote CLASS))
			      (eql? (canonical-type (slot-base-type method)) 
				    (class-type (cast (the-object other-unit) CLASS))))
		   do (return TRUE))
	       (return FALSE))
	      (otherwise
	       (foreach other-unit in *translationUnits*
		   where (and (eq? (category other-unit) (quote CLASS))
			      (eql? (canonical-type (slot-owner method))
				    (class-type (cast (the-object other-unit) CLASS))))
		   do (return TRUE))
	       (return FALSE))))) ))

(defun (combine-translated-trees CONS) ()
  ;; Combines all translated parse trees currently stored in
  ;;    '*translationUnits*' into a single compound parse tree.
  (let ((oTree CONS nil))
    (case (translator-output-language)
      ((:common-lisp :cpp :cpp-standalone :idl)
       (foreach unit in *translationUnits*
	   collect (translation unit) into oTree))
      ((:java :java-standalone)
       (foreach unit in *translationUnits*
	   where (not (unit-included-in-other-units? unit))
	   collect (translation unit) into oTree)))
    (case (translator-output-language)
      (:common-lisp
       (setq oTree (bquote (CL:PROGN && oTree))))
      ((:cpp :cpp-standalone :java :idl)))
    (return oTree)))
    
(defun (translate-walked-tree OBJECT) ((codeTree OBJECT))
  ;; Translate the parse tree 'codeTree' into a parse tree tailored for
  ;;    the output language.
  (case (translator-output-language)
    (:common-lisp
     (return (cl-translate-a-tree codeTree)))
    (:idl
     (return (idl-translate-a-tree codeTree)))    
    (:java
     (return (java-translate-a-tree codeTree)))    
    ((:cpp :cpp-standalone)
     (return (cpp-translate-a-tree codeTree)))) )

(defun (incrementally-translate OBJECT) ((tree OBJECT))
  :documentation "Translate a single Stella expression `tree' and return
the result.  For C++ and Java print the translation to standard output and
return NIL instead."
  :public? TRUE
  ;; Strategy:  Mimic translation of a file of Stella source code:
  ;;    If 'expression' represents a top level declaration, generate
  ;;       declaration objects, translate the objects into an output
  ;;       parse tree, and return code representing the parse tree.
  ;;    Otherwise, translate the code by-passing object generation.
  (let ((topLevelInvocation? (null? *translationUnits*))
        (oCode OBJECT NULL)
        (declaration?
         (and (cons? tree)
              (declaration-tree? tree))))
    (special ((*translationUnits* (new (LIST OF TRANSLATION-UNIT)))
              (*translationVerbosityLevel* 0)
              (*translationPhase* NULL)
              (*translationErrors* 0)
              (*translationWarnings* 0)
              (*translationNotes* 0))
      ;; Walking:
      (cond 
       (declaration?
        (setq *translationPhase* :DEFINE)
        (walk-top-level-tree tree FALSE)
        (when (translation-errors?)
          (summarize-translation-errors)
          (return NIL))
        ;; This is a no-op, since we should only have one unit here:
        (reverse *translationUnits*)
        (setq *translationPhase* :FINALIZE)
        (finalize-classes-and-slots)
        (setq *translationPhase* :WALK)
	(unless (use-hardcoded-symbols?)
	  (clear-symbol-registry))
        (walk-all-phase-one-units))
       (otherwise
        (setq *translationPhase* :WALK)
        (special ((*useHardcodedSymbols?* TRUE))
          ;; Don't use soft-coded symbols here, since we won't get proper
          ;;    startup-time code to initialize them.  Actually, for
          ;;    incremental translation we really never need soft-coded
          ;;    symbols, but we'll keep them anyway for "readability".
          ;;(unless (use-hardcoded-symbols?)
          ;;  (clear-symbol-registry))
          (setq oCode (walk-top-level-expression tree)))))
      ;; Translating:
      (when (translation-errors?)
        (summarize-translation-errors)
        (return NIL))
      (setq *translationPhase* :TRANSLATE)
      (cond 
       (declaration?
        (translate-all-units)
        ;; This step differs from file translation and
        ;; really only makes sense for Common-Lisp:
        (setq oCode (combine-translated-trees)))
       (otherwise
        (special ((*useHardcodedSymbols?* TRUE))
          (setq oCode (translate-walked-tree oCode)))))
      ;; Code generation:
      (when (translation-errors?)
        (summarize-translation-errors)
        (return NIL))
      (case (translator-output-language)
        (:common-lisp NULL)
	(:idl
	 (idl-output-parse-tree oCode)
	 (setq oCode NIL))
	(:java
	 (java-output-parse-tree oCode)
	 (setq oCode NIL))
        ((:cpp :cpp-standalone)
         (cpp-output-parse-tree oCode)
         (setq oCode NIL)))
      ;; Clean up translation units:
      (foreach unit in *translationUnits* do (free unit))
      (clear *translationUnits*)
      (when topLevelInvocation?
        (sweep-transients))
      (summarize-translation-errors)
      (return oCode))))


  ;;
;;;;;; Routines used by the walker.
  ;;

;;; The Stella code walker takes as input a parse tree built from
;;;    conses, and destructively transforms it into a canonical
;;;    parse tree that replaces complex forms by simpler ones, all
;;;    of which have analogues in C++ and Common Lisp.

(defspecial *localVariableTypeTable*
    (KEY-VALUE-LIST OF SYMBOL STANDARD-OBJECT) NULL
  :documentation "Table mapping local variable names their declared types
(declared explicitly or implicitly).")

;; This should be phased out in favor of using '*currentTranslationUnit*'.
;;    For now we keep it for the sake of a minute gain in efficiency.
(defspecial *methodBeingWalked* METHOD-SLOT NULL
  :documentation "Contains the method or function being walked, or else `null'.")

(defspecial *foundReturn?* BOOLEAN FALSE
  :documentation "Indicates that one or more return statements have been found
during the walk of the current method.")

(defspecial *targetType* TYPE-SPEC @VOID
  :documentation "Bound to the target type for an expression currently walked.
Used instead of an extra argument to `walk-a-tree', since only a few types
of expressions need to know about their expected type (e.g., FUNCALL).")

(defspecial *localGensymTable* KEY-VALUE-LIST NULL
  :documentation "Table that maps each prefix of a function-local gensym
to its own gensym counter and/or to related gensyms.")


;;; Error handling:

(defspecial *translationErrors* INTEGER 0
  :public? TRUE)
(defspecial *translationWarnings* INTEGER 0
  :public? TRUE)
(defspecial *translationNotes* INTEGER 0
  :public? TRUE)

(defun reset-translation-errors ()
  ;; Reset the global translation error indicators.
  (setq *translationErrors* 0)
  (setq *translationWarnings* 0)
  (setq *translationNotes* 0))

(defun signal-translation-error ()
  :public? TRUE
  ;; Signal a translation error.  Called by 'walk-error'.
  (++ *translationErrors*))

(defun signal-translation-warning ()
  :public? TRUE
  ;; Signal a translation warning.  Called by 'walk-warn'.
  (++ *translationWarnings*))

(defun signal-translation-note ()
  :public? TRUE
  ;; Signal a translation warning.  Called by 'walk-inform'.
  (++ *translationNotes*))

(defun (ignore-translation-errors? BOOLEAN) ()
  ;; Return `true' if translation errors should be ignored.
  ;; Maybe also have an environment feature that can be overridden
  ;;    by the variable.
  (return *ignoreTranslationErrors?*))

(defun (translation-errors? BOOLEAN) ()
  :public? TRUE
  ;; Return `true' if any non-ignorable translation errors were encountered
  ;;    since the last call to 'reset-translation-errors'.
  (return (and (> *translationErrors* 0)
               (not (ignore-translation-errors?)))))

(defun summarize-translation-errors ()
  ;; Print a message indicating how many errors and warnings were issued
  ;;    since the last call to 'reset-translation-errors'.
  (when (> *translationErrors* 0)
    (print *translationErrors* " error")
    (when (> *translationErrors* 1)
      (print "s")))
  (when (> *translationWarnings* 0)
    (when (> *translationErrors* 0)
      (print ", "))
    (print *translationWarnings* " warning")
    (when (> *translationWarnings* 1)
      (print "s")))
  (when (> *translationNotes* 0)
    (when (or (> *translationErrors* 0)
	      (> *translationWarnings* 0))
      (print ", "))
    (print *translationNotes* " note")
    (when (> *translationNotes* 1)
      (print "s")))
  (when (or (> *translationErrors* 0)
            (> *translationWarnings* 0)
	    (> *translationNotes* 0))
    (print "." EOL)))

(defun print-error-context ((prefix STRING) (stream OUTPUT-STREAM))
  :public? TRUE
  ;; Print an error context based on the current translation unit
  ;;    and translation phase onto 'stream'.
  ;; 'prefix' can be used to annotate the context as an error or warning.
  ;; The various print cases try to be smart about handling cases
  ;;    where the actual object is not yet available, but the
  ;;    offending definition tree is.
  (print-stream stream prefix "While ")
  (cond ((defined? *translationPhase*)
         (case *translationPhase*
           (:DEFINE (print-stream stream "defining "))
           (:FINALIZE (print-stream stream "finalizing "))
           (:WALK (print-stream stream "walking "))
           (:TRANSLATE (print-stream stream "translating "))))
        (otherwise (print-stream stream "processing ")))
  (cond ((defined? *currentTranslationUnit*)
         (let ((object (the-object *currentTranslationUnit*))
               (category (category *currentTranslationUnit*)))
           (case category
             (CLASS
              (print-stream stream "class ")
              (typecase object
                (CLASS (print-stream stream (name object)))
                (otherwise (print-stream stream object))))

             (SLOT
              (print-stream stream "external slot ")
              (typecase object
                (CONS (print-stream stream (second object) "." (third object)))
                (STORAGE-SLOT
                 (print-stream stream (slot-owner object)
                               "." (symbol-name (slot-name object))))))
             
             ((METHOD PRINT-METHOD)
              (typecase object
                (METHOD-SLOT
                 (cond ((method-macro? object)
                        (print-stream stream "macro " (slot-name object)))
                       ((method-function? object)
                        (print-stream stream "function " (slot-name object)))
                       (otherwise
                        (print-stream stream "method " (slot-owner object)
                                      "." (symbol-name (slot-name object))))))
                (CONS
                 (case (first object)
                   (DEFMETHOD (print-stream stream "method "))
                   ;; unfortunately, definition options get extracted which
                   ;;    makes it impossible to know whether this is a macro:
                   (DEFUN (print-stream stream "function "))
                   (otherwise NULL))
                 (print-stream
                  stream
                  (choose (cons? (second object))
                          (first (cast (second object) CONS))
                          (second object))))))
             
             (GLOBAL-VARIABLE
              (typecase object
                (GLOBAL-VARIABLE
                 (if (variable-constant? object)
                     (print-stream stream "constant ")
                   (if (variable-special? object)
                       (print-stream stream "special variable ")
                     (print-stream stream "global variable ")))
                 (print-stream stream (variable-name object)))
                (CONS
                 (print-stream stream (first object) " " (second object)))))

             (TYPE
              (print-stream stream "type ")
              (typecase object
                (CONS (print-stream stream (second object)))
                (TYPE-SPEC
                 (print-stream stream (yield-type-spec-tree object)))))

             (MODULE
              (print-stream stream "module ")
              (typecase object
                (MODULE (print-stream stream (module-name object)))
                (CONS (print-stream stream (second object)))))

             (otherwise
              (print-stream stream category)))))
        (otherwise (print-stream stream "top-level statement")))
  (print-stream stream ":"))


;;; Debugging aids:

;;; Function call logging can be used to investigate differences in runtime
;;; behavior between different translations of the same program (e.g.,
;;; differences between Lisp and C++ or between an optimized and a non-
;;; optimized translation).  Unfortunately, since C++ does not prescribe an
;;; evaluation order for function arguments, we would also have to rig up the
;;; translator to enforce an order to enable successful comparisons between a
;;; Lisp and a C++ translation of a STELLA program.

;;; The procedure for debugging is to first translate the program portion in
;;; question with `*log-function-calls?*' set to `true' for the two differing
;;; translation schemes (e.g., Lisp and C++).  Then run the programs and
;;; initialize the program state under absolutely IDENTICAL conditions.  Then
;;; use `start-function-call-logging' to start call logging to file-A for
;;; translation scheme A and to file-B for translation scheme B.  Now start
;;; the offending function and interrupt or stop it as soon as the programs
;;; exhibit a difference in behavior (the current scheme does not
;;; compress/encode call logs, which means that the log files will grow very
;;; big very fast).  Use Unix `diff' or some other tool to find the first
;;; place where the program runs deviate.  Suppose the offending call is at
;;; line number 1234.  Restart the program under the exact same conditions,
;;; set a break point with `(set-call-log-break-point 1234)' which will
;;; interrupt the program right before the offending call at which point you
;;; can investigate the reason why.

(defglobal *function-call-log-stream* OUTPUT-STREAM NULL
  :documentation "The current log file to which function calls should be logged.
A non-NULL value indicates that function call logging is enabled.")

(defglobal *log-function-calls?* BOOLEAN FALSE
  :documentation "Translation switch which indicates that methods should
be instrumented to log their calls to a file.")

(defun (log-function-call? BOOLEAN) ((method METHOD-SLOT))
  ;; Return `true' if `method' should be instrumented to log calls to a file.
  (when (and *log-function-calls?*  
             (not (method-auxiliary? method))
             (not (method-globally-inline? method)))
    (case (slot-name method)
      ((LOG-FUNCTION-CALL START-FUNCTION-CALL-LOGGING STOP-FUNCTION-CALL-LOGGING
        SET-CALL-LOG-BREAK-POINT BREAK-PROGRAM TERMINATE-PROGRAM PO
        DEFINED? NULL? EQ? EQL? < <= > >= CAST)
       (return FALSE))
      (otherwise
       (when (or (member? (method-parameter-type-specifiers method) @UNKNOWN)
                 (member? (method-parameter-type-specifiers method) @LISP-CODE)
                 (member? (method-return-type-specifiers method) @UNKNOWN)
                 (member? (method-return-type-specifiers method) @LISP-CODE)
                 (exists tSpec in (method-parameter-type-specifiers method)
                   where (sub-type-spec-of? tSpec @OUTPUT-STREAM))
                 (exists tSpec in (method-parameter-type-specifiers method)
                   where (sub-type-spec-of? tSpec @NATIVE-OUTPUT-STREAM))
                 (and
                  (defined? *currentFile*)
                  (or (defined? (string-search *currentFile* "cl-primal" 0))
                      (defined?
                          (string-search *currentFile* "stella-to-cl" 0)))))
         (return FALSE))))
    (return TRUE))
  (return FALSE))

(defun (wrap-body-with-log-function-call-tree CONS)
    ((method METHOD-SLOT) (body CONS))
  ;; Instrument the `body' of `method' with code to be able to log calls.
  (if (and (cons? (first body))
           (not (eql? (first (safe-cast (first body) CONS)) (quote INLINE))))
      (return (bquote ((log-function-call & (stringify method))
                       && body)))
    (return body)))

(defglobal *log-break-point-counter* INTEGER NULL)

(defun log-function-call ((name STRING))
  ;; If function call logging is enabled, write the `name' of the currently
  ;;    called function to `*function-call-log-stream*'.
  ;; If defined, decrement `*log-break-point-counter*' or interrupt
  ;;    execution if its value is down to zero.
  (when (not (eq? *function-call-log-stream* NULL))
    (print-stream *function-call-log-stream* name EOL))
  ;; This should work independent of whether we are currently logging to a file:
  (when (defined? *log-break-point-counter*)
    (-- *log-break-point-counter*)
    (when (= *log-break-point-counter* 0)
      (setq *log-break-point-counter* NULL)
      (break-program "Call log break point"))))

(defun start-function-call-logging ((fileName STRING))
  :documentation "Start function call logging to `fileName'."
  :command? TRUE :public? TRUE
  (let ((currentLogStream *function-call-log-stream*))
    (setq *function-call-log-stream* NULL)
    (when (defined? currentLogStream)
      (free currentLogStream))
    (setq *function-call-log-stream*
      (new OUTPUT-FILE-STREAM :filename fileName))))

(defun stop-function-call-logging ()
  :documentation "Stop function call logging and close the current log file."
  :command? TRUE :public? TRUE
  (let ((currentLogStream *function-call-log-stream*))
    (setq *function-call-log-stream* NULL)
    (when (defined? currentLogStream)
      (free currentLogStream))))

(defun set-call-log-break-point ((count INTEGER))
  :documentation "Set a call log break point to `count'.  Execution will be
interrupted right at the entry of the `count'th logged function call."
  :command? TRUE :public? TRUE
  (setq *log-break-point-counter* count))

;;; miscellaneous debugging stuff:

(defun break-program ((message STRING))
  :documentation "Interrupt the program and print `message'.  Continue after
confirmation with the user."
  :public? TRUE
  (verbatim
      :common-lisp "(CL:break message)"
      :otherwise (progn
                   (print "Program break: " message EOL EOL)
                   (when (not (yes-or-no? "Continue?"))
                     (terminate-program)))))

(defun terminate-program ()
  :documentation "Terminate and exit the program with normal exit code."
  :public? TRUE
  (verbatim
      :cpp "exit(0);"
      :java "java.lang.System.exit(0);"
      :otherwise (break-program "Don't know how to terminate the program!")))

(defun po ((thing OBJECT))
  ;; print-object function that's handy for the C++ debugger.
  (print thing EOL))


;;; Variable binding:

;;; Since local variable symbols can be transient or permanent, and since that
;;;    can change while a function is walked, we need some extra machinery to
;;;    safely compare transient with permanent symbols.

(defun (variable-eql? BOOLEAN) ((var1 SYMBOL) (var2 SYMBOL))
  ;; Return `true' if `var1' and `var2' denote the same variable.
  ;; If they are not eq, this is also the case if one of them is a transient
  ;;    symbol with a symbol-name that equals that of the other variable.
  ;; NOTE: THIS SHOULD BE SAFER AND FASTER THAN SPRINKLING THE CODE WITH
  ;;    CALLS TO `SOFT-PERMANENTIFY' AS WE DID BEFORE.
  ;; NOTE2: WE DON'T TAKE MODULE INFORMATION INTO ACCOUNT ANYMORE, ASSUMING
  ;;    THAT LOCAL VARIABLE NAMES WILL ALWAYS BE UNQUALIFIED (ONCE IN A WHILE
  ;;    WE DID GET DIFFERENT MODULES BY ACCIDENT WHICH CAUSED PROBLEMS).
  ;;    THIS ALSO MEANS WE CAN NEVER USE THIS FOR GLOBAL VARIABLES.
  (return (or (eql? var1 var2)
              (eql? (symbol-name var1) (symbol-name var2)))))

(defun (lookup-variable-table (LIKE (any-value self)))
    ((self (KEY-VALUE-LIST OF SYMBOL OBJECT)) (variable SYMBOL))
  ;; Lookup `variable' in the table `self' and return the result.
  ;; Just like the regular `lookup' but uses `variable-eql?'.
  (foreach (key value) in self
      where (variable-eql? key variable)
      do (return value))
  (return NULL))

(defun insert-at-variable-table ((self (KEY-VALUE-LIST OF SYMBOL OBJECT))
                                 (variable SYMBOL)
                                 (value OBJECT))
  ;; Insert `value' at key `variable' in the table `self'.
  ;; Just like the regular `insert-at' but uses `variable-eql?'.
  (let ((cursor (the-kv-list self)))
    (while (defined? cursor)
      (when (variable-eql? (key cursor) variable)
        (setf (value cursor) value)
        (return))
      (setq cursor (rest cursor)))
    (setf (the-kv-list self)
      (kv-cons variable value (the-kv-list self)))))

(defun push-variable-binding ((variable SYMBOL) (type TYPE-SPEC))
  ;; Push the entry <variable, type> onto *localVariableTypeTable*.
  ;; CAUTION: We explicitly permit the occurrence of duplicate keys in the
  ;;    table, and rely on the fact that 'lookup-at' will always 
  ;;    return the value of the most recently pushed entry.
  (let ((class
         ;; assumes we are never called with an anchored type:
         (type-spec-to-class type)))
    ;; Allow `null' variables for cases where the variable is optional,
    ;; such as when walking EXCEPTION-CASE forms.
    (when (null? variable)
      (return))
    ;; TO DO: ALSO CATCH CASES SUCH AS `(CONS OF BLERTCH)' AND FUNCTION RETURN
    ;;    TYPES THAT ARE UNDEFINED.
    (when (and (null? class)
               (not (eq? type @UNINITIALIZED)))
      (walk-error "No class defined for type: " (type-spec-to-base-type type))
      ;; guard against breakage:
      (setq type @UNKNOWN))

    (when (and (not (mixin-type-variables-allowed?))
               (defined? class)
               (mixin? class)
               (or (null? *methodBeingWalked*)
                   (not (mixin-method? *methodBeingWalked*))
                   ;; The first arg to a mixin method is exempt,
                   ;;    but then they don't get walked anyway:
                   (non-empty? *localVariableTypeTable*)))
      (walk-error "Variable " variable " is typed with a mixin class which is" EOL
                  " illegal when translating to a single-inheritance language"))

    (setf (the-kv-list *localVariableTypeTable*)
      (kv-cons variable type (the-kv-list *localVariableTypeTable*)))
    (maybe-rename-local-variable variable)))

(defun pop-variable-binding ()
  ;; Pop the first entry <variable, type> in the table
  ;;    *localVariableTypeTable*.
  ;; CAUTION: This operation is not normally supported by
  ;;    association lists; we are somewhat abusing the data structure.
  (let ((kvList (the-kv-list *localVariableTypeTable*)))
    (setf (the-kv-list *localVariableTypeTable*) (rest kvList))
    (typecase (value kvList)
      ;; If we stored some additional variable info, free it too:
      (KEY-VALUE-LIST (free (value kvList)))
      (otherwise NULL))
    (free-kv-cons kvList) ))

(defun (lookup-variable-type TYPE-SPEC) ((variableName SYMBOL))
  ;; Scan the local and global type tables for an entry named
  ;;    'variableName'.
  ;; If found, return the corresponding type.  Otherwise, signal an
  ;;    undeclared variable.
  (let ((entry
         (choose (defined? *localVariableTypeTable*)
                 (lookup-variable-table *localVariableTypeTable* variableName)
                 NULL))
        (type TYPE-SPEC NULL))
    (cond ((null? entry)
           (when (eq? variableName (quote NULL))
             (return @UNKNOWN))
           (setq type (lookup-global-variable-type variableName))
           (register-reference-to-global-variable variableName))
          (otherwise
           ;; In most cases, the entry associated with a variable
           ;;    will simply be its type.  However, sometimes (e.g.,
           ;;    for method inlining, we need to record more stuff
           ;;    in which case the entry will be an association list
           ;;    itself):
           (typecase entry
             (KEY-VALUE-LIST
              (setq type (lookup entry :TYPE)))
             (otherwise (setq type entry)))))
    (when (null? type)
      (walk-error "Undeclared variable " variableName)
      (return @UNKNOWN))
    (when (eq? type @UNINITIALIZED)
      (walk-error "Reference to defined but uninitialized variable "
                  variableName)
      (return @UNKNOWN))
    (return type) ))

(defun set-local-variable-info
    ((variable SYMBOL) (key KEYWORD) (info OBJECT))
  ;; Record `info' under `key' for the locally bound variable `variable'.
  ;; Note, that one can only associate additional information with a
  ;;    variable, if it has already been recorded on the local variable stack.
  (let ((entry (lookup-variable-table *localVariableTypeTable* variable)))
    (when (defined? entry)
      (typecase entry
        (KEY-VALUE-LIST
         (insert-at entry key info))
        (otherwise
         (let ((variableInfo (new KEY-VALUE-LIST)))
           (insert-at variableInfo key info)
           (insert-at variableInfo :TYPE entry)
           (insert-at-variable-table
            *localVariableTypeTable* variable variableInfo)))))))

(defun (get-local-variable-info OBJECT) ((variable SYMBOL) (key KEYWORD))
  ;; Retrieve the info stored under `key' for the locally bound `variable'.
  (let ((entry (choose (defined? *localVariableTypeTable*)
		       (lookup-variable-table *localVariableTypeTable* variable)
		       NULL)))
    (when (defined? entry)
      (typecase entry
        (KEY-VALUE-LIST
         (return (lookup entry key)))
        (otherwise
         (when (eql? key :TYPE)
           (return entry)))))
    (return NULL)))

(defun register-reference-to-global-variable ((variableName SYMBOL))
  ;; Register a reference to the global variable named 'variableName'.
  (when (defined? *currentTranslationUnit*)
    (let ((global (lookup-global-variable variableName))
          (referencedGlobals
           (referenced-globals *currentTranslationUnit*)))
      (when (and (defined? global)
                 (not (member? referencedGlobals global)))
        (insert referencedGlobals global)))))

;;; Variable naming/renaming support:

(defun (local-gensym SYMBOL) ((prefix STRING))
  ;; Return a transient symbol with a name beginning with 'prefix' and 
  ;;    ending with a gensym'd integer.
  ;; The generated name will be unique within the scope of a function
  ;;    definition so that it can be used as an anonymous local variable.
  ;; Each 'prefix' gets its own counter.
  (when (null? *localGensymTable*)
    (return (gensym prefix)))
  (let ((prefixCounter INTEGER-WRAPPER (lookup *localGensymTable* prefix)))
    (if (null? prefixCounter)
        (setq prefixCounter 0)
      (setq prefixCounter (1+ prefixCounter)))
    (insert-at *localGensymTable* prefix prefixCounter)
    (return
      (intern-transient-symbol
       (yield-gensym-name prefix prefixCounter)))))

(defun (method-gensym SYMBOL) ((prefix STRING))
  ;; Generate a globally unique gensym based on the name of the currently
  ;;    walked method and `prefix'.  This is useful for generating global
  ;;    variables or symbols associated with a particular function.  Multiple
  ;;    gensyms for the same function will be numbered consecutively starting
  ;;    from 000 similar to local gensyms.
  (let ((method *methodBeingWalked*)
        (local? FALSE))
    (when (defined? method)
      (if (method-function? method)
          (setq prefix
            (concatenate "F-" (symbol-name (slot-name method)) "-" prefix))
        (setq prefix
          (concatenate "M-" (symbol-name (slot-owner method))
                       "." (symbol-name (slot-name method))
                       "-" prefix)))
      (setq local? TRUE))
    (if local?
        (return (local-gensym prefix))
      (return (gensym prefix)))))

(defun (yield-local-variable-alias SYMBOL) ((variable SYMBOL) (level INTEGER))
  ;; Return an alias for the local `variable' which is bound at `level' >= 1,
  ;;    i.e., it shadows a variable of the same name.
  ;; The generated name will be a unique gensym, however, it is guaranteed
  ;;    that subsequent calls with the same arguments will yield the previously
  ;;    generated alias.  This is necessary, since in some cases variables
  ;;    are pushed and popped from the stack multiple times, in which case
  ;;    it is important that they wind up with the same alias.
  ;; NOTE: Assumes, that a call with <variable, level+1> was (indirectly)
  ;;    preceded by a call with <variable, level>.
  ;; TRICKY/HACK: Relies on the fact that `local-gensym' uses string prefixes
  ;;    as keys while this function uses symbols to avoid unintended
  ;;    clashes in `*localGensymTable*'.
  (safety 1 (>= level 1) "INTERNAL ERROR: Variable level must be >= 1")
  (when (null? *localGensymTable*)
    (return (local-gensym (symbol-name variable))))
  (let ((aliases (CONS OF SYMBOL) (lookup *localGensymTable* variable))
        (alias SYMBOL NULL))
    (when (null? aliases)
      (setq aliases NIL))
    (cond
     ((< (length aliases) level)
      (setq alias (local-gensym (symbol-name variable)))
      (insert-at *localGensymTable* variable (bquote (&& aliases & alias)))
      (return alias))
     (otherwise
      (return (nth aliases (1- level)))))))

(defun (rename-shadowing-local-variables? BOOLEAN) ()
  :globally-inline? TRUE
  ;; Return `true' if nested local variables that shadow a variable
  ;;    of the same name should/must be renamed.
  (return (eql? (translator-output-language) :JAVA)))

(defun maybe-rename-local-variable ((variable SYMBOL))
  ;; Check whether `variable' (which is assumed to be bound on the current
  ;;    local variable stack) needs to be renamed, and rename it if necessary.
  ;; TO DO: Figure out whether this mechanism should also handle the renaming
  ;;    of variables that clash with reserved words.
  (when (rename-shadowing-local-variables?)
    (let ((cursor (the-kv-list *localVariableTypeTable*))
          ;; the first occurrence of a variable is at level 0:
          (level -1))
      (while (defined? cursor)
        (when (variable-eql? (key cursor) variable)
          (++ level))
        (setq cursor (rest cursor)))
      (when (>= level 1)
        (set-local-variable-info
         variable :alias (yield-local-variable-alias variable level))))))

(defun (true-variable-name SYMBOL) ((variable SYMBOL))
  ;; Return the true name of `variable' as it will be used in the current
  ;;    target language.
  ;; This chases alias links for local variables that needed to be renamed
  ;;    to avoid shadowing.
  (when (rename-shadowing-local-variables?)
    (let ((alias (get-local-variable-info variable :alias)))
      (when (defined? alias)
        (return alias))))
  (return variable))


;;; Error handling support

(defun (suppress-warnings? BOOLEAN) ()
  :public? TRUE
  ;; Return `true' if the feature :suppress-warnings is enabled.
  (return
   (member? *current-stella-features* :suppress-warnings)) )

(defun (bad-argument-range? BOOLEAN)
    ((tree CONS) (minArity INTEGER) (maxArity INTEGER))
  ;; Print out a warning and return `true' if 'tree' has the wrong number of
  ;;    arguments.  A 'maxArity' of `null' indicates that there is no
  ;;    upper bound on the number of arguments.
  (let ((argNum (1- (length tree))))
    (cond
     ((< argNum minArity)
      (walk-error "Missing arguments in the expression: " EOL " " tree)
      (return TRUE))
     ((and (defined? maxArity)
           (> argNum maxArity))
      (walk-error "Too many arguments in the expression: " EOL " " tree)
      (return TRUE))
     (otherwise
      (return FALSE)))))

(defun (bad-argument-count? BOOLEAN) ((tree CONS) (arity INTEGER))
  ;; Print out a warning and return `true' if 'tree' has the wrong number of
  ;;    arguments.
  (return (bad-argument-range? tree arity arity)))

(defun (yield-illegal-statement-tree CONS) ()
  ;; Allocate just enough environment to translate a single tree.
  ;; Return a tree that flags an illegal statement.
  (special ((*localVariableTypeTable* (allocate KEY-VALUE-LIST)))
    (return
     (walk-without-type-tree
      (bquote
       (error "Attempt to execute illegal statement flagged by the translator"
              EOL "    but not yet fixed.")))) ))

(defun (yield-illegal-expression-tree OBJECT) ()
  ;; Return an expression that indicates an illegal expression.
  (return (quote ILLEGAL-EXPRESSION-FLAGGED-BY-THE-TRANSLATOR)) )

(defun (walk-dont-call-me-tree CONS TYPE-SPEC)
    ((tree OBJECT) (returnType TYPE-SPEC))
  ;; Return a tree representing a statement that shouldn't be called, and
  ;;    the type 'returnType'.
  (return (bquote (BAD-SYS & tree & (type-spec-to-base-type returnType)))
          returnType) )

(defun (illegal-tree? BOOLEAN) ((tree OBJECT))
  ;; Return `true' if the walker has flagged 'tree' as illegal.
  (return (and (cons? tree)
               (eql? (first (cast tree CONS)) (quote BAD-SYS)))))

(defun (native-class-method-inlining? BOOLEAN) ()
  ;; Return `true' if the syntax for native classes supports method inlining.
  (case (translator-output-language)
    (:common-lisp (return FALSE))
    ((:java :cpp :cpp-standalone :idl) (return TRUE))) )  ;; :java ??? HUH

;; Some simple parse-tree manipulation/optimization functions:

(defun (prognify OBJECT) ((trees CONS))
  ;; Collects 'trees' into a PROGN if necessary.  Otherwise the single
  ;; tree will be returned.  This does not save all that much, since
  ;; the CL compiler should optimize them away automatically, but
  ;; it makes the output a bit more readable, and maybe C++ can take
  ;; advantage of it.
  (case (length trees)
    (0 (return nil))
    (1 (let ((tree OBJECT (first trees)))
         (setf (first trees) NULL)
         (return tree)))
    (otherwise
     (return (bquote (progn && trees))))))

(defun (optimize-progn OBJECT) ((progn-tree CONS))
  ;; Optimizes away an unneeded PROGN.
  (case (length (rest progn-tree))
    (0 (return nil))
    (1 (let ((tree OBJECT (second progn-tree)))
         (setf (second progn-tree) NULL)
         (return tree)))
    (otherwise (return progn-tree))))

(defun (tree-to-trees CONS) ((tree OBJECT))
  ;; Converts `tree' into a list of trees for use in an implicit `progn'.
  (typecase tree
    (CONS
     (when (eql? (first tree) (quote PROGN))
       (return (rest tree))))
    (otherwise NULL))
  (return (bquote (& tree))))

  ;;
;;;;;; Automatic Coersion
  ;;

(defglobal *wrapped-type-table* (CONS OF CONS)
  (bquote
   ((@INTEGER-WRAPPER             @INTEGER)
    (@LONG-INTEGER-WRAPPER        @LONG-INTEGER)
    (@FLOAT-WRAPPER               @FLOAT)
    ;; This entry is needed by propositions.ste:
    (@NUMBER-WRAPPER              @NUMBER)
    (@STRING-WRAPPER              @STRING)
    (@MUTABLE-STRING-WRAPPER      @MUTABLE-STRING)
    (@CHARACTER-WRAPPER           @CHARACTER)
    (@BOOLEAN-WRAPPER             @BOOLEAN)
    (@FUNCTION-CODE-WRAPPER            @FUNCTION-CODE)
    (@METHOD-CODE-WRAPPER              @METHOD-CODE)
    ))
  :documentation "Table of pairs used by `wrapper-value-type' and
`type-to-wrapped-type'.")

(defun (wrapped-type-to-type TYPE) ((self TYPE))
  :documentation "Return the unwrapped type for the wrapped type `self',
or `self' if it is not a wrapped type."
  :public? TRUE
  (foreach entry in *wrapped-type-table*
           where (eq? (first entry) self)
           do (return (second entry)))
  (return self))

(defun (wrapper-value-type TYPE) ((self WRAPPER))
  :documentation "Return the type of the value stored in the wrapper `self'."
  :public? TRUE
  (let ((wrapperType (primary-type self))
        (valueType (wrapped-type-to-type wrapperType)))
    (if (eql? valueType wrapperType)
        (error "Missing *wrapped-type-table* entry")
      (return valueType))))

(defmethod (type-to-wrapped-type TYPE) ((self TYPE))
  :documentation "Return the wrapped type for the type `self',
or 'self' if it is not a bare literal type."
  :public? TRUE
  (when (null? (type-class self))
    (walk-error "Can't find a class named " self)
    (return @UNKNOWN))
  (when (subtype-of? self @OBJECT)
    (return self))
  (foreach entry in *wrapped-type-table*
           where (eq? (second entry) self)
           do (return (first entry)))
  ;; Maybe it is a synonym:
  (let ((realType (class-type (type-class self))))
    (unless (eql? self realType)
      ;; It is a synonym, try its root:
      (foreach entry in *wrapped-type-table*
               where (eq? (second entry) realType)
               do (return (first entry)))))
  ;; if it's not in the table, it's not wrappable:
  (return NULL) )                       ; RMM 1/8/97
  

;;; Tricky: For triples with the same source type, the triple with the
;;;    more general target type must precede the one with the more specific target
;;;    type.

;;; TO DO: use un/wrap-<literal> at various places to be smarter about NULL's:
(defglobal *coersion-table* (CONS OF CONS)
  ;; sourceType         targetType         coersionFunction:
  (bquote
   ((@BOOLEAN           @BOOLEAN-WRAPPER   inline-wrap-boolean)
    (@INTEGER           @INTEGER-WRAPPER   wrap-literal)      ; order dependent
    (@LONG-INTEGER      @LONG-INTEGER-WRAPPER  wrap-literal)  ; order dependent
    (@INTEGER           @BOOLEAN-WRAPPER   integer-to-boolean-wrapper) ; order dependent
    (@INTEGER           @BOOLEAN           integer-to-boolean)
    (@FLOAT             @FLOAT-WRAPPER     wrap-literal)
    (@MUTABLE-STRING    @STRING            mutable-string-to-string) ; order dependent. prefer non-mutable
    (@MUTABLE-STRING    @MUTABLE-STRING-WRAPPER    wrap-literal)     ; order dependent
    (@STRING            @STRING-WRAPPER    wrap-literal)   ; order dependent
    (@STRING            @MUTABLE-STRING    string-to-mutable-string) 
    (@STRING            @SYMBOL            intern-symbol)         ; order dependent
    (@CHARACTER         @CHARACTER-WRAPPER wrap-literal)
    (@CHARACTER         @STRING		   character-to-string)
    (@FUNCTION-CODE     @FUNCTION-CODE-WRAPPER wrap-literal)
    (@METHOD-CODE       @METHOD-CODE-WRAPPER   wrap-literal)
    (@SYMBOL            @STRING            symbol-name)
    (@BOOLEAN-WRAPPER   @BOOLEAN           inline-unwrap-boolean)
    (@INTEGER-WRAPPER   @INTEGER           wrapper-value)
    (@INTEGER-WRAPPER   @LONG-INTEGER      wrapper-value)
    (@LONG-INTEGER-WRAPPER  @LONG-INTEGER  wrapper-value)
    (@FLOAT-WRAPPER     @FLOAT             wrapper-value)
    (@NUMBER-WRAPPER    @FLOAT             number-wrapper-to-float)
    (@STRING-WRAPPER    @STRING            wrapper-value)
    (@MUTABLE-STRING-WRAPPER @MUTABLE-STRING wrapper-value)
    (@CHARACTER-WRAPPER @CHARACTER         wrapper-value)
    (@FUNCTION-CODE-WRAPPER @FUNCTION-CODE wrapper-value)
    (@METHOD-CODE-WRAPPER   @METHOD-CODE   wrapper-value)
    (@SURROGATE         @CLASS             surrogate-value)
    (@SURROGATE         @MODULE            surrogate-value)
    (@INPUT-STREAM      @NATIVE-INPUT-STREAM  native-stream)
    (@OUTPUT-STREAM     @NATIVE-OUTPUT-STREAM native-stream)
    (@NUMBER            @INTEGER           (cast <X> @INTEGER))
    (@NUMBER            @LONG-INTEGER      (cast <X> @LONG-INTEGER))
    (@NUMBER            @FLOAT             (cast <X> @FLOAT))
    (@INTEGER           @FLOAT             (cast <X> @FLOAT))
    (@INTEGER           @SINGLE-FLOAT      (cast <X> @SINGLE-FLOAT))
    ;(@LONG-INTEGER      @INTEGER           (cast <X> @INTEGER)) ;; require explicit cast
    (@LONG-INTEGER      @FLOAT             (cast <X> @FLOAT))
    (@LONG-INTEGER      @SINGLE-FLOAT      (cast <X> @SINGLE-FLOAT))
    ;; For these types rely on automatic coercion in the target language:
    (@FLOAT             @SINGLE-FLOAT      identity)
    (@FLOAT             @DOUBLE-FLOAT      identity)
    (@INTEGER           @SHORT-INTEGER     identity)
    (@INTEGER           @LONG-INTEGER      identity)
    (@INTEGER           @UNSIGNED-SHORT-INTEGER   identity)
    (@INTEGER           @UNSIGNED-LONG-INTEGER    identity)
    ))
  :documentation "Table of triples used by `lookup-coersion-method' to
locate a coersion method.")

(defun (lookup-coersion-method OBJECT)
       ((sourceType TYPE) (targetType TYPE) (expression OBJECT))
  ;; If a coersion method exists that converts an expression of type
  ;;    'sourceType' into an expression of type 'targetType', return it.
  (ignore expression)
  ;; Dereference synonyms such as FILE-NAME:
  (setq sourceType (canonical-type sourceType))
  (foreach triple in *coersion-table*
      where (and (subtype-of? sourceType (first triple))
                 (subtype-of? (second triple) targetType))
      do (return (third triple)))
  (return NULL) )

(defun (apply-coercion-method OBJECT TYPE-SPEC) ((expression OBJECT)
                                                 (sourceType TYPE)
                                                 (targetType TYPE)
                                                 (coercionMethod OBJECT))
  ;; Apply `coercionMethod' to the already walked `expression' to coerce it
  ;;    from `sourceType' to `targetType'.
  ;; Return the walked coerced expression and resulting type.
  ;; If `coercionMethod' is supplied as `null', it will be looked up first
  ;;    with `lookup-coersion-method'.
  ;; If it is a CONS, all occurrences of the symbol `<X>' will be replaced
  ;;    with `expression' before the resulting tree is walked.
  (when (null? coercionMethod)
    (setq coercionMethod
      (lookup-coersion-method sourceType targetType expression)))
  (when (null? coercionMethod)
    (return expression sourceType))
  (when (eql? coercionMethod (quote identity))
    ;; Rely on automatic coercion by the target language:
    (return expression targetType))
  (typecase coercionMethod
    (SYMBOL
     (return
       (walk-expression-tree
        (bquote (& coercionMethod & expression))
        targetType coercionMethod FALSE)))
    (CONS
     (return
       (walk-expression-tree
        ;; copy result in case there were multiple substitutions:
        (copy-cons-tree
         (substitute-cons-tree
          (copy-cons-tree coercionMethod) expression (quote <X>)))
        targetType (first coercionMethod) FALSE)))))

(defun (translating-code? BOOLEAN) ()
  ;; `true' if we are currently translating Stella code.
  (return (or (eq? *translationPhase* :WALK)
              (eq? *translationPhase* :TRANSLATE))))

;; TO DO: IMPLEMENT THROW, SO WE CAN KICK OUT HERE:
(defun (verify-type TYPE) ((self TYPE))
  ;; Check that a class has been defined for 'self'.  If not, generate
  ;;    a warning, and point 'self' at the class UNKNOWN.
  (when (and (defined? (surrogate-value self))
             (not (stella-class? (surrogate-value self))))
    (warn "Illegal object " (surrogate-value self) " found" EOL
             "   where STELLA class expected" EOL)
    (setf (type-class self) (type-class @UNKNOWN)))
  (when (and (translating-code?)
             (or (null? (type-class self))
                 (eql? (type-class self) (type-class @UNKNOWN))) )
    (walk-warn "Reference to undefined class "
               (symbol-name self))
    (setf (type-class self) (type-class @UNKNOWN)))
  (return self) )

(defun (safe-subtype-of? BOOLEAN) ((subType TYPE) (superType TYPE))
  ;; Variant of 'subtype-of?' that checks that 'subType' and 'superType'
  ;;    have classes attached to them, and generates a warning otherwise.
  (verify-type subType)
  (verify-type superType)
  (return (subtype-of? subType superType)) )

(defun warn-about-unknown-source-type ((tree OBJECT))
  ;; Print a warning in case an UNKNOWN source type of 'tree' is problematic.
  ;; Only do this if we also worry about undefined functions and methods.
  (when (warn-about-undefined-methods?)
    (typecase tree
      (SYMBOL
       ;; Either the `null' symbol, or a variable typed UNKNOWN, or a variable 
       ;; initialized by an UNKNOWN expression, or an undefined variable:
       (return))
      (CONS
       (case (first tree)
         ((VERBATIM VRLET)
          (return))
         (SYS-CALL-METHOD
          (when (or (symbol-common-lisp? (cast (third tree) SYMBOL))
                    ;; We must have had an "undefined function" warning:
                    (null? (safe-lookup-slot
                            (type-class (cast (second tree) TYPE))
                            (cast (third tree) SYMBOL))))
            (return)))
         (SYS-CALL-FUNCTION
          (when (eq? (slot-base-type 
                      (lookup-function-or-stella-function (second tree)))
                     @UNKNOWN)
            ;; Function with explicitly defined UNKNOWN return type:
            (return)))
         ((TYPED-SYS SYS-INLINE-CALL)
          (warn-about-unknown-source-type (second tree))
          (return))
         (otherwise NULL)))
      (otherwise
       (when (null? tree)
         (return))))
    (walk-error "The expression" EOL "   " tree EOL " has UNKNOWN type")))

(defun (coerce-a-tree OBJECT TYPE-SPEC)
       ((tree OBJECT) (sourceType TYPE-SPEC) (targetType TYPE-SPEC))
  ;; If 'sourceType' specializes 'targetType' return 'tree' and 'sourceType'.
  ;; Otherwise, if 'targetType' specializes 'sourceType', wrap 'tree'
  ;;    with a coersion function or a cast.
  ;; Otherwise, signal a type error.
  ;; Handling of parameterized types: If either 'sourceType' or
  ;;    'targetType' is a simple type, only the base type of the other
  ;;    parameterized type is considered (this might be dangerous).
  ;;    Only if both types are parameterized are their parameter types
  ;;    checked for compatibility also (see 'compatible-parameter-types?').
  (mv-bind (oTree oType coercible?)
      (help-coerce-a-tree tree sourceType targetType FALSE)
    (unless coercible?
      (walk-error "Type conflict: the expression:" EOL "   " tree EOL
                  " has type " (yield-type-spec-tree sourceType)
                  " but should have type " (yield-type-spec-tree targetType)))
    (return oTree oType)))

(defun (help-coerce-a-tree OBJECT TYPE-SPEC BOOLEAN)
    ((tree OBJECT) (sourceType TYPE-SPEC)
     (targetType TYPE-SPEC) (testOnly? BOOLEAN))
  ;; Helper function for 'coerce-a-tree'.  Returns as a third value whether
  ;;    a coersion could be successfully performed.
  ;; If 'testOnly?' is true, no actual coersion or casting code is generated.
  (let ((coersionFunction OBJECT NULL)
        ;; Check whether the target language needs a wider type:
        (realSourceType (target-language-type tree))
        (sourceBaseType (type-spec-to-base-type sourceType))
        (targetBaseType (type-spec-to-base-type targetType)))
    (when (eq? sourceType @UNKNOWN)
      (warn-about-unknown-source-type tree)
      (if (and (eq? tree (quote NULL))
               (defined? targetBaseType))
	  ;; cl-array-null
        (return
          (type-to-walked-null-value-tree targetType targetBaseType) targetType TRUE)
        (return tree targetType TRUE)))
    (when (defined? realSourceType)
      ;; First coerce from 'realSourceType' to 'sourceType', since we might
      ;; need more coersion or wrapping that is only defined for 'sourceType':
      (set-target-language-type tree NULL)
      (setq tree (coerce-a-tree tree realSourceType sourceType)))
    (when (eq? targetType @UNKNOWN)
      (return tree sourceType TRUE))
    (when (null? (type-class sourceBaseType))
      (walk-error "No class defined for type: " sourceBaseType)
      (return tree targetType TRUE))
    (when (and (defined? targetBaseType)
               (null? (type-class targetBaseType)))
      (walk-error "No class defined for type: " targetBaseType)
      (return tree sourceType TRUE))
    (when (sub-type-spec-of? sourceType targetType)
      (return tree sourceType TRUE))
    (when (and (defined? targetBaseType)
               (or (compatible-parameter-types? sourceType targetType)
                   ;; Allow downcasting on parameter types similar to what
                   ;;    we do for base types, e.g., cast `(SEQUENCE OF OBJECT)'
                   ;;    to `(LIST OF SYMBOL)'.
                   (and (not (array-type-specifier? sourceType))
                        (subtype-of? targetBaseType sourceBaseType)
                        (compatible-parameter-types? targetType sourceType))))
      ;; basetype mismatch -- try coersion:
      (when (and (type? sourceType)
                 (setq? coersionFunction
                        (lookup-coersion-method
                         sourceType targetBaseType tree)))
        (unless testOnly?
          (mv-setq (tree targetType)
            (apply-coercion-method
             tree sourceType targetBaseType coersionFunction)))
        (return tree targetType TRUE))
      ;; no available coersion -- try casting:
      (when (subtype-of? targetBaseType sourceBaseType)
        (when testOnly?
          (return tree targetType TRUE))
        (return
         ;; Walk the cast for proper surrogate registry:
         (walk-without-type-tree
          (bquote (& (choose (defined? realSourceType)
                             ;; If Stella knows the type, but the target
                             ;; language doesn't we can use a SAFE-CAST:
                             (quote SAFE-CAST)
                             (quote CAST))
                     & tree & targetType)))
         targetType TRUE))
      ;; try converting OBJECT to NON-OBJECT, e.g., OBJECT -> INTEGER:
      (when (and (subtype-of? targetBaseType @NON-OBJECT)
                 (and (type? sourceType)
                      (subtype-of? @WRAPPER sourceType)))
        (let ((wrapperType (type-to-wrapped-type targetBaseType)))
          (when (defined? wrapperType)
            (when testOnly?
              (return tree targetType TRUE))
            (setq coersionFunction
                  (lookup-coersion-method wrapperType targetBaseType tree))
            ;; tricky: if 'wapperType' is defined but is an abstract type,
            ;;    then it won't have a coersion function:
            (when (defined? coersionFunction)
              (mv-setq (tree targetType)
                (apply-coercion-method
                 ;; Walk the cast for proper surrogate registry:
                 (bquote (CAST & tree & wrapperType))
                 sourceType targetBaseType coersionFunction))
              (return tree targetType TRUE))))))
    ;; can't coerce or cast -- give up:
    (return tree sourceType FALSE)))

(defun (coercible? BOOLEAN)
    ((tree OBJECT) (sourceType TYPE-SPEC) (targetType TYPE-SPEC))
  ;; Return `true' if 'tree' can be coerced from 'sourceType' to 'targetType'.
  (mv-bind (oTree oType coercible?)
      (help-coerce-a-tree tree sourceType targetType TRUE)
    (ignore oTree oType)
    (return coercible?)))

(defun (walking-expression? BOOLEAN) ()
  ;; `true' if we are currently walking a Stella expression.
  (return (not (eql? *targetType* @VOID))))

(defun (walk-expression-tree OBJECT TYPE-SPEC)
       ((expTree OBJECT) (targetType TYPE-SPEC)
        (operatorName SYMBOL) (vrletIsOk? BOOLEAN))
  ;; Walk 'expTree' as an expression.  Its return type is the source type.
  ;; While walking 'tree' the special variable '*targetType*' is bound to
  ;;    'targetType' to indicate that an expression is being walked.
  ;; Coerce the source type into the target type with 'coerce-a-tree' (this
  ;;    defines 'targetType' if it was unknown).  Signal a type error if
  ;;    they are not compatible.
  ;; Return the walked tree and the possibly modified 'targetType'.
  ;; TO DO: ADD CHECK THAT 'expTree' RETURNS ONLY A SINGLE VALUE.
  (special ((*targetType* (choose (defined? targetType)
                                  targetType
                                  @UNKNOWN)))
    (mv-bind (oExp sourceType)
        (walk-a-tree expTree)
      (when (vrlet-expression? oExp)
        (unless vrletIsOk?
          (walk-error "Illegal procedural expression as argument to "
                      operatorName ":" EOL "   " expTree))
        (return oExp sourceType))
      (when (and (void? sourceType)
                 (not (void? targetType)))
        (walk-error "Illegal argument to " operatorName ":" EOL "   "
                    oExp EOL
                    "The argument must be an expression, not a statement")
        (return (walk-dont-call-me-tree oExp sourceType)))
      (when (null? sourceType)
        (setq sourceType @UNKNOWN))
      (when (null? targetType)
        (setq targetType sourceType))
      (return (coerce-a-tree oExp sourceType targetType)))))

(defun (compute-expression-type TYPE-SPEC) ((expression OBJECT) (wrap? BOOLEAN))
  ;; Determine the type of `expression' by walking it and return the result.
  ;; If `wrap?' is TRUE return the wrapped version of literal types.
  ;; This is non-destructive and can handle VRLETs.  Assumes that it is called
  ;;    during code walking with all the proper top-level data structures set up.
  (let ((walkedTree
         (walk-a-tree
          (bquote (let ((x & (copy-cons-tree expression)))))))
        (typeSpec
         ;; UGLY AND BRITTLE: we key-in on the fact that the type of the first
         ;; variable of the outermost `let' expression is what we want (this
         ;; works for VRLETs and regular expressions alike):
         (cons-tree-nth walkedTree 1 1 0 1)))
    (if wrap?
        (return
          (choose (sub-type-spec-of? typeSpec @LITERAL)
                  (type-to-wrapped-type (type-spec-to-base-type typeSpec))
                  typeSpec))
      (return typeSpec))))

(defun (walk-without-type-tree OBJECT) ((tree OBJECT))
  ;; Return only one value, the canonicalized tree, on the assumption that
  ;;    the calling function already knows the type of 'tree'.
  (mv-bind (oTree unusedTypeSpec)
           (walk-a-tree tree)
    (ignore unusedTypeSpec)
    (return oTree) ))


  ;;
;;;;;; Generic walk functions
  ;;

;;; Storage note:  Conceptually, the parse tree being walked is transformed
;;;    destructively.  The actual walk strategy is a blend of destructive and
;;;    substitutional operations:  Each walk function returns a tree that
;;;    represents the result of its transformations.  The tree may have the
;;;    same root as the tree passed into it, or it may be a new tree, one that
;;;    usually incorporates subtrees from the original tree.  It is the
;;;    responsibility of each walk function to explicitly free any discarded
;;;    subtrees, i.e., the parse tree returned by the walk function is the
;;;    only structure that must subsequently be freed up.

(defun (walk-list-of-trees CONS) ((trees CONS))
  ;; Convert each parse tree in 'trees' into an elemental tree.
  ;; Return the transformed list of trees.
  (let ((cursor trees))
    (while (non-empty? cursor)
      (setf (value cursor) (walk-statement (value cursor) FALSE))
      (setq cursor (rest cursor)))
    (return trees) ))

(defun (walk-list-of-statements CONS) ((trees CONS))
  ;; Similar to `walk-list-of-trees' but ignore atomic expression statements.
  (let ((oTrees NIL))
    (foreach oTree in (walk-list-of-trees trees)
        where (cons? oTree)
        collect oTree into oTrees)
    (return oTrees)))

(defun (walk-statement OBJECT) ((tree OBJECT) (warnOnAtom? BOOLEAN))
  ;; Walk 'tree'.
  ;; If 'tree' is atomic, generate a warning.
  ;; If 'tree' expands to a VRLET, convert it to an ordinary LET.
  (mv-bind (oTree unusedTypeSpec)
           (walk-a-tree tree)
    (ignore unusedTypeSpec)
    (typecase oTree
      (CONS
        (when (eql? (first oTree) (quote VRLET))
          (setq oTree (eliminate-vrlet-statement oTree))))
      (otherwise
       (when (and warnOnAtom?
                  (defined? oTree)
                  (not (eql? oTree (quote NULL))))
         (walk-warn "Expression found where statement expected: " tree))))
    (return oTREE) ))

(defun (eliminate-vrlet-statement CONS) ((tree CONS))
  ;; 'tree' is a VRLET expression that appears as a statement rather
  ;;    than as an expression.
  ;; Convert it into an ordinary LET (the last value will be clipping out
  ;;    automatically by `walk-list-of-statements' if it is atomic).
  (setf (first tree) (quote LET))
  (return (walk-a-tree tree)))

(defun (sys-tree CONS TYPE-SPEC) ((tree OBJECT) (typeSpec TYPE-SPEC))
  ;; Wrap 'tree' with a SYS operator that prevents the walker from
  ;;    walking it a second time.
  (typecase tree
    (CONS (case (first tree)
            (VOID-SYS (when (void? typeSpec)
                        (return tree typeSpec)))
            (TYPED-SYS (when (eql? (third tree) typeSpec)
                         (return tree typeSpec)))
            (VRLET (return tree typeSpec))
            (otherwise NULL)))
    (otherwise NULL))
  (if (void? typeSpec)
    (return (bquote (VOID-SYS & tree)) @VOID)
    (return (bquote (TYPED-SYS & tree & typeSpec)) typeSpec)) )

(defun (walked-expression-type TYPE-SPEC) ((tree OBJECT))
  ;; Assume 'tree' is the result of walking an expression.
  ;; Try to return its result type without rewalking 'tree'.
  (typecase tree
    (CONS
     (when (eq? (first tree) (quote TYPED-SYS))
       (return (third tree))))
    (WRAPPER
     (return (wrapped-type-to-type (primary-type tree))))
    (otherwise NULL))
  (return @UNKNOWN))

(defun (walked-expression-expression OBJECT) ((tree OBJECT))
  ;; Assume 'tree' is the result of walking an expression.
  ;; Return the actual walked expression which unwraps it from any
  ;;    SYS-TREE or TYPED-SYS wrappers.
  (typecase tree
    (CONS
     (case (first tree)
       ((VOID-SYS TYPED-SYS)
        (return (second tree)))
       (otherwise NULL)))
    (otherwise NULL))
  (return tree))

;;; If we are translating to C++, virtual methods in the class
;;;   hierarchy must have identical signatures.  Hence, the return
;;;   type of a virtual method is the return type of the most
;;;   general virtual method.  We explicitly downcast the results
;;;   of method calls to their original, more specific return types.

;;; Example: (ptrans (allocate-iterator (make-list)))

;;; Here the C++ translation of 'allocate-iterator' has to return an 
;;;   ITERATOR, since that is its return type in its definition on 
;;;   COLLECTION which is a superclass of LIST.

(defun (need-identical-method-signatures? BOOLEAN) ()
  ;; Return `true' if the target language requires methods to have
  ;;    identical signatures.
  (case (translator-output-language)
    ((:cpp :cpp-standalone :java) (return TRUE))
    (otherwise (return FALSE))))

(defun (compute-most-general-return-type TYPE-SPEC)
    ((method METHOD-SLOT) (returnType TYPE-SPEC))
  ;; Computes the most general return type of 'method' in the virtual
  ;;    method hierarchy.
  ;; TO DO: THIS SHOULD REALLY ALWAYS RETURN A PROPER TYPE-SPEC INSTEAD OF
  ;;    REDUCING THEM TO A BASE TYPE.  HOWEVER, IF WE DO THAT WE ALSO HAVE
  ;;    TO UPGRADE "REAL-TYPE" COERCION, SINCE IT CURRENTLY DOES NOT TOLERATE
  ;;    COERCION FROM, FOR EXAMPLE, (CONS OF OBJECT) TO (CONS OF CONS), WHILE
  ;;    COERCION FROM CONS TO (CONS OF CONS) WORKS FINE.  THIS WILL NEED TO
  ;;    BE REVISITED IF WE WANT TO IMPLEMENT ARRAY ELEMENT TYPE NARROWING.
  ;;    MOST PROBABLY, `compute-real-slot-type' WILL NEED FIXING TOO.
  (let ((mostGeneralReturnType returnType)
	(mostGeneralMethod method))
    (while (defined? (slot-direct-equivalent mostGeneralMethod))
       (setq mostGeneralMethod (slot-direct-equivalent mostGeneralMethod))
       ;; Guard against anchored return types, e.g., for 'first' on SEQUENCE:
       (unless (eq? (slot-base-type mostGeneralMethod) @UNKNOWN)
         ;; Is this type really always more general than where we started?
         ;; Probably.  Slot inheritance should insure that:
         (if (array-type-specifier? mostGeneralReturnType)
             (setq mostGeneralReturnType
               (compute-return-type-spec
                mostGeneralMethod (slot-owner mostGeneralMethod)))
           (setq mostGeneralReturnType (slot-base-type mostGeneralMethod)))))
    (return mostGeneralReturnType)))

(defun (compute-real-slot-type TYPE-SPEC)
    ((slot STORAGE-SLOT) (firstArgType TYPE-SPEC) (returnType TYPE-SPEC))
  ;; Computes the real type for 'slot' as it has to be used in its
  ;;   implementation in the target language.
  (let ((slotType returnType)
        (canonicalSlot (canonical-slot slot))
        (nativeSlotHome CLASS NULL))
    (when (native-slot? canonicalSlot)
      (setq nativeSlotHome
        (native-slot-home slot (type-spec-to-class firstArgType))))
    (if (defined? nativeSlotHome)
        (setq slotType
          (type-spec-to-base-type
           (compute-return-type-spec
            (lookup-slot nativeSlotHome (slot-name canonicalSlot))
            (class-type nativeSlotHome))))
      (setq slotType
        (type-spec-to-base-type
         (compute-return-type-spec
          slot (type-spec-to-base-type firstArgType)))))
    ;; Check whether there really was a base type difference, and
    ;; keep the original (possibly parametric) type if there wasn't:
    (when (eql? slotType (type-spec-to-base-type returnType))
      (setq slotType returnType))
    (return slotType)))

(defun (sys-tree-if-needed OBJECT TYPE-SPEC)
    ((slot SLOT) (tree OBJECT) (firstArgType TYPE-SPEC) (returnType TYPE-SPEC))
  ;; Records type information of a walked 'tree' in a TYPED-SYS tree
  ;;     similar to 'sys-tree', but only if necessary.
  ;; 'tree' must be the result of walking a call to a 'slot'
  ;;     (method call or slot lookup).
  ;; Situations where this is necessary are:
  ;; (1) If 'slot' has an anchored type, since rewalking such a tree would
  ;;     also have to rewalk the object reference to properly recover the
  ;;     full return type.
  ;; (2) If the return type of the 'tree' has to be different (wider) in
  ;;     the target language than the type known by Stella, e.g., for methods
  ;;     that have ancestors with different return types, or for renaming
  ;;     slots whose type is narrower than the type of the slot they rename,
  ;;     or for slots that have to be redefined on subclasses due to different
  ;;     parameters types.  In these cases the type required by the target
  ;;     language is recorded as a fourth element in the TYPED-SYS tree.
  ;; Otherwise, 'tree' and 'returnType' are returned as is.
  (when (and (defined? slot)
             (not (procedural-expression? tree)))
    (typecase slot
      (METHOD-SLOT
       ;; Check for more general methods if necessary:
       (when (and (not (method-function? slot))
                  (need-identical-method-signatures?))
         (let ((mostGeneralReturnType
                (compute-most-general-return-type slot returnType)))
           (unless (eq? returnType mostGeneralReturnType)
             (return
               (set-target-language-type
                (sys-tree tree returnType)
                mostGeneralReturnType))))))
      (STORAGE-SLOT
       (let ((realSlotType
              (compute-real-slot-type slot firstArgType returnType))
             (realSlot SLOT NULL))
         (unless (eql? returnType realSlotType)
           (when (and (eql? realSlotType @UNKNOWN)
                      (not (eql? slot (setq realSlot
                                        (slot-from-expression-tree tree))))
                      (method-slot? realSlot))
             ;; We accessed an abstract storage slot via an access method
             ;;    (e.g., ARGUMENT-LIST-ITERATOR.VALUE):
             (return
               (sys-tree-if-needed realSlot tree firstArgType returnType)))
           (return
             (set-target-language-type
              (sys-tree tree returnType)
              realSlotType))))))
    ;; Check if 'slot' has an anchored type:
    (let ((slotType (slot-type-specifier slot)))
      (when (and (defined? slotType)
                 (or (anchored-type-specifier? slotType)
                     (exists ts in (specifier-parameter-types
                                    (cast slotType
                                          PARAMETRIC-TYPE-SPECIFIER))
                             where (anchored-type-specifier? ts))))
        (if (and (anchored-type-specifier? slotType)
                 (not (eq? (translator-output-language) :common-lisp)))
            ;; Record the base type of the slot as the type
            ;; that needs to be used by the target language:
            (return
              (set-target-language-type
               (sys-tree tree returnType)
               (choose (eq? (slot-base-type slot) @UNKNOWN)
                       (type-spec-to-base-type returnType)
                       (slot-base-type slot))))
          (return (sys-tree tree returnType))))))
  (return tree returnType))

(defun (target-language-type TYPE) ((tree OBJECT))
  ;; Checks whether 'tree' is a TYPED-SYS with a target language type.
  ;;    If so it returns the target language type, `null' otherwise.
  (typecase tree
    (CONS
      (when (and (eq? (first tree) (quote TYPED-SYS))
                 (eq? (length tree) 4))
        (return (fourth tree))))
    (otherwise NULL))
  (return NULL))

(defun (set-target-language-type CONS TYPE-SPEC) ((sysTree CONS) (type TYPE))
  ;; Sets the target language type of a TYPED-SYS 'sysTree' to 'type'.
  ;;    Returns the modified tree and the actual narrower type.
  (if (eq? (length sysTree) 4)
      (setf (fourth sysTree) type)
    (setf (rest (rest (rest sysTree))) (cons-list type)))
  (return sysTree (third sysTree)))

(defun (walk-a-tree OBJECT TYPE-SPEC) ((tree OBJECT))
  ;; Walk "tree", replacing complex forms by more elementary ones,
  ;;    and collecting and verifying type information.
  ;; Return two values, the transformed tree and the static type of "tree".
  (return (help-walk-a-tree tree)))

(defun (help-walk-a-tree OBJECT TYPE-SPEC) ((tree OBJECT))
  ;; Work-horse for 'walk-a-tree'.
  ;; Extracted the functionality, so 'walk-a-tree' can be "advised"
  ;;    for debugging purposes.
  (if (null? tree)
      (return NULL @UNKNOWN)
    (typecase tree
      (CONS
       (when (nil? tree) (return NIL @CONS))
       (when (cons? (value tree))
         (walk-error "Unimplemented or illegal parse tree: " tree)
         (return tree @VOID))
       (unless (cons? (rest tree))
         (walk-error "Illegal dotted pair or list*")
         (return tree @VOID))
       (case (first tree)
         (VOID-SYS (return tree @VOID))         ; already-walked tree
         (TYPED-SYS (return tree (third tree))) ; already-walked tree
         (SYS-FOREACH (return tree @VOID))      ; already-walked tree
         (BAD-SYS (return tree (third tree)))   ; already-walked-tree
         ((SETQ SYS-SET-DEFAULT) (return (walk-setq-tree tree)))
         (SETF (return (walk-setf-tree tree)))
         (SLOT-VALUE (return (walk-slot-value-tree tree)))
         (SLOT-VALUE-SETTER (return (walk-slot-value-setter-tree tree)))
         ((AREF AREF-SETTER) (return (walk-aref-tree tree)))
         (PROGN
          (setf (rest tree) (walk-list-of-statements (rest tree)))
          (return (sys-tree tree @VOID)))
         (WITH-PROCESS-LOCK (return (walk-with-process-lock-tree tree)))
         (LOOP (return (walk-loop-tree tree)))
         (LET (return (walk-let-tree tree)))
         ;; translation of VRLET depends on context:
         (VRLET (return tree @UNKNOWN))
         (VALUES (return (walk-values-tree tree)))
         ((SPECIAL SYS-SPECIAL) (return (walk-special-tree tree)))
         ((CAST SAFE-CAST) (return (walk-cast-tree tree)))
         (RETURN (return (walk-return-tree tree)))
         (MV-SETQ (return (walk-mv-setq-tree tree)))
         (MV-BIND (return (walk-mv-bind-tree tree)))
         ((BREAK CONTINUE) (return (walk-loop-exit-tree tree)))
         (WHILE (return (walk-while-tree tree)))
         ((FOREACH EXISTS FORALL SOME SETOF SET-OF SELECT)
          (return (walk-foreach-tree tree)))
         ((IF WHEN UNLESS) (return (walk-conditional-tree tree)))
         (CHOOSE (return (walk-choose-tree tree)))
         ((AND OR NOT) (return (walk-boolean-tree tree)))
         (COND (return (walk-cond-tree tree)))
         (CASE (return (walk-case-tree tree)))
         (TYPECASE (return (walk-typecase-tree tree)))
         ((EQ? EQL? =) (return (walk-equality-tree tree)))
         ((+ - * /) (return (walk-arithmetic-tree tree)))
         (QUOTE (return (walk-quoted-tree tree)))
         (BQUOTE (return (walk-bquote-tree tree)))
         ((PRINT-STREAM PRINT-NATIVE-STREAM)
          (return (walk-print-stream-tree tree)))
         ((NEW ALLOCATE LOCAL-NEW) (return (walk-new-tree tree)))
         (MAKE (return (walk-make-tree tree)))
         ((FUNCALL SYS-CALL-FUNCTION-CODE SYS-CALL-METHOD-CODE)
          (return (walk-funcall-tree tree)))
         (THE-CODE (return (walk-the-code-tree tree)))
	 (SIGNAL-EXCEPTION (return (walk-signal-exception-tree tree)))
         (EXCEPTION-CASE (return (walk-exception-case-tree tree)))
         ((UNWIND-PROTECT SYS-UNWIND-PROTECT)
          (return (walk-unwind-protect-tree tree)))
         (VERBATIM (return (walk-verbatim-tree tree)))
         (INLINE (return tree @VOID))
         ;;(IGNORE (return tree @VOID)) ;; handled by a macro now
         ((SYS-SLOT-VALUE SYS-SLOT-VALUE-SETTER
           SYS-CALL-METHOD SYS-CALL-METHOD-SETTER SYS-CALL-FUNCTION)
          (return (walk-sys-call-tree tree)))
         (SYS-NEW (return tree (second tree)))
         ((DEFCLASS DEFMETHOD DEFUN DEFMACRO STARTUP-TIME-PROGN
                    DEFGLOBAL DEFSPECIAL DEFCONSTANT)
          (walk-error
           "Illegal declaration -- must appear as a top-level statement;"
           EOL "   not nested within other statements.")
          (return NULL @VOID))
         (otherwise
          (if (symbol? (first tree))
              (return (walk-call-slot-tree tree))
            (progn
              (walk-error
               "Illegal expression where method name expected:" EOL "   "
               (first tree))
              ;; CONSIDER RETURNING SOMETHING THAT'S LEGAL:
              (return (walk-dont-call-me-tree tree @VOID)))))))
      (otherwise
       (return (walk-atomic-tree tree))))))

(defun (walk-a-cons-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Variant of 'walk-a-tree' that expects and returns a 'tree' of type CONS.
  ;; Can be used instead of a cast wherever a CONS is needed instead of
  ;;    an OBJECT.
  (mv-bind ((oTree OBJECT) (oType TYPE-SPEC))
      (walk-a-tree tree)
    (return oTree oType)))

  ;;
;;;;;; Symbol registration
  ;;

;; Support for recording symbols whose IDs get hardcoded into
;; translated code (e.g., in case statements, calls to 'get-sym', etc.).
;; At the end of translation the recorded symbols can be used to
;; generate startup code that recreates the symbol table appropriately.

#||
(defclass symbol-registry-info (standard-object)
  :public-slots
  ((global-variable-name :type GENERALIZED-SYMBOL)
   (global-variable-module :type MODULE)))

(defglobal *symbol-registry*
    (HASH-TABLE OF GENERALIZED-SYMBOL SYMBOL-REGISTRY-INFO)
    (new (HASH-TABLE OF GENERALIZED-SYMBOL SYMBOL-REGISTRY-INFO)))
||#

(defglobal *symbol-registry*
    (HASH-TABLE OF GENERALIZED-SYMBOL GENERALIZED-SYMBOL)
    (new (HASH-TABLE OF GENERALIZED-SYMBOL GENERALIZED-SYMBOL))
  :public? TRUE)

;; Since we can't iterate over hash tables, we need an
;; extra list to represent the set of recorded symbols:
(defglobal *symbol-set* (LIST OF GENERALIZED-SYMBOL)
  (new (LIST OF GENERALIZED-SYMBOL)))

(defspecial *currentFile* STRING NULL
  :public? TRUE
  :documentation "Name of file that is currently being translated.
A NULL value indicates an incremental translation.")

(defun (incremental-translation? BOOLEAN) ()
  ;; Return `true' if the current translation is incremental.
  (return (null? *currentFile*)))

(defun (construct-symbol-constant-name STRING) ((symbol GENERALIZED-SYMBOL))
  ;; Construct the appropriate native language name for 'symbol'
  ;; Helping function for walker and translator code.
  (let ((prefix STRING NULL)
        (environmentName STRING ""))
    ;; environmentName is the Module name for Java & incremental and
    ;;    the Module name plue file name for other cases.
    (when (defined? (interned-in symbol))
      (setq environmentName 
	(concatenate (module-name (interned-in symbol)) "-")))
    (unless (or (incremental-translation?)
		(eq? (translator-output-language) :java))
      (setq environmentName 
	(concatenate (string-upcase *currentFile*) "-" environmentName)))

    ;; For Java, we encode the module name into the symbol-variable
    ;; name, since symbols with the same name from multiple Stella
    ;; modules may end up in the same Java package.  Since all Java
    ;; global names are in the same Flotsam class, we need to
    ;; de-conflict the names using the module.
    ;;   For other languages, the file name is used and the module
    ;; of the symbol object will provide a pointer to the module itself.
    (typecase symbol
      (SYMBOL (setq prefix "SYM-"))
      (SURROGATE (setq prefix "SGT-"))
      (KEYWORD (setq prefix "KWD-")))
    (return (concatenate prefix environmentName (symbol-name symbol))) ))

(defun (yield-symbol-constant-name SYMBOL) ((symbol GENERALIZED-SYMBOL))
  ;; Convert 'symbol' representing a symbol/surrogate/keyword constant
  ;;    into a native language symbol/surrogate/keyword constant identifier.
  (return (intern-symbol-in-module 
           (construct-symbol-constant-name (permanentify symbol))
           *module*
           TRUE)))

(defun (create-startup-symbol SYMBOL) ((symbol GENERALIZED-SYMBOL))
  ;; Create a startup-time form for defining a softcoded 'symbol'.
  ;; Return the variable's name.
  (let ((symbolModule *module*)
        (symbolConstant (yield-symbol-constant-name symbol))
        (symbolConstantName (symbol-name symbolConstant))
        (symbolConstantTypeTree (yield-type-spec-tree (primary-type symbol)))
        (lispPackage (lisp-package symbolModule))
	(tree CONS NULL))
    ;; Avoid "undefined special" warnings during incremental translation:
    (when (incremental-translation?)
      (verbatim
          :common-lisp
          "(CL:proclaim 
             `(CL:special ,(CL:intern symbolConstantName lispPackage)))"
        :otherwise NULL))
    ;; Generate the symbol variable:
    (setq tree
      (bquote 
       (defglobal & symbolConstant
                  & symbolConstantTypeTree
                  NULL
		  :public? TRUE)))
    (walk-auxiliary-tree tree)
    ;; Generate the initialization code:
    (setq tree
      (bquote 
       (startup-time-progn :symbols
         (setq & symbolConstant
               (safe-cast
                (intern-rigid-symbol-wrt-module
                 & (wrap-literal (symbol-name symbol))
                 ;; Only supply a module if we really have to:
                 & (choose (or (eql? (interned-in symbol) *module*)
                               (keyword? symbol))
                           (bquote NULL)
                           (bquote
                            (get-stella-module
                             & (wrap-literal 
				(module-full-name (interned-in symbol)))
                             TRUE)))
                 ;; Dereference the xxx-SYM's right here:
                 & (wrap-literal
                    (choose (keyword? symbol)
                            KEYWORD-SYM
                            (choose (surrogate? symbol)
                                    SURROGATE-SYM
                                    SYMBOL-SYM))))
                & symbolConstantTypeTree)))))
    (walk-auxiliary-tree tree)
    (return symbolConstant)))

;; BUG: FOR HARDCODED SYMBOLS THIS DOESN'T WORK FOR NON-STELLA MODULES.

#||
(defun register-symbol ((symbol GENERALIZED-SYMBOL))
  ;; Register a symbol for creation at startup time
  (setq symbol (permanentify symbol))
  (unless (defined? (lookup *symbol-registry* symbol))
    (insert-at *symbol-registry* symbol symbol)
    (insert *symbol-set* symbol)
    (unless (use-hardcoded-symbols?)
      (create-startup-symbol symbol))))
||#

(defun (register-symbol GENERALIZED-SYMBOL) ((symbol GENERALIZED-SYMBOL))
  ;; Register a symbol for creation at startup time, and for
  ;;  non-hardcoded symbols, keep a pointer to the global variable name.
  (setq symbol (permanentify symbol))
  (let ((registeredSymbol (lookup *symbol-registry* symbol)))
    (unless (defined? registeredSymbol)
      (insert *symbol-set* symbol)
      (if (use-hardcoded-symbols?)
	  (setq registeredSymbol symbol)
	(setq registeredSymbol (create-startup-symbol symbol)))
      (insert-at *symbol-registry* symbol registeredSymbol))
    (return registeredSymbol) ))

(defun clear-symbol-registry ()
  (foreach symbol in *symbol-set*
           do (remove-at *symbol-registry* symbol))
  (clear *symbol-set*))

(defun (yield-hardcoded-intern-registered-symbols-tree CONS) ()
  ;; Create a 'startup-time-progn' that interns symbols, surrogates
  ;;    and keywords according to the current state of '*symbol-set*'.
  ;; This version hardcodes the symbols, i.e., they are assigned fixed
  ;;    offsets in the symbol table
  (let ((internTrees (bquote (startup-time-progn :symbols))))
    (foreach symbol in *symbol-set*
        collect (bquote
                 (& (choose (symbol? symbol)
                            (quote intern-symbol-at)
                            (choose (surrogate? symbol)
                                    (quote intern-surrogate-at)
                                    (quote intern-keyword-at)))
                    & (wrap-literal (symbol-name symbol))
                    & (wrap-literal (symbol-id symbol))))
        into internTrees)
    (return internTrees)))

  ;;
;;;;;; 'walk-atomic-tree'
  ;;

(defmethod (walk-atomic-tree OBJECT TYPE-SPEC) ((self OBJECT))
  (error "walk-atomic-tree: Not defined on " self)
  ;  (return NULL NULL)
  )

(defmethod (walk-atomic-tree OBJECT TYPE-SPEC) ((self WRAPPER))
  (return self (wrapper-value-type self)) )

(defun (lookup-constant-symbol TYPE) ((self SYMBOL))
  ;; Return the declared type of the constant symbol 'self',
  ;;   or `null' if 'self' is not a constant symbol.
  ;; NOTE: This is probably semi-obsolete.
  ;; IMPORTANT: ALL OF THESE CONSTANTS MUST REALLY BE CONSTANTS IN THE
  ;;    TARGET LANGUAGES AND NOT THEMSELVES REQUIRE INITIALIZATION CODE
  ;;    TO RUN; OTHERWISE INITIALIZATION OF SPECIALS MIGHT BE INCORRECT!
  (case self
    (NULL (return @UNKNOWN))
    (TRUE (return @BOOLEAN))
    (FALSE (return @BOOLEAN))
    (otherwise (return NULL))))

(defun (constant-symbol? BOOLEAN) ((symbol SYMBOL))
  ;; Return `true' if 'symbol' is declared as a constant.
  (return (defined? (lookup-constant-symbol symbol))))

(defun (walk-constant-symbol SYMBOL TYPE) ((self SYMBOL))
  ;; Walk the constant symbol 'self'.
  (return self (lookup-constant-symbol self)))

(defmethod (walk-atomic-tree OBJECT TYPE-SPEC) ((self SYMBOL))
  (when (constant-symbol? self)
    (return (walk-constant-symbol self)))
  (when (inline-variable-reference? self)
    (return (walk-inline-variable-reference self)))
  (let ((trueName (true-variable-name self))
        (type (lookup-variable-type self)))
    (if (eql? trueName self)
        (return self type)
      (return (sys-tree trueName type) type))))

(defmethod (walk-atomic-tree OBJECT TYPE-SPEC) ((self KEYWORD))
  (register-symbol self)
  (return self @KEYWORD) )

(defmethod (walk-atomic-tree OBJECT TYPE-SPEC) ((self SURROGATE))
  (register-symbol self)
  (return self @SURROGATE) )

(defun (atomic-expression? BOOLEAN) ((tree OBJECT))
  ;; Return `true' if `tree' represents an atomic STELLA expression.
  (typecase tree
    (CONS
     (case (first tree)
       (TYPED-SYS
        (return (atomic-expression? (second tree))))
       (otherwise NULL))
     (return FALSE))
    (otherwise
     (return TRUE))))

(defun (variable-expression? BOOLEAN) ((tree OBJECT))
  ;; Return `true' if `tree' is a STELLA expression representing a variable.
  (typecase tree
    (CONS
     (case (first tree)
       (TYPED-SYS
        (return (variable-expression? (second tree))))
       (otherwise NULL))
     (return FALSE))
    (SYMBOL
     (return TRUE))
    (otherwise
     (return FALSE))))

  ;;
;;;;;; transformation of VRLET expressions
  ;;

;;; These procedures handle the problem of a procedural statement occuring
;;;    where the syntax requires an expression.  They move the bulk of
;;;    the procedural code outside of the surrounding statement, leaving
;;;    only a variable inside to represent the value of the procedural
;;;    computation.
;;; Boolean procedural expressions are a special case; the code handles
;;;    the case that the procedural expression is nested within 'AND', 'OR,
;;;    etc. statements.

(defun (vrlet-expression? BOOLEAN) ((tree OBJECT))
  ;; Return `true' if 'tree' is headed by the symbol 'VRLET'.
  (return (and (cons? tree)
               (eq? (value (cast tree CONS)) (quote VRLET)))) )

(defun (procedural-expression? BOOLEAN) ((tree OBJECT))
  ;; Return `true' if 'tree' contains the symbol 'VRLET'.
  (return (and (cons? tree)
               (or (eq? (value (cast tree CONS)) (quote VRLET))
                   (exists term in (rest (cast tree CONS))
                           where (procedural-expression? term))))) )

(defun (substitute-once BOOLEAN)
       ((expression OBJECT) (newTree OBJECT) (oldTree OBJECT))
  ;; Search "expression" looking for "oldTree".  When found
  ;;    substitute "newTree".  Return `true' iff a substitution
  ;;    occurred.
  ;; Assumes that 'expression' does not equal 'oldTree'.
  ;; CAUTION: Destructive operation.
  (typecase expression
    (CONS
     (when (not (nil? expression))
       (when (eql? (value expression) oldTree)
         (setf (value expression) newTree)
         (return TRUE))
       (return
         (or (substitute-once (value expression) newTree oldTree)
             (substitute-once (rest expression) newTree oldTree)))))
    (otherwise NULL))
  (return FALSE))

(defun (transform-vrlet-expression CONS TYPE-SPEC)
       ((statement CONS) (vrExpression CONS))
  ;; Situation: The form 'statement' contains 'vrExpression', which
  ;;    is a VRLET statement, i.e., 'vrExpression' is illegal.
  ;; Return a form (a statement) in which the procedural code
  ;;    'vrExpression' has been moved outside of 'statement', with
  ;;    a variable containing the result being substituted for
  ;;    'vrExpression' within 'statement', and with 'statement'
  ;;    placed after 'vrExpression'.
  ;; CAUTION: Destructive operation.
  (safety 2 (eql? (value vrExpression) (quote VRLET))
          "Non-VRLET encountered unexpectedly.")
  (let ((cursor CONS NULL)
        (lastStatement OBJECT NULL))
    ;; replace 'vrExpression' by :PLACE-WHERE-VRLET-WAS inside of 'statement':
    (substitute-once statement :PLACE-WHERE-VRLET-WAS vrExpression)
    (setf (value vrExpression) (quote LET))   ; substitute 'LET for 'VRLET
    ;; skip past declaration, and destructively modify 'vrExpression', replacing
    ;;    its last statement (guaranteed to be an expression) by 'statement'.
    (setq cursor (rest (rest vrExpression)))
    (while (non-empty? cursor)
      (when (empty? (rest cursor))
        ;; find the last statement in 'vrLet' and then operate:
        (setq lastStatement (value cursor))
        (setf (value cursor) statement)
        (break))
      (setq cursor (rest cursor)))
    ;; replace :PLACE-WHERE-VRLET-WAS by 'lastStatement' inside of 'statement':
    (substitute-once statement lastStatement :PLACE-WHERE-VRLET-WAS)
    (return
     (walk-a-cons-tree vrExpression)) ))

(defun (help-transform-boolean-procedural-expression CONS)
       ((expression OBJECT) (testVariable SYMBOL))
  ;; Helping function for 'transform-boolean-procedural-expression'.
  ;; Return a list of trees representing a code body that sets 'testVariable'
  ;;    to TRUE iff 'expression' evaluates to `true'.
  (when (or (not (cons? expression))
            (not (procedural-expression? expression)))
    (return (bquote ((setq & testVariable & expression)))))
  (let ((exp CONS expression)
        (operator (value exp))
        (firstArg (second exp))
        (otherArgs (rest (rest exp))))
    (case operator
      (AND
       (cond
        ((empty? otherArgs)
         (return
          (help-transform-boolean-procedural-expression firstArg testVariable)))
        ((procedural-expression? firstArg)
         (return
          (bquote (&& (help-transform-boolean-procedural-expression
                       firstArg testVariable)
                      (when & testVariable
                            && (help-transform-boolean-procedural-expression
                                (bquote (and && otherArgs)) testVariable))))))
        (otherwise
         (return
          (bquote ((setq & testVariable & firstArg)
                   (when & testVariable
                         && (help-transform-boolean-procedural-expression
                             (bquote (and && otherArgs)) testVariable))))))))
      (OR
       (cond
        ((empty? otherArgs)
         (return
          (help-transform-boolean-procedural-expression firstArg testVariable)))
        ((procedural-expression? firstArg)
         (return
          (bquote (&& (help-transform-boolean-procedural-expression
                       firstArg testVariable)
                      (when (not & testVariable)
                        && (help-transform-boolean-procedural-expression
                            (bquote (or && otherArgs)) testVariable))))))
        (otherwise
         (let ((otherArgsTest
                (help-transform-boolean-procedural-expression
                 (bquote (or && otherArgs)) testVariable)))
           (when (non-empty? (rest otherArgsTest))
             (setq otherArgsTest (bquote ((progn && otherArgsTest)))))
           (return
            (bquote ((if & firstArg
                         (setq & testVariable TRUE)
                         && otherArgsTest))))))))
      (NOT                                ; 'firstArg' must be procedural:
       (return
        (bquote (&& (help-transform-boolean-procedural-expression
                     firstArg testVariable)
                    (setq & testVariable (not & testVariable))))))
      (VRLET       
        (let ((cursor otherArgs))
          ;; find the last statement in the VRLET, and assign it to 'testVariable':
         (while (non-empty? (rest cursor))
            (setq cursor (rest cursor)))
          ;; '(value cursor)' now points at the last statement in the VRLET
          (setf (value cursor)
                (bquote (setq & testVariable & (value cursor)))))
        ;; note: 'firstArg' contains the declarations
        (return (bquote ((let & firstArg && otherArgs)))))) ))

(defun (transform-boolean-procedural-expression CONS TYPE-SPEC)
       ((statement CONS) (vrExpression CONS))
  ;; Return a tree (a statement) in which the procedural code
  ;;    'vrExpression' has been moved outside of 'statement'.
  (when (eq? (first vrExpression) (quote VRLET))
    (return (transform-vrlet-expression statement vrExpression)))
  ;; CODE NOTE: WE BELIEVE THAT THE CALL TO
  ;;    'percolate-out-boolean-vrlet-expressions' INSIDE OF 'walk-boolean-tree'
  ;;    NEGATES THE NEED FOR THIS FUNCTION, I.E., WE NEVER REACH THIS POINT.
  (let ((testVariable (local-gensym "TEST-VALUE"))
        (oTree CONS NULL))
    ;; replace 'vrExpression' by 'testVariable' inside of 'statement':
    (substitute-once statement testVariable vrExpression)
    (setq oTree
          (walk-without-type-tree
           (bquote
            (let ((& testVariable FALSE))
              && (help-transform-boolean-procedural-expression
                  vrExpression testVariable)
              & statement))))
    (return oTree @BOOLEAN) ))

(defun (percolate-out-boolean-vrlet-expressions CONS) ((booleanExpression CONS))
  ;; 'booleanExpression' contains one or more VRLETs within it.
  ;; Return a VRLET that declares a new Boolean variable, generates
  ;;    code to evaluate the boolean expressions, inserting
  ;;    the procedural code in appropriate places, and finishes
  ;;    with the new variable as the last statement.
  (let ((testVariable (local-gensym "TEST-VALUE"))
        (oTree CONS NULL))    
    (setq oTree
          (bquote
           (VRLET ((& testVariable FALSE))
                  && (help-transform-boolean-procedural-expression
                      booleanExpression testVariable)
                  & testVariable)))
    (return oTree) ))

(defun (transform-procedural-expression CONS TYPE-SPEC)
       ((statement CONS) (vrExpression CONS) (type TYPE-SPEC))
  ;; Return a tree (a statement) in which the procedural code
  ;;    'vrExpression' has been moved outside of 'statement'.
  ;; If 'boolean' is `true', then additional transformations operations
  ;;    are available to perform the task.
  (safety 2 (eql? (value vrExpression) (quote VRLET))
          "Non-VRLET encountered unexpectedly.")
  (if (eq? (type-spec-to-base-type type) @BOOLEAN)
    (return
     (transform-boolean-procedural-expression statement vrExpression))
    (return (transform-vrlet-expression statement vrExpression))) )

(defun (percolate-out-vrlet-expression CONS TYPE-SPEC)
       ((statement CONS) (vrExpression CONS) (type TYPE-SPEC))
  ;; Return a VRLET expression in which 'statement' has been moved
  ;;    inside of 'vrExpression'.  Used to make VRLETs "percolate"
  ;;    out to a point where 'transform-vrlet-expression' can
  ;;    eliminate them.
  ;; Strategy: Substitute last statement of 'vrExpression' into place
  ;;    where 'vrExpression lives inside of 'statement'.
  ;;    Substitute 'statement' in place of last statement within
  ;;    'vrExpression'.
  (let ((lastStatement OBJECT NULL)
        (cursor (rest (rest vrExpression))))    ; skip past declaration
    (while (non-empty? cursor)
      (when (empty? (rest cursor))
        ;; replace the last statement in 'vrLet' by :PLACE-WHERE-LAST-EXPRESSION-WAS
        (setq lastStatement (value cursor))
        (setf (value cursor) :PLACE-WHERE-LAST-EXPRESSION-WAS)
        (break))
      (setq cursor (rest cursor)))
    (substitute-once statement lastStatement vrExpression)
    (substitute-once vrExpression statement :PLACE-WHERE-LAST-EXPRESSION-WAS)
    (return vrExpression type) ))


  ;;
;;;;;; 'setq' and 'setf'
  ;;

(defun (walk-setq-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk the value expression in a 'setq' form.  Wrap with coersion or
  ;;    cast if necessary to match the type of the variable.
  ;; Check for possible VRLET in value expression.
  (when (bad-argument-count? tree 2)
    (return (walk-dont-call-me-tree tree @VOID)))
  (let ((variable (second tree))
        (value (third tree))
        (variableType TYPE-SPEC NULL)
        (oValue OBJECT NULL)
        (oType TYPE-SPEC NULL))
    (unless (symbol? variable)
      (walk-error "Illegal first argument to 'setq'; should be a symbol: "
                  variable)
      (return (walk-dont-call-me-tree tree @VOID)))
    (setq variableType (lookup-variable-type variable))
    (mv-setq (oValue oType)
      (walk-expression-tree value variableType (quote SETQ) TRUE))
    (setf (third tree) oValue)
    (unless (procedural-expression? oValue)
      (setf (second tree) (true-variable-name variable))
      (when (and (walking-expression?)
                 (not (eql? (translator-output-language) :common-lisp)))
        ;; In C++ the value of an expression 'x = b' has the type of the
        ;;    variable 'x' which could be more general than the type of 'b',
        ;;    thus, we need to encode the target language type to ensure
        ;;    the generation of proper casts.  Example situation:
        ;;        (let ((x OBJECT NULL)
        ;;              (y CONS (setq x NIL))) ...)
        (return (set-target-language-type
                 (sys-tree tree oType) (type-spec-to-base-type variableType))))
      (if (not (eql? variable (second tree)))
          (return (sys-tree tree oType))
        (return tree oType)))
    ;; 'oValue' contains a VRLET expression.  Return the result of
    ;;     applying a vrlet transform:
    (return
     (transform-procedural-expression
      tree oValue
      (choose (eq? oType @UNKNOWN) variableType oType))) ))

(defun (yield-fixed-slot-value-setter-tree CONS)
       ((slot SLOT) (objectRef OBJECT) (valueTree OBJECT))
  ;; Return parse tree code that writes the stored value of an ordinary
  ;;    slot.
  (return (bquote
           (SYS-SLOT-VALUE-SETTER
            & (slot-owner slot) & (slot-name slot) & objectRef
            ;; code borrowed from 'walk-slot-value-setter-tree':
            & (walk-expression-tree
               valueTree (type slot) (quote SLOT-VALUE-SETTER) FALSE)))) )

(defun (walk-setf-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk the value expression in a 'setf' form.  Wrap 'value' expression
  ;;    with coercion or cast if necessary to match the type of the
  ;;    'place' expression.
  ;; Check for possible VRLET in value expression.
  (let ((place CONS NULL))
    (when (cons? (second tree))
      (setq place (second tree)))
    (unless (and (defined? place)
                 (symbol? (first place))
                 (>= (length place)
                     (choose (eql? (first place) (quote SLOT-VALUE)) 3 2)))
      (walk-error "Illegal place argument in 'setf' expression: " tree)
      (return (walk-dont-call-me-tree tree @VOID)))
    (when (bad-argument-count? tree 2)
      (return (walk-dont-call-me-tree tree @VOID)))
    (mv-bind ((objectRef OBJECT) (objectType TYPE-SPEC))
        (walk-a-tree (second place))
      ;; coerce to get a cast if we have a 4-argument TYPED-SYS:
      (setq objectRef (coerce-a-tree objectRef objectType objectType))
      (let ((objectClass (type-spec-to-class objectType))
            (slotName (first place))
            (slot SLOT (safe-lookup-slot objectClass slotName))
            (slotType TYPE-SPEC NULL)
            (otherPlaceArguments (rest (rest place)))
            (oTree CONS NIL))
        (when (defined? slot)
          (setq slotType (compute-return-type-spec slot objectType)))
        (mv-bind ((valueRef OBJECT) (valueTypeSpec TYPE-SPEC))
            (walk-expression-tree
             (third tree) slotType (quote SETF) TRUE)
          (when (procedural-expression? valueRef)
            (setf (third tree) valueRef)
            (mv-bind ((ooTree CONS) (oTypeSpec TYPE-SPEC))
                ;; SHOULD THIS BE percolate-out-vrlet-expression?:
                (transform-procedural-expression tree valueRef valueTypeSpec)
              (return ooTree oTypeSpec)))
          (when (eq? slotName (quote SLOT-VALUE))
            ;; '(setf (slot-value ...) ...)':
            (return
              (walk-a-cons-tree
               (bquote (SLOT-VALUE-SETTER
                        & objectRef & valueRef
                        ;; Contains slot name + context options:
                        && otherPlaceArguments)))))
          (typecase slot
            (STORAGE-SLOT
             ;; Test for user-defined slot writer:
             (when (or (defined? (writer slot))
                       (defined? (safe-lookup-slot
                                  objectClass
                                  (yield-setter-method-name slotName))))
               ;; '(setf (<slotName> ...) ...)' -> '(<slotName>-SETTER ...)',
               ;;    e.g., '(setf (key it) o)' -> '(key-setter it o)'.
               ;; append '-SETTER' suffix to slot name, flatten arguments, put
               ;; 'valueRef' directly after 'objectRef', and call the walker:
               (return
                 (walk-a-cons-tree
                  (bquote (& (choose (defined? (writer slot))
                                     (writer slot)
                                     (yield-setter-method-name slotName))
                             & objectRef & valueRef
                             && otherPlaceArguments)))))
             (when (system-defined-slot-writer? slot)
                ;; Call the system-defined writer method directly:
                (return
                  (sys-tree-if-needed
                   slot
                   (bquote
                    (SYS-CALL-METHOD
                     & (slot-owner slot)
                     & (yield-setter-method-name slotName)
                     & objectRef
                     & (walk-expression-tree
                        valueRef slotType (quote setf) FALSE)))
                   objectType
                   slotType)))
              ;; Otherwise, we must have a direct storage slot access (copy
              ;;    portion of the logic of 'walk-slot-value-setter-tree'):
              (setq oTree
                ;; This might generate a VRLET:
                (yield-slot-value-setter-tree
                 slot objectRef objectType valueRef slotType NULL))
              (if (procedural-expression? oTree)
                  ;; We have a VRLET, magic things have to happen:
                  (return oTree slotType)
                (return (sys-tree-if-needed slot oTree objectType slotType))))
            (otherwise
             ;; ...it better be user-defined, run it through the walker,
             ;;    e.g., '(setf (nth o n) v)' -> '(nth-setter o v n)':
             ;; TRICKY: During bootstrap this 'otherwise' clause also handles
             ;;    'setf's for slots whose slot object does not yet exist.
             (return
               (walk-a-cons-tree
                (bquote (& (yield-setter-method-name slotName)
                         & objectRef & valueRef
                         && otherPlaceArguments)))))))))))

  ;;
;;;;;; 'slot-value' and 'slot-value-setter'
  ;;

;;; The slot access protocol is divided into the following layers
;;;    (starting with the innermost layer):
;;;
;;;    1. native slots
;;;    2. dynamic slots
;;;    3. contexts
;;;    4. active/hardwired slots
;;;    5. default values (for read access only)

;;; The primitives 'slot-value' and 'slot-value-setter' hide the details
;;;    of dynamic vs. instance slots, and of context-sensitive slots from
;;;    higher level code.  They implement the lower three layers of the 
;;;    slot value access protocol.  The other two layers are handled by 
;;;    system-generated access functions.

(defun (yield-dynamic-slot-value-tree CONS)
    ((slot STORAGE-SLOT) (objectRef OBJECT) (returnType TYPE-SPEC))
  ;; Return code that reads the value of the dynamic slot "slotName".
  (when (standard-dynamic-slot-access? slot)
    (return (yield-standard-dynamic-slot-value-tree
             slot objectRef returnType)))
  ;; This part would only be used for unhandled (user-defined)
  ;;    literal types, which really shouldn't happen at all:
  (case (allocation slot)
    (:dynamic
     (let ((answerVar (local-gensym "ANSWER")))
       (return
         (bquote
          (vrlet ((& answerVar & returnType
                     & (type-to-walked-null-value-tree
			(type-specifier slot) (type slot))))
            (foreach it on (dynamic-slots & objectRef)
                     where (eq? (key it) (bquote & (slot-name slot)))
                     do
                     & (choose (slot-value-is-bare-literal? slot)
                               (bquote
                                (let ((wrappedValue
                                       & (type-to-wrapped-type (type slot))
                                       (value it)))
                                  (setq & answerVar
                                        (wrapper-value wrappedValue))))
                               (bquote (setq & answerVar (value it))))
                     (break))
            & answerVar)))))
    (:bit
     (error "Allocation :bit IS NOT YET IMPLEMENTED"))) )

(defun (yield-dynamic-slot-value-setter-tree CONS)
       ((slot STORAGE-SLOT) (objectRef OBJECT)
        (valueRef OBJECT) (returnType TYPE-SPEC))
  ;; Return parse tree code that writes the value of the slot "slotName".
  (let ((slotName (slot-name slot)))
    (when (standard-dynamic-slot-access? slot)
      (return (yield-standard-dynamic-slot-value-setter-tree
               slot objectRef valueRef returnType)))
    ;; This part would only be used for unhandled (user-defined)
    ;;    literal types, which really shouldn't happen at all:
    (case (allocation slot)
      (:dynamic
       (return
        (bquote
         (vrlet ((dynamicSlots (dynamic-slots & objectRef))
               (newValue & valueRef)
               (foundMatchingEntry? FALSE))
           (foreach it on dynamicSlots
                    where (eq? (key it) (bquote & slotName))
                    do
                    & (choose (slot-value-is-bare-literal? slot)
                        (bquote
                         (let ((oldValue
                                & (type-to-symbol (type-to-wrapped-type (type slot)))
                                (value it)))
                           ; re-use old wrapper if stored as wrapped literal:
                           (setf (wrapper-value oldValue) newValue)))
                        (bquote (setf (value it) newValue)))
                    (setq foundMatchingEntry? TRUE))
           (when (and (not foundMatchingEntry?)
                      (defined? newValue))
             (setf (the-kv-list dynamicSlots)
                   (kv-cons (bquote & slotName)
                            & (choose (slot-value-is-bare-literal? slot)
                                (bquote (wrap-literal newValue))
                                (cast (quote newValue) OBJECT))
                            (the-kv-list dynamicSlots))))
           newValue))))
      (:bit
       (error "Allocation :bit IS NOT YET IMPLEMENTED"))) ))

(defun (yield-native-slot-value-tree CONS)
    ((slot STORAGE-SLOT) (objectRef OBJECT) (objectType TYPE-SPEC))
  ;; Return parse tree code that reads the stored value of the native
  ;;    storage slot 'slot' on object 'objectRef'.
  (setq slot (canonical-slot slot))
  (let ((mixinSlot? (mixin? (type-class (slot-owner slot))))
        (objectClass (type-spec-to-class objectType)))
    (when (and mixinSlot?
               (translate-to-single-inheritance-language?))
      (when (mixin? objectClass)
        ;; Avoid rewalking, since we won't find a signature:
        (return
          (sys-tree
           ;;(bquote
           ;; (SYS-CALL-FUNCTION
           ;;  & (yield-mixin-slot-reader-name slot) & objectRef))
           (bquote
            (SYS-CALL-METHOD @OBJECT
             & (yield-native-slot-reader-name slot) & objectRef))
           (choose (defined? (slot-type-specifier slot))
                   (slot-type-specifier slot)
                   (slot-base-type slot))))))
    (if (slot-hardwired? slot)
        (return
          (bquote
           (SYS-CALL-METHOD
            & (class-type objectClass) & (slot-name slot) & objectRef)))
      (return
        (bquote
         (SYS-SLOT-VALUE
          & (class-type objectClass) & (slot-name slot) & objectRef))))))

(defun (yield-context-sensitive-slot-value-tree CONS TYPE-SPEC)
    ((slot STORAGE-SLOT) (objectRef OBJECT)
     (returnType TYPE-SPEC) (csOptions CONS))
  ;; Return a walked parse tree that reads a context-sensitive value
  ;;    from the storage slot 'slot'.
  ;; 'returnType' is the previously determined type of 'slot' on 'objectRef'.
  ;; Legal 'csOptions' keywords are :context-sensitive? and :dont-inherit?.
  ;; The second return value is the actual type of the object read from
  ;;    'slot' which is 'returnType', unless the slot was accessed with
  ;;    :context-sensitive? set to `false', in which case the type of the
  ;;    accessed object is OBJECT.
  (let ((contextSensitive?
         (not (and (defined? csOptions)
                   (eql? (search-plist csOptions :context-sensitive?)
                         (quote FALSE)))))
        (dontInherit?
         ;; TO DO:  ADD THE FACET 'dont-inherit-cs-value?' TO SLOT; THEN
         ;;    REMOVE THIS COMMENT:
         (choose (or ;; (dont-inherit-cs-value? slot)
                     (and (defined? csOptions)
                          (eql? (search-plist csOptions :dont-inherit?)
                                (quote TRUE))))
                 (quote TRUE)
                 (quote FALSE)))
        (objectRefCopy objectRef)
        ;; If 'objectRef' is complex, its evaluation might have side-effects,
        ;;    in which case we have to use a temporary variable to achieve
        ;;    once-only evaluation:
        (onceOnlyWrapper?
         (and contextSensitive?
              (not (side-effect-free-expression? objectRef))))
        (literalSlot? (slot-value-is-bare-literal? slot))
        (realBaseType (slot-base-type slot))
        (realTypeSpec (slot-type-specifier slot))
        (oldValueTree OBJECT NULL)
        (oldValueRef (local-gensym "OLD-VALUE"))
        (accessTree CONS NULL))
    (cond (onceOnlyWrapper?
           (setq objectRef (local-gensym "OBJECT"))
           (push-variable-binding objectRef (slot-owner slot)))
          (otherwise
           ;; Walk this here to minimize chance of breaking during the
           ;;    creation of 'oldValueTree', since we have to temporarily
           ;;    changed the type of 'slot' to trick the type system:
           (setq objectRef
             (sys-tree (walk-without-type-tree objectRef) (slot-owner slot)))))
    ;; Temporarily tell Stella that the slot really holds an OBJECT, and
    ;;    generate slot access code based on that (this better not break):
    (setf (slot-base-type slot) @OBJECT)
    (when (defined? realTypeSpec)
      (setf (slot-type-specifier slot) NULL))
    ;; Temporarily turn off context-sensitivity to access the real values:
    (setf (slot-context-sensitive? slot) FALSE)
    ;; Generate lookup of the old value:
    (setq oldValueTree
      ;; The TYPED-SYS prevents the tree from being rewalked:
      (sys-tree (walk-without-type-tree
                 (bquote
                  (slot-value
                   & (choose contextSensitive?
                             ;; Copy the TYPED-SYS, since we'll need it again:
                             (copy-cons-tree objectRef)
                             objectRef)
                   & (slot-name slot))))
                @OBJECT))
    (setf (slot-base-type slot) realBaseType)
    (when (defined? realTypeSpec)
      (setf (slot-type-specifier slot) realTypeSpec))
    (setf (slot-context-sensitive? slot) TRUE)
    (when (not contextSensitive?)
      (return oldValueTree @OBJECT))
    (when onceOnlyWrapper?
      (pop-variable-binding))
    ;; Generate context-sensitive lookup of the current value:
    (setq accessTree
      (bquote
       (safe-cast (access-in-context
                   & (choose onceOnlyWrapper?
                             oldValueRef
                             oldValueTree)
                   (home-context & objectRef)
                   & dontInherit?)
                  & (yield-type-spec-tree
                     (choose literalSlot?
                             (type-to-wrapped-type (type slot))
                             returnType)))))
    (when literalSlot?
      (setq accessTree (bquote (wrapper-value & accessTree))))
    (if onceOnlyWrapper?
        (return
          (bquote
           ;; Need to use all gensyms here, since VRLET variables
           ;;    might wind up outside of other unsuspecting code:
           (vrlet ((& objectRef & objectRefCopy)
                   (& oldValueRef & oldValueTree))
             & accessTree))
          returnType)
      (return (walk-without-type-tree accessTree) returnType))))

(defun (yield-slot-value-tree CONS TYPE-SPEC)
    ((slot STORAGE-SLOT) (objectRef OBJECT) (objectType TYPE-SPEC)
     (returnType TYPE-SPEC) (csOptions CONS))
  ;; Return a walked parse tree that reads the storage slot 'slot'
  ;;    on object 'objectRef'.
  ;; 'returnType' is the previously determined type of 'slot' on 'objectRef'.
  ;; Legal 'csOptions' keywords are :context-sensitive? and :dont-inherit?.
  ;; Native slot vs. dynamic slot access is handled here, and context
  ;;    sensitive logic is inserted if needed.
  ;; The second return value is the actual type of the object read from
  ;;    'slot' which is 'returnType', unless a context-sensitive slot was
  ;;    accessed with :context-sensitive? set to `false', in which case the
  ;;    actual type of the accessed object is OBJECT.
  (if (slot-context-sensitive? slot)
      (return (yield-context-sensitive-slot-value-tree
               slot objectRef returnType csOptions))
    (if (dynamic-storage? slot)
        (return (walk-without-type-tree
                 (yield-dynamic-slot-value-tree slot objectRef returnType))
                returnType)
      (return
        (yield-native-slot-value-tree slot objectRef objectType) returnType))))

(defun (walk-slot-value-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Return parse tree code that expands a 'slot-value' call.  It may
  ;;    turn into a native-slot-value call or it may be an in-line
  ;;    expansion of a dynamic slot value access.
  ;; 'tree' has the form '(SLOT-VALUE <objectRef> <slotName> [<csOptions>])'.
  ;; Note: The slot name is implicitly quoted, i.e., it cannot be a variable.
  (mv-bind ((objectRef OBJECT) (objectType TYPE-SPEC))
           (walk-a-tree (second tree))
    (let ((slotName (third tree))
          (csOptions (nth-rest tree 3))
          (objectClass (type-spec-to-class objectType))
          (slot SLOT (safe-lookup-slot objectClass slotName))
          (oTree CONS NULL)
          (oType TYPE-SPEC NULL))
;      (when (class-abstract? objectClass)   ; RMM 1/19/96
;        (walk-error "Can't read a slot belonging to the abstract class "
;               (class-name objectClass))
;        (return (walk-dont-call-me-tree tree @UNKNOWN)))
      (when (null? slot)
        (walk-error "Can't read a non-existent slot " slotName EOL
               "   on the class " (class-name objectClass))
        (return (walk-dont-call-me-tree tree @UNKNOWN)))
      (typecase slot
        (METHOD-SLOT
         (walk-error
          "Can't read the method slot " slot " by calling 'slot-value'")
	 (return NULL NULL))
        (STORAGE-SLOT
         (setq oType (compute-return-type-spec slot objectType))
         (mv-setq (oTree oType)
           ;; This might generate a VRLET:
           (yield-slot-value-tree slot objectRef objectType oType csOptions))
         (if (procedural-expression? oTree)
             ;; We have a VRLET, magic things have to happen:
             (return oTree oType)
           (return (sys-tree-if-needed slot oTree objectType oType))))))))

(defun (yield-native-slot-value-setter-tree CONS)
    ((slot STORAGE-SLOT) (objectRef OBJECT)
     (objectType TYPE-SPEC) (valueRef OBJECT))
  ;; Return parse tree code that writes the value 'valueRef' into the
  ;;     native storage slot 'slot' on object 'objectRef'.
  (setq slot (canonical-slot slot))
  (let ((mixinSlot? (mixin? (type-class (slot-owner slot))))
        (objectClass (type-spec-to-class objectType)))
    (when (and mixinSlot?
               (translate-to-single-inheritance-language?))
      (when (mixin? objectClass)
        (return
          (sys-tree
           ;;(bquote
           ;; (SYS-CALL-FUNCTION
           ;;  & (yield-mixin-slot-writer-name slot) & objectRef & valueRef))
           (bquote
            (SYS-CALL-METHOD @OBJECT
             & (yield-native-slot-reader-name slot) & objectRef & valueRef))
           (choose (defined? (slot-type-specifier slot))
                   (slot-type-specifier slot)
                   (slot-base-type slot))))))
    (when (slot-hardwired? slot)
      (walk-error "Can't set the value of the hardwired slot "
                  (slot-owner slot) "." (slot-name slot))
      (return (walk-dont-call-me-tree NULL (slot-base-type slot))))
    (return
      (bquote
       (SYS-SLOT-VALUE-SETTER
        & (class-type objectClass) & (slot-name slot)
        & objectRef & valueRef)))))

(defun (yield-context-sensitive-slot-value-setter-tree CONS TYPE-SPEC)
    ((slot STORAGE-SLOT) (objectRef OBJECT) (valueRef OBJECT)
     (returnType TYPE-SPEC) (csOptions CONS))
  ;; Return a walked parse tree that writes a value to the storage slot 'slot'.
  ;; 'returnType' is the previously determined type of 'slot' on 'objectRef'.
  ;; Legal "csOptions" keywords are :context-sensitive? and :copy-to-children?.
  ;; The second return value is the actual type of the object stored in
  ;;    'slot' which is 'returnType', unless the slot was accessed with
  ;;    :context-sensitive? set to `false', in which case the type of the
  ;;    stored object is OBJECT.
  (let ((contextSensitive?
         (not (and (defined? csOptions)
                   (eql? (search-plist csOptions :context-sensitive?)
                         (quote FALSE)))))
        (copyToChildren 
         (choose (and (defined? csOptions)
                      (eql? (search-plist csOptions :copy-to-children?)
                            (quote TRUE)))
                 (quote TRUE)
                 (quote FALSE)))
        (realBaseType (slot-base-type slot))
        (realTypeSpec (slot-type-specifier slot))
        (objectVar SYMBOL NULL)
        (valueVar SYMBOL NULL)
        (oldValueVar SYMBOL NULL)
        (newValueVar SYMBOL NULL)
        (oldValueTree CONS NULL)
        (setNewValueTree CONS NULL))
    ;; Temporarily tell Stella that the slot really holds an OBJECT, and
    ;;    generate slot access code based on that (this better not break):
    (setf (slot-base-type slot) @OBJECT)
    (when (defined? realTypeSpec)
      (setf (slot-type-specifier slot) NULL))
    ;; Temporarily turn off context-sensitivity to access the real values:
    (setf (slot-context-sensitive? slot) FALSE)
    (cond
     (contextSensitive?
      (setq objectVar (local-gensym "OBJECT"))
      (setq valueVar (local-gensym "VALUE"))
      (setq oldValueVar (local-gensym "OLD-VALUE"))
      (setq newValueVar (local-gensym "NEW-VALUE"))
      (push-variable-binding objectVar (slot-owner slot))
      (push-variable-binding newValueVar @OBJECT)
      ;; Generate lookup of the old value:
      (setq oldValueTree
        ;; The TYPED-SYS prevents the tree from being rewalked:
        (sys-tree (walk-without-type-tree
                   (bquote (slot-value & objectVar & (slot-name slot))))
                  @OBJECT))
      ;; Generate tree to set the value in a non-context-sensitive manner:
      (setq setNewValueTree
        ;; The TYPED-SYS prevents the tree from being rewalked:
        (sys-tree (walk-without-type-tree
                   (bquote
                    (setf (slot-value & objectVar & (slot-name slot))
                      & newValueVar)))
                  @OBJECT)))
     (otherwise
      ;; Generate tree to set the value in a non-context-sensitive manner:
      (setq setNewValueTree
        ;; The TYPED-SYS prevents the tree from being rewalked:
        (sys-tree (walk-without-type-tree
                   (bquote
                    (setf (slot-value & objectRef & (slot-name slot))
                      & valueRef)))
                  @OBJECT))))
    (setf (slot-base-type slot) realBaseType)
    (when (defined? realTypeSpec)
      (setf (slot-type-specifier slot) realTypeSpec))
    (setf (slot-context-sensitive? slot) TRUE)
    (when (not contextSensitive?)
      (return setNewValueTree @OBJECT))
    (pop-variable-binding)
    (pop-variable-binding)
    (return
      (bquote
       ;; TO DO: Optimize redundant binding of 'objectVar' and/or 'valueVar'
       ;;   if their corresponding trees don't have side-effects.
       (vrlet ((& objectVar & objectRef)
               ;; Explicitly type it, since 'valueRef' might be `null':
               (& valueVar & realBaseType & valueRef)
               (& oldValueVar & oldValueTree)
               (& newValueVar
                  ;; TO DO: Maybe make 'update-in-context' into a BOOLEAN, to
                  ;;   avoid the 'cs-value?' test below.
                  (update-in-context
                   ;; Literal values will be wrapped automatically:
                   & oldValueVar & valueVar (home-context & objectVar) & copyToChildren)))
         (when (not (cs-value? & oldValueVar))
           & setNewValueTree)
         & valueVar))
      returnType)))

(defun (yield-slot-value-setter-tree CONS TYPE-SPEC)
       ((slot STORAGE-SLOT) (objectRef OBJECT) (objectType TYPE-SPEC)
        (valueRef OBJECT) (returnType TYPE-SPEC) (csOptions CONS))
  ;; Return a walked parse tree that writes the value 'valueRef' into the
  ;;     native storage slot 'slot' on object 'objectRef'.
  ;; 'returnType' is the previously determined type of 'slot' on 'objectRef'.
  ;; Native slot vs. dynamic slot access is handled here, and context
  ;;    sensitive logic is inserted if needed.
  ;; The second return value is the actual type of the object stored in
  ;;    'slot' which is 'returnType', unless a context-sensitive slot was
  ;;    accessed with :context-sensitive? set to `false', in which case the
  ;;    actual type of the stored object is OBJECT.
  (if (slot-context-sensitive? slot)
      (return (yield-context-sensitive-slot-value-setter-tree
               slot objectRef valueRef returnType csOptions))
    (if (dynamic-storage? slot)
        (return
          (walk-without-type-tree
           (yield-dynamic-slot-value-setter-tree
            slot objectRef valueRef returnType))
          returnType)
      (return (yield-native-slot-value-setter-tree
               slot objectRef objectType valueRef)
              returnType))))

(defun (walk-slot-value-setter-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Return parse tree code that expands a 'slot-value-setter' call.  It may
  ;;    turn into a native-slot-value-setter call or it may be an in-line
  ;;    expansion of a dynamic slot value access.
  ;; 'tree' has the form
  ;;    '(SLOT-VALUE-SETTER <objRef> <valueRef> <slotName> [<csOptions>])'.
  (mv-bind ((objectRef OBJECT) (objectType TYPE-SPEC))
           (walk-a-tree (second tree))
    (let ((slotName (fourth tree))
          (csOptions (nth-rest tree 4))
          (objectClass (type-spec-to-class objectType))
          (slot (safe-lookup-slot objectClass slotName))
          (valueRef OBJECT NULL)
          (oTree CONS NULL)
          (oType TYPE-SPEC NULL))
      (when (null? slot)
        (walk-error "Can't set a non-existent slot " slotName EOL
               "   on the class " (class-name objectClass))
        (return (walk-dont-call-me-tree tree @VOID)))
;      (when (and (class-abstract? objectClass)   ; RMM 1/19/96
;                 (not (eq? (class-type objectClass) @UNKNOWN)))
;        (error "Can't write a slot belonging to the abstract class "
;               (class-name objectClass)))
      (typecase slot
        (METHOD-SLOT
         (walk-error "Can't set the method slot " slot
                     " by calling 'slot-value-setter'")
	 (return (walk-dont-call-me-tree tree @VOID)))
        (STORAGE-SLOT
         (setq oType (compute-return-type-spec slot objectType))
         (setq valueRef
           (walk-expression-tree
            (third tree) oType (quote SLOT-VALUE-SETTER) FALSE))
         (mv-setq (oTree oType)
           ;; This might generate a VRLET:
           (yield-slot-value-setter-tree
            slot objectRef objectType valueRef oType csOptions))
         (if (procedural-expression? oTree)
             ;; We have a VRLET, magic things have to happen:
             (return oTree oType)
           (return (sys-tree-if-needed slot oTree objectType oType))))))))

  ;;
;;;;;; Array access via `aref':
  ;;

(defun (walk-aref-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk an `aref' or `aref-setter' call and return the result in
  ;;    the form of a walked method call.
  ;; `tree' has one of the following forms:
  ;;    (AREF <arrayRef> <dim>+)
  ;;    (AREF-SETTER <arrayRef> <valueRef> <dim>+)
  ;; Most of the functionality below we could have achieved by treating
  ;;    `aref/-setter' as special purpose native methods (similar to
  ;;    methods on ARGUMENT-LIST), however, we need special checks for
  ;;    definiteness of the array type as well as whether the number of
  ;;    dimensions is matched by the number of indices.  Also, the &rest
  ;;    argument handling for Java doesn't do what we want for this case,
  ;;    which is why we have this special-purpose function.
  (let ((operator (first tree))
        (oTree OBJECT NULL)
        (oType TYPE-SPEC NULL)
        (arrayType PARAMETRIC-TYPE-SPECIFIER NULL)
        (elementType TYPE-SPEC NULL)
        (arguments (rest tree)))
    ;; Walk array expression:
    (mv-setq (oTree oType)
      (walk-expression-tree (first arguments) @ARRAY operator TRUE))
    (when (vrlet-expression? oTree)
      (setf (first arguments) oTree)
      (return (percolate-out-vrlet-expression tree oTree @UNKNOWN)))
    (unless (array-type-specifier? oType)
      (return (walk-dont-call-me-tree tree @UNKNOWN)))
    (setq arrayType oType)
    (setq elementType (extract-parameter-type arrayType (quote ANY-VALUE)))
    (when (and (indefinite-array-type? arrayType)
               ;; C++ is the most restricitve, but it allows the first
               ;;    dimension to be unspecified:
               (not (forall dim in (rest (array-type-dimensions arrayType))
                      always (defined? dim))))
      (walk-error "Can't AREF underspecified array type" EOL
                  "   " arrayType " in" EOL
                  "   " tree)
      (return (walk-dont-call-me-tree tree @UNKNOWN)))
    (setf (first arguments) oTree)
    (setq arguments (rest arguments))

    (when (eql? operator (quote AREF-SETTER))
      ;; walk value expression:
      (mv-setq (oTree oType)
        (walk-expression-tree (first arguments) elementType operator TRUE))
      (setf (first arguments) oTree)
      (when (vrlet-expression? oTree)
        (return (percolate-out-vrlet-expression tree oTree @UNKNOWN)))
      (setq arguments (rest arguments)))

    ;; Walk dimension expressions:
    (when (not (= (length arguments) (array-type-rank arrayType)))
      (walk-error "AREF indices don't match the rank of the array in" EOL
                  "   " tree))
    (while (non-empty? arguments)
      (mv-setq (oTree oType)
        (walk-expression-tree (first arguments) @INTEGER operator TRUE))
      (setf (first arguments) oTree)
      (when (vrlet-expression? oTree)
        (return (percolate-out-vrlet-expression tree oTree @UNKNOWN)))
      (setq arguments (rest arguments)))
    (return
      (sys-tree
       (bquote (SYS-CALL-METHOD & (specifier-base-type arrayType) & operator
                ;; record type of array arg for the potential benefit of the
                ;;    translator, e.g., to generate type declarations in Lisp:
                & (sys-tree (second tree) arrayType)
                && (rest (rest tree))))
       elementType))))


  ;;
;;;;;; Declarations
  ;;

(defun (safe-yield-type-specifier TYPE-SPEC) ((typeTree OBJECT))
  ;; Parse the type expression 'typeTree' and return
  ;;    a type or type specification.
  ;; The `null' value just passes through.
  (if (defined? typeTree)
    (let ((typeSpec (yield-type-specifier typeTree)))
      (validate-type-specifier typeSpec NULL TRUE)
      (return typeSpec))
    (return NULL)) )

(defun (walk-a-declaration CONS)
       ((variable SYMBOL) (typeTree OBJECT)
        (value OBJECT) (inputParameter? BOOLEAN))
  ;; Called by 'walk-variable-declarations'.
  ;; Check the compatibility of the type of 'value' with 'targetType',
  ;;    or compute a value for 'targetType' if it is `null'.
  ;; Return a newly-minted declaration.
  (let ((sourceType TYPE-SPEC NULL)
        (targetType (safe-yield-type-specifier typeTree))
        (methodOwnerType (only-if (defined? *methodBeingWalked*)
                           (slot-owner *methodBeingWalked*)))
        (oValue OBJECT NULL))
    ;; Handle anchored types:
    (when (and (defined? targetType)
               (defined? methodOwnerType)
               (not (void? methodOwnerType)))
      (setq targetType
        (compute-relative-type-spec targetType methodOwnerType)))
    ;; Handle initial value expressions:
    (unless inputParameter?
      ;; Mirror C++ semantics, where the bound variable becomes
      ;; visible before its initialization takes place:
      (push-variable-binding variable @UNINITIALIZED)
      (mv-setq (oValue sourceType)
        (walk-expression-tree
         value targetType (quote VARIABLE-DECLARATION) TRUE))
      (when (null? targetType)
        ;; No type specified, type the variable from the initializer:
        (setq targetType sourceType))
      (pop-variable-binding))
    (push-variable-binding variable targetType)
    (if inputParameter?
        (return (bquote (& variable & targetType)))
      (return
        (bquote (& (true-variable-name variable) & targetType & oValue)))) ))

(defun (walk-variable-declarations CONS) ((declarations CONS))
  ;; Called by 'walk-let-tree'.
  ;; CAUTION: Side-effect: Pushes variable bindings onto 
  ;;    *localVariableTypeTable*.
  ;; Return a walked list of declarations, and record variable
  ;;    types on the local stack.  If one or more initialization
  ;;    trees were VRLETs, the declarations starting with the
  ;;    first VRLET will remain unwalked, and their variables
  ;;    and types will not get recorded on the stack.  This
  ;;    is relied upon by `walk-let-tree'.
  (let ((oDeclarations (CONS OF CONS) NIL)
        (variable SYMBOL NULL)
        (vrletEncountered? FALSE))
    (foreach 
      decl in declarations
      do
      (typecase decl
        (CONS
         (cond (vrletEncountered?
                ;; Don't walk any remaining declarations, since they might
                ;;    reference the variable initialized (and typed) by the VRLET:
                (pushq oDeclarations decl)
                (continue))
               ((not (symbol? (first decl)))
                (walk-error "Illegal variable in `let' declaration: " decl)
                (setq variable (quote ILLEGAL-VARIABLE)))
               (otherwise
                (setq variable (first decl))
                (when (or (defined? (lookup-global-variable variable))
                          (constant-symbol? variable))
                  ;; QUESTION: Should we allow the re-binding of globals
                  ;;    that are not specials?
                  (walk-error (choose (constant-symbol? variable)
                                      "Illegal binding of constant value "
                                      "Illegal binding of global or special variable ")
                              "in `let' declaration:" EOL
                              "    " decl)
                  (setq variable (quote ILLEGAL-VARIABLE)))))
         (case (length decl)
           (1 (walk-error "Missing argument(s) in `let' declaration: " decl))
           (2 (when (eql? (second decl) (quote NULL))
                ;; Special-case this, since it is a common error:
                (walk-error "Missing type specifier in `let' declaration: "
                            decl))
              (pushq oDeclarations
                     (walk-a-declaration
                      variable NULL (second decl) FALSE)))
           (3 (pushq oDeclarations
                     (walk-a-declaration
                      variable (second decl) (third decl) FALSE)))
           (otherwise
            (walk-error "Too many terms in `let' declaration:" decl)))
         (when (procedural-expression? (third (first oDeclarations)))
           (setq vrletEncountered? TRUE)
           (pop-variable-binding)))
        (otherwise
         (walk-error "Illegal `let' declaration: " decl))))
    (return (reverse oDeclarations))))

;(defun (find-procedural-expression CONS) ((tree OBJECT))
;  ;; Called by "transform-let-with-procedural-expression".
;  ;; "tree" contains one or more VRLET expression.
;  ;; Return the first one found in it.
;  (typecase tree
;    (CONS
;     (if (eql? (value tree) (quote VRLET))
;       (return tree)
;       (foreach term in (rest tree)
;                do
;                (let ((result (find-procedural-expression term)))
;                  (when (defined? result)
;                    (return result))))))
;    (otherwise NULL))
;  (return NULL) )

(defun (transform-let-with-procedural-expression CONS) ((tree CONS))
  ;; Called by 'walk-let-tree'.
  ;; The first let declaration in 'tree' contains a procedural expression
  ;;    (a VRLET).  Return a tree with that expression moved outside of
  ;;    the let.
  (let ((firstDeclaration CONS (first (cast (second tree) CONS)))
        (typeTree (second firstDeclaration))
        (vrletTree (walk-without-type-tree (third firstDeclaration))))
    (when (eq? typeTree @UNKNOWN)
      ;; Remove an UNKNOWN type declaration, so the variable
      ;; can be retyped from the result of the VRLET:
      (setf (rest firstDeclaration)
        (rest (rest firstDeclaration))))
    (mv-bind (oTree unusedTypeSpec)
             (transform-procedural-expression tree vrletTree typeTree)
      (ignore unusedTypeSpec)
      (return oTree) )))

(defun pop-local-variable-bindings ((declarations CONS))
  ;; Remove a variable binding from *localVariableTypeTable* for each
  ;;    variable declaration in 'declarations'.
  ;; Called in 'walk-let-tree' to remove bindings introduced by
  ;;    the call to 'walk-variable-declarations'.
  (foreach d in declarations
      do (ignore d)
	 (pop-variable-binding)) )

(defun (walk-let-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk let declaration, recording the type of each local variable.
  (setf (second tree)
    ;; this pushes variable bindings for each variable up to (but excluding)
    ;;    the first variable initialized by a VRLET expression:
    (walk-variable-declarations (second tree)))
  (when (not (exists d in (cast (second tree) (CONS OF CONS))
                     where (procedural-expression? (third d))))
    (setf (rest (rest tree)) (walk-list-of-statements (rest (rest tree))))
    (pop-local-variable-bindings (second tree))
    (return (sys-tree tree @VOID)))
  ;; one or more declarations contains a VRLET.
  (let ((originalDeclarations CONS (second tree))
        (leadingDeclarations NIL)
        (trailingDeclarations NIL)
        (leading? TRUE))
    ;; extract declarations that don't contain a VRLET:
    (foreach d in (cast originalDeclarations (CONS OF CONS))
             do
             (when (procedural-expression? (third d))
               (setq leading? FALSE))
             (cond (leading?
                    (pushq leadingDeclarations d))
                   (otherwise
                    (pushq trailingDeclarations d))))
    (setq leadingDeclarations (reverse leadingDeclarations))
    (setq trailingDeclarations (reverse trailingDeclarations))
    (setf (second tree) trailingDeclarations)
    ;; at this point, 'leadingDeclarations' contains any leading declarations
    ;;    that didn't contain a procedural expression, while the original
    ;;    declarations have been replaced by 'trailingDeclarations'.
    (setq tree (transform-let-with-procedural-expression tree))
    (when (non-empty? leadingDeclarations)
      (pop-local-variable-bindings leadingDeclarations)
      (setq tree (bquote (let & leadingDeclarations
                              & tree))))
    ;; now that (at least one) VRLET has been expanded away, rewalk the
    ;;    let tree:
    (return (walk-a-cons-tree tree)) ))

(defspecial *specialVariableStack* (KEY-VALUE-LIST OF SYMBOL SYMBOL)
  (new (KEY-VALUE-LIST OF SYMBOL SYMBOL))
  :documentation "Stack mirroring the current state of bound specials
with their associated old-value variables.")

(defspecial *specialsEnabled?* BOOLEAN TRUE
  :documentation "`true' if using specials is enabled and legal.")

(defspecial *nofSpecialsAtLoopEntry* INTEGER 0
  :documentation "Number of specials bound at the most recent entry
to a LOOP/WHILE/FOREACH construct.")

(defun (special-implementation-style KEYWORD) ()
  ;; Return the implementation style for special variables.
  ;;    Binding and unbinding differs depending on the style.
  ;;    Currently, only :common-lisp, :unwind-protect and :save-and-restore
  ;;    are supported.
  (case (translator-output-language)
    (:common-lisp (return :common-lisp))
    (:cpp (return :unbind-with-destructors))
    (:java (return :common-lisp))  ;; Was :unwind-protect
    (otherwise
     (return :unwind-protect)
     ;;(return :save-and-restore)		
     ;;(return :special-stack)
     )))

(defun push-special ((variable SYMBOL) (oldValueVariable SYMBOL))
  ;; Push the entry <variable, oldValueVariable> onto *specialVariableStack*.
  (setf (the-kv-list *specialVariableStack*)
        (kv-cons variable oldValueVariable (the-kv-list *specialVariableStack*))))

(defun pop-special ()
  ;; Pop the first/top entry from *specialVariableStack*.
  (let ((kvList (the-kv-list *specialVariableStack*)))
    (setf (the-kv-list *specialVariableStack*) (rest kvList))
    (free-kv-cons kvList) ))

(defun (lookup-old-value-variable SYMBOL) ((variable SYMBOL))
  ;; Lookup the old-value variable of the most recent binding of
  ;;    the special 'variable'.
  (return (lookup-variable-table *specialVariableStack* variable)))

(defun (need-to-unbind-specials? BOOLEAN) ()
  ;; True if a 'return' or 'break' statement needs to unbind specials.
  (return (and *specialsEnabled?*
               (> (length *specialVariableStack*) 0)
               (not (member? (quote (:common-lisp :unbind-with-destructors))
                             (special-implementation-style))))))

(defun (yield-special-unbind-tree CONS) ((nofBindings INTEGER))
  ;; Return a tree to unbind 'nofBindings' special variables.
  (let ((oTree (CONS OF CONS) NIL))
    (case (special-implementation-style)
      (:unwind-protect
       (foreach (variable oldValueVariable) in *specialVariableStack*
           where (>= (-- nofBindings) 0)
           do (setq oTree
                ;; Remove any previous unbinding of 'variable', since
                ;;    it became redundant with the current unbinding:
                (remove oTree
                        (some tree in oTree
                          where (eql? (second tree) variable))))
              (pushq oTree (bquote (setq & variable & oldValueVariable))))
       (return (prognify (reverse oTree))))
      (otherwise (return NULL)))))

(defun (yield-return-special-unbind-tree CONS) ()
  ;; Return a tree to unbind special variables in a 'return' statement.
  (return (yield-special-unbind-tree (length *specialVariableStack*))))

(defun (yield-loop-exit-special-unbind-tree CONS) ()
  ;; Return a tree to unbind special variables in a loop-exit statement
  ;; such as 'break' or 'continue'.
  (return (yield-special-unbind-tree
           (- (length *specialVariableStack*)
              *nofSpecialsAtLoopEntry*))))

(defun (walk-special-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk a 'special' statement.
  ;; 'special' statements (unlike 'let's) do not allow type specifications,
  ;;    since special variables are typed by their global declarations.
  ;; Depending on the implementation style, code is added to ensure
  ;;    proper binding and unbinding.
  (unless *specialsEnabled?*
    (walk-error "'special' statement not legal in the current context: "
                EOL tree)
    (return (walk-dont-call-me-tree tree @VOID)))
  (when (or (< (length tree) 2)
            (not (cons? (second tree)))
            (not (forall binding in (cast (second tree) (CONS OF CONS))
                     always (and (cons? binding)
                                 (symbol? (first binding))
                                 (eq? (length binding) 2)))))
    (walk-error "Illegal 'special' statement: " tree)
    (return (walk-dont-call-me-tree tree @VOID)))
  (when (eq? (length (cast (second tree) CONS)) 0)
    (setf (first tree) (quote LET))
    (return (walk-let-tree tree)))
  (let ((variable GLOBAL-VARIABLE NULL))
    (foreach binding in (cast (second tree) (CONS OF CONS))
        do (setq variable
             (lookup-global-variable (cast (first binding) SYMBOL)))
           (when (or (null? variable)
                     (not (variable-special? variable)))
             (walk-error "Trying to bind non-special variable "
                         (first binding) EOL " in 'special' statement"))))
  (case (special-implementation-style)
    (:common-lisp
     ;; Use native Common-Lisp specials:
     (return (walk-cl-special-tree tree)))
    (:unbind-with-destructors
     ;; just like :common-lisp, let translator handle it:
     (return (walk-cl-special-tree tree)))
    (:unwind-protect
     ;; Use an unwind-protect form:
     (return (walk-unwind-protect-special-tree tree)))))

(defun (walk-cl-special-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk a syntactically checked 'special' statement, and
  ;;    implement it via native Common-Lisp specials.
  (let ((bindings (CONS OF CONS) (second tree))
        (body (rest (rest tree)))
        (variableName SYMBOL NULL)
        (variableType TYPE-SPEC NULL)
        (bindViaSetq? FALSE)
        (bindViaSetqTrees NIL)
        (oTree OBJECT NULL))
    (foreach binding in bindings
        do (setq variableName (first binding))
           (setq variableType (lookup-global-variable-type variableName))
           (cond (bindViaSetq?
                  (pushq bindViaSetqTrees
                         (walk-a-tree
                          (bquote (setq & variableName & (second binding)))))
                  (setf (second binding) variableType)
                  (setf (rest (rest binding)) (bquote (NULL))))
                 (otherwise
                  (setq oTree
                    (walk-expression-tree
                     (second binding) variableType (quote SPECIAL) TRUE))
                  (when (procedural-expression? oTree)
                    (setq bindViaSetq? TRUE)
                    (pushq bindViaSetqTrees
                           (walk-a-tree
                            (bquote (setq & variableName & oTree))))
                    (setq oTree (quote NULL)))
                  (setf (second binding) variableType)
                  (setf (rest (rest binding)) (bquote (& oTree))))))
    (setf (first tree) (quote SPECIAL)) ;; eliminate SYS-SPECIALs
    (setf (rest (rest tree))
      (concatenate (reverse bindViaSetqTrees) (walk-list-of-statements body)))
    (return (sys-tree tree @VOID))))

(defun (walk-unwind-protect-special-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk a syntactically checked 'special' statement, and
  ;;    implement it via the 'unwind-protect' mechanism.
  ;; This saves and restores old values in/from local variables, which
  ;;    is simple, non-local exits are handled via unwind-protection code.
  (let ((bindings (CONS OF CONS) (second tree))
        (body (rest (rest tree)))
        (variable SYMBOL NULL)
        (oldValueVariable SYMBOL NULL)
        (oldValueBindings NIL)
        (bindTrees NIL)
        (unbindTrees NIL))
    (foreach binding in bindings
        do (setq variable (first binding))
           (pushq bindTrees (bquote (setq & variable & (second binding))))
           (setq oldValueVariable
             (local-gensym (concatenate "OLD-" (symbol-name variable))))
           (push-special variable oldValueVariable)
           (pushq oldValueBindings
                  (bquote (& oldValueVariable & variable)))
           (pushq unbindTrees
                  (bquote (setq & variable & oldValueVariable))))
    (setq tree
      (walk-a-tree
       (bquote
        (let & (reverse oldValueBindings)
             && (reverse bindTrees)
	     (unwind-protect & (prognify body)
		 && unbindTrees)))))
    (foreach binding in bindings
        do (ignore binding)
           (pop-special))
    (return tree @VOID)))


#|
;;; How to protect special unbinding against exceptions in C++:

  (let (...old values...)
    (sys-special ((*exceptionHandlerAddress* NULL))
      (when (or (not *pendingExceptionHandler?*) ;; for efficiency
                (setup-long-jump? *exceptionHandlerAddress*))
        (progn
          ...bind specials to new values...
          ...special body...
          ...unbind to old values...
          (setq *exception* NULL))))  ;; <- do I really need this here?
    (when (defined? *exception*)
      ...unbind to old values...
      (resignal)))
|#
                  
(defun (walk-cast-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk cast expression of the form
  ;;    '(cast <expression> <className>)' or
  ;;    '(safe-cast <expression> <className>)'.
  ;; 'SAFE-CAST's are used whenever we can be sure about the run-time
  ;;    type of <expression>, but we have to use a cast since that
  ;;    type is different from the static type of <expression>.
  (when (bad-argument-count? tree 2)
    (return (walk-dont-call-me-tree tree @UNKNOWN)))
  (let ((typeSpec (yield-type-specifier (third tree))))
    (setf (second tree)
          (walk-expression-tree (second tree) @UNKNOWN (quote CAST) TRUE))
    (when (vrlet-expression? (second tree))
      (return (percolate-out-vrlet-expression tree (second tree) typeSpec)))
    (setf (third tree) typeSpec)
    (when (and (eql? (translator-output-language) :common-lisp)
               (eql? (first tree) (quote CAST))
               (>= *safety* 2))
      (register-symbol (type-spec-to-base-type typeSpec)))
    (return tree typeSpec) ))


  ;;
;;;;;; 'return' and multiple values
  ;;

;; There are two types of expressions that can generate multiple values:
;;    (1) Calls to multiple-valued functions
;;    (2) '(VALUES ...)' expressions
;; If a '(VALUES ...)' expression is encountered anywhere else but in
;; multiple-value context, it is simply converted into a PROGN.

(defun (values-tree? BOOLEAN) ((tree OBJECT))
  ;; True if 'tree' is of the form '(VALUES ...)'.
  (return (and (cons? tree)
               (eql? (quote VALUES) (first (safe-cast tree CONS))))))

(defun (walk-values-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk a 'tree' of the form '(VALUES ...)' with 0 or more values,
  ;;   each of which can be procedural.  A '(VALUES ...)' form
  ;;   encountered outside of a form that expects multiple values
  ;;   is simply translated into a PROGN.
  ;; This function exists mainly for the benefit of 'walk-mv-values-tree'.
  ;;   On exit it is guaranteed that 'tree' has been destructively
  ;;   modified into a '(PROGN ...)' where each argument is a non-procedural
  ;;   value expression wrapped in a TYPED-SYS which records its type.
  ;;   Thus even though the returned tree might be different from 'tree',
  ;;   'walk-mv-values-tree' can always recover the value types from the
  ;;   TYPED-SYS trees that wrap individual value expressions.
  ;; The modified 'tree' (the values tree) will be nested within the
  ;;   walked tree.
  (let ((oTree OBJECT NULL)
        (oType TYPE-SPEC NULL)
        (bindTree NIL)
        (valueVar SYMBOL NULL)
        (hasProceduralValue? FALSE))
    (foreach it on (rest tree)
             do
             (mv-setq (oTree oType) (walk-a-tree (value it)))
             (when (vrlet-expression? oTree)
               (setf (value it) oTree)
               (setq hasProceduralValue? TRUE)
               (break))
             ;; Record the type for the benefit of 'walk-mv-values-tree':
             (setq oTree (sys-tree oTree oType))
             (when (void? oType)
               (setq oTree (bquote (&& (safe-cast oTree CONS) @VOID))))
             (setf (value it) oTree))
    (when (not hasProceduralValue?)
      ;; quick exit if no values are procedural:
      (setf (first tree) (quote PROGN))
      (return tree @VOID))
    ;; migrate procedural code outside of the values tree:
    (foreach
     it on (rest tree)
     do (let ((value CONS (value it)))
          ;; Only save values of non-atomic expressions (slightly tricky -
          ;; this also avoids resaving of previously saved values):
          (when (or (procedural-expression? value)
                    (not (atomic-expression? (second value))))
            (setq valueVar (local-gensym "VALUE"))
            (pushq bindTree
                   (bquote
                    (& valueVar
                       & (choose (procedural-expression? value)
                                 value
                                 (second value)))))
            (cond ((procedural-expression? value)
                   (setf (value it) valueVar)
                   (break))
                  (otherwise
                   (setf (second value) valueVar))))))
    (return
     (walk-a-cons-tree
      (bquote (let & (reverse bindTree)
                   & tree)))) ))

(defun (walk-mv-expression-tree OBJECT CONS (LIST OF TYPE-SPEC))
       ((tree OBJECT) (targetTypes (LIST OF TYPE-SPEC)) (operator SYMBOL))
  ;; Multiple-value analog to 'walk-expression-tree'.
  ;; 'tree' is an expression returning 0 or more values.
  ;; Walk 'tree', verifying that the number of values matches the length of
  ;;    'targetTypes', and that the types of the values are compatible with
  ;;    'targetTypes'.
  ;; Coerce/cast individual values to their target types with help of
  ;;    'coerce-mv-tree'.  Coersion might make it necessary to store
  ;;     values in temporary variables.
  ;; Return the walked tree, a values tree if one was generated, and a
  ;;    possibly modified list of target types corresponding to the actual
  ;;    value types (this is always a fresh list which can be 'free'd
  ;;    without harm).
  ;; The values tree (the second return argument) is either `null' or of the
  ;;    form '(VALUES ...)' where each argument is guaranteed to be a
  ;;    non-procedural expression.  If the original 'tree' contained
  ;;    procedural expressions, e.g., '(values (popq x) (popq y) ...)',
  ;;    or if temporary variables were necessary due to value coersion,
  ;;    then the returned values tree will be a subtree of the returned
  ;;    walked tree that can be used by callers such as 'mv-setq-tree'
  ;;    to perform the necessary operations on the individual values.
  ;;    This scheme is a variation of the standard transformation of
  ;;    procedural expressions which avoids multiple rewalking if there
  ;;    was more than one procedural expression in 'tree'.
  (special (;; special-case this to deal with '(return (funcall ...))'
            ;; expressions.  If we ever allow anonymous functions to be
            ;; multiple-valued, we need a list of '*targetTypes*':
            (*targetType* (choose (eq? (length targetTypes) 1)
                                  (first targetTypes)
                                  @UNKNOWN)))
    (mv-bind (oTree valuesTree sourceTypes)
        (walk-mv-tree tree)
      (when (not (eq? (length sourceTypes) (length targetTypes)))
        (if (and (eq? (length sourceTypes) 1)
                 (eql? @UNKNOWN (first sourceTypes)))
            (warn-about-unknown-source-type oTree)
          (walk-error operator " operator expected "
                      (length targetTypes) " value(s) from " tree))
        (return oTree valuesTree (copy targetTypes)))
      (when (empty? sourceTypes)
        (return oTree valuesTree sourceTypes))
      (if (defined? valuesTree)
          (mv-setq (tree valuesTree targetTypes)
            (coerce-mv-tree valuesTree operator sourceTypes targetTypes))
        (mv-setq (oTree valuesTree targetTypes)
          (coerce-mv-tree oTree operator sourceTypes targetTypes)))
      (free sourceTypes)
      (return oTree valuesTree targetTypes))))

(defun (listify-type-spec (LIST OF TYPE-SPEC)) ((typeSpec TYPE-SPEC))
  ;; Create a listified version of 'typeSpec'.
  ;; If 'typeSpec' is @VOID, a new empty list is returned.
  (if (void? typeSpec)
      (return (list))
    (return (list typeSpec))))

(defun (slot-from-expression-tree SLOT) ((tree CONS))
  ;; The parse tree 'tree' calls some kind of slot, representing a 
  ;;    storage slot, method, or function.  Figure out what the slot
  ;;    object is and return it.
  ;; If the slot can't be found, return `null'.
  (when (eql? (quote TYPED-SYS) (first tree))
    (setq tree (second tree)))
  (case (first tree)
    ((SYS-SLOT-VALUE SYS-CALL-METHOD
                     SYS-SLOT-VALUE-SETTER SYS-CALL-METHOD-SETTER)
     (return (safe-lookup-slot (type-class (cast (second tree) TYPE))
                               (third tree))))
    (SYS-CALL-FUNCTION
     (let ((function (lookup-function-or-stella-function (second tree))))
       (when (and (defined? function)
                  (isa? function @METHOD-SLOT))
         (return function))))
    (otherwise
     (return NULL)))
  (return NULL))

(defun (walk-mv-tree OBJECT CONS (LIST OF TYPE-SPEC)) ((tree OBJECT))
  ;; Multiple-value analog to 'walk-a-tree'.
  ;; Return the walked tree, the values tree, and the list of value types.
  (let ((oTree OBJECT NULL)
        (oType TYPE-SPEC NULL)
        (slot SLOT NULL))
    (when (values-tree? tree)
      (return (walk-mv-values-tree tree)))
    (mv-setq (oTree oType)
      (walk-a-tree tree))
    (when (cons? oTree)
      (setq slot (slot-from-expression-tree oTree)))
    (when (defined? slot)
      (typecase slot
        (METHOD-SLOT
         (return oTree NULL (copy (method-return-type-specifiers slot))))
        (otherwise NULL)))
    (return oTree NULL (listify-type-spec oType))))

(defun (walk-mv-values-tree CONS CONS (LIST OF TYPE-SPEC)) ((tree CONS))
  ;; Multiple-value-walk a '(VALUES ...)' tree.
  ;; Return the walked tree, the values tree, and a list of value types.
  ;; The values tree will be a PROGN nested within the walked tree.
  (when (eq? (length tree) 1)
    (return tree tree (listify-type-spec @VOID)))
  (let ((oTree OBJECT NULL)
        (oType TYPE-SPEC NULL)
        (returnTypes (new (LIST OF TYPE-SPEC)))
        (typedSysTree CONS NULL))
    (ignore oType)
    (mv-setq (oTree oType)
      (walk-values-tree tree))
    ;; 'walk-values-tree' destructively modifies 'tree' to be of the form
    ;; '(PROGN <value-1> ... <value-N>)' where each value is a non-procedural
    ;; expression wrapped in a TYPED-SYS to record its type (since in here we
    ;; might not have enough context to rewalk the values to get their types):
    (setf (first tree) (quote VALUES))
    (foreach it on (rest tree)
             do
             (setq typedSysTree (value it))
             (push returnTypes (third typedSysTree))
             ;; Unwrap @UNKNOWNs to not upset coersion:
             (when (eql? @UNKNOWN (third typedSysTree))
               (setf (value it) (second typedSysTree))))
    (return oTree tree (reverse returnTypes))))

(defun (coerce-mv-tree OBJECT CONS (LIST OF TYPE-SPEC))
       ((tree OBJECT)  (operator SYMBOL)
        (sourceTypes (LIST OF TYPE-SPEC))
        (targetTypes (LIST OF TYPE-SPEC)))
  ;; Multiple-value analog to 'coerce-a-tree'.
  ;; 'tree' is an expression returning length of 'sourceTypes' values.  It
  ;;    is assumed that the number of source and target types is the same.
  ;; Runs 'coerce-a-tree' on each sourceType/targetType pair and returns
  ;;    a possibly modified tree, a values tree, and a possibly modified
  ;;    list of target types.  If any coersion or cast was necessary,
  ;;    temporary variables might be used to hold individual return values
  ;;    of multiple-valued functions so that they can be coerced.
  (let ((valuesTree? (values-tree? tree))
        (valuesTree NIL)
        (needTemporaries? FALSE)
        (success? BOOLEAN NULL)
        (oTree OBJECT NULL)
        (oType TYPE-SPEC NULL)
        (returnTypes (new (LIST OF TYPE-SPEC))))
    (cond (valuesTree?
           (setq valuesTree tree))
          (otherwise
           ;; Create dummy values with appropriate types:
           (setq valuesTree (bquote (VALUES)))
           (foreach type in sourceTypes
                    collect (sys-tree NULL type) into valuesTree)))
    (foreach tgtTs in targetTypes
	     as srcTs in sourceTypes
	     as i in (interval 1 NULL)
	     as it on (rest valuesTree)
	do (mv-setq (oTree oType success?)
	     (help-coerce-a-tree (value it) srcTs tgtTs FALSE))
	   (unless success?
	     (walk-error
	      "Type clash on argument " i " of " operator " operator."
	      EOL " " srcTs " found where " tgtTs " expected")
	     (return tree (choose valuesTree? tree NULL) (copy targetTypes)))
	   ;; Check whether explicit coersion/cast code was added (in C++
	   ;; we wouldn't need temporaries if only the first return value
	   ;; needs a cast, but in Lisp we do, so, for simplicity
	   ;; we always use them):
	   (when (or (not (eql? oTree (value it)))
		     ;; Check whether we need to "upcast" C++ return
		     ;; (reference) variables via temporaries, e.g.,
		     ;; Cons*& to Object*&:
		     (and (> i 1)
			  (not valuesTree?)
			  (not (eql? (translator-output-language)
				     :common-lisp))
			  (not (eql? (type-spec-to-base-type tgtTs)
				     @UNKNOWN))
			  (not (eql? (type-spec-to-base-type srcTs)
				     (type-spec-to-base-type tgtTs)))))
	     (setq needTemporaries? TRUE))
	   (setf (value it) oTree)
	collect oType into returnTypes)
    (when valuesTree?
      (return tree tree returnTypes))
    (when (not needTemporaries?)
      (return tree NULL returnTypes))
    (setq valuesTree (bquote (VALUES)))
    (foreach i in (interval 1 (length targetTypes))
	do (ignore i)
	collect (local-gensym "VALUE") into valuesTree)
    (setq oTree
      (walk-without-type-tree
       (bquote (mv-bind & (copy-cons-list (rest valuesTree))
                 & tree
                 & valuesTree))))
    (setf (first valuesTree) (quote (VALUES)))
    (foreach it on (rest valuesTree)
             as srcTs in sourceTypes
             as tgtTs in targetTypes
             do (setf (value it) (coerce-a-tree (value it) srcTs tgtTs)))
    (return oTree valuesTree returnTypes)))

(defun (walk-return-and-unbind-specials CONS TYPE-SPEC) ((tree CONS))
  (let ((unbindTree (yield-return-special-unbind-tree))
        (valueTrees (rest tree))
        (valueVariables NIL)
        (valueBindings (CONS OF CONS) NIL))
    (special ((*specialsEnabled?* FALSE))
      ;; Case 1: No return values:
      (when (eq? (length valueTrees) 0)
        (return (walk-a-cons-tree (bquote (progn & unbindTree & tree)))))
      
      ;; Since return-value expressions might reference special variables,
      ;; we can't unbind them before all return expressions got evaluated,
      ;; hence, we have to save the values, unbind the specials, and then
      ;; return the previously saved values.
      
      ;; Case 2: Multiple return values from a single value tree:
      (when (and (eq? (length valueTrees) 1)
                 (non-empty?
                  (rest (method-return-type-specifiers *methodBeingWalked*))))
        (foreach i in (interval 0 (1- (length (method-return-type-specifiers
                                               *methodBeingWalked*))))
            do (ignore i)
            collect (local-gensym "RETURN-VALUE") into valueVariables)
        (setf (rest tree) valueVariables)
        (return (walk-a-cons-tree
                 (bquote (mv-bind & (copy-cons-list valueVariables)
                           & (first valueTrees)
                           && (tree-to-trees unbindTree)
                           & tree)))))
      
      ;; Case 3: One or more return values from individual value trees:
      (foreach it on valueTrees
          where (or (cons? (value it))
                    ;; Only save the values of atomic value expressions if
                    ;;    they are one of the specials about to be unbound:
                    (and (symbol? (value it))
                         (defined? (lookup-old-value-variable (value it)))))
          do (pushq valueBindings
                    (bquote (& (local-gensym "RETURN-VALUE")
                               & (value it))))
             (setf (value it) (first (first valueBindings))))
      (return (walk-a-cons-tree
               (bquote (let & (reverse valueBindings)
                            && (tree-to-trees unbindTree)
                            & tree)))))))

(defun (walk-return-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk method or function return statement.
  (when (not (defined? *methodBeingWalked*))
    (walk-error
     "Return statement encountered outside of method or function definition")
    (return (walk-dont-call-me-tree tree @VOID)))
  (setq *foundReturn?* TRUE)
  (when (need-to-unbind-specials?)
    (return (walk-return-and-unbind-specials tree)))
  (let ((method *methodBeingWalked*)
        (targetTypes (new LIST)))
    (foreach rType in (method-return-type-specifiers method)
             collect (compute-relative-type-spec rType (slot-owner method))
             into targetTypes)
    (mv-bind (oTree valuesTree valueTypes)
        (walk-mv-expression-tree
         (choose (and (eq? (length (rest tree)) 1)
                      (non-empty? (rest targetTypes)))
                 (second tree)
                 (bquote (values && (rest tree))))
         targetTypes
         (quote RETURN))
      (free targetTypes)
      (free valueTypes)
      (when (null? valuesTree)
        (when (non-empty? (rest tree))
          (setf (second tree) oTree))
        (return tree @VOID))
      ;; clobber VALUES operator, possibly nested within oTree:
      (setf (first valuesTree) (quote RETURN))
      (return oTree @VOID))))

(defun (walk-mv-setq-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk an 'mv-setq' (multiple-valued setq) statement.
  (when (or (bad-argument-count? tree 2)
            (not (cons? (second tree)))
            (not (forall v in (safe-cast (second tree) CONS)
                         always (symbol? v))))
    (walk-error "Illegal 'mv-setq' expression: " tree)
    (return (walk-dont-call-me-tree tree @VOID)))
  (let ((variables CONS (second tree))
        (targetTypes (new (LIST OF TYPE-SPEC))))
    (foreach it on variables
        do (setf (value it) (true-variable-name (value it)))
        collect (lookup-variable-type (value it)) into targetTypes)
    (mv-bind (oTree valuesTree valueTypes)
        (walk-mv-expression-tree (third tree) targetTypes (quote MV-SETQ))
      (free valueTypes)
      (free targetTypes)
      (when (defined? valuesTree)
        (setf (first valuesTree) (quote PROGN))
        (foreach it on (rest valuesTree)
                 as var in variables
                 do (setf (value it)
                      (bquote (setq & var & (value it)))))
        (setf (rest (rest tree)) NIL)
        (return (sys-tree oTree @VOID)))
      (setf (third tree) oTree)
      (return (sys-tree tree @VOID)))))

(defun (walk-mv-bind-tree CONS TYPE-SPEC)  ((tree CONS))
  ;; Walk a multiple value bind statement; convert it into a
  ;;    LET statement containing an MV-SETQ.
  (when (or (< (length tree) 3)
            (not (cons? (second tree))))
    (walk-error "Illegal 'mv-bind' expression: " tree)
    (return (walk-dont-call-me-tree tree @VOID)))
  (let ((declarations CONS (second tree))
        (mvTree (third tree))
        (body (rest (rest (rest tree))))
        (variables NIL)
        (decl OBJECT NULL)
        (targetTypes (new (LIST OF TYPE-SPEC))))
    (foreach
     it on declarations
     do
     (setq decl (value it))
     (typecase decl
       (CONS
        (unless (and (symbol? (first decl))
                     (eq? (length decl) 2))
          (walk-error "Illegal variable declaration " decl
                      " in 'mv-bind' expression: " tree)
          (return (walk-dont-call-me-tree tree @VOID)))
        (push targetTypes (yield-type-specifier (second decl)))
        (setf (rest (rest decl)) (bquote (NULL)))
        (pushq variables (first decl)))
       (SYMBOL
        (push targetTypes @UNKNOWN)
        (setf (value it) (bquote (& decl @UNKNOWN NULL)))
        (pushq variables decl))
       (otherwise
        (walk-error "Illegal variable " decl " in 'mv-bind' expression: " tree)
        (return (walk-dont-call-me-tree tree @VOID)))))
    (setq variables (reverse variables))
    ;; Protect against illegal references to variables bound in the 'mv-bind':
    (foreach variable in variables
             do (push-variable-binding variable @UNINITIALIZED))
    (mv-bind (oMvTree valuesTree variableTypes)
        (walk-mv-expression-tree mvTree (reverse targetTypes) (quote MV-BIND))
      (foreach variable in variables
	  do (ignore variable)
	     (pop-variable-binding))
      (free targetTypes)
      (setf (rest (rest (rest tree))) NIL)
      (foreach decl in (cast declarations (CONS OF CONS))
               as type in variableTypes
               where (eql? @UNKNOWN (second decl))
               do (setf (second decl) type))
      (free variableTypes)
      (cond ((defined? valuesTree)
             (setf (first valuesTree) (quote PROGN))
             (foreach it on (rest valuesTree)
                      as var in variables
                      do (setf (value it)
                           (bquote (setq & var & (value it)))))
             (setq valuesTree oMvTree))
            (otherwise
             (setq valuesTree
               (bquote (mv-setq & variables & oMvTree)))))
      (return
        (walk-a-cons-tree
         (bquote (let & declarations
                      & valuesTree
                      && body)))))))

  ;;
;;;;;; 'loops' and 'conditionals'
  ;;

(defun (walk-loop-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk LOOP statement.
  (special ((*nofSpecialsAtLoopEntry* (length *specialVariableStack*)))
    (setf (rest tree) (walk-list-of-statements (rest tree)))
    (return (sys-tree tree @VOID))))

(defun (walk-loop-exit-tree CONS TYPE-SPEC) ((tree CONS))
  (bad-argument-count? tree 0)
  (if (need-to-unbind-specials?)
      (let ((unbindTree (yield-loop-exit-special-unbind-tree)))
        (special ((*specialsEnabled?* FALSE))
          (return (walk-a-cons-tree (bquote (progn & unbindTree & tree))))))
    (return tree @VOID)))

(defun (walk-while-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk while loop.
  (special ((*nofSpecialsAtLoopEntry* (length *specialVariableStack*)))
    (let ((test (walk-expression-tree
                 (second tree) @BOOLEAN (quote WHILE) TRUE))
          (body (rest (rest tree))))
      (setf (second tree) test)
      (when (procedural-expression? test) ; need to eliminate VRLET?
        (setf (rest (rest tree)) NIL)   ; clip out loop body before gc
        (return
          (walk-a-cons-tree
           (bquote (LOOP (UNLESS & test (BREAK))
                         && body)))))
      (setf (rest (rest tree))
        (walk-list-of-statements (rest (rest tree))))
      (return tree @VOID))))

(defun (walk-conditional-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk 'IF', 'WHEN', or 'UNLESS' statement.
  ;; Walk the test and body(ies) of 'tree'.
  ;; Eliminate possible VRLETs in the test expression.
  (let ((operator (first tree))
        (test (walk-expression-tree (second tree) @BOOLEAN operator TRUE)))
    (setf (second tree) test)
    (when (procedural-expression? test)
      (return
       (transform-boolean-procedural-expression tree test) @VOID))
    ;; else: "test" is an ordinary expression. Expand the conditional
    ;;    body(ies):
    (case operator
      (IF
        (when (bad-argument-count? tree 3)
          (return (walk-dont-call-me-tree tree @VOID)))
        (setf (third tree) (walk-statement (third tree) TRUE))
        (setf (fourth tree) (walk-statement (fourth tree) TRUE)))
      ((WHEN UNLESS)
       (setf (rest (rest tree)) (walk-list-of-statements (rest (rest tree))))))
    (return tree @VOID) ))

(defun (walk-choose-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk 'CHOOSE' expression.
  ;; Walk the test and alternative expressions in 'tree'.
  ;; Eliminate possible VRLETs in the test expression.
  (let ((operator (first tree))
        (test (walk-expression-tree (second tree) @BOOLEAN operator TRUE))
        (temp OBJECT NULL)
        (type1 TYPE-SPEC NULL)
        (type2 TYPE-SPEC NULL)
        (type TYPE-SPEC NULL))
    (setf (second tree) test)
    ;------
    ;(choose (vrlet ((a b)) a) 3 4)
    ;=>
    ;(vrlet ((a b)) (choose a 3 4))
    ;------
    (when (vrlet-expression? test)
      (return
       (percolate-out-vrlet-expression tree test @BOOLEAN)))
    ;; else: "test" is an ordinary expression. Expand the alternatives:
    (when (bad-argument-count? tree 3)
      (return (walk-dont-call-me-tree tree @UNKNOWN)))
    (mv-setq (temp type1)
      (walk-expression-tree (third tree) *targetType* (quote CHOOSE) TRUE))
    (setf (third tree) temp)
    (mv-setq (temp type2)
      (walk-expression-tree (fourth tree) *targetType* (quote CHOOSE) TRUE))
    (setf (fourth tree) temp)
    (cond
     ((eq? type1 @UNKNOWN)
      (setq type type2)
      ;; coerce to other type if one expression is `null':
      (setf (third tree) (coerce-a-tree (third tree) type1 type)))
     ((eq? type2 @UNKNOWN)
      (setq type type1)
      ;; coerce to other type if one expression is `null':
      (setf (fourth tree) (coerce-a-tree (fourth tree) type2 type)))
     (otherwise
      (setq type
        (two-argument-least-common-supertype type1 type2))))
    (when (or (eql? type @VOID)
              (and (not (sub-type-spec-of? type @OBJECT))
                   (abstract? (type-spec-to-class type)))) ; NUMBER, UNKNOWN, etc.
      (walk-error "Incompatible subexpression types " type1 " and " type2
                  EOL " in 'choose' expression."))
    (when (or (vrlet-expression? (third tree))
              (vrlet-expression? (fourth tree)))
      (let ((resultVariable (local-gensym "CHOOSE-VALUE")))
        (return
         (walk-a-tree
          (bquote
           (vrlet ((& resultVariable & type NULL))
                  (if & (second tree)
                      (setq & resultVariable & (third tree))
                      (setq & resultVariable & (fourth tree)))
                  & resultVariable))))))
    (case (translator-output-language)
      (:common-lisp NULL)
      (otherwise
       ;; Generate upcasts to the common supertype if necessary:
       (when (and (not (eql? type1 type))
                  (not (sub-type-spec-of? type1 type2)))
         (setf (third tree) (bquote (cast & (third tree) & type))))
       (when (and (not (eql? type2 type))
                  (not (sub-type-spec-of? type2 type1)))
         (setf (fourth tree) (bquote (cast & (fourth tree) & type))))))
    (return tree type)))

(defun (walk-boolean-tree OBJECT TYPE-SPEC) ((tree CONS))
  ;; Walk the argument(s) of an AND, OR, or NOT.
  ;; Special logic in helping function insures that only an outer-most
  ;;    boolean operator calls 'percolate-out-boolean-vrlet-expressions'
  ;;    (to avoid creation of extraneous VRLETs).
  (let ((oTree (help-walk-boolean-tree tree)))
    (when (procedural-expression? oTree)
      (setq oTree (percolate-out-boolean-vrlet-expressions oTree)))
    (return oTree @BOOLEAN) ))

(defun (and-or-not-tree? BOOLEAN) ((tree OBJECT))
  ;; Return `true' if 'tree' is a cons headed by AND, OR, or NOT.
  (if (cons? tree)
    (case (value (cast tree CONS))
      ((AND OR NOT) (return TRUE))
      (otherwise (return FALSE)))
    (return FALSE)) )

(defun (help-walk-boolean-tree OBJECT) ((tree CONS))
  ;; Walk the argument(s) of an AND, OR, or NOT, and possibly
  ;;    simplify the expression.
  (let ((cursor (rest tree))
        (temp OBJECT NULL))
    ;; walk boolean arguments:
    (while (non-empty? cursor)
      (setf (value cursor)
            (choose (and-or-not-tree? (value cursor))
               (help-walk-boolean-tree (value cursor))
               (walk-expression-tree (value cursor) @BOOLEAN (first tree) TRUE)))
      (setq cursor (rest cursor)))
    (case (first tree)
      (AND
       (when (empty? (rest tree))       ; no arguments
         (return TRUE-WRAPPER))
       (when (empty? (rest (rest tree)))        ; exactly one argument
         (setq temp (second tree))
         (return temp)))
      (OR
       (when (empty? (rest tree))       ; no arguments
         (return FALSE-WRAPPER))
       (when (empty? (rest (rest tree)))        ; exactly one argument
         (setq temp (second tree))
         (return temp)))
      (NOT
       (when (bad-argument-count? tree 1)
         (return (walk-dont-call-me-tree tree @BOOLEAN)))))
    (return tree) ))

(defun (walk-cond-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk a COND tree.
  (foreach condition in (rest tree)
           do
           (typecase condition
             (CONS
              (unless (eq? (value condition) (quote OTHERWISE))
                (setf (value condition)
                  (walk-expression-tree
                   (value condition) @BOOLEAN (quote COND) TRUE))
                (when (procedural-expression? (value condition))
                  ;; To expand VRLETs, we need to convert to an IF:
                  (return (walk-a-cons-tree (cond-tree-to-if-tree tree)))))
              (setf (rest condition)
                (walk-list-of-statements (rest condition))))
             (otherwise
              (walk-error "Illegal condition in COND statement: " condition)
              (return (walk-dont-call-me-tree tree @VOID)))))
  (return tree @VOID) )

(defun (cond-tree-to-if-tree CONS) ((tree CONS))
  ;; Transform the COND 'tree' into an equivalent IF (or WHEN) tree.
  (let ((firstCondition (value (rest tree)))
        (otherConditions (rest (rest tree)))
        (firstTest OBJECT NULL))
    (typecase firstCondition
      (CONS
       (setq firstTest (value firstCondition))
       (cond ((eq? firstTest (quote OTHERWISE))
              (cond ((empty? otherConditions)
                     (setf (first tree) (quote PROGN))
                     (setf (rest tree) (rest firstCondition))
                     (return tree))
                    (otherwise
                     (setf (value firstCondition) (quote TRUE))
                     (return (cond-tree-to-if-tree tree)))))
             ((empty? otherConditions)
              (setf (first tree) (quote WHEN))
              (setf (rest tree) firstCondition)
              (return tree))
             (otherwise
              (setf (value firstCondition) (quote PROGN))
              (setf (second tree) (quote COND))
              (return (bquote (IF & firstTest
                                  & firstCondition
                                  & (cond-tree-to-if-tree (rest tree))))))))
      (otherwise
       (walk-error "Illegal condition in COND statement: " firstCondition)
       (return (walk-dont-call-me-tree tree @VOID))))))

  ;;
;;;;;; 'walk-case-tree'
  ;;

(defun (yield-hardcoded-case-symbol-id-or-ids OBJECT) ((caseTest OBJECT))
  ;; Helping function for 'walk-symbol-case-statement'.
  ;; Intern 'caseTest' in the permanent symbol table and return 
  ;;    its Stella symbol id.
  ;; CAUTION: 'Doesn't work for Common Lisp symbols other than SETF and SETQ.
  (when (eq? caseTest (quote OTHERWISE))
    (return caseTest))
  (let ((symbol SYMBOL NULL))
    (typecase caseTest
      (CONS
       ;; list of case symbols:
       (foreach it on caseTest
                do
                (setq symbol (cast (value it) SYMBOL))
		(unless (defined? (symbol-id symbol))
		  ;; TO DO: REPLACE WITH 'intern-generalized-symbol':
		  (setq symbol
		    (intern-permanent-symbol
		     (symbol-name symbol))))
		(setf (value it) (wrap-literal (symbol-id symbol)))
                (register-symbol symbol))
       (return caseTest))
      (SYMBOL
       (setq symbol caseTest)
       (unless (defined? (symbol-id symbol))
		  ;; TO DO: REPLACE WITH 'intern-generalized-symbol':
		  (setq symbol
		    (intern-permanent-symbol
		     (symbol-name symbol))))
       (register-symbol caseTest)
       (return (wrap-literal
		    ;; TO DO: REPLACE WITH 'intern-generalized-symbol':
		    (symbol-id symbol)))))))

(defun (walk-hardcoded-symbol-case-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk a case clause that dispatches on a symbol value.
  ;; Stella symbols are converted to integers.
  (setf (second tree)
    (bquote (symbol-id (cast & (second tree) GENERALIZED-SYMBOL))))
  (foreach cond in (cast (rest (rest tree)) (CONS OF CONS))
           do (setf (first cond) 
		(yield-hardcoded-case-symbol-id-or-ids (first cond))))
  (return (walk-case-tree tree)) )

(defglobal *type-predicate-table* (CONS OF CONS)
  ;; Type                  isa?-Predicate       subtype-of?-Predicate
  (bquote
   ((@BOOLEAN                 boolean?          subtype-of-boolean?)
    (@INTEGER                 integer?          subtype-of-integer?)
    (@LONG-INTEGER            long-integer?     subtype-of-long-integer?)
    (@FLOAT                   float?            subtype-of-float?)
    (@STRING                  string?           subtype-of-string?)
    (@CHARACTER               character?        subtype-of-character?)
    (@WRAPPER                 wrapper?          subtype-of-wrapper?)
    (@BOOLEAN-WRAPPER         boolean?          subtype-of-boolean?)
    (@INTEGER-WRAPPER         integer?          subtype-of-integer?)
    (@LONG-INTEGER-WRAPPER    long-integer?     subtype-of-long-integer?)
    (@FLOAT-WRAPPER           float?            subtype-of-float?)
    (@STRING-WRAPPER          string?           subtype-of-string?)
    (@CHARACTER-WRAPPER       character?        subtype-of-character?)
    (@VERBATIM-STRING-WRAPPER verbatim-string?  subtype-of-verbatim-string?)
    (@SURROGATE               surrogate?        subtype-of-surrogate?)
    (@TYPE                    type?             subtype-of-type?)
    (@SYMBOL                  symbol?           subtype-of-symbol?)
    (@TRANSIENT-SYMBOL        transient-symbol? subtype-of-transient-symbol?)
    (@KEYWORD                 keyword?          subtype-of-keyword?)
    (@CONS                    cons?             subtype-of-cons?)
    (@CLASS                   stella-class?     subtype-of-class?)
    (@STORAGE-SLOT            storage-slot?     subtype-of-storage-slot?)
    (@METHOD-SLOT             method-slot?      subtype-of-method-slot?)
    (@ANCHORED-TYPE-SPECIFIER anchored-type-specifier?
                              subtype-of-anchored-type-specifier?)
    (@PARAMETRIC-TYPE-SPECIFIER parametric-type-specifier?
                                subtype-of-parametric-type-specifier?)))
  :documentation "Table of specialized type predicates for various types.
These predicates have to be used instead of `isa?', since they also work
during bootstrap when only some class objects are defined.")

(defun (yield-isa?-case-test CONS) ((caseKey TYPE) (testExpression OBJECT))
  ;; Yield an `isa?'-style test to test the type of `testExpression'
  ;;    relative to `caseKey'.
  ;; Use a specialized type predicate if available:
  (foreach entry in *type-predicate-table*
      where (eql? (first entry) caseKey)
      do (return (bquote (& (second entry) & (copy-cons-tree testExpression)))))
  (return (bquote (isa? & (copy-cons-tree testExpression) & caseKey))))

(defun (yield-subtype-of?-case-test CONS) ((caseKey TYPE) (testExpression OBJECT))
  ;; Yield an `subtype-of?'-style test to test the type of `testExpression'
  ;;    relative to `caseKey'.
  ;; Use a specialized type predicate if available:
  (foreach entry in *type-predicate-table*
      where (eql? (first entry) caseKey)
      do (return (bquote (& (third entry) & (copy-cons-tree testExpression)))))
  (return (bquote (subtype-of? & (copy-cons-tree testExpression) & caseKey))))

(defun (yield-cond-test CONS)
       ((caseTest OBJECT) (testVariable OBJECT) (equalityTest SYMBOL))
  ;; Helping function for 'yield-cond-test-or-tests'.
  ;; Return an expression that tests whether 'caseTest' is equal to
  ;;    'testVariable' according to 'equalityTest' ('caseTest' has
  ;;    to be an atom).
  (when (and (symbol? caseTest)
	     (not (use-hardcoded-symbols?)))
    ;; Softcoded-Symbols turn into variables that point to them:
    (setq caseTest (bquote (TYPED-SYS 
			    & (register-symbol caseTest)
			    @SYMBOL))))
  (case equalityTest
    (ISA?
     (return (yield-isa?-case-test (typify caseTest) testVariable)))
    (SUBTYPE-OF?
     (return (yield-subtype-of?-case-test (typify caseTest) testVariable)))
    (otherwise
     (return
       (bquote (& equalityTest & (copy-cons-tree testVariable) & caseTest))))))

(defun (yield-cond-test-or-tests OBJECT)
       ((caseTest OBJECT) (testVariable OBJECT) (equalityTest SYMBOL))
  ;; Helping function for 'walk-non-built-in-case-tree'
  ;; Return an expression that tests whether 'castTest' is equal to
  ;;    'testVariable' ('castTest' could be a list).
  (typecase caseTest
    ;; list of case symbols:
    (CONS
     (foreach it on caseTest
              do (setf (value it)
                   (yield-cond-test (value it) testVariable equalityTest)))
     (pushq caseTest (quote OR))
     (return caseTest))
    (otherwise
     (if (eq? caseTest (quote OTHERWISE))
         ;; mildly tricky: case and cond OTHERWISE clauses have the same
         ;;    syntax, so we don't transform anything.
         (return caseTest)
       (return (yield-cond-test caseTest testVariable equalityTest))))))

(defun (count-case-test-clauses INTEGER BOOLEAN) ((tree CONS))
  ;; Return the number test clauses (non-otherwise clauses) in a CASE `tree'.
  ;; Return `true' as the second value if it contained an otherwise clause.
  (let ((clauses (cast (rest (rest tree)) (CONS OF CONS)))
        (nofClauses 0)
        (otherwise? FALSE))
    (foreach clause in clauses
        do (typecase (first clause)
             (CONS (++ nofClauses (length (cast (first clause) CONS))))
             (otherwise
              (if (eql? (first clause) (quote OTHERWISE))
                  (setq otherwise? TRUE)
                (++ nofClauses)))))
    (return nofClauses otherwise?)))

(defun (attach-unhandled-case-error-clause CONS)
    ((caseTree CONS) (testTree OBJECT))
  ;; If `caseTree' does not have an `otherwise' clause, attach one
  ;;    that raises an error if it is reached.
  (let ((lastClause (last caseTree)))
    (if (and (cons? lastClause)
             (not (eql? (first (cast lastClause CONS)) (quote OTHERWISE))))
        (return
          (bquote
           (&& caseTree
               (otherwise
                (error & (copy-cons-tree testTree)
                       " is not a valid case option")))))
      (return caseTree))))

(defun (walk-non-built-in-case-tree CONS TYPE-SPEC)
    ((tree CONS) (equalityTest SYMBOL))
  ;; Called by 'walk-case-tree'.
  ;; Transform a case statement into a conditional statement,
  ;;    and then walk the conditional.
  ;; Currently used for all tests except hardcoded symbols and integers.
  (let ((testExpression (second tree))
        (testVariable
         (choose (or (atomic-expression? testExpression)
                     (<= (count-case-test-clauses tree) 1))
                 (second tree)
                 (local-gensym "TEST-VALUE")))
        (conditions (rest (rest tree))))
    ;; transform CASE tests into COND tests:
    (foreach cond in (cast conditions (CONS OF CONS))
        do (setf (first cond)
             (yield-cond-test-or-tests 
              (first cond) testVariable equalityTest)))
    ;; If neccessary, add clause to detect unhandled case:
    (setq conditions (attach-unhandled-case-error-clause conditions testVariable))
    (return
     (walk-a-cons-tree
      ;; Avoid extra 'let' if 'testExpression' was a variable:
      (choose (eql? testExpression testVariable)
              (bquote (cond && conditions))
              (bquote 
               (let ((& testVariable & testExpression))
                 (cond && conditions))))) )))
  
(defun (walk-case-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk a CASE tree.
  ;; TO DO: CHECK WHETHER ALL CASE CONSTANTS HAVE A UNIFORM TYPE.
  (when (not (and (>= (length tree) 3)
                  (forall clause in (rest (rest tree))
                      always (cons? clause))))
    (walk-error "Illegal `case' statement: " tree)
    (return (walk-dont-call-me-tree tree @VOID)))
  (let ((clauses (cast (rest (rest tree)) (CONS OF CONS)))
        (firstTestTree
         (choose (cons? (first (first clauses)))
                 (first (cast (first (first clauses)) CONS))
                 (first (first clauses))))
        (caseConstantType @UNKNOWN))
    (typecase firstTestTree
      (SYMBOL (setq caseConstantType @GENERALIZED-SYMBOL))
      (SURROGATE (setq caseConstantType @GENERALIZED-SYMBOL))
      (KEYWORD (setq caseConstantType @GENERALIZED-SYMBOL))
      (STRING (setq caseConstantType @STRING))
      (CHARACTER (setq caseConstantType @CHARACTER))
      (INTEGER (setq caseConstantType @INTEGER))
      (LONG-INTEGER (setq caseConstantType @LONG-INTEGER))
      (FLOAT (setq caseConstantType @FLOAT))
      (otherwise
       (walk-error "`case' statement contains illegal constant of type "
                   (primary-type firstTestTree) EOL
                   "    " tree)
       (return (walk-dont-call-me-tree tree @VOID))))
    ;; walk test expression:
    (setf (second tree)
      (walk-expression-tree (second tree) caseConstantType (quote case) TRUE))
    (when (vrlet-expression? (second tree))
      (return
        (percolate-out-vrlet-expression tree (second tree) caseConstantType)))
    (when (and (eql? caseConstantType @GENERALIZED-SYMBOL)
               (use-hardcoded-symbols?))
      (return (walk-hardcoded-symbol-case-tree tree)))
    ;; convert to a 'cond' statement if the test is not
    ;;    of type INTEGER or CHARACTER:
    (unless (or (eql? caseConstantType @INTEGER)
                (eql? caseConstantType @LONG-INTEGER)
                (eql? caseConstantType @CHARACTER))
      (return (walk-non-built-in-case-tree
               tree
               (choose (eql? caseConstantType @STRING)
                       (quote string-eql?)
                       (quote eql?)))))
    (unless (eql? (translator-output-language) :common-lisp)
      ;; In Lisp we have an `ecase', in C++ and Java we have to check ourselves:
      (setq tree (attach-unhandled-case-error-clause tree (second tree))))
    ;; walk the test and statement parts of each condition:
    (let ((cursor (rest (rest tree)))
          (conditionTree CONS NULL))
      (while (non-empty? cursor)
        (setq conditionTree (value cursor))
        (unless (eq? (first conditionTree) (quote OTHERWISE))
          (setf (first conditionTree)
                (choose (cons? (first conditionTree))
                  (walk-list-of-trees (first conditionTree))
                  (walk-a-tree (first conditionTree)))))
        (setf (rest conditionTree)
              (walk-list-of-statements (rest conditionTree)))
        (setq cursor (rest cursor)))
      (return tree @VOID)) ))

(defun (walk-typecase-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk a TYPECASE tree.
  ;; A TYPECASE is similar to a Common-Lisp 'etypecase', but it has the
  ;;    additional feature that if the test expression is a variable,
  ;;    that variable will be cast to the type of the particular case
  ;;    in the case body.
  ;; TO DO:
  ;;  - Optimize to avoid multiple evaluations of `primary-type'.
  ;;  - Maybe optimize tests against known leaf classes.
  ;;  - Investigate use of native `CL:typecase' or type tests in Java.
  ;;  - Avoid generation of unnecessary casting helper variables.
  (let ((testTree (second tree))
        (testExpressionType TYPE-SPEC NULL)
        (testVariable SYMBOL NULL)
        (expandedCases NIL)
        ;; If we have a variable as a test expression we cast
        ;; it to the appropriate type in each case body:
        (needCast?
         ;; At this point, `testTree' should still be unwalked, so we don't use
         ;;    `variable-expression?' to test (if we did, we would need a reverse
         ;;    lookup for aliased locals):
         (and (symbol? testTree)
              (null? (lookup-global-variable (cast testTree SYMBOL)))))
        (precedingClauseTypes (new LIST)))
    (when needCast?
      (setq testVariable testTree))
    (mv-setq (testTree testExpressionType)
      (walk-a-tree testTree))
    (setf (second tree) testTree)
    (setq testExpressionType (type-spec-to-base-type testExpressionType))
    (when (unknown-type? testExpressionType)
      (setq testExpressionType @UNKNOWN))
    (setf (second tree) (sys-tree testTree testExpressionType))
    ;; If we need to cast the test variable, multi-type cases
    ;; have to be expanded into separate cases by copying them:
    (when needCast?
      (foreach
       caseTree in (rest (rest tree))
       do (typecase caseTree
            (CONS
             (let ((typeTree (first caseTree)))
               (typecase typeTree
                 (CONS
                  (setf (first caseTree) (first typeTree))
                  (pushq expandedCases caseTree)
                  (foreach
                   type in (rest typeTree)
                   do (pushq expandedCases
                             (bquote
                              (& type
                               && (cast (copy-cons-tree (rest caseTree))
                                        CONS))))))
                 (otherwise
                  (pushq expandedCases caseTree)))))
            (otherwise
             (pushq expandedCases caseTree))))
      (setf (rest (rest tree)) (reverse expandedCases)))
    ;; Now do the normal checking and preprocessing:
    (foreach
     caseTree in (rest (rest tree))
     do (typecase caseTree
          (CONS
           (let ((typeTree (first caseTree)))
             (typecase typeTree
               ((SYMBOL SURROGATE)
                (unless
                    ;; This test works for symbols and surrogates alike:
                    (string-eql? (symbol-name typeTree) "OTHERWISE")
                  (let ((type
                         ;; Deal with defined types:
                         (type-spec-to-base-type
                          (yield-type-specifier typeTree))))
                    (verify-typecase-clause-type
                     testExpressionType type precedingClauseTypes caseTree)
                    (setf (first caseTree) type)
                    ;; STRING really means STRING-WRAPPER:
                    (setq type (type-to-wrapped-type type))
                    (when (and needCast?
                               (non-empty? (rest caseTree)))
                      (setf (rest caseTree)
                        (yield-casted-typecase-clause-trees
                         testVariable type (rest caseTree)))))))
               (CONS
                (foreach
                 it on typeTree
                 do (when (cons? (value it))
                      (walk-error "Illegal type expression in 'typecase': "
                                  typeTree)
                      (return (walk-dont-call-me-tree tree @VOID)))
                    (setf (value it)
                      ;; Deal with defined types:
                      (type-spec-to-base-type
                       (yield-type-specifier (value it))))
                    (verify-typecase-clause-type
                     testExpressionType (value it) precedingClauseTypes caseTree)))
               (otherwise
                (walk-error "Illegal type expression in 'typecase': "
                            typeTree)
                (return (walk-dont-call-me-tree tree @VOID))))))
          (otherwise
           (walk-error "Illegal case expression in 'typecase': " caseTree)
           (return (walk-dont-call-me-tree tree @VOID)))))
    ;; Finally, call 'walk-non-built-in-case-tree' to generate a 'cond':
    (return
      (walk-non-built-in-case-tree
       (bquote (CASE (safe-primary-type & (second tree)) && (rest (rest tree))))
       (quote subtype-of?)))))

(defun (yield-casted-typecase-clause-trees CONS)
    ((testVariable SYMBOL) (clauseType TYPE-SPEC) (clauseTrees CONS))
  ;; Generate a list of trees from `clauseTrees' where each reference to
  ;;    `testVariable' is properly casted to `clauseType'.
  ;; For various reasons, this does something slightly different for
  ;;     each individual target language.
  (let ((testVariableType
         (lookup-variable-type testVariable))
        (needRealCast?
         (not (eql? (translator-output-language) :common-lisp)))
        (auxVariable
         (choose (and (not (rename-shadowing-local-variables?))
                      needRealCast?)
                 (local-gensym (symbol-name testVariable))
                 NULL))
        (castedClauseTrees CONS NULL))
    (cond
     ((not needRealCast?)
      (push-variable-binding testVariable clauseType)
      (setq castedClauseTrees
        (bquote
         ((void-sys
           ;; unfortunately, this translates into a redundant `progn':
           (progn && (walk-list-of-statements clauseTrees))))))
      (pop-variable-binding))
     (otherwise
      (when (defined? auxVariable)
        (push-variable-binding auxVariable testVariableType))
      (setq castedClauseTrees
        (bquote
         ;; Better would be to walk the body, find out if the variable was
         ;;    actually used, and only then generate the 'let'-style cast.
         ;; Also, we could rename in C++ to avoid the auxiliary variable.
         ((let & (choose
                  (defined? auxVariable)
                  (bquote
                   ((& auxVariable & testVariable)
                    (& testVariable & clauseType & auxVariable)))
                  (bquote
                   ((& testVariable
                       (safe-cast
                        & (sys-tree (walk-without-type-tree  testVariable)
                                    clauseType)
                        & clauseType)))))
               && clauseTrees))))
      (when (defined? auxVariable)
        (pop-variable-binding))))
    (return castedClauseTrees)))

(defun verify-typecase-clause-type
    ((testType TYPE) (clauseType TYPE)
     (precedingClauseTypes (LIST OF TYPE)) (clause CONS))
  ;; Verify the validity of `clauseType' (the type of the current `clause')
  ;;    relative to the type of the test expression `testType' and the types
  ;;    of preceding clauses passed in `precedingClauseTypes'.
  ;; If `clauseType' passes all tests, add it to the front of
  ;;    `precedingClauseTypes'.
  ;; PERFORMANCE BUG: For huge `typecase's, the quadratic runtime of checking
  ;;    against `precedingClauseTypes' might kill us.
  (let ((shadowingType TYPE NULL)
        (wrappedClauseType
         ;; @STRING really means @STRING-WRAPPER:
         (type-to-wrapped-type clauseType)))
    (when (defined? wrappedClauseType)
      (setq clauseType wrappedClauseType))
    (cond
     ((unknown-type? clauseType)
      (walk-error
       "Reference to undefined or unwrappable non-object type in `typecase': "
       clauseType))
     ((and (not (eql? testType @UNKNOWN))
           (not (sub-type-spec-of? clauseType testType)))
      (walk-warn "Type " clauseType " of `typecase' clause " EOL
                 "    " clause EOL
                 " is not a subtype of the test expression type " testType))
     ((setq? shadowingType
             (some type in precedingClauseTypes
                 where (subtype-of? clauseType type)))
      (walk-warn "Type " clauseType " of `typecase' clause " EOL
                 "    " clause EOL
                 " is shadowed by type " shadowingType))
     (otherwise
      (push precedingClauseTypes clauseType)))))

#|
;;; Unfortunately, the `optimization' scheme below which used a special
;;;    cache structure and runtime-optimzied subtype tests produced
;;;    a `negative' speed-up, which is why it is disabled.

(defun (optimize-typecase? BOOLEAN) ()
  ;; Return `true' if the type tests of `typecase's should be optimized.
  (return (and (defined? *methodBeingWalked*)
               (method-call-inlining-enabled?))))

(defun (walk-optimized-typecase-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Translate a `typecase' to allow runtime-optimzation of subtype tests.
  ;; To use this, it needs to be called by `walk-typecase-tree' instead
  ;;    of `walk-non-built-in-case-tree'.
  ;; Equally disabled runtime support for this translation scheme can be
  ;;    found in `type-predicates.ste'.
  (let ((clauses (cast (rest (rest tree)) (CONS OF CONS)))
        (nofClauses (length clauses))
        (clauseKeys (CONS OF TYPE) NIL))
    (when (or (<= nofClauses 1)
              (and (= nofClauses 2)
                   (eql? (first (last clauses)) (quote OTHERWISE))))
      (return (walk-non-built-in-case-tree tree (quote isa?))))
    (foreach clause in clauses
        do (typecase (first clause)
             (CONS
              (foreach it on (cast (first clause) CONS)
                  do (setf (value it)
                       (canonical-type
                        (type-to-wrapped-type (cast (value it) TYPE))))
                     (pushq clauseKeys (value it))))
             (otherwise
              (unless (eql? (first clause) (quote OTHERWISE))
                (setf (first clause)
                  (canonical-type
                   (type-to-wrapped-type (cast (first clause) TYPE))))
                (pushq clauseKeys (first clause))))))
    (mv-bind (string code)
        (encode-typecase-keys (reverse clauseKeys) *methodBeingWalked*)
      (setf (second tree)
        (bquote (select-typecase-clause & (second tree) & string & code)))
      (return (walk-non-built-in-case-tree tree (quote eql?))))))
|#

  ;;
;;;;;; Multi-processing support
  ;;

(defun (walk-with-process-lock-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk a `with-process-lock-tree' form.
  (setf (second tree)
    (walk-expression-tree 
     (second tree) @PROCESS-LOCK-OBJECT (first tree) TRUE))
  (setf (rest (rest tree)) (walk-list-of-statements (rest (rest tree))))
  (return (sys-tree tree @VOID)))


  ;;
;;;;;; Equality
  ;;

;;; TO DO: CHECK WHETHER 3.0 == 3 IN C++.  PROBABLY SO, BUT USES
;;;    COERSION.  FIGURE OUT HOW TO EMULATE THAT IN THIS METHOD:
(defun (finish-walking-eql-tree CONS TYPE-SPEC)
       ((tree CONS) (type1 TYPE) (type2 TYPE))
  ;; Finish walking 'eql?' test.
  ;; If either or both arguments are statically typed as STANDARD-OBJECTs,
  ;;    NON-OBJECTs, or LITERALs, then substitute an 'eq?' or 'string-eql?'
  ;;    test, plus any needed de-encapsulation code.
  ;; Otherwise, leave it as an 'eql?' test that dynamically determines
  ;;    how to de-wrap.
  (when (or (subtype-of? type1 @STANDARD-OBJECT)
            (subtype-of? type2 @STANDARD-OBJECT)
            (and (eql? type1 @BOOLEAN-WRAPPER)
                 (eql? type2 @BOOLEAN-WRAPPER))
            ;; NON-OBJECTs that are not literals are also compared with 'eq?':
            (and (not (subtype-of? type1 @OBJECT))
                 (not (subtype-of? type1 @LITERAL)))
            (and (not (subtype-of? type2 @OBJECT))
                 (not (subtype-of? type2 @LITERAL))))
    (setf (first tree) (quote EQ?))
    ;; Record the expression types for the sake of the CL translator:
    (setf (second tree) (sys-tree (second tree) type1))
    (setf (third tree) (sys-tree (third tree) type2))
    (return tree @BOOLEAN))
  ;; we are comparing two objects that might or might not be literals.
  ;; if the types are both literals, we get a quick exit:
  (when (and (subtype-of? type1 @LITERAL)
             (subtype-of? type2 @LITERAL))
    (if (eq? type1 @STRING)
      (setf (first tree) (quote STRING-EQL?))
      (setf (first tree) (quote EQ?)))
    (return (walk-a-cons-tree tree)))
  ;; when neither type is a literal, we use a run-time EQL? test:
  (when (and (not (subtype-of? type1 @LITERAL))
             (not (subtype-of? type2 @LITERAL)))
    (mv-bind ((oTree OBJECT) (oType TYPE-SPEC))
        (walk-call-slot-tree tree)
      (return (cast oTree CONS) oType)))
  ;; at this point, exactly one of 'type1' or 'type2' indicates a
  ;;    LITERAL argument.  Swap arguments if necessary so that
  ;;    'type2' is the static type determiner.
  (when (not (subtype-of? type2 @LITERAL))
    (let ((tempArg (third tree))
          (tempType type2))
      (setf (third tree) (second tree))
      (setf (second tree) tempArg)
      (setq type2 type1)
      (setq type1 tempType)))
  ;; at this point, 'type2' indicates the kind of equality test, and the
  ;;    the second argument needs to be wrapped with de-encapsulation code:
  ;; TO DO: OPTIMIZE THIS FOR CASES WHERE WE KNOW THAT TYPE1 IS THE WRAPPED
  ;;    VERSION OF TYPE2.
  (case type2
    (@BOOLEAN (setf (first tree) (quote EQL-TO-BOOLEAN?)))
    (@INTEGER (setf (first tree) (quote EQL-TO-INTEGER?)))
    (@LONG-INTEGER (setf (first tree) (quote EQL-TO-LONG-INTEGER?)))
    (@FLOAT (setf (first tree) (quote EQL-TO-FLOAT?)))
    (@STRING (setf (first tree) (quote EQL-TO-STRING?))))
  (return (walk-without-type-tree tree) @BOOLEAN) )

(defun (finish-walking-equal-tree CONS TYPE-SPEC)
       ((tree CONS) (type1 TYPE) (type2 TYPE))
  ;; Finish walking '=' test.
  (ignore tree type1 type2)
  (walk-error "finish-walking-equal-tree: NOT YET IMPLEMENTED.")
  (return NULL @BOOLEAN) )

(defun (walk-equality-tree OBJECT TYPE-SPEC) ((tree CONS))
  ;; Walk an EQ?, EQL?, or '=' parse tree.
  ;; '=' is treated as a synonym for 'EQ?'.
  (let ((arg1 OBJECT NULL)
        (arg2 OBJECT NULL)
        (type1 TYPE-SPEC NULL)
        (type2 TYPE-SPEC NULL))
    (mv-setq (arg1 type1)
      (walk-expression-tree (second tree) @UNKNOWN (first tree) TRUE))
    (mv-setq (arg2 type2)
      (walk-expression-tree (third tree) @UNKNOWN (first tree) TRUE))
    (setf (second tree) arg1)
    (setf (third tree) arg2)
    (when (vrlet-expression? arg1)
      (return (walk-a-tree
               (percolate-out-vrlet-expression tree arg1 @BOOLEAN))))
    (when (vrlet-expression? arg2)
      (return (walk-a-tree
               (percolate-out-vrlet-expression tree arg2 @BOOLEAN))))
    (setq type1 (canonical-type (type-spec-to-base-type type1)))
    (setq type2 (canonical-type (type-spec-to-base-type type2)))
    (unless (or (eql? type1 @UNKNOWN)
                (eql? type2 @UNKNOWN)
                (subtype-of? type1 type2)
                (subtype-of? type2 type1)
                ;; CL:= and C++/Java's == transparently compare numbers of different types:
                (and (subtype-of? type1 @NUMBER)
                     (subtype-of? type2 @NUMBER))
                ;; these are comparable via the `EQL-TO-X' functions:
                (subtype-of? (type-to-wrapped-type (cast type1 TYPE)) type2)
                (subtype-of? (type-to-wrapped-type (cast type2 TYPE)) type1))
      (walk-warn "This equality test will always fail due to disjoint "
                 "argument types:" EOL "    " tree))
    (case (first tree) 
      ((EQ? =)
       (setf (first tree) (quote EQ?))
       ;; Record the expression types for the sake of the CL translator:
       (setf (second tree) (sys-tree (second tree) type1))
       (setf (third tree) (sys-tree (third tree) type2))
       (return tree @BOOLEAN))
      (EQL? (return (finish-walking-eql-tree tree type1 type2)))
      ;;(= (return (finish-walking-equal-tree tree type1 type2)))
      )))


  ;;
;;;;;; Arithmetic expressions
  ;;

(defglobal *numeric-type-hierarchy* (LIST OF TYPE)
  (list @INTEGER @LONG-INTEGER @FLOAT @NUMBER))

(defun (more-general-numeric-type TYPE) ((type1 TYPE) (type2 TYPE))
  ;; Return the more general of 'type1' and 'type2' according to
  ;;    '*numeric-type-hierarchy*'.
  (let ((position1 (position *numeric-type-hierarchy* type1 0))
        (position2 (position *numeric-type-hierarchy* type2 0)))
    (when (or (null? position1)
              (null? position2))
      ;; One of the types was non-numeric:
      (return @NUMBER))
    (if (> position1 position2)
        (return type1)
      (return type2))))

(defun (yield-arithmetic-operator-call-tree CONS)
    ((operator SYMBOL) (operands CONS))
  ;; Return a tree to call the arithmetic 'operator' on 'operands'.
  (return (bquote (SYS-CALL-METHOD @NUMBER & operator && operands))))

(defun (yield-nested-arithmetic-operator-call-tree CONS)
    ((operator SYMBOL) (operands CONS))
  ;; Return a nested tree to call the arithmetic 'operator' on 'operands'
  ;;    where each individual call is on exactly two operands.
  ;; It is assumed that there are at least two 'operands'.
  (let ((nofOperands (length operands))
        (parenthesizedTree
         (yield-arithmetic-operator-call-tree
          operator (cons-list (first operands) (second operands)))))
    (foreach i in (interval 2 (1- nofOperands))
             do
             (setq parenthesizedTree
               (yield-arithmetic-operator-call-tree
                operator (cons-list parenthesizedTree (nth operands i)))))
    (return parenthesizedTree)))

(defun (walk-arithmetic-tree OBJECT TYPE) ((tree CONS))
  ;; Walk an arithmetic tree of the form '(+|-|*|/ <arg>*)'.
  ;; All operators behave exactly like their Common-Lisp analogues, with
  ;;    the exception that '/' always performs a floating-point division.
  ;; CAVEAT: Code that needs to be translatable by the bootstrap walker
  ;;    has to always use the operators with two arguments only.
  (let ((operator (first tree))
        (operands (rest tree))
        (nofOperands (length operands))
        (operand OBJECT NULL)
        (operandType TYPE-SPEC NULL)
        (returnType @INTEGER))
    ;; Handle zero- and single-argument special cases:
    (case nofOperands
      (0 (case operator
           (+ (return (wrap-literal 0) @INTEGER))
           (* (return (wrap-literal 1) @INTEGER))
           (otherwise
            (bad-argument-count? tree 1)
            (return (walk-dont-call-me-tree tree @NUMBER)))))
      (1 (case operator
           ((+ *) (return
                    (walk-expression-tree
                     (first operands) @NUMBER operator FALSE)))
           ;; For '-' and '/' we use the Common-Lisp semantics:
           ((- /) (setf (rest operands) (bquote (& (first operands))))
                  (setf (first operands)
                    (choose (eql? operator (quote -))
                            (wrap-literal 0)
                            (wrap-literal 1))))))
      (otherwise NULL))
    ;; Walk the operands:
    (foreach it on operands
        do (mv-setq (operand operandType)
             (walk-expression-tree (value it) @NUMBER operator FALSE))
           (setq returnType
             (more-general-numeric-type
              returnType (type-spec-to-base-type operandType)))
           (setf (value it) operand))
    ;; Enforce floating-point division:
    (when (and (eql? operator (quote /))
               (or (eql? returnType @INTEGER)
                   (eql? returnType @LONG-INTEGER)))
      ;; Force a uniform behavior by always performing a floating-point
      ;; division (without that Common-Lisp would use ratios and C++ or
      ;; Java would perform truncating integer division).  This means
      ;; we'll probably need a 'div' function for efficient integer
      ;; division.
      (cond
       ((wrapper? (first operands))
        (setf (first operands) (coerce-to-float (first operands))))
       ((wrapper? (second operands))
        (setf (second operands) (coerce-to-float (second operands))))
       (otherwise
	(setq operands (bquote ((cast & (first operands) @FLOAT) && (rest operands))))
        (++ nofOperands)))
      (setq returnType @FLOAT))
    ;; Return a (possibly nested) result tree:
    (if (and (> nofOperands 2)
             (not (eql? (translator-output-language) :common-lisp)))
        (return
          (sys-tree ;; preserve most specific type for coercion rewalking:
           (yield-nested-arithmetic-operator-call-tree operator operands)
           returnType))
      (return
        (sys-tree ;; preserve most specific type for coercion rewalking:
         (yield-arithmetic-operator-call-tree operator operands)
         returnType)))))


  ;;
;;;;;; walking QUOTE and BQUOTE
  ;;

(defun (walk-quoted-tree OBJECT TYPE-SPEC) ((tree CONS))
  ;; Construct a parse tree representing a quoted version of 'tree' 
  ;;    and return it.
  (when (bad-argument-count? tree 1)
    (return (walk-dont-call-me-tree tree @UNKNOWN)))
  (let ((argument (second tree))
        (quotedLiteral? (or (not (cons? argument))
                            (nil? argument)))
        (objectName STRING NULL))
    (when quotedLiteral?
      (mv-bind ((oTree OBJECT) (oType TYPE-SPEC))
          (walk-a-tree (bquotify argument))
        (return oTree oType)))
    ;; Otherwise, we must have a quoted cons.  Return a tree that
    ;;   looks up a quoted cons tree by its name in a global table:
    (setq objectName (name-quoted-tree argument))
    (return
      (walk-a-tree
       (bquote
        (get-quoted-tree
         & (wrap-literal objectName)
         & (wrap-literal (module-full-name *module*))))))))

(defun (walk-bquote-tree OBJECT TYPE-SPEC) ((tree CONS))
  ;; Construct a parse tree representing a bquote version of 'tree'
  ;;    and return it.
  (when (bad-argument-count? tree 1)
    (return (walk-dont-call-me-tree tree @UNKNOWN)))
  (mv-bind ((oTree OBJECT) (oType TYPE-SPEC))
      (walk-a-tree (simplify-bquote-tree (expand-bquote-tree (second tree))))
    (return oTree oType)))

(defun (expand-macro OBJECT) ((tree CONS))
  ;; Return the expansion of the macro expression 'tree'.
  ;; Assumes that 'tree' really is a macro expression.
  (let ((macroName (cast (first tree) SYMBOL))
        (expanderObject (lookup-macro macroName))
        (expanderCode (function-code expanderObject))
        (args (rest tree))
        (expansion OBJECT NULL))
    (when (null? expanderCode)
      (walk-error "Macro expander code for " macroName " is not available")
      (return (walk-dont-call-me-tree tree @UNKNOWN)))
    (if (method-body-argument? expanderObject)
      (case (method-argument-count expanderObject)
        (1
         (setq expansion (funcall expanderCode args))
         (setf (rest tree) NIL))        ; clip off &body argument
        (2
         (setq expansion (funcall expanderCode (first args) (rest args)))
         (setf (rest args) NIL))        ; clip off &body argument
        (3
         (setq expansion
               (funcall expanderCode
                        (first args) (second args) (rest (rest args))))
         (setf (rest (rest args)) NIL))         ; clip off &body argument
        (4
         (setq expansion
               (funcall expanderCode 
                        (first args) (second args) (third args)
                        (nth-rest args 3)))
         (setf (nth-rest args 3) NIL))          ; clip off &body argument
        (5
         (setq expansion
               (funcall expanderCode
                        (first args) (second args) (third args) (fourth args)
                        (nth-rest args 4)))
         (setf (nth-rest args 4) NIL))          ; clip off &body argument
        (otherwise
         (walk-error "Too many arguments in definition of macro " macroName)
         (return (walk-dont-call-me-tree tree @UNKNOWN))))
      (setq expansion (apply expanderCode (rest tree))))
    (return expansion)))

(defun (walk-macro-tree OBJECT TYPE-SPEC) ((tree CONS))
  ;; Expand the macro expression 'tree', walk it, and return the
  ;;    resulting parse tree.
  ;; Called by 'walk-call-slot-tree'.
  ;; TO DO: WE SHOULD DO SOME ARGUMENT TYPE CHECKING SIMILAR TO REGULAR
  ;;    FUNCTION CALLS, OTHERWISE EXPANSION MIGHT BREAK!
  (return (walk-a-tree (expand-macro tree))))


  ;;
;;;;;; Input/Output Operators
  ;;

(defun (walk-print-stream-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk the arguments of 'print-stream' or 'print-native-stream'.
  (when (<= (length tree) 2)
    (walk-error "Missing arguments in print statement: " tree)
    (return (walk-dont-call-me-tree tree @VOID)))
  (let ((operator (first tree))
        (streamTree (second tree))
        (oTree OBJECT NULL)
        (oType TYPE-SPEC NULL))
    (cond ((keyword? streamTree)
           ;; Check pseudo-streams supplied as keywords:
           (unless (or (eql? streamTree :warn)
                       (eql? streamTree :error)
                       (eql? streamTree :continuable-error))
             (walk-error "Illegal stream argument in print statement: " tree)
             (return (walk-dont-call-me-tree tree @VOID))))
          (otherwise
           ;; Walk the stream argument:  We rely on coercion to convert STELLA
           ;;    streams into native streams.  If we get a native stream with
           ;;    a `print-stream' statement, we happily accept it, since everything
           ;;    gets converted into a `print-native-stream' anyway:
           (mv-setq (oTree oType)
             (walk-expression-tree
              streamTree @NATIVE-OUTPUT-STREAM (first tree) FALSE))
           (setf (first tree) (quote PRINT-NATIVE-STREAM))
           (setf (second tree) oTree)))
    ;; Walk the arguments that need to be printed:
    (foreach it on (rest (rest tree))
             do
             (mv-setq (oTree oType)
               (walk-expression-tree (value it) @UNKNOWN operator FALSE))
             (setf (value it) oTree)
             (unless (eql? oTree (quote EOL))
               ;; Convert literal of various types into strings, since
               ;;    strings can usually be printed more efficiently:
               (typecase oTree
                 (STRING NULL)
                 ((INTEGER LONG-INTEGER FLOAT)
                  (setf (value it) (wrap-literal (stringify oTree))))
                 (CHARACTER
                  (setf (value it)
                    (wrap-literal (make-string 1 (wrapper-value oTree)))))
                 (otherwise
                  ;; Record the object type for the translator, so it can
                  ;;    decide whether to use special-purpose print fns:
                  (setf (value it) (sys-tree oTree oType))))))
    (return tree @VOID)))


  ;;
;;;;;; 'walk-call-slot-tree' and friends
  ;;

(defun (warn-about-undefined-methods? BOOLEAN) ()
  ;; Return `true' if the feature :warn-about-undefined-methods is enabled.
  (return
   (member? *current-stella-features* :warn-about-undefined-methods)))

(defun (warn-about-missing-methods? BOOLEAN) ()
  ;; Return `true' if warnings should be generated for methods which are
  ;;    called on an abstract type, but the methods are only implemented on
  ;;    some or all of its non-abstract subtypes.
  (return (or (not (eq? (translator-output-language) :common-lisp))
              (member? *current-stella-features*
                       :warn-about-missing-methods))))

(defun (walk-type-spec-is-native-type? BOOLEAN) ((theType TYPE-SPEC))
  ;; Called by `walk-undefined-slot-tree'.  Returns TRUE if TYPE-SPEC is
  ;;    implemented via a native type in the target language.
  (case (translator-output-language)
    (:common-lisp 
     (return (defined? (class-cl-native-type (type-spec-to-class theType)))))
    (:cpp 
     (return (defined? (class-cpp-native-type (type-spec-to-class theType)))))
    (:java
     (return (defined? (class-java-native-type (type-spec-to-class theType)))))
    (otherwise
     (return FALSE))))

(defun (walk-undefined-slot-tree CONS TYPE)
    ((tree CONS) (firstArgType TYPE-SPEC) (warn? BOOLEAN))
  ;; Called by 'walk-call-slot-tree' to finish off processing of a call
  ;;    to an as yet undefined method.
  ;; Record the undefined method and walk all but the first argument.
  ;; Return a method call -- user loses if they intended a function or 
  ;;    storage slot call.
  ;; TO DO: ATTACH THE UNDEFINED METHOD TO "firstArgType" SOMEHOW.
  (let ((cursor (rest (rest tree)))
        (type (type-spec-to-base-type firstArgType))
        (operatorName SYMBOL (first tree)))
    (while (non-empty? cursor)
      (setf (value cursor)
            (walk-expression-tree (value cursor) NULL operatorName TRUE))
      (setq cursor (rest cursor)))
    (when (and warn?
               ;; Don't warn about CL functions:
               (not (symbol-common-lisp? operatorName)))
      (if (or (eq? operatorName (quote NULL?))
              (eq? operatorName (quote DEFINED?)))
        (unless (walk-type-spec-is-native-type? type)
          (inform "Using default native test for " operatorName 
                  " in the expression:" EOL "  " tree))
        (walk-error "Reference to undefined method or function named "
                    operatorName EOL "   in the expression:" EOL "   " tree)))
    (return (bquote (SYS-CALL-METHOD & type && tree))
            @UNKNOWN) ))

(defun (walk-slot-on-abstract-type-tree CONS TYPE-SPEC)
    ((tree CONS) (abstractType TYPE))
  ;; Called by 'walk-call-slot-tree' to do something slightly more
  ;;    informative than what 'walk-undefined-slot-tree' does.
  ;; If a method is called on an 'abstractType', it tries to figure out
  ;;    whether the method is defined on any or all of its non-abstract
  ;;    subtypes.  If the method is defined on all non-abstract, direct
  ;;    subtypes, and if all their signatures are identical apart from the
  ;;    first arg, it will "infer" the method for the abstract type and
  ;;    pretend that it is defined there.  This handles cases where a method
  ;;    M is called on an abstract type T, but M is not defined on T but
  ;;    instead on all non-abstract, direct subtypes of T.
  ;; This inference is not sufficient for C++, since there we would also
  ;;    need to add the inferred method to the abstract class and make
  ;;    sure the class gets re/translated properly.
  ;; If the method is only defined on some of the non-abstract subclasses,
  ;;    or if their signatures don't match, a warning is printed and the
  ;;    call is handled just like for an undefined method.
  (let ((methodName (first tree))
        (prototypeMethod (find-prototype-method methodName abstractType))
        (undefinedMethod? TRUE)
        (oTree OBJECT NULL)
        (oType TYPE-SPEC NULL))
    (when (defined? prototypeMethod)
      ;; The method is implemented on at least one non-abstract subtype:
      (setq undefinedMethod? FALSE)
      (when (warn-about-missing-methods?)
        (mv-bind ((nofSubs INTEGER) (nofMethods INTEGER) (compatible? BOOLEAN))
            (compatible-real-methods prototypeMethod abstractType)
          (cond ((and (eq? nofSubs nofMethods)
                      compatible?)
                 ;; This is the only "good" case, everything else
                 ;; will be treated as a call to an undefined function.
                 (walk-inform
                  "Inferred the method " methodName " on the abstract" EOL
                  "   type " abstractType ", since "
                  methodName " is implemented" EOL
                  "   on all non-abstract subtypes of "
                  abstractType)
                 ;; Pretend that the first argument is real, by using the
                 ;; type of the first argument of the prototype method:
                 (setf (second tree)
                   (sys-tree (second tree) (slot-owner prototypeMethod)))
                 (mv-setq (oTree oType)
                   (walk-call-slot-tree tree)))
                ((eq? nofSubs nofMethods)
                 (walk-warn
                  "Could not infer " methodName
                  " on abstract type " abstractType "," EOL
                  "   since the implementations of " methodName
                  " on the non-abstract" EOL
                  "   subtypes of " abstractType
                  " are not all compatible"))
                (otherwise
                 (walk-warn
                  "Could not infer " methodName
                  " on abstract type " abstractType "," EOL
                  "   since " methodName " is only implemented on "
                  nofMethods " of the " nofSubs EOL
                  "   non-abstract subtypes of " abstractType)
                 (unless compatible?
                   (inform " Additionally, the method signatures are "
                           "not compatible.")))))))
    (if undefinedMethod?
        (mv-setq (oTree oType)
          (walk-undefined-slot-tree
           tree abstractType (warn-about-undefined-methods?)))
      (mv-setq (oTree oType)
        (walk-undefined-slot-tree tree abstractType FALSE)))
    (return oTree oType)))

(defun (find-prototype-method METHOD-SLOT) ((methodName SYMBOL)
                                            (abstractType TYPE))
  ;; Tries to find some method with 'methodName' on one of the
  ;;    non-abstract, direct subtypes of 'abstractType'.
  (let ((method SLOT NULL))
    (foreach
     sub in (class-direct-subs (type-class abstractType))
     where (defined? (type-class sub))          ; rmm INCREASE ROBUSTNESS
     do
     (if (class-abstract? (type-class sub))
         (setq method (find-prototype-method methodName sub))
       (setq method (safe-lookup-slot (type-class sub) methodName)))
     (when (and (defined? method)
                (not (storage-slot? method)))
       (return method)))
    (return NULL)))

(defun (compatible-real-methods INTEGER INTEGER BOOLEAN)
    ((prototypeMethod METHOD-SLOT) (abstractType TYPE))
  ;; Finds all methods matching 'prototypeMethod' on any of the non-abstract,
  ;;    direct subtypes of 'abstractType'.
  ;; The first value returned is the number of non-abstract, direct subtypes,
  ;;    the second value is the number of those which had a method with the
  ;;    name of 'prototypeMethod' defined on them, and the third value
  ;;    is `true' if all the method signatures were compatible.
  (let ((methodName (slot-name prototypeMethod))
        (nofRealSubTypes 0)
        (nofRealMethods 0)
        (compatibleSignatures? TRUE))
    (foreach
     sub in (class-direct-subs (type-class abstractType))
     do (if (class-abstract? (type-class sub))
            (mv-bind
                ((nofSubs INTEGER) (nofMethods INTEGER) (compatible? BOOLEAN))
                (compatible-real-methods prototypeMethod sub)
              (setq nofRealSubTypes (+ nofRealSubTypes nofSubs))
              (setq nofRealMethods (+ nofRealMethods nofMethods))
              (unless compatible?
                (setq compatibleSignatures? FALSE)))
          (let ((thisMethod SLOT NULL))
            (++ nofRealSubTypes)
            (setq thisMethod (safe-lookup-slot (type-class sub) methodName))
            (when (and (defined? thisMethod)
                       (not (storage-slot? thisMethod)))
              (++ nofRealMethods)
              (unless (identical-signatures?
                       prototypeMethod thisMethod)
                (setq compatibleSignatures? FALSE))))))
    (return nofRealSubTypes nofRealMethods compatibleSignatures?)))

(defmethod (finish-walking-call-slot-tree OBJECT TYPE-SPEC)
    ((self SLOT) (tree CONS) (firstArgType TYPE-SPEC))
  (ignore tree firstArgType)
  (error "finish-walking-call-slot-tree: Not defined on " self)
  ; (return NULL NULL)
  )

(defmethod (finish-walking-call-slot-tree OBJECT TYPE-SPEC)
           ((self STORAGE-SLOT) (tree CONS) (firstArgType TYPE-SPEC))
  ;; Called by 'walk-call-slot-tree' to finish processing a slot-value tree;
  ;; 'tree' has the form '(<slotName> <objRef>)'.
  (let ((objectRef (second tree))
        (oType (compute-return-type-spec self firstArgType)))
    ;; Test for user-defined reader method:
    (when (defined? (reader self))
      ;; We can't have a storage slot and a method slot of the same name
      ;; defined on a class, so this should never lead to an infinite loop:
      (setf (first tree) (reader self))
      (return (walk-a-cons-tree tree)))
    (if (system-defined-slot-reader? self)
        (return
          (bquote
           (SYS-CALL-METHOD
            & (slot-owner self) & (slot-name self) & objectRef))
          oType)
      (return
        (yield-slot-value-tree self objectRef firstArgType oType NULL)
        oType))))

;;; Variable arguments support:

;;; In general, calls to pseudo methods defined on `ARGUMENT-LIST' are passed
;;;    on to the translators and translated there into the proper native
;;;    varargs paradigm.  However, for methods that need to be evaluable (and
;;;    for Java), an `ARGUMENT-LIST' type is listified into a CONS.  This case
;;;    is handled directly by the walker, since it involves various type
;;;    trickery the translators couldn't perform.  In particular, if the
;;;    elements of an `ARGUMENT-LIST' need to be wrapped in order to be stuck
;;;    into a CONS, they have to be properly unwrapped by the `foreach' walker.

(defun (string-concatenate-method? BOOLEAN) ((method METHOD-SLOT))
  ;; Return `true' if this is the CONCATENATE method on STRING.
  (return (and (eq? (slot-name method) (quote CONCATENATE))
	       (eq? (slot-owner method) @STRING))))

(defun (pass-variable-arguments-as-list? BOOLEAN) ((method METHOD-SLOT))
  ;; Return `true' if 'method' takes a variable number of arguments
  ;;    which have to be collected and passed as a list.
  (return (or (method-must-be-evaluable? method)
              (and (eql? (translator-output-language) :java)
		   ;; STRING.CONCATENATE calls are handled as a special case
		   ;; by the Java translator, but we need to do traditional
		   ;; variable arguments handling for its definition to allow
		   ;; for backward compatibility.
		   (or (eq? *methodBeingWalked* method)
		       (not (string-concatenate-method? method)))
		   ))))

(defun (variable-arguments-type TYPE-SPEC) ((method METHOD-SLOT))
  ;; Return the element type of the rest parameter of 'method'.
  (return
    (extract-parameter-type
     (last (method-parameter-type-specifiers method))
     (quote ANY-VALUE))))

(defun (variable-arguments-name SYMBOL) ((method METHOD-SLOT))
  ;; Return the name of the rest parameter of 'method'.
  (return (last (method-parameter-names method))))

(defun (yield-listified-variable-arguments-type TYPE-SPEC) ((method METHOD-SLOT))
  ;; Yield the proper listified type for the variable arguments `method'.
  ;; Wrap the element type if it was a literal type.
  (let ((listBaseType @CONS)
        (elementType (variable-arguments-type method)))
    (when (and (eql? (translator-output-language) :java)
               (not (method-must-be-evaluable? method)))
      ;; This is just place holder code, since, eventually, we might want to use
      ;;    VECTORs in Java; however, the evaluator assumes conses, thus, for
      ;;    evaluable methods we have to stick with CONS argument lists.  Also,
      ;;    if this does change, `yield-listified-variable-arguments' needs to
      ;;    change accordingly:
      ;(setq listBaseType @VECTOR)
      )
    (when (type? elementType)
      (setq elementType (type-to-wrapped-type (cast elementType TYPE))))
    (return
      (new PARAMETRIC-TYPE-SPECIFIER
           :specifier-base-type listBaseType
           :specifier-parameter-types (list elementType)))))

(defun (yield-listified-variable-arguments CONS)
    ((walkedArgs CONS) (targetType TYPE-SPEC) (wrapArgs? BOOLEAN))
  ;; Return a tree that collects the already walked arguments in 'walkedArgs'
  ;;    which are expected to be of type 'targetType' into a cons-list.
  ;; If `wrapArgs?' is `true' the arguments will be wrapped before they
  ;;    get collected in a list.
  ;; This scheme is used to support interpreted evaluation of variable-
  ;;    arguments functions as well as Java.
  (if (non-empty? walkedArgs)
      (let ((listifiedArgs OBJECT (quote NIL)))
        (foreach it on walkedArgs
                 do (let ((arg (value it)))
                      (setq arg (sys-tree arg targetType))
                      (when wrapArgs?
                        (setq arg
                          (bquote (& (choose (eql? targetType @BOOLEAN)
                                             (quote wrap-boolean)
                                             (quote wrap-literal))
                                     & arg))))
                      (setf (value it) arg)))
        ;; TO FIX: Using 'cons-list' or 'cons' is a bit crude.
        (case (translator-output-language)
          (:JAVA
           (foreach arg in (reverse walkedArgs)
                    do (setq listifiedArgs
                         (bquote (cons & arg & listifiedArgs)))))
          (otherwise
           (setq listifiedArgs
             ;; CAUTION: If 'cons-list' ever qualifies for rest argument
             ;;          listification we'll recurse infinitely here!
             ;; Preserve the head-cons of 'walkedArgs':
             (bquote (cons-list & (value walkedArgs) && (rest walkedArgs))))))
        (return (walk-without-type-tree listifiedArgs)))
    (return (bquote (NIL)))))

(defun (finish-walking-argument-list-tree OBJECT TYPE-SPEC)
    ((self SLOT) (tree CONS) (firstArgType TYPE-SPEC))
  ;; Walk a call to the ARGUMENT-LIST slot `self'.
  ;; In the normal case, such a call is passed on to the translators to
  ;;    be handled appropriately for the particular target language.
  ;;    If the currently walked method needs to have its variable argument
  ;;    list listified, however, the call is intercepted and handled directly
  ;;    by the walker by mapping it onto the appropriate list access methods.
  (when (eql? (slot-name self) (quote ALLOCATE-ITERATOR))
    (walk-error "Cannot invoke " self " directly, use `foreach' instead")
    (return (walk-dont-call-me-tree tree @ARGUMENT-LIST-ITERATOR)))
  (when (eql? (slot-owner self) @CONS)
    
;;; TEMPORARY KLUDGE: REMOVE ONCE POWERLOOM COMMANDS HAVE BEEN FIXED (ALSO
;;; FIX RELATED CODE IN `walk-call-slot-tree'):
    (walk-inform "Applying CONS-methods to &rest-arguments is deprecated." EOL
                 "   " tree EOL
                 " Use `foreach' or explicitly coerce with `coerce-&rest-to-cons'")
    (setq firstArgType
      (yield-listified-variable-arguments-type *methodBeingWalked*)))
  
  (cond ((pass-variable-arguments-as-list? *methodBeingWalked*)
         (case (slot-name self)
           (LENGTH
            (return
              (sys-tree
               (bquote
                (SYS-CALL-METHOD
                 & (type-spec-to-base-type
                    (yield-listified-variable-arguments-type *methodBeingWalked*))
                 && tree))
               @INTEGER)))
           (otherwise
            ;; this case should really never come up, since no other legal
            ;;    methods exist on ARGUMENT-LIST:
            (return (finish-walking-call-slot-tree self tree firstArgType)))))
        (otherwise
         (return (finish-walking-call-slot-tree self tree firstArgType)))))

(defun (walk-variable-arguments CONS) ((arguments CONS)
                                       (method METHOD-SLOT)
                                       (firstArgType TYPE-SPEC))
  ;; Helping function for 'METHOD-SLOT.finish-walking-call-slot-tree'.
  ;; 'method' takes variable arguments; 'arguments' points to ones that
  ;;    haven't been walked.
  (let ((targetType (variable-arguments-type method))
        (listifyArgs? (pass-variable-arguments-as-list? method))
        (wrapArgs? FALSE)
        (cursor arguments))
    (when (and (not (type? targetType))
               (defined? firstArgType))
      (setq targetType (compute-relative-type-spec targetType firstArgType)))
    (setq wrapArgs?
      (and listifyArgs?
           (sub-type-spec-of? targetType @LITERAL)))
    (while (non-empty? cursor)
      (setf (value cursor)
        (walk-expression-tree
         (value cursor) targetType (slot-name method) FALSE))
      (setq cursor (rest cursor)))
    (when listifyArgs?
      (let ((listifiedArgs
             (yield-listified-variable-arguments
              arguments targetType wrapArgs?)))
        (when (empty? arguments)
          (return listifiedArgs))
        (setf (value arguments) listifiedArgs)
        (setf (rest arguments) NIL)))
    (return arguments)))

(defmethod (finish-walking-call-slot-tree OBJECT TYPE-SPEC)
           ((self METHOD-SLOT) (tree CONS) (firstArgType TYPE-SPEC))
  ;; Called by 'walk-call-slot-tree' to finish processing a method or
  ;;    function call tree;
  ;; MILD BUG: THE LOGIC THAT PERCOLATES VRLETS OUT OF METHOD ARGUMENTS
  ;;    DOES NOT RESPECT THE LEFT-TO-RIGHT EVALUATION ORDER.
  ;; (Maybe that should be "WILD BUG"? :-)
  (let ((methodName (slot-name self))
        (oTypeSpec (compute-return-type-spec self firstArgType))
        (oTree OBJECT NULL))
    ;; finish off walking remaining arguments:
    (let ((pTypeSpecs (method-parameter-type-specifiers self))
          (nofParameters (length pTypeSpecs))
          (cursor (rest (rest tree))))
      (foreach 
       targetTS in (rest pTypeSpecs)
       as pIndex in (interval 2 nofParameters)
       do
       (setq targetTS (compute-relative-type-spec targetTS firstArgType))
       (when (and (eq? pIndex nofParameters)
                  (method-variable-arguments? self))
         (setf (nth-rest tree pIndex)
           (walk-variable-arguments cursor self firstArgType))
         (break))
       (setf (value cursor)
         (walk-expression-tree (value cursor) targetTS methodName TRUE))
       (setq cursor (rest cursor))))
    ;; premature exit if VRLET argument encountered:
    (foreach arg in (rest tree)
           where (vrlet-expression? arg)
           do (return (percolate-out-vrlet-expression tree arg oTypeSpec)))
    (when (inline-method-call? self)
      (setq oTree (walk-inline-method-call self (rest tree) firstArgType))
      (when (defined? oTree)
        (return (sys-tree oTree oTypeSpec))))
    (if (method-function? self)
      (setq oTree (bquote (SYS-CALL-FUNCTION && tree)))
      (setq oTree (bquote (SYS-CALL-METHOD & (slot-owner self) && tree))))
    (return oTree oTypeSpec)) )

(defun (quote-arguments CONS) ((method METHOD-SLOT) (arguments CONS))
  ;; Return a tree that quotes all 'arguments' before they are passed
  ;;    to the non-argument-evaluating 'method'.
  ;; The symbol `null' always evaluates to the null value; the
  ;;    symbols `true' and `false' as well as wrapped literals
  ;;    get evaluated if the target type justifies the coercion.
  (let ((pTypeSpecs (method-parameter-type-specifiers method))
        (lastParameterIndex (1- (length pTypeSpecs)))
        (varArgsType (choose (method-variable-arguments? method)
                             (variable-arguments-type method)
                             NULL))
        (pType TYPE-SPEC NULL))
    (foreach it on arguments
             as argIndex in (interval 0 NULL)
             where (not (or (surrogate? (value it))
                            (keyword? (value it))))
             do
             (if (and (>= argIndex lastParameterIndex)
                      (defined? varArgsType))
                 (setq pType varArgsType)
               (setq pType (nth pTypeSpecs argIndex)))
             (when (or (eql? (value it) (quote NULL))
                       (and (eql? pType @BOOLEAN)
                            (or (eql? (value it) (quote TRUE))
                                (eql? (value it) (quote FALSE))))
                       (and (wrapper? (value it))
                            (defined? pType)
                            (sub-type-spec-of? pType @LITERAL)))
               (continue))
             ;; Use 'quote' to quote argument trees so we can have &'s,
             ;;    and copy them so functions can destructively modify them:
             (setf (value it)
               (bquote (copy-cons-tree (quote & (value it))))))
    (return arguments)))

(defun (walk-first-argument-to-function TYPE-SPEC) ((fnSlot METHOD-SLOT) (tree CONS))
  ;; Called by 'walk-call-slot-tree'.
  ;; Walk the first argument, if there is one, write it back into 'tree',
  ;;    and return its type.
  (let ((pTypeSpecs (method-parameter-type-specifiers fnSlot))
        (targetTS (first pTypeSpecs)))
    (when (not (method-evaluate-arguments? fnSlot))
      (setf (rest tree) (quote-arguments fnSlot (rest tree))))
    (when (and (method-variable-arguments? fnSlot)
               (eq? (length pTypeSpecs) 1))
      ;; TRICKY: we walk ALL arguments now, since '(method-ptype-specs fnSlot)'
      ;; has only length one, so later processing thinks there is only one arg:
      (setf (rest tree) (walk-variable-arguments (rest tree) fnSlot NULL))
      (return @UNKNOWN))                ; we don't care about the arg type
    (when (or (empty? (rest tree))
              (empty? (method-parameter-type-specifiers fnSlot)))
      (return @UNKNOWN))
    (mv-bind ((oTree OBJECT) (oType TYPE-SPEC))
        (walk-expression-tree (second tree) targetTS (slot-name fnSlot) TRUE)
      (setf (second tree) oTree)
      ;; Catch calls to 'get-sym' and friends for proper symbol registration:
      (typecase oTree
        (INTEGER
         (case (slot-name fnSlot)
           (GET-SYM (register-symbol (get-sym-from-offset (wrapper-value oTree))))
           (GET-SGT (register-symbol (get-sgt-from-offset (wrapper-value oTree))))
           (GET-KWD (register-symbol (get-kwd-from-offset (wrapper-value oTree))))
           (otherwise NULL)))
        (otherwise NULL))
      (return oType))))

(defun (walk-call-slot-tree OBJECT TYPE-SPEC) ((tree CONS))
  ;; If the head of 'tree' references a macro, expand the macro.
  ;; Otherwise, walk a method call, function call, or storage slot read.
  ;; Check arity of arguments.  Coerce arguments if necessary.
  ;; TO DO: FIGURE OUT HOW TO CHECK FOR MULTIPLE RETURN VALUES.
  (let ((slotName (first tree))
        (walkedFirstArg OBJECT NULL)
        (firstArgType TYPE-SPEC @VOID)
        (firstArgClass CLASS NULL)
        (illegalFirstArg? FALSE)
        (previousErrors *translationErrors*)
        (slot SLOT NULL))
    (when (eq? slotName (quote ERROR))  ;; Kludge? -- tar
      (setq *foundReturn?* TRUE))
    (setq slot (lookup-function slotName))
    (if (defined? slot)
        ;; slightly unclean for very minor performance reasons: we don't use
        ;;    `lookup-macro' to avoid a redundant call to `lookup-function':
        (if (method-macro? (cast slot METHOD-SLOT))
            (return (walk-macro-tree tree))
          ;; 'slot' represents a function -- walk first argument:
          (setq firstArgType (walk-first-argument-to-function slot tree)))
      ;; maybe 'slot' is a method or storage slot:
      (when (non-empty? (rest tree))
        ;; one or more arguments are being passed in:
        (mv-setq (walkedFirstArg firstArgType)
          (walk-expression-tree (second tree) @UNKNOWN slotName TRUE))
        (setf (second tree)
          ;; coerce to get a cast if we have a 4-argument TYPED-SYS:
          (coerce-a-tree walkedFirstArg firstArgType firstArgType))
        (when (void? firstArgType)
          (walk-error "First argument in call to " slotName " returns @VOID")
          (return (walk-dont-call-me-tree tree @UNKNOWN)))
        (setq firstArgClass (type-spec-to-class firstArgType))
        (setq slot (safe-lookup-slot firstArgClass slotName))))
    ;; Record whether any errors ocurred while walking the first argument:
    (setq illegalFirstArg? (> *translationErrors* previousErrors))
    ;; premature exit if VRLET encountered:
    (when (vrlet-expression? (second tree))
      (return (percolate-out-vrlet-expression tree (second tree) @UNKNOWN)))

;;; TEMPORARY KLUDGE: REMOVE ONCE POWERLOOM COMMANDS HAVE BEEN FIXED:
    (when (and (null? slot)
               (sub-type-spec-of? firstArgType @ARGUMENT-LIST))
      (setq slot (safe-lookup-slot (type-class @CONS) slotName)))

    (when (null? slot)
      (if (and (warn-about-undefined-methods?)
               (not (eql? firstArgType @UNKNOWN))
               (defined? firstArgClass)
               (class-abstract? firstArgClass))
          (return (walk-slot-on-abstract-type-tree
                   tree (type-spec-to-base-type firstArgType)))
        (return (walk-undefined-slot-tree
                 tree
                 (choose (void? firstArgType) @UNKNOWN firstArgType)
                 ;; Try to avoid (most probably) incorrect error messages if
                 ;;    the first argument to a function contained an error:
                 (and (not illegalFirstArg?)
                      (warn-about-undefined-methods?))))))
    (let ((minArgs (method-argument-count slot))
          (maxArgs minArgs))
      (typecase slot
        (METHOD-SLOT
         (when (or (method-variable-arguments? slot)
                   (method-body-argument? slot))
           (-- minArgs)
           (setq maxArgs NULL)))
        (otherwise NULL))
      (when (bad-argument-range? tree minArgs maxArgs)
        (return (walk-dont-call-me-tree tree @UNKNOWN))))
    (let ((oTree OBJECT NULL)
          (oType TYPE-SPEC NULL))
      (if (sub-type-spec-of? firstArgType @ARGUMENT-LIST)
          (mv-setq (oTree oType)
            (finish-walking-argument-list-tree slot tree firstArgType))
        (mv-setq (oTree oType)
          (finish-walking-call-slot-tree slot tree firstArgType)))
      (return (sys-tree-if-needed slot oTree firstArgType oType)))))

  ;;
;;;;;; Support for simple, macro-like inlining of method calls
  ;;

;;; For example, if inlining is enabled, the call `(nil? foo)'
;;;    will be replaced by `(eq? foo NIL)' by substituting
;;;    the body of the `nil?' method.
;;; Currently, inlining works only for functions and methods
;;;    whose body consists of a single `return' expression.
;;;    Procedural inlining for functions that do not return
;;;    a value cannot yet be done, since that would require
;;;    extending STELLA with a named block construct to handle
;;;    the `return' statements.  Inlining will also not be
;;;    performed if it would require to save an argument in
;;;    an auxiliary variable to avoid multiple evaluations.
;;; Also, since we only stringify the bodies of methods that
;;;    were declared as :globally-inline?, local inlining requests
;;;    via the :inline keyword can currently not be honored.

;;; TO DO: 
;;; - Improve the check for `verbatim' statements.

(defun (inline-method-call? BOOLEAN) ((method METHOD-SLOT))
  ;; Return `true' if a call to `method' should be inlined.
  (return (and (method-call-inlining-enabled?)
               (or (method-globally-inline? method)
                   (and (defined? *methodBeingWalked*)
                        (member? (method-inlined-functions *methodBeingWalked*)
                                 (slot-name method))))
               (method-inlinable? method))))

(defun (method-inlinable? BOOLEAN) ((method METHOD-SLOT))
  ;; Return `true' if some calls to `method' could possibly be inlined.
  ;; NOTE: Since inlining is similar to macro expansion, it is dangerous
  ;;    to inline calls to non-functions, since a later specialization of
  ;;    the method (which amounts to a redefinition) will not take effect.
  ;; POSSIBLE SOLUTION: Consider such methods as FINAL and disallow
  ;;    specialization.
  (when (or (void? (type method))
            (> (length (method-return-type-specifiers method)) 1)
            (method-variable-arguments? method))
    (return FALSE))
  (cond ((or (method-function? method)
             (most-specific-method? method))
         (return (defined? (inlinable-method-body method))))
        (otherwise
         (walk-inform "Cannot inline method " method ", since there are" EOL
                      " one or more methods that specialize it")
         (return FALSE))))

(defun (most-specific-method? BOOLEAN) ((method METHOD-SLOT))
  ;; Return `true' if there is no method that specializes `method'.
  (return (forall sub in (class-direct-subs (type-class (slot-owner method)))
              always (help-most-specific-method? (type-class sub) method))))

(defun (help-most-specific-method? BOOLEAN)
    ((class CLASS) (method METHOD-SLOT))
  ;; Helper function for `most-specific-method?'.
  ;; Return `true' if neither `class' nor any of its subclasses define
  ;;    a more specific version of `method'.
  (when (null? class)
    (return TRUE))
  (return
    (and (not (exists slot in (class-local-slots class)
                  where (eql? (slot-direct-equivalent slot) method)))
         (forall sub in (class-direct-subs class)
             always (help-most-specific-method? (type-class sub) method)))))

(defslot METHOD-SLOT cached-inlinable-method-body :type OBJECT)
                     
(defun (inlinable-method-body OBJECT) ((method METHOD-SLOT))
  ;; Retrieve the body of `method', convert it into a form that
  ;;    is equivalent to a call to `method', cache the result
  ;;    and return it.  If a previously cached result is
  ;;    available, return it instead.
  ;; Return `null' if the method body is not available or can't
  ;;    be inlined.  Currently, only methods whose body is a
  ;;    single `(return ...)' expression can be inlined.
  (let ((definition CONS NULL)
        (body (cached-inlinable-method-body method)))
    (when (eql? body method)
      ;; If the cached body is the method itself, then previous
      ;;    analysis showed that it wasn't inlinable:
      (return NULL))
    (when (defined? body)
      (return body))
    (setq definition
      (unstringify-stella-source
       (method-stringified-source method) (home-module method)))
    (extract-options definition NULL)
    (setf (cached-inlinable-method-body method) method)
    (when (= (length definition) 4)
      (setq body (last definition))
      (typecase body
        (CONS (when (and (eql? (first body) (quote RETURN))
                         (or
                          ;; If we have a VERBATIM tree, the translators
                          ;;    might be able to inline it:
                          (verbatim-tree? (second body))
                          ;; Otherwise, exclude bodies that contain VERBATIM
                          ;;    expressions, since they foil the variable
                          ;;    substitution scheme:
                          (not (search-cons-tree? body (quote VERBATIM)))))
                (return (setf (cached-inlinable-method-body method)
                          (permanentify-form (second body))))))
        (otherwise NULL)))
    (return NULL)))

;; This is true while we are inlining a method call (currently, its
;;    only effect is that it makes `walk-atomic-tree' walk inline
;;    references via `walk-inline-variable-reference'.  Eventually,
;;    we might be able to inline more complicated expressions, and then
;;    this will allow us to throw an exception if somewhere along the
;;    way we encountered something that foils inlining:
(defspecial *inliningMethodCall?* BOOLEAN FALSE)

(defun (walk-inline-method-call OBJECT)
    ((method METHOD-SLOT) (walkedArgs CONS) (firstArgType TYPE-SPEC))
  ;; Try to inline a call to `method' applied to `walkedArgs'.
  ;; If successful, return the resulting tree; otherwise, return `null'.
  ;; Here's how it works:
  ;; - When this function is called, we already have walked all of
  ;;   `method's arguments and handled any procedural code, i.e.,
  ;;   at this point it can be called as `(m a1...an)'.
  ;; - To inline the call, we push the methods parameter variables
  ;;   as local variables, record the actual to-be-inlined argument
  ;;   for each parameter, and then simply walk its inlinable body
  ;;   expression.
  ;; - While we are walking the inlinable body, we handle references
  ;;   to local variables differently by expanding them with their
  ;;   associated inline argument.  We also record how often a variable
  ;;   was referenced, since if a variable is referenced more than
  ;;   once, then it can only be substituted with an inline argument
  ;;   if it was also a variable or some other simple, side-effect free
  ;;   expression.  By using this scheme we can correctly handle nested
  ;;   inlining as well as macros.
  (let ((body (inlinable-method-body method))
        (nofReferences INTEGER NULL)
        (inlineArg OBJECT NULL)
        (success? TRUE))
    (when (and (verbatim-tree? body)
               (defined? (lookup-verbatim-tree body NULL)))
      ;; Tell the translator to try to inline the verbatim code:
      (return (yield-verbatim-inline-call-tree method walkedArgs)))
    (setq body (transientify-form body))
    (special ((*inliningMethodCall?* TRUE)
              (*methodBeingWalked* method))
      (foreach var in (method-parameter-names method)
          as tSpec in (method-parameter-type-specifiers method)
          as arg in walkedArgs
          as i in (interval 0 NULL)
          do (if (and (= i 0)
                      (mixin-method? method)
                      (translate-to-single-inheritance-language?))
                 (setq tSpec firstArgType)
               (setq tSpec (compute-relative-type-spec tSpec firstArgType)))
             (walk-a-declaration var tSpec NULL TRUE)
             (set-local-variable-info var :inline-argument arg)
             (set-local-variable-info var :inline-references 0))
      (setq body
        (walk-expression-tree body (type method) (quote INLINE-CALL) TRUE)))
    (when (procedural-expression? body)
      (setq success? FALSE))
    (when success?
      (foreach var in (method-parameter-names method)
          do (setq inlineArg (get-local-variable-info var :inline-argument))
             (setq nofReferences
               (cast (get-local-variable-info var :inline-references)
                     INTEGER-WRAPPER))
             (case nofReferences
               (0 (when (not (side-effect-free-expression? inlineArg))
                    (setq success? FALSE)
                    (break)))
               (1 NULL)
               (otherwise
                ;; We have to duplicate the argument, since we can't
                ;;    (don't want to) store it in an auxiliary variable:
                (when (not (and (side-effect-free-expression? inlineArg)
                                (<= (* (estimated-evaluation-cost inlineArg)
                                       nofReferences)
                                    2)))
                  (setq success? FALSE)
                  (break))))))
    (foreach var in (method-parameter-names method)
        do (ignore var)
           (pop-variable-binding))
    (return (choose success? body NULL))))

(defun (yield-verbatim-inline-call-tree CONS)
    ((method METHOD-SLOT) (walkedArgs CONS))
  ;; Generate a standard function or method call tree for `method' and
  ;;    `walkedArgs', and wrap it into a `SYS-INLINE-CALL' expression
  ;;    to indicate to the translator that it should try to inline the
  ;;    call to the function which has a `verbatim' body expression.
  ;; Return the result.
  (return
    (bquote
     (SYS-INLINE-CALL
      (& (choose (method-function? method)
                 (quote SYS-CALL-FUNCTION)
                 (quote SYS-CALL-METHOD))
         && (choose (method-function? method)
                    NIL
                    (bquote (& (slot-owner method))))
         & (slot-name method)
         && walkedArgs)))))

(defun (inline-variable-reference? BOOLEAN) ((self SYMBOL))
  ;; Return `true' if `self' is a local variable that should be
  ;;    substituted with its associated inline argument.
  :globally-inline? TRUE
  (return (and *inliningMethodCall?*
               (defined? (get-local-variable-info self :inline-argument)))))

(defun (walk-inline-variable-reference CONS TYPE-SPEC) ((self SYMBOL))
  ;; Walk a reference to the variable `self' and substitute it with its
  ;;    associated inline argument (it is assumed to have one).
  ;; Also increment the associated reference counter.
  (set-local-variable-info
   self :inline-references
   (1+ (cast (get-local-variable-info self :inline-references) INTEGER-WRAPPER)))
  (return
    (sys-tree (copy-cons-tree (get-local-variable-info self :inline-argument))
              (lookup-variable-type self))))

(defun (side-effect-free-expression? BOOLEAN) ((tree OBJECT))
  ;; Return `true' if it is certain that the evaluation of `tree'
  ;;    is side-effect free.
  ;; Note that assigning a slot value is also viewed as side-effect free,
  ;;    since assigning it more than once doesn't change the outcome.
  (typecase tree
    (CONS
     (case (first tree)
       ((TYPED-SYS CAST SAFE-CAST)
        (return (side-effect-free-expression? (second tree))))
       ((AND OR NOT
         EQ? EQL? =
         + - * / >
         >= < <=
         THE-CODE
         SYS-SLOT-VALUE SYS-SLOT-VALUE-SETTER)
        (return (forall arg in (rest tree)
                    always (side-effect-free-expression? arg))))
       (otherwise NULL)))
    (otherwise
     (return TRUE)))
  (return FALSE))

(defun (estimated-evaluation-cost INTEGER) ((tree OBJECT))
  ;; Return a "symbolic" evaluation cost estimate for the evaluation
  ;;    of the side-effect free expression `tree'.
  ;; Atomic expressions such as variables have cost 0.
  ;; All handled non-atomic expressions have cost 1 plus the sum
  ;;    of the evaluation costs of their arguments.
  (let ((cost 0))
    (typecase tree
      (CONS
       (case (first tree)
         ((TYPED-SYS CAST SAFE-CAST)
          ;; NOTE, in Java the casts won't be for free.
          (return (estimated-evaluation-cost (second tree))))
         ((AND OR NOT
           EQ? EQL? =
           + - * / >
           >= < <=
           THE-CODE
           SYS-SLOT-VALUE SYS-SLOT-VALUE-SETTER)
          (++ cost)
          ;; NOTE: This also counts some extra args such as slot owners,
          ;;    but, since they are atoms, their cost is zero.
          (foreach arg in (rest tree)
              do (setq cost (+ cost (estimated-evaluation-cost arg)))))
         (otherwise NULL)))
      (otherwise NULL))
    (return cost)))

  ;;
;;;;;; 'walk-defmethod-tree' and friends
  ;;

(defun (yield-synthesized-method-body CONS) ((unit TRANSLATION-UNIT))
  ;; Generate the body of an :inherits-through method and do some checking.
  ;;    Assumes that the method stored in 'unit' is finalized.
  (let ((method METHOD-SLOT (the-object unit))
        (body CONS (code-register unit)))
    (when (null? (method-parameter-names method))
      (walk-error "Missing parameters for :inherits-through method"))
    (cond ((non-empty? body)
           (walk-error "Over-specified definition of :inherits-through method")
           (return body))
          (otherwise
           (return (synthesize-method-body method))))))

(defun (walk-method-object CONS) ((unit TRANSLATION-UNIT))
  ;; Walk the body of the method stored in 'unit' and return
  ;;    the walked (canonicalized) parse tree.
  ;; Also set the 'code-register' of 'unit' to the walked body.
  (let ((method METHOD-SLOT (the-object unit))
        (body CONS (code-register unit)))
    (special (;; The new translation scheme can lead to nested walking of
              ;; functions (e.g., if a 'foreach' generated an auxiliary
              ;; function), thus these variables have to be bound now:
              (*localVariableTypeTable* (allocate KEY-VALUE-LIST))
              (*localGensymTable* (allocate KEY-VALUE-LIST))
              (*specialVariableStack* (allocate KEY-VALUE-LIST))
              (*methodBeingWalked* method)
              (*foundReturn?* FALSE))
      (when (defined? (method-inherits-through method))
        (setq body (yield-synthesized-method-body unit)))
      (foreach name in (method-parameter-names method)
               as typeSpec in (method-parameter-type-specifiers method)
               do (walk-a-declaration name typeSpec NULL TRUE))
      ;; Stop here for forward declarations:
      (unless (empty? body)
        (when (and (check-for-illegal-return?)
                   (not (void? (type method)))
                   (not (auxiliary? unit))
                   (not (method-auxiliary? method))
                   (not (exists form in body
                          where (and (cons? form)
                                     (eql? (first (cast form CONS))
                                           (quote RETURN))))))
          (setq body
            (bquote
             (&& body
                 (error "Returned from `" & (stringify method)
                        "' without a `return'.")))))
        (when (and (log-function-call? method)
                   (not (auxiliary? unit)))
          (setq body (wrap-body-with-log-function-call-tree method body)))
        (setq body (walk-list-of-statements body))
        (when (and (not (void? (type method)))
		   (not (abstract? method))
                   (not *foundReturn?*))
          (walk-error "Missing return statement")))
      (free *localVariableTypeTable*)
      (free *localGensymTable*)
      (free *specialVariableStack*)
      (setf (code-register unit) body)
      (return body))))

(defun walk-defmethod-tree ((tree CONS))
  ;; Create a new translation unit containing a new (or old, if equivalent
  ;;    method already exists) STELLA method object representing the parse
  ;;    of 'tree'.
  (let ((method METHOD-SLOT NULL))
    (setq *currentTranslationUnit*
      (new TRANSLATION-UNIT
           :category (quote METHOD)
           :the-object tree		   ; temporary, for error printing
	   :tu-home-module *module*))
    (setq method (define-method-from-parse-tree tree))
    (cond ((and (not (method-function? method))
                (or (null? (slot-owner method))
                    (null? (type-class (slot-owner method)))))
           (walk-error "Can't define method " (slot-name method)
                       " on the non-existent class " (slot-owner method))
           (free method)
           (clear-translation-unit *currentTranslationUnit*)
           (setq *currentTranslationUnit* NULL))
          (otherwise
           (setf (the-object *currentTranslationUnit*) method)
           ;; Store the method body in the 'code-register':
           ;; IMPORTANT: This assumes that any option/value pairs
           ;;    will be destructively detached from 'tree' by
           ;;    'define-method-from-parse-tree' and friends:
           (setf (code-register *currentTranslationUnit*)
             (nth-rest tree 3))
           (when (method-needs-lisp-macro? method)
             (register-native-name
              (slot-name method) :common-lisp :function))))))

(defslot METHOD-SLOT forward-declaration? :type BOOLEAN :default FALSE
         :documentation "Set to `true' for walked methods without a body.
Used to flag functions and methods that were declared but not defined.")

(defun walk-method-unit ((unit TRANSLATION-UNIT))
  ;; Generate parse tree code defining a native method or function
  ;;    for the method object stored in 'unit', and generate an
  ;;    additional translation unit for the startup-time code defining
  ;;    a Stella method.
  ;; If 'method-auxiliary?', or if 'unit' is auxiliary, avoid generating
  ;     a Stella method object.
  (special (;; Rebind this here for the sake of functions such as
            ;; 'create-inline-method-units' which call this directly:
            (*currentTranslationUnit* unit))
    (let ((method METHOD-SLOT (the-object unit))
          (name (slot-name method))
          (body CONS (code-register unit))
          (createMethodObject? TRUE)
          (storeCodePointer? TRUE)
	  (evaluatorWrapperMethod METHOD-SLOT NULL))
      (when (and (mixin-method? method)
                 (translate-to-single-inheritance-language?))
        ;; Ignore it, since it gets inherited down to individual classes,
        ;; but do generate startup code, otherwise, we'll have trouble
        ;; translating anything later that references this method:
        (clear-translation-unit unit)
        (walk-auxiliary-tree
         (bquote
          (startup-time-progn :methods
            & (yield-define-stella-method-object method NULL NULL))))
        (return))
      (when (forward-declaration? method)
        ;; Reset this in case we now walk the actual definition of
        ;;    a foward-declared method:
        (setf (forward-declaration? method) FALSE))
      (when (and (not (method-function? method))
                 (not (method-native? method))
                 (not (eql? (home-module method)
                            (home-module (type-class (owner method))))))
        (case (translator-output-language)
          (:common-lisp
           (walk-warn "Defining method " method " outside the home module of"
                      EOL "   its owner class will be illegal in C++ and Java"))
          (otherwise
           (walk-error "Defining method " method " outside the home module of"
                       EOL "   its owner class is illegal in "
                       (translator-output-language-name))
           (clear-translation-unit unit)
           (return))))
      (cond ((and (empty? body)
                  (null? (method-inherits-through method)))
             ;; Don't define native method if 'method' does not have a body,
             ;; but walk its signature:
             (walk-method-object unit)
             (unless (or (method-native? method)
                         (abstract? method))
               (setq createMethodObject? FALSE)
               ;; Unfortunately, this scheme does not allow us to detect
               ;;    whether we already saw the definition of the method:
               (setf (forward-declaration? method) TRUE)
               (when (>= *translationVerbosityLevel* 3)
                 (inform "Forward declaration of " method)))
             (clear-translation-unit unit))
            ;; 'method' is probably a slot reader or slot writer;
            ;; the slot provides the signature:
            ((or (method-auxiliary? method)
                 ;; Also, don't create method objects for auxiliary
                 ;; functions such as creators, destructors, etc.:
                 (auxiliary? unit))
             (setq createMethodObject? FALSE)
             ;; Pushing the method unit back on immediately means that any
             ;; auxiliary units will come after it (e.g., special next
             ;; functions for setof iterators).  Is this a problem?
             (push *translationUnits* unit)
             (walk-method-object unit))
            (otherwise
             (push *translationUnits* unit)
             (walk-method-object unit)))
      (when createMethodObject?
        (when (and (method-command? method)
                   (not (command? method)))
          (walk-warn "Ignored :command? declaration.  "
                     "Currently, only functions can be commands."))
        (when (method-needs-evaluator-wrapper? method)
          (setq evaluatorWrapperMethod (create-evaluator-wrapper-unit method)))
        (when (method-needs-lisp-macro? method)
          (create-lisp-macro-units name method))
        (when (or (method-native? method)
                  (abstract? method)
                  (eql? name (quote MAIN))) ;; can't point to `main' in C++
          ;; Don't store code in native method objects, since not all :native?
          ;; functions/methods are implemented as such (e.g., null?, <=,...):
          (setq storeCodePointer? FALSE))
        (walk-auxiliary-tree
         (bquote
          (startup-time-progn :methods
            & (yield-define-stella-method-object
               method
               (choose storeCodePointer? method NULL)
               (choose storeCodePointer? evaluatorWrapperMethod NULL)))))))))

(defun print-undefined-methods ((module MODULE) (local? BOOLEAN))
  :public? TRUE
  :documentation "Print all declared but not yet defined functions and methods
in `module'.  If `local?' is true, do not consider any parent modules of
`module'.  If `module' is NULL, look at all modules in the system.  This
is handy to pinpoint forward declarations that haven't been followed up
by actual definitions."
  (let ((undefinedMethods NIL))
    (foreach method in (all-methods module local?)
        where (and (forward-declaration? method)
                   (not (abstract? method))
                   (not (method-contains-unknown-type? method)))
        collect method into undefinedMethods)
    (foreach function in (all-functions module local?)
        where (forward-declaration? function)
        collect function into undefinedMethods)
    (when (non-empty? undefinedMethods)
      (print "The following functions and methods are declared "
             "but not yet defined:" EOL)
      (foreach method in undefinedMethods
          do (print "    " method EOL)))))

(defun (walk-sys-call-tree CONS TYPE-SPEC) ((tree CONS))
  ;; 'tree' has already been walked.  Compute the return type and return.
  ;; Assumes that 'slot' does not have an anchored type.
  (let ((slot (slot-from-expression-tree tree))
        (slotType TYPE-SPEC @UNKNOWN))
    (when (defined? slot)
      ;; Recover the full parametric type if there was one:
      (setq slotType (slot-type-specifier slot))
      ;; TO DO: Get rid of this 'when' once things appear to be stable:
      (when (and (defined? slotType)
                 (or (anchored-type-specifier? slotType)
                     (exists ts in (specifier-parameter-types
                                    (cast slotType PARAMETRIC-TYPE-SPECIFIER))
                             where (anchored-type-specifier? ts))))
        ;; Must have forgotten to use 'sys-tree-if-needed' somewhere:
        (error "walk-sys-call-tree: OOPS, can't handle anchored slot types: "
               tree))
      (unless (defined? slotType)
        (setq slotType (type slot))))
    (return tree slotType)))

  ;;
;;;;;; 'walk-defclass-tree' and 'walk-class-unit'
  ;;

(defun walk-defclass-tree ((tree CONS))
  ;; Create a new translation unit containing a new (or old, if equivalent
  ;;    class already exists) STELLA class object representing the parse
  ;;    of 'tree'.
  (setq *currentTranslationUnit*
    (new TRANSLATION-UNIT
         :category (quote CLASS)
         :the-object (second tree)	   ; temporary, for error printing
	 :tu-home-module *module*))
  (setf (the-object *currentTranslationUnit*)
    (define-class-from-parse-tree tree))
  ;; Check whether something went wrong:
  (when (null? (the-object *currentTranslationUnit*))
    (clear-translation-unit *currentTranslationUnit*)
    (setq *currentTranslationUnit* NULL)))

#|
;; Not used right now, since 'primary-type' is implemented
;; directly by methods instead of using a hardwired slot:
(defun (yield-initialize-primary-type CONS) ((class CLASS))
  ;; Return a parse tree that initializes the 'primary-type' slot of 'class'.
  (when (and (create-native-class? class)
             (subtype-of? (class-type class) @OBJECT)
             (not (class-abstract? class)))
    (return
      (bquote (setq & (yield-hardwired-slot-variable
                       (lookup-slot class (quote primary-type)))
                    & (class-type class)))))
  (return NULL) )
|#

(defun (yield-initialize-hardwired-slots CONS) ((class CLASS))
  ;; Return a list of parse trees to initialize the hardwired slots of 'class'.
  ;; 'primary-type' is excluded, since it is handled as a special case.
  (let ((hardwiredSlotInitializers CONS NIL))
    (when (create-native-class? class)
      (foreach slot in (class-slots class)
               do (typecase slot
                    (STORAGE-SLOT
                     (when (and (slot-hardwired? slot)
                                (defined? (initial-value slot)))
                       (pushq hardwiredSlotInitializers
                              (bquote
                               (setq & (yield-hardwired-slot-variable slot)
                                     & (initial-value slot))))))
                    (otherwise NULL))))
    (return hardwiredSlotInitializers)))

;; IMPORTANT: Also fix the bootstrap version in second-upgrade.ste
;;            if this function gets changed!!

(defun (yield-initial-value-expression OBJECT) ((slot STORAGE-SLOT))
  ;; Helping function for 'yield-initial-value-assignments'.
  ;; Establish either a user-defined initial value or a null initial
  ;;    value (note: one or the other is needed to clobber the
  ;;    CLOS default CL:nil).
  ;; If 'slot' is abstract or dynamic, return `null'.
  (when (or (abstract? slot)
            ;; An initial value for a dynamic slot would defeat its purpose:
            (dynamic-storage? slot)
            (slot-hardwired? slot)
            (eq? (allocation slot) :class))
    (return NULL))
  ;; slightly tricky -- 'initially recursively walks up the direct
  ;;    equivalence chain looking for initial value expressions:
  (let ((initialValueExpression (initially slot)))
    (when (defined? initialValueExpression)
      (return (transientify-form initialValueExpression)))
    (case (translator-output-language)
      (:common-lisp
       (when (eq? (allocation slot) :embedded)
         ;; simulate C++ creation of embedded collection:
         (return
          (bquote (allocate & (type-to-symbol (type slot)))))))
      ((:java :cpp :cpp-standalone :idl)
       (when (eq? (allocation slot) :embedded)
         ;; Until we fully implement :embedded slots,
         ;; also simulate them in C++ and Java:
         (return
          (bquote (allocate & (type-to-symbol (type slot))))))))
    (return (type-to-walked-null-value-tree (type-specifier slot) (type slot)))))

(defun (yield-constructor-attachment CONS) ((class CLASS) (classRef SYMBOL))
  ;; Return a parse tree fragment for code that fills the class-creator
  ;;    slot of 'class' with a pointer to the class instantiation function.
  ;; 'classRef' evaluates to 'class' at run-time.
  (if (and (not (class-abstract? class))
           (create-native-class? class))
      (let ((constructorFnCode
             (bquote
              (the-code :function & (yield-constructor-name class)))))
        (return (bquote ((setf (class-constructor-code & classRef)
                           & constructorFnCode)))))
    (return NIL)))

;;; The scheme below to store auxiliary methods should be replaced by
;;;    a more general scheme to associate auxiliary objects with primary,
;;;    explicitly defined objects.  This could then be used to improve
;;;    the current scheme for whole-program two-pass translation.

(defslot CLASS class-auxiliary-methods
  :type (LIST OF METHOD-SLOT) :default NIL-LIST
  :documentation "Stores auxiliary method objects such as slot accessors and
inherited mixin methods that are not attached to the class as regular methods
but need to be accessible by the C++ translator in order to generate the
necessary signatures.")

(defslot METHOD-SLOT auxiliary-method-reason :type SLOT)

(defun cleanup-auxiliary-methods ((class CLASS))
  ;; Remove any obsolete auxiliary methods of `class' whose reason
  ;;    ceased to exist.
  (let ((auxiliaryMethods (class-auxiliary-methods class))
        (reason SLOT NULL))
    (foreach method in auxiliaryMethods
        where (not (deleted? method))
        do (cond
            ((bad? method)
             (setf (deleted? method) TRUE))
            (otherwise
             ;; Check whether its reason ceased to exist:
             (setq reason (auxiliary-method-reason method))
             (when (or (null? reason)
                       (deleted? reason)
                       (bad? reason)
                       (null? (slot-owner reason))
                       (deleted? (slot-owner reason))
                       (null? (type-class (slot-owner reason)))
                       (deleted? (type-class (slot-owner reason)))
                       (bad? (type-class (slot-owner reason)))
                       (not (eql? (safe-lookup-slot
                                   (type-class (slot-owner reason))
                                   (slot-name reason))
                                  reason)))
               (setf (auxiliary-method-reason method) NULL)
               (setf (deleted? method) TRUE)))))
    (remove-deleted-members auxiliaryMethods)))

(defun register-auxiliary-method ((method METHOD-SLOT) (reason SLOT))
  ;; Register `method' as an auxiliary method of its owner class.
  ;; Remember that `reason' was the reason for the creation of `method'.
  (when (defined? method)
    (let ((class (type-class (slot-owner method)))
          (auxiliaryMethods (LIST OF METHOD-SLOT) NULL))
      (when (defined? class)
        (setq auxiliaryMethods (class-auxiliary-methods class))
        (when (null-list? auxiliaryMethods)
          (setq auxiliaryMethods
            (setf (class-auxiliary-methods class) (new LIST))))
        (finalize-auxiliary-method method)
        ;; remove an old auxiliary method with the same owner and name
        ;;    generated by a previous translation:
        (remove auxiliaryMethods
                (some aux in auxiliaryMethods
                  where (and (eql? (slot-name method) (slot-name aux))
                             (eql? (slot-owner method) (slot-owner aux)))))
        (insert auxiliaryMethods method)
        (setf (auxiliary-method-reason method) reason)))))

(defglobal *mixin-implementation-style* KEYWORD :SECOND-CLASS
  :documentation "A keyword describing how mixin classes are handled in
single-inheritance target languages.  The legal values are
:FIRST-CLASS-WITH-METHOD, which means that variables of a mixin type
are legal and that slot access on a mixin type is facilitated by
inherited-down accessor methods and a catch-all method on OBJECT,
:FIRST-CLASS-WITH-TYPECASE which is similar but replaces the catch-all
method with a function using a TYPECASE, and :SECOND-CLASS, which
means that variables of a mixin type are illegal and no additional
accessors and catch-all methods are needed.")

(defun (mixin-type-variables-allowed? BOOLEAN) ()
  ;; Return `true' if it is legal to have variables typed with a mixin type.
  :globally-inline? TRUE
  (return
    (or (not (translate-to-single-inheritance-language?))
        (not (eql? *mixin-implementation-style* :SECOND-CLASS)))))

(defun (create-native-mixin-slot-accessors? BOOLEAN) ()
  ;; Return `true' if native mixin slot accessor methods should be generated
  ;;    for each class inheriting a mixin class.
  :globally-inline? TRUE
  (return (and (translate-to-single-inheritance-language?)
               (mixin-type-variables-allowed?))))

(defun create-accessor-units-for-slot
    ((slot STORAGE-SLOT) (class CLASS)
     (mixinAccessors? BOOLEAN) (signaturesOnly? BOOLEAN))
  ;; Creates translation units that define slot reader and writer
  ;;    methods for 'slot' on 'class' and pushes them onto
  ;;    '*translationUnits*'.
  ;; If 'mixinAccessors?' is `true', native accessors for inherited-down
  ;;    mixin slots will be created.
  ;; If 'signaturesOnly?' is `true', only signature objects will be
  ;;    generated and stored in 'class-auxiliary-methods' so that the C++
  ;;    translator can generate the right signatures for the accessors of
  ;;    external slots.  The actual accessor methods are created when the
  ;;    'defslot' is translated.
  ;; Accessor method objects do not get attached to a class like
  ;;    regular methods, instead, they get collected in the slot
  ;;    'class-auxiliary-methods' of 'class'.
  (let ((methodTree CONS NULL)
        (method METHOD-SLOT NULL))
    ;; generate system-defined reader if necessary:
    (when (system-defined-slot-reader? slot)
      (setq methodTree (yield-slot-reader-tree slot class))
      (if signaturesOnly?
          (within-module (home-module slot)
            (setq method (define-method-from-parse-tree methodTree)))
        (setq method (the-object (help-walk-auxiliary-tree methodTree TRUE))))
      (register-auxiliary-method method slot))
        
    ;; generate system-defined writer if necessary:
    (when (system-defined-slot-writer? slot)
      (setq methodTree (yield-slot-writer-tree slot class))
      (if signaturesOnly?
          (within-module (home-module slot)
            (setq method (define-method-from-parse-tree methodTree)))
        (setq method (the-object (help-walk-auxiliary-tree methodTree TRUE))))
      (register-auxiliary-method method slot))

    ;; generate mixin accessors if necessary:
    (when (and mixinAccessors?
               (not (abstract? slot)))
      ;; generate native reader:
      (setq methodTree (yield-native-slot-reader-tree slot class))
      (if signaturesOnly?
          (within-module (home-module slot)
            (setq method (define-method-from-parse-tree methodTree)))
        (setq method (the-object (help-walk-auxiliary-tree methodTree TRUE))))
      (register-auxiliary-method method slot)

      ;; generate native writer:
      (unless (slot-hardwired? slot)
        (setq methodTree (yield-native-slot-writer-tree slot class))
        (if signaturesOnly?
            (within-module (home-module slot)
              (setq method (define-method-from-parse-tree methodTree)))
          (setq method
            (the-object (help-walk-auxiliary-tree methodTree TRUE))))
        (register-auxiliary-method method slot)))))

(defun create-accessor-units-for-mixin-slot ((slot STORAGE-SLOT) (class CLASS))
  ;; Creates translation units that define catch-all slot reader and
  ;;    writer methods on OBJECT for the mixin slot 'slot' and pushes
  ;;    them onto '*translationUnits*'.
  ;; This scheme is only used if we are translating to a single-
  ;;    inheritance language.
  (when (and (native-slot? slot)
             (eql? (native-slot-home slot class) class))
    (cond
     ((eql? *mixin-implementation-style* :FIRST-CLASS-WITH-TYPECASE)
      (walk-auxiliary-tree (yield-mixin-slot-reader-tree slot))
      (walk-auxiliary-tree (yield-mixin-slot-writer-tree slot)))
     (otherwise
      ;; Create catch-all methods for native slot access as well
      ;;    as system-defined accessors on OBJECT (since the 'typecase's
      ;;    generated by 'yield-mixin-slot-reader-tree' are kind of slow
      ;;    and problematic during startup, however, we might want to
      ;;    resurrect them for Java):
      (create-accessor-units-for-slot slot (type-class @OBJECT) TRUE FALSE))))
  (when (slot-hardwired? slot)
    (mv-bind (readCode auxiliaryCode)
        (yield-hardwired-slot-reader-body slot)
      (ignore readCode)
      ;; Define the class variable exactly once:
      (walk-auxiliary-tree auxiliaryCode))
    (create-accessor-units-for-slot slot (type-class @OBJECT) FALSE FALSE)))

(defun create-slot-accessor-units ((class CLASS))
  ;; Creates translation units that define slot reader and writer methods
  ;;    for qualifying slots and pushes them onto '*translationUnits*'.
  ;; Accessor method objects do not get attached to a class like regular
  ;;    methods, instead, they get collected in `class-auxiliary-methods'.
  (foreach 
      slot in (local-slots class)
      do (typecase slot
           (STORAGE-SLOT
            (if (and (create-native-mixin-slot-accessors?)
                     (mixin? class))
                (create-accessor-units-for-mixin-slot slot class)
              (create-accessor-units-for-slot
               slot class FALSE (slot-external? slot))))
           (otherwise NULL)))
  (when (and (translate-to-single-inheritance-language?)
             (exists super in (class-direct-supers class)
                 where (mixin? (type-class super))))
    ;; Create accessors for slots inherited from mixin classes:
    ;; NOTE: To make this work with a typed language such as Java,
    ;;       we also have to define each access method on OBJECT.
    (foreach
        slot in (class-slots class)
        where (and (mixin-slot? slot)
                   (eql? (native-slot-home slot class) class))
        do (create-accessor-units-for-slot
            slot class
            (create-native-mixin-slot-accessors?)
            (slot-external? slot))))
  (create-generic-slot-accessor-unit class))

(defun create-inline-method-units ((class CLASS))
  ;; Helping function for the function 'walk-class-unit'.
  ;; If translating to COMMON-LISP, push a list of translation units
  ;;     that define inline methods onto '*translationUnits*'.
  ;; If translating to C++ do nothing, because in-line C++ methods are 
  ;;     defined within the native class definition.
  ;; QUESTION: IF A METHOD IS BOTH IN-LINED AND EXTERNAL, COULD IT APPEAR
  ;;    TWICE IN THE C++ OUTPUT???
  ;; NOTE: The above comments do not apply anymore.  If we want to make
  ;;    such a distinction, it either has to be taken care of by
  ;;    'walk-method-unit' or directly in the translator.
  (foreach slot in (local-slots class)
      where (inline-method? slot)
      do (mv-bind (name parameters body)
             (destructure-defmethod-tree
              (unstringify-stella-source
               (method-stringified-source (cast slot METHOD-SLOT))
               (home-module slot))
              NULL)
           (ignore name parameters)
           ;; Instead of using `walk-auxiliary-tree', we do this by hand to
           ;;    preserve the `method-inline?' status of `slot':
           (walk-method-unit
            (new TRANSLATION-UNIT
                 :the-object slot
                 :category (quote METHOD)
                 :code-register body
                 :auxiliary? TRUE
		 :tu-home-module *module*)))))  ; Needed?  -TAR

(defun (yield-mixin-method-tree CONS) ((method METHOD-SLOT) (class CLASS))
  ;; Generate a method definition that implements `method' on `class'.
  ;; Assumes that `method' stores the complete body in its stringified source.
  ;; If class=OBJECT, create a catch-all method with a dummy body.
  (let ((tree CONS (unstringify-stella-source
                    (method-stringified-source method)
                    (home-module method)))
        (parameters CONS (third tree))
        (selfTree CONS (first parameters))
        (selfTypeTree
         (yield-type-spec-tree (first (method-parameter-type-specifiers method))))
        (body (nth-rest tree 3)))
    (typecase selfTypeTree
      (CONS
       ;; Moot case, since complex self types are currently illegal:
       (setf (first selfTypeTree) (yield-type-spec-tree (class-type class))))
      (otherwise
       (setq selfTypeTree (yield-type-spec-tree (class-type class)))))
    (setf (first (last-cons selfTree)) selfTypeTree)
    ;; If `class' is OBJECT, we have to create a dummy catch-all method:
    (when (eql? class (type-class @OBJECT))
      (setq body (bquote (&& (extract-options tree NULL) NULL))))
    (return
      (bquote
       (defmethod & (second tree) & parameters
                  :auxiliary? TRUE
                  ;; Explicitly set this to be the same as for `method', since
                  ;;    `method' might have been defined in a `:public-methods'
                  ;;    clause without explicit use of a `:public?' option:
                  :public? & (choose (slot-public? method)
                                     (quote TRUE)
                                     (quote FALSE))
                  && body)))))

(defun create-mixin-method-units ((class CLASS))
  ;; Helping function for the function 'walk-class-unit'.
  ;; Create translation units that inherit down mixin methods onto `class'
  ;;    if necessary.
  ;; If `class' is a mixin itself, generate catch-all methods on OBJECT
  ;;    for each of its methods.
  (cond
   ((and (mixin? class)
         (mixin-type-variables-allowed?))
    ;; Create catch-all methods on OBJECT for each mixin method:
    ;; BUG: CURRENTLY THIS WILL ONLY WORK IF `OBJECT' GETS TRANSLATED LATE ENOUGH:
    (foreach slot in (class-local-slots class)
        where (method-slot? slot)
        do (register-auxiliary-method
            (the-object
             (help-walk-auxiliary-tree
              (yield-mixin-method-tree slot (type-class @OBJECT))
              TRUE))
            slot)))
   (otherwise
    (let ((mixinMethods (new (LIST OF METHOD-SLOT)))
          (superMethods (new (LIST OF METHOD-SLOT))))
      (foreach super in (class-direct-supers class)
          where (mixin? (type-class super))
          do (foreach slot in (class-slots (type-class super))
                 where (and (method-slot? slot)
                            (eql? (native-slot-home slot class) class))
                 do (when (defined? (slot-direct-equivalent slot))
                      (insert-new superMethods (slot-direct-equivalent slot)))
                    (unless (member? superMethods slot)
                      (insert-new mixinMethods slot))))
      (foreach method in (reverse mixinMethods)
          do (register-auxiliary-method
              (the-object
               (help-walk-auxiliary-tree
                (yield-mixin-method-tree method class)
                TRUE))
              method))))))

(defun create-defprint-unit ((class CLASS))
  ;; Helping function for the function 'walk-class-unit'.
  ;; Create a translation unit that can be used to define a Common Lisp
  ;;   'print-object' method or to overload the C++ 'operator<<', and
  ;;   push it onto '*translationUnits*'.
  (unless (null? (class-print-form class))
    (walk-auxiliary-tree
     (bquote
      (defmethod print-object ((self & (class-type class))
                               (stream NATIVE-OUTPUT-STREAM))
	:public? TRUE
        & (transientify-form (class-print-form class)))))
    ;; The 'print-object' method is sufficient for Lisp (since the CL symbol
    ;; is imported into the Stella package)
    ;; C++ needs a definition for 'operator<<' to dispatch it:
    (when (and (eq? (translator-output-language) :cpp)
               ;; Only define '<<' on the top-most class with a :print-form
               ;; in this particular tree of the class forest:
               (not (exists super in (class-all-super-classes class)
                            where (defined? (class-print-form super)))))
      (push-variable-binding (quote self) (class-type class))
      (push-variable-binding (quote stream) @NATIVE-OUTPUT-STREAM)
      (push *translationUnits*
            (new TRANSLATION-UNIT
                 ;; This translation unit has a slightly different
                 ;; structure, so we use the 'class' as the object
                 ;; and stuff walked body code into the code register:
                 :the-object class
                 :category (quote PRINT-METHOD)
		 :tu-home-module *module*
                 :code-register
                 (walk-a-tree
                  (bquote
                   (if (null? self)
                       (print-native-stream stream "!NULL!")
                     (print-object self stream))))
                 :auxiliary? TRUE))
      (pop-variable-binding)
      (pop-variable-binding))
    ;; Java needs a definition for the 'toString' method to dispatch it:
    (when (and (eq? (translator-output-language) :java)
	       ;; Only define 'toString' on the top-most class with a :print-form
	       ;; in this particular tree of the class forest:
               (not (exists super in (class-all-super-classes class)
			where (defined? (class-print-form super)))))
      (special ((*methodBeingWalked* (new METHOD-SLOT))) ; dummy method to allow walking.
	(setf (method-return-type-specifiers *methodBeingWalked*) (list @STRING))
	(push-variable-binding (quote self) (class-type class))
	(push *translationUnits*
	      (new TRANSLATION-UNIT
		   ;; This translation unit has a slightly different
		   ;; structure, so we use the 'class' as the object
		   ;; and stuff walked body code into the code register:
		   :the-object class
		   :category (quote PRINT-METHOD)
		   :tu-home-module *module*
		   :code-register
		   (walk-a-tree
		    (bquote
		     (if (null? self)
			 (return "!NULL!")
			 (return (verbatim 
				     :java "#$(STELLAROOT).javalib.Native.stringify_via_print(self)")))))
		   :auxiliary? TRUE))
	(pop-variable-binding)))))

(defun walk-class-unit ((unit TRANSLATION-UNIT))
  ;; Generate parse tree code that defines a native (C++ or CLOS) class for
  ;;    the class object stored in 'unit'.  Additionally, generate translation
  ;;    units for class constructors and destructors, slot accessors, AND
  ;;    for startup time code that (re)defines the Stella class, and attaches 
  ;;    pointers to constructor code and read and write accessors to it.
  (let ((class CLASS (the-object unit))
        (startupTimeCode CONS NULL))
    (when (not (class-finalized? class))
      ;; Eventually, logic classes should not trigger this warning:
      (walk-error "Cannot translate class " (class-symbol class)
                  ", since it could not be finalized")
      (clear-translation-unit unit)
      (return))
    (when (create-native-class? class)
      (warn-about-multiple-parents class)
      (warn-about-non-direct-supers class)
      (cleanup-auxiliary-methods class)
      (unless (and (mixin? class)
                   (translate-to-single-inheritance-language?))
        (push *translationUnits* unit)
        (create-constructor-and-destructor-units class)
        (create-inline-method-units class))
      (create-slot-accessor-units class)
      (when (translate-to-single-inheritance-language?)
        (create-mixin-method-units class))
      ;; check for the (unlikely) case that a storage slot was defined
      ;;    outside the module of its owner class:
      (foreach slot in (class-local-slots class)
          where (and (storage-slot? slot)
                     (native-slot? slot)
                     (eql? (native-slot-home slot class) class)
                     (not (eql? (home-module class) (home-module slot)))
                     (slot-name-conflict? slot class)
                     )
          do (case (translator-output-language)
               (:common-lisp
                (walk-warn "Defining slot " slot " outside the home module of"
                 EOL "   its owner class will be illegal in C++ and Java"))
               (otherwise
                (walk-error "Slot " slot " is defined outside the home module of "
                            EOL "   its owner class " class ", and the name of"
                            EOL "   the slot conflicts with another slot.")
                #|
                (walk-error "Defining slot " slot " outside the home module of"
                            EOL "   its owner class is illegal in "
                            (translator-output-language-name))
                |#
                ;; discard any units we created:
                (while (not (eql? (pop *translationUnits*) unit)))
                (clear-translation-unit unit)
                (return)))))
    (create-defprint-unit class)
    ;; initialization code wrapped inside of
    ;;    "startup-time-progn" executes after linking
    ;;    but before running an application:
    (setq startupTimeCode
      (bquote
        (&& (yield-initialize-hardwired-slots class)
            && (yield-constructor-attachment class (bquote class))
            && (yield-generic-slot-accessor-attachment class (bquote class)))))
    (walk-auxiliary-tree
     (choose (empty? startupTimeCode)
             (bquote (startup-time-progn :classes
                       & (yield-define-stella-class class)))
             (bquote
              (startup-time-progn :classes
                (let ((class & (yield-define-stella-class class)))
                  && startupTimeCode)))))
    ;; Ensure that each type has a corresponding type symbol created:
    (foreach synonym in (class-synonyms class)
        do (register-symbol (type-to-symbol synonym)))))

(defun create-finalization-units ()
  ;; Create translation units to finalize classes and methods on
  ;;    a per-file basis.
  (walk-auxiliary-tree
   (bquote
    (startup-time-progn :finalize-classes
      (finalize-classes))))
  (walk-auxiliary-tree
   (bquote
    (startup-time-progn :finalize-methods
      (finalize-slots)
      (cleanup-unfinalized-classes)))))

  ;;
;;;;;; 'walk-defslot-tree'
  ;;

(defun walk-defslot-tree ((tree CONS))
  ;; Define an external slot from 'tree' and create a new unit containing the
  ;;    defined slot and its defining tree.
  (setq *currentTranslationUnit*
    (new TRANSLATION-UNIT
         :category (quote SLOT)
         :the-object tree		   ; temporary, for error printing
	 :tu-home-module *module*))
  (let ((slot STORAGE-SLOT NULL))
    (setq slot (define-external-slot-from-parse-tree tree))
    (when (null? slot)
      (clear-translation-unit *currentTranslationUnit*)
      (setq *currentTranslationUnit* NULL)
      (return))
    (setf (the-object *currentTranslationUnit*) slot)
    (setf (code-register *currentTranslationUnit*) tree)))

(defun walk-slot-unit ((unit TRANSLATION-UNIT))
  ;; Create startup-time code for the external slot definition held in 'unit'.
  (let ((slot STORAGE-SLOT (the-object unit))
        (ownerClass (type-class (slot-owner slot)))
        (stringifiedDefinition (stringify (code-register unit))))
    ;; TO DO: INTERPRETED SLOT ACCESS NEEDS TO BE UPGRADED TO HANDLE
    ;;    ACCESS METHODS ON EXTERNAL SLOTS.
    ;; TO DO: HANDLE THE CASE WHERE 'ownerClass' IS 'DYNAMIC-SLOTS-MIXIN'
    ;;    WHICH IS THE ONLY MIXIN CLASS THAT CAN OWN AN EXTERNAL SLOT.
    (create-accessor-units-for-slot slot ownerClass FALSE FALSE)
    (clear-translation-unit unit)
    (walk-auxiliary-tree
     (bquote
      (startup-time-progn :methods
        (define-external-slot-from-stringified-source
            & (wrap-literal stringifiedDefinition)))))))

  ;;
;;;;;; Macros
  ;;

(defun (lookup-macro METHOD-SLOT) ((name SYMBOL))
  :documentation "If `name' has a macro definition, return the method object
holding its expander function."
  :public? TRUE
  (let ((function (lookup-function name)))
    (when (and (defined? function)
               (method-macro? function))
      (return function))
    (return NULL)))

(defslot METHOD-SLOT method-macro? :type BOOLEAN :option-keyword :macro?
         :documentation "If true, the object is a macro expander function.")

(defun walk-defmacro-tree ((tree CONS))
  ;; Create a new translation unit containing a new (or old, if equivalent
  ;;    macro already exists) STELLA method object representing the parse
  ;;    of the macro expansion function derived from 'tree'.
  ;; 'tree' has the form '(defmacro <name> (<parameters>) <body>)'.
  ;; Macro expanders are handled just like regular functions, all we do
  ;;    is add a `:macro? TRUE' annotation.  Every macro is assumed to
  ;;    return an element of type OBJECT.
  (let ((name (second tree))
        (options (new PROPERTY-LIST
                      :the-plist (extract-options tree NULL)))
        (method METHOD-SLOT NULL))
    (when (cons? name)
      (walk-error "Macro " (first (cast name CONS))
                  " contains return type specification")
      (return))
    (unless (symbol? name)
      (walk-error "Illegal macro name: " name)
      (return))
    (setf (first tree) (quote DEFUN))
    (insert-at options :macro? (quote TRUE))
    ;(insert-at options :evaluate-arguments? (quote FALSE))
    (insert-at options :type (quote OBJECT))
    (setf (rest (rest (rest tree)))
      (concatenate (the-plist options) (rest (rest (rest tree)))))
    (walk-defmethod-tree tree)
    (when (defined? *currentTranslationUnit*)
      (setq method (the-object *currentTranslationUnit*))
      (when (> (method-argument-count method) 5)
        (walk-error "Too many arguments in macro definition, maximum is 5")
        (setq *currentTranslationUnit* NULL)))))


  ;;
;;;;;; 'walk-defglobal-tree'
  ;;

(defun walk-defglobal-tree ((tree CONS))
  ;; Create a new translation unit containing a STELLA global-variable
  ;;    object representing the parse of 'tree'.
  ;; Does not walk initial value code, instead, stores it in the
  ;;    'code-register' of the generated unit.
  (setq *currentTranslationUnit*
    (new TRANSLATION-UNIT
         :category (quote GLOBAL-VARIABLE)
         :the-object tree		   ; temporary, for error printing
	 :tu-home-module *module*))
  (when (< (length tree) 3)
    (bad-argument-count? tree 3)
    (clear-translation-unit *currentTranslationUnit*)
    (setq *currentTranslationUnit* NULL)
    (return))
  (let ((global GLOBAL-VARIABLE NULL)
        (initialValueTree OBJECT NULL))
    (mv-setq (global initialValueTree)
      (define-stella-global-variable-from-parse-tree
          tree (stringify tree)))
    (setf (the-object *currentTranslationUnit*) global)
    ;; Don't walk any initial-value code, save it for later:
    (setf (code-register *currentTranslationUnit*) initialValueTree)
    (setf (auxiliary? *currentTranslationUnit*) (variable-auxiliary? global))))

(defun walk-global-unit ((unit TRANSLATION-UNIT))
  ;; Push 'unit' which holds a STELLA global-variable object onto
  ;;    '*translationUnits*'.
  ;; Additionally, walk the initial value tree and generate a startup-time
  ;;    unit initializing the global, generate units for reader and writer
  ;;    functions for special variables, and generate a startup-time unit
  ;;    to create a STELLA global-variable object unless 'unit' is auxiliary.
  (let ((global GLOBAL-VARIABLE (the-object unit))
        (initialValueTree (code-register unit))
        (stringifiedSource (variable-stringified-source global)))
    (push *translationUnits* unit)
    (unless (eq? initialValueTree :UNBOUND-SPECIAL-VARIABLE)
      (cond ((and (variable-special? global)
		  (translate-to-java?))
	     ;; In Java, all special variable initializations need to be run as
	     ;; startup code, using a special setter to handle sibling-thread
	     ;; issues.  This is particularly important for running PowerLoom
	     ;; inside web servers such as Tomcat.
	     (setf (variable-constant? global) FALSE) ; can't be native constant
             (walk-auxiliary-tree
              (bquote
               (startup-time-progn :globals
                 (sys-set-default & (variable-name global) & initialValueTree))))
             (setq initialValueTree :UNBOUND-SPECIAL-VARIABLE))
	    ((or (wrapper? initialValueTree)
                 ;; NOTE: we only directly initialize variables that have native-language
                 ;; constants as their initializers (NULL, TRUE & FALSE); all others are
                 ;; initialized via startup code to insure proper sequencing:
                 (and (symbol? initialValueTree)
                      (constant-symbol? initialValueTree)
                      (or (not (eql? initialValueTree (quote NULL)))
                          ;; fail in case NULL gets mapped onto NULL-INTEGER, etc:
                          (eql? (type-to-null-value-tree (variable-type global)) (quote NULL))))
		 ;; Treat 'verbatim' initialization code as constant
		 ;;    (if it relies on other stuff, it needs to go
		 ;;    inside of a 'startup-time-progn'):
                 (and (cons? initialValueTree)
                      (eql? (first (safe-cast initialValueTree CONS))
                            (quote verbatim))))
	     ;; Run the initial value expression through the walker:
             (setq initialValueTree
               (walk-expression-tree
                initialValueTree
		(global-variable-type-spec global)
                (variable-name global)
                TRUE)))
            (otherwise
             ;; Non-constant initializations need to be run as startup code:
	     (setf (variable-constant? global) FALSE) ; can't be native constant
             (walk-auxiliary-tree
              (bquote
               (startup-time-progn :globals
                 (setq & (variable-name global) & initialValueTree))))
	     ;; cl-array-null
             (setq initialValueTree
               (type-to-walked-null-value-tree
		(global-variable-type-spec global)
                (type-spec-to-base-type (variable-type global)))))))
    (setf (code-register unit) initialValueTree)
    ;; Don't create variable objects for system-defined variables,
    ;; e.g., recycle lists (or should we???):
    (unless (auxiliary? unit)
      (walk-auxiliary-tree
       (bquote (startup-time-progn
                (define-stella-global-variable-from-stringified-source
                    & (wrap-literal stringifiedSource))))))))

  ;;
;;;;;; 'walk-deftype-tree'
  ;;

;;; NOTE: to properly dereference defined types when walking code,
;;;       `yield-type-specifier' should be used; see the function
;;;       `get-method-with-identical-signature' for an example.

(defun walk-deftype-tree ((tree CONS))
  ;; Define a type from 'tree' and create a new unit containing the
  ;;    defined type and its defining tree.
  (setq *currentTranslationUnit*
    (new TRANSLATION-UNIT
         :category (quote TYPE)
         :the-object tree		   ; temporary, for error printing
	 :tu-home-module *module*))
  (when (< (length tree) 3)
    (bad-argument-count? tree 3)
    (clear-translation-unit *currentTranslationUnit*)
    (setq *currentTranslationUnit* NULL)
    (return))
  (let ((type TYPE NULL))
    (setq type (define-stella-type-from-parse-tree tree))
    (setf (the-object *currentTranslationUnit*) type)
    (setf (code-register *currentTranslationUnit*) tree)))

(defun walk-type-unit ((unit TRANSLATION-UNIT))
  ;; Create startup-time code for the type definition held in 'unit'.
  (let ((stringifiedDefinition (stringify (code-register unit))))
    (push *translationUnits* unit)
    (walk-auxiliary-tree
     (bquote
      (startup-time-progn :classes
       (define-stella-type-from-stringified-source
           & (wrap-literal stringifiedDefinition)))))
    ;; Ensure that each type has a corresponding type symbol created:
    (register-symbol (type-to-symbol (the-object unit)))))

  ;;
;;;;;; 'walk-startup-time-progn-tree'
  ;;

;; Startup-time code is accumulated on a per-file basis in a startup-time 
;; function.  To deal with the intricate dependencies of startup-time code
;; during boot time, 'startup-time-progn's can be "phased" by giving them
;; an optional phase keyword.  By setting '*startup-time-phase*' to a
;; particular phase, only certain parts of a startup-time function will
;; be executed when it is run.  Phases have to be translated into numbers,
;; since keyword objects are not available right away.  Using 999 as the
;; value for '*startup-time-phase*' disables phasing.

(defun walk-startup-time-progn-tree ((tree CONS))
  (setq *currentTranslationUnit*
    (new TRANSLATION-UNIT
         :category (quote STARTUP-TIME-PROGN)
	 :tu-home-module *module*
         ;; save the unwalked tree for later:
         :code-register tree)))

(defun (extract-startup-time-phase KEYWORD) ((tree CONS))
  ;; Extracts the phase from a 'startup-time-progn' 'tree' and returns it.
  ;;    The phase keyword will be removed from 'tree'.
  ;; If 'tree' does not contain a phase keyword, :final is used by default.
  (let ((startupTimePhase :final)
        (startupTimePhaseTree CONS NULL))
    (when (and (>= (length tree) 2)
               (keyword? (second tree))
               (member? *startup-time-phases* (second tree)))
      (setq startupTimePhase (cast (second tree) KEYWORD))
      ;; Cut-out and free the keyword cons-cell:
      (setq startupTimePhaseTree (rest tree))
      (setf (rest tree) (rest (rest tree)))
      (setf (rest startupTimePhaseTree) NIL))
    (return startupTimePhase)))

(defun walk-startup-time-progn-unit ((unit TRANSLATION-UNIT))
  ;; Walk a STARTUP-TIME-PROGN unit.
  ;; This simply extracts the phase from the 'startup-time-progn', stores
  ;;    it in the code register, and stores the walked body forms as
  ;;    the object of the unit.
  (let ((tree CONS (code-register unit))
        (phase (extract-startup-time-phase tree)))
    (push *translationUnits* unit)
    (setf (the-object unit)
      ;; Need to walk this here to generate soft-coded symbol startup
      ;;    code before the startup-time units get combined:
      ;; PROBLEM: THIS GIVES US THE WRONG VARIABLE RENAMING IN JAVA IF
      ;;    WE HAVE A `WITHIN-MODULE' INSIDE A STARTUP-TIME-PROGN:
      (walk-list-of-statements (rest tree)))
    (setf (code-register unit) phase)))

(defglobal *max-number-of-startup-units* INTEGER 60
  :documentation "The maximum number of startup units that can be combined
into a single startup function (this avoids the construction of huge startup
functions that would cause too much stress for some wimpy compilers).")

(defun (earlier-startup-unit? BOOLEAN)
    ((unit1 TRANSLATION-UNIT) (unit2 TRANSLATION-UNIT))
  ;; Return `true' if startup `unit1' has to run in an earlier phase
  ;;    than `unit2'.
  (return (< (encode-startup-time-phase (code-register unit1))
             (encode-startup-time-phase (code-register unit2)))))

(defun (combine-startup-function-units CONS) ((startupFnName SYMBOL))
  ;; Helping function for 'create-startup-function-unit'.
  ;; Combine the bodies of all STARTUP-TIME-PROGN units currently held
  ;;    in '*translationUnits*', and return them as a list of trees sorted
  ;;    by phases.  All STARTUP-TIME-PROGN units are then removed from
  ;;    '*translationUnits*'.
  ;; Assumes that '*translationUnits*' are in reversed order as is the
  ;;     case at the end of 'walk-all-phase-one-units'.
  ;; TO DO: Process x-ref information collected in individual startup-time
  ;;    translation units.  Currently, it gets discarded.
  (let ((earlyStartupTrees NIL)
        (startupTrees NIL)
        (startupPhaseTrees NIL)
        (startupUnits (new (LIST OF TRANSLATION-UNIT))))
    ;; Extract all startup units, unreverse them, and sort them by phases:
    (foreach it on *translationUnits*
        where (eql? (category (value it)) (quote STARTUP-TIME-PROGN))
        do (push startupUnits (value it))
           (setf (value it) NULL))
    (remove *translationUnits* NULL)
    ;; stable sort perserves original order for equal phases:
    (sort startupUnits (the-code :function earlier-startup-unit?))
    (when (and (defined? startupFnName)
               (> (length startupUnits) *max-number-of-startup-units*))
      ;; If we have too many units, extract some of them into separate fns:
      (extract-startup-function-units startupUnits startupFnName))
    ;; Collect startup-time code by phases:
    (foreach phase in *startup-time-phases*
        do (while (and (non-empty? startupUnits)
                       (eql? (code-register (first startupUnits)) phase))
             (setq startupPhaseTrees
               (concatenate startupPhaseTrees
                            (cast (the-object (first startupUnits)) CONS)))
             (clear-translation-unit (pop startupUnits)))
           (when (non-empty? startupPhaseTrees)
             (setq startupPhaseTrees
               (bquote (VOID-SYS ;; avoid rewalking of startup code
                        (when (SYS-CALL-FUNCTION
                               current-startup-time-phase? 
                               & (wrap-literal
                                  (encode-startup-time-phase phase)))
                          && startupPhaseTrees))))
             (if (<= (encode-startup-time-phase phase)
                     (encode-startup-time-phase :modules))
                 ;; Don't bind '*module*' during early startup phases:
                 (pushq earlyStartupTrees startupPhaseTrees)
               (pushq startupTrees startupPhaseTrees))
             (setq startupPhaseTrees NIL)))
    (when (non-empty? startupTrees)
      (setq startupTrees
        (bquote
         ;; Generate startup-time equivalent of 'in-module':
         ((within-module
              ;; Need to special-case /STELLA for the bootstrap:
              & (choose (eql? *module* *stella-module*)
                        (bquote *stella-module*)
                        (bquote
                         (get-stella-module
                          & (wrap-literal (module-full-name *module*))
                          ;; Hack, so we won't get "undefined module"
                          ;;    warnings during phased startup when
                          ;;    modules might not yet be available:
                          (> *startup-time-phase*
                             & (encode-startup-time-phase :modules)))))
              && (reverse startupTrees))))))
    (when (or (non-empty? earlyStartupTrees)
              (non-empty? startupTrees))
      (setq startupTrees
        (concatenate (reverse earlyStartupTrees) startupTrees)))
    (return startupTrees)))

;; Used to annotate startup functions, so the Java translator can move
;;    them to a special auxiliary class file.
(defslot METHOD-SLOT method-startup-classname :type STRING)

;; Helping method for method-startup-classname:
(defmethod (method-startup-function? BOOLEAN) ((method METHOD-SLOT))
  (return (defined? (method-startup-classname method))))

(defun extract-startup-function-units
    ((startupUnits (LIST OF TRANSLATION-UNIT)) (startupFnName SYMBOL))
  ;; Extract some of the units in `startupUnits' into separate functions
  ;;    to bring the length of `startupUnits' under the threshold set
  ;;    by `*max-number-of-startup-units*'.
  ;; The names of the helper functions will be derived from `startupFnName'.
  ;; Each helper function only combines startup code from a single phase
  ;;    to simplify the interaction with the main startup function.
  (let ((remainingUnits (length startupUnits))
        (minUnitsPerFunction
         ;; Only if a single phase has at least that many units will
         ;;    we extract them into a separate function:
         (floor (1+ (/ *max-number-of-startup-units*
                       (length *startup-time-phases*)))))
        (cursor (the-cons-list startupUnits))
        (phaseStart cursor)
        (phaseUnits 0)
        (phase KEYWORD (code-register (first cursor)))
        (unitPhase phase)
        (helpFnCounter 0))

    (while (non-empty? cursor)
      (setq unitPhase (code-register (first cursor)))
      (when (eql? unitPhase phase)
        ;; Collect same-phase units until we hit the threshold:
        (++ phaseUnits)
        (when (< phaseUnits *max-number-of-startup-units*)
          (setq cursor (rest cursor))
          (continue)))
      
      (when (< phaseUnits minUnitsPerFunction)
        ;; We reached a new phase before we found enough same-phase units,
        ;;    start collecting the next phase:
        (setq phaseStart cursor)
        (setq phaseUnits 0)
        (setq phase unitPhase)
        (continue))

      ;; We found enough same-phase units to collect them into a function:
      (let ((functionName
             (intern-derived-symbol
              startupFnName
              (concatenate
                "HELP-"
                (concatenate
                  (symbol-name startupFnName)
                  (integer-to-string (++ helpFnCounter))))))
            (helpFnTree CONS (the-object (first phaseStart))))
        ;; Keep the first unit, but change it to call the helper function:
        (setf (the-object (first phaseStart))
          (bquote ((SYS-CALL-FUNCTION & functionName))))
        ;; Collect the code of the remaining units:
        (setq phaseStart (rest phaseStart))
        (foreach it on phaseStart
            as i in (interval 2 phaseUnits)
            do (ignore i)
               (setq helpFnTree
                 (concatenate
                   helpFnTree (cast (the-object (value it)) CONS)))
               ;; Free the extracted unit and mark its place for removal:
               (clear-translation-unit (value it))
               (setf (value it) NULL))
        (setq helpFnTree
          (bquote
           (defun & functionName ()
		  :PUBLIC? FALSE
                  ;; Avoid rewalking of startup-time code:
                  (VOID-SYS (progn && helpFnTree)))))
	(setf (method-startup-classname
	       (cast (the-object (help-walk-auxiliary-tree helpFnTree TRUE))
		     METHOD-SLOT))
	  (yield-startup-function-classname startupFnName))
        (setq remainingUnits (- remainingUnits (1- phaseUnits)))
        (when (<= remainingUnits *max-number-of-startup-units*)
          ;; We have extracted enough units to get under the threshold:
          (break))
        
        ;; Otherwise, start collecting the next batch:
        (when (eql? unitPhase phase)
          ;; If we didn't have a phase transition, the cursor
          ;;    points at the last unit of the previous batch:
          (setq cursor (rest cursor)))
        (setq phaseStart cursor)
        (setq phaseUnits 0)
        (setq phase (code-register (first cursor)))))
    
    ;; Finally, remove the place holders of the extracted units:
    (remove startupUnits NULL)))

(defun (yield-startup-function-name SYMBOL) ((file STRING))
  ;; Yield a name for the startup function for `file', or, if `file' is
  ;;    `null', for the currently translated file.
  (setq file (choose (null? file) *currentFile* file))
  (if (system-startup-file? file)
      ;; we are translating a system startup file, use special name:
      (return (system-startup-function-symbol *currentSystemDefinition*))
    (return
      (intern-symbol-in-module
       (concatenate "STARTUP-" (string-upcase (file-base-name file)))
       *module*
       TRUE))))

(defun (yield-startup-function-classname STRING) ((function-name SYMBOL))
  ;; If this is the system startup function, then use a normal name.
  ;; Otherwise, it is an internal startup name and gets a leading underscore.
  ;; IMPORTANT:  This character may be used as key by the Java translation
  ;; software in deciding whether the class is public is not.  This is a
  ;; bit of a kludge, but it saves a slot that would otherwise be needed.
  (let ((base-name (java-translate-class-namestring (symbol-name function-name))))
    (if (system-startup-file? *currentFile*)
      (return base-name)
      (return (concatenate "_" base-name)))))

(defun create-startup-function-units ()
  ;; Create a translation unit for a startup function named 'startupFnName'
  ;;     (plus auxiliary units for helper functions if necessary).
  ;; The body of the startup function combines all startup code currently
  ;;     held in any of '*translationUnits*'.  All STARTUP-TIME-PROGN
  ;;     units are then removed from '*translationUnits*'.
  ;; Assumes that '*translationUnits*' are in reversed order as is the
  ;;     case at the end of 'walk-all-phase-one-units'.
  (let ((startupFnName
         ;; If 'startupFnName' is `null', incremental startup code is generated:
         (choose (incremental-translation?)
                 NULL
                 (yield-startup-function-name *currentFile*)))
        (tree CONS NULL)
        (method METHOD-SLOT NULL))
    (cond
     ((dont-generate-startup-code?)
      (remove-all-startup-time-progn-units))
     ((defined? startupFnName)
      ;; This is a bit messy, since we need to create a signature for the
      ;;    startup function, and we don't want to stringify all startup
      ;;    code during the creation of the startup function method object
      ;;    nor create any more startup-time code units.
      ;; (1) Create a startup function signature now and at startup time:
      (setq tree (bquote (defun & startupFnName () :public? TRUE NULL)))
      (setq method (define-method-from-parse-tree tree))
      (setf (forward-declaration? method) FALSE)
      (setf (method-startup-classname method)
	(yield-startup-function-classname startupFnName))
      (setq tree
        (bquote
         (startup-time-progn :methods
           & (yield-define-stella-method-object method method NULL)
           (let ((function (lookup-function (quote & startupFnName))))
             (setf (method-startup-classname function)
               & (method-startup-classname method))))))
      (walk-auxiliary-tree tree)
      ;; (2) Combine all STARTUP-TIME-PROGNs and walk the actual startup
      ;;     function (treating it as an auxiliary function avoids the 
      ;;     generation of any more startup-time code and stringification):
      (if (system-startup-file? *currentFile*)
        (setq tree
              (bquote
               (defun & startupFnName ()
                      :public? TRUE :auxiliary? TRUE
                      (with-process-lock *bootstrap-lock*
                        && (combine-startup-function-units startupFnName)))))
        (setq tree
              (bquote
               (defun & startupFnName ()
                      :public? TRUE :auxiliary? TRUE
                      && (combine-startup-function-units startupFnName)))))
      ;; Set this for Java translation:
      (setf (method-startup-classname
             (cast (the-object (help-walk-auxiliary-tree tree TRUE)) METHOD-SLOT))
	(yield-startup-function-classname startupFnName)))
     (otherwise
      ;; We have an incremental translation:
      (setq tree
        (bquote (startup-time-progn
                    && (combine-startup-function-units startupFnName))))
      (walk-auxiliary-tree tree)
      ;; Modify the STARTUP-TIME-PROGN unit, so the translator can handle it:
      (setq tree (cons (quote PROGN)
                       (cast (the-object (first *translationUnits*)) CONS)))
      (setf (the-object (first *translationUnits*)) tree)))))

(defun (dont-generate-startup-code? BOOLEAN) ()
  ;; Return `true' if no startup code needs to be generated.
  (return (eql? (translator-output-language) :cpp-standalone)))

(defun remove-all-startup-time-progn-units ()
  ;; Remove all STARTUP-TIME-PROGN units from '*translationUnits*'.
  (let ((placeHolderUnit TRANSLATION-UNIT NULL))
    (foreach it on *translationUnits*
             where (eq? (category (value it)) (quote STARTUP-TIME-PROGN))
             do (let ((unit (value it))) 
                  (if (null? placeHolderUnit)
                      (setq placeHolderUnit unit)
                    (clear-translation-unit unit))
                  (setf (value it) placeHolderUnit)))
    (remove *translationUnits* placeHolderUnit)
    (clear-translation-unit placeHolderUnit)))

  ;;
;;;;;; exception-case
  ;;

;;; Support for non-local jumps and exception handling:

;;; An exception handler is established with 'exception-case' whose
;;; syntax is very similar to Common-Lisp's 'handler-case':
;;;
;;;    (exception-case <statement>
;;;      {(<exception-type> ([<var>]) <statement>*)}+ )
;;;
;;; An exception is signalled with a call to
;;;
;;;    (signal-exception <exception>)
;;;
;;; which will resume execution at the most recently established
;;; exception handler that has an exception clause whose <exception-type>
;;; is a supertype of the type of the <exception> object.  If an exception
;;; handler has multiple exception clauses, they are tried in sequence, and
;;; the first one with a general enough <exception-type> will be used.
;;; The optional variable in an exception clause will be bound to the
;;; thrown exception object if that clause ever gets selected.
;;;
;;; If an exception handler handles an exception, but wants other handlers
;;; to see it too, then it should bind the exception to a variable and call
;;; signal-exception on it.

;;; Restrictions:

;;; - Exceptions created by STELLA code have to be a subtype of
;;;   STELLA-EXCEPTION.
;;; - Signalled exceptions have to be a subtype of NATIVE-EXCEPTION.
;;; - Native exceptions such as arithmetic errors, segmentation faults, etc.
;;;   can be caught using the Stella exception class NATIVE-EXCEPTION.

;;; Implementation notes:

;;; We use the languages native exception handling mechanisms.
;;; Lisp: Currently, we use Lisp's Condition system.
;;; Java: Currently, we use subclasses of Java's RuntimeException.
;;;  C++: Currently, we use subclasses of Exception

;;; Signalling functions:

(defun (walk-signal-exception-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk a tree of the form `(signal-exception <exception>)'.
  ;; <exception> can't be a NATIVE-EXCEPTION, since in order to throw those
  ;;    in Java, we would need to declare it with a `throws' clause.
  (setq *foundReturn?* TRUE)
  (mv-bind (expression its-type)
           (walk-expression-tree
            (second tree) @STELLA-ROOT-EXCEPTION (quote signal-exception) FALSE)
           (return 
            (bquote
             (SYS-SIGNAL & expression & its-type))
            @VOID)))

(defun (walk-exception-case-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk an 'exception-case' 'tree' which has to be of the form:
  ;;
  ;;    (exception-case <statement>
  ;;      {(<exception-type> ([<var>]) <statement>*)}+ )
  ;;
  (when (<= (length tree) 2)
    (walk-error "Missing handler(s) in 'exception-case': " tree)
    (return (walk-dont-call-me-tree tree @VOID)))
  (let ((protectedTree (walk-a-tree (second tree)))
        (handlerTrees (walk-exception-handler-trees (rest (rest tree)))))
    (when (or (null? protectedTree)
              (null? handlerTrees))
      (return (walk-dont-call-me-tree tree @VOID)))
    (return 
      (bquote (SYS-HANDLER-CASE
	       & (walk-a-tree protectedTree)
	       && handlerTrees))
      @VOID) ))

(defun (walk-exception-handler-trees CONS) ((tree CONS))
  ;; Walk the list of exception handler clauses in 'tree' and collect
  ;;    it into a list of statments that handle an exception which occurs
  ;;    during the execution of the protected statement, and, if so,
  ;;    handles it.
  (let ((clauses NIL)
        (exceptionType OBJECT NULL)
        (exceptionVariableSpec OBJECT NULL)
        (exceptionVariable SYMBOL NULL))
    (foreach clause in tree
        do (typecase clause
             (CONS
              (when (< (length clause) 2)
                (walk-error "Illegal exception handler clause: " clause)
                (return NULL))
              (setq exceptionType (first clause))
              (when (not (symbol? exceptionType))
                (walk-error "Illegal exception type: " exceptionType)
                (return NULL))
              (setq exceptionType (typify exceptionType))
              (when (null? (type-to-class exceptionType))
                (walk-error "Undefined exception type: " exceptionType)
                (return NULL))
              (when (not (subtype-of? exceptionType @NATIVE-EXCEPTION))
                (walk-error "Exception type " exceptionType
                            " is not a subtype of NATIVE-EXCEPTION")
                (return NULL))
              (setq exceptionVariableSpec (second clause))
              (when (or (not (cons? exceptionVariableSpec))
                        (> (length (cast exceptionVariableSpec CONS)) 1)
                        (and
                         (= (length (cast exceptionVariableSpec CONS)) 1)
                         (not (symbol?
                               (first (cast exceptionVariableSpec CONS))))))
                (walk-error "Illegal exception variable specification: "
                            clause)
                (return NULL))
              (setq exceptionVariable
                (first (cast exceptionVariableSpec CONS)))
	      ;; Do we only need to do the following for Java?
	      (when (and (translate-to-java?)
			 (null? exceptionVariable))
		(setq exceptionVariable (local-gensym "E")))
              (setq exceptionVariableSpec
                (walk-a-declaration exceptionVariable exceptionType NULL TRUE))
	      (setq clause
		(bquote
		 (SYS-HANDLE-EXCEPTION
		  & exceptionVariableSpec
		  && (walk-list-of-trees (rest (rest clause))))))
	      (when (defined? exceptionVariable)
		(pop-variable-binding))
              (pushq clauses clause))
             (otherwise
              (walk-error "Illegal exception handler clause: " tree)
              (return NULL))))
    (return (reverse clauses))))

  ;;
;;;;;; unwind-protect
  ;;

(defun (walk-unwind-protect-tree CONS TYPE) ((tree CONS))
  ;; Walk an (unwind-protect <protected-form> <cleanup-forms>*) `tree'.
  (when (eql? (first tree) (quote SYS-UNWIND-PROTECT))
    (return tree @VOID))
  (return
    (bquote
     (SYS-UNWIND-PROTECT
      && (walk-list-of-statements (rest tree))))
    @VOID))

  ;;
;;;;;; 'walk-verbatim-tree'
  ;;

(defun walk-verbatim-definition-tree ((tree CONS))
  (setq *currentTranslationUnit*
    (new TRANSLATION-UNIT
         :category (quote VERBATIM)
         ;; save the unwalked tree for later:
         :code-register tree)))

(defun walk-verbatim-unit ((unit TRANSLATION-UNIT))
  (setf (the-object unit) (walk-a-tree (code-register unit)))
  (cond ((defined? (the-object unit))
         (push *translationUnits* unit)
         (setf (code-register unit) NULL))
        (otherwise
         ;; No verbatim code for the current output language:
         (setf (code-register unit) NULL)
         (clear-translation-unit unit))))

(defun (walk-verbatim-tree OBJECT TYPE-SPEC) ((tree CONS))
  ;; Walk the verbatim tree 'tree'.
  ;; Check that 'tree' contains an option matching
  ;;    '(translator-output-language)' or an :OTHERWISE clause.
  (let ((options (allocate PROPERTY-LIST :the-plist (rest tree)))
        (verbatimTree (lookup options (translator-output-language))))
    (when (null? verbatimTree)
      (setq verbatimTree (lookup options :OTHERWISE))
      (when (null? verbatimTree)
        (walk-error "Verbatim statement has no " (translator-output-language)
                    " option.")
        (return NULL @UNKNOWN))
      ;; :OTHERWISE is assumed to contain Stella code:
      (unless (eq? verbatimTree (quote NULL))
        (return (walk-a-tree verbatimTree))))
    (when (eq? verbatimTree (quote NULL))
      (return NULL @UNKNOWN))
    (typecase verbatimTree
      (STRING
       (insert-at options (translator-output-language)
                  (new VERBATIM-STRING-WRAPPER
                       :wrapper-value (wrapper-value verbatimTree))))
      (otherwise NULL))
    (return tree @UNKNOWN)))

(defun (lookup-verbatim-tree OBJECT) ((tree CONS) (language KEYWORD))
  ;; Return the verbatim expression in `tree' for `language'.
  ;; If `language' is `null', use the current output language.
  (when (null? language)
    (setq language (translator-output-language)))
  (return (search-plist (rest tree) language)))                                

(defun (verbatim-tree? BOOLEAN) ((tree OBJECT))
  ;; Return `true' if `tree' is a VERBATIM expression.
  (return (and (cons? tree)
               (eql? (first (cast tree CONS)) (quote VERBATIM)))))


  ;;
;;;;;; 'walk-defmodule-tree'
  ;;

(defun walk-defmodule-tree ((tree CONS))
  ;; Create a new translation unit containing a STELLA module
  ;;    object representing the parse of 'tree'.
  (setq *currentTranslationUnit*
    (new TRANSLATION-UNIT
         :category (quote MODULE)
         :the-object tree))  ;; temporary, for error printing
  (let ((module MODULE NULL)
        (moduleName (coerce-to-module-name (second tree) FALSE)))
    (when (null? moduleName)
      (walk-error "Illegal module name: " (second tree))
      (clear-translation-unit *currentTranslationUnit*)
      (setq *currentTranslationUnit* NULL)
      (return))
    (setq module (define-module moduleName (rest (rest tree))))
    (setf (the-object *currentTranslationUnit*) module)))

(defun walk-module-unit ((unit TRANSLATION-UNIT))
  ;; Push startup-time units which create a STELLA module contained
  ;;   in `unit'
  (let ((module MODULE (the-object unit)))
    (walk-auxiliary-tree
      (bquote 
       (startup-time-progn 
           :modules
         & (yield-define-module module))))))

  ;;
;;;;;; 'make' and 'new'
  ;;

(defun (extract-required-argument-values CONS)
    ((classType TYPE-SPEC) (slotsAndValues (PROPERTY-LIST OF SLOT OBJECT)))
  ;; Helping function for 'yield-new-arguments-tree'.
  ;; Return a list of required arguments extracted from 'slotsAndValues'.
  ;; Side-effect: Remove required slot entries from 'slotsAndValues'.
  (let ((arrayType? (array-type-specifier? classType))
        (requiredValues (new LIST))
        (found? FALSE))
    (when arrayType?
      (preprocess-array-arguments classType slotsAndValues))
    (foreach requiredSlotName in (class-required-slot-names
                                  (type-spec-to-class classType))
        do (setq found? FALSE)
           (foreach (slot valueRef) in slotsAndValues
               where (eql? (slot-name slot) requiredSlotName)
               do (setq found? TRUE)
                  (if arrayType?
                      (evaluate-array-argument-value
                       classType requiredValues slot valueRef)
                    (insert-last requiredValues
                                 (walk-expression-tree
                                  valueRef
                                  (compute-return-type-spec slot classType)
                                  (quote NEW)
                                  FALSE)))
                  ;; eliminate matching entry:
                  (remove-at slotsAndValues slot)
                  (break))
           (unless found?
             (walk-error "Missing required NEW argument: " requiredSlotName)))
    (return (the-cons-list requiredValues))))

(defun preprocess-array-arguments
    ((arrayType PARAMETRIC-TYPE-SPECIFIER)
     (slotsAndValues (PROPERTY-LIST OF SLOT OBJECT)))
  ;; Helping function for `extract-required-argument-values'.
  ;; Preprocess any array-specific arguments that are treated like
  ;;    required arguments without necessarily having to be supplied.
  ;; Specially process the :size argument of an array type constructor
  ;;    and add or modify the :size slot in `slotsAndValues' accordingly.
  ;; If no explicit :size argument was supplied, try to generate one from
  ;;    the dimensions specification of `arrayType' (requires that all
  ;;    dimensions are properly specified).
  ;; Additionally, process the :size intialization expression to always
  ;;    be a CONS list of expressions that matches the array rank
  ;;    (this handles cases where the size of a 1-dimensional array was
  ;;    supplied as a single expression instead of a 1-element list).
  (let ((arrayClass (type-class (specifier-base-type arrayType)))
        (arrayDimensions (array-type-dimensions arrayType))
        (arrayRank (length arrayDimensions))
        (initialElementSlot (lookup-slot arrayClass (quote INITIAL-ELEMENT)))
        (initialElementRef (lookup slotsAndValues initialElementSlot))
        (arraySizeSlot (lookup-slot arrayClass (quote SIZE)))
        (sizeRef (lookup slotsAndValues arraySizeSlot))
        (nonListSize? FALSE))
    ;; Handle :size initialization:
    (when (null? sizeRef)
      (when (not (indefinite-array-type? arrayType))
        (setq sizeRef (the-cons-list (array-type-dimensions arrayType)))))
    (cond ((null? sizeRef)
           (walk-error "Missing array :size argument in NEW expression"))
          (otherwise
           ;; Ensure we have a CONS list of dimension expressions, one
           ;;    for each dimension of the array, e.g., correctly handle
           ;;    (new (ARRAY (10) OF FLOAT)) vs.
           ;;    (new (ARRAY () OF FLOAT) :size 10) vs.
           ;;    (new (ARRAY () OF FLOAT) :size x) vs.
           ;;    (new (ARRAY () OF FLOAT) :size (x)) vs.
           ;;    (new (ARRAY () OF FLOAT) :size (1+ x)) vs.
           ;;    (new (ARRAY () OF FLOAT) :size ((1+ x))).
           ;; The current scheme will ensures a non-matching :size expression
           ;;    will lead to an error; however, the actual error message
           ;;    might not always indicate the culprit very well.
           (typecase sizeRef
             (CONS
              ;; Only the 1-dimensional case is ambiguous:
              (when (and (= arrayRank 1)
                         (or
                          ;; if the length of `sizeRef' doesn't match the
                          ;;    dimensions, it must be a single expression:
                          (not (= (length sizeRef) 1))
                          ;; else, it could be a no-argument function/macro:
                          (and (symbol? (first sizeRef))
                               (or (defined?
                                       (lookup-function (first sizeRef)))
                                   (defined?
                                       (lookup-macro (first sizeRef)))))))
                (setq nonListSize? TRUE)))
             (otherwise
              (setq nonListSize? TRUE)))
           (when nonListSize?
             (setq sizeRef (cons sizeRef NIL)))
           (cond ((not (= (length (cast sizeRef CONS)) arrayRank))
                  (walk-error "Array :size initializer " sizeRef EOL
                              "   doesn't match the rank of" EOL
                              "   " arrayType)
                  (setq sizeRef NULL))
                 (otherwise
                  ;; make any indefinite dimensions definite if we have
                  ;;    a constant initializer for them, and check whether
                  ;;    definite dimensions are properly matched:
                  (foreach sizeIt on (cast sizeRef CONS)
                      as dimIt on arrayDimensions
                      as dim in (interval 0 NULL)
                      do (cond ((null? (value dimIt))
                                (when (integer? (value sizeIt))
                                  (setf (value dimIt) (value sizeIt))))
                               ((not (eql? (value dimIt) (value sizeIt)))
                                (walk-error
                                 "Array :size initializer " (value sizeIt)
                                 " doesn't match array dimension " dim " of"
                                 EOL "   " arrayType)
                                ;; make type size dominate:
                                (setf (value sizeIt) (value dimIt)))))))))

    ;; insert preprocessed value-refs into `slotsAndValues':
    (insert-at slotsAndValues initialElementSlot initialElementRef)
    (if (defined? sizeRef)
        (insert-at slotsAndValues arraySizeSlot sizeRef)
      ;; we had an error:
      (remove-at slotsAndValues arraySizeSlot))))

(defun evaluate-array-argument-value
    ((arrayType PARAMETRIC-TYPE-SPECIFIER) (requiredValues LIST)
     (slot SLOT) (valueRef OBJECT))
  ;; Evaluate the initializer `valueRef' expression for an `arrayType' `slot'.
  (cond
   ((eql? (slot-name slot) (quote SIZE))
    ;; special-case evaluation of array :size argument - this pseudo-quoting
    ;;    is awkward, since it differs from the evaluation of regular
    ;;    initializers, but we need it to size multi-dimensional arrays:
    (foreach dim in (cast valueRef CONS)
        collect (walk-expression-tree dim @INTEGER (quote NEW) FALSE)
        into requiredValues))
   (otherwise
    (insert-last requiredValues
                 (walk-expression-tree
                  valueRef
                  (compute-return-type-spec slot arrayType)
                  (quote NEW)
                  FALSE)))))
  
(defun (yield-new-arguments-tree CONS CONS)
    ((keywordsAndValues CONS) (classType TYPE-SPEC) (selfVariable SYMBOL))
  ;; Helping function for 'walk-new-tree'.
  ;; Return two cons lists of required arguments and other slot assignments 
  ;;    extracted from 'keywordsAndValues'.
  ;; GC Side effect: Reuse or deallocate conses in 'keywordsAndValues'.
  (when (odd? (length keywordsAndValues))
    (walk-error "Odd number of arguments in 'new' expression: " keywordsAndValues)
    (return NIL NIL))
  (let ((class (type-spec-to-class classType))
        (pList (new PROPERTY-LIST :the-plist keywordsAndValues))
        (otherAssignments NIL)
        (requiredValues CONS NULL)
        (slotName SYMBOL NULL)
        (slot SLOT NULL))
    ;; convert slot keywords to slots:
    (foreach it on pList
        do (when (not (keyword? (key it)))
             (walk-error "Illegal slot keyword " (key it) " in NEW expression")
             (return NIL NIL))
           (setq slotName (intern-symbol-in-module
                           (symbol-name (cast (key it) KEYWORD))
                           (home-module class)
                           FALSE))
           (setq slot (safe-lookup-slot class slotName))
           (when (null? slot)
             (walk-error "No such slot " slotName " on the class "
                         (class-name class))
             (return NIL NIL))
           (setf (key it) slot))
    (setq requiredValues (extract-required-argument-values classType pList))
    (foreach (slot valueRef) in (cast pList (PROPERTY-LIST OF SLOT OBJECT))
        do (when (not (storage-slot? slot))
             (let ((method METHOD-SLOT slot))
               (when (defined? (method-storage-slot method))
                 (setq slot (lookup-slot class (method-storage-slot method))))))
        collect (bquote (setf (& (slot-name slot) & selfVariable) & valueRef))
        into otherAssignments)
    (return requiredValues otherAssignments) ))

(defun (get-current-self-type TYPE) ()
  ;; Try to determine what a `self' reference in an anchored type
  ;; refers to in the current translation context.
  (let ((method *methodBeingWalked*)
        (owner @UNKNOWN))
    (when (defined? method)
      (setq owner (owner method))
      (when (null? owner)
        (if (method-constructor? method)
            (setq owner (slot-base-type method))
          (setq owner @UNKNOWN))))
    (return owner)))

(defun (walk-new-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Expand a 'new' or 'allocate' expression.
  ;; Return a form that
  ;;    (1) Calls the class constructor, passing it any required arguments;
  ;;    (2) Assigns additional arguments (if there are any);
  (let ((operator (first tree))
        (classTree (second tree))
        (baseClassName (choose (cons? classTree)
                               (first (cast classTree CONS))
                               classTree))
        (keywordArguments (rest (rest tree)))
        (selfVariable (local-gensym "SELF"))
        (classType TYPE-SPEC NULL)
        (newTree CONS NULL))        
    (when (and (not (symbol? baseClassName))
               (not (keyword? baseClassName)))
      (walk-error "Illegal argument to " operator
                  " where symbol expected:  " baseClassName)
      (return (walk-dont-call-me-tree tree @UNKNOWN)))
    (setq classType (safe-yield-type-specifier classTree))
    (when (null? (type-spec-to-class classType))
      (walk-error "Undefined class supplied to " operator " operator: "
                  baseClassName)
      (return (walk-dont-call-me-tree tree @UNKNOWN)))
    (unless (type? classType)
      ;; instantiate any anchored types such as `(new (CONS OF (LIKE (any-value self))))':
      (setq classType (compute-relative-type-spec classType (get-current-self-type))))
    (when (abstract? (type-spec-to-class classType))
      (walk-error "Trying to create an instance of the ABSTRACT class "
                  baseClassName)
      (return (walk-dont-call-me-tree tree @UNKNOWN)))
    ;; SHOULD WE BE CHECKING HERE FOR new ON ABSTRACT CLASSES?
    (mv-bind (requiredArgs otherAssignments)
        (yield-new-arguments-tree keywordArguments classType selfVariable)
      ;; Return the class type instead of the base class, so the translator
      ;; gets to know whether we had a parameterized type or not:
      (setq newTree (bquote (SYS-NEW & classType && requiredArgs)))
      (if (empty? otherAssignments)
        (return newTree classType)
        (return
         (bquote (vrlet ((& selfVariable & newTree))
                   && otherAssignments
                   & selfVariable))
         classType))) ))

(defun (walk-make-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Check syntax of 'make', verify that the class exists, and process any
  ;;    arguments for the native constructor if necessary.
  (let ((className (second tree))
        (arguments (rest (rest tree)))
        (type TYPE NULL)
        (class CLASS NULL))
    (cond
     ((symbol? className) NULL)         ; do nothing
     ((type? className)
      (setf (second tree) (type-to-symbol className)))
     (otherwise
      (walk-error "Bad argument to 'make':" EOL "   "
                  className " found where symbol expected")
      (return (walk-dont-call-me-tree tree @UNKNOWN))))
    (setq type (typify className))
    (setq class (type-class type))
    (when (not (defined? class))
      (walk-error "Reference to undefined class " className)
      (return (walk-dont-call-me-tree tree @UNKNOWN)))
    (when (and (non-empty? arguments)
               (not (exception-class? class)))
      ;; We have arguments that need to be passed to a native constructor.
      ;;    Check whether we have a native non-Lisp class, since currently only
      ;;    those classes could have constructors other than the default one:
      (case (translator-output-language)
        (:cpp (unless (defined? (class-cpp-native-type class))
                (walk-error "MAKE arguments not supported for non-native class "
                            className)
                (return (walk-dont-call-me-tree tree type))))
        (:java (unless (defined? (class-java-native-type class))
                 (walk-error "MAKE arguments not supported for non-native class "
                             className)
                 (return (walk-dont-call-me-tree tree type))))
        (otherwise
         ;; be more tolerant here, for example, to allow partial testing in Lisp:
         (walk-warn "MAKE arguments not supported for " 
                    (translator-output-language-name) "; skipping them")
         (setq arguments NIL))))
    (setf (rest (rest tree)) (walk-list-of-trees arguments))
    (return tree type) ))

(defun (walk-funcall-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk a 'funcall' tree and return a
  ;;    '(SYS-CALL-FUNCTION-CODE <signature> <fun> <arg1> ... <argn>)' or
  ;;    '(SYS-CALL-METHOD-CODE <signature> <method> <arg1> ... <argn>) tree.
  ;; The signature specification is necessary to generate a proper
  ;;    function/method pointer casting expression in C++.  Since CODE is
  ;;    untyped, we infer the signature from the types of the argument
  ;;    expressions and the expected return types.
  (when (or (eq? (first tree) (quote SYS-CALL-FUNCTION-CODE))
            (eq? (first tree) (quote SYS-CALL-METHOD-CODE)))
    (return tree (first (first (cast (second tree) (CONS OF CONS))))))
  (let ((returnType (choose (eq? *targetType* @UNKNOWN)
                            @VOID
                            *targetType*))
        (signature
         ;; The first element of the signature specification is a list of
         ;; return types (multiple return types are not handled right now,
         ;; so currently this is always a single element list):
         (bquote ((& returnType)))))
    (mv-bind (oTree oType)
        (walk-expression-tree (second tree) @CODE (quote FUNCALL) TRUE)
      (setf (first tree)
        (choose (eql? oType @METHOD-CODE)
                (quote SYS-CALL-METHOD-CODE)
                (quote SYS-CALL-FUNCTION-CODE)))
      (setf (second tree) oTree))
    (foreach it on (rest (rest tree))
             do (mv-bind (argTree argType)
                    (walk-a-tree (value it))
                  (setf (value it) argTree)
                  (pushq signature argType)))
    (setf (rest tree)
      (cons (reverse signature) (rest tree)))
    (return tree returnType)))

(defun (walk-the-code-tree CONS TYPE-SPEC) ((tree CONS))
  ;; Walk a 'the-code' tree.
  ;; TO DO: SHOULD THIS CHECK WHETHER THE FUNCTION/METHOD ACTUALLY EXIST?
  (case (second tree)
    (:function
     (when (bad-argument-range? tree 2 3)   ; tar
       (return (walk-dont-call-me-tree tree @FUNCTION-CODE)))
     (when (eql? (third tree) (quote MAIN))
       (case (translator-output-language)
         ((:cpp :cpp-standalone)
	  (walk-error "Cannot generate a function pointer to `main' in C++")
	  (return (walk-dont-call-me-tree tree @FUNCTION-CODE)))
         (otherwise
          (walk-warn
           "Won't be able to generate a function pointer to `main' in C++"))))
     (return tree @FUNCTION-CODE))
    (:method
     (when (bad-argument-count? tree 3)
       (return (walk-dont-call-me-tree tree @METHOD-CODE)))
     (let ((type (typify (third tree))))
       (setf (third tree) type)
       (if (null? (type-class type))
           (walk-error "No class defined for the type: " type)
         (case (translator-output-language)
           ((:cpp :cpp-standalone)
	    (when (subtype-of? type @LITERAL)
              (walk-inform "Cannot have methods on literals in "
			   (translator-output-language-name)
			   ", hence, cannot generate" EOL
			   " a method-code pointer for "
			   (third tree) "." (fourth tree))
              (return (walk-a-tree (bquote (CAST NULL METHOD-CODE)))))
            (when (not (subtype-of? type @OBJECT))
              (walk-inform "Cannot store a method-code pointer for " EOL
			   " " (third tree) "." (fourth tree) EOL
			   " since it is not defined on a subtype of @OBJECT")
              (return (walk-a-tree (bquote (CAST NULL METHOD-CODE))))))
;;;	   (:java
;;;	    (when (subtype-of? type @LITERAL)
;;;              (walk-warn "Cannot have methods on literals in "
;;;                           (translator-output-language-name)
;;;                           ", hence, cannot generate" EOL
;;;                           " a method-code pointer for "
;;;                           (third tree) "." (fourth tree))
;;;              (return (walk-a-tree (bquote (CAST NULL METHOD-CODE))))))
           (otherwise NULL)))
       (return tree @METHOD-CODE)))))


  ;;
;;;;;; Pretty printing of walker error messages
  ;;

(defun (de-uglify-arguments CONS) ((uglyArguments CONS))
  (let ((prettyArguments NIL))
    (foreach arg in uglyArguments
             collect (de-uglify-parse-tree arg) into prettyArguments)
    (return prettyArguments) ))

(defun (de-uglify-parse-tree OBJECT) ((tree OBJECT))
  :public? TRUE
  ;; Return a parse tree that replaces system-specific parse tree
  ;;    constructs by one's that user's can understand.
  (when (null? tree)
    (return NULL))
  (typecase tree
    (CONS
     (let ((operator (first tree)))
       (when (not (symbol? operator))
         (return (de-uglify-arguments tree)))
       (case operator
         ((SYS-SLOT-VALUE SYS-SLOT-VALUE-SETTER SYS-CALL-METHOD)
          (return (de-uglify-parse-tree (rest (rest tree)))))
         (SYS-CALL-FUNCTION
          (return (de-uglify-parse-tree (rest tree))))
         ((TYPED-SYS VOID-SYS BAD-SYS)
          (return (de-uglify-parse-tree (second tree))))
         (GET-SYM
          (return (get-sym-from-offset (second tree))))
         (otherwise
          (let ((prettyArguments NIL))
            (foreach arg in (rest tree)
                     collect (de-uglify-parse-tree arg) into prettyArguments)
            (return
              (bquote (& operator && prettyArguments))))))))
    (COMPOUND-TYPE-SPECIFIER
     (return (yield-type-spec-tree tree)))
    (otherwise
     (return tree))))

  ;;
;;;;;; Generation of Lisp macros
  ;;

;;; Lisp macros for functions, methods, and macros can be generated
;;; automatically by supplying ':lisp-macro? TRUE' as one of the
;;; definition options.  Commands defined with ':command? TRUE' get a
;;; Lisp macro by default, unless that was explictly turned off with
;;; ':lisp-macro? FALSE'.

;;; Specifying ':lisp-macro? TRUE' for some function or method 'foo'
;;; allows one to call 'foo' directly at the Lisp top-level without
;;; having to wrap the call inside an 'eval'.  It also enables one to
;;; call 'foo' directly inside some Lisp application code.

;;; Automatically generated Lisp macros translate the function or method
;;; call at macro expansion time (which is different than what 'eval' does).
;;; This has the advantage to be more efficient when the macro is compiled
;;; into a Lisp application.  
;;; MINOR PROBLEM: The translation can generate hard-coded symbol
;;; references at compile time which might cause problems at execution
;;; time (even using soft-coded references would be problematic
;;; though, since we don't have startup-code to generate them).

;;; Since Stella functions or methods with a Lisp macro still need to
;;; be callable from within Stella code, their Lisp translation has to
;;; be renamed apart from the Lisp macro so that both definitions can
;;; coexist.

(defglobal *native-name-table*
    (HASH-TABLE OF SYMBOL (KEY-VALUE-LIST OF KEYWORD LIST))
  (new HASH-TABLE))

(defun register-native-name
    ((name SYMBOL) (language KEYWORD) (category KEYWORD))
  ;; Register the existence of a global native definition for 'name'
  ;;    in 'language' with 'category'.
  ;; 'language' should be one of the legal target languages such as
  ;;    :common-lisp, :cpp, or :java.
  ;; 'category' should be one of :function, :variable, or :class.
  ;; With this information the 'language' translator can consistently
  ;;    rename apart a conflicting Stella definition.
  ;; Currently, this is only used to separate Stella implementations
  ;;    of command functions from their associated Lisp macros, so,
  ;;    maybe this whole scheme is overkill.  We could of course also
  ;;    store something like a "true name" on the objects themselves,
  ;;    or maybe use (and extend) the :renames mechanism, but that
  ;;    wouldn't work very well for methods.
  (let ((tableEntry (lookup *native-name-table* name))
        (categories LIST NULL))
    (when (null? tableEntry)
      (setq tableEntry (new KEY-VALUE-LIST)))
    (setq categories (lookup tableEntry language))
    (when (null? categories)
      (setq categories (new LIST)))
    (insert-new categories category)
    (insert-at tableEntry language categories)
    (insert-at *native-name-table* name tableEntry)))

(defun (native-name? BOOLEAN)
    ((name SYMBOL) (language KEYWORD) (category KEYWORD))
  ;; Return `true' if a native definition of 'name' with 'category'
  ;;    exists in 'language'.  If `category' is NULL, return true if
  ;;    a native definition of 'name' with any category exists.
  (let ((tableEntry (lookup *native-name-table* name))
        (categories LIST NULL))
    (when (null? tableEntry)
      (return FALSE))
    (setq categories (lookup tableEntry language))
    (if (null? categories)
        (return FALSE)
      (return (or (null? category)
                  (member? categories category))))))

(defun (yield-renamed-name-if-native SYMBOL)
    ((name SYMBOL) (language KEYWORD) (category KEYWORD))
  ;; Return a renamed version of 'name' if it has a native definition
  ;;    in 'language' with 'category'.
  ;; Otherwise, return the unmodified 'name'.
  (if (native-name? name language category)
      (let ((newName SYMBOL NULL))
        (case language
          (:common-lisp
           (setq newName
             (intern-derived-symbol
              name (concatenate "%" (symbol-name name)))))
          (:cpp
           ;; we can disambiguate via explicit qualification:
           (return name))
          (otherwise
           (setq newName
             (intern-derived-symbol
              name (concatenate (symbol-name name) "_")))))
        ;; Unlikely, but hey...
        (return (yield-renamed-name-if-native newName language category)))
    (return name)))

(defun (method-needs-lisp-macro? BOOLEAN) ((method METHOD-SLOT))
  ;; Return `true' if 'method' needs to have a Lisp macro associated with it
  ;;    that can be used to call it directly at the Lisp top level without
  ;;    the help of 'eval'.
  ;; A ':lisp-macro? TRUE' declaration forces the generation of a Lisp
  ;;    macro.  Commands defined with ':command? TRUE' get a Lisp macro
  ;;    by default, unless they also have ':lisp-macro? FALSE' specified.
  (if (and (translate-to-common-lisp?)
           (non-empty? (method-parameter-names method)))
      (let ((lispMacro? (method-lisp-macro? method)))
        (return (or (and (defined? lispMacro?)
                         lispMacro?)
                    (and (command? method)
                         ;; Exclude commands such as `defclass' or `in-module'
                         ;;    which are implemented by a native Lisp macro:
                         (not (method-native? method))
                         (or (null? lispMacro?)
                             lispMacro?)))))
    (return FALSE)))

(defun (yield-lisp-macro-trees CONS CONS) ((name SYMBOL) (method METHOD-SLOT))
  ;; Return a tree to define a Lisp macro named 'name' that will apply
  ;;    the Stella function or method 'method' to a set of arguments.
  ;; Once the Lisp macro is defined, calling '(<name> ....)' at the Lisp
  ;;    top level is equivalent to calling '(eval (<name> ....))'.
  ;; The second return value copies the Lisp macro definition onto the
  ;;    Lisp symbol that represents the fully qualified version of 'name'.
  (let ((module (choose (defined? (interned-in name))
                        (interned-in name)
                        *module*))
        (translatedName
         (yield-global-lisp-symbol module (symbol-name name)))
        (translatedFullName
         (yield-global-lisp-symbol
          module (compute-full-name (symbol-name name) module)))
        (documentation (documentation method)))
    (return
      (bquote
       (verbatim :common-lisp
         (CL:defmacro & translatedName
           (CL:&whole expression CL:&rest ignore)
           && (choose (defined? documentation)
                      (bquote (& (wrap-literal documentation)))
                      NIL)
           (CL:declare (CL:ignore ignore))
           ;; Using 'evaluate' gives robuster error messages, but it wraps
           ;;    results which is not really what we want in API situations:
;;           && (choose
;;               (command? method)
;;               (cons-list
;;                (new VERBATIM-STRING-WRAPPER
;;                     :wrapper-value
;;                     "(setq expression `(evaluate (bquote ,expression)))"))
;;               NIL)
           (CL:let ((& (cl-translate-global-symbol
                        (quote *ignoreTranslationErrors?*))
                     & (choose (command? method)
                               (cl-translate-global-symbol (quote FALSE))
                               (cl-translate-global-symbol (quote TRUE)))))
             (& (cl-translate-global-symbol (quote cl-incrementally-translate))
              expression)))
         :otherwise NULL))
      (bquote
       (verbatim :common-lisp
         (CL:setf (CL:macro-function (CL:quote & translatedFullName))
           (CL:macro-function (CL:quote & translatedName)))
         :otherwise NULL)))))

(defun create-lisp-macro-units ((name SYMBOL) (method METHOD-SLOT))
  ;; Create the necessary translation units to define a Lisp macro
  ;;    named 'name' that calls 'method' (for Stella macros 'method'
  ;;    will be the expander function).
  (when (eql? name (slot-name method))
    (register-native-name name :common-lisp :function))
  (mv-bind (macroTree aliasDefinitionTree)
      (yield-lisp-macro-trees name method)
    (walk-auxiliary-tree macroTree)
    (walk-auxiliary-tree aliasDefinitionTree))
  (when (eql? name (slot-name method))
    (walk-auxiliary-tree
     (bquote
      (startup-time-progn
          (register-native-name
           (quote & name) :common-lisp :function))))))

  ;;
;;;;;; Command definition and evaluation support
  ;;

;;; Stella functions intended to directly serve as a user interface or API
;;; to a particular functionality are called commands.  Commands are defined
;;; by supplying ':command? TRUE' as one of the definition options in a
;;; function definition.  Marking a function as a command provides the
;;; following additional functionality:
;;;
;;; - The function is guaranteed to be evaluable via 'evaluate'.
;;; - It can be called directly at the top-level of a Stella file without
;;;   having to wrap it inside a 'startup-time-progn'.
;;; - A lisp macro will be generated for it automatically, unless
;;;   ':lisp-macro? FALSE' was explicitly specified.

;;; Specifying ':evaluate-arguments? FALSE' allows one to define commands
;;; that do not evaluate their arguments.  This is a better mechanism than
;;; defining a command as a macro, since the macro would always generate
;;; new structure during macro expansion (executing the command as an
;;; expansion side-effect would prohibit the use of the command in regular
;;; Stella code), and to evaluate the generated expansion would require
;;; a general purpose Stella interpreter, while command evaluation can be
;;; performed with a simpler mechanism.

;;; Restrictions:
;;; - Currently, only functions can be commands (methods would require
;;;   more complicated evaluated command dispatch, in particular, since
;;;   the first argument would need to be checked first unevaluated and
;;;   then evaluated - the same functionality would need to be added to
;;;   the walker).  Polymorphic commands can be implemented via generic 
;;;   OBJECT commands that use a 'typecase' or internal methods.
;;; - Return values beyond the first can not be used during evaluation.

;;; TO DO:
;;; - handle C++ translation of definitions and calls to methods
;;;   whose &rest arguments get listified.

(defun (command? BOOLEAN) ((method METHOD-SLOT))
  :documentation "Return `true' if `method' is an evaluable command."
  :public? TRUE
  (return (and (method-command? method)
               (method-function? method))))

(defun (lookup-command METHOD-SLOT) ((name SYMBOL))
  :documentation "If `name' names an evaluable command return its associated
command object;  otherwise, return `null'.  Currently, commands are not
polymorphic, i.e., they can only be implemented by functions."
  :public? TRUE
  (let ((function (lookup-function name)))
    (if (and (defined? function)
             (command? function))
        (return function)
      (return NULL))))

(defun (method-must-be-evaluable? BOOLEAN) ((method METHOD-SLOT))
  ;; Return `true' if 'method' needs to be evaluable by the interpreter.
  (return (and (command? method)
               ;; Exclude commands such as 'defclass':
               (not (method-native? method)))))

(defun (method-needs-evaluator-wrapper? BOOLEAN) ((method METHOD-SLOT))
  ;; Return `true' if an evaluator wrapper needs to be created for 'method'.
  ;; A wrapper is necessary if 'method' needs to be evaluable (e.g., by
  ;;    the command interpreter), and if some of its input/output parameters
  ;;    are bare literals, or if 'method' takes a variable number of arguments.
  ;; In that case the interpreter calls the wrapper function instead of
  ;;    calling the code of 'method' directly.
  (return
    (and (method-must-be-evaluable? method)
         (or (method-variable-arguments? method)
             (> (length (method-parameter-names method)) 5) ;; 'apply' limit
             (> (length (method-return-type-specifiers method)) 1)
             (subtype-of? (type method) @LITERAL)
             (exists tSpec in (method-parameter-type-specifiers method)
                     where (subtype-of? (type-spec-to-base-type tSpec)
                                        @LITERAL))))))

(defun (yield-evaluator-wrapper-name SYMBOL) ((methodName SYMBOL))
  ;; Return the name of the evaluator wrapper for method 'methodName'.
  (let ((base-name (symbol-name methodName))
        (suffix (choose (all-upper-case-string? base-name) 
                        "-EVALUATOR-WRAPPER" "-Evaluator-Wrapper")))
    (return (intern-derived-symbol methodName (concatenate base-name suffix)))))

(defun (yield-argument-access-tree OBJECT)
    ((argumentsVariable SYMBOL) (index INTEGER) (restArgument? BOOLEAN))
  ;; Return a tree to access argument `index' (1-based) in the CONS-list
  ;;    of arguments bound to `argumentsVariable'.
  ;; Argument `index' is considered to be a rest argument if `restArgument?'
  ;;    is `true'.
  (let ((limit 5)
        (accessTree OBJECT argumentsVariable))
    (if (<= index limit)
        (foreach i in (interval 2 index)
	    do (ignore i)
	       (setq accessTree (bquote (rest & accessTree))))
      (setq accessTree
        (bquote (nth-rest & accessTree & (wrap-literal (1- index))))))
    (when (not restArgument?)
      (if (<= index limit)
          (setq accessTree (bquote (value & accessTree)))
        (setf (value (cast accessTree CONS)) (quote nth))))
    (return accessTree)))

(defun (yield-evaluator-wrapper-tree CONS) ((method METHOD-SLOT))
  ;; Return a tree that defines an evaluator wrapper for 'method'.
  (let ((nameTree OBJECT (yield-evaluator-wrapper-name (slot-name method)))
        (callTree (bquote (& (slot-name method))))
        (parameterTypeSpecs
         (method-parameter-type-specifiers method))
        (resultType (type method))
        (nofParameters (length parameterTypeSpecs))
        (variableArguments? (method-variable-arguments? method)))
    (foreach index in (interval 1 nofParameters)
        collect (yield-argument-access-tree
                 (quote arguments) index
                 (and variableArguments?
                      (eq? index nofParameters)))
        into callTree)
    (foreach pType in parameterTypeSpecs
        as it on (rest callTree)
        do
          (cond
           ((sub-type-spec-of? pType @LITERAL)
            (setf (value it)
              (bquote
               (wrapper-value
                (safe-cast & (value it)
                           & (type-to-wrapped-type
                              (type-spec-to-base-type
                               pType)))))))
           ((sub-type-spec-of? pType @ARGUMENT-LIST)
            ;; "Hand-walk" the passing of the argument list from the wrapper
            ;;     to the listified arglist of the `method', since under
            ;;     normal circumstances this is illegal.
            ;; Unfortunately, we have to walk the rest argument access right
            ;;    here, so we can `sys-tree' it to avoid later type conflicts:
            (push-variable-binding
             (quote arguments)
             (yield-listified-variable-arguments-type method))
            (setf (value it)
              (sys-tree (walk-without-type-tree (value it)) pType))
            (pop-variable-binding))
           ((not (eql? pType @OBJECT))
            (setf (value it)
              (bquote
               (safe-cast & (value it)
                          & (yield-type-spec-tree pType)))))))
    (cond ((void? resultType) NULL)
          ((subtype-of? resultType @LITERAL)
           (setq nameTree
             (bquote (& nameTree & (type-to-wrapped-type resultType))))
           (if (eql? (type method) @BOOLEAN)
               (setq callTree (bquote (return (wrap-boolean & callTree))))
             (setq callTree
               (bquote
                (let ((result & callTree))
                  (if (defined? result)
                      (return (wrap-literal result))
                    (return NULL)))))))
          (otherwise
           (setq nameTree (bquote (& nameTree & resultType)))
           (setq callTree (bquote (return & callTree)))))
    (return
      (bquote
       (defun & nameTree ((arguments CONS))
              :auxiliary? TRUE
              && (choose (= nofParameters 0)
                         (bquote ((ignore arguments)))
                         NIL)
              & callTree)))))

(defun (create-evaluator-wrapper-unit METHOD-SLOT) ((method METHOD-SLOT))
  ;; Create a translation unit to define an evaluator wrapper for 'method'.
  ;;  and return the resulting METHOD-SLOT object. 
  (let ((variableArguments? (method-variable-arguments? method))
        (evaluateArguments? (method-evaluate-arguments? method))
        (wrapperTree (yield-evaluator-wrapper-tree method))
	(wrapperMethod METHOD-SLOT NULL))
    (when (> (length (method-return-type-specifiers method)) 1)
      (walk-warn "During interpreted command evaluation only the" EOL
                 " first return value will be usable"))
    ;; Since the evaluator already took care of quoting and collection
    ;; of rest arguments, we have to temporarily pretend 'method' is
    ;; a plain function when it is called inside the evaluator wrapper:
    (when (not evaluateArguments?)
      (setf (method-evaluate-arguments? method) TRUE))
    (when variableArguments?
      (setf (method-variable-arguments? method) FALSE))
    (setq wrapperMethod
      (the-object (help-walk-auxiliary-tree wrapperTree TRUE)))
    (when (not evaluateArguments?)
      (setf (method-evaluate-arguments? method) FALSE))
    (when variableArguments?
      (setf (method-variable-arguments? method) TRUE))
    (return wrapperMethod)))

  ;;
;;;;;; Evaluation
  ;;

;;; 'evaluate' implements the Stella evaluator.

;;; Restrictions:
;;; - Currently, evaluation is restricted to (possibly nested) command
;;;   expressions and global variables.
;;; - Only one return value can be passed during evaluation.

;;; There are two ways to make this evaluator more general:
;;; (1) Define more and more Stella functionality via special commands.
;;; (2) Don't use the special-purpose evaluator functions defined below,
;;;     but instead run an expression through the walker and then interpret
;;;     the resulting parse tree (this conses).

;;; To allow the evaluation of functions that return literals or take
;;; them as arguments or take a variable number of arguments,
;;; evaluator wrappers are used.  For full-fledged Stella evaluation,
;;; these wrappers would need to be generated for all functions and
;;; methods that require them.  Evaluation of functions with variable
;;; number of arguments also makes it necessary to pass these
;;; arguments in a cons-list (similar to Java, see 'walk-variable-arguments'
;;; to see how that is now supported directly by the walker).

;;; Functions that serendipitously fulfill the requirements for being
;;; evaluable could be considered by 'evaluate' even if they are not
;;; commands, however, this is not yet done.

(defspecial *evaluationTree* OBJECT NULL
    :public? TRUE)
(defspecial *evaluationParentTree* OBJECT NULL
    :public? TRUE)

(defun (evaluate OBJECT) ((expression OBJECT))
  :documentation "Evaluate the expression `expression' and return the result.
Currently, only the evaluation of (possibly nested) commands and global
variables is supported.  The second return value indicates the actual type 
of the result (which might have been wrapped), and the third return value
indicates whether an error occurred during the evaluation.  Expressions
are simple to program in Common Lisp, since they are built into the language,
and relatively awkward in Java and C++.  Users of either of those 
languages are more likely to want to call `evaluate-string'."
  :command? TRUE :public? TRUE 
  (let ((oTree OBJECT NULL))
    (when (defined? expression)
      (typecase expression
        (CONS
         (setq oTree (evaluate-cons-tree expression)))
        (otherwise
         (setq oTree (evaluate-atomic-tree expression)))))
    (return oTree)))

(defun (evaluate-string OBJECT) ((expression STRING))
  :documentation
  "Evaluate the expression represented by `expression' and return the result.
This is equivalent to '(evaluate (unstringify expression))'."
  :public? TRUE
  (return (evaluate (unstringify expression))))

(defun (try-to-evaluate OBJECT) ((tree OBJECT))
  :documentation "Variant of `evaluate' that only evaluates `tree' if it
represents an evaluable expression.  If it does not, `tree' is returned
unmodified.  This can be used to implement commands with mixed argument
evaluation strategies."
  :public? TRUE
  (let ((oTree tree))
    (when (defined? tree)
      (typecase tree
        (CONS
         (when (and (symbol? (value tree))
		    (defined? (lookup-command (value tree))))
	   (exception-case 
	       (setq oTree (evaluate-cons-tree tree))
	     (STELLA-EXCEPTION (e)
	       (walk-error (exception-message e))))))
        (otherwise 
	 NULL)))
    (return oTree)))

(defun (evaluate-cons-tree OBJECT TYPE-SPEC) ((tree CONS))
  ;; Evaluate the cons tree 'tree'.
  (special ((*evaluationParentTree* *evaluationTree*)
            (*evaluationTree* tree))
    (let ((operatorName (value tree))
          (arguments (rest tree))
          (operator METHOD-SLOT NULL))
      (typecase operatorName
        (SYMBOL
         (case operatorName
           ;; Special-case certain operators (mostly to support bquote):
           (QUOTE
            (when (eq? (length arguments) 1)
              (return (value arguments) (primary-type (value arguments))))
            (evaluation-error "Illegal QUOTE expression"))
           (BQUOTE
            (return (evaluate-bquote-tree tree)))
           (CONS
            (let ((arg1 (evaluate-argument-tree (first arguments) TRUE))
                  (arg2 (evaluate-argument-tree (second arguments) TRUE)))
              (when (and (cons? arg2)
                         (empty? (rest (rest arguments))))
                (return (cons arg1 arg2) @CONS))
              (evaluation-error "Illegal CONS expression")))
           (APPEND
            (let ((arg1 (evaluate-argument-tree (first arguments) TRUE))
                  (arg2 (evaluate-argument-tree (second arguments) TRUE)))
              (when (and (cons? arg1)
                         (cons? arg2)
                         (empty? (rest (rest arguments))))
                (return (append arg1 arg2) @CONS))
              (evaluation-error "Illegal APPEND expression")))
           (PROGN
             (foreach arg in arguments
                 do (evaluate arg))
             (return NULL @VOID))
           (otherwise
            (when (not (setq? operator (lookup-command operatorName)))
              (evaluation-error "Undefined operator: " operatorName)))))
        (otherwise
         (evaluation-error "Illegal operator: " operatorName)))
      (let ((evaluatorWrapperCode (evaluator-wrapper-code operator))
            (evaluateArgs? (method-evaluate-arguments? operator))
            (variableArgs? (method-variable-arguments? operator))
            (parameterTypes (method-parameter-type-specifiers operator))
            (nofParameters (length parameterTypes))
            (nofArgs (length arguments))
            (minArgs (choose variableArgs?
                             (1- nofParameters)
                             nofParameters))
            (maxArgs (choose variableArgs?
                             NULL
                             nofParameters))
            (unevaluatedArgs arguments)
            (evaluatedArg OBJECT NULL)
            (evaluatedArgType TYPE-SPEC NULL)
            (argIndex 0)
            (returnType (type operator))
            (result OBJECT NULL))
        (when (or (< nofArgs minArgs)
                  (and (defined? maxArgs)
                       (> nofArgs maxArgs)))
          (let ((minString (integer-to-string minArgs))
                (maxString ""))
            (cond ((null? maxArgs)
                   (setq maxString "+"))
                  ((> maxArgs minArgs)
                   (setq maxString (string-concatenate "-" (integer-to-string maxArgs)))))
            (evaluation-error "Wrong number of arguments.  Expected " minString maxString " but got " nofArgs)))
        ;; Loop "by-hand" so we avoid the creation of an ON-iterator:
        (while (non-empty? unevaluatedArgs)
          (mv-setq (evaluatedArg evaluatedArgType)
            (evaluate-argument-tree (value unevaluatedArgs) evaluateArgs?))
          (mv-setq (evaluatedArg evaluatedArgType)
            (coerce-evaluated-tree
             evaluatedArg (value unevaluatedArgs)
             evaluatedArgType
             (choose (>= argIndex minArgs)
                     (variable-arguments-type operator)
                     (nth parameterTypes argIndex))
             evaluateArgs?))
          (setf (value unevaluatedArgs) evaluatedArg)
          (setq unevaluatedArgs (rest unevaluatedArgs))
          (++ argIndex))
        (if (defined? evaluatorWrapperCode)
            (if (void? returnType)
                (funcall evaluatorWrapperCode arguments)
		(setq result (funcall evaluatorWrapperCode arguments)))
          (if (void? returnType)
              ;; TO DO: Check whether 'apply' really works for this in C++,
              ;;        since it assumes a single return value:
              (apply (function-code operator) arguments)
	      (setq result (apply (function-code operator) arguments))))
        (when (defined? result)
          ;; return the actual dynamic return type instead of the static
          ;;    function return type to facilitate coercion:
          (setq returnType (primary-type result)))
        (return result returnType)))))

(defun (evaluate-argument-tree OBJECT TYPE-SPEC)
    ((tree OBJECT) (evaluate? BOOLEAN))
  ;; Evaluate 'tree' which is assumed to be in argument position of a
  ;;    parent cons tree currently under evaluation.
  ;; 'evaluate?' indicates whether the parent tree evaluates its arguments.
  (typecase tree
    (CONS
     (if evaluate?
         (return (evaluate-cons-tree tree))
       (return tree @CONS)))
    (WRAPPER
     (return tree (wrapped-type-to-type (primary-type tree))))
    (otherwise
     (if evaluate?
         (return (evaluate-atomic-tree tree))
       (return tree (primary-type tree))))))

(defun (evaluate-atomic-tree OBJECT TYPE-SPEC) ((tree OBJECT))
  ;; Evaluate the atomic tree 'tree'.
  (special ((*evaluationParentTree* *evaluationTree*)
            (*evaluationTree* tree))
    (typecase tree
      (SYMBOL
       (case tree
         ;; Special-case a few constants:
         (NULL (return tree @UNKNOWN))
         (NIL (return NIL @CONS))
         (TRUE (return TRUE-WRAPPER @BOOLEAN))
         (FALSE (return FALSE-WRAPPER @BOOLEAN))
         (otherwise
          ;; Try to evaluate a global variable:
          (evaluation-error "Variable evaluation not yet implemented"))))
      (SURROGATE
       (return tree @SURROGATE))
      (KEYWORD
       (return tree @KEYWORD))
      (WRAPPER
       (return tree (wrapped-type-to-type (primary-type tree))))
      (otherwise
       (evaluation-error "Unknown atomic expression type: " tree)))))

(defun (make-evaluatable-bquote-tree OBJECT) ((tree OBJECT))
  ;; Return 'tree' with 'cons' replacing 'list*' and
  ;; `quote' to represent symbol references.
  (typecase tree
    (CONS
     (case (first tree)
       (GET-SYM
        (return (bquote (QUOTE & (get-sym (second tree))))))
       (GET-SGT
        (return (get-sgt (second tree))))
       (GET-KWD
        (return (get-kwd (second tree))))
       (otherwise
        (let ((args NIL))
          (foreach arg in (rest tree)
              collect (make-evaluatable-bquote-tree arg) into args)
          (case (first tree)
            (LIST*
             (when (empty? (rest args))
               (return (first args)))
             (setq args (reverse args))
             (let ((consTree (bquote (cons & (second args) & (first args)))))
               (foreach arg in (rest (rest args))
                   do (setq consTree (bquote (cons & arg & consTree))))
               (return consTree)))
            (CONCATENATE
             ;; map `concatenate' onto `append', since it is a function: 
             (return (bquote (append & (first args) & (second args)))))
            (otherwise
             (return (cons (first tree) args))))))))
    (otherwise
     (return tree))))
  
(defun (evaluate-bquote-tree OBJECT TYPE-SPEC) ((tree CONS))
  ;; Normalize and evaluate the bquote `tree' `(bquote ...)'.
  (let ((argTree OBJECT NULL))
    (special ((*useHardcodedSymbols?* true))
      (setq argTree (make-evaluatable-bquote-tree (expand-bquote-tree (second tree)))))
    (return (evaluate-argument-tree argTree TRUE))))

(defun (coerce-evaluated-tree OBJECT TYPE-SPEC)
    ((tree OBJECT) (sourceTree OBJECT)
     (sourceType TYPE-SPEC) (targetType TYPE-SPEC)
     (evaluate? BOOLEAN))
  ;; Try to coerce the evaluated 'tree' from 'sourceType' to 'targetType'
  ;;    and return the result and its type.
  ;; 'evaluate?' indicates whether 'tree' represents an evaluated argument.
  ;; 'sourceTree' is only used for error annotations.
  ;; Since we are in interpreted mode, the number of possible coercions
  ;;    is limited to conversions between wrapped and unwrapped types
  ;;    and the special handling of the symbols `null', `true', and `false'.
  (special ((*evaluationParentTree* *evaluationTree*)
            (*evaluationTree* sourceTree))
    (let ((sourceBaseType (type-spec-to-base-type sourceType))
          (targetBaseType (type-spec-to-base-type targetType)))
      (when (eql? tree (quote NULL))
        (case targetType
          (@INTEGER (return NULL-INTEGER-WRAPPER targetType))
          (@LONG-INTEGER (return NULL-LONG-INTEGER-WRAPPER targetType))
          (@FLOAT (return NULL-FLOAT-WRAPPER targetType))
          (@STRING (return NULL-STRING-WRAPPER targetType))
          (@BOOLEAN (return FALSE-WRAPPER targetType))
          (otherwise (return NULL targetType))))
      (when (and (eql? targetType @BOOLEAN)
                 (not evaluate?))
        (when (eql? tree (quote TRUE))
          (return TRUE-WRAPPER targetType))
        (when (eql? tree (quote FALSE))
          (return FALSE-WRAPPER targetType)))
      (when (subtype-of? sourceBaseType targetBaseType)
        (return tree sourceType))
      ;; Handle wrapped literals passed to unevaluated OBJECT parameters:
      (when (and (or (not evaluate?)
                     ;; constants such as TRUE or FALSE have already been
                     ;;    converted to wrappers by `evaluate-atomic-tree':
                     (isa? tree @WRAPPER))
                 (subtype-of? sourceBaseType @LITERAL)
                 (subtype-of?
                  (type-to-wrapped-type sourceBaseType) targetBaseType))
        (return tree (type-to-wrapped-type sourceBaseType)))
      ;; This is the only coercion we can perform, since a literal parameter
      ;; triggers the construction of an evaluator wrapper which will do it:
      (when (and (subtype-of? targetBaseType @LITERAL)
                 (subtype-of?
                  sourceBaseType (type-to-wrapped-type targetBaseType)))
        (return tree targetType))
      (if (void? sourceType)
          (evaluation-error sourceTree ; (value (cast sourceTree CONS))
			    " does not return a value")
	  (evaluation-error "Type conflict: " (yield-type-spec-tree sourceType)
			    " found where " (yield-type-spec-tree targetType)
			    " expected"))
      )))

#|
;; Tests:

(defun (NOT CONS) ((arg OBJECT))
  :command? TRUE :evaluate-arguments? FALSE
  (return (bquote (LOGIC-NOT & (try-to-evaluate arg)))))

(defun (AND CONS) ((arg1 OBJECT) (arg2 OBJECT))
  :command? TRUE :evaluate-arguments? FALSE
  (return (bquote (LOGIC-AND & (try-to-evaluate arg1)
                             & (try-to-evaluate arg2)))))

(defun (OR CONS) ((arg1 OBJECT) (arg2 OBJECT))
  :command? TRUE :evaluate-arguments? FALSE
  (return (bquote (LOGIC-OR & (try-to-evaluate arg1)
                            & (try-to-evaluate arg2)))))

(defun (AND* CONS) (&rest (args STANDARD-OBJECT))
  :command? TRUE :evaluate-arguments? FALSE
  (foreach it on args
           do (setf (value it) (try-to-evaluate (value it))))
  (return (bquote (LOGIC-AND && args))))

;; Can't use the 'or' at the top level directly, since the Lisp macro calls
;;    'incrementally-translate' which interprets it as a Stella 'or':

STELLA(71): (evaluate (bquote (or (and p (not q)) (not (and p q)))))
{LOGIC-OR {LOGIC-AND P {LOGIC-NOT Q}} {LOGIC-NOT {LOGIC-AND P Q}}}
@CONS
0
STELLA(72): (evaluate (bquote (or (and p (not)) (not (and p q)))))
>> ERROR: While evaluating '(NOT)' inside '(AND P (NOT))':
   Wrong number of arguments.
{LOGIC-OR {LOGIC-AND P NULL} {LOGIC-NOT {LOGIC-AND P Q}}}
@CONS
0
STELLA(73): (evaluate (bquote (or (and* p (not q) r) (not (and p q)))))
{LOGIC-OR {LOGIC-AND P {LOGIC-NOT Q} R} {LOGIC-NOT {LOGIC-AND P Q}}}
@CONS
0
STELLA(74): (evaluate (bquote (or (and* 2 (not q) r) (not (and p q)))))
>> ERROR: While evaluating '2' inside '(AND* 2 (NOT Q) R)':
   Type conflict: 'INTEGER' found where 'STANDARD-OBJECT' expected.
{LOGIC-OR NULL {LOGIC-NOT {LOGIC-AND P Q}}}
@CONS
0
STELLA(75): 
|#

  ;;
;;;;;; STELLA Listener
  ;;

;;; Implements a STELLA read/eval/print loop that exploits the
;;; evaluator of the surrounding Lisp environment.
  
;;; TO DO:
;;; - handle implicit definition of variables via `setq' (use dynamic
;;;   runtime typing to infer types that can be used in the translation)
;;; - properly handle top-level VRLET expressions (currently, we don't get
;;;   the return value)
;;; - handle printing of results depending on whether we are evaluating an
;;;   expression or a statement
;;; - implement an escape-to-lisp function (e.g., via ^)
;;; - pass-on Allegro keyword commands if possible
;;; - print copyright similar to PowerLoom listener

#|
(defspecial *stella-listener-input-stream* INPUT-STREAM NULL)
(defspecial *stella-listener-output-stream* OUTPUT-STREAM NULL)

(startup-time-progn
  (setq *stella-listener-input-stream* STANDARD-INPUT)
  (setq *stella-listener-output-stream* STANDARD-OUTPUT))

(defglobal *stella-listener-prompt* STRING "[%m] ")

(defun (stella-listener-prompt STRING) ()
  ;; Substitute format directives such as `%m' in `*stella-listener-prompt*'
  ;;    and return the result.
  (let ((prompt *stella-listener-prompt*))
    (setq prompt (replace-substrings prompt (module-name *module*) "%m"))
    (setq prompt (replace-substrings prompt (module-full-name *module*) "%M"))
    (return prompt)))

;;; these should be "virtual" variables with type UNKNOWN, since they must
;;;    be able to handle literals as well as objects:
(defglobal * OBJECT NULL)
(defglobal ** OBJECT NULL)
(defglobal *** OBJECT NULL)

(defun stella-listener-loop ()
  ;; Run a read/eval/print loop that reads STELLA commands from the current
  ;;    listener input stream, evaluates them, and prints their results.
  ;; Exit if the user entered a termination command as determined by
  ;;    'stella-listener-exit?'.
  (let ((command OBJECT NULL))
    (special ((*module* *module*)
              (*context* *context*)
              (*printReadably?* TRUE)
              (*printPretty?* TRUE))
      (loop
	(exception-case
	    (progn
	      (print-stream *stella-listener-output-stream*
                            (stella-listener-prompt))
	      (setq command (stella-listener-read))
	      (when (stella-listener-exit? command)
		(break))
	      (stella-listener-eval-and-print command))
	  (STELLA-EXCEPTION (e)
            (print-stream STANDARD-ERROR ">> Error: "
                          (exception-message e))))))))

(defun (stella-listener-read OBJECT) ()
  ;; Read a STELLA listener input expression and return it.
  (return (read-s-expression *stella-listener-input-stream*)))

(defun (stella-listener-exit? BOOLEAN) ((command OBJECT))
  ;; Return true if 'command' is a STELLA listener exit command.
  (let ((exit? FALSE))
    (typecase command
      ((KEYWORD SYMBOL)
       (case (symbol-name command)
         (("BYE" "EXIT" "HALT" "QUIT" "STOP"
           "bye" "exit" "halt" "quit" "stop")
          (setq exit? TRUE))
         (otherwise NULL)))
      (otherwise NULL))
    (return exit?)))

(defun stella-listener-eval-and-print ((command OBJECT))
  (special ((*translatorOutputLanguage* :COMMON-LISP)
            (*ignoreTranslationErrors?* FALSE)
            (*safety* 3)
            (*debugLevel* 3)
            (*optimizeSpeedLevel* 0)
            (*optimizeSpaceLevel* 0))
    (let ((translation (incrementally-translate command))
          (nativeOut (native-stream *stella-listener-output-stream*))
          (result OBJECT NULL))
      (verbatim
        :common-lisp
        "(CL:progn
          (CL:setq result (CL:eval (cons-tree-to-lisp-code translation)))
          (CL:setq *** **)
          (CL:setq ** *)
          (CL:setq * result)
          (CL:format nativeOut \"~s~%\" result))"
        :otherwise NULL))))

(defun stella ()
  :documentation "Run the STELLA listener.  Read STELLA expressions from the
standard input, evaluate them, and print their results.  Exit if the user
entered `bye', `exit', `halt', `quit', or `stop'."
  :public? TRUE
  (print EOL "    Welcome to " *stella-version-string* EOL EOL
         "Copyright (C) USC Information Sciences Institute." EOL
         "STELLA comes with ABSOLUTELY NO WARRANTY!" EOL
         ;"Type `(copyright)' for detailed copyright information." EOL
         "Type `bye', `exit', `halt', `quit', or `stop', to exit."
         EOL EOL)
  (stella-listener-loop)
  (print "Bye." EOL EOL))

|#
