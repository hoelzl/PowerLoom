;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;; BEGIN LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
; Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          ;
;                                                                            ;
; The contents of this file are subject to the Mozilla Public License        ;
; Version 1.1 (the "License"); you may not use this file except in           ;
; compliance with the License. You may obtain a copy of the License at       ;
; http://www.mozilla.org/MPL/                                                ;
;                                                                            ;
; Software distributed under the License is distributed on an "AS IS" basis, ;
; WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   ;
; for the specific language governing rights and limitations under the       ;
; License.                                                                   ;
;                                                                            ;
; The Original Code is the STELLA Programming Language.                      ;
;                                                                            ;
; The Initial Developer of the Original Code is                              ;
; UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          ;
; 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               ;
;                                                                            ;
; Portions created by the Initial Developer are Copyright (C) 1996-2006      ;
; the Initial Developer. All Rights Reserved.                                ;
;                                                                            ;
; Contributor(s):                                                            ;
;                                                                            ;
; Alternatively, the contents of this file may be used under the terms of    ;
; either the GNU General Public License Version 2 or later (the "GPL"), or   ;
; the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   ;
; in which case the provisions of the GPL or the LGPL are applicable instead ;
; of those above. If you wish to allow use of your version of this file only ;
; under the terms of either the GPL or the LGPL, and not to allow others to  ;
; use your version of this file under the terms of the MPL, indicate your    ;
; decision by deleting the provisions above and replace them with the notice ;
; and other provisions required by the GPL or the LGPL. If you do not delete ;
; the provisions above, a recipient may use your version of this file under  ;
; the terms of any one of the MPL, the GPL or the LGPL.                      ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; END LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; Version: date-time.ste,v 1.29 2006/05/16 06:40:17 hans Exp

(in-package "STELLA")

(in-module "/STELLA")

;;;;
;;;;  Support Functions
;;;;

(defun (compute-julian-day integer) ((yyyy INTEGER) (mm INTEGER) (dd INTEGER))
  :public? TRUE
  :documentation "Returns the Julian day that starts at noon on yyyy-mm-dd.
`yyyy' is the year.  `mm' is the month.  `dd' is the day of month.
Negative years are B.C.  Remember there is no year zero."
  ;; Algorithm converted from "Numeric Recipes in C", p. 10.
  (let ((jul 0)
	(ja 0)
	(jy 0)
	(jm 0))

    ;; Optional error checking:
    (when (= yyyy 0)
      (error "There is no year zero."))
    (when (> mm 12)
      (error "Month " mm " must be <= 12"))
    (when (< mm 0)
      (error "Month " mm " must be > zero."))
    (when (> dd 31)
      (error "Day " dd " must be <= 31"))
    (when (< dd 0)
      (error "Day " dd " must be > zero."))

    (when (< yyyy 0)
      (++ yyyy))
    (if (> mm 2)
      (progn
	(setq jy yyyy)
	(setq jm (+ mm 1)))
      (progn
	(setq jy (- yyyy 1))
	(setq jm (+ mm 13))))
    (setq jul (+ (floor (* 365.25 jy))
		 (floor (* 30.6001 jm))
		 dd
		 1720995))
    ;; Test for change to Gregorian Calendar on Oct. 15, 1582
    (when (>= (+ dd (* 31 (+ mm (* 12 yyyy))))
	      (+ 15 (* 31 (+ 10 (* 12 1582)))))
      (setq ja (* 0.01 jy))
      (++ jul (+ (- 2 ja) (cast (* 0.25 ja) INTEGER))))
    (return jul) ))

(defun (julian-day-to-modified-julian-day INTEGER) ((julian-day INTEGER))
  :public? TRUE
  :documentation
  "Returns the modified Julian day during which `julian-day'starts at noon."
  ;; Technical this should subtract 2400000.5 to account for the half-day
  ;; shift, but since we are only dealing with whole days, we ignore that.
  (return (- julian-day 2400000)))

(defun (modified-julian-day-to-julian-day INTEGER) ((modified-julian-day INTEGER))
  :public? TRUE
  :documentation
  "Returns the modified Julian day during which `julian-day'starts at noon."
  ;; Technical this should add 2400000.5 to account for the half-day
  ;; shift, but since we are only dealing with whole days, we ignore that.
  (return (+ modified-julian-day 2400000)))

(defun (compute-day-of-week-julian KEYWORD) ((julian-day INTEGER))
  :public? TRUE
  :documentation "Returns the day of the week for julian-day"
  (case (rem julian-day 7)
    (0 (return :monday))
    (1 (return :tuesday))
    (2 (return :wednesday))
    (3 (return :thursday))
    (4 (return :friday))
    (5 (return :saturday))
    (6 (return :sunday))))

(defun (compute-day-of-week KEYWORD) ((yyyy INTEGER) (mm INTEGER) (dd INTEGER))
  :public? TRUE
  :documentation "Returns the day of the week for yyyy-mm-dd."
  (return (compute-day-of-week-julian (compute-julian-day yyyy mm dd))))

(defun (compute-next-moon-phase INTEGER FLOAT) ((N INTEGER) (PHASE KEYWORD))
  :public? TRUE
  :documentation "Returns the Julian Day and fraction of day of the Nth occurence
since January 1, 1900 of moon PHASE.  PHASE is one of :NEW-MOON, :FIRST-QUARTER,
:FULL-MOON, :LAST-QUARTER"
  ;; Algorithm converted from "Numeric Recipes in C", p. 1-2.
  (let ((i 0)
	(am 0.0)
	(as 0.0)
	(c 0.0)
	(x 0.0)
	(x2 0.0)
	(extra 0.0)
	(rad (/ PI 180.0))
	(julian-day 0))
    (case phase
      (:new-moon
       (setq c n)
       (setq julian-day 0))
      (:first-quarter
       (setq c (+ n 0.25))
       (setq julian-day 7))
      (:full-moon
       (setq c (+ n 0.5))
       (setq julian-day 14))
      (:last-quarter
       (setq c (+ n 0.75))
       (setq julian-day 21)))
    (setq x (/ c 1236.85))
    (setq x2 (* x x))
    (setq as (+ 359.2242 (* 29.105356 c)))
    (setq am (+ 306.0253 (* 385.816918 c) (* 0.010730 x2)))
    (setq julian-day (+ 2415020 (* 28 n) julian-day))
    (setq extra (+ 0.75933 (* 1.53058868 c) (* (- 1.178e-4 (* 1.55e-7 x)) x2)))
    (case phase
      ((:new-moon :full-moon)
       (++ extra (- (* (- 0.1734 (* 3.93e-4 x)) (sin (* as rad)))
		    (* 0.4068 (sin (* am rad))))))
      ((:first-quarter :last-quarter)
       (++ extra (- (* (- 0.1721 (* 4.0e-4 x)) (sin (* as rad)))
		    (* 0.6280 (sin (* am rad)))))))
    (setq i (choose (>= extra 0.0) (floor extra) (ceiling (- extra 1.0))))
    (return (+ julian-day i) (- extra i))))
  
(defun (compute-calendar-date INTEGER INTEGER INTEGER KEYWORD) ((julian-day INTEGER))
  :public? TRUE
  :documentation "Returns the YEAR, MONTH, DAY, DAY-OF-WEEK on which the given
`julian-day' begins at noon."
  ;; Algorithm converted from "Numeric Recipes in C", p. 11-12.
  (let ((ja julian-day)
	(jalpha 0)
	(jb 0)
	(jc 0)
	(jd 0)
	(je 0)
	(igreg 2299161)			; Start of Gregorian calendar.
	(yyyy 0)
	(mm 0)
	(dd 0))
    (when (>= julian-day igreg)		; Gregorian calendar correction
      (setq jalpha (/ (- julian-day 1867216 0.25) 36524.25))
      (setq ja (+ julian-day 1 jalpha (cast (* -0.25 jalpha) INTEGER))))
    (setq jb (+ ja 1524))
    (setq jc (+ 6680.0 (/ (- jb 2439870 122.1) 365.25)))
    (setq jd (+ (* 365 jc) (* 0.25 jc)))
    (setq je (/ (- jb jd) 30.6001))
    (setq dd (- jb jd (cast (* 30.6001 je) INTEGER)))
    (setq mm (- je 1))
    (when (> mm 12) (-- mm 12))
    (setq yyyy (- jc 4715))
    (when (> mm 2) (-- yyyy))
    (when (<= yyyy 0) (-- yyyy))
    (return yyyy mm dd (compute-day-of-week-julian julian-day))))


;;;
;;; Current Time
;;;

(verbatim
    :cpp "# include <time.h>
"
    :otherwise NULL)

(defun (get-current-date-time INTEGER INTEGER INTEGER KEYWORD
			      INTEGER INTEGER INTEGER INTEGER) ()
  :public? TRUE
  :documentation "Returns the current time in UTC as multiple values of
year month day day-of-week hour minute second millisecond.  Currently
millisecond will always be zero (even in Java where it is technically available)."
  ()
  (let ((year 0)
	(month 0)
	(day 0)
	(hour 0)
	(minute 0)
	(second 0)
	(millisecond 0))
    (verbatim
	:common-lisp (cl:multiple-value-setq (second minute hour day month year)
		       (cl:decode-universal-time (cl:get-universal-time) 0))
	:java "java.util.Calendar gc = new java.util.GregorianCalendar(java.util.TimeZone.getTimeZone(\"UTC\"));
      year = gc.get(java.util.Calendar.YEAR);
      month = gc.get(java.util.Calendar.MONTH) + 1 - java.util.Calendar.JANUARY;
      day = gc.get(java.util.Calendar.DAY_OF_MONTH);
      hour = gc.get(java.util.Calendar.HOUR_OF_DAY);
      minute = gc.get(java.util.Calendar.MINUTE);
      second = gc.get(java.util.Calendar.SECOND);"
	;; Include files: <time.h> <sys/types.h>
	:cpp "time_t now = time(0);
      if (now > 0) {
        struct tm* time = gmtime(&now);
        year  = time->tm_year + 1900;
        month = time->tm_mon + 1;
        day   = time->tm_mday;
        hour  = time->tm_hour;
        minute = time->tm_min;
        second = time->tm_sec;
      }"
	)
    (return year month day (compute-day-of-week year month day)
	    hour minute second millisecond)))

(defun (get-local-time-zone FLOAT) ()
  :public? TRUE
  :documentation "Returns the current time zone offset from UTC as a float,
considering the effects of daylight savings time."
  (let ((offset 0.0))
    (verbatim
	:common-lisp 
      "(cl:multiple-value-bind 
	  (s m h dd mm yy dow daylight-savings-p zone)
	  (cl:get-decoded-time)
	(cl:declare (cl:ignore s m h dd mm yy dow))
	(cl:if daylight-savings-p
	  (cl:setq offset (cl:- (cl:float (- zone 1) 0.0d0)))
          (cl:setq offset (cl:- (cl:float zone 0.0d0)))))"
      :java "java.util.Calendar gc = java.util.Calendar.getInstance();
    offset = (gc.get(java.util.Calendar.ZONE_OFFSET) + 
              gc.get(java.util.Calendar.DST_OFFSET)) / (1000.0 * 60.0 * 60.0);"
      :cpp "tzset();
#if defined(__APPLE__)
   time_t now = time(0);
   if (now > 0) {
       struct tm* time = gmtime(&now);
       offset = time->tm_gmtoff  / (60.0 * 60.0);
     }
#elif defined(__CYGWIN__)
    offset = - _timezone / (60.0 * 60.0);
    if (daylight > 0) offset += 1.0;
#else
    offset = - timezone / (60.0 * 60.0);
    if (daylight > 0) offset += 1.0;
#endif
")
    (return offset) ))

(defun (get-local-standard-time-zone FLOAT) ()
  :public? TRUE
  :documentation "Returns the standard time zone offset from UTC as a float,
without considering the effects of daylight savings time."
  (let ((offset 0.0))
    (verbatim
	:common-lisp 
      "(cl:multiple-value-bind 
	  (s m h dd mm yy dow daylight-savings-p zone)
	  (cl:get-decoded-time)
	(cl:declare (cl:ignore s m h dd mm yy dow daylight-savings-p))
        (cl:setq offset (cl:- (cl:float zone 0.0d0))))"
      :java "java.util.Calendar gc = java.util.Calendar.getInstance();
    offset = gc.get(java.util.Calendar.ZONE_OFFSET) / (1000.0 * 60.0 * 60.0);"
      :cpp "tzset();
#if defined(__APPLE__)
   time_t now = time(0);
   if (now > 0) {
       struct tm* time = gmtime(&now);
       offset = time->tm_gmtoff  / (60.0 * 60.0);
       if (time->tm_isdst > 0) offset -= 1.0;
     }
#elif defined(__CYGWIN__)
    offset = - _timezone / (60.0 * 60.0);
#else
    offset = - timezone / (60.0 * 60.0);
#endif
")
    (return offset) ))

(defun (get-local-time-zone-for-date FLOAT)
    ((year INTEGER) (month INTEGER) (day INTEGER)
     (hour INTEGER) (minute INTEGER) (second INTEGER))
  :public? TRUE
  :documentation "Returns the time zone offset from UTC (as a float)
that is applicable to the given date.  Assumes that the date is one
that is valid for the underlying programming language.  If not, then
returns 0.0"
  (let ((offset 0.0))
    (verbatim
	:common-lisp 
      "(cl:when (cl:>= year 1900)
         (cl:multiple-value-bind 
	  (s m h dd mm yy dow daylight-savings-p zone)
	    (cl:decode-universal-time
              (cl:encode-universal-time second minute hour day month year))
	  (cl:declare (cl:ignore s m h dd mm yy dow))
	  (cl:if daylight-savings-p
	    (cl:setq offset (cl:- (cl:float (- zone 1) 0.0d0)))
            (cl:setq offset (cl:- (cl:float zone 0.0d0))))))"
      :java "java.util.Calendar gc;
    if (year > 0) {
      gc = new java.util.GregorianCalendar (year,month-1,day,hour,minute,second);
    } else {
      gc = new java.util.GregorianCalendar (-year,month-1,day,hour,minute,second);
      gc.set(java.util.Calendar.ERA, java.util.GregorianCalendar.BC);
    }
    offset = (gc.get(java.util.Calendar.ZONE_OFFSET) + 
              gc.get(java.util.Calendar.DST_OFFSET)) / (1000.0 * 60.0 * 60.0);"
      :cpp "if ((year > 1970) && (year < 2038)) {
        struct tm time;
        time.tm_year = year - 1900;
        time.tm_mon = month - 1;
        time.tm_mday = day;
        time.tm_hour = hour;
        time.tm_min = minute;
        time.tm_sec = second;
        time.tm_isdst = -1;    // Flag to have mktime determine DST

        mktime(&time);  // Executed for normalization effect only!

        tzset();

#if defined(__APPLE__)
        offset = time.tm_gmtoff / (60.0 * 60.0);
#elif defined(__CYGWIN__)
        offset = - _timezone / (60.0 * 60.0);
        if (time.tm_isdst > 0) offset += 1.0;
#else 
        offset = - timezone / (60.0 * 60.0);
        if (time.tm_isdst > 0) offset += 1.0;
#endif
  }")
    (return offset) ))

(defun (time-zone-format60 STRING) ((timezone FLOAT))
  :public? FALSE
  :documentation "Format `zone' as an hh:mm string"
  (let ((sign "+")
	(hours 0))
    (when (< timezone 0)
      (setq sign "-")
      (setq timezone (- timezone)))
    (setq hours (round timezone))
    (return (concatenate 
	     sign
	     (format-with-padding (integer-to-string hours)
				  2 #\0 :right false)
	     ":"
	     (format-with-padding (integer-to-string (round (* (- timezone hours) 60.0)))
				  2 #\0 :right false)))))


;;;;
;;;;  Date and Time Objects
;;;;

(defconstant MILLIS-PER-DAY INTEGER (* 1000 60 60 24)
  :public? FALSE)
(defconstant MILLIS-PER-HOUR INTEGER (* 1000 60 60)
  :public? FALSE)

(defglobal *month-abbreviation-vector* (VECTOR OF STRING-WRAPPER) NULL
  :documentation "A vector of month abbreviations for printing dates")

(startup-time-progn :globals
  (setq *month-abbreviation-vector*
    (new (VECTOR OF STRING-WRAPPER)
         :array-size 13))
  (foreach i in (interval 0 12)
      as abbreviation in (quote ("NUL" "JAN" "FEB" "MAR" "APR" "MAY" "JUN"
				       "JUL" "AUG" "SEP" "OCT" "NOV" "DEC"))
      do (setf (nth *month-abbreviation-vector* i) abbreviation)))


(defclass native-date-time ()
  :public? true
  :documentation "A data type that is used to hold the native date and time
information.   It is opaque to the Stella users.  It is provided so that
Stella `calendar-date' objects can be translated into and out of native format.
Note that there is no way to initialize a variable holding a `native-date-time'
except by such a translation."
  :cpp-native-type "time_t"
  :cl-native-type "INTEGER"
  :java-native-type "long")

;;; The decoded-date-time structure holds the time/date values 
;;; Note: Currently nothing is done with the day of the week.  It might
;;; be appropriate to add a function to see if it matches the date.

(defclass decoded-date-time (STANDARD-OBJECT)
  :public? TRUE
  :documentation "A data structure for holding decoded time values with fields
for easy access of the components."
  :public-slots
  ((date-time-millis :initially 0.0  :type float)    ; Value < 1000.0
   (date-time-second :initially 0    :type integer)  ; Value between 0 and 59.
   (date-time-minute :initially 0    :type integer)	; Value between 0 and 59.
   (date-time-hour   :initially 0    :type integer)	; Value between 0 and 23.
   (date-time-day    :initially 1    :type integer)	; Value between 1 and 31.
   (date-time-month  :initially 1    :type integer)	; Value between 1 and 12.
   (date-time-year   :initially 1900 :type integer)	; 
   (date-time-zone   :initially 0.0  :type float)    ; Value between -12.0 and 14.0
   (date-time-dow    :initially :SUNDAY :type keyword)) ; Day of week.
  )

(defmethod (hash-code INTEGER) ((self DECODED-DATE-TIME))
  :public? TRUE :globally-inline? TRUE
  (return (logxor (logor (logor (shift-left (date-time-year self) 9)
				(shift-left (date-time-month self) 5))
			 (date-time-day self))
		  (logor (logor (shift-left (date-time-hour self) 12)
				(shift-left (date-time-minute self) 6))
			 (date-time-second self)))))

(defmethod set-current-time ((values-structure DECODED-DATE-TIME))
  :public? TRUE
  :documentation "Sets the current time into `values-structure'"
  (mv-bind (year mon day dow hour min sec millis)
      (get-current-date-time)
    (ignore year mon day dow)
    (setf (date-time-millis values-structure) millis)
    (setf (date-time-second values-structure) sec)
    (setf (date-time-minute values-structure) min)
    (setf (date-time-hour values-structure) hour)))

(defmethod set-current-date ((values-structure DECODED-DATE-TIME))
  :public? TRUE
  :documentation "Sets the current date into `values-structure'"
  (mv-bind (year mon day dow hour min sec millis)
      (get-current-date-time)
    (ignore hour min sec millis)
    (setf (date-time-dow values-structure) dow)
    (setf (date-time-day values-structure) day)
    (setf (date-time-month values-structure) mon)
    (setf (date-time-year values-structure) year)))

(defmethod set-current-date-time ((values-structure DECODED-DATE-TIME))
  :public? TRUE
  :documentation "Sets the current date and time into `values-structure'"
  (mv-bind (year mon day dow hour min sec millis)
      (get-current-date-time)
    (setf (date-time-millis values-structure) millis)
    (setf (date-time-second values-structure) sec)
    (setf (date-time-minute values-structure) min)
    (setf (date-time-hour values-structure) hour)
    (setf (date-time-dow values-structure) dow)
    (setf (date-time-day values-structure) day)
    (setf (date-time-month values-structure) mon)
    (setf (date-time-year values-structure) year)))


(defmethod (decoded-date-time-to-iso8601-string STRING) ((date DECODED-DATE-TIME))
  :public? TRUE
  :documentation "Returns an ISO-8601 string representation of `date'
The Format is YYYY-MM-DDThh:mm:ss+zz:zz, with the string stopping at
when a null value is first encountered.  The time zone will only
be included (if present) if a time value is given."
  
  (let ((buffer (make-raw-mutable-string 25))
	(index 0))
    (when (defined? (date-time-year date))
      (setq index (insert-string (integer-to-string (date-time-year date))
				 0 null buffer index :PRESERVE))
      (when (defined? (date-time-month date))
	(setq index (insert-string "-" 0 null buffer index :PRESERVE))
	(setq index (insert-string (format-with-padding 
				    (integer-to-string (date-time-month date))
				    2 #\0 :right false)
				   0 null buffer index :PRESERVE))
	(when (defined? (date-time-day date))
	  (setq index (insert-string "-" 0 null buffer index :PRESERVE))
	  (setq index (insert-string (format-with-padding 
				      (integer-to-string (date-time-day date))
				      2 #\0 :right false)
				     0 null buffer index :PRESERVE))
	  (when (defined? (date-time-hour date))
	    (setq index (insert-string "T" 0 null buffer index :PRESERVE))
	    (setq index (insert-string (format-with-padding 
					(integer-to-string (date-time-hour date))
					2 #\0 :right false)
				       0 null buffer index :PRESERVE))
	    (when (defined? (date-time-minute date))
	      (setq index (insert-string ":" 0 null buffer index :PRESERVE))
	      (setq index (insert-string (format-with-padding 
					  (integer-to-string (date-time-minute date))
					  2 #\0 :right false)
					 0 null buffer index :PRESERVE))
	    (when (defined? (date-time-second date))
	      (setq index (insert-string ":" 0 null buffer index :PRESERVE))
	      (setq index (insert-string (format-with-padding 
					  (integer-to-string (date-time-second date))
					  2 #\0 :right false)
					 0 null buffer index :PRESERVE))))
	    (when (defined? (date-time-zone date))
	      (if (= (date-time-zone date) 0.0)
		  (setq index (insert-string "Z" 0 null buffer index :PRESERVE))
		  (setq index (insert-string (time-zone-format60 (date-time-zone date))
					     0 null buffer index :PRESERVE))))))))
    (return (subsequence buffer 0 index)) ))

(defmethod set-consistent-dow ((self DECODED-DATE-TIME))
  :public? FALSE
  (when (all-defined? (date-time-year  self)
		      (date-time-month self)
		      (date-time-day   self))
    (setf (date-time-dow self)
	  (compute-day-of-week (date-time-year  self)
			       (date-time-month self)
			       (date-time-day   self)))))		      

(defmethod help-merge-null-fields ((self DECODED-DATE-TIME) 
				   (default DECODED-DATE-TIME)
				   (index INTEGER))
  :public? FALSE
  ;; Helping function that only sets null fields with place
  ;; number <= `index'.
  ;;   Year: 0
  ;;  Month: 1
  ;;    Day: 2
  ;;   Hour: 3
  ;; Minute: 4
  ;; Second: 5
  ;; Millis: 6
  (when (and (null? (date-time-year self))
	     (>= index 0))
    (setf (date-time-year self) (date-time-year default)))
  (when (and (null? (date-time-month  self))
	     (>= index 1))
    (setf (date-time-month  self) (date-time-month  default)))
  (when (and (null? (date-time-day    self))
	     (>= index 2))
    (setf (date-time-day    self) (date-time-day    default)))
  (when (and (null? (date-time-hour   self))
	     (>= index 3))
    (setf (date-time-hour   self) (date-time-hour   default)))
  (when (and (null? (date-time-minute self))
	     (>= index 4))
    (setf (date-time-minute self) (date-time-minute default)))
  (when (and (null? (date-time-second self))
	     (>= index 5))
    (setf (date-time-second self) (date-time-second default)))
  (when (and (null? (date-time-millis self))
	     (>= index 6))
    (setf (date-time-millis self) (date-time-millis default)))
  ;; Always do these:
  (when (null? (date-time-zone   self))
    (setf (date-time-zone   self) (date-time-zone   default)))
  (set-consistent-dow self))

(defmethod merge-null-fields ((self DECODED-DATE-TIME) (default DECODED-DATE-TIME))
  :public? TRUE
  :documentation "Replace any null valued fields in `self' with values from `default'.
The day of the week will be set consistently, if possible."
  (help-merge-null-fields self default 6))
 

(defmethod merge-superior-null-fields ((self DECODED-DATE-TIME) (default DECODED-DATE-TIME))
  :public? TRUE
  :documentation "Replace only null valued fields in `self' that represent larger
time units than the smallest non-null in `self' with values from `default'.
The day of the week will be set consistently, if possible.
Example: if `self' just has the month being non-null, then only the year
will be filled in from `default'.  If the day and minute were non-null,
then hour, month and year will be filled.

This can be useful when one doesn't want to extend the precision
of the answer."

  (cond ((defined? (date-time-millis self))
	 (help-merge-null-fields self default 6))
	((defined? (date-time-second self))
	 (help-merge-null-fields self default 5))
	((defined? (date-time-minute self))
	 (help-merge-null-fields self default 4))
	((defined? (date-time-hour   self))
	 (help-merge-null-fields self default 3))
	((defined? (date-time-day    self))
	 (help-merge-null-fields self default 2))
	((defined? (date-time-month  self))
	 (help-merge-null-fields self default 1))
	(otherwise
	 (help-merge-null-fields self default 0))))

;;
;;  Decoded Time Duration
;;

(defclass decoded-time-duration (STANDARD-OBJECT)
  :public? TRUE
  :documentation "A data structure for holding decoded time duration values with
fields for easy access of the components.  Note that all non-zero values
should have the same sign."
  :public-slots
  ((duration-millis  :initially 0.0  :type float)    ; Value > -1000.0 and < 1000.0
   (duration-seconds :initially 0    :type integer)  ; Value between -59 and 59.
   (duration-minutes :initially 0    :type integer)	; Value between -59 and 59.
   (duration-hours   :initially 0    :type integer)	; Value between -23 and 23.
   (duration-days    :initially 0    :type integer)	; Any value.
  ))

(defmethod (hash-code INTEGER) ((self DECODED-TIME-DURATION))
  :public? TRUE :globally-inline? TRUE
  (return (logxor (duration-days self)
		  (logor (logor (shift-left (duration-hours self) 12)
				(shift-left (duration-minutes self) 6))
			 (duration-seconds self)))))

;;;;
;;;;  DATE-TIME objects
;;;;

(defclass date-time-object (QUANTITY)
  :abstract? TRUE)

(defclass calendar-date (date-time-object)
  :public? TRUE
  :documentation "Representation of Date and Time with the date represented
as a modified Julian day (starting at midnight instead of noon) and the
time as the offset in milliseconds from midnight, UTC"
  :public-slots
  ((modified-julian-day :type integer)
   (time-millis :type integer))
  :print-form (print-calendar-date self stream)
  )

(defmethod (coerce-to CALENDAR-DATE) ((x CALENDAR-DATE) (y OBJECT))
  (typecase y
    (CALENDAR-DATE
     (return y))
    (otherwise
     (signal INCOMPATIBLE-QUANTITY-EXCEPTION
             "Can't coerce " y " to a CALENDAR-DATE"))))

(defmethod (hash-code INTEGER) ((self CALENDAR-DATE))
  :public? TRUE :globally-inline? TRUE
  (return (logxor (modified-julian-day self) (time-millis self))))


(defmethod (calendar-date-to-date-string STRING) ((date CALENDAR-DATE) 
						  (timezone FLOAT)
						  (numeric-month? BOOLEAN))
  :public? TRUE
  :documentation "Returns the date part of the string representation of `date' 
adjusted for `timezone'.  Format is YYYY-MMM-DD, where MMM is a three letter
English abbreviation of the month if `numeric-month?' is `false' and a two
digit numeric value if `numeric-month?' is `true'.  The value `false' is
recommended."
  (mv-bind (year month day dow)
      (get-calendar-date date timezone)
    (ignore dow)
    (let ((year-string (choose (< year 0)
                               (concatenate (integer-to-string (- year)) "BC")
                               (integer-to-string year)))
          (month-string (choose numeric-month?
                                (format-with-padding (integer-to-string month)
				                     2 #\0 :right false)
                                (unwrap-string (nth *month-abbreviation-vector* month)))))
      (return (concatenate
		year-string
		"-"
		month-string
		"-"
		(format-with-padding (integer-to-string day)
				     2 #\0 :right false))) )))


(defmethod (calendar-date-to-time-string STRING) ((date CALENDAR-DATE) 
						  (timezone FLOAT)
						  (include-timezone? BOOLEAN)
						  (include-millis? BOOLEAN)
						  (pad-hours? BOOLEAN))
  :public? TRUE
  :documentation "Returns the time part of the string representation of `date'
adjusted for `timezone'.  The timezone is included in the string if
`include-timezone?' is `true'.  The value `true' is recommended.
Milliseconds will be included if `include-millis?' is `true'.
Hours will be zero-padded to length 2 if `pad-hours?' is `true'.
"
  (mv-bind (hours minutes seconds milli)
	   (get-time date timezone)
    (let ((timezone-string (choose include-timezone?
                                   (choose (= timezone 0.0)
                                           " UTC"
                                           (concatenate " " (float-to-string timezone)))
                                   ""))
          (milli-string (choose include-millis?
                                (concatenate "." (format-with-padding (integer-to-string milli)
                                                                      3 #\0 :right false))
                                "")))
      (return (concatenate
               (choose pad-hours?
                       (format-with-padding (integer-to-string hours)
                                            2 #\0 :right false)
                       (integer-to-string hours))
               ":"
               (format-with-padding (integer-to-string minutes)
                                    2 #\0 :right false)
               ":"
               (format-with-padding (integer-to-string seconds)
                                    2 #\0 :right false)
               milli-string
               timezone-string)) )))

(defmethod (calendar-date-to-string STRING) ((date CALENDAR-DATE) 
					     (timezone FLOAT)
					     (numeric-month? BOOLEAN)
					     (include-timezone? BOOLEAN))
  :public? TRUE
  :documentation "Returns a string representation of `date' adjusted for `timezone'.
The Format is YYYY-MMM-DD hh:mm:ss z.z, where MMM is a three letter
English abbreviation of the month if `numeric-month?' is `false' and a two
digit numeric value if `numeric-month?' is `true'.  The timezone as a
float offset z.z is included if `include-timezone?' is `true'.

Recommended values for the flags are `false' and `true' respectively."
  (return (concatenate (calendar-date-to-date-string date timezone numeric-month?)
                       " "
                       (calendar-date-to-time-string date timezone include-timezone? TRUE FALSE))))

(defmethod (calendar-date-to-iso8601-string STRING) ((date CALENDAR-DATE) 
						     (timezone FLOAT)
						     (include-timezone? BOOLEAN))
  :public? TRUE
  :documentation "Returns an ISO-8601 string representation of `date' adjusted for `timezone'.
The Format is YYYY-MM-DDThh:mm:ss z:zz.  The timezone as an offset
hh:mm is included if `include-timezone?' is `true'.

Recommended values for the flag is `true'."
  (let ((tz-string ""))
    (when include-timezone?
      (if (= timezone 0.0)
        (setq tz-string "Z")
	(setq tz-string (time-zone-format60 timezone))))
    (return (concatenate (calendar-date-to-date-string date timezone TRUE)
                         "T"
                         (calendar-date-to-time-string date timezone FALSE FALSE TRUE)
                         tz-string))))

(defmethod (calendar-date-to-native-date-time NATIVE-DATE-TIME) ((date CALENDAR-DATE))
  ;; (a) MJD 15021 is January 1, 1900
  ;; (b) MJD 40588 is January 1, 1970
  ;; Common Lisp Universal Time is seconds since (a)
  ;; Java Time is milliseconds since (b)
  ;; C time is seconds since (b)
  (let ((mjd (modified-julian-day date))
	(millis (time-millis date)))
    (return
      (verbatim 
	  :common-lisp "(CL:+ (CL:* (CL:- mjd 15021) 86400) (CL:TRUNCATE millis 1000))"
	  :java "(((long)mjd - 40588L) * 86400000L) + (long)millis"
	  :cpp "(((time_t)mjd - 40588) * 86400) + ((time_t)millis / 1000)"))))
  
(defun (native-date-time-to-calendar-date CALENDAR-DATE) ((date NATIVE-DATE-TIME))
  :constructor? TRUE
  ;; (a) MJD 15021 is January 1, 1900
  ;; (b) MJD 40588 is January 1, 1970
  ;; Common Lisp Universal Time is seconds since (a)
  ;; Java Time is milliseconds since (b)
  ;; C time is seconds since (b)
  (let ((mjd 0)
	(millis 0))
    (verbatim 
	:common-lisp "
    (CL:PROGN
      (CL:MULTIPLE-VALUE-SETQ (mjd millis) (CL:TRUNCATE date 86400))
      (CL:INCF mjd 15021)
      (CL:SETQ millis (CL:* millis 1000)))
"
	:java "mjd = (int) ((date / 86400000) + 40588);
      millis = (int) (date % 86400000)"
	:cpp "mjd =  (int) ((date / 86400) + 40588);
      millis = (int) ((date % 86400) * 1000)")
    (return (make-calendar-date mjd millis))))

(defmethod print-calendar-date ((date CALENDAR-DATE) (stream NATIVE-OUTPUT-STREAM))
  (if *printreadably?*
      (print-native-stream stream "\"")
      (print-native-stream stream "<" (modified-julian-day date) " "))
  (print-native-stream stream (calendar-date-to-string date 0.0 FALSE FALSE))
  (if *printreadably?*
      (print-native-stream stream " UTC\"")
      (print-native-stream stream " UTC>")) )

(defclass time-duration (date-time-object)
  :public? TRUE
  :documentation "Representation of Relative Days and Time with the date represented
as a number of days and the time in milliseconds."
  :public-slots
  ((days :type integer)
   (millis :type integer))
  :print-form (print-time-duration self stream))

(defmethod (coerce-to TIME-DURATION) ((x TIME-DURATION) (y OBJECT))
  (typecase y
    (TIME-DURATION
     (return y))
    (otherwise
     (signal INCOMPATIBLE-QUANTITY-EXCEPTION
             "Can't coerce " y " to a TIME-DURATION"))))

(defmethod (hash-code INTEGER) ((self TIME-DURATION))
  :public? TRUE :globally-inline? TRUE
  (return (logxor (days self) (millis self))))

(defmethod (time-duration-to-string STRING) ((date TIME-DURATION))
  :public? TRUE
  :documentation "Returns a string representation of `date'"
  ;; NOTE: This can be simplified if we are sure that relative dates are
  ;;       always normalized.
  (let ((n-days (days date))
	(n-millis (millis date)))
    (if (< n-days 0)
      (if (<= n-millis 0)
	(return
	  (concatenate "minus " 
		       (integer-to-string (- n-days)) " days; "
		       (integer-to-string (- n-millis)) " ms"))
	(return
	  (concatenate "minus " 
		       (integer-to-string (- (+ n-days 1))) " days; "
		       (integer-to-string (- MILLIS-PER-DAY n-millis)) " ms")))
      (if (< n-millis 0)
	(if (> n-days 0)
	  (return
	    (concatenate "plus "
			 (integer-to-string (- n-days 1)) " days; "
			 (integer-to-string (+ MILLIS-PER-DAY n-millis)) " ms"))
	  (return
	    (concatenate "minus 0 days; "
			 (integer-to-string (- n-millis)) " ms")))
	(return
	  (concatenate "plus " 
		       (integer-to-string n-days) " days; "
		       (integer-to-string n-millis) " ms"))))))


(defun (string-to-time-duration TIME-DURATION) ((duration STRING))
  :public? TRUE
  :constructor? TRUE
  :documentation "Parses and returns an time-duration object corresponding to `duration'.
The syntax for time duration strings is \"{plus|minus} N days[; M ms]\" where N and M are
integer values for days and milliseconds.  If no valid parse is found, `null' is returned."
  ;; NOTE: This can be simplified if we are sure that relative dates are
  ;;       always normalized.
  (let ((n-days 0)
        (n-millis 0)
        (negative? (defined? (string-search duration "minus" 0)))
        (day-start-position 0)
        (day-end-position 0)
        (ms-start-position 0)
        (ms-end-position 0))
    (cond (negative?
	 (setq day-start-position 6))
	((defined? (string-search duration "plus" 0))
	 (setq day-start-position 5))
	(otherwise
	 (setq day-start-position 0)))
    (setq day-end-position (string-search duration "days" day-start-position))
    (if (null? day-end-position)
        (return null)
      (setq n-days (string-to-integer (subsequence duration 
					 day-start-position
					 (- day-end-position 1)))))
    (setq ms-start-position (position duration #\Space day-end-position))
    (when (defined? ms-start-position)  ;; ms entry is optional.
      (setq ms-end-position (string-search duration "ms" ms-start-position))
      (when (defined? ms-end-position)
        (setq n-millis (string-to-integer (subsequence duration 
					     ms-start-position
					     (- ms-end-position 1))))))
    (if negative?
      (return (make-time-duration (- n-days) (- n-millis)))
      (return (make-time-duration n-days n-millis)))))


(defmethod print-time-duration ((date TIME-DURATION) (stream NATIVE-OUTPUT-STREAM))
  (print-native-stream stream "<" (time-duration-to-string date) ">"))


(defun (make-date-time CALENDAR-DATE) ((year INTEGER) (month INTEGER) (day INTEGER)
				       (hour INTEGER) (minute INTEGER) (second INTEGER)
				       (millis INTEGER) (timezone FLOAT))
  :public? TRUE
  :constructor? TRUE
  :documentation "Create a calendar date with the specified components.  `year' must be
the complete year (i.e., a year of 98 is 98 A.D in the 1st century).
`timezone' is a real number in the range -12.0 to +14.0 where UTC is zone 0.0;  The number
is the number of hours to add to UTC to arrive at local time."
  (let ((time INTEGER (+ (* hour MILLIS-PER-HOUR)
			 (* minute 60000)
			 (* second  1000)
			 millis)))
    (setq time (- time (* timezone MILLIS-PER-HOUR)))
    (return (make-calendar-date (julian-day-to-modified-julian-day
				 (compute-julian-day year month day))
				time)) ))

(defun (make-current-date-time CALENDAR-DATE) ()
  :public? TRUE
  :constructor? TRUE
  :documentation "Create a calendar date with current time and date."
  (mv-bind (year month day dow hour minute second millisecond)
      (get-current-date-time)
    (ignore dow)
    (return 
      (make-date-time year month day hour minute second millisecond 0.0)) ))

(defun (make-calendar-date CALENDAR-DATE) ((day INTEGER) (time INTEGER))
  :constructor? TRUE
  (while (< time 0)
    (++ time MILLIS-PER-DAY)
    (-- day))
  (while (> time MILLIS-PER-DAY)
    (-- time MILLIS-PER-DAY)
    (++ day))
  (return (new CALENDAR-DATE :modified-julian-day day :time-millis time)))

(defun (make-time-duration TIME-DURATION) ((days INTEGER) (millis INTEGER))
  :constructor? TRUE
  (while (< millis (- MILLIS-PER-DAY))
    (++ millis MILLIS-PER-DAY)
    (-- days))
  (while (> millis MILLIS-PER-DAY)
    (-- millis MILLIS-PER-DAY)
    (++ days))
  (cond ((< days 0)
	 (unless (<= millis 0)
	   (++ days)
	   (-- millis MILLIS-PER-DAY)))
	((> days 0)
	 (unless (>= millis 0)
	   (-- days)
	   (++ millis MILLIS-PER-DAY)))
	(otherwise NULL))
  (return (new TIME-DURATION :days days :millis millis)))

(defun (decode-time-in-millis INTEGER INTEGER INTEGER INTEGER) ((time INTEGER))
  :public? TRUE
  :documentation "Returns multiple values of hours, minutes, seconds, milliseconds for
`time' specified in milliseconds."
  (let ((millis (rem time 1000))
	(secs (rem (div time 1000) 60))
	(mins (rem (div time 60000) 60))
	(hours (div time MILLIS-PER-HOUR)))
    (return (values hours mins secs millis)) ))

(defmethod (get-calendar-date INTEGER INTEGER INTEGER KEYWORD) 
    ((date CALENDAR-DATE) (timezone FLOAT))
  :public? TRUE
  :documentation "Returns multiple values of year, month, day and day of week for `date'
in `timezone'.  `timezone' is the number of hours added to UTC to get local time.  It
is in the range -12.0 to +14.0 where UTC is zone 0.0"
  (when (null? timezone)
    (warn "Timezone not specified in GET-CALENDAR-DATE  Using local zone.")
    (mv-bind (year month day dow)
	(compute-calendar-date 
	 (modified-julian-day-to-julian-day (modified-julian-day date)))
      (ignore dow)
      (setq timezone (get-local-time-zone-for-date year month day 12 0 0))))
  (let ((time (time-millis date))
	(timezone-adjusted-time INTEGER (+ time (* timezone MILLIS-PER-HOUR)))
	(day-offset 0))
    (cond ((< timezone-adjusted-time 0)
	   (setq day-offset -1))
	  ((> timezone-adjusted-time MILLIS-PER-DAY)
	   (setq day-offset 1))
	  (otherwise NULL))
    (return (compute-calendar-date (modified-julian-day-to-julian-day
				    (+ (modified-julian-day date) day-offset))))))

(defmethod (get-time INTEGER INTEGER INTEGER INTEGER)
    ((date CALENDAR-DATE) (timezone FLOAT))
  :public? TRUE
  :documentation "Returns multiple values of hours, minutes, seconds, milliseconds for
the calendar date `date' in `timezone'.  `timezone' is the number of hours added to UTC
to get local time.  It is in the range -12.0 to +14.0 where UTC is zone 0.0"
  (when (null? timezone)
    (warn "Timezone not specified in GET-TIME.  Using local zone.")
    (mv-bind (year month day dow)
	(compute-calendar-date 
	 (modified-julian-day-to-julian-day (modified-julian-day date)))
      (ignore dow)
      (setq timezone (get-local-time-zone-for-date year month day 12 0 0))))
  (cond ((= timezone 0.0)
	 (return (decode-time-in-millis (time-millis date))))
	((< timezone 0.0)
	 (return (decode-time-in-millis 
		  (rem (+ (time-millis date) MILLIS-PER-DAY (* timezone MILLIS-PER-HOUR))
		       MILLIS-PER-DAY))))
	(otherwise
	 (return (decode-time-in-millis 
		  (rem (+ (time-millis date) (* timezone MILLIS-PER-HOUR))
		       MILLIS-PER-DAY))))) )


(defmethod (decode-calendar-date DECODED-DATE-TIME)
    ((date CALENDAR-DATE) (timezone FLOAT))
  :public? TRUE
  :documentation "Returns a decoded time object for `date' interpreted in `timezone'
`timezone' is the number of hours added to UTC to get local time.  It is 
in the range -12.0 to +14.0 where UTC is zone 0.0"
  (mv-bind (hour min sec millis)
      (get-time date timezone)
    (mv-bind (year month day dow)
	(get-calendar-date date timezone)
      (return (new DECODED-DATE-TIME
		   :date-time-millis millis
		   :date-time-second sec
		   :date-time-minute min
		   :date-time-hour   hour
		   :date-time-day    day
		   :date-time-month  month
		   :date-time-year   year
		   :date-time-zone   timezone
		   :date-time-dow    dow)) )))

(defconstant *DEFAULT-DECODED-DATE-TIME* DECODED-DATE-TIME (NEW DECODED-DATE-TIME))
(defconstant *NULL-DECODED-DATE-TIME* DECODED-DATE-TIME (new DECODED-DATE-TIME
                                                             :date-time-millis null
                                                             :date-time-second null
                                                             :date-time-minute null
                                                             :date-time-hour null
                                                             :date-time-day null
                                                             :date-time-month null
                                                             :date-time-year null
                                                             :date-time-zone null
                                                             :date-time-dow null))

(defmethod (encode-calendar-date CALENDAR-DATE) ((time-structure DECODED-DATE-TIME))
  :public? TRUE
  :documentation "Returns a calendar date object for `time-structure'."
  (return (make-date-time 
           (choose (defined? (date-time-year   time-structure))
                   (date-time-year   time-structure)
                   (date-time-year   *DEFAULT-DECODED-DATE-TIME*))
           (choose (defined? (date-time-month  time-structure))
                   (date-time-month  time-structure)
                   (date-time-month  *DEFAULT-DECODED-DATE-TIME*))
           (choose (defined? (date-time-day    time-structure))
                   (date-time-day    time-structure)
                   (date-time-day    *DEFAULT-DECODED-DATE-TIME*))
           (choose (defined? (date-time-hour   time-structure))
                   (date-time-hour   time-structure)
                   (date-time-hour   *DEFAULT-DECODED-DATE-TIME*))
           (choose (defined? (date-time-minute time-structure))
                   (date-time-minute time-structure)
                   (date-time-minute *DEFAULT-DECODED-DATE-TIME*))
           (choose (defined? (date-time-second time-structure))
                   (date-time-second time-structure)
                   (date-time-second *DEFAULT-DECODED-DATE-TIME*))
           (choose (defined? (date-time-millis time-structure))
                   (round (date-time-millis time-structure))
                   (round (date-time-millis *DEFAULT-DECODED-DATE-TIME*)))
           (choose (defined? (date-time-zone   time-structure))
                   (date-time-zone   time-structure)
                   (date-time-zone   *DEFAULT-DECODED-DATE-TIME*)))))

(defmethod (decode-time-duration DECODED-TIME-DURATION) ((duration TIME-DURATION))
  (if (> (millis duration) 0)
    (return (new DECODED-TIME-DURATION
		 :duration-days (days duration)
		 :duration-hours (div (millis duration) MILLIS-PER-HOUR)
		 :duration-minutes (div (rem (millis duration) MILLIS-PER-HOUR) 60000)
		 :duration-seconds (div (rem (millis duration) 60000) 1000)
		 :duration-millis (rem (millis duration) 1000)))
    (return (new DECODED-TIME-DURATION
		 :duration-days (days duration)
		 :duration-hours (- (div (- (millis duration)) MILLIS-PER-HOUR))
		 :duration-minutes (- (div (rem (- (millis duration)) MILLIS-PER-HOUR) 60000))
		 :duration-seconds (-  (div (rem (- (millis duration)) 60000) 1000))
		 :duration-millis (- (rem (- (millis duration)) 1000))))))

(defmethod (encode-time-duration TIME-DURATION) ((time-structure DECODED-TIME-DURATION))
  (return 
    (make-time-duration (duration-days time-structure)
			(+ (* (duration-hours time-structure) MILLIS-PER-HOUR)
			   (* (duration-minutes time-structure) 60000)
			   (* (duration-seconds time-structure) 1000)
			   (duration-millis time-structure)))))

;;;
;;;  Time Arithmetic and Comparisons
;;;

(defun (time-add DATE-TIME-OBJECT) ((t1 DATE-TIME-OBJECT) (t2 DATE-TIME-OBJECT))
  :public? TRUE
  :documentation "Add `t1' to `t2'.
If one of `t1' or `t2' is a calendar date, then the result is a calendar date.
If both `t1' and `t2' are relative dates, then the result is a relative date.
`t1' and `t2' cannot both be calendar dates."
  (typecase t1
    (CALENDAR-DATE
     (typecase t2
       (CALENDAR-DATE
	(error "You can't add two calendar dates: " t1 "  " t2))
       (TIME-DURATION
	(return (make-calendar-date (+ (modified-julian-day t1) (days t2))
				    (+ (time-millis t1) (millis t2)))))))
    (TIME-DURATION
     (typecase t2
       (CALENDAR-DATE
	(return (make-calendar-date (+ (days t1) (modified-julian-day t2))
				    (+ (millis t1) (time-millis t2)))))
       (TIME-DURATION
	(return (make-time-duration (+ (days t1) (days t2))
				    (+ (millis t1) (millis t2)))))))))

(defun (time-subtract DATE-TIME-OBJECT) ((t1 DATE-TIME-OBJECT) (t2 DATE-TIME-OBJECT))
  :public? TRUE
  :documentation "Subtract `t2' from `t1'.  If `t1' is a calendar date, then `t2' can
be either a calendar date (in which case the return value is a relative date) or it
can be a relative date (in which case the return value is a calendar date).  If `t1'
is a relative date, then `t2' must also be a relative date and a relative date is returned."
  (typecase t1
    (CALENDAR-DATE
     (typecase t2
       (CALENDAR-DATE
	(return (make-time-duration (- (modified-julian-day t1) (modified-julian-day t2))
				    (- (time-millis t1) (time-millis t2)))))
       (TIME-DURATION
	(return (make-calendar-date (- (modified-julian-day t1) (days t2))
				    (- (time-millis t1) (millis t2)))))))
    (TIME-DURATION
     (typecase t2
       (CALENDAR-DATE
	(error "You can't subtract a calendar date from a relative date: " t1 "  " t2))
       (TIME-DURATION
	(return (make-time-duration (- (days t1) (days t2))
				    (- (millis t1) (millis t2)))))))))

(defun (time-multiply TIME-DURATION) ((t1 OBJECT) (t2 OBJECT))
  :public? TRUE
  :documentation "Multiplies a relative date by a wrapped number.  One of `t1' or `t2'
must be a relative date and the other a wrapped number."
  (typecase t1
    (CALENDAR-DATE
     (error "Calendar dates cannot be involved in multiplication:  " t1 "  " t2))
    (TIME-DURATION
     (typecase t2
       (CALENDAR-DATE
	(error "Calendar dates cannot be involved in multiplication:  " t1 "  " t2))
       (TIME-DURATION
	(error "You can't multiply two relative dates: " t1 "  " t2))
       (INTEGER-WRAPPER
	(return (make-time-duration (* (days t1) (wrapper-value t2))
				    (* (millis t1) (wrapper-value t2)))))
       (FLOAT-WRAPPER
	(return (make-time-duration (round (* (days t1) (wrapper-value t2)))
				    (round (* (millis t1) (wrapper-value t2))))))))
    (INTEGER-WRAPPER
     (typecase t2
       (CALENDAR-DATE
	(error "Calendar dates cannot be involved in multiplication:  " t1 "  " t2))
       (TIME-DURATION
	(return (make-time-duration (* (wrapper-value t1) (days t2))
				    (* (wrapper-value t1) (millis t2)))))
       (NUMBER-WRAPPER
	(error "One argument must be a relative date:  " t1 "  " t2))))
    (FLOAT-WRAPPER
     (typecase t2
       (CALENDAR-DATE
	(error "Calendar dates cannot be involved in multiplication:  " t1 "  " t2))
       (TIME-DURATION
	(return (make-time-duration (round (* (wrapper-value t1) (days t2)))
				    (round (* (wrapper-value t1) (millis t2))))))
       (NUMBER-WRAPPER
	(error "One argument must be a relative date:  " t1 "  " t2))))))

(defun (time-divide OBJECT) ((t1 TIME-DURATION) (t2 OBJECT))
  :public? TRUE
  :documentation "Divides the relative date `t1' by `t2'.  `t2' must be
either a relative date or a wrapped number.  If `t2' is a relative date,
then the return value will be a wrapped float.  If `t2' is a wrapped number,
then the reutrn value will be a relative date."
  (typecase t2
    (CALENDAR-DATE
     (error "Calendar dates cannot be involved in division:  " t1 "  " t2))
    (TIME-DURATION
     (return (wrap-literal (/ (+ (days t1) (/ (millis t1) MILLIS-PER-DAY))
			      (+ (days t2) (/ (millis t2) MILLIS-PER-DAY))))))
    (INTEGER-WRAPPER
     (return (make-time-duration (round (/ (days t1) (wrapper-value t2)))
				 (round (/ (millis t1) (wrapper-value t2))))))
    (FLOAT-WRAPPER
     (return (make-time-duration (round (/ (days t1) (wrapper-value t2)))
				 (round (/ (millis t1) (wrapper-value t2))))))))

(defmacro define-time-comparison ((name SYMBOL) (operator SYMBOL) (error? SYMBOL))
  :public? FALSE
  (let ((otherwise-clause
         (choose (eql? error? (quote TRUE))
                 (bquote (signal INCOMPATIBLE-QUANTITY-EXCEPTION
                                 "Can't compare calendar date " t1 " with object " t2))
                 (bquote (return FALSE)))))
    (return
     (bquote
      (progn 
        (defmethod (& name BOOLEAN) ((t1 CALENDAR-DATE) (t2 OBJECT))
          (typecase t2
            (CALENDAR-DATE
             (if (= (modified-julian-day t1) (modified-julian-day t2))
               (return (& operator (time-millis t1) (time-millis t2)))
               (return (& operator (modified-julian-day t1) (modified-julian-day t2)))))
            (otherwise
             & (copy-cons-list otherwise-clause))))
        (defmethod (& name BOOLEAN) ((t1 TIME-DURATION) (t2 OBJECT))
          (typecase t2
            (TIME-DURATION
             (if (= (days t1) (days t2))
	          (return (& operator (millis t1) (millis t2)))
	          (return (& operator (days t1) (days t2)))))
            (otherwise
             & (copy-cons-list otherwise-clause)))))))))

(define-time-comparison object-eql? = FALSE)
(define-time-comparison less? < TRUE)
(define-time-comparison greater? > TRUE)
(define-time-comparison less-equal? <= TRUE)
(define-time-comparison greater-equal? >= TRUE)


;;;
;;;  Random Time Utility Functions
;;;


  ;;
;;;;;; with-date-substitution
  ;;

(defun fill-in-date-substitution ((substitution-list (KEY-VALUE-LIST OF STRING-WRAPPER STRING-WRAPPER)))
  :documentation "Fill in `substitution-list' with template variable substitions
for the names YEAR and DATE which correspond to the current year and date.
These substitutions can then be used with `substitute-template-variables-in-string'"
  :public? TRUE
  (mv-bind (year month day dow)
      (get-calendar-date (make-current-date-time) (get-local-time-zone))
    (ignore dow)
    (insert-at substitution-list "YEAR" (integer-to-string year))
    (insert-at substitution-list "DATE" 
	       (concatenate (format-with-padding (integer-to-string day)
						 2 #\0 :right false)
			    "-"
			    (nth *month-abbreviation-vector* month)
			    "-"
			    (integer-to-string year))) ))
