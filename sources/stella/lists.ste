;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;; BEGIN LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
; Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          ;
;                                                                            ;
; The contents of this file are subject to the Mozilla Public License        ;
; Version 1.1 (the "License"); you may not use this file except in           ;
; compliance with the License. You may obtain a copy of the License at       ;
; http://www.mozilla.org/MPL/                                                ;
;                                                                            ;
; Software distributed under the License is distributed on an "AS IS" basis, ;
; WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   ;
; for the specific language governing rights and limitations under the       ;
; License.                                                                   ;
;                                                                            ;
; The Original Code is the STELLA Programming Language.                      ;
;                                                                            ;
; The Initial Developer of the Original Code is                              ;
; UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          ;
; 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               ;
;                                                                            ;
; Portions created by the Initial Developer are Copyright (C) 1996-2006      ;
; the Initial Developer. All Rights Reserved.                                ;
;                                                                            ;
; Contributor(s):                                                            ;
;                                                                            ;
; Alternatively, the contents of this file may be used under the terms of    ;
; either the GNU General Public License Version 2 or later (the "GPL"), or   ;
; the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   ;
; in which case the provisions of the GPL or the LGPL are applicable instead ;
; of those above. If you wish to allow use of your version of this file only ;
; under the terms of either the GPL or the LGPL, and not to allow others to  ;
; use your version of this file under the terms of the MPL, indicate your    ;
; decision by deleting the provisions above and replace them with the notice ;
; and other provisions required by the GPL or the LGPL. If you do not delete ;
; the provisions above, a recipient may use your version of this file under  ;
; the terms of any one of the MPL, the GPL or the LGPL.                      ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; END LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; Version: lists.ste,v 1.82 2006/05/11 07:06:12 hans Exp

;;; Procedures that implement lists and assoc lists.

(in-package "STELLA")

(in-module "/STELLA")


  ;;
;;;;;; Lists
  ;;

;;; Hand-build the empty list:
(defglobal NIL-LIST LIST NULL :public? TRUE)
(startup-time-progn :early-inits
  (unless (defined? NIL-LIST)
    (setq NIL-LIST (make LIST)))
  (setf (the-cons-list NIL-LIST) NIL))

;; We used to have special versions of 'defined?' and 'null?' that worked
;; on LISTs, but they conflicted with the overall 'defined?/null?' strategy.
;; These two functions can be used instead:

(defun (defined-list? BOOLEAN) ((self LIST))
  :public? TRUE
  :documentation "Return TRUE unless `self' is NULL or the `NIL-LIST'."
  (return (and (not (eq? self NIL-LIST))
               (defined? self))))

(defun (null-list? BOOLEAN) ((self LIST))
  :public? TRUE
  :documentation "Return TRUE iff `self' is NULL or the `NIL-LIST'."
  (return (or (eq? self NIL-LIST)
              (null? self))))

(defmethod (empty? BOOLEAN) ((self LIST))
  :public? TRUE
  :documentation "Return TRUE if the list `self' has no members."
   (return (empty? (the-cons-list self))) )

(defmethod (non-empty? BOOLEAN) ((self LIST))
  :public? TRUE
  :documentation "Return TRUE if the list `self' has at least one member."
   (return (non-empty? (the-cons-list self))) )

(defun (terminate-list? BOOLEAN) ((self LIST))
  ;; Terminate `self' by freeing all its CONSes.
  (when (eq? self NIL-LIST)
    (safety 1 (not (eq? self NIL-LIST)) "Attempt to free NIL-LIST.")
    (return FALSE))
  (let ((cons (the-cons-list self))
        (rest (CONS OF OBJECT) NULL))
    (while (non-empty? cons)
      (setq rest (rest cons))
      (free cons)
      (setq cons rest))
    (setf (the-cons-list self) NIL)
    (return TRUE)))

(defmethod (member? BOOLEAN) ((self LIST) (object OBJECT))
  :documentation "Return TRUE iff `object' is a member of the list
`self' (uses an `eql?' test)."
  :public? TRUE
  (foreach i in (the-cons-list self)
           where (eql? i object)
           do (return TRUE))
  (return FALSE) )

(defmethod (memb? BOOLEAN) ((self LIST) (object (LIKE (any-value self))))
  :documentation "Return TRUE iff `object' is a member of the cons list
`self' (uses an 'eq?' test)."
  :public? TRUE
  (foreach i in (the-cons-list self)
           where (eq? i object)
           do (return TRUE))
  (return FALSE) )

(defmethod (first (LIKE (any-value self))) ((self LIST))
  :documentation "Return the first item in the list `self', or NULL if empty."
  :public? TRUE
  (let ((cons (the-cons-list self)))
    (return (choose (non-empty? cons) (value cons) NULL)) ))

(defmethod (second (LIKE (any-value self))) ((self LIST))
  :documentation "Return the second item in the list `self', or NULL if empty."
  :public? TRUE
  (return (second (the-cons-list self))) )

(defmethod (third (LIKE (any-value self))) ((self LIST))
  :documentation "Return the third item in the list `self', or NULL if empty."
  :public? TRUE
  (return (third (the-cons-list self))) )

(defmethod (fourth (LIKE (any-value self))) ((self LIST))
  :documentation "Return the fourth item in the list `self', or NULL if empty."
  :public? TRUE
  (return (fourth (the-cons-list self))) )

(defmethod (fifth (LIKE (any-value self))) ((self LIST))
  :documentation "Return the fifth item in the list `self', or NULL if empty."
  :public? TRUE
  (return (fifth (the-cons-list self))) )

(defmethod (nth (LIKE (any-value self))) ((self LIST) (position INTEGER))
  :documentation "Return the nth item in the list `self', or NULL if empty."
  :public? TRUE
  (return (nth (the-cons-list self) position)) )

(defmethod (last (LIKE (any-value self))) ((self LIST))
  :documentation "Return the last element of `self'."
  :public? TRUE
  (return (last (the-cons-list self))))

(defmethod (rest (CONS OF (LIKE (any-value self)))) ((self LIST))
  :documentation "Return a cons list of all but the first item in the list `self'."
  :public? TRUE
  (return (rest (the-cons-list self))) )

(defmethod (first-setter (LIKE (any-value self)))
    ((self LIST) (value (LIKE (any-value self))))
  :public? TRUE
  (return (setf (first (the-cons-list self)) value)))

(defmethod (second-setter (LIKE (any-value self)))
    ((self LIST) (value (LIKE (any-value self))))
  :public? TRUE
  (return (setf (second (the-cons-list self)) value)))

(defmethod (third-setter (LIKE (any-value self)))
    ((self LIST) (value (LIKE (any-value self))))
  :public? TRUE
  (return (setf (third (the-cons-list self)) value)))

(defmethod (fourth-setter (LIKE (any-value self)))
    ((self LIST) (value (LIKE (any-value self))))
  :public? TRUE
  (return (setf (fourth (the-cons-list self)) value)))

(defmethod (fifth-setter (LIKE (any-value self)))
    ((self LIST) (value (LIKE (any-value self))))
  :public? TRUE
  (return (setf (fifth (the-cons-list self)) value)))

(defmethod (nth-setter (LIKE (any-value self)))
    ((self LIST) (value (LIKE (any-value self))) (position INTEGER))
  :public? TRUE
  (return (setf (nth (the-cons-list self) position) value)))

(defmethod (length INTEGER) ((self LIST))
  :public? TRUE
  (inline length)
  (return (length (the-cons-list self))) )

(defmethod (position INTEGER) ((self LIST) (object OBJECT) (start INTEGER))
  :documentation "Return the position of `object' within the list
`self' (counting from zero); or return NULL if `object' does not occur within 
`self' (uses an `eql?' test).  If `start' was supplied as non-NULL, only 
consider the sublist starting at `start', however, the returned position 
will always be relative to the entire list."
  :public? TRUE
  (return (position (the-cons-list self) object start)))

(defmethod (last-position INTEGER) ((self LIST) (object OBJECT) (end INTEGER))
  :documentation "Return the position of `object' within the list
`self' (counting from zero); or return NULL if `object' does not occur within 
`self' (uses an `eql?' test).  If `end' was supplied as non-NULL, only 
consider the sublist ending at `end', however, the returned position 
will always be relative to the entire list."
  :public? TRUE
  (return (last-position (the-cons-list self) object end)))

(defmethod insert ((self LIST) (value (LIKE (any-value self))))
  :documentation "Add `value' to the front of the list `self'."
  :public? TRUE
  (safety 1 (not (eq? self NIL-LIST)) "Attempt to insert into NIL-LIST.")
  (setf (the-cons-list self) (cons value (the-cons-list self))) )

(defmethod push ((self LIST) (value (LIKE (any-value self))))
  :documentation "Add `value' to the front of the list `self'."
  :public? TRUE
  (safety 1 (not (eq? self NIL-LIST)) "Attempt to insert into NIL-LIST.")
  (setf (the-cons-list self) (cons value (the-cons-list self))) )

(defmethod insert-new ((self LIST) (value (LIKE (any-value self))))
  :documentation "Add `value' to the front of the list `self' unless its 
already a member."
  :public? TRUE
  (safety 1 (not (eq? self NIL-LIST)) "Attempt to insert into NIL-LIST.")
  (when (not (member? (the-cons-list self) value))
    (setf (the-cons-list self) 
          (cons value (the-cons-list self)))) )

(defmethod insert-last ((self LIST) (value (LIKE (any-value self))))
  :documentation "Insert `value' as the last entry in the list `self'."
  :public? TRUE
  (safety 1 (not (eq? self NIL-LIST)) "Attempt to insert into NIL-LIST.")
  (let ((cursor (the-cons-list self))
        (lastCons (cons value NIL)))
    (if (empty? cursor)
      (setf (the-cons-list self) lastCons)
      (add-cons-to-end-of-cons-list cursor lastCons))))

(defmethod (remove (LIKE self)) ((self LIST) (value (LIKE (any-value self))))
  :documentation
  "Destructively remove all entries in `self' that match `value'."
  :public? TRUE
  (setf (the-cons-list self)
        (remove (the-cons-list self) value))
  (return self) )

(defmethod (remove-if (LIKE self)) ((self LIST) (test? FUNCTION-CODE))
  :documentation "Destructively remove all members of the list `self' for which
'test?' evaluates to TRUE.  `test' takes a single argument of type OBJECT and
returns TRUE or FALSE.  Returns `self'."
  :public? TRUE
  (setf (the-cons-list self) (remove-if (the-cons-list self) test?))
  (return self))

(defmethod (remove-duplicates (LIKE self)) ((self LIST))
  :documentation
  "Destructively remove duplicates from `self' and return the result.
Preserves the original order of the remaining members."
   :public? TRUE
   (when (non-empty? (the-cons-list self))
     (setf (the-cons-list self) (remove-duplicates (the-cons-list self))))
   (return self) )

(defmethod (pop (LIKE (any-value self))) ((self LIST))
  :documentation "Remove and return the first element in the list `self'.
Return NULL if the list is empty."
  :public? TRUE
  (let ((cons (the-cons-list self))
        (value OBJECT NULL))
    (when (empty? cons)
      (return NULL))
    (setq value (value cons))
    (setf (the-cons-list self) (rest cons))
    (return value) ))

(defmethod (reverse (LIKE self)) ((self LIST))
  :documentation "Reverse the members of `self' (in place)."
  :public? TRUE
  (setf (the-cons-list self) (reverse (the-cons-list self)))
  (return self) )

(defmethod (substitute (LIKE self))
    ((self LIST) (inValue OBJECT) (outValue OBJECT))
  :documentation "Destructively replace each appearance of `outValue' by
`inValue' in the list `self'."
  (setf (the-cons-list self)
    (substitute (the-cons-list self) inValue outValue))
  (return self))

(defmethod (concatenate LIST)
    ((list1 LIST) (list2 LIST) &rest (otherLists LIST))
  :documentation "Copy `list2' and all `otherLists' onto the end of `list1'.
The operation is destructive wrt `list1', but leaves all other lists intact.
The two mandatory parameters allow us to optimize the common binary case by
not relying on the somewhat less efficient variable arguments mechanism."
  :public? TRUE
  (let ((firstList (the-cons-list list1))
        (lastList (the-cons-list list2))
        (copy NIL))
    (cond ((empty? firstList)
           (setq firstList (copy-cons-list lastList))
           (setq lastList firstList))
          ((empty? lastList)
           (setq lastList firstList))
          (otherwise
           (setq lastList (copy-cons-list lastList))
           (setf (rest (last-cons firstList)) lastList)))
    (when (> (length otherLists) 0)
      (foreach list in otherLists
          where (non-empty? list)
          do (setq copy (copy-cons-list (the-cons-list list)))
             (if (non-empty? lastList)
                 (setf (rest (last-cons lastList)) copy)
               (setq firstList copy))
             (setq lastList copy)))
    (setf (the-cons-list list1) firstList)
    (return list1)))

;; NOTHING CALLS THIS:
(defmethod (prepend (LIKE self)) ((self LIST) (list2 LIST))
  :documentation "Copy `list2' onto the front of the list `self'.
The operation is destructive wrt `self', but leaves `list2' intact."
  :public? TRUE
  (when (empty? list2)
    (return self))
  (setf (the-cons-list self)
        (concatenate (copy-cons-list (the-cons-list list2))
                     (the-cons-list self)))
  (return self) )

(defun (create-derived-list LIST) ((self LIST))
  :documentation "Create a new list object with the same type as `self'."
  :public? TRUE
  (let ((listType (primary-type self)))
    (case listType
      (@LIST (return (new LIST)))
      (@SET (return (new SET)))
      (otherwise (return (create-object listType))))))

(defmethod (copy (LIST OF (LIKE (any-value self)))) ((self LIST))
  :documentation "Return a copy of the list `self'.  The conses in the copy are
freshly allocated."
  :public? TRUE
  (let ((copy (create-derived-list self)))
    (setf (the-cons-list copy)
      (copy-cons-list (the-cons-list self)))
    (return copy)) )

(defmethod clear ((self LIST))
  :documentation "Make `self' an empty list."
  :public? TRUE
  (setf (the-cons-list self) NIL) )

(defmethod (sort (LIST OF (LIKE (any-value self))))
    ((self LIST) (predicate FUNCTION-CODE))
  :public? TRUE
  :documentation "Perform a stable, destructive sort of `self' according to
`predicate', and return the result.  If `predicate' has a '<' semantics, the
result will be in ascending order.  If `predicate' is NULL, a suitable
'<' predicate is chosen depending on the first element of `self', and it 
is assumed that all elements of `self' have the same type (supported
element types are GENERALIZED-SYMBOL, STRING, INTEGER, and FLOAT)."
  (setf (the-cons-list self) (sort (the-cons-list self) predicate))
  (return self))

(defun (map-NULL-to-NIL-LIST LIST) ((self LIST))
  :documentation "Return NIL-LIST iff `self' is NULL or `self' otherwise."
  :public? TRUE :globally-inline? TRUE
  (return (choose (null? self) NIL-LIST self)))

(defmethod (object-equal? BOOLEAN) ((x LIST) (y OBJECT))
  :documentation "Return TRUE iff the lists `x' and `y' are structurally
equivalent.  Uses `equal?' to test equality of elements."
  :public? TRUE
  (typecase y
    (LIST
     (return (equal? (the-cons-list x) (the-cons-list y))))
    (otherwise NULL))
  (return FALSE))

(defmethod (equal-hash-code INTEGER) ((self LIST))
  :documentation "Return an `equal?' hash code for `self'.  Note that this
is O(N) in the number of elements of `self'."
  :public? TRUE
  (let ((code 5619580)) ;; random number
    (return (logxor code (equal-hash-code (the-cons-list self))))))


  ;;
;;;;;; Iteration over LISTs
  ;;

(defmethod (allocate-iterator (LIST-ITERATOR OF (LIKE (any-value self))))
    ((self LIST))
  (let ((iterator (new LIST-ITERATOR)))
    (setf (list-iterator-cursor iterator) (the-cons-list self))
    (setf (list-iterator-collection iterator) self)
    (setf (first-iteration? iterator) TRUE)
    (return iterator) ))

(defun (terminate-list-iterator? BOOLEAN) ((self LIST-ITERATOR))
  (setf (list-iterator-cursor self) NIL)
  (setf (list-iterator-collection self) NULL)
  (return TRUE))

(defmethod (next? BOOLEAN) ((self LIST-ITERATOR))
  :public? TRUE
  (if (first-iteration? self)
    (progn
      (setf (first-iteration? self) FALSE)
      (setf (list-iterator-cursor self)
            (the-cons-list (list-iterator-collection self))))
    (setf (list-iterator-cursor self) (rest (list-iterator-cursor self))))
  (setf (slot-value self value) (value (list-iterator-cursor self)))
  (return (not (nil? (list-iterator-cursor self)))) )

(defmethod (empty? BOOLEAN) ((self LIST-ITERATOR) )
  :public? TRUE
  ;; Return TRUE if `self' has no more elements.
  (return (choose (first-iteration? self)
                  (empty? (the-cons-list (list-iterator-collection self)))
                  (empty? (rest (list-iterator-cursor self))))))

(defmethod (value-setter OBJECT)
    ((self LIST-ITERATOR) (value (LIKE (any-value self))))
  (setf (value (list-iterator-cursor self)) value)
  (setf (slot-value self value) value)
  (return value) )

(defmethod (but-last (ITERATOR OF (LIKE (any-value self)))) ((self LIST))
  :documentation "Generate all but the last element of the list `self'."
  :public? TRUE
  (return (but-last (the-cons-list self))) )


  ;;
;;;;;; 'deleted?' objects
  ;;

(defmethod (remove-deleted-members (LIKE self)) ((self LIST))
  :public? TRUE
  ;; Remove all members of `self' marked 'deleted?'.
  (setf (the-cons-list self)
        (remove-deleted-members (the-cons-list self)))
  (return self) )


  ;;
;;;;;; Property Lists (Keyword-Value Lists)
  ;;

(defmethod initialize-object ((self PROPERTY-LIST))
  (setf (the-plist self) NIL) )

(defun (search-plist OBJECT) ((pList CONS) (key OBJECT))
  ;; Helping function for property list routines.
  ;; If a key within `pList' matches `key', return the following value.
  (while (non-empty? pList)
    (when (eql? (value pList) key)
      (return (value (rest PList))))
    (setq pList (rest (rest pList))))
  (return NULL) )

(defmethod (lookup (LIKE (any-value self)))
           ((self PROPERTY-LIST) (key (LIKE (any-key self))))
  :public? TRUE
  (inline search-plist)
  (return (search-plist (the-plist self) key)) )

(defmethod (lookup-with-default (LIKE (any-value self)))
    ((self PROPERTY-LIST)
     (key (LIKE (any-key self)))
     (default (LIKE (any-value self))))
  :documentation "Lookup `key' in `self' and return the result.
Return `default' if no value was found."
  :public? TRUE
  (let ((value (search-plist (the-plist self) key)))
    (if (null? value)
        (return default)
      (return value))))

(defmethod (length INTEGER) ((self PROPERTY-LIST))
  :public? TRUE
  (let ((cursor (the-plist self))
        (length 0))
    (while (non-empty? cursor)
      (++ length)
      (setq cursor (rest (rest cursor))))
    (return length) ))

(defmethod insert-at ((self PROPERTY-LIST) (key (LIKE (any-key self))) 
                      (value (LIKE (any-value self))))
  :documentation "Insert the entry <`key', `value'> into the property list `self'.
If a previous entry existed with key `key', that entry is replaced."
  :public? TRUE
  (let ((cursor (the-plist self)))
    (while (non-empty? cursor)
      (when (eql? (value cursor) key)
        (setq cursor (rest cursor))
        (setf (value cursor) value)
        (return))
      (setq cursor (rest (rest cursor))))
    (setf (the-plist self)
      (cons key (cons value (the-plist self)))) ))

(defmethod (remove-at OBJECT) ((self PROPERTY-LIST) (key (LIKE (any-key self))))
  :documentation "Remove the entry that matches the key `key'.  Return the
value of the matching entry, or NULL if there is no matching entry.  Assumes that at
most one entry matches `key'."
  :public? TRUE
  (let ((cursor (the-plist self))
        (previousCons CONS NULL)
        (value OBJECT NULL))
    (when (non-empty? cursor)
      (when (eql? (value cursor) key)
        ;; first entry matches:
        (setf (the-plist self) (rest (rest cursor)))         ; chop out two conses
        (setq value (value (rest cursor)))
        (return value))
      ;; the first entry doesn't match:
      (setq previousCons (rest cursor))
      (setq cursor (rest previousCons))
      (while (non-empty? cursor)
        (when (eql? (value cursor) key)
          (setf (rest previousCons) (rest (rest cursor)))      ; chop out two conses
          (setq value (value (rest cursor)))
          (return value))
        (setq previousCons (rest cursor))
        (setq cursor (rest previousCons))))
    (return NULL) ))

(defmethod (empty? BOOLEAN) ((self PROPERTY-LIST))
  :public? TRUE
  (return (empty? (the-plist self))) )

(defmethod (non-empty? BOOLEAN) ((self PROPERTY-LIST))
  :public? TRUE
  (return (non-empty? (the-plist self))) )

(defmethod (copy (LIKE self)) ((self PROPERTY-LIST))
  :documentation "Return a copy of the list `self'.  The conses in the copy are
freshly allocated."
  :public? TRUE
  (let ((copy PROPERTY-LIST (create-object (primary-type self))))
    (setf (the-plist copy) (copy-cons-list (the-plist self)))
    (return copy)) )

(defmethod clear ((self PROPERTY-LIST))
  :documentation "Make `self' an empty property list."
  (setf (the-plist self) NIL) )

(defmethod (object-equal? BOOLEAN) ((x PROPERTY-LIST) (y OBJECT))
  :documentation
  "Return TRUE if `x' and `y' represent the same set of key/value pairs.."
  :public? TRUE
  (typecase y
    (PROPERTY-LIST
     (when (= (length x) (length y))
       (foreach (key value) in x
           where (not (equal? value (lookup y key)))
           do (return FALSE))
       (return TRUE)))
    (otherwise NULL))
  (return FALSE))

(defmethod (equal-hash-code INTEGER) ((self PROPERTY-LIST))
  :documentation "Return an `equal?' hash code for `self'.  Note that this
is O(N) in the number of entries of `self'."
  :public? TRUE
  (let ((code 108398967)) ;; result of (hash-string "PROPERTY-LIST" 0)
    (foreach (key value) in self
        ;; exploits the fact that `XOR' is commutative
        ;; (minor bug: doesn't distinguish between keys and values):
        do (setq code (logxor code (safe-equal-hash-code key)))
           (setq code (logxor code (safe-equal-hash-code value))))
    (return code)))

(defmethod (subset? BOOLEAN) ((self LIST) (otherList LIST))
  :documentation
  "Return true if every element of `self' also occurs in `otherList'.
Uses an `eql?' test and a simple quadratic-time algorithm.  Note that
this does not check whether `self' and `otherList' actually are sets."
  :public? TRUE
  (return (subset? (the-cons-list self) (the-cons-list otherList))))
  
(defmethod (equivalent-sets? BOOLEAN) ((self LIST) (otherList LIST))
  :documentation
  "Return true if every element of `self' occurs in `otherList' and vice versa.
Uses an `eql?' test and a simple quadratic-time algorithm.  Note that
this does not check whether `self' and `otherList' actually are sets."
  :public? TRUE
  (return (equivalent-sets? (the-cons-list self) (the-cons-list otherList))))

(defmethod (intersection LIST) ((self LIST) (otherList LIST))
  :documentation
  "Return the set intersection of `self' and `otherList'.  Uses an `eql?'
test and a simple quadratic-time algorithm.  Note that the result is only
guaranteed to be a set if both `self' and `otherList' are sets."
  :public? TRUE
  (let ((result (create-derived-list self)))
    (setf (the-cons-list result)
      (intersection (the-cons-list self) (the-cons-list otherList)))
    (return result)))

(defmethod (union LIST) ((self LIST) (otherList LIST))
  :documentation
  "Return the set union of `self' and `otherList'.  Uses an `eql?' test
and a simple quadratic-time algorithm.  Note that the result is only
guaranteed to be a set if both `self' and `otherList' are sets."
  :public? TRUE
  (let ((result (create-derived-list self)))
    (setf (the-cons-list result)
      (union (the-cons-list self) (the-cons-list otherList)))
    (return result)))

(defmethod (difference LIST) ((self LIST) (otherList LIST))
  :documentation
  "Return the set difference of `self' and `otherList' (i.e., all elements
that are in `self' but not in `otherSet').  Uses an `eql?' test and a simple
quadratic-time algorithm.  Note that the result is only guaranteed to be a
set if both `self' and `otherList' are sets."
  :public? TRUE
  (let ((result (create-derived-list self)))
    (setf (the-cons-list result)
      (difference (the-cons-list self) (the-cons-list otherList)))
    (return result)))

(defmethod (subtract LIST) ((self LIST) (otherList LIST))
  :documentation
  "Return the set difference of `self' and `otherList' by destructively
removing elements from `self' that also occur in `otherList'.  Uses an `eql?'
test and a simple quadratic-time algorithm.  Note that the result is only
guaranteed to be a set if `self' is a set."
  :public? TRUE
  (setf (the-cons-list self)
    (subtract (the-cons-list self) (the-cons-list otherList)))
  (return self))


  ;;
;;;;;; Property List Iterators
  ;;

(defmethod (allocate-iterator
            ;; FIGURE OUT: WHY DON'T WE INHERIT THE PARAMETERS FROM
            ;;    DICTIONARY.allocate-iterator???
            (PROPERTY-LIST-ITERATOR
             OF (LIKE (any-key self)) (LIKE (any-value self))))
    ((self PROPERTY-LIST))
  (let ((iterator (new PROPERTY-LIST-ITERATOR)))
    (setf (plist-iterator-cursor iterator) (the-plist self))
    (setf (plist-iterator-collection iterator) self)
    (setf (first-iteration? iterator) TRUE)
    (return iterator) ))

(defmethod (next? BOOLEAN) ((self PROPERTY-LIST-ITERATOR))
  :public? TRUE
  (if (first-iteration? self)
    (setf (first-iteration? self) FALSE)
    (setf (plist-iterator-cursor self)
          (rest (rest (plist-iterator-cursor self)))))
  (let ((remainingPList (plist-iterator-cursor self)))
    (when (non-empty? remainingPList)
      (setf (slot-value self key) (value remainingPList))
      (setf (slot-value self value) (value (rest remainingPList)))
      (return TRUE))
    (return FALSE)) )

(defmethod (value-setter (LIKE (any-value self)))
    ((self PROPERTY-LIST-ITERATOR) (value (LIKE (any-value self))))
  (setf (value (rest (plist-iterator-cursor self))) value)
  (setf (slot-value self value) value)
  (return value) )

(defmethod (key-setter (LIKE (any-key self)))
    ((self PROPERTY-LIST-ITERATOR) (key (LIKE (any-key self))))
  (setf (value (plist-iterator-cursor self)) key)
  (setf (slot-value self key) key)
  (return key) )


  ;;
;;;;;; KV-CONS
  ;;

(defun (kv-cons KV-CONS) ((key OBJECT) (value OBJECT) (rest KV-CONS))
  :documentation "Create, fill-in, and return a new KV-CONS."
  (let ((newKVC (new KV-CONS)))
    (setf (key newKVC) key)
    (setf (value newKVC) value)
    (setf (rest newKVC) rest)
    (return newKVC) ))

(defmethod (lookup (LIKE (any-value self)))
           ((cursor KV-CONS) (key (LIKE (any-key self))))
  :public? TRUE
  (while (defined? cursor)
    (when (eql? (key cursor) key)
      (return (value cursor)))
    (setq cursor (rest cursor)))
  (return NULL) )

(defmethod (length INTEGER) ((cursor KV-CONS))
  :public? TRUE
  (let ((length 0))
    (while (defined? cursor)
      (++ length)
      (setq cursor (rest cursor)))
    (return length) ))

(defun free-kv-cons ((kvCons KV-CONS))
  ;; No special GC invented yet.
  (free kvCons) )

(defmethod (lookup (LIKE (any-value self)))
           ((self KEY-VALUE-LIST) (key (LIKE (any-key self))))
  :public? TRUE
  (let ((cursor (the-kv-list self)))
    (while (defined? cursor)
      (when (eql? (key cursor) key)
        (return (value cursor)))
      (setq cursor (rest cursor)))
    (return NULL) ))

(defmethod (lookup-with-default (LIKE (any-value self)))
    ((self KEY-VALUE-LIST)
     (key (LIKE (any-key self)))
     (default (LIKE (any-value self))))
  :documentation "Lookup `key' in `self' and return the result.
Return `default' if no value was found."
  :public? TRUE
  (let ((cursor (the-kv-list self)))
    (while (defined? cursor)
      (when (eql? (key cursor) key)
        (return (value cursor)))
      (setq cursor (rest cursor)))
    (return default)))

(defmethod (length INTEGER) ((self KEY-VALUE-LIST))
  :public? TRUE
  (let ((length 0)
        (cursor (the-kv-list self)))
    (while (defined? cursor)
      (++ length)
      (setq cursor (rest cursor)))
    (return length) ))

(defmethod insert-at ((self KEY-VALUE-LIST) (key (LIKE (any-key self))) 
                      (value (LIKE (any-value self))))
  :public? TRUE
  :documentation "Insert the entry <`key', `value'> into the association
`self'. If a previous entry existed with key `key', that entry is replaced."
  (let ((cursor (the-kv-list self)))
    (while (defined? cursor)
      (when (eql? (key cursor) key)
        (setf (value cursor) value)
        (return))
      (setq cursor (rest cursor)))
    (setf (the-kv-list self)
          (kv-cons key value (the-kv-list self))) ))

(defmethod (remove-at OBJECT) ((self KEY-VALUE-LIST) (key (LIKE (any-key self))))
  :public? TRUE
  :documentation "Remove the entry that matches the key `key'.
Return the value of the matching entry, or NULL if there is no matching entry.
Assumes that at most one entry matches `key'."
  (let ((cursor (the-kv-list self))
        (previousCursor KV-CONS NULL)
        (value OBJECT NULL))
    (when (defined? cursor)
      (when (eql? (key cursor) key)
        ;; first entry matches:
        (setf (the-kv-list self) (rest cursor))
        (setq value (value cursor))
        (free-kv-cons cursor)
        (return value))
      ;; the first entry doesn't match:
      (while (defined? (rest cursor))
        (setq previousCursor cursor)
        (setq cursor (rest cursor))
        (when (eql? (key cursor) key)
          (setf (rest previousCursor) (rest cursor))
          (setq value (value cursor))
          (free-kv-cons cursor)
          (return value))))
    (return NULL) ))

;;; The following two variants of `insert-at' and `remove-at' somewhat
;;; abuse the data structure by making the value part of the key:

(defmethod insert-entry ((self KEY-VALUE-LIST) (key (LIKE (any-key self)))
                         (value (LIKE (any-value self))))
  :public? TRUE
  :documentation "Insert an entry <`key',`value'> to `self' unless an identical
entry already exists.  This can generate duplicate entries for `key'."
  (unless (exists (k v) in self
                  where (and (eq? k key)
                             (eq? v value)))
    (setf (the-kv-list self) (kv-cons key value (the-kv-list self)))))

(defmethod remove-entry ((self KEY-VALUE-LIST) (key (LIKE (any-key self)))
                         (value (LIKE (any-value self))))
  :public? TRUE
  :documentation "Remove the entry that matches <`key',`value'>.
Assumes that more than one entry can match `key'."
  (let ((cursor (the-kv-list self))
        (previousCursor KV-CONS NULL))
    (when (defined? cursor)
      (when (and (eql? (key cursor) key)
                 (eql? (value cursor) value))
        ;; first entry matches:
        (setf (the-kv-list self) (rest cursor))
        (free-kv-cons cursor)
        (return))
      ;; the first entry doesn't match:
      (while (defined? (rest cursor))
        (setq previousCursor cursor)
        (setq cursor (rest cursor))
        (when (and (eql? (key cursor) key)
                   (eql? (value cursor) value))
          (setf (rest previousCursor) (rest cursor))
          (free-kv-cons cursor)
          (return)))) ))


;;; Allow the list to be used like a stack of bindings:

(defmethod push ((self KEY-VALUE-LIST) (value KV-CONS))
  :documentation "Make `value' be the new first element of `self'.  Note that
the `rest' slot of `value' should be `null', since it will be overwritten.
This might duplicate an existing entry. If a previous entry existed with the
same key as `value', that entry is retained, but shadowed by this new entry."
  :public? TRUE
  (safety 1 (null? (rest value)) "Push only supports single entry KV-CONSes")
  (setf (rest value) (the-kv-list self))
  (setf (the-kv-list self) value))

(defmethod kv-push ((self KEY-VALUE-LIST)
		    (key (LIKE (any-key self))) (value (LIKE (any-value self))))
  :documentation "Add a new entry <`key', `value'> to the front of the association
`self'. This might duplicate an existing entry. If a previous entry existed with key
`key', that entry is retained, but shadowed by this new entry."
  (setf (the-kv-list self)
    (kv-cons key value (the-kv-list self))))


(defmethod (pop (LIKE (any-value self))) ((self KEY-VALUE-LIST))
  :documentation "Remove and return the value of the first element of the
kv-list `self'.  It does NOT return the KV-CONS object.  Return `null' if
the list is empty."
  :public? TRUE
  (when (empty? self)
    (return NULL))
  (let ((cons (the-kv-list self))
        (value OBJECT NULL))
    (setq value (value cons))
    (setf (the-kv-list self) (rest cons))
    (free-kv-cons cons)
    (return value) ))

(defmethod (reverse (LIKE self)) ((self KEY-VALUE-LIST))
  :documentation "Destructively reverse the members of the list `self'."
  :public? TRUE
  (let ((reversedList (the-kv-list self))
        (remainingList KV-CONS NULL)
        (temp KV-CONS NULL))
    (when (null? reversedList)
      (return self))  ;; empty list
    (setq remainingList (rest reversedList))
    (when (null? remainingList)
      (return self))  ;; singleton list
    (setf (rest reversedList) NULL)
    (while (defined? remainingList)
      (setq temp remainingList)
      (setq remainingList (rest remainingList))
      (setf (rest temp) reversedList)
      (setq reversedList temp))
    (setf (the-kv-list self) reversedList)
    (return self)))

(defmethod (empty? BOOLEAN) ((self KEY-VALUE-LIST))
  :public? TRUE
  (return (null? (the-kv-list self))) )

(defmethod (non-empty? BOOLEAN) ((self KEY-VALUE-LIST))
  :public? TRUE
  (return (defined? (the-kv-list self))) )

(defun (copy-kv-cons-list KV-CONS) ((kvConsList KV-CONS))
  :documentation "Return a copy of the cons list `consList'."
  :public? TRUE
  (when (null? kvConsList)
    (return NULL))
  (let ((newKVconsList (new KV-CONS))
        (nextKVcons newKVconsList)
        (copyFromKVcons KV-CONS NULL)
        (previousKVcons KV-CONS NULL))
    (setf (key nextKVcons) (key kvConsList))
    (setf (value nextKVcons) (value kvConsList))
    (setq copyFromKVcons (rest kvConsList))
    (while (defined? copyFromKVcons)
      (setq previousKVcons nextKVcons)
      (setq nextKVcons (new KV-CONS))
      (setf (rest previousKVcons) nextKVcons)
      (setf (key nextKVcons) (key copyFromKVcons))
      (setf (value nextKVcons) (value copyFromKVcons))
      (setq copyFromKVcons (rest copyFromKVcons)))
    (setf (rest nextKVcons) NULL)
    (return newKVconsList) ))

(defmethod (copy (LIKE self)) ((self KEY-VALUE-LIST))
  :documentation "Return a copy of the kv-list `self'.  The kv-conses in
the copy are freshly allocated."
  :public? TRUE
  (let ((copy (new KEY-VALUE-LIST)))
    (setf (the-kv-list copy)
          (copy-kv-cons-list (the-kv-list self)))
    (return copy)) )

(defmethod clear ((self KEY-VALUE-LIST))
  :documentation "Make `self' an empty dictionary."
  :public? TRUE
  (let ((next (the-kv-list self))
        (current KV-CONS NULL))
    (while (defined? next)
      (setq current next)
      (setq next (rest next))
      (free-kv-cons current))
    (setf (the-kv-list self) NULL) ))

(defmethod (object-equal? BOOLEAN) ((x KEY-VALUE-LIST) (y OBJECT))
  :documentation
  "Return TRUE if `x' and `y' represent the same set of key/value pairs."
  :public? TRUE
  (typecase y
    (KEY-VALUE-LIST
     (when (= (length x) (length y))
       (foreach (key value) in x
           where (not (equal? value (lookup y key)))
           do (return FALSE))
       (return TRUE)))
    (otherwise NULL))
  (return FALSE))

(defmethod (equal-hash-code INTEGER) ((self KEY-VALUE-LIST))
  :documentation "Return an `equal?' hash code for `self'.  Note that this
is O(N) in the number of entries of `self'."
  :public? TRUE
  (let ((code 94797224)) ;; result of (hash-string "KEY-VALUE-LIST" 0)
    (foreach (key value) in self
        ;; exploits the fact that `XOR' is commutative
        ;; (minor bug: doesn't distinguish between keys and values):
        do (setq code (logxor code (safe-equal-hash-code key)))
           (setq code (logxor code (safe-equal-hash-code value))))
    (return code)))

;;; KV-LIST ITERATORS:
(defmethod (allocate-iterator
            ;; FIGURE OUT: WHY DON'T WE INHERIT THE PARAMETERS FROM
            ;;    DICTIONARY.allocate-iterator???
            (KV-LIST-ITERATOR OF (LIKE (any-key self)) (LIKE (any-value self))))
    ((self KEY-VALUE-LIST))
  :public? TRUE
  (let ((iterator (new KV-LIST-ITERATOR)))
    (setf (the-kv-list iterator) self)
    (setf (kv-list-iterator-cursor iterator) (the-kv-list self))
    (setf (first-iteration? iterator) TRUE)
    (return iterator) ))

(defmethod (next? BOOLEAN) ((self KV-LIST-ITERATOR))
  :public? TRUE
  (if (first-iteration? self)
    (setf (first-iteration? self) FALSE)
    (setf (kv-list-iterator-cursor self)
          (rest (kv-list-iterator-cursor self))))
  (when (null? (kv-list-iterator-cursor self))
    (return FALSE))
  (setf (slot-value self KEY) (key (kv-list-iterator-cursor self)))
  (setf (slot-value self VALUE) (value (kv-list-iterator-cursor self)))
  (return TRUE) )

(defmethod (value-setter (LIKE (any-value self)))
    ((self KV-LIST-ITERATOR) (value (LIKE (any-value self))))
  :public? TRUE
  (setf (value (kv-list-iterator-cursor self)) value)
  (setf (slot-value self value) value)
  (return value) )

(defmethod (key-setter OBJECT) ((self KV-LIST-ITERATOR) (key OBJECT))
  :public? TRUE
  (setf (key (kv-list-iterator-cursor self)) key)
  (setf (slot-value self key) key)
  (return key) )

(defun (kvlist-to-plist (PROPERTY-LIST OF (LIKE (any-key self)) (LIKE (any-value self))))
    ((self KEY-VALUE-LIST))
  :documentation "Convert `self' into a property list with identical and identically
ordered keys and values."
  :public? TRUE
  (let ((plist NIL))
    (foreach (key value) in self
        do (setq plist (cons value (cons key plist))))
    (return (new PROPERTY-LIST :the-plist (reverse plist)))))

(defun (plist-to-kvlist (KEY-VALUE-LIST OF (LIKE (any-key self)) (LIKE (any-value self))))
    ((self PROPERTY-LIST))
  :documentation "Convert `self' into a key-value list with identical and identically
ordered keys and values."
  :public? TRUE
  (let ((kvList (new KEY-VALUE-LIST))
        (kvCons KV-CONS NULL))
    (foreach (key value) in self
        do (cond ((null? kvCons)
                  (setq kvCons (new KV-CONS))
                  (setf (the-kv-list kvList) kvCons))
                 (otherwise
                  (setf (rest kvCons) (new KV-CONS))
                  (setq kvCons (rest kvCons))))
           (setf (key kvCons) key)
           (setf (value kvCons) value))
    (return kvList)))

#|
(eval (setq d (dictionary @KEY-VALUE-LIST :a 1 :b 2 :c 3)))
(eval (foreach (k v) in d do (print k "," v EOL)))
(eval (foreach k in d do (print k EOL)))
(eval (foreach it on d where (eq? (key it) :b) do (setf (value it) 4)))
|#


  ;;
;;;;;; Generic collection access and construction
  ;;

(defmethod (member? BOOLEAN) ((self SEQUENCE) (value OBJECT))
  :documentation "Return TRUE if `value' is a member of the sequence `self'."
  :public? TRUE
  (foreach m in self
           where (eql? m value)
           do (return TRUE))
  (return FALSE) )
    
(defun (list LIST) (&rest (values OBJECT))
  :documentation "Return a list containing `values', in order."
  :public? TRUE
  (let ((list (new LIST)))
    (foreach v in values collect v into list)
    (return list) ))

(defun (sequence (SEQUENCE OF OBJECT))
    ((collectionType TYPE) &rest (values OBJECT))
  :documentation "Return a sequence containing `values', in order."
  :public? TRUE
  (let ((sequence (SEQUENCE OF OBJECT) (create-object collectionType)))
    (foreach i in values
             do
             ;; This is ugly, but there is not easy/clean way out:
             (typecase sequence
               (LIST (insert-last sequence i))
               (otherwise
                (error "sequence: Don't know how to `insert-last' into a "
                       collectionType))))
    (return sequence) ))

(defun (dictionary (ABSTRACT-DICTIONARY OF OBJECT OBJECT))
       ((collectionType TYPE) &rest (alternatingKeysAndValues OBJECT))
  :documentation
  "Return a dictionary of `collectionType' containing `values', in order.
Currently supported `collectionType's are @HASH-TABLE, @STELLA-HASH-TABLE,
@KEY-VALUE-LIST, @KEY-VALUE-MAP and @PROPERTY-LIST."
  :public? TRUE
  (let ((dictionary (ABSTRACT-DICTIONARY OF OBJECT OBJECT)
                    (create-object collectionType))
        (key OBJECT NULL)
        (value OBJECT NULL)
        (copy NIL)
        (cursor CONS NULL))
    (foreach item in alternatingKeysAndValues collect item into copy)
    (setq cursor copy)
    (while (non-empty? cursor)
      (setq key (first cursor))
      (setq value (second cursor))
      ;; This is ugly, but there is no easy/clean way out:
      (typecase dictionary
        (HASH-TABLE (insert-at dictionary key value))
        (STELLA-HASH-TABLE (insert-at dictionary key value))
        (KEY-VALUE-LIST (insert-at dictionary key value))
        (KEY-VALUE-MAP (insert-at dictionary key value))
        (PROPERTY-LIST (insert-at dictionary key value))
        (otherwise
         (error "dictionary: Can't create dictionaries of type "
                collectionType)))
      (setq cursor (rest (rest cursor))))
    (return dictionary) ))

(defmethod (listify (LIST OF (LIKE (any-value self)))) ((self LIST))
  :documentation "Return `self'."
  :public? TRUE
  (return self) )

(defmethod (listify (LIST OF (LIKE (any-value self)))) ((self CONS))
  :documentation "Return a list of elements in `self'."
  :public? TRUE
  (return (new LIST :the-cons-list self)) )

(defmethod (listify (LIST OF (LIKE (any-value self)))) ((self KEY-VALUE-LIST))
  :documentation "Return a list of key-value pairs in `self'."
  :public? TRUE
  (let ((result (new LIST)))
    (foreach (k v) in self
             collect (cons k (cons v NIL)) into result)
    (return result) ))

(defmethod (listify (LIST OF (LIKE (any-value self)))) ((self VECTOR))
  :documentation "Return a list of elements in `self'."
  :public? TRUE
  (let ((result (new LIST)))
    (foreach v in self collect v into result)
    (return result) ))

(defmethod (listify (LIST OF (LIKE (any-value self)))) ((self ITERATOR))
  :documentation "Return a list of elements generated by `self'."
  :public? TRUE
  (let ((list (new LIST)))
    (foreach value in self do (push list value))
    (return (reverse list)) ))
    

  ;;
;;;;;; print-form support for collections:
  ;;

(defun print-key-value-list ((self KEY-VALUE-LIST)
                             (stream NATIVE-OUTPUT-STREAM))
  (print-native-stream stream "|kv|(")
  (let ((cursor (the-kv-list self))
        (position 1))
    (while (defined? cursor)
      (when (and (defined? *printLength*)
                 (> position *printLength*))
        (print-native-stream stream " ...")
        (break))
      (unless (= position 1) (print-native-stream stream " "))
      (print-native-stream stream cursor)
      (setq cursor (rest cursor))
      (++ position))
    (print-native-stream stream ")") ))

