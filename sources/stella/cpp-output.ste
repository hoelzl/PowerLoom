;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;; BEGIN LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
; Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          ;
;                                                                            ;
; The contents of this file are subject to the Mozilla Public License        ;
; Version 1.1 (the "License"); you may not use this file except in           ;
; compliance with the License. You may obtain a copy of the License at       ;
; http://www.mozilla.org/MPL/                                                ;
;                                                                            ;
; Software distributed under the License is distributed on an "AS IS" basis, ;
; WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   ;
; for the specific language governing rights and limitations under the       ;
; License.                                                                   ;
;                                                                            ;
; The Original Code is the STELLA Programming Language.                      ;
;                                                                            ;
; The Initial Developer of the Original Code is                              ;
; UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          ;
; 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               ;
;                                                                            ;
; Portions created by the Initial Developer are Copyright (C) 1996-2010      ;
; the Initial Developer. All Rights Reserved.                                ;
;                                                                            ;
; Contributor(s):                                                            ;
;                                                                            ;
; Alternatively, the contents of this file may be used under the terms of    ;
; either the GNU General Public License Version 2 or later (the "GPL"), or   ;
; the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   ;
; in which case the provisions of the GPL or the LGPL are applicable instead ;
; of those above. If you wish to allow use of your version of this file only ;
; under the terms of either the GPL or the LGPL, and not to allow others to  ;
; use your version of this file under the terms of the MPL, indicate your    ;
; decision by deleting the provisions above and replace them with the notice ;
; and other provisions required by the GPL or the LGPL. If you do not delete ;
; the provisions above, a recipient may use your version of this file under  ;
; the terms of any one of the MPL, the GPL or the LGPL.                      ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; END LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; Version: cpp-output.ste,v 1.75 2010/09/08 20:52:12 hans Exp

;;; Routines for outputing a formatted C++ program.

(in-package "STELLA")

(in-module "/STELLA")


;;; Output a C++ program.

;; Number of characters to indent the current line.
(defspecial *cpp-indent-chars* INTEGER 0)

(defspecial *outputtingDefprint?* BOOLEAN FALSE
	    :documentation "`true' when outputting a defprint, used to 
            conditionally dereference streams in print-native-stream 
            statements.  Also used to take the address of streams
            when passed to functions inside of a defprint")

(defmacro cpp-output-to-string ((statement CONS))
  ;; Execute `statement' and redirect all translation output generated by
  ;;    it to a string stream.
  ;; Return the generated translation output as a string.
  ;; Needed for the translation of complex objects such as function
  ;;    signatures that might need to be wrapped with an array type.
  (let ((resultVar (local-gensym "RESULT")))
    (return
      (bquote
       (vrlet ((& resultVar STRING NULL))
	 (special ((*current-stream* (new OUTPUT-STRING-STREAM)))
	   & statement
	   (setq & resultVar
		 (the-string (cast *current-stream* OUTPUT-STRING-STREAM))))
	 & resultVar)))))

(defun cpp-output-parse-tree ((consTree CONS))
  ;; Top level function to output a C++ program.
  (special ((*cpp-indent-chars* 0))
    (cpp-output-statement consTree)))

(defun (cpp-flatten-statements CONS) ((statements CONS))
  ;; Flatten `statements' to remove any redundant, nested occurrances
  ;;    of CPP_PROGN and/or CPP_STATEMENTS.
  ;; Return the flattened list of statements.
  ;; If `statements' was a single CPP_PROGN or CPP_STATEMENTS statement,
  ;;    its list of body statements will be returned.
  ;; If `statements' was a single unflattenable statement, it will
  ;;    be returned unmodified.
  (if (and (defined? statements)
           (non-empty? statements))
      (typecase (first statements)
        (CONS
         (let ((flattenedSubTree NIL)
               (flattenedTree NIL))
           (while (not (nil? statements))
             (setq flattenedSubTree
               (cpp-flatten-statements (first statements)))
             (if (cons? (first flattenedSubTree))
                 ;; we have a list of statements:
                 (setq flattenedTree
                   (concatenate (reverse flattenedSubTree) flattenedTree))
               ;; we have a single statement:
               (pushq flattenedTree flattenedSubTree))
             (setq statements (rest statements)))
           (return (reverse flattenedTree))))
        (SYMBOL
         (case (first statements)
           ((CPP_PROGN CPP_STATEMENTS)
            (if (empty? (rest statements))
                (return NIL)
              (return (cpp-flatten-statements (rest statements)))))
           (otherwise
            (return statements)))))
    (return statements)))

(defun (cpp-prognify-statement CONS) ((statement OBJECT))
  ;; Ensure `statement' is wrapped into a `progn'.
  (if (cpp-progn? statement)
      (return statement)
    ;; Should we flatten `statement' first?
    (return (bquote (CPP_PROGN (CPP_STATEMENTS & statement))))))

(defun (cpp-statement-to-list CONS) ((statement OBJECT))
  ;; Convert `statement' into a list of statements, flattening it first
  ;;    if possible.
  (let ((flattenedStatement (cpp-flatten-statements statement)))
    (if (eql? flattenedStatement statement)
        (return (cons flattenedStatement NIL))
      (return flattenedStatement))))

(defun cpp-output-statement ((statement OBJECT))
  ;; Output a C++ statement, which involves interpreting the C++
  ;;   parse tree
  (typecase statement
    (CONS
     (when (nil? statement) (return))
     (if (or (cons? (first statement)) (null? (first statement)))
	 ;; Take care of the case where statement consists of nested stmts.
	 (progn
	   (cpp-output-statement (first statement))
	   (cpp-output-statement (rest statement)))
         (case (first statement)
	   (CPP_COMMENT (cpp-output-comment (second statement)))
	   (CPP_CLASS (cpp-output-class  (rest statement)))
           (CPP_HANDLER_CASE (cpp-output-handler-case (rest statement)))
           (CPP_CATCH (cpp-output-catch (rest statement)))
	   (CPP_SIGNAL (cpp-output-signal (rest statement)))
           (CPP_UNWIND_PROTECT (cpp-output-unwind-protect (rest statement)))
	   (CPP_VERBATIM (cpp-output-verbatim (second statement)))
	   (CPP_CAST (cpp-output-cast (rest statement)))
	   ((CPP_GLOBAL CPP_SPECIAL CPP_LOCAL)
            (cpp-output-variable-definition statement))
	   (CPP_TYPE (cpp-output-type-expression (rest statement)))
	   (CPP_DEREFERENCE (cpp-output-dereference (rest statement)))
           (CPP_ARRAY_REFERENCE (cpp-output-array-reference (rest statement)))
	   (CPP_PROGN (cpp-output-progn (second statement)))
	   (CPP_WITH_PROCESS_LOCK (cpp-output-with-process-lock (rest statement)))
	   (CPP_BREAK (cpp-output-break))
	   (CPP_CONTINUE (cpp-output-continue))
	   (CPP_IF (cpp-output-if (rest statement)))
	   (CPP_FUNCTION_SIGNATURE (cpp-output-funcall-function-signature
				    (rest statement)))
	   (CPP_METHOD_SIGNATURE (cpp-output-method-code-call-signature
				    (rest statement)))
	   (CPP_COND (cpp-output-cond (rest statement)))
	   (CPP_CASE (cpp-output-case (rest statement)))
	   (CPP_WHEN (cpp-output-when (rest statement)))
	   (CPP_UNLESS (cpp-output-unless (rest statement)))
	   (CPP_ASSIGN (cpp-output-assignment (rest statement)))
	   (CPP_LOOP (cpp-output-loop (rest statement)))
	   (CPP_WHILE (cpp-output-while (rest statement)))
	   (CPP_FOREACH (cpp-output-foreach (rest statement)))
	   (CPP_BLOCK (cpp-output-block (rest statement)))
	   (CPP_IDENT (cpp-output-identifier (second statement)))
	   (CPP_PRINT_STREAM (cpp-output-print-stream (rest statement)))
	   (CPP_PRINT_NATIVE_STREAM (cpp-output-print-native-stream
				     (rest statement)))
	   (CPP_LITERAL (cpp-output-literal (second statement)))
	   ((CPP_FUNCTION CPP_METHOD) (cpp-output-function (rest statement)))
	   (CPP_RETURN (cpp-output-return (second statement)))
	   (CPP_SYMBOL (cpp-output-literal (second statement)))
	   (CPP_MAKE (cpp-output-make (rest statement)))
	   (CPP_FUNCALL (cpp-output-funcall (rest statement)))
	   (CPP_METHOD_CODE_CALL 
	    (cpp-output-method-code-call (rest statement)))
	   (CPP_FUNCTION_POINTER (cpp-output-function-pointer (second statement)))
	   (CPP_METHOD_POINTER 
	    (cpp-output-method-pointer (second statement)))
	   (CPP_SLOT_VALUE
	    (cpp-output-slot-value (rest statement)))
	   (CPP_REFERENCED_SLOT_VALUE
	    (cpp-output-referenced-slot-value (rest statement)))
	   (CPP_SLOT_VALUE_SETTER
	    (cpp-output-slot-value-setter (rest statement)))
	   (CPP_DECLARATIONS 
	    (cpp-output-declarations (second statement) (third statement)))
           (CPP_DEFINITIONS
	    (cpp-output-definitions (second statement) (third statement)))
	   (CPP_SIGNATURES 
	    (cpp-output-signatures (second statement) (third statement)))
	   (CPP_STATEMENTS
	    (cpp-output-statements (rest statement)))
	   (CPP_UNARY_OP
	    (cpp-output-unary-operator (rest statement)))
	   (CPP_BINARY_OP
	    (cpp-output-binary-operator (rest statement)))
	   (CPP_TERNARY_OP
	    (cpp-output-ternary-operator (rest statement)))
	   (CPP_FUNCTION_CALL
	    (cpp-output-function-call (rest statement)))
	   (CPP_METHOD_SETTER_CALL
	    (cpp-output-method-setter-call (rest statement)))
	   (CPP_METHOD_CALL
	    (cpp-output-method-call (rest statement)))
	   (CPP_REFERENCED_METHOD_CALL
	    (cpp-output-referenced-method-call (rest statement)))
	   (CPP_ACTUALS
	    (cpp-output-actual-parameters (rest statement)))
	   (CPP_DEFPRINT (cpp-output-defprint (rest statement))))))
    (otherwise 
     (when (null? statement)
       (return))
     (cpp-output-atomic-expression statement))) )
    
(defun cpp-output-verbatim ((verbatimStatement STRING-WRAPPER))
  (print-stream *current-stream* (wrapper-value verbatimStatement)) )

(defun cpp-output-comment ((tree STRING-WRAPPER))
  (print-stream *current-stream* "// ")
  (let ((returnP FALSE))
    (foreach char in (wrapper-value tree)
	do (case char
	     (#\Linefeed
	      (unless returnP
		(print-stream *current-stream* EOL)
		(cpp-indent)
		(print-stream *current-stream* "// "))
	      (setq returnP FALSE))
	     (#\Return
	      (print-stream *current-stream* EOL)
	      (cpp-indent)
	      (print-stream *current-stream* "// ")
	      (setq returnP TRUE))
	     (otherwise
	      (print-stream *current-stream* char)
	      (setq returnP FALSE))))
    (print-stream *current-stream* EOL)))

(defun cpp-output-dereference ((tree CONS))
  ;; Dereference a C++ statement, used for multiple return values
  (print-stream *current-stream* "*")
  (cpp-output-statement tree) )

(defun cpp-output-array-reference ((tree CONS))
  ;; Output a reference to an array element.
  ;; `tree' has the form (<array-expression> <index-expression>+)
  (cpp-maybe-output-statement-with-parentheses (first tree))
  (foreach indexExpression in (rest tree)
      do (print-stream *current-stream* "[")
         (cpp-output-statement indexExpression)
         (print-stream *current-stream* "]")))

(defun cpp-output-cast ((tree CONS))
  ;; `tree' has form (<expression> <type>)
  (print-stream *current-stream* 
		"((" 
		(wrapper-value (cast (second tree) STRING-WRAPPER)) ")(")
  (cpp-output-statement (first tree))
  (print-stream *current-stream* "))"))

(defun cpp-output-signal ((tree CONS))
  (print-stream *current-stream* "throw ")
  (cpp-output-statement (first tree)))

(defun cpp-output-handler-case ((tree CONS))
  ;; Output a C++ try/catch forms to implement an `exception-case'.
  ;; `tree' has the form `(<protected form> <handler form>+)'.
  (print-stream *current-stream* "try {" EOL)
  ;; output protected form:
  (cpp-bump-indent)
  (cpp-output-statements (cpp-statement-to-list (first tree)))
  (cpp-unbump-indent)
  (cpp-indent)
  (print-stream *current-stream* "}" EOL)
  ;; output handler forms:
  (cpp-output-statements (rest tree)))

(defun cpp-output-catch ((tree CONS))
  ;; Output a C++ catch handler form.
  ;; `tree' has the form `((<exceptionType> [<variableName>]) <catch form>*)'.
  (let ((variableDecl CONS (first tree)))
    (print-stream *current-stream* "catch (")
    ;; output catch parameter list:
    (cpp-output-statement (first variableDecl))
    (when (defined? (second variableDecl))
      (cpp-output-statement (second variableDecl)))
    (print-stream *current-stream* ") {" EOL)
    ;; output code inside the catch clause:
    (cpp-bump-indent)
    (cpp-output-statements (cpp-flatten-statements (rest tree)))
    (cpp-unbump-indent)
    (cpp-indent)
    (print-stream *current-stream* "}" EOL)))

(defun cpp-output-unwind-protect ((tree CONS))
  ;; Output a C++ try/catch form to implement unwind-protect.
  ;; `tree' has the form `(<protected form> <cleanup form>+)'.
  (print-stream *current-stream* "try {" EOL)
  ;; output protected form:
  (cpp-bump-indent)
  (cpp-output-statements (cpp-statement-to-list (first tree)))
  (cpp-unbump-indent)
  (cpp-indent)
  (print-stream *current-stream* "}" EOL)
  ;; catch everything:
  (print-stream *current-stream* "catch (...) {" EOL)
  (cpp-bump-indent)
  ;; output cleanup forms:
  (cpp-output-statements (copy-cons-tree (rest tree)))
  (cpp-indent)
  (print-stream *current-stream* "throw;" EOL)
  (cpp-unbump-indent)
  (cpp-indent)
  (print-stream *current-stream* "}" EOL)
  ;; output cleanup forms again, in case we had a normal exit:
  (cpp-output-statements (rest tree)))

(defun cpp-output-global-declaration ((global CONS))
  ;; Output a C++ global declaration.  `global' has the form:
  ;;    (<kind> <documentation> <type> <name> <initialValue>).
  ;; NOTE: Currently, all global variables are external.
  ;; NOTE: Should <documentation> go here as well?
  (let ((kind (first global))
        ;(documentation (second global))
        (type (third global))
        (name (fourth global))
        ;(initialValue (fifth global))
        )
    (print-stream *current-stream* "extern ")
    (case kind
      (CPP_SPECIAL
       (if (eql? (special-implementation-style) :unbind-with-destructors)
           (cpp-output-statement
            (bquote
             (CPP_FUNCTION_CALL
              (CPP_IDENT "DECLARE_STELLA_SPECIAL")
              (CPP_ACTUALS
               (CPP_IDENT & name)
               & type))))
         (cpp-output-typed-entity type name NULL)))
      (otherwise
       (cpp-output-typed-entity type name NULL)))
    (print-stream *current-stream* ";" EOL)))

(defun cpp-output-variable-definition ((variable CONS))
  ;; Output a C++ variable definition.  `variable' has the form:
  ;;    (<kind> <documentation> <type> <name> <initialValue>).
  ;; NOTE: Currently, all global variables are external.
  (let ((kind (first variable))
        (documentation (unwrap-string (second variable)))
        (type (third variable))
        (name (fourth variable))
        (initialValue (fifth variable)))
    (when (defined? documentation)
      (cpp-output-comment documentation))
    (case kind
      (CPP_SPECIAL
       (if (eql? (special-implementation-style) :unbind-with-destructors)
           (cpp-output-statement
            (bquote
             (CPP_FUNCTION_CALL
              (CPP_IDENT "DEFINE_STELLA_SPECIAL")
              (CPP_ACTUALS
               (CPP_IDENT & name) & type & initialValue))))
         (cpp-output-typed-entity type name initialValue)))
      (otherwise
       (cpp-output-typed-entity type name initialValue)))
    (print-stream *current-stream* ";" EOL EOL)))

(defun cpp-output-funcall-function-signature ((signature CONS))
  (let ((returnTypes (CONS OF STRING-WRAPPER) (first signature))
        ;; can only handle one right now:
        (returnType (first returnTypes))
        (parameterTypes (CONS OF STRING-WRAPPER) (second signature))
        (nofParameters (length parameterTypes))
        (bareSignature
         (cpp-output-to-string
          (progn
            (print-stream *current-stream* " (*) (")
            (foreach parType in parameterTypes
                as i in (interval 1 nofParameters)
                do (print-stream *current-stream* (wrapper-value parType))
                   (when (< i nofParameters)
                     (print-stream *current-stream* ", ")))
            (print-stream *current-stream* ")")))))
    (print-stream *current-stream* "(")
    (cpp-output-typed-entity returnType bareSignature NULL)
    (print-stream *current-stream* ")") ))

(defun cpp-output-method-code-call-signature ((signature CONS))
  ;; signature has form (<return-types> <object-type> <parameter-types>)
  (let ((returnTypes (CONS OF STRING-WRAPPER) (first signature))
        ;; can only handle one right now:
        (returnType (first returnTypes))
        (objectType STRING (second signature))
        (parameterTypes (CONS OF STRING-WRAPPER) (third signature))
        (nofParameters (length parameterTypes))
        (bareSignature
         (cpp-output-to-string
          (progn
            (print-stream *current-stream* " (")
            (print-stream *current-stream* objectType)
            (print-stream *current-stream* "::*) (")
            (foreach parType in parameterTypes
                as i in (interval 1 nofParameters)
                do (print-stream *current-stream* (wrapper-value parType))
                   (when (< i nofParameters)
                     (print-stream *current-stream* ", ")))
            (print-stream *current-stream* ")")))))
    (print-stream *current-stream* "(")
    (cpp-output-typed-entity returnType bareSignature NULL)
    (print-stream *current-stream* ")")))

(defun cpp-output-funcall ((funcall CONS))
  ;; `tree' has form (<function-signature> <funcallExpression> <args> )
  (print-stream *current-stream* "(")
  (cpp-output-statement (first funcall))
  (cpp-output-statement (second funcall))
  (print-stream *current-stream* ")")
  (cpp-output-statement (third funcall)) )

(defun cpp-output-method-code-call ((methodCall CONS))
  ;; `tree' has form (<method-signature> <methodExpression> <object> <args> )
  (print-stream *current-stream* "(")
  (cpp-maybe-output-statement-with-parentheses (third methodCall))
  (print-stream *current-stream* "->*(")
  (cpp-output-statement (first methodCall))
  (print-stream *current-stream* " ")
  (cpp-output-statement (second methodCall))
  (print-stream *current-stream* ")) ")
  (cpp-output-statement (fourth methodCall)) )

(defun cpp-output-break ()
  ;; Output a break statement in a loop
  (print-stream *current-stream* "break;" EOL) )

(defun cpp-output-continue ()
  ;; Output a continue statement in a loop
  (print-stream *current-stream* "continue;" EOL) )

(defun (cpp-last-statement-is-return? BOOLEAN) ((statements CONS))
  ;; Helping function for `cpp-output-case' if the last statement
  ;;    in this statements block is a return statement, return TRUE.
  (let ((lastItem (last statements)))
    (return 
     (and (cons? lastItem)
          (eql? (first (cast lastItem CONS)) (quote CPP_RETURN)))) ))

(defun cpp-output-case ((case CONS))
  ;; Output a C++ case (i.e. a switch) 
  ;; "case" has form (<keyForm> <default case> <otherCases>)
  ;; where <otherCases> = ((<key> <actions>)*)
  (let ((keyForm (first case))
	(defaultCase (second case))
	(conditions (third case)))
    (print-stream *current-stream* "switch (")
    (cpp-output-statement keyForm)
    (print-stream *current-stream* ") {" EOL)
    (cpp-bump-indent)
    (foreach c in (cast conditions (CONS OF CONS))
	do
	  (let ((condition CONS c))
	    (foreach cond in 
		  (cast 
		   (choose (cons? (first 
				   (cast (first condition)
					 CONS)))
			   (first condition)
			   (cons (first condition) NIL))
		   CONS)
		do
		  (cpp-indent)
		  (print-stream *current-stream* "case ")
		  (cpp-output-statement cond)
		  (print-stream *current-stream* ": " EOL))
	    (cpp-bump-indent)
	    (cpp-output-statement (second condition))
	    (cpp-unbump-indent)
	    (unless (cpp-last-statement-is-return? (second condition))
	      (cpp-indent)
	      (print-stream *current-stream* "break;" EOL))))
	     
    (safety 1 (defined? defaultCase)
            "INTERNAL ERROR: `cpp-output-case' expects an `otherwise' clause.")
    (cpp-indent)
    (print-stream *current-stream* "default:" EOL)
    (cpp-bump-indent)
    (cpp-output-statement defaultCase)
    (cpp-unbump-indent)
    (unless (cpp-last-statement-is-return? defaultCase)
      (cpp-indent)
      (print-stream *current-stream* "break;" EOL))
    (cpp-unbump-indent)
    (cpp-indent)
    (print-stream *current-stream* "}" EOL) ))

(defun cpp-output-cond ((cond CONS))
  ;; Output a C++ conditional (i.e. an extended if..then..else) statement
  ;; "cond" has form (<default cond> <otherConds>)
  ;; where <otherConds> = ((<test> <actions>)*)
  (let ((defaultCondition CONS (first cond))
	(conditions cons (second cond))
	(firstCondition CONS (first conditions))
	(restConditions CONS (rest conditions)))
    ;; Handle case where defaultCondition is only conditition
    (when (and (defined? defaultCondition)
	       (empty? conditions))
      (print-stream *current-stream* "if (TRUE) ")
      (cpp-output-statement defaultCondition)
      (return))
    (print-stream *current-stream* "if (")
    (cpp-output-statement (first firstCondition))
    (print-stream *current-stream* ") ")
    (cpp-output-statement (second firstCondition))
    (foreach c in restConditions
	     do
	     (let ((condition CONS c))
	       (cpp-indent)
	       (print-stream *current-stream* "else if (")
	       (cpp-output-statement (first condition))
	       (print-stream *current-stream* ") ")
	       (cpp-output-statement (second condition))))
    (when (defined? defaultCondition)
      (cpp-indent)
      (print-stream *current-stream* "else ")
      (cpp-output-statement defaultCondition)) ))

(defun (cpp-progn? BOOLEAN) ((tree OBJECT))
  ;; Return TRUE if `tree' is a CPP_PROGN
  (return (and (cons? tree)
	       (eql? (first (cast tree CONS)) (quote CPP_PROGN)))) )

(defun (cpp-block? BOOLEAN) ((tree OBJECT))
  ;; Return TRUE if `tree' is a CPP_BLOCK or CPP_PROGN which
  ;;    both get translated into C++ blocks.
  (typecase tree
    (CONS
     (case (first tree)
       ((CPP_BLOCK CPP_PROGN)
        (return TRUE))
       (otherwise NULL)))
    (otherwise NULL))
  (return FALSE))

(defun cpp-output-if ((tree CONS))
  ;; Output an if statement.
  ;; tree has the form <test> <true body> <false body>
  (print-stream *current-stream* "if (")
  (cpp-output-statement (first tree))
  (print-stream *current-stream* ") ")
  (if (cpp-block? (second tree))
      (cpp-output-statement (second tree))
      (progn
	(print-stream *current-stream* EOL)
	(cpp-bump-indent)
	(cpp-indent)
	(cpp-output-statement (second tree))
	(print-stream *current-stream* ";" EOL)
	(cpp-unbump-indent)))
  (unless (null? (third tree))
    (cpp-indent)
    (print-stream *current-stream* "else ")
    (if (cpp-block? (third tree))
	(cpp-output-statement (third tree))
        (progn
	  (print-stream *current-stream* EOL)
	  (cpp-bump-indent)
	  (cpp-indent)
	  (cpp-output-statement (third tree))
	  (print-stream *current-stream* ";" EOL)
	  (cpp-unbump-indent)))) )

(defun cpp-output-when ((tree CONS))
  ;; Output an when statement.
  ;; tree has the form <test> <body> 
  (print-stream *current-stream* "if (")
  (cpp-output-statement (first tree))
  (print-stream *current-stream* ") {" EOL)
  ;; (second tree) = (CPP_STATEMENTS...)
  (cpp-bump-indent)
  (cpp-output-statement (second tree))
  (cpp-unbump-indent)
  (cpp-indent)
  (print-stream *current-stream* "}" EOL) )

(defun cpp-output-unless ((tree CONS))
  ;; Output an when statement.
  ;; tree has the form <test> <body> 
  (print-stream *current-stream* "if (!(")
  (cpp-output-statement (first tree))
  (print-stream *current-stream* ")) {" EOL)
  ;; (second tree) = (CPP_STATEMENTS...)
  (cpp-bump-indent)
  (cpp-output-statement (second tree))
  (cpp-unbump-indent)
  (cpp-indent)
  (print-stream *current-stream* "}" EOL) )

(defun cpp-output-assignment ((assignment CONS))
  ;; Output assignment statement.
  ;; Assignment has the form (<lvalue> <rvalue>)
  (cpp-output-statement (first assignment))
  (print-stream *current-stream* " = ")
  (cpp-output-statement (second assignment)) )

(defun cpp-output-loop ((loop CONS))
  ;; Output a C++ loop.  
  ;; "loop" has the form (<statements>)
  (print-stream *current-stream* "for (;;) ")
  (cpp-output-statement (first loop)) )

(defun cpp-output-while ((loop CONS))
  ;; Output a C++ while statement.  
  ;; "loop" has the form (<test> <statements>)
  (print-stream *current-stream* "while (")
  (cpp-output-statement (first loop))
  (print-stream *current-stream* ") ")
  (cpp-output-statement (second loop)) )

(defun cpp-output-foreach ((loop CONS))
  ;; Output a C++ foreach statement.  "loop" has the form
  ;;   (<variables>
  ;;    <continuationTest>
  ;;    <valueAssignments>
  ;;    <nextAssignments>
  ;;    <body>)
  ;; All <variables> are already assumed to be declared in
  ;;    a surrounding block.
  (let ((variables (CONS OF CONS) (first loop))
        (nofVariables (length variables))
        (continuationTest (second loop))
        (valueAssignments CONS (third loop))
	(nextAssignments CONS (fourth loop))
        (nofNextAssignments (length nextAssignments))
	(body CONS (fifth loop))
        (eolSeparateExpressions?
         (or (> nofVariables 2)
             (> *cpp-indent-chars* 35))))
    (cpp-indent)
    (if eolSeparateExpressions?
        (print-stream *current-stream* "for  (")
      (print-stream *current-stream* "for ("))
    (cpp-bump-indent)
    (cpp-bump-indent)
    (cpp-bump-indent)
    (foreach var in variables
        as i in (interval 1 NULL)
        do (cpp-output-statement var)
           (unless (= i nofVariables)
             (print-stream *current-stream* ", ")))
    (print-stream *current-stream* "; ")
    (when (and (non-empty? variables)
               eolSeparateExpressions?)
      (print-stream *current-stream* EOL)
      (cpp-indent))
    (cpp-output-statement continuationTest)
    (print-stream *current-stream* "; ")
    (when (non-empty? nextAssignments)
      (when eolSeparateExpressions?
        (print-stream *current-stream* EOL))
      (foreach next in nextAssignments
          as i in (interval 1 NULL)
          do (when eolSeparateExpressions?
               (cpp-indent))
             (cpp-output-statement next)
             (unless (= i nofNextAssignments)
               (if eolSeparateExpressions?
                   (print-stream *current-stream* "," EOL)
                 (print-stream *current-stream* ", ")))))
    (print-stream *current-stream* ") {" EOL)
    (cpp-unbump-indent)
    (cpp-unbump-indent)
    (cpp-output-statements
     (cpp-flatten-statements (concatenate valueAssignments body)))
    (cpp-unbump-indent)
    (cpp-indent)
    (print-stream *current-stream* "}" EOL) ))

(defun cpp-output-function-pointer ((functionName STRING-WRAPPER))
  ;; Output a pointer to a C++ function.
  (print-stream *current-stream* "&" (wrapper-value functionName)) )

(defun cpp-output-method-pointer ((methodName STRING-WRAPPER))
  ;; Output a pointer to a C++ member function.
  (print-stream *current-stream* "&" (wrapper-value methodName)) )

(defun cpp-output-slot-value ((statement CONS))
  ;; Output a slot access statement.
  (cpp-maybe-output-statement-with-parentheses (first statement))
  (print-stream *current-stream*
		"->" 
		(wrapper-value (cast (second statement) 
				     STRING-WRAPPER))) )

(defun cpp-output-referenced-slot-value ((statement CONS))
  ;; Output a referenced slot access statement.
  (cpp-maybe-output-statement-with-parentheses (first statement))
  (print-stream *current-stream*
		"." 
		(wrapper-value (cast (second statement) 
				     STRING-WRAPPER))) )

(defun cpp-output-slot-value-setter ((statement CONS))
  ;; Output a slot setting statement.
  (cpp-maybe-output-statement-with-parentheses (first statement))
  (print-stream *current-stream* 
		"->" 
		(wrapper-value (cast (second statement)
				     STRING-WRAPPER))
		" = ")
  (cpp-output-statement (third statement)) )

(defun cpp-output-make ((statement CONS))
  ;; Output a storage-allocation statement.
  (print-stream *current-stream* "new ")
  (cpp-output-statement (first statement))
  (when (defined? (second statement))
    (cpp-output-statement (second statement))))

(defun cpp-bump-indent ()
  ;; Bump the indent level 
  (setq *cpp-indent-chars* (+ *cpp-indent-chars* 2)) )

(defun cpp-unbump-indent ()
  ;; Bump the indent level 
  (setq *cpp-indent-chars* (- *cpp-indent-chars* 2)) )

(defmethod cpp-output-literal ((object OBJECT))
  ;; Dummy method on abstract class
  NULL
  )

(defmethod cpp-output-literal ((character CHARACTER-WRAPPER))
  ;; Output a character
  (let ((ch (wrapper-value character)))
    (case ch
      (#\' (print-stream *current-stream* "'\\''"))
      (#\\ (print-stream *current-stream* "'\\\\'"))
      (#\LINEFEED (print-stream *current-stream* "'\\n'"))
      (#\BACKSPACE (print-stream *current-stream* "'\\b'"))
      (#\TAB (print-stream *current-stream* "'\\t'"))
      (#\RETURN (print-stream *current-stream* "'\\r'"))
      (#\PAGE (print-stream *current-stream* "'\\f'"))
      (#\NULL (print-stream *current-stream* "'\\0'"))
      (otherwise
       (if (eql? ch NULL-CHARACTER)
           (print-stream *current-stream* "'\\0'")
         (print-stream *current-stream* #\' ch #\'))))))

(defmethod cpp-output-literal ((int INTEGER-WRAPPER))
  ;; Output an integer
  (print-stream *current-stream* (wrapper-value int)) )

(defmethod cpp-output-literal ((int LONG-INTEGER-WRAPPER))
  ;; Output a long integer
  (print-stream *current-stream* (wrapper-value int) "l") )

(defmethod cpp-output-literal ((float FLOAT-WRAPPER))
  ;; Output a float
  (print-stream *current-stream* (wrapper-value float)) )

(defmethod cpp-output-literal ((boolean BOOLEAN-WRAPPER))
  ;; Output a boolean value.
  (if (wrapper-value boolean)
      (print-stream *current-stream* "TRUE")
    (print-stream *current-stream* "FALSE")))

(defmethod cpp-output-literal ((cons CONS))
  ;; Output cons or NIL
  (if (nil? cons)
      (print-stream *current-stream* "NIL")
      (progn
	(print-stream *current-stream* "(" (value cons) " . ")
	(cpp-output-literal (rest cons)))) )

(defun (replace-character-with-substring STRING)
    ((string STRING) (new STRING) (character CHARACTER))
  ;; Replace all instances of `character' in `string' with `new'.
  ;; This is obsolete.
  :globally-inline? TRUE
  (return (replace-substrings string new character)))

(defglobal *cpp-max-string-literal-length* INTEGER 1024
  :documentation "C++ string literals longer than this are broken
into multiple pieces to avoid problems with certain MS compilers.")

(defmethod cpp-output-literal ((string STRING))
  ;; Output `string', quote special characters and translate
  ;;    linefeeds and returns into the appropriate C++ syntax.
  ;; Literals longer than `*cpp-max-string-literal-length*'
  ;;    are broken up into multiple adjacent pieces (works
  ;;    around a problem of some MS Visual C++ compilers).
  (let ((free *cpp-max-string-literal-length*))
    (print-stream *current-stream* #\")
    (foreach ch in string
        do (when (<= free 1)
             (print-stream *current-stream* "\" \"")
             (setq free *cpp-max-string-literal-length*))
           (case ch
             ((#\\ #\")
              (print-stream *current-stream* #\\)
              (-- free))
             (#\linefeed
              (print-stream *current-stream* #\\)
              (-- free)
              (setq ch #\n))
             (#\return
               (print-stream *current-stream* #\\)
               (-- free)
               (setq ch #\r))
             (otherwise NULL))
           (print-stream *current-stream* ch)
           (-- free))
    (print-stream *current-stream* #\")))
  
(defmethod cpp-output-literal ((string STRING-WRAPPER))
  ;; Output `string'.
  (cpp-output-literal (wrapper-value string)) )

(defmethod cpp-output-literal ((string MUTABLE-STRING-WRAPPER))
  ;; Output `string'.
  (cpp-output-literal (mutable-string-to-string (wrapper-value string))) )

(defmethod cpp-output-literal ((tree QUOTED-EXPRESSION))
  ;; Output a quoted expression.
  ;; NOTE: for now, its just a string.  Eventually we want
  ;;   a real reference to the quoted expression.
  (print-stream *current-stream* "\"" tree "\"") )

(defmethod cpp-output-literal ((symbol SYMBOL))
  ;; Output symbol.  NOTE: We assume that a macro definition
  ;;   of the form SYM_<symbol name> exists which implements the getting 
  ;;   of the actual symbol
  (print-stream *current-stream* 
		(wrapper-value (cpp-translate-symbol-name symbol))) )

(defmethod cpp-output-literal ((surrogate SURROGATE))
  ;; Output surrogate  NOTE: We assume that a macro definition
  ;;   of the form SGT_<surrogate name> exists which implements the getting 
  ;;   of the actual kewyord.
  (print-stream *current-stream* 
		(wrapper-value (cpp-translate-surrogate-name 
				surrogate))) )

(defmethod cpp-output-literal ((keyword KEYWORD))
  ;; Output Keyword.  NOTE: We assume that a macro definition
  ;;   of the form KWD_<kwd name> exists which implements the getting 
  ;;   of the actual kewyord.
  (print-stream *current-stream* 
		(wrapper-value (cpp-translate-keyword-name keyword))) )

(defun cpp-output-identifier ((identifier STRING-WRAPPER))
  (print-stream *current-stream* (wrapper-value identifier)) )

;;; Q: ARE THE SPECIAL SYMBOLS (E.G. SCOLON) USED ANYMORE?
(defun cpp-output-atomic-expression ((atom OBJECT))
  ;; Output a C++ token.  Do special printing on certain symbols.
  (case atom
    (NEWLINE (print-stream *current-stream* EOL))
    (CPP_NULL_VALUE (print-stream *current-stream* "NULL_VALUE"))
    (ASSIGN (print-stream *current-stream* "="))
    (SCOLON (print-stream *current-stream* ";"))
    (LPAREN (print-stream *current-stream* "("))
    (RPAREN (print-stream *current-stream* ")"))
    (otherwise 
     ;; Assume literal
     (cpp-output-literal atom)) ))

(defun cpp-indent ()
  ;; Indent a line.
  (print-spaces *current-stream* *cpp-indent-chars*))

(defun (cpp-output-semicolon? BOOLEAN) ((statement CONS))
  ;; Only output semicolons at the end of selected statements,
  ;;    e.g., method calls.  Don't output semicolons after conditionals,
  ;;    loops, etc.
  (when (defined? statement)
    (case (first statement)
      ((CPP_ASSIGN
        CPP_UNARY_OP
        CPP_BINARY_OP
        CPP_TERNARY_OP
        CPP_CAST
        CPP_FUNCALL
        CPP_FUNCTION_CALL
        CPP_FUNCTION_POINTER
        CPP_MAKE
        CPP_METHOD_CALL 
        CPP_METHOD_CODE_CALL
        CPP_METHOD_POINTER
        CPP_METHOD_SETTER_CALL
        CPP_NEW
        CPP_PRINT_NATIVE_STREAM
        CPP_PRINT_STREAM
        CPP_REFERENCED_METHOD_CALL
        CPP_RETURN
        CPP_SIGNAL
        CPP_SLOT_VALUE_SETTER
        CPP_THROW
        ;; This is slightly problematic for cases where we want to generate
        ;;    unterminated preprocessor directives, but  most of those can be
        ;;    handled by adding an extra newline after the directive.  If we
        ;;    change this we also have to fix inlining of verbatim expressions
        ;;    that become statements when they are inlined (e.g., NTH-SETTER).
        CPP_VERBATIM)
       (return TRUE))
      (otherwise NULL)))
  (return FALSE))

(defun (cpp-indent-statement? BOOLEAN) ((statement CONS))
  ;; Only indent selected statements.
  ;; E.g., don't indent a CPP_STATEMENTS statement
  (if (defined? statement)
      (return (not (member? (quote (CPP_STATEMENTS)) 
			    (first statement))))
      (return FALSE)) )

(defun (illegal-cpp-statement? BOOLEAN) ((statement CONS))
  ;; Return TRUE if statement is an illegal C++ statement (e.g., an identifier)
  ;; Ideally the walker shouldn't generate illegal statements, but for
  ;;   now I filter them out here.
  (when (defined? statement)
    (case (first statement)
      ((CPP_LITERAL CPP_IDENT)
       (return TRUE))
      (otherwise NULL)))
  (return FALSE))

(defun cpp-output-statements ((statementList CONS))
  ;; Output a list of C++ statements
  (foreach statement in statementList
      do ;; KLUDGE: some stuff that comes out of the walker
         ;;   is ignorable.  E.g., sometimes identifiers appear as statements
         (unless (illegal-cpp-statement? statement)
           (when (cpp-indent-statement? statement)
             (cpp-indent))
           (cpp-output-statement statement)
           (when (cpp-output-semicolon? statement)
             (print-stream *current-stream* ";" EOL)))) )

(defun cpp-maybe-output-statement-with-parentheses ((statement OBJECT))
  ;; If statement is an operator, enclose it with parentheses
  (let ((operator? (cpp-operator? statement)))
    (when operator?
      (print-stream *current-stream* "("))
    (cpp-output-statement statement)
    (when operator?
      (print-stream *current-stream* ")"))))


(defun cpp-output-stream-print-items ((items CONS))
  ;; Output the print items for a stream output statement.
  (foreach e in items
           do
           (print-stream *current-stream* " << ")
           (cpp-maybe-output-statement-with-parentheses e)))

(defun cpp-output-print-stream ((exps CONS))
  ;; Output a stream output statement.
  ;; First expression is the name of the stream, rest are items
  ;;   to print.
  (let ((stream (first exps)))
    (cond 
     ((eql? stream (quote CPP_STANDARD_OUT))
      (print-stream *current-stream* "std::cout"))
     ((eql? stream (quote CPP_STANDARD_ERROR))
      (print-stream *current-stream* "std::cerr"))
     (otherwise
      (print-stream *current-stream* "get_ostream(")
      (cpp-output-statement stream)
      (print-stream *current-stream* ")")))
    (cpp-output-stream-print-items (rest exps)) ))

(defun cpp-output-print-native-stream ((exps CONS))
  ;; Output a native stream output statement.
  ;; Like "cpp-output-print-stream" except we don't append
  ;;  "->native_stream" to the stream variable
  ;; First expression is the name of the stream, rest are items
  ;;   to print.
  (let ((stream (first exps)))
    (cond 
     ((eql? stream (quote CPP_STANDARD_OUT))
      (print-stream *current-stream* "std::cout"))
     ((eql? stream (quote CPP_STANDARD_ERROR))
      (print-stream *current-stream* "std::cerr"))
     (otherwise
      (unless *outputtingDefprint?*
	(print-stream *current-stream* "*("))
      (cpp-output-statement stream)
      (unless *outputtingDefprint?*
	(print-stream *current-stream* ")"))))
    (cpp-output-stream-print-items (rest exps)) ))

(defun (cpp-indentable-binary-operator? BOOLEAN) ((operator STRING-WRAPPER))
  ;; Return TRUE if the second argument of the operator should be broken 
  ;;   onto a new line.
  (return (member? (quote ("||" "&&")) operator)))

(defun (cpp-commutative-binary-operator? BOOLEAN) ((operator STRING-WRAPPER))
  ;; Return TRUE if operator is commutative, so that we don't need to
  ;;   use parentheses for nested invocations.
  (return (member? (quote ("+" "*")) operator) ))

(defun (cpp-binary-operator? BOOLEAN) ((statement OBJECT))
  ;; Return TRUE if the statment is an expression containing an operator
  (return 
    (and (cons? statement)
	 (eql? (quote CPP_BINARY_OP)
	       (value (cast statement CONS))))) )

(defun (cpp-operator? BOOLEAN) ((statement OBJECT))
  ;; Return TRUE if the statment is an expression containing an operator
  (return 
    (and (cons? statement)
	 (member? (quote (CPP_UNARY_OP CPP_BINARY_OP CPP_TERNARY_OP
				       CPP_ASSIGN CPP_SLOT_VALUE_SETTER))
		  (value (cast statement CONS))))) )

(defun (cpp-assignment? BOOLEAN) ((statement CONS))
  ;; Return TRUE if `statement' is an assignment statement.
  ;; THIS MIGHT BE OBSOLETE.
  (return (eql? (first statement) (quote CPP_ASSIGN))))

(defun cpp-output-unary-operator ((expression CONS))
  ;; Output a unary operator, which consists of a list of the form
  ;;    `(OP arg)' or `(arg OP)'.  Whether OP is prefix or postfix
  ;;    is decided by the type of the first argument, which means
  ;;    that for a postfix operator the argument has to be something
  ;;    other than a string.
  (let ((op STRING-WRAPPER NULL)
	(arg OBJECT NULL)
        (postfix? FALSE))
    (typecase (first expression)
      (STRING-WRAPPER
       (setq op (first expression))
       (setq arg (second expression)))
      (otherwise
       (setq op (second expression))
       (setq arg (first expression))
       (setq postfix? TRUE)))
    (unless postfix?
      (print-stream *current-stream* (wrapper-value op)))
    ;; Output parenthesis if we have a nested expression
    (cpp-maybe-output-statement-with-parentheses arg)
    (when postfix?
      (print-stream *current-stream* (wrapper-value op)))))
    
(defun (cpp-nested-operator-needs-parentheses? BOOLEAN)
    ((op STRING-WRAPPER) (nested OBJECT))
  ;; Return TRUE if a nested operator call needs to have
  ;; parentheses around it.  This is true for all operators
  ;; unless they are commutative and the same as the higher operator.
  (return (and (cpp-operator? nested)
	       (not (and (cpp-commutative-binary-operator? op)
			 (string-eql? op (third (cast nested CONS))))))))

(defun cpp-help-output-binary-operator ((expression CONS) (nestLevel INTEGER))
  ;; Helping function for `cpp-output-binary-operator'.  Implements
  ;;   semi-pretty formatting of binary operators such as `&&'.
  ;;   Each subexpression is placed on a new line and appropriately
  ;;   indented.
  ;; NOTE: For now, we indent expressions 4 spaces from the left
  ;;   margin.  This is a heuristic that matches the common 
  ;;   "if (" statement.  A more general algorithm would figure
  ;;   out the rightmost column of the top-level predicate.
  (let ((arg1 (first expression))
	(op STRING-WRAPPER (second expression))
	(arg2 (third expression)))
    ;; Output Parenthesis if we have nested expressions
    (when (cpp-nested-operator-needs-parentheses? op arg1)
      (print-stream *current-stream* "("))
    (if (cpp-binary-operator? op)
      (cpp-help-output-binary-operator (rest (cast arg1 CONS)) (+ nestLevel 1))
      (cpp-output-statement arg1))
    (when (cpp-nested-operator-needs-parentheses? op arg1)
      (print-stream *current-stream* ")"))
    (print-stream *current-stream* " ")
    (print-stream *current-stream* (wrapper-value op))
    (if (cpp-indentable-binary-operator? op)
      (progn
	(print-stream *current-stream* EOL)
	(cpp-indent)
	(print-stream *current-stream* "    ") ; See above note
	(print-spaces *current-stream* nestLevel))
      (print-stream *current-stream* " "))
    (when (cpp-nested-operator-needs-parentheses? op arg2)
      (print-stream *current-stream* "("))
    (if (cpp-binary-operator? arg2)
      (cpp-help-output-binary-operator (rest (cast arg2 CONS)) (+ nestLevel 1))
      (cpp-output-statement arg2))
    (when (cpp-nested-operator-needs-parentheses? op arg2)
      (print-stream *current-stream* ")")) ))

(defun cpp-output-binary-operator ((expression CONS))
  ;; Output an epression containing a binary operator, 
  ;; which consits of a list of the form (arg1 OP arg2)
  ;; NOTE: May eventually implement fancy formatting, e.g., if the
  ;;   expression doesn't fit on a line.
  (cpp-help-output-binary-operator expression 0) )

(defun cpp-output-ternary-operator ((expression CONS))
  ;; Output a TERNARY operator, which consits of a list of
  ;;   the form (arg1 OP1 arg2 OP2 arg3).
  ;; NOTE: May eventually implement fancy formatting, e.g., if the
  ;;   expression doesn't fit on a line.
  (let ((arg1 (first expression))
	(op1 STRING-WRAPPER (second expression))
	(arg2 (third expression))
	(op2 STRING-WRAPPER (fourth expression))
	(arg3 (fifth expression))
        (translatedArg STRING NULL))
    ;; Surround whole statement w/parens.
    ;; This avoids ambiguities, e.g.
    ;;   (a (choose x b (c x))) would translate to
    ;;   x ? b : x->c->a  w/o parens,
    ;;   (x ? b : x->c)->  w/ parens
    (print-stream *current-stream* "(")
    ;; Output Parenthesis if we have nested expressions
    (cpp-maybe-output-statement-with-parentheses arg1)
    (print-stream *current-stream* " ")
    (print-stream *current-stream* (wrapper-value op1))
    (print-stream *current-stream* " ")
    ;; The following causes problems in g++ 2.96, since the result type of
    ;;    the choose expression is `const char*' instead of `char*':
    ;;       char* foo = ((x < y) ? "<" : ">=");
    ;;    Casting the string constants to `char*' fixes the problem (not sure
    ;;    whether this is a bug or justified by ISO C++):
    (setq translatedArg
      (cpp-output-to-string
       (cpp-maybe-output-statement-with-parentheses arg2)))
    (when (eql? (nth translatedArg 0) #\")
      ;; we have a string constant, explicitly convert it to (char*):
      (print-stream *current-stream* "(char*)"))
    (print-stream *current-stream* translatedArg)
    (print-stream *current-stream* " ")
    (print-stream *current-stream* (wrapper-value op2))
    (print-stream *current-stream* " ")
    (setq translatedArg
      (cpp-output-to-string
       (cpp-maybe-output-statement-with-parentheses arg3) ))
    (when (eql? (nth translatedArg 0) #\")
      ;; we have a string constant, explicitly convert it to (char*):
      (print-stream *current-stream* "(char*)"))
    (print-stream *current-stream* translatedArg)
    (print-stream *current-stream* ")")))

(defun cpp-output-statement-line ((statement CONS))
  ;; Output a 1-line C++ statement.
  (cpp-output-statement (first statement))
  (foreach e in (rest statement)
           do
           (print-stream *current-stream* " ")
           (cpp-output-statement e))
  (print-stream *current-stream* ";" EOL))

(defun cpp-output-return ((returnStatement CONS))
  (print-stream *current-stream* "return")
  (when (defined? returnStatement)
    (print-stream *current-stream* " (")
    (cpp-output-statement returnStatement) 
    (print-stream *current-stream* ")")) )


;; Loop which doesn't translate correctly.  Use for pretty formatting
;;    of declarations
;  ;; Collect lengths of types
;    (foreach declaration in declarations 
;	     do
;	     (trace-values typeLengths)
;	     (setq typeLength 0)
;	     (foreach typeExpr in (first declaration) 
;		      do
;		      (setq typeLength (+ typeLength (wrapper-value typeExpr)))
;	     collect typeLength into typeLengths)

(defun cpp-output-type-expression ((typeExpression (CONS OF STRING-WRAPPER)))
  ;; Output a type expression, which is a list of type tokens
  ;;    (e.g., (static long int)).
  (foreach typeExpr in typeExpression
      do (print-stream *current-stream* (wrapper-value typeExpr) " ")) )

(defun cpp-output-typed-entity
    ((type OBJECT) (entity OBJECT) (initialValue OBJECT))
  ;; Output a typed entity of the form
  ;;    <type> <entity> [= <initalValue>]
  ;; Does the right thing for array `type's by folding `entity' inside the
  ;;    type at the appropriate position (C++ is so bizarre).
  ;; This can handle `type's and `entities' that are already translated as
  ;;    well as those that still need translation.
  ;; A non-null `initialValue' will generate an initial value expression.
  ;;    `initialValue' is assumed to not be translated already.
  (let ((arrayType? (cpp-translated-array-type? type)))
    (cond
     (arrayType?
      (let ((translatedType STRING NULL)
            (translatedEntity STRING NULL))
        (typecase type
          (CONS
           (unless (eql? (first type) (quote CPP_TYPE))
             (pushq type (quote CPP_TYPE)))
           (setq translatedType
             (cpp-output-to-string
              (cpp-output-statement type))))
          (STRING
           ;; already translated:
           (setq translatedType type)))
        (typecase entity
          (CONS
           (setq translatedEntity
             (cpp-output-to-string
              (cpp-output-statement entity))))
          (STRING
           ;; already translated:
           (setq translatedEntity entity)))
        (print-stream *current-stream*
                      (cpp-generate-array-typed-entity
                       translatedEntity translatedType))))
     (otherwise
      (typecase type
          (CONS
           (unless (eql? (first type) (quote CPP_TYPE))
             (pushq type (quote CPP_TYPE)))
           (cpp-output-statement type))
          (STRING
           ;; already translated:
           (print-stream *current-stream* (wrapper-value type) " ")))
      (typecase entity
          (CONS
           (cpp-output-statement entity))
          (STRING
           (print-stream *current-stream* (wrapper-value entity))))))
    (when (defined? initialValue)
      (print-stream *current-stream* " = ")
      (cpp-output-statement initialValue))))

(defun cpp-output-declarations ((accessControlMode KEYWORD) 
				(declarations (CONS OF CONS)))
  ;; Output a list of declarations.  Declarations of the form
  ;;   (TYPE VAR [DOC]), where TYPE is a list of type expressions
  ;;   (e.g., (static long int)), VAR is the name of a variable
  ;;   (e.g., x) or a function (e.g., f()), and DOC is an optional
  ;;   documenation string.
  ;;
  (cpp-indent)
  (case accessControlMode
    (:PUBLIC (print-stream *current-stream* "public:" EOL))
    (:PRIVATE (print-stream *current-stream* "private:" EOL))
    (:PROTECTED (print-stream *current-stream* "protected:" EOL)))
  (when (defined? accessControlMode)
    (cpp-bump-indent))
  (foreach declaration in declarations 
      do (when (defined? (third declaration))
	   (cpp-indent)
	   (cpp-output-comment (third declaration)))
	 (cpp-indent)
         (cpp-output-typed-entity
          (first declaration) (second declaration) NULL)
         (print-stream *current-stream* ";" EOL))
  (when (defined? accessControlMode)
    (cpp-unbump-indent)) )

(defun cpp-output-signature ((signature CONS) (outputMethodClass? BOOLEAN))
  ;; Output a C++ signature.  `signature' is of the form
  ;;    (<methodClass> <returnType> <name> <parameters>).
  (let ((methodClass STRING-WRAPPER (first signature))
        (returnType (second signature))
        (name STRING-WRAPPER (third signature))
        (parameters (fourth signature))
        (bareSignature
         ;; To handle array return types where we have to wrap the whole
         ;;    signature inside the type, we output to a string here (we
         ;;    could avoid this for normal return types, but hey):
         (cpp-output-to-string
          (progn
            (when (and outputMethodClass?
                       (defined? methodClass))
              (print-stream *current-stream* (wrapper-value methodClass))
              (print-stream *current-stream* "::"))
            (print-stream *current-stream* (wrapper-value name))
            (cpp-output-formal-parameters parameters)))))
    (cpp-output-typed-entity returnType bareSignature NULL)))

(defun cpp-output-signatures ((accessControlMode KEYWORD) (signatures CONS))
  ;; Output a list of signatures (i.e. function prototypes).
  ;;   Signatures are of the form (RETURN-TYPE FUNCTION-NAME PARAMETERS).
  (cpp-indent)
  (case accessControlMode
    (:PUBLIC (print-stream *current-stream* "public:" EOL))
    (:PRIVATE (print-stream *current-stream* "private:" EOL))
    (:PROTECTED (print-stream *current-stream* "protected:" EOL)))
  (when (defined? accessControlMode)
    (cpp-bump-indent))
  (foreach signature in signatures 
      do (cpp-indent)
         (cpp-output-signature signature FALSE)
         (print-stream *current-stream* ";" EOL))
  (when (defined? accessControlMode)
    (cpp-unbump-indent)) )

(defun cpp-output-definitions ((accessControlMode KEYWORD) (definitions CONS))
  ;; Output a list of `definitions' (e.g., constructors or inline functions).
  (cpp-indent)
  (case accessControlMode
    (:PUBLIC (print-stream *current-stream* "public:" EOL))
    (:PRIVATE (print-stream *current-stream* "private:" EOL))
    (:PROTECTED (print-stream *current-stream* "protected:" EOL)))
  (when (defined? accessControlMode)
    (cpp-bump-indent))
  (foreach definition in definitions
      do (cpp-indent)
         (cpp-output-statement definition))
  (when (defined? accessControlMode)
    (cpp-unbump-indent)))

(defun cpp-output-progn ((progn CONS))
  ;; Output a C++ progn, e.g., a block without declarations as used
  ;;   in a for loop, if statement, etc.
  ;; Progn has the form <STATEMENTS>
  (print-stream *current-stream* "{" EOL)
  (cpp-bump-indent)
  (cpp-output-statement progn)
  (cpp-unbump-indent)
  (cpp-indent)
  (print-stream *current-stream* "}" EOL) )

(defun cpp-output-block ((block CONS))
  ;; Output a C++ block as in a let statement.  Blocks are of the form
  ;;    (<DECLARATIONS> <STATEMENTS>).
  ;; TODO: Fix this so curly braces don't show up if there is only
  ;;    a single block within another block (e.g. a function containing
  ;;    only one block).
  (let ((firstStatement? TRUE))
    (print-stream *current-stream* "{ ")
    (cpp-bump-indent)
    ;; Declarations have form "(TYPE LVALUE RVALUE)"
    (foreach declaration in (cast (first block) (CONS OF CONS))
        do (unless firstStatement?
             (cpp-indent))
           (setq firstStatement? FALSE)
           (cpp-output-typed-entity
            (first declaration) (second declaration) (third declaration))
           (print-stream *current-stream* ";" EOL))
    (print-stream *current-stream* EOL)
    (cpp-output-statement (second block))
    (cpp-unbump-indent)
    (cpp-indent)
    (print-stream *current-stream* "}" EOL)) )

(defun cpp-output-with-process-lock ((synch CONS))
  ;; Currently just output a Progn, ignoring the lock form:
  (let ((s (new STRING-OUTPUT-STREAM)))
    (special ((*current-stream* s))
      (cpp-output-statement (first synch)))
    (cpp-output-comment (concatenate "Should be synchronized on process lock " (the-string s)))
    (cpp-indent))
  (cpp-output-progn (second synch)))
		
(defun cpp-output-static-member-vars ((class STRING-WRAPPER)
                                      (declarations (CONS OF CONS)))
  ;; Output a list of static member variable declarations.
  ;;   Declarations of the form
  ;;   (TYPE VAR INIT), where TYPE is a list of type expressions
  ;;   (e.g., (static long int)), VAR is the name of a variable
  ;;   (e.g., x) or a function (e.g., f()), and INIT is the initial
  ;;   value.
  (foreach declaration in declarations 
      do (cpp-indent)
         (cpp-output-typed-entity
          (first declaration)
          (concatenate (wrapper-value class) "::"
                       (wrapper-value 
                        (cast (second declaration) STRING-WRAPPER)))
          (third declaration))
         (print-stream *current-stream* ";" EOL))
  (when (non-empty? declarations)
    (print-stream *current-stream* EOL)) )

(defun cpp-output-derived-classes ((classList CONS))
  ;; Output a list of derived classes.
  (when (defined? (first classList))
    (print-stream *current-stream*
                  (wrapper-value (cast (first classList) STRING-WRAPPER))))
  (foreach class in (rest classList)
           do (print-stream *current-stream* ", public ")
           (case (translator-output-language)
             (:cpp-standalone (print-stream *current-stream* "virtual "))
             (otherwise NULL))
           (print-stream *current-stream* 
                         (wrapper-value (cast class STRING-WRAPPER))))
  (print-stream *current-stream*  " "))

(defun cpp-output-template-parameters ((parameters CONS))
  ;; Output a list of class parameters
  (when (non-empty? parameters)
    (print-stream *current-stream* "template <")
    (print-stream *current-stream* 
                  "class " (wrapper-value 
                            (cast (first parameters) STRING-WRAPPER)))
    (foreach parameter in (rest parameters)
             do
             (print-stream *current-stream* 
                           "class " (cast parameter STRING-WRAPPER) ", "))
    (print-stream *current-stream* ">" EOL)) )

(defun (cpp-output-template-classes? BOOLEAN) ()
  ;; Return TRUE if we are outputting parameterized classes as templates
  (return (eql? (translator-output-language) :cpp-standalone)) )

(defun cpp-output-class ((classDef CONS))
  ;; Output a C++ class definition.
  (when (cpp-output-template-classes?)
    (cpp-output-template-parameters (second classDef)))
  (print-stream *current-stream* "class "
		(wrapper-value (cast (first classDef) STRING-WRAPPER)) " ")
  (when (non-empty? (cast (third classDef) CONS))
    (print-stream *current-stream* ": public ")
    (case (translator-output-language)
      (:cpp-standalone (print-stream *current-stream* "virtual "))
      (otherwise NULL))
    (cpp-output-derived-classes (third classDef)))
  (print-stream *current-stream* "{" EOL)
  (foreach statement in (nth-rest classDef 4)
      do (cpp-output-statement statement))
  (print-stream *current-stream* "};" EOL EOL) 
  (cpp-output-static-member-vars
   (first classDef) (cast (fourth classDef) (CONS OF CONS))) )
   
(defun cpp-output-formal-parameters ((parameters (CONS OF CONS)))
  ;; Output C++ formal parameters.
  (let ((n-parameters (length parameters))
        (variable-arguments? FALSE))
    (print-stream *current-stream* "(")
    ;; The last parameter needs special handling to allow
    ;; for variable arguments:
    (foreach parameter in parameters
             as n in (interval 1 n-parameters)
             do (if (= n n-parameters)  ; last parameter
                  (progn 
                    (setq variable-arguments?
                          (eql? (first parameter) (quote CPP_VAR_ARGS)))
                    (cpp-output-typed-entity
                     (choose variable-arguments?
                             "int"
                             (first parameter))
                     (second parameter)
                     NULL)
                    (when variable-arguments?
                      (print-stream *current-stream* ", ...")))
                  (progn
                    (cpp-output-typed-entity
                     (first parameter) (second parameter) NULL)
                    (print-stream *current-stream* ", ")
                    )))
    (print-stream *current-stream* ")")))

(defun (cpp-argument-is-stream? BOOLEAN) ((arg OBJECT))
  ;; Helping function for `cpp-output-one-actual-parameter'.
  ;; Return TRUE if the argument is `stream' in a call inside a defprint.
  (typecase arg
    (CONS
     (return
       (and (eql? (first arg) (quote CPP_IDENT))
	    (eql? (second arg) "stream"))))
    (otherwise
     (return FALSE))))

(defun cpp-output-one-actual-parameter ((parameter OBJECT))
  ;; Output parameter expression
  ;; UGLY: If we are outputting a defprint form, we check
  ;;   if the parameter is a stream, and take the address
  ;;   of the stream if it is.
  (if (and *outputtingDefprint?* 
           (cpp-argument-is-stream? parameter))
    (progn
      (print-stream *current-stream* "&")
      (cpp-output-statement parameter))
    (cpp-output-statement parameter)) )

(defun cpp-output-actual-parameters ((parameters CONS))
  ;; Output C++ actual parameters for function call
  (print-stream *current-stream* "(")
  (when (defined? (first parameters))
    (cpp-output-one-actual-parameter (first parameters)))
  (foreach parameter in (rest parameters)
           do (print-stream *current-stream* ", ")
           (cpp-output-one-actual-parameter parameter))
  (print-stream *current-stream* ")"))

(defun cpp-output-method-setter-call ((methodSetterCall CONS))
  ;; Output a C++ method setter.
  ;; 'methodSetterCall' has the form 
  ;;    '(<methodName> <objRef> <valueRef>)'.
  ;; NOTE: For now, the syntax is just a call to a member function,
  ;;  which we assume returns a reference to the appropriate storage
  ;;  location
  (cpp-maybe-output-statement-with-parentheses (second methodSetterCall))
  (print-stream *current-stream* "->")
  (cpp-output-statement (first methodSetterCall))
  (print-stream *current-stream* "_setter(")
  (cpp-output-statement (third methodSetterCall))
  (print-stream *current-stream* ")") )

(defun cpp-output-method-call ((methodCall CONS))
  ;; Output a C++ method call.
  ;; "methodCall" has format (<type> <methodName> <object> <args>)
  ;; Class name (for now commented out):
;  (cpp-output-statement (first methodCall))
;  (print-stream *current-stream* "::")
  ;; Object:
  (cpp-maybe-output-statement-with-parentheses (third methodCall))
  (print-stream *current-stream* "->")
  ;; Method name
  (cpp-output-statement (second methodCall))
  ;; Actual parameters
  (cpp-output-statement (fourth methodCall)) )

(defun cpp-output-referenced-method-call ((methodCall CONS))
  ;; Output a referenced (not pointer-based) C++ method call
  ;; "methodCall" has format (<type> <methodName> <object> <args>)
  ;; Class name (for now commented out)
;  (cpp-output-statement (first methodCall))
;  (print-stream *current-stream* "::")
  ;; Object
  (cpp-maybe-output-statement-with-parentheses (third methodCall))
  (print-stream *current-stream* ".")
  ;; Method name
  (cpp-output-statement (second methodCall))
  ;; Actual parameters
  (cpp-output-statement (fourth methodCall)) )

(defun cpp-output-function-call ((functionCall CONS))
  ;; Output a C++ function call
  ;; "functionCall" has format (<functionName> <args>)
  ;; Function name
  (cpp-output-statement (first functionCall))
  ;; Actual parameters
  (cpp-output-statement (second functionCall)) )

(defun cpp-output-defprint-signature ((defprint CONS))
  ;; Output the signature for a defprint
  (print-stream *current-stream*
                "std::ostream& operator << (std::ostream& stream, ")
  (print-stream *current-stream* 
		(wrapper-value (cast (first defprint) STRING-WRAPPER)))
  (print-stream *current-stream* " self)") )

(defun cpp-output-defprint ((defprint CONS))
  ;; Outupt a C++ angle-bracket overload (i.e. insertion operator)
  (cpp-output-defprint-signature defprint)
  (print-stream *current-stream* " {" EOL)
  (cpp-bump-indent)
  ;; The flag *outputtingDefprint?* ensures that print-native-stream
  ;;  forms *do not* dereference their streams inside the defprint.
  (special ((*outputtingDefprint?* TRUE))
	   (cpp-output-statement (second defprint)))
  (cpp-unbump-indent)
  (print-stream *current-stream* "}" EOL)
  (print-stream *current-stream* EOL) )

(defun cpp-output-function-signature ((function CONS))
  ;; Output the signature for a function.
  (let ((bareSignature
         ;; To handle array return types where we have to wrap the whole
         ;;    signature inside the type, we output to a string here (we
         ;;    could avoid this for normal return types, but hey):
         (cpp-output-to-string
          (progn
            (print-stream *current-stream*
                          (wrapper-value 
                           (cast (second function) STRING-WRAPPER)))
            (cpp-output-formal-parameters (third function))))))
    (cpp-output-typed-entity (first function) bareSignature NULL)))

(defun cpp-output-function ((function CONS))
  ;; Output a C++ function (or method) definition.  `function' has the form
  ;;    (<returnType> <name> <parameters> <body> [<baseMembers>]).
  (let ((body (fourth function))
        (baseMembers CONS (fifth function)))
    (cpp-output-function-signature function)
    (when (defined? baseMembers)
      ;; we are outputting a constructor:
      (print-stream *current-stream* " : ")
      (foreach member in baseMembers
          do (cpp-output-statement member)))
    (print-stream *current-stream* " {" EOL)
    ;; list of statements 
    (cpp-bump-indent)
    (cpp-output-statement body)
    (cpp-unbump-indent)
    (print-stream *current-stream* "}" EOL)
    (print-stream *current-stream* EOL)))
