<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<!-- Created on May, 21  2006 by texi2html 1.65 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>STELLA Manual: The STELLA Language</TITLE>

<META NAME="description" CONTENT="STELLA Manual: The STELLA Language">
<META NAME="keywords" CONTENT="STELLA Manual: The STELLA Language">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.65">

</HEAD>

<BODY LANG="en" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC11"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_2.html#SEC10"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC12"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_2.html#SEC3"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC21"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 3. The STELLA Language </H1>
<!--docid::SEC11::-->
<P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_3.html#SEC12">3.1 Language Overview</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_3.html#SEC13">3.2 Basic Data Types (tbw)</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_3.html#SEC14">3.3 Control Structure (tbc)</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_3.html#SEC16">3.4 Functions (tbw)</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_3.html#SEC17">3.5 Classes (tbw)</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_3.html#SEC18">3.6 Methods (tbw)</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_3.html#SEC19">3.7 Macros (tbw)</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_3.html#SEC20">3.8 Modules (tbw)</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Language Overview"></A>
<HR SIZE="6">
<A NAME="SEC12"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC11"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC13"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC11"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC11"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC21"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 3.1 Language Overview </H2>
<!--docid::SEC12::-->
<P>

STELLA is a strongly typed, object-oriented, Lisp-like language.  STELLA
programs are first translated into either Common Lisp, C++, or Java, and then
compiled with any conventional compiler for the chosen target language to
generate executable code.  Over 95% of the STELLA system is written in STELLA
itself, the rest is written in target-language-specific native code.
</P><P>

The design of STELLA borrows from a variety of programming languages, most
prominently from Common Lisp, and to a lesser degree from other
object-oriented languages such as Eiffel, Sather, and Dylan.  Since STELLA has
to be translatable into C++ and Java, various restrictions of these languages
also influenced its design.
</P><P>

In the following, we assume that the reader is familiar with basic Common Lisp
concepts, and has at least some familiarity with C++ or Java.  Let us start
with a cursory overview of STELLA's main features:
</P><P>

<STRONG>Syntax:</STRONG> STELLA uses a parenthesized, uniform expression syntax
similar to Lisp.  Most definitional constructs and control structures
are similar to their Common Lisp analogues with variations to support
types.
</P><P>

<STRONG>Type system:</STRONG> STELLA is strongly typed and supports efficient
static compilation similar to C++.  Types are required for the arguments
and return values of functions and methods, for global variables, and
for slot definitions.  Local, lexically scoped variables can be typed
implicitly by relying on type inference.
</P><P>

<STRONG>Object system:</STRONG> Types are organized into a single inheritance
class hierarchy.  Restricted multiple inheritance is allowed via mixin
classes.  Dynamic method dispatch is based on the runtime type of the
first argument (similar to C++ and Java).  Slots can be static (native)
or dynamic.  Dynamic slots can be defined at runtime and do not occupy
any space until they are filled.  Slots can have both initial and
default values, and demons can be triggered by slot accesses.  A
meta-object protocol allows the control of object creation,
initialization, termination, and destruction.
</P><P>

<STRONG>Control structure:</STRONG> Functions and methods are distinguished.
They can have multiple (zero or more) return values and a variable
number of arguments.  Lisp-style macros are supported to facilitate
syntax extensions.  Expressions and statements are distinguished.  Local
variables are lexically scoped, but dynamically scoped variables
(specials) are also supported.  STELLA has an elegant, uniform, and
efficient iteration mechanism plus a built-in protocol for iterators.
An exception mechanism can be used for error handling and non-local
exits.
</P><P>

<STRONG>Symbolic programming:</STRONG> Symbols are first-class objects, and
extensive support for dynamic datatypes such as cons-trees, lists, sets,
association lists, hash tables, extensible vectors, etc., is available.
A backquote mechanism facilitates macro writing and code generation.
Interpreted function call, method call, slot access, and object creation
is supported, and a restricted evaluator is also available.
</P><P>

<STRONG>Name spaces:</STRONG> Functions, methods, variables, and classes occupy
separate name spaces (i.e., the same name can be used for a function and
a class).  A hierarchical module system compartmentalizes symbol tables
and supports large-scale programming.
</P><P>

<STRONG>Memory management:</STRONG> STELLA relies on automatic memory management
via a garbage collector.  For Lisp and Java the native garbage collector
is used.  For the C++ version of STELLA we use the Boehm- Weiser
conservative garbage collector with good results.  Various built-in
support for explicit memory management is also available.
</P><P>

The Common Lisp features most prominently absent from STELLA are anonymous
functions via lambda abstraction, lexical closures, multi-methods,
full-fledged eval (a restricted evaluator is available), optional and keyword
arguments, and a modifiable readtable.  STELLA does also not allow dynamic
re/definition of functions and classes, even though the Lisp-based development
environment provides this facility (similar to Dylan).  The main influences of
C++ and Java onto STELLA are the strong typing, limited multiple inheritance,
first-argument polymorphism, and the distinction between statements and
expressions.
</P><P>

<A NAME="Basic Data Types"></A>
<HR SIZE="6">
<A NAME="SEC13"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC12"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC14"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC11"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC11"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC21"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 3.2 Basic Data Types (tbw) </H2>
<!--docid::SEC13::-->
To be written.
<P>

<A NAME="Control Structure"></A>
<HR SIZE="6">
<A NAME="SEC14"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC13"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC15"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC11"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC11"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC16"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 3.3 Control Structure (tbc) </H2>
<!--docid::SEC14::-->
To be completed.
<P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_3.html#SEC15">3.3.1 Conditionals</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Conditionals"></A>
<HR SIZE="6">
<A NAME="SEC15"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC14"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC16"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC13"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC14"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC16"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.3.1 Conditionals </H3>
<!--docid::SEC15::-->
<P>

STELLA conditionals are very similar to those found in Common-Lisp.
The main difference is that most STELLA conditionals are statements and
therefore do not return a value.  For this reason, a C++-style
<CODE>choose</CODE> directive has been added to the language to allow value
conditionalization based on a boolean expression.
</P><P>

<A NAME="IDX1"></A>
<DL>
<DT><U>Statement:</U> <B>if</B> <I>condition then-statement else-statement</I>
<DD>Evaluate the boolean expression <VAR>condition</VAR>.  If the result is true
execute <VAR>then-statement</VAR>, otherwise, execute <VAR>else-statement</VAR>.
Note that unlike the Common-Lisp version of <CODE>if</CODE> the
<VAR>else-statement</VAR> is not optional in STELLA.  Example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(if (&#62; x y)
    (print "x is greater than y" EOL)
  (print "x is less than or equal to y" EOL))
</pre></td></tr></table></DL>
</P><P>

<A NAME="IDX2"></A>
<DL>
<DT><U>Statement:</U> <B>when</B> <I>condition statement<small>...</small></I>
<DD>Evaluate the boolean expression <VAR>condition</VAR>.  Only if the result is
true execute the <VAR>statement'</VAR>s in the body.  Example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(when (symbol? x)
  (print "x is a symbol, ")
  (print "its name is " (symbol-name (cast x SYMBOL)) EOL))
</pre></td></tr></table></DL>
</P><P>

<A NAME="IDX3"></A>
<DL>
<DT><U>Statement:</U> <B>unless</B> <I>condition statement<small>...</small></I>
<DD>Evaluate the boolean expression <VAR>condition</VAR>.  Only if the result is
false execute the <VAR>statement'</VAR>s in the body.  Therefore,
<CODE>(unless <VAR>test</VAR> <small>...</small>)</CODE> is equivalent to <CODE>(when (not
<VAR>test</VAR>) <small>...</small>)</CODE>.  Example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(unless (symbol? x)
  (print "x is not a symbol, ")
  (print "hence, its name is unknown" EOL))
</pre></td></tr></table></DL>
</P><P>

<A NAME="IDX4"></A>
<DL>
<DT><U>Statement:</U> <B>cond</B> <I>clause<small>...</small></I>
<DD><CODE>cond</CODE> is a conditional with an arbitrary number of conditions each
represented by a <VAR>clause</VAR>.  Each <CODE>cond</CODE> clause has to be of the
following form:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>(<VAR>condition</VAR> <VAR>statement</VAR><small>...</small>)
</pre></td></tr></table>The first <VAR>clause</VAR> whose <VAR>condition</VAR> evaluates to true will be
selected and its <VAR>statement'</VAR>s will be executed.  Each clause can
have 0 or more statements.  The special condition <CODE>otherwise</CODE>
always evaluates to true and can be used for the catch-all case.
Example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(cond ((symbol? x)
       (print "x is a symbol" EOL))
      ((cons? x)
       (print "x is a cons" EOL))
      (otherwise
       (print "x is an object" EOL)))
</pre></td></tr></table></DL>
</P><P>

<A NAME="IDX5"></A>
<DL>
<DT><U>Expression:</U> <B>choose</B> <I>condition true-expression false-expression</I>
<DD>Evaluate the boolean expression <VAR>condition</VAR>.  If the result is true
return the value of <VAR>true-expression</VAR>, otherwise, return the value
of <VAR>false-expression</VAR>.  STELLA computes the most specific common
supertype of <VAR>true-expression</VAR> and <VAR>false-expression</VAR> and uses
that as the type returned by the <CODE>choose</CODE> expression.  If no such
type exists, a translation error will be signaled.  Example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(setq face (choose happy? :smile :frown))
</pre></td></tr></table></DL>
</P><P>

<A NAME="IDX6"></A>
<DL>
<DT><U>Statement:</U> <B>case</B> <I>expression clause<small>...</small></I>
<DD>Each <CODE>case</CODE> clause has to be of one of
the following forms:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(<VAR>key</VAR> <VAR>statement</VAR><small>...</small>)
((<VAR>key</VAR><small>...</small>) <VAR>statement</VAR><small>...</small>)
</pre></td></tr></table></P><P>

<CODE>case</CODE> selects the first <VAR>clause</VAR> whose <VAR>key</VAR> (or one of
the listed <VAR>key'</VAR>s) matches the result of <VAR>expression</VAR> and
executes the clause's <VAR>statement'</VAR>s.  Each <CODE>case</CODE> <VAR>key</VAR> has
to be a constant such as a number, character, string, symbol, keyword or
surrogate.  Keys are compared with <CODE>eql?</CODE> (or <CODE>string-eql?</CODE> 
for strings).  All keys in a <CODE>case</CODE> statement have to be of the
same type.  The special key <CODE>otherwise</CODE> can be used to catch
everything.  It is a run-time error if no clause with a matching key
exists.  Therefore, a STELLA <CODE>case</CODE> without an <CODE>otherwise</CODE>
clause corresponds to a Common Lisp <CODE>ecase</CODE>.  An empty
<CODE>otherwise</CODE> clause can always be specified via <CODE>(otherwise
NULL)</CODE>.  Example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(case car-make
  ("Yugo" 
   (setq price :cheap))
  ("VW"   
   (setq price :medium))
  (("Ferrari" "Rolls Royce")
   (setq price :expensive))
  (otherwise 
   (setq price :unknown)))
</pre></td></tr></table></DL>
</P><P>

<A NAME="IDX7"></A>
<DL>
<DT><U>Statement:</U> <B>typecase</B> <I>expression clause<small>...</small></I>
<DD>Each <CODE>typecase</CODE> clause has to be of one of
the following forms:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(<VAR>type</VAR> <VAR>statement</VAR><small>...</small>)
((<VAR>type</VAR><small>...</small>) <VAR>statement</VAR><small>...</small>)
</pre></td></tr></table></P><P>

<CODE>typecase</CODE> selects the first <VAR>clause</VAR> whose <VAR>type</VAR> (or one
of the listed <VAR>type'</VAR>s) equals or is a supertype of the run-time
type of the result of <VAR>expression</VAR> and then executes the clause's
<VAR>statement'</VAR>s.  Therefore, <CODE>typecase</CODE> can be used to implement
a type dispatch for cases where the run-time type of an expression can
be different from the static type known at translation time.  Currently,
the static type of <VAR>expression</VAR> is required to be a subtype of
<CODE>OBJECT</CODE>.
</P><P>

Each <VAR>type</VAR> expression has to be a symbol describing a simple type
(i.e., parametric or anchored types are not allowed).  Similar to
<CODE>case</CODE>, the special key <CODE>otherwise</CODE> can be used to catch
everything.  It is a run-time error if no clause with a matching type
exists.  Therefore, a STELLA <CODE>typecase</CODE> without an <CODE>otherwise</CODE>
clause corresponds to a Common Lisp <CODE>etypecase</CODE>.  An empty
<CODE>otherwise</CODE> clause can always be specified via <CODE>(otherwise
NULL)</CODE>.  <CODE>typecase</CODE> does allow the value of <VAR>expression</VAR> to be
undefined, in which case the <CODE>otherwise</CODE> clause is selected.
Example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(typecase (first list)
  (CONS
   (print "it is a cons"))
  ((SYMBOL KEYWORD)
   (print "it is a symbol"))
  (STANDARD-OBJECT
   (print "it is a regular object"))
  (otherwise NULL))
</pre></td></tr></table></P><P>

Note that in the example above it is important to list
<CODE>STANDARD-OBJECT</CODE> after <CODE>SYMBOL</CODE> and <CODE>CONS</CODE>, since it
subsumes the preceding types.  Otherwise, it would always shadow the
clauses with the more specific types.
</P><P>

The semantics of <CODE>typecase</CODE> is slightly extended for the case where
<VAR>expression</VAR> is a local variable.  In that case each reference to
the variable within a <CODE>typecase</CODE> clause is automatically casted to
the appropriate narrower type.  For example, in the code snippet below
method calls such as <CODE>first</CODE> or slot accesses such as
<CODE>symbol-name</CODE> are translated correctly without needing to
explicitly downcast <CODE>x</CODE> which is assumed to be of type
<CODE>OBJECT</CODE>:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(typecase x
  (CONS
   (print "it is a cons with value " (first x)))
  ((SYMBOL KEYWORD)
   (print "it is a symbol with name " (symbol-name x)))
  (STANDARD-OBJECT
   (print "it is a regular object"))
  (otherwise NULL))
</pre></td></tr></table></DL>
</P><P>

Since the <CODE>typecase</CODE> <VAR>expression</VAR> has to be a subtype of
<CODE>OBJECT</CODE>, a <CODE>typecase</CODE> cannot be used to test against literal
types such as <CODE>STRING</CODE> or <CODE>INTEGER</CODE>.  If such type names are
encountered as keys in a <CODE>typecase</CODE>, they are automatically
converted to their wrapped version, e.g., <CODE>STRING-WRAPPER</CODE>,
<CODE>INTEGER-WRAPPER</CODE>, etc.
</P><P>

<A NAME="Functions"></A>
<HR SIZE="6">
<A NAME="SEC16"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC15"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC17"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC14"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC11"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC21"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 3.4 Functions (tbw) </H2>
<!--docid::SEC16::-->
To be written.
<P>

<A NAME="Classes"></A>
<HR SIZE="6">
<A NAME="SEC17"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC16"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC18"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC11"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC11"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC21"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 3.5 Classes (tbw) </H2>
<!--docid::SEC17::-->
To be written.
<P>

<A NAME="Methods"></A>
<HR SIZE="6">
<A NAME="SEC18"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC17"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC19"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC11"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC11"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC21"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 3.6 Methods (tbw) </H2>
<!--docid::SEC18::-->
To be written.
<P>

<A NAME="Macros"></A>
<HR SIZE="6">
<A NAME="SEC19"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC18"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC20"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC11"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC11"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC21"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 3.7 Macros (tbw) </H2>
<!--docid::SEC19::-->
To be written.
<P>

<A NAME="Modules"></A>
<HR SIZE="6">
<A NAME="SEC20"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC19"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC21"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC11"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC11"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC21"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 3.8 Modules (tbw) </H2>
<!--docid::SEC20::-->
To be written.
<P>

<A NAME="Programming in STELLA"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC11"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC21"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Hans Chalupsky</I> on <I>May, 21  2006</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>
</FONT>

</BODY>
</HTML>
