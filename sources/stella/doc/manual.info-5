This is manual.info, produced by makeinfo version 4.2 from manual.texi.

   This file documents the STELLA programming language.

   Copyright (C) 2003 University of Southern California, Information
Sciences Institute 4676 Admiralty Way Marina Del Rey, CA 90292

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.


File: manual.info,  Node: Miscellaneous,  Prev: XML Support,  Up: Library Functions

Miscellaneous
=============

   This is a catch-all section for functions and methods that haven't
been categorized yet into any of the previous sections.  They are in
random order and many of them will never be part of the official STELLA
interface.  So beware!

 - Function: operating-system () : KEYWORD
     Not documented.

 - Function: acos ((n FLOAT)) : FLOAT
     Return the arccosine of N in radians.

 - Function: activate-demon ((demon DEMON)) :
     Install DEMON in the location(s) specified by its internal
     structure.

 - Method: active? ((self POLYMORPHIC-RELATION)) : BOOLEAN
     True if SELF or a superslot of SELF is marked active.

 - Function: add-hook ((hookList HOOK-LIST) (hookFunction SYMBOL)) :
     Insert the function named HOOKFUNCTION into HOOKLIST.

 - Command: add-trace (&rest (keywords GENERALIZED-SYMBOL)) : LIST
     Enable trace messages identified by any of the listed KEYWORDS.
     After calling (`add-trace' <keyword>) code guarded by (`trace-if'
     <keyword> ...)  will be executed when it is encountered.

 - Function: all-classes ((module MODULE) (local? BOOLEAN)) : (ITERATOR
          OF CLASS)
     Iterate over all classes visible from MODULE.  If LOCAL?, return
     only classes interned in MODULE.  If MODULE is null, return all
     classes interned everywhere.

 - Function: all-contexts () : (ITERATOR OF CONTEXT)
     Return an iterator that generates all contexts.

 - Macro: all-defined? (&body (forms CONS)) : OBJECT
     Evaluate each of the forms in FORMS, and return TRUE if none of
     them are NULL.

 - Function: all-functions ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF FUNCTION)
     Iterate over all functions visible from MODULE.  If LOCAL?, return
     only functions bound to symbols interned in MODULE.  If MODULE is
     null, return all functions defined everywhere.

 - Function: all-included-modules ((self MODULE)) : (ITERATOR OF MODULE)
     Generate a sequence of all modules included by SELF, inclusive,
     starting from the highest ancestor and working down to SELF (which
     is last).

 - Function: all-methods ((module MODULE) (local? BOOLEAN)) : (ITERATOR
          OF METHOD-SLOT)
     Iterate over all methods visible from MODULE.  If LOCAL?, return
     only methods interned in MODULE.  If MODULE is null, return all
     methods interned everywhere.

 - Function: all-modules () : (ITERATOR OF MODULE)
     Return an iterator that generates all modules.

 - Function: all-public-functions ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF FUNCTION)
     Iterate over all functions visible from MODULE.  If LOCAL?, return
     only functions bound to symbols interned in MODULE.  If MODULE is
     null, return all functions defined everywhere.

 - Function: all-public-methods ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF METHOD-SLOT)
     Iterate over all public methods visible from MODULE.  If LOCAL?,
     return only methods interned in MODULE.  If MODULE is null, return
     all methods interned everywhere.

 - Function: all-slots ((module MODULE) (local? BOOLEAN)) : (ITERATOR
          OF SLOT)
     Iterate over all slots visible from MODULE.  If LOCAL?, return
     only methods interned in MODULE.  If MODULE is null, return all
     methods interned everywhere.

 - Function: all-subcontexts ((context CONTEXT) (traversal KEYWORD)) :
          (ALL-PURPOSE-ITERATOR OF CONTEXT)
     Return an iterator that generates all subcontexts of `self' (not
     including `self') in the order specified by TRAVERSAL (one of
     :preorder, :inorder, or :postorder).

 - Function: all-surrogates ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF SURROGATE)
     Iterate over all surrogates visible from MODULE.  If LOCAL?,
     return only surrogates interned in MODULE.  If MODULE is null,
     return all surrogates interned everywhere.

 - Function: all-symbols ((module MODULE) (local? BOOLEAN)) : (ITERATOR
          OF SYMBOL)
     Iterate over all symbols visible from MODULE.  If LOCAL?, return
     only symbols interned in MODULE.  If MODULE is null, return all
     symbols interned everywhere.

 - Function: all-variables ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF GLOBAL-VARIABLE)
     Iterate over all variables visible from MODULE.  If LOCAL?, return
     only variables bound to symbols interned in MODULE.  If MODULE is
     null, return all variables defined everywhere.

 - Method: allocate-iterator ((self ABSTRACT-ITERATOR)) : (LIKE SELF)
     Iterator objects return themselves when asked for an iterator
     (they occupy the same position as a collection within a `foreach'
     statement).

 - Method: allocate-iterator ((self MEMOIZABLE-ITERATOR)) : (ITERATOR
          OF (LIKE (ANY-VALUE SELF)))
     Alias for `clone-memoized-iterator'.

 - Method: allocation ((self STORAGE-SLOT)) : KEYWORD
     Return the most specific :allocation facet, or :instance if all
     inherited values are NULL.

 - Function: apply ((code FUNCTION-CODE) (arguments (CONS OF OBJECT)))
          : OBJECT
     Apply CODE to ARGUMENTS, returning a value of type OBJECT.

 - Function: apply-boolean-method ((code METHOD-CODE)
          (arguments (CONS OF OBJECT))) : BOOLEAN
     Apply CODE to ARGUMENTS, returning a value of type BOOLEAN.

 - Function: apply-float-method ((code METHOD-CODE)
          (arguments (CONS OF OBJECT))) : FLOAT
     Apply CODE to ARGUMENTS, returning a value of type FLOAT.

 - Function: apply-integer-method ((code METHOD-CODE)
          (arguments (CONS OF OBJECT))) : INTEGER
     Apply CODE to ARGUMENTS, returning a value of type INTEGER.

 - Function: apply-method ((code METHOD-CODE)
          (arguments (CONS OF OBJECT))) : OBJECT
     Apply CODE to ARGUMENTS, returning a value of type OBJECT.

 - Function: apply-string-method ((code METHOD-CODE)
          (arguments (CONS OF OBJECT))) : STRING
     Apply CODE to ARGUMENTS, returning a value of type STRING.

 - Function: asin ((n FLOAT)) : FLOAT
     Return the arcsine of N in radians.

 - Function: atan ((n FLOAT)) : FLOAT
     Return the arc tangent of N in radians.

 - Function: atan2 ((x FLOAT) (y FLOAT)) : FLOAT
     Return the arc tangent of X / Y in radians.

 - Function: break-program ((message STRING)) :
     Interrupt the program and print MESSAGE.  Continue after
     confirmation with the user.

 - Command: call-clear-module (&rest (name NAME)) :
     Destroy all objects belonging to module NAME or any of its
     children.  If no NAME is supplied, the current module will be
     cleared after confirming with the user.  Important modules such as
     STELLA are protected against accidental clearing.

 - Function: cast ((value OBJECT) (type TYPE)) : OBJECT
     Perform a run-time type check, and then return VALUE.

 - Command: ccc (&rest (name NAME)) : CONTEXT
     Change the current context to the one named NAME.  Return the
     value of the new current context.  If no NAME is supplied, return
     the pre-existing value of the current context.  `cc' is a no-op if
     the context reference cannot be successfully evaluated.  In
     CommonLisp, if the new context is case sensitive, then change the
     readtable case to :INVERT, otherwise to :UPCASE.

 - Function: cl-slot-value ((object OBJECT) (slotName STRING)
          (dontConvert? BOOLEAN)) : LISP-CODE
     Lookup slot SLOTNAME on OBJECT and return the lispified slot value
     (see `lispify').  If DONTCONVERT? is TRUE, the returned slot value
     will not be lispified.  Generate a warning if no such slot exists
     on OBJECT.  In a call directly from Lisp SLOTNAME can also be
     supplied as a Lisp symbol.

 - Function: cl-slot-value-setter ((object OBJECT) (slotName STRING)
          (value LISP-CODE) (dontConvert? BOOLEAN)) : LISP-CODE
     Lookup slot SLOTNAME on OBJECT and set its value to the stellafied
     VALUE (see `stellafy').  If DONTCONVERT? is TRUE, VALUE will not
     be stellafied before it gets assigned.  Generate a warning if no
     such slot exists on OBJECT, or if VALUE has the wrong type.  In a
     call directly from Lisp SLOTNAME can also be supplied as a Lisp
     symbol.

 - Function: cl-translate-file ((file FILE-NAME) (relative? BOOLEAN)) :
     Translate a Stella FILE to Common-Lisp.  If RELATIVE?, concatenate
     root directory to FILE.

 - Function: cl-translate-system ((system-name STRING)) :
     Translate a Stella system named SYSTEM-NAME to Common Lisp.

 - Function: cleanup-unfinalized-classes () :
     Remove all finalized classes from `*UNFINALIZED-CLASSES*', and set
     `*NEWLY-UNFINALIZED-CLASSES?*' to `false'.

 - Function: clear-recycle-list ((list RECYCLE-LIST)) :
     Reset LIST to its empty state.

 - Function: clear-recycle-lists () :
     Reset all currently active recycle lists to their empty state.

 - Function: clear-system ((name STRING)) :
     Clears out the system definition named NAME.  If NAME is `null',
     then clear out all system definitions.  This function is useful
     when changes have been made to the system definition, and one
     wants to have it reloaded from the standard location in the file
     system.

 - Command: clear-trace () :
     Disable all tracing previously enabled with `add-trace'.

 - Function: clone-memoized-iterator ((self MEMOIZABLE-ITERATOR)) :
          (ITERATOR OF (LIKE (ANY-VALUE SELF)))
     Clone the memoized iterator SELF so it can be used to iterate over
     the collection represented by SELF, while allowing to iterate over
     it multiple times via multiple clones.

 - Function: close-all-files () :
     Close all currently open file streams.  Use for emergencies or for
     cleanup.

 - Function: close-stream ((self STREAM)) :
     Close the stream SELF.

 - Macro: coerce-&rest-to-cons ((restVariable SYMBOL)) : OBJECT
     Coerce the argument list variable RESTVARIABLE into a CONS list
     containing all its elements (uses argument list iteration to do
     so).  If RESTVARIABLE already is a CONS due to argument
     listification, this is a no-op.

 - Function: coerce-to-symbol ((name NAME)) : GENERALIZED-SYMBOL
     Return the (generalized) symbol represented by NAME.  Return
     `null' if NAME is undefined or does not represent a string.

 - Macro: collect ((collectvariable SYMBOL) &body (body CONS)) : OBJECT
     Use a VRLET to collect values.  Input has the form `(collect <x>
     in <expression> where (<test> <x>))'.

 - Method: collection-valued? ((self SLOT)) : BOOLEAN
     True if slot values are collections.

 - Function: command? ((method METHOD-SLOT)) : BOOLEAN
     Return `true' if METHOD is an evaluable command.

 - Method: component? ((self STORAGE-SLOT)) : BOOLEAN
     True if fillers of this slot are components of the owner slot, and
     therefore should be deleted if the owner is deleted.

 - Function: compose-namestring
          ((name-components (CONS OF STRING-WRAPPER))
          &rest (options OBJECT)) : STRING
     NAME-COMPONENTS is a cons to be processed into a namestring.
     `:prefix' and `:suffix' are strings that will NOT be
     case-converted.  `:case' is one of :UPCASE :TitleCase :titleCaseX
     :downcase :Capitalize         default is :TitleCase `:separator'
     is a string that should separate word elements.  It does not
     separate the prefix or suffix.  Default is ""
     `:translation-table' should be a STRING-HASH-TABLE hash table that
     strings into their        desired printed representation as a
     string.  In general the argument        will be strings, but that
     is not strictly necessary.


 - Function: compose-namestring-full
          ((strings (CONS OF STRING-WRAPPER)) (prefix STRING)
          (suffix STRING) (outputcase KEYWORD) (outputseparator STRING)
          (translationtable STRING-HASH-TABLE)
          (useacronymheuristics? BOOLEAN)) : STRING
     Non-keyword version of `compose-namestring', which will probably be
     easier to use when called from non-Lisp languages.

 - Function: configure-stella ((file FILE-NAME)) :
     Perform STELLA run-time configuration.  If supplied, load the
     configuration file FILE first which should be supplied with a
     physical pathname.

 - Method: consify ((self OBJECT)) : CONS
     If `object' is a CONS, return it.  Otherwise, return a singleton
     cons list containing it.

 - Macro: continuable-error (&body (body CONS)) : OBJECT
     Signal error message, placing non-string arguments in quotes.

 - Function: cpp-translate-system ((systemName STRING)) :
     Translate the system SYSTEMNAME to C++.

 - Command: cpptrans ((statement OBJECT)) :
     Translate STATEMENT to C++ and print the result.

 - Function: create-derived-list ((self LIST)) : LIST
     Create a new list object with the same type as SELF.

 - Function: create-object ((type TYPE)
          &rest (initial-value-pairs OBJECT)) : OBJECT
     Funcallable version of the `new' operator.  Return an instance of
     the class named by TYPE.  If INITIAL-VALUE-PAIRS is supplied, it
     has to be a key/value list similar to what's accepted by `new' and
     the named slots will be initialized with the supplied values.
     Similar to `new', all required arguments for TYPE must be
     included.  Since all the slot initialization, etc. is handled
     dynamically at run time, `create-object' is much slower than
     `new'; therefore, it should only be used if TYPE cannot be known
     at translation time.

 - Function: deactivate-demon ((demon DEMON)) :
     Detach DEMON from the location(s) specified by its internal
     structure.

 - Function: decompose-namestring ((namestring STRING)
          &rest (options OBJECT)) : (CONS OF STRING-WRAPPER)
     Keyword options:   :break-on-cap    one of  :YES :NO :CLEVER
      default is :CLEVER   :break-on-number one of  :YES :NO :CLEVER
          default is :CLEVER   :break-on-separators string
              default is "-_ "

     DECOMPOSE-NAMESTRING returns a cons of STRING-WRAPPERS that are
     the decomposition of the input STRING.  The arguments are used as
     follows:   NAMESTRING       is the input string.    :break-on-cap
      is a keyword controlling whether changes in capitalization is
     used                    to indicate word boundaries.  If :YES,
     then all capitalization                    changes delineate
     words.  If :CLEVER, then unbroken runs of
     capitalized letters are treated as acronyms and remain grouped.
                     If :NO or NULL, there is no breaking of words
     based on capitalization.    :break-on-number is a flag controlling
     whether encountering a number indicates                    a word
     boundary.  If :YES, then each run of numbers is treated as 		   a
     word separate from surrounding words.  If :CLEVER, then an
     attempt is made to recognize ordinal numbers (ie, 101st) and
     treat them as separate words.  If :NO or NULL, there is no breaking
                       of words when numbers are encountered.
     :break-on-separators   A string of characters which constitute
     word delimiters in                          the input word.  This
     is used to determine how to break                    the name into
     individual words.  Defaults are space, `-' and `_'.

 - Function: decompose-namestring-full ((namestring STRING)
          (break-on-cap KEYWORD) (break-on-number KEYWORD)
          (break-on-separators STRING)) : (CONS OF STRING-WRAPPER)
     Non-keyword version of `decompose-namestring', which will probably
     be easier to use when called from non-Lisp languages.

 - Method: default-form ((self STORAGE-SLOT)) : OBJECT
     Returns the current value of default expression when the slot has
     not been assigned a value.

 - Macro: defdemon ((name STRING-WRAPPER) (parameterstree CONS)
          &body (optionsandbody CONS)) : OBJECT
     Define a demon NAME and attach it to a class or slot.

 - Function: define-demon ((name STRING) &rest (options OBJECT)) : DEMON
     Define a class or slot demon.  Options are :create, :destroy,
     :class, :slot, :guard?, :code, :method, :inherit?, and
     :documentation.

 - Function: define-logical-host-property ((host STRING)
          (property KEYWORD) (value OBJECT)) :
     Define PROPERTY with VALUE for the logical host HOST.  As a
     side-effect, this also defines HOST as a logical host (both
     PROPERTY and VALUE can be supplied as NULL).  If :ROOT-DIRECTORY
     is specified, all pathnames with HOST are assumed to be relative to
     that directory (even if they are absolute) and will be rerooted
     upon translation.  :ROOT-DIRECTORY can be a logical or physical
     pathname.  If :LISP-TRANSLATIONS is specified, those will be used
     verbatimely as the value of `(CL:logical-pathname-translations
     host)' if we are running in Lisp, which allows us to depend on the
     native `CL:translate-logical-pathname' for more complex
     translation operations.

 - Function: define-module ((name STRING) (options CONS)) : MODULE
     Define or redefine a module named NAME having the options OPTIONS.
     Return the new module.

 - Function: define-stella-class ((name TYPE) (supers (LIST OF TYPE))
          (slots (LIST OF SLOT)) (options KEYWORD-KEY-VALUE-LIST)) :
          CLASS
     Return a Stella class with name NAME.  Caution:  If the class
     already exists, the Stella class object gets redefined, but the
     native C++ class is not redefined.

 - Function: define-stella-method-slot ((inputname SYMBOL)
          (returntypes CONS) (function? BOOLEAN) (inputParameters CONS)
          (options KEYWORD-KEY-VALUE-LIST)) : METHOD-SLOT
     Define a new Stella method object (a slot), and attach it to the
     class identified by the first parameter in INPUTPARAMETERS.

 - Macro: defmain ((varList CONS) &body (body CONS)) : OBJECT
     Defines a function called MAIN which will have the appropriate
     signature for the target translation language.  The signature will
     be:   C++:   public static int main (int v1, char** v2) {<body>}
     Java:  public static void main (String [] v2) {<body>}   Lisp:
     (defun main (&rest args) <body>) The argument VARLIST must have
     two symbols, which will be the names for the INTEGER argument
     count and an array of STRINGs with the argument values.  It can
     also be empty to indicate that no command line arguments will be
     handled.  The startup function for the containing system will
     automatically be called before BODY is executed unless the option
     :STARTUP-SYSTEM? was supplied as FALSE.  There can only be one
     DEFMAIN per module.

 - Command: defsystem ((name SYMBOL) &rest (options OBJECT)) :
          SYSTEM-DEFINITION
     Define a system of files that collectively define a Stella
     application.     Required options are:    :directory - the path
     from the Stella root directory to the directory
     containing the system files.  Can be a string or a list
          of strings (do not include directory separators).     :files
     - a list of files in the system, containing strings and lists
            of strings; the latter defines exploded paths to files
             in subdirectories.     Optional options are:
     :required-systems - a list of systems (strings) that should be
     loaded                         prior to loading this system.
     :cardinal-module - the name (a string) of the principal module for
     this                        system.     :copyright-header - string
     with a header for inclusion into all translated
         files produced by Stella.     :lisp-only-files  - Like the
     :files keyword, but these are only included    :cpp-only-files
     in the translation for the specific language, namely
     :java-only-files     Common Lisp, C++ or Java

 - Method: deleted? ((self OBJECT)) : BOOLEAN
     Default `deleted?' method which always returns FALSE.  Objects
     that inherit DYNAMIC-SLOTS-MIXIN also inherit the
     dynamically-allocated slot `deleted-object?' which is
     read/writable with specializations of this method.

 - Command: describe ((name OBJECT) &rest (mode OBJECT)) :
     Print a description of an object in :verbose, :terse, or :source
     modes.

 - Method: describe-object ((self OBJECT) (stream OUTPUT-STREAM)
          (mode KEYWORD)) :
     Prints a description of SELF to stream STREAM.  MODE can be
     :terse, :verbose, or :source.  The :terse mode is often equivalent
     to the standard print function.

 - Method: destroy-class ((self CLASS)) :
     Destroy the Stella class SELF.  Unfinalize its subclasses (if it
     has any).

 - Function: destroy-class-and-subclasses ((self CLASS)) :
     Destroy the Stella class SELF and all its subclasses.

 - Function: destructure-defmethod-tree ((method-tree CONS)
          (options-table KEY-VALUE-LIST)) : OBJECT CONS CONS
     Return three parse trees representing the name, parameters, and
     code body of the parse tree METHOD-TREE.  Fill OPTIONS-TABLE with
     a dictionary of method options.  Storage note:  Options are
     treated specially because the other return values are subtrees of
     METHOD-TREE, while OPTIONS-TABLE is a newly-created cons tree.
     Note also, the parameter and body trees are destructively removed
     from METHOD-TREE.

 - Function: dictionary ((collectionType TYPE)
          &rest (alternatingkeysandvalues OBJECT)) :
          (ABSTRACT-DICTIONARY OF OBJECT OBJECT)
     Return a dictionary of COLLECTIONTYPE containing `values', in
     order.  Currently supported COLLECTIONTYPEs are @HASH-TABLE,
     @STELLA-HASH-TABLE, @KEY-VALUE-LIST, @KEY-VALUE-MAP and
     @PROPERTY-LIST.

 - Method: direct-super-classes ((self CLASS)) : (ITERATOR OF CLASS)
     Returns an iterator that generates all direct super classes of
     SELF.

 - Command: disable-memoization () :
     Enable memoization and use of memoized expression results.

 - Function: disabled-stella-feature? ((feature KEYWORD)) : BOOLEAN
     Return true if the STELLA FEATURE is currently disabled.

 - Function: div ((x INTEGER) (y INTEGER)) : INTEGER
     Return the integer quotient from dividing X by Y.

 - Function: drop-hook ((hookList HOOK-LIST) (hookFunction SYMBOL)) :
     Remove the function named HOOKFUNCTION from HOOKLIST.

 - Command: drop-trace (&rest (keywords GENERALIZED-SYMBOL)) : LIST
     Disable trace messages identified by any of the listed KEYWORDS.
     After calling (`drop-trace' <keyword>) code guarded by (`trace-if'
     <keyword> ...)  will not be executed when it is encountered.

 - Macro: either ((value1 OBJECT) (value2 OBJECT)) : OBJECT
     If VALUE1 is defined, return that, else return VALUE2.

 - Method: empty? ((x STRING-WRAPPER)) : BOOLEAN
     Return true if X is the wrapped empty string ""

 - Command: enable-memoization () :
     Enable memoization and use of memoized expression results.

 - Function: enabled-stella-feature? ((feature KEYWORD)) : BOOLEAN
     Return true if the STELLA FEATURE is currently enabled.

 - Macro: error (&body (body CONS)) : OBJECT
     Signal error message, placing non-string arguments in quotes.

 - Function: evaluate ((expression OBJECT)) : OBJECT
     Evaluate the expression EXPRESSION and return the result.
     Currently, only the evaluation of (possibly nested) commands and
     global variables is supported.  The second return value indicates
     the actual type of the result (which might have been wrapped), and
     the third return value indicates whether an error occurred during
     the evaluation.  Expressions are simple to program in Common Lisp,
     since they are built into the language, and relatively awkward in
     Java and C++.  Users of either of those languages are more likely
     to want to call `evaluate-string'.

 - Function: evaluate-string ((expression STRING)) : OBJECT
     Evaluate the expression represented by EXPRESSION and return the
     result.  This is equivalent to `(evaluate (unstringify
     expression))'.

 - Function: exception-message ((e NATIVE-EXCEPTION)) : STRING
     Accesses the error message of the exception E.

 - Function: expt ((x FLOAT) (y FLOAT)) : FLOAT
     Return X ^ Y.

 - Method: extension ((self CLASS)) : CLASS-EXTENSION
     Return the nearest class extension that records instances of the
     class SELF.

 - Function: fill-in-date-substitution
          ((substitution-list (KEY-VALUE-LIST OF STRING-WRAPPER STRING-WRAPPER)))
          :
     Fill in SUBSTITUTION-LIST with template variable substitions for
     the names YEAR and DATE which correspond to the current year and
     date.  These substitutions can then be used with
     `substitute-template-variables-in-string'

 - Function: finalize-classes () :
     Finalize all currently unfinalized classes.

 - Function: finalize-classes-and-slots () :
     Finalize all currently unfinalized classes and slots.

 - Function: finalize-slots () :
     Finalize all currently unfinalized slots.

 - Macro: first-defined (&body (forms CONS)) : OBJECT
     Return the result of the first form in FORMS whose value is defined
     or NULL otherwise.

 - Function: flush-output ((self OUTPUT-STREAM)) :
     Flush all buffered output of SELF.

 - Function: format-with-padding ((input STRING) (length INTEGER)
          (padchar CHARACTER) (align KEYWORD) (truncate? BOOLEAN)) :
          STRING
     Formats INPUT to be (at least) LENGTH long, using PADCHAR to fill
     if necessary.  ALIGN must be one of :LEFT, :RIGHT, :CENTER and
     will control how INPUT will be justified in the resulting string.
     If TRUNCATE? is true, then then an overlength string will be
     truncated, using the opposite of ALIGN to pick the truncation
     direction.

 - Method: free ((self ACTIVE-OBJECT)) :
     Remove all pointers between SELF and other objects, and then
     deallocate the storage for self.

 - Method: free ((self OBJECT)) :
     Default method.  Deallocate storage for SELF.

 - Method: free-hash-table-values ((self ABSTRACT-HASH-TABLE)) :
     Call free on each value in the hash table SELF.

 - Function: gcd ((x INTEGER) (y INTEGER)) : INTEGER
     Return the greatest common divisor of X and Y.

 - Method: get-calendar-date ((date CALENDAR-DATE) (timezone FLOAT)) :
          INTEGER INTEGER INTEGER KEYWORD
     Returns multiple values of year, month, day and day of week for
     DATE in TIMEZONE.  TIMEZONE is the number of hours added to UTC to
     get local time.  It is in the range -12.0 to +14.0 where UTC is
     zone 0.0

 - Function: get-global-value ((self SURROGATE)) : OBJECT
     Return the (possibly-wrapped) value of the global variable for the
     surrogate SELF.

 - Function: get-local-standard-time-zone () : FLOAT
     Returns the standard time zone offset from UTC as a float, without
     considering the effects of daylight savings time.

 - Function: get-local-time-zone-for-date ((year INTEGER)
          (month INTEGER) (day INTEGER) (hour INTEGER) (minute INTEGER)
          (second INTEGER)) : FLOAT
     Returns the time zone offset from UTC (as a float) that is
     applicable to the given date.  Assumes that the date is one that
     is valid for the underlying programming language.  If not, then
     returns 0.0

 - Function: get-quoted-tree ((tree-name STRING) (modulename STRING)) :
          CONS
     Return the quoted tree with name TREE-NAME.

 - Function: get-slot ((self STANDARD-OBJECT) (slot-name SYMBOL)) : SLOT
     Return the slot named SLOT-NAME on the class representing the type
     of SELF.

 - Method: get-stella-class ((class-name TYPE) (error? BOOLEAN)) : CLASS
     Return a class with name CLASS-NAME.  If none exists, break if
     ERROR?, else return `null'.

 - Method: get-stella-class ((class-name SYMBOL) (error? BOOLEAN)) :
          CLASS
     Return a class with name CLASS-NAME.  If non exists, break if
     ERROR?, else return `null'.

 - Method: get-stella-class ((class-name STRING) (error? BOOLEAN)) :
          CLASS
     Return a class with name CLASS-NAME.  If none exists, break if
     ERROR?, else return `null'.

 - Method: get-time ((date CALENDAR-DATE) (timezone FLOAT)) : INTEGER
          INTEGER INTEGER INTEGER
     Returns multiple values of hours, minutes, seconds, milliseconds
     for the calendar date DATE in TIMEZONE.  TIMEZONE is the number of
     hours added to UTC to get local time.  It is in the range -12.0 to
     +14.0 where UTC is zone 0.0

 - Function: global-variable-type-spec ((global GLOBAL-VARIABLE)) :
          TYPE-SPEC
     Return the type spec for the global variable GLOBAL.

 - Function: hash-string ((string STRING) (seedCode INTEGER)) : INTEGER
     Generate a hash-code for STRING and return it.  Two strings that
     are equal but not eq will generate the same code.  The hash-code
     is based on SEEDCODE which usually will be 0.  However, SEEDCODE
     can also be used to supply the result of a previous hash operation
     to achieve hashing on sequences of strings without actually having
     to concatenate them.

 - Function: hashmod ((code INTEGER) (size INTEGER)) : INTEGER
     Map the hash code CODE onto a bucket index for a hash table of
     SIZE (i.e., onto the interval [0..size-1].  This is just like
     `rem' for positive hash codes but also works for negative hash
     codes by mapping those onto a positive number first.  Note, that
     the sign conversion mapping is not equivalent to calling the `abs'
     function (it simply masks the sign bit for speed) and therefore
     really only makes sense for hash codes.

 - Function: help-get-stella-module ((pathName STRING)
          (error? BOOLEAN)) : MODULE
     Return the module located at PATHNAME, or `null' if no such module
     exists.  The search looks at ancestors and top-most  (cardinal)
     modules.  If ERROR? is `true', throw an exception if no  module is
     found.

 - Method: home-module ((self OBJECT)) : MODULE
     Return the home module of SELF.

 - Macro: if-output-language ((language KEYWORD) (thenForm OBJECT)
          (elseForm OBJECT)) : OBJECT
     Expand to THENFORM if the current translator output language
     equals LANGUAGE.  Otherwise, expand to ELSEFORM.  This can be used
     to conditionally translate Stella code.

 - Macro: if-stella-feature ((feature KEYWORD) (thenForm OBJECT)
          (elseForm OBJECT)) : OBJECT
     Expand to THENFORM if FEATURE is a currently enabled STELLA
     environment feature.  Otherwise, expand to ELSEFORM.  This can be
     used to conditionally translate Stella code.

 - Macro: ignore (&body (variables CONS)) : OBJECT
     Ignore unused VARIABLES with NoOp `setq' statements.

 - Function: incrementally-translate ((tree OBJECT)) : OBJECT
     Translate a single Stella expression TREE and return the result.
     For C++ and Java print the translation to standard output and
     return NIL instead.

 - Macro: inform (&body (body CONS)) : OBJECT
     Print informative message, placing non-string arguments in quotes,
     and terminating with a newline.

 - Method: initial-value ((self CLASS)) : OBJECT
     Return an initial value for the class SELF.

 - Method: initial-value ((self STORAGE-SLOT)) : OBJECT
     Return an initial value for SELF, or `null'.  The initial value
     can be defined by the slot itself, inherited from an equivalent
     slot, or inherit from the :initial-value option for the class
     representing the type of SELF.

 - Method: initialize-hash-table ((self STELLA-HASH-TABLE)) :
     Initialize the STELLA hash table SELF.  This is a no-op and
     primarily exists to shadow the standard initializer inherited from
     ABSTRACT-HASH-TABLE.  STELLA hash tables are initialized at the
     first insertion operation.

 - Method: initially ((self STORAGE-SLOT)) : OBJECT
     Defines the value of a slot before it has been assigned a value.

 - Function: interpret-command-line-arguments ((count INTEGER)
          (arguments (ARRAY () OF STRING))) :
     Interpret any STELLA-relevant command line ARGUMENTS.

 - Function: isa? ((object OBJECT) (type TYPE)) : BOOLEAN
     Return `true' iff OBJECT is an instance of the class named TYPE.

 - Function: java-translate-system ((systemName STRING)) :
     Translate the system SYSTEMNAME to Java.

 - Command: jptrans ((statement OBJECT)) :
     Translate STATEMENT to C++ and print the result.

 - Method: length ((self CONS-ITERATOR)) : INTEGER
     Iterate over SELF, and count how many items there are.

 - Function: lispify ((thing UNKNOWN)) : LISP-CODE
     Convert a Stella THING as much as possible into a Common-Lisp
     analogue.  The currently supported THING types are CONS, LIST,
     KEY-VALUE-LIST, ITERATOR, SYMBOL, KEYWORD, and all wrapped and
     unwrapped literal types.  BOOLEANs are translated into Lisp's CL:T
     and CL:NIL logic.  Unsupported types are left unchanged.

 - Function: lispify-boolean ((thing UNKNOWN)) : LISP-CODE
     Lispify THING which is assumed to be a (possibly wrapped) Stella
     boolean.

 - Method: listify ((self CONS)) : (LIST OF (LIKE (ANY-VALUE SELF)))
     Return a list of elements in SELF.

 - Method: listify ((self LIST)) : (LIST OF (LIKE (ANY-VALUE SELF)))
     Return SELF.

 - Method: listify ((self KEY-VALUE-LIST)) : (LIST OF (LIKE (ANY-VALUE
          SELF)))
     Return a list of key-value pairs in SELF.

 - Method: listify ((self VECTOR)) : (LIST OF (LIKE (ANY-VALUE SELF)))
     Return a list of elements in SELF.

 - Method: listify ((self ITERATOR)) : (LIST OF (LIKE (ANY-VALUE SELF)))
     Return a list of elements generated by SELF.

 - Function: load-configuration-file ((file FILE-NAME)) :
          CONFIGURATION-TABLE
     Read a configuration FILE and return its content as a
     configuration table.  Also enter each property read into the
     global system configuration table.  Assumes Java-style property
     file syntax.  Each property name is represented as a wrapped
     string and each value as a wrapped string/integer/float or boolean.

 - Command: load-file ((file STRING)) :
     Read STELLA commands from FILE and evaluate them.  The file should
     begin with an `in-module' declaration that specifies the module
     within which all remaining commands are to be evaluated The
     remaining commands are evaluated one-by-one, applying the function
     `evaluate' to each of them.

 - Function: load-system ((systemName STRING) (language KEYWORD)
          &rest (options OBJECT)) : BOOLEAN
     Natively LANGUAGE-compile out-of-date translated files of system
     SYSTEMNAME and then load them into the running system (this is only
     supported/possible for Lisp at the moment).  Return true if at
     least one file was compiled. The following keyword/value OPTIONS
     are recognized:

     `:force-recompilation?' (default false): if true, files will be
     compiled whether or not their compilations are up-to-date.

     `:startup?' (default true): if true, the system startup function
     will be called once all files have been loaded.

 - Function: log10 ((n FLOAT)) : FLOAT
     Return the logarithm (base 10) of N.

 - Method: lookup-class ((name SYMBOL)) : CLASS
     Return a class with name NAME.  Scan all visible surrogates
     looking for one that has a class defined for it.

 - Method: lookup-class ((name STRING)) : CLASS
     Return a class with name NAME.  Scan all visible surrogates
     looking for one that has a class defined for it.

 - Function: lookup-command ((name SYMBOL)) : METHOD-SLOT
     If NAME names an evaluable command return its associated command
     object;  otherwise, return `null'.  Currently, commands are not
     polymorphic, i.e., they can only be implemented by functions.

 - Function: lookup-configuration-property ((property STRING)
          (defaultValue WRAPPER) (configuration CONFIGURATION-TABLE)) :
          WRAPPER
     Lookup PROPERTY in CONFIGURATION and return its value.  Use the
     global system configuration table if CONFIGURATION is NULL.  Return
     DEFAULTVALUE if PROPERTY is not defined.

 - Function: lookup-demon ((name STRING)) : DEMON
     Return the demon named NAME.

 - Function: lookup-function ((functionSymbol SYMBOL)) : FUNCTION
     Return the function defined for FUNCTIONSYMBOL, if it exists.

 - Function: lookup-function-by-name ((name STRING)) : FUNCTION
     Return a function with name NAME visible from the current module.
     Scan all visible symbols looking for one that has a function
     defined for it.

 - Method: lookup-global-variable ((self SURROGATE)) : GLOBAL-VARIABLE
     Return a global variable with name SELF.

 - Method: lookup-global-variable ((self GENERALIZED-SYMBOL)) :
          GLOBAL-VARIABLE
     Return a global variable with name SELF.

 - Method: lookup-global-variable ((self STRING)) : GLOBAL-VARIABLE
     Return a global variable with name SELF.

 - Function: lookup-local-slot ((class CLASS) (slot-name SYMBOL)) : SLOT
     Lookup a local slot with SLOT-NAME on CLASS.

 - Function: lookup-macro ((name SYMBOL)) : METHOD-SLOT
     If NAME has a macro definition, return the method object holding
     its expander function.

 - Function: lookup-slot ((class CLASS) (slot-name SYMBOL)) : SLOT
     Return a slot owned by the class CLASS with name SLOT-NAME.
     Multiply inherited slots are disambiguated by a left-to-right class
     precedence order for classes with multiple parents (similar to
     CLOS).

 - Command: lptrans ((statement OBJECT)) :
     Translate STATEMENT to Common-Lisp and print the result.

 - Function: make-matching-name ((original STRING)
          &rest (options OBJECT)) : STRING
     Keyword options:   :break-on-cap    one of  :YES :NO :CLEVER
      default is :CLEVER   :break-on-number one of  :YES :NO :CLEVER
          default is :CLEVER   :break-on-separators string
              default is "-_ "   :remove-prefix   string
     :remove-suffix   string

     :case            one of  :UPCASE :TitleCase :titleCaseX :downcase
     :Capitalize :preserve
            default is :TitleCase   :separator       string
                    default is ""   :add-prefix      string
     :add-suffix      string

     MAKE-MATCHING-NAME returns a matching name (a string) for the
     input name (a string).  A matching name is constructed by breaking
     the input into `words' and then applying appropriate transforms.
     The arguments are used as follows:   ORIGINAL         is the input
     name.  It is a string.    :break-on-cap    is a keyword
     controlling whether changes in capitalization is used
          to indicate word boundaries.  If :YES, then all
     capitalization                    changes delineate words.  If
     :CLEVER, then unbroken runs of                    capitalized
     letters are treated as acronyms and remain grouped.
         If :NO or NULL, there is no breaking of words based on
     capitalization.    :break-on-number is a flag controlling whether
     encountering a number indicates                    a word
     boundary.  If :YES, then each run of numbers is treated as 		   a
     word separate from surrounding words.  If :CLEVER, then an
     attempt is made to recognize ordinal numbers (ie, 101st) and
     treat them as separate words.  If :NO or NULL, there is no breaking
                       of words when numbers are encountered.
     :break-on-separators   A string of characters which constitute
     word delimiters in                          the input word.  This
     is used to determine how to break                    the name into
     individual words.  Defaults are space, `-' and `_'.
     :remove-prefix   Specifies a prefix or suffix that is stripped
     from the input   :remove-suffix   name before any other
     processing.  This allows the removal of                    any
     naming convention dictated prefixes or suffixes.    :add-prefix
      Specifies a prefix or suffix that is added to the output name
     :add-suffix      after all other processing.  This allows the
     addition of any                    naming convention dictated
     prefixes or suffixes.    :case            The case of the
     resulting name.  This is applied to the name
     before adding prefixes or suffixes.  The two title case options
                    differ only in how the first word of the name is
     treated.                     :TitleCase capitalizes the first
     letter of the first word and                        also the first
     letter of all other words.                     :TitleCaseX does
     not capitalizes the first letter of the first 		       word but
     capitalizes the first letter of all subsequent words.
     :preserve results in no change in case.    :separator       This
     is a string specifying the word separator to use in the
            returned name.  An empty string (the default) means that
     the                    resulting words are concatenated without
     any separation.  This                    normally only makes sense
     when using one of the title case values                    for the
     case keyword.

 - Function: make-matching-name-full ((originalname STRING)
          (breakoncap KEYWORD) (breakonnumber KEYWORD)
          (breakonseparators STRING) (removeprefix STRING)
          (removesuffix STRING) (addprefix STRING) (addsuffix STRING)
          (outputcase KEYWORD) (outputseparator STRING)) : STRING
     Non-keyword version of `make-matching-name', which will probably be
     easier to use when called from non-Lisp languages.

 - Command: make-system ((systemName STRING) (language KEYWORD)
          &rest (options OBJECT)) : BOOLEAN
     Translate all out-of-date files of system SYSTEMNAME into LANGUAGE
     and then compile and load them (the latter is only possible for
     Lisp right now).  The following keyword/value OPTIONS are
     recognized:

     `:two-pass?': if true, all files will be scanned twice, once to
     load the signatures of objects defined in them, and once to
     actually translate the definitions.  Otherwise, the translator
     will make one pass in the case that the system is already loaded
     (and is being remade), and two passes otherwise.

     `:development-settings?' (default false): if true translation will
     favor safe, readable and debuggable code over efficiency
     (according to the value of `:development-settings' on the system
     definition).  If false, efficiency will be favored instead
     (according to the value of `:production-settings' on the system
     definition).

     `:production-settings?' (default true): inverse to
     `:development-settings?'.

     `:force-translation?' (default false): if true, files will be
     translated whether or not their translations are up-to-date.

     `:force-recompilation?' (default false): if true, translated files
     will be recompiled whether or not their compilations are
     up-to-date (only supported in Lisp right now).

     `:load-system?' (default true): if true, compiled files will be
     loaded into the current STELLA image (only supported in Lisp right
     now).

     `:startup?' (default true): if true, the system startup function
     will be called once all files have been loaded.

 - Method: member? ((self CONS-ITERATOR) (value OBJECT)) : BOOLEAN
     Iterate over values of SELF and return TRUE if one of them is
     `eql?' to 'value.

 - Method: member? ((self COLLECTION) (object OBJECT)) : BOOLEAN
     Return true iff OBJECT is a member of the collection SELF.

 - Method: member? ((self SEQUENCE) (value OBJECT)) : BOOLEAN
     Return TRUE if VALUE is a member of the sequence SELF.

 - Macro: memoize ((inputArgs CONS) &body (body CONS)) : OBJECT
     Compute the value of an expression and memoize it relative to
     the values of INPUTARGS.  INPUTARGS should characterize the
     complete set of values upon which    the computation of the result
     depended.  Calls to `memoize' should be of the form

     (memoize (<arg>+) {:<option> <value>}* <expression>)

     and have the status of an expression.     The following options
     are supported:

     :timestamps   A single or list of keywords specifying the names of
                        timestamps which when bumped should invalidate
     all                     entries currently memoized in this table.
          :name         Names the memoization table so it can be
     shared by other                     memoization sites.  By
     default, a gensymed name is used.                      CAUTION: IT
     IS ASSUMED THAT ALL ENTRIES IN A MEMOZATION
     TABLE DEPEND ON THE SAME NUMBER OF ARGUMENTS!!        :max-values
     The maximum number of values to be memoized.  Only the
             `:max-values' most recently used values will be kept
                   in the memoization table, older values will be
     discarded                     and recomputed if needed.  Without a
     `:max-values'                     specification, the memoization
     table will grow                     indefinitely.

     PERFORMANCE NOTES: For most efficient lookup, input arguments that
     vary the most should be listed first.  Also, arguments of type
     STANDARD-OBJECT (and all its subtypes) can be memoized more
     efficiently than arguments of type OBJECT or wrapped literals
     (with the exception of BOOLEANs).

 - Function: merge-file-names ((baseFile FILE-NAME)
          (defaults FILE-NAME)) : FILE-NAME
     Parse BASEFILE, supply any missing components from DEFAULTS if
     supplied and return the result.

 - Method: multiple-parents? ((class CLASS)) : BOOLEAN
     Return `true' if CLASS has more than one direct superclass.

 - Method: multiple-parents? ((module MODULE)) : BOOLEAN
     Return TRUE if MODULE has more than one parent.

 - Function: name-to-string ((name OBJECT)) : STRING
     Return the string represented by NAME.  Return `null' if NAME is
     undefined or does not represent a string.

 - Method: next? ((self MEMOIZABLE-ITERATOR)) : BOOLEAN
     Generate the next value of the memoized iterator SELF (or one of
     its clones) by either using one of the values generated so far or
     by generating and saving the next value of the `base-iterator'.

 - Method: no-duplicates? ((self COLLECTION)) : BOOLEAN
     Return `true' if the collection SELF forbids duplicate values.

 - Method: non-empty? ((x STRING-WRAPPER)) : BOOLEAN
     Return true if X is not the wrapped empty string ""

 - Method: nth ((self NATIVE-VECTOR) (position INTEGER)) : (LIKE
          (ANY-VALUE SELF))
     Return the element in SELF at POSITION.

 - Macro: only-if ((test OBJECT) (expression OBJECT)) : OBJECT
     If TEST is TRUE, return the result of evaluating EXPRESSION.

 - Function: open-network-stream ((host STRING) (port INTEGER)) :
          INPUT-STREAM OUTPUT-STREAM
     Open a TCP/IP network stream to HOST at PORT and return the result
     as an input/output stream pair.

 - Method: ordered? ((self COLLECTION)) : BOOLEAN
     Return `true' if the collection SELF is ordered.

 - Method: parameters ((self CLASS)) : (LIST OF SYMBOL)
     Returns the list of parameters names of SELF.

 - Function: parse-date-time-in-time-zone ((date-time-string STRING)
          (time-zone FLOAT) (start INTEGER) (end INTEGER)
          (error-on-mismatch? BOOLEAN)) : DECODED-DATE-TIME
     Tries very hard to make sense out of the argument DATE-TIME-STRING
     and returns a time structure if successful.  If not, it returns
     `null'.  If ERROR-ON-MISMATCH? is true, parse-date-time will
     signal an error instead of returning `null'.  Default values are
     00:00:00 in the given timezone on the current date.  If the given
     TIME-ZONE value is `null', then the local time zone for the given
     date and time will be used as determined by the operating system.

 - Function: pick-hash-table-size-prime ((minSize INTEGER)) : INTEGER
     Return a hash table prime of at least MINSIZE.

 - Method: primary-type ((self OBJECT)) : TYPE
     Returns the primary type of SELF.  Gets defined automatically for
     every non-abstract subclass of OBJECT.

 - Method: primitive? ((self RELATION)) : BOOLEAN
     Return `true' if SELF is not a defined relation.

 - Macro: print (&body (body CONS)) : OBJECT
     Print arguments to the standard output stream.

 - Function: print-exception-context ((e NATIVE-EXCEPTION)
          (stream OUTPUT-STREAM)) :
     Prints a system dependent information about the context of the
     specified exception.  For example, in Java it prints a stack
     trace.  In Lisp, it is vendor dependent.

 - Function: print-recycle-lists () :
     Print the current state of all recycle lists.

 - Macro: print-spaces (&body (body CONS)) : OBJECT
     (print-spaces [stream] N) prints N spaces onto stream.  If no
     stream form is provided, then STANDARD-OUTPUT will be used.

 - Command: print-stella-features () :
     Print the list of enabled and disabled STELLA features.

 - Command: print-unbound-surrogates (&rest (args OBJECT)) :
     Print all unbound surrogates visible from the module named by the
     first argument (a symbol or string).  Look at all modules if no
     module name or `null' was supplied.  If the second argument is
     `true', only consider surrogates interned in the specified module.

 - Function: print-undefined-methods ((module MODULE) (local? BOOLEAN))
          :
     Print all declared but not yet defined functions and methods in
     MODULE.  If LOCAL? is true, do not consider any parent modules of
     MODULE.  If MODULE is NULL, look at all modules in the system.
     This is handy to pinpoint forward declarations that haven't been
     followed up by actual definitions.

 - Command: print-undefined-super-classes ((class NAME)) :
     Print all undefined or bad (indirect) super classes of CLASS.

 - Function: private-class-methods ((class CLASS)) : (ITERATOR OF
          METHOD-SLOT)
     Iterate over all private methods attached to CLASS.

 - Function: private-class-storage-slots ((class CLASS)) : (ITERATOR OF
          STORAGE-SLOT)
     Iterate over all private storage-slots attached to CLASS.

 - Method: private? ((self RELATION)) : BOOLEAN
     Return `true' if SELF is not public.

 - Command: ptrans ((statement OBJECT)) :
     Translate STATEMENT to Common-Lisp and print the result.

 - Function: public-class-methods ((class CLASS)) : (ITERATOR OF
          METHOD-SLOT)
     Iterate over all private methods attached to CLASS.

 - Function: public-class-storage-slots ((class CLASS)) : (ITERATOR OF
          STORAGE-SLOT)
     Iterate over all public storage-slots attached to CLASS.

 - Method: public-slots ((self CLASS)) : (ITERATOR OF SLOT)
     Return an iterator over public slots of SELF.

 - Method: public-slots ((self OBJECT)) : (ITERATOR OF SLOT)
     Return an iterator over public slots of SELF.

 - Method: public? ((self SLOT)) : BOOLEAN
     True if SELF or one it its ancestors is marked public.

 - Macro: pushf ((place CONS) (value OBJECT)) : OBJECT
     Push VALUE onto the cons list PLACE.

 - Method: reader ((self STORAGE-SLOT)) : SYMBOL
     Name of a method called to read the value of the slot SELF.

 - Function: rem ((x INTEGER) (y INTEGER)) : INTEGER
     Return the remainder from dividing X by Y.  The sign of the result
     is always the same as the sign of X.  This has slightly different
     behavior than the `mod' function, and has less overhead in C++ and
     Java, which don't have direct support for a true modulus function.

 - Method: remove-duplicates ((self COLLECTION)) : (LIKE SELF)
     Return SELF with duplicates removed.  Preserves the original order
     of the remaining members.

 - Method: required-slots ((self CLASS)) : (LIST OF SYMBOL)
     Returns a list of names of required slots for SELF.

 - Method: required? ((self STORAGE-SLOT)) : BOOLEAN
     True if a value must be assigned to this slot at creation time.

 - Command: reset-stella-features () :
     Reset STELLA features to their default settings.

 - Function: reverse-interval ((lowerbound INTEGER)
          (upperbound INTEGER)) : REVERSE-INTEGER-INTERVAL-ITERATOR
     Create a reverse interval object.

 - Function: rotate-hash-code ((arg INTEGER)) : INTEGER
     Rotate ARG to the right by 1 position.  This means shift ARG to
     the right by one and feed in ARGs bit zero from the left.  In Lisp
     the result will stay in positive FIXNUM range.  In C++ and Java
     this might return a negative value which might be equal to
     NULL-INTEGER.  Important: to make this inlinable, it must be
     called with an atom (i.e., constant or variable) as its argument.
     This function is primarily useful for hashing sequences of items
     where the hash code should take the sequential order of elements
     into account (e.g., lists).

 - Function: run-hooks ((hooklist HOOK-LIST) (argument OBJECT)) :
     Run all hook functions in HOOKLIST, applying each one to ARGUMENT.

 - Function: running-as-lisp? () : BOOLEAN
     Return true if the executable code is a Common Lisp application.

 - Function: safe-equal-hash-code ((self OBJECT)) : INTEGER
     Return a hash code for SELF.  Just like `equal-hash-code' - which
     see, but also works for NULL.  `equal-hash-code' methods that
     expect to handle NULL components should use this function for
     recursive calls.

 - Function: safe-hash-code ((self OBJECT)) : INTEGER
     Return a hash code for SELF.  Just like `hash-code' - which see,
     but also works for NULL.

 - Function: safe-lookup-slot ((class CLASS) (slot-name SYMBOL)) : SLOT
     Alias for `lookup-slot'.  Kept for backwards compatibility.

 - Macro: safety ((level INTEGER-WRAPPER) (test OBJECT)
          &body (body CONS)) : OBJECT
     Signal warning message, placing non-string arguments in quotes.

 - Function: search-cons-tree-with-filter? ((tree OBJECT)
          (value OBJECT) (filter CONS)) : BOOLEAN
     Return `true' iff the value VALUE is embedded within the cons tree
     TREE.  Uses an `eql?' test.  Does not descend into any cons whose
     first element matches an element of FILTER.

 - Function: search-for-object ((self OBJECT) (typeref OBJECT)) : OBJECT
     If SELF is a string or a symbol, search for an object named SELF
     of type `type'.  Otherwise, if SELF is an object, return it.

 - Function: seed-random-number-generator () :
     Seeds the random number generator with the current time.

 - Function: sequence ((collectiontype TYPE) &rest (values OBJECT)) :
          (SEQUENCE OF OBJECT)
     Return a sequence containing VALUES, in order.

 - Command: set-call-log-break-point ((count INTEGER)) :
     Set a call log break point to COUNT.  Execution will be
     interrupted right at the entry of the COUNTth logged function call.

 - Function: set-configuration-property ((property STRING)
          (value WRAPPER) (configuration CONFIGURATION-TABLE)) : WRAPPER
     Set PROPERTY in CONFIGURATION to VALUE and return it.  Use the
     global system configuration table if CONFIGURATION is NULL.

 - Function: set-global-value ((self SURROGATE) (value OBJECT)) : OBJECT
     Set the value of the global variable for the surrogate SELF to
     VALUE.

 - Function: set-optimization-levels ((safety INTEGER) (debug INTEGER)
          (speed INTEGER) (space INTEGER)) :
     Set optimization levels for the qualities SAFETY, DEBUG, SPEED,
     and SPACE.

 - Command: set-stella-feature (&rest (features KEYWORD)) :
     Enable all listed STELLA FEATURES.

 - Command: set-translator-output-language ((new-language KEYWORD)) :
          KEYWORD
     Set output language to NEW-LANGUAGE.  Return previous language.

 - Macro: setq? ((variable SYMBOL) (expression CONS)) : OBJECT
     Assign VARIABLE the result of evaluating EXPRESSION, and return
     TRUE if EXPRESSION is not NULL else return FALSE.

 - Function: shadowed-symbol? ((symbol GENERALIZED-SYMBOL)) : BOOLEAN
     Return `true' if SYMBOL is shadowed in its home module.

 - Function: shift-right ((arg INTEGER) (count INTEGER)) : INTEGER
     Shift ARG to the right by COUNT positions and 0-extend from the
     left if ARG is positive or 1-extend if it is negative.  This is an
     arithmetic shift that preserve the sign of ARG and is equivalent
     to dividing ARG by 2** COUNT.

 - Macro: signal ((type SYMBOL) &body (body CONS)) : OBJECT
     Signal error message, placing non-string arguments in quotes.

 - Macro: signal-read-error (&body (body CONS)) : OBJECT
     Specialized version of `signal' that throws a READ-EXCEPTION.

 - Command: start-function-call-logging ((fileName STRING)) :
     Start function call logging to FILENAME.

 - Function: stella-collection? ((self OBJECT)) : BOOLEAN
     Return `true' if SELF is a native collection.

 - Function: stella-object? ((self OBJECT)) : BOOLEAN
     Return true if SELF is a member of the STELLA class `OBJECT'.

 - Function: stella-version-string () : STRING
     Return a string identifying the current version of STELLA.

 - Function: stellafy ((thing LISP-CODE) (targetType TYPE)) : OBJECT
     Partial inverse to `lispify'.  Convert the Lisp object THING into
     a Stella analogue of type TARGETTYPE.  Note: See also `stellify'.
     it is similar, but guesses TARGETTYPE on its own, and makes
     somewhat different translations.

 - Function: stellify ((self OBJECT)) : OBJECT
     Convert a Lisp object into a STELLA object.

 - Command: stop-function-call-logging () :
     Stop function call logging and close the current log file.

 - Function: string-to-time-duration ((duration STRING)) : TIME-DURATION
     Parses and returns an time-duration object corresponding to
     DURATION.  The syntax for time duration strings is "{plus|minus} N
     days[; M ms]" where N and M are integer values for days and
     milliseconds.  If no valid parse is found, `null' is returned.

 - Function: subclass-of? ((subClass CLASS) (superClass CLASS)) :
          BOOLEAN
     Return `true' if SUBCLASS is a subclass of SUPERCLASS.

 - Method: subsequence ((string MUTABLE-STRING) (start INTEGER)
          (end INTEGER)) : STRING
     Return a substring of STRING beginning at position START and
     ending up to but not including position END, counting from zero.
     An END value of NULL stands for the rest of the string.

 - Method: substitute-characters ((self STRING) (new-chars STRING)
          (old-chars STRING)) : STRING
     Substitute all occurences of of a member of OLD-CHARS with the
     corresponding member of NEW-CHARS in the string SELF.  Returns a
     new string.

 - Method: substitute-characters ((self MUTABLE-STRING)
          (new-chars STRING) (old-chars STRING)) : MUTABLE-STRING
     Substitute all occurences of of a member of OLD-CHARS with the
     corresponding member of NEW-CHARS in the string SELF.  IMPORTANT:
     The return value should be used instead of relying on destructive
     substitution, since the substitution will not be destructive in
     all translated languages.

 - Function: subtype-of? ((sub-type TYPE) (super-type TYPE)) : BOOLEAN
     Return `true' iff the class named SUB-TYPE is a subclass of the
     class named SUPER-TYPE.

 - Method: super-classes ((self CLASS)) : (ITERATOR OF CLASS)
     Returns an iterator that generates all super classes of SELF.
     Non-reflexive.

 - Method: sweep ((self OBJECT)) :
     Default method.  Sweep up all SELF-type objects.

 - Method: system-default-value ((self STORAGE-SLOT)) : OBJECT
     Return a default value expression, or if SELF has dynamic storage,
     an initial value expression.

 - Method: system-default-value ((self SLOT)) : OBJECT
     Return a default value expression, or if SELF has dynamic storage,
     an initial value expression.

 - Function: system-loaded? ((name STRING)) : BOOLEAN
     Return `true' if system NAME has been loaded.

 - Function: terminate-program () :
     Terminate and exit the program with normal exit code.

 - Function: time-duration-to-string ((date TIME-DURATION)) : STRING
     Returns a string representation of DATE

 - Function: toggle-output-language () : KEYWORD
     Switch between Common Lisp and C++ as output languages.

 - Macro: trace-if ((keyword OBJECT) &body (body CONS)) : OBJECT
     If KEYWORD is a trace keyword that has been enabled with
     `add-trace' print all the elements in BODY to standard output.
     Otherwise, do nothing.  KEYWORD can also be a list of keywords in
     which case printing is done if one or more of them are trace
     enabled.

 - Function: translate-system ((systemName STRING)
          (outputLanguage KEYWORD) &rest (options OBJECT)) : BOOLEAN
     Translate all of the STELLA source files in system SYSTEMNAME into
     OUTPUTLANGUAGE.  The following keyword/value OPTIONS are
     recognized:

     `:two-pass?' (default false): if true, all files will be scanned
     twice, once to load the signatures of objects defined in them, and
     once to actually translate the definitions.

     `:force-translation?' (default false): if true, files will be
     translated whether or not their translations are up-to-date.

     `:development-settings?' (default false): if true translation will
     favor safe, readable and debuggable code over efficiency
     (according to the value of `:development-settings' on the system
     definition).  If false, efficiency will be favored instead
     (according to the value of `:production-settings' on the system
     definition).

     `:production-settings?' (default true): inverse to
     `:development-settings?'.

 - Function: translate-to-common-lisp? () : BOOLEAN
     Return `true' if current output language is Common-Lisp.

 - Function: translate-to-cpp? () : BOOLEAN
     Return `true' if current output language is C++

 - Function: translate-to-java? () : BOOLEAN
     Return `true' if current output language is Java

 - Function: try-to-evaluate ((tree OBJECT)) : OBJECT
     Variant of `evaluate' that only evaluates TREE if it represents an
     evaluable expression.  If it does not, TREE is returned
     unmodified.  This can be used to implement commands with mixed
     argument evaluation strategies.

 - Function: two-argument-least-common-superclass ((class1 CLASS)
          (class2 CLASS)) : CLASS
     Return the most specific class that is a superclass of both CLASS1
     and CLASS2.  If there is more than one, arbitrarily pick one.  If
     there is none, return `null'.

 - Function: two-argument-least-common-supertype ((type1 TYPE-SPEC)
          (type2 TYPE-SPEC)) : TYPE-SPEC
     Return the most specific type that is a supertype of both TYPE1
     and TYPE2.  If there is more than one, arbitrarily pick one.  If
     there is none, return @VOID.  If one or both types are parametric,
     also try to generalize parameter types if necessary.

 - Method: type ((self SLOT)) : TYPE
     The type of a storage slot is its base type.

 - Method: type-specifier ((self SLOT)) : TYPE-SPEC
     If SELF has a complex type return its type specifier, otherwise,
     return `type' of SELF.

 - Function: type-to-symbol ((type TYPE)) : SYMBOL
     Convert TYPE into a symbol with the same name and module.

 - Method: type-to-wrapped-type ((self TYPE)) : TYPE
     Return the wrapped type for the type SELF, or SELF if it is not a
     bare literal type.

 - Function: unbound-surrogates ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF SURROGATE)
     Iterate over all unbound surrogates visible from MODULE.  Look at
     all modules if MODULE is `null'.  If LOCAL?, only consider
     surrogates interned in MODULE.

 - Function: unescape-html-string ((input STRING)) : STRING
     Replaces HTML escape sequences such as &amp; with their associated
     characters.

 - Function: unescape-url-string ((input STRING)) : STRING
     Takes a string and replaces %-format URL escape sequences with
     their real character equivalent according to RFC 2396.

 - Command: unset-stella-feature (&rest (features KEYWORD)) :
     Disable all listed STELLA FEATURES.

 - Function: unsigned-shift-right-by-1 ((arg INTEGER)) : INTEGER
     Shift ARG to the right by 1 position and 0-extend from the left.
     This does not preserve the sign of ARG and shifts the sign-bit
     just like a regular bit.  In Common-Lisp we can't do that directly
     and need to do some extra masking.

 - Function: unstringify-stella-source ((source STRING)
          (module MODULE)) : OBJECT
     Unstringify a STELLA SOURCE string relative to MODULE, or
     `*MODULE*' if no module is specified.  This function allocates
     transient objects as opposed to `unstringify-in-module' or the
     regular `unstringify'.

 - Function: unwrap-boolean ((wrapper BOOLEAN-WRAPPER)) : BOOLEAN
     Unwrap WRAPPER and return its values as a regular BOOLEAN.  Map
     NULL onto FALSE.

 - Function: unwrap-function-code ((wrapper FUNCTION-CODE-WRAPPER)) :
          FUNCTION-CODE
     Unwrap WRAPPER and return the result.  Return NULL if WRAPPER is
     NULL.

 - Function: unwrap-method-code ((wrapper METHOD-CODE-WRAPPER)) :
          METHOD-CODE
     Unwrap WRAPPER and return the result.  Return NULL if WRAPPER is
     NULL.

 - Method: value-setter ((self ABSTRACT-DICTIONARY-ITERATOR)
          (value (LIKE (ANY-VALUE SELF)))) : (LIKE (ANY-VALUE SELF))
     Abstract method needed to allow application of this method on
     abstract iterator classes that do not implement it.  By having
     this here all `next?' methods of dictionary iterators MUST use the
     `slot-value' paradigm to set the iterator value.

 - Macro: warn (&body (body CONS)) : OBJECT
     Signal warning message, placing non-string arguments in quotes.

 - Macro: with-input-file ((binding CONS) &body (body CONS)) : OBJECT
     Sets up an unwind-protected form which opens a file for input and
     closes it afterwards.  The stream for reading is bound to the
     variable provided in the macro form.  Syntax is (WITH-INPUT-FILE
     (var filename) body+)

 - Macro: with-network-stream ((binding CONS) &body (body CONS)) :
          OBJECT
     Sets up an unwind-protected form which opens a network socket
     stream to a host and port for input and output and closes it
     afterwards.  Separate variables as provided in the call are bound
     to the input and output streams. Syntax is (WITH-NETWORK-STREAM
     (varIn varOut hostname port) body+)

 - Macro: with-output-file ((binding CONS) &body (body CONS)) : OBJECT
     Sets up an unwind-protected form which opens a file for output and
     closes it afterwards.  The stream for writing is bound to the
     variable provided in the macro form.  Syntax is (WITH-OUTPUT-FILE
     (var filename) body+)

 - Macro: with-permanent-objects (&body (body CONS)) : OBJECT
     Allocate `permanent' (as opposed to `transient') objects within
     the scope of this declaration.

 - Macro: with-system-definition ((systemnameexpression OBJECT)
          &body (body CONS)) : OBJECT
     Set *currentSystemDefinition* to the system definition named
     `system'.  Set *currentSystemDefinitionSubdirectory* to match.
     Execute BODY within that scope.

 - Macro: with-transient-objects (&body (body CONS)) : OBJECT
     Allocate `transient' (as opposed to `permanent') objects within
     the scope of this declaration.  CAUTION: The default assumption is
     the allocation of permanent objects.  The scope of
     `with-transient-objects' should be as small as possible, and the
     user has to make sure that code that wasn't explicitly written to
     account for transient objects will continue to work correctly.

 - Function: wrap-boolean ((value BOOLEAN)) : BOOLEAN-WRAPPER
     Return a literal object whose value is the BOOLEAN VALUE.

 - Function: wrap-function-code ((value FUNCTION-CODE)) :
          FUNCTION-CODE-WRAPPER
     Return a literal object whose value is the FUNCTION-CODE VALUE.

 - Function: wrap-method-code ((value METHOD-CODE)) :
          METHOD-CODE-WRAPPER
     Return a literal object whose value is the METHOD-CODE VALUE.

 - Function: wrapped-type-to-type ((self TYPE)) : TYPE
     Return the unwrapped type for the wrapped type SELF, or SELF if it
     is not a wrapped type.

 - Function: wrapper-value-type ((self WRAPPER)) : TYPE
     Return the type of the value stored in the wrapper SELF.

 - Function: write-html-escaping-url-special-characters
          ((stream NATIVE-OUTPUT-STREAM) (input STRING)) :
     Writes a string and replaces unallowed URL characters according to
     RFC 2396 with %-format URL escape sequences.

 - Method: writer ((self STORAGE-SLOT)) : SYMBOL
     Name of a method called to write the value of the slot SELF.

 - Function: xml-token-list-to-s-expression
          ((tokenList TOKENIZER-TOKEN)) : OBJECT
     Convert the XML TOKENLIST into a representative s-expression and
     return the result.  Every XML tag is represented as a cons-list
     starting with the tag as its header, followed by a possibly empty
     list of keyword value pairs representing tag attributes, followed
     by a possibly empty list of content expressions which might
     themselves be XML expressions.  For example, the expression

     <a a1=v1 a2='v2'> foo <b a3=v3/> bar </a>

     becomes

     (<a> (<a1> "v1" <a2> "v2") "foo" (<b> (<a3> "v3")) "bar")

     when represented as an s-expression.  The tag names are subtypes
     of XML-OBJECT such as XML-ELEMENT, XML-LOCAL-ATTRIBUTE,
     XML-GLOBAL-ATTRIBUTE, etc.  ?, ! and [ prefixed tags are encoded
     as their own subtypes of XML-OBJECT, namely
     XML-PROCESSING-INSTRUCTION, XML-DECLARATION, XML-SPECIAL,
     XML-COMMENT, etc.  CDATA is an XML-SPECIAL tag with a name of
     CDATA.

     The name is available using class accessors.

 - Function: yield-define-stella-class ((class CLASS)) : CONS
     Return a cons tree that (when evaluated) constructs a Stella class
     object.

