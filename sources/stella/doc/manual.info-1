This is manual.info, produced by makeinfo version 4.2 from manual.texi.

   This file documents the STELLA programming language.

   Copyright (C) 2003 University of Southern California, Information
Sciences Institute 4676 Admiralty Way Marina Del Rey, CA 90292

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.


File: manual.info,  Node: Top,  Next: Overview,  Prev: (dir),  Up: (dir)

STELLA Manual
*************

   This document describes the STELLA programming language.  STELLA
stands for Strongly-TypEd, Lisp-like LAnguage.  It is an object-oriented
language that strongly supports symbolic programming tasks.  STELLA
programs can currently be translated into Common-Lisp, C++ and Java.
STELLA programming is best done in an Emacs-based Lisp development
environment, which leverages off Lisp's rapid prototyping and
incremental development features.  Once a STELLA program has matured, it
can be translated into C++ or Java to gain extra efficiency, to deliver
it as a stand-alone application, or to link it with other programs.

* Menu:

* Overview::
* Installation::
* The STELLA Language::
* Programming in STELLA::
* Library Classes::
* Library Functions::
* Function Index::
* Variable Index::
* Concept Index::


File: manual.info,  Node: Overview,  Next: Installation,  Prev: Top,  Up: Top

Introduction
************

   This document describes the STELLA programming language.  STELLA
stands for Strongly-TypEd, Lisp-like LAnguage.  It is an object-oriented
language that strongly supports symbolic programming tasks.  We
developed it, since none of the currently "healthy" languages such as
C++ or Java adequately support symbolic programming.  While Common-Lisp
would probably still be today's language of choice for many symbolic
programming applications, its dwindling vendor support and user base
make it more and more difficult to justify its use.

   When we started the development of the PowerLoom knowledge
representation system in 1995 we were faced with exactly this problem.
PowerLoom had to be delivered in C++, but it was simply incoceivable to
write such a large symbolic programming application directly in C++.
The solution was to invent a new programming language we called STELLA
and write PowerLoom in STELLA instead.

   STELLA is a strongly typed, object-oriented, Lisp-like language
specifically geared to support artificial intelligence applications.
STELLA preserves those features of Common Lisp deemed essential for
symbolic programming such as built-in support for dynamic data
structures, heterogeneous collections, first-class symbols, powerful
iteration constructs, name spaces, an object-oriented type system with a
simple meta-object protocol, exception handling, language extensibility
through macros and automatic memory management.  Maybe the biggest
difference between STELLA and Common Lisp is that STELLA is strongly
typed.  All externally visible interfaces such as slots, function
parameters and return values, etc. have to be explicitly typed.
Internal objects such as local variables, however, are mostly typed
implicitly supported by type inference.  This in conjunction with a
powerful type coercion mechanism significantly reduces the number of
explicit type information that needs to be supplied by the programmer
compared to languages such as C++ or Java.

   STELLA programs are first translated into a target language such as
Common Lisp, C++ or Java, and then compiled with the native target
language compiler to generate executable code. The language constructs
of STELLA are restricted to those that can be translated fairly directly
into native constructs of the intended target languages.  This allows
STELLA to be translated into efficient, conventional and readable Lisp,
C++ and Java code.  The resulting native code can be understood and to
some extent even maintained by programmers who don't know STELLA, and it
can easily be interfaced with other programs not written in STELLA.

   As of Fall 2000, we have programmed approximately 100,000 lines of
STELLA code - about 50% for the STELLA kernel itself and the other 50%
for the PowerLoom knowledge representation system and related systems.
Our subjective experience has been that it is only slightly more
difficult to write and debug a STELLA program than a Lisp program, and
that the inconvenience of having to supply some type information is
much outweighed by the benefits such as catching many errors during
compile time instead of at run time.

   The biggest benefit, however, seems to be that we can still leverage
all the incremental code development benefits of Lisp, since we use the
Common Lisp-based version of STELLA for prototyping.  This allows us to
incrementally define and redefine functions, methods and classes and to
inspect, debug and fix incorrect code on the fly.  Even the most
sophisticated C++ or Java IDE's don't yet seem to support this fully
incremental development style, i.e., a change in a class (every change
in Java is a change to a class) still requires recompilation and restart
of the application.  But it is the restart that can be the most time
consuming if one debugs a complex application that takes a significant
time to reach a certain state!

   Once a STELLA program has matured, it can be translated into C++ or
Java to gain extra efficiency, to deliver it as a stand-alone
application, or to link it with other programs.

* Menu:

* Credits and History::


File: manual.info,  Node: Credits and History,  Prev: Overview,  Up: Overview

Credits and History
===================

   Bob MacGregor invented STELLA in 1995 to implement the PowerLoom
knowledge representation system.  He wrote most of the first Lisp-based
kernel system of STELLA and still occasionally writes extensions or
provides fixes.  Today he is primarily a STELLA user writing his own
applications.

   Hans Chalupsky completed the first full STELLA bootstrap (STELLA
translating itself) in Spring 1996, and then went on to deal with all
the changes necessary to handle the many C++ and Java idiosyncrasies
that were discovered when the first versions of these translators came
online.  He is currently one of the principal maintainers of STELLA
supporting the STELLA code analyzer and the Lisp and C++ translators.

   Eric Melz wrote the first version of the C++ translator under very
trying circumstances (i.e., at a stage where the STELLA language
changed under him on a daily basis).  He got the first C++ version of
STELLA running in the Fall of 1996.

   Tom Russ wrote the Java translator and got the first Java version of
STELLA running in Spring 1999.  He is currently one of the principal
maintainers of STELLA supporting the STELLA code analyzer and the Lisp
and Java translators.  He is also still active writing occasional
extensions such as the STELLA XML parser.


File: manual.info,  Node: Installation,  Next: The STELLA Language,  Prev: Overview,  Up: Top

Installation
************

* Menu:

* System Requirements::
* Unpacking the Sources::
* Lisp Installation::
* C++ Installation::
* Java Installation::
* X/Emacs Setup::
* Removing Unneeded Files::


File: manual.info,  Node: System Requirements,  Next: Unpacking the Sources,  Prev: Installation,  Up: Installation

System Requirements
===================

   To install and use STELLA you'll approximately need the following
amounts of disk space:

   * 8 MB for the tar-red or zip-ped archive file

   * 35 MB for the untarred sources, tanslations, compiled Java files
     and documentation

   * 8 MB to compile a Lisp version

   * 11 MB to compile the C++ version (without -g)

   * 3 MB to compile the Java version (already included)


   This means that you will need approximately 55 MB to work with one
Lisp, one C++ and one Java version of STELLA in parallel.  If you also
want to experiment with the Lisp translation variant that uses
structures instead of CLOS instances to implement STELLA objects, then
you will need an extra 8 MB to compile that.

   The full STELLA development tree is quite large, since for every
STELLA source file there are three to four translated versions and as
many compiled versions thereof.  The actual STELLA libraries that you
have to ship with an application, however, are quite small.  For
example, the Java jar file `stella.jar' is only 2 MB including Java
sources.  Eliminating the Java sources cuts that down to about 1 MB!
The dynamic C++ library `libstella.so' compiled on a Linux platform is
about 4 MB.  Additionally, if you don't need all the different
translations of STELLA, you can delete some of the versions to keep
your development tree smaller (*Note Removing Unneeded Files::).

   To run the Lisp version of STELLA you need an ANSI Common-Lisp (or at
least one that supports CLOS and logical pathnames).  We have
successfully tested STELLA with Allegro-CL 4.2, 4.3, 5.0 and 6.0,
Macintosh CL 3.0 and 4.0, Lucid CL 4.1 (plus the necessary ANSI
extensions and Mark Kantrowitz's logical pathnames implementation) and
the freely available CMUCL 18c.  Our main development platform is
Allegro CL running under Sun Solaris and Linux RedHat, so, the closer
your environment is to ours, the higher are the chances that everything
will work right out of the box.  Lisp development under Windows should
also be no problem.

   To run the C++ version of STELLA you need a C++ compiler such as g++
that supports templates and exception handling.  We have successfully
compiled and run STELLA with g++ 3.2 under Linux Redhat 8.0, and with
CygWin 5.0 under Windows 2000 (CygWin provides a very Unix-like
environment).  We have not yet tried to run the C++ version fully
natively under Windows.  The main portability issue is the garbage
collector.  It is supposed to be very portable and run natively on
Windows platforms, but we have never verified that.

   For the Java version you will need Java JDK 1.2 or later.  To get
reasonable performance, you should use JDK 1.3 or later.  We've run the
Java version of STELLA on a variety of platforms without any problems.

   Any one of the Lisp, C++ or Java implementations of STELLA can be
used to develop your own STELLA code and translate it into all three
languages, but the most convenient development environment is the one
based on Lisp.  If you use the C++ or Java version, translating and
using your own STELLA macros is possible but not yet very well
supported.


File: manual.info,  Node: Unpacking the Sources,  Next: Lisp Installation,  Prev: System Requirements,  Up: Installation

Unpacking the Sources
=====================

   Uncompress and untar the file `stella-X.Y.Z.tar.gz' (or unzip the
file `stella-X.Y.Z.zip') in the parent directory of where you want to
install STELLA (`X.Y.Z' are place holders for the actual version
numbers).  This will create the STELLA tree in the directory
`stella-X.Y.Z/'.  All pathnames mentioned below will be relative to that
directory which we will usually refer to as the "STELLA directory".


File: manual.info,  Node: Lisp Installation,  Next: C++ Installation,  Prev: Unpacking the Sources,  Up: Installation

Lisp Installation
=================

   To install the Lisp version startup Lisp and load the file
`load-stella.lisp' with:

     (CL:load "load-stella.lisp")

   The first time around this will compile all Lisp-translated STELLA
files before they are loaded.  During subsequent sessions the compiled
files will be loaded right away.

   If you want to use the version that uses Lisp structs instead of CLOS
objects to implement STELLA objects do the following:

     (CL:setq cl-user::*load-cl-struct-stella?* CL:t)
     (CL:load "load-stella.lisp")

   Alternatively, you can edit the initial value of the variable
`*load-cl-struct-stella?*' in the file `load-stella.lisp'.  Using
structs instead of CLOS objects greatly improves slot access speed,
however, it may cause problems with incremental re-definition of STELLA
classes.  It is therefore recommended to only use this for systems that
are in or near the production stage.

   Once all the files are loaded, you should see a message like this:

     Initializing STELLA...
     STELLA 3.3.0 loaded.
     Type `(in-package "STELLA")' to execute STELLA commands.
     USER(2):

   To reduce startup time, you might want to create a Lisp image that
has all of STELLA preloaded.

   Now type
     (in-package "STELLA")

   to enter the `STELLA' Lisp package where all the STELLA code resides.

   *IMPORTANT*: All unqualified Lisp symbols in this document are
assumed to be in the `STELLA' Lisp package.  Moreover, the `STELLA'
package does *NOT* inherit anything from the `COMMON-LISP' package (see
the file `sources/stella/cl-lib/cl-setup.lisp' for the few exceptions),
hence, you have to explicitly qualify every Lisp symbol you want to use
with `CL:'.  For example, to get the result of the previous evaluation
you have to type `CL:*' instead of `*'.


File: manual.info,  Node: C++ Installation,  Next: Java Installation,  Prev: Lisp Installation,  Up: Installation

C++ Installation
================

   To compile the C++ version of STELLA change to the native C++
directory and run `make':

     % cd native/cpp/stella
     % make

   This will compile all STELLA files, the garbage collector and
generate a static or dynamic `libstella' library file in the directory
`native/cpp/lib' which can later be linked with your own C++-translated
STELLA (or other) code.  To test whether the compilation was successful
you can run STELLA from the same directory like this:

     % ./stella
     Welcome to STELLA 3.3.0
     Running kernel startup code...
     Initializing symbol tables...
     Initializing quoted constants...
     Initializing global variables...
     Creating class objects...
     Finalizing classes...
     Creating method objects...
     Finalizing methods...
     Running non-phased startup code...
     Starting up translators...
     Bye!

   This will simply run various STELLA startup code and exit.  *Note
Hello World in C++::, to see how you can use the STELLA C++ executable
to translate STELLA code.


File: manual.info,  Node: Java Installation,  Next: X/Emacs Setup,  Prev: C++ Installation,  Up: Installation

Java Installation
=================

   Nothing needs to be done to install the Java version.  Since Java
class files are platform independent, they are already shipped with the
STELLA distribution and can be found in the directory `native/java' and
its subdirectories.  Additionally, they have been collected into the
file `stella.jar' in the STELLA directory.  To try out the Java version
of STELLA run the following in the STELLA directory:

     % java -jar stella.jar
     Welcome to STELLA 3.3.0
     Running kernel startup code...
     Initializing symbol tables...
     Initializing quoted constants...
     Initializing global variables...
     Creating class objects...
     Finalizing classes...
     Creating method objects...
     Finalizing methods...
     Running non-phased startup code...
     Starting up translators...
     Bye!

   Similar to the C++ executable, this will simply run various STELLA
startup code and exit.  *Note Hello World in Java::, to see how you can
use the STELLA Java executable to translate STELLA code.


File: manual.info,  Node: X/Emacs Setup,  Next: Removing Unneeded Files,  Prev: Java Installation,  Up: Installation

X/Emacs Setup
=============

   STELLA development is very similar to Lisp development, and it is
best done in an X/Emacs-based Lisp development environment such as the
Allegro-CL Emacs interface plus Allegro Composer, or ILISP.  If you do
use X/Emacs with the Allegro CL interface, add the following to your
`.emacs' or `.xemacs/init.el' file:

     (setq auto-mode-alist
           (cons '("\\.ste$" . fi:common-lisp-mode) auto-mode-alist))

   If you are using the Allegro CL interface, you might want to install
the file `emacs/fi-stella.el', since it sets up proper indentation for
STELLA code and makes looking up STELLA definitions via the `C-c .' or
`M-.' commands work better.  Look at the file `emacs/fi-stella.el' for
specific installation instructions.


File: manual.info,  Node: Removing Unneeded Files,  Prev: X/Emacs Setup,  Up: Installation

Removing Unneeded Files
=======================

   To save disk space you can remove files that you don't need.  For
example, if you are not interested in the C++ version of STELLA, you can
delete the directory `native/cpp'.  Similarly, you can remove
`native/java' to eliminate all Java-related files.  You could do the
same thing for the Lisp directory `native/lisp', but (in our opinion)
that would make it less convenient for you to develop new STELLA code.
Finally, if you don't need any of the STELLA sources, you can delete
the directory `sources/stella'.  If you don't need local copies of the
STELLA documentation, you can delete parts or all of the
`sources/stella/doc' directory.


File: manual.info,  Node: The STELLA Language,  Next: Programming in STELLA,  Prev: Installation,  Up: Top

The STELLA Language
*******************

* Menu:

* Language Overview::
* Basic Data Types::
* Control Structure::
* Functions::
* Classes::
* Methods::
* Macros::
* Modules::


File: manual.info,  Node: Language Overview,  Next: Basic Data Types,  Prev: The STELLA Language,  Up: The STELLA Language

Language Overview
=================

   STELLA is a strongly typed, object-oriented, Lisp-like language.
STELLA programs are first translated into either Common Lisp, C++, or
Java, and then compiled with any conventional compiler for the chosen
target language to generate executable code.  Over 95% of the STELLA
system is written in STELLA itself, the rest is written in
target-language-specific native code.

   The design of STELLA borrows from a variety of programming
languages, most prominently from Common Lisp, and to a lesser degree
from other object-oriented languages such as Eiffel, Sather, and Dylan.
Since STELLA has to be translatable into C++ and Java, various
restrictions of these languages also influenced its design.

   In the following, we assume that the reader is familiar with basic
Common Lisp concepts, and has at least some familiarity with C++ or
Java.  Let us start with a cursory overview of STELLA's main features:

   *Syntax:* STELLA uses a parenthesized, uniform expression syntax
similar to Lisp.  Most definitional constructs and control structures
are similar to their Common Lisp analogues with variations to support
types.

   *Type system:* STELLA is strongly typed and supports efficient
static compilation similar to C++.  Types are required for the arguments
and return values of functions and methods, for global variables, and
for slot definitions.  Local, lexically scoped variables can be typed
implicitly by relying on type inference.

   *Object system:* Types are organized into a single inheritance class
hierarchy.  Restricted multiple inheritance is allowed via mixin
classes.  Dynamic method dispatch is based on the runtime type of the
first argument (similar to C++ and Java).  Slots can be static (native)
or dynamic.  Dynamic slots can be defined at runtime and do not occupy
any space until they are filled.  Slots can have both initial and
default values, and demons can be triggered by slot accesses.  A
meta-object protocol allows the control of object creation,
initialization, termination, and destruction.

   *Control structure:* Functions and methods are distinguished.  They
can have multiple (zero or more) return values and a variable number of
arguments.  Lisp-style macros are supported to facilitate syntax
extensions.  Expressions and statements are distinguished.  Local
variables are lexically scoped, but dynamically scoped variables
(specials) are also supported.  STELLA has an elegant, uniform, and
efficient iteration mechanism plus a built-in protocol for iterators.
An exception mechanism can be used for error handling and non-local
exits.

   *Symbolic programming:* Symbols are first-class objects, and
extensive support for dynamic datatypes such as cons-trees, lists, sets,
association lists, hash tables, extensible vectors, etc., is available.
A backquote mechanism facilitates macro writing and code generation.
Interpreted function call, method call, slot access, and object creation
is supported, and a restricted evaluator is also available.

   *Name spaces:* Functions, methods, variables, and classes occupy
separate name spaces (i.e., the same name can be used for a function and
a class).  A hierarchical module system compartmentalizes symbol tables
and supports large-scale programming.

   *Memory management:* STELLA relies on automatic memory management
via a garbage collector.  For Lisp and Java the native garbage collector
is used.  For the C++ version of STELLA we use the Boehm- Weiser
conservative garbage collector with good results.  Various built-in
support for explicit memory management is also available.

   The Common Lisp features most prominently absent from STELLA are
anonymous functions via lambda abstraction, lexical closures,
multi-methods, full-fledged eval (a restricted evaluator is available),
optional and keyword arguments, and a modifiable readtable.  STELLA
does also not allow dynamic re/definition of functions and classes,
even though the Lisp-based development environment provides this
facility (similar to Dylan).  The main influences of C++ and Java onto
STELLA are the strong typing, limited multiple inheritance,
first-argument polymorphism, and the distinction between statements and
expressions.


File: manual.info,  Node: Basic Data Types,  Next: Control Structure,  Prev: Language Overview,  Up: The STELLA Language

Basic Data Types (tbw)
======================

   To be written.


File: manual.info,  Node: Control Structure,  Next: Functions,  Prev: Basic Data Types,  Up: The STELLA Language

Control Structure (tbc)
=======================

   To be completed.

* Menu:

* Conditionals::


File: manual.info,  Node: Conditionals,  Prev: Control Structure,  Up: Control Structure

Conditionals
------------

   STELLA conditionals are very similar to those found in Common-Lisp.
The main difference is that most STELLA conditionals are statements and
therefore do not return a value.  For this reason, a C++-style `choose'
directive has been added to the language to allow value
conditionalization based on a boolean expression.

 - Statement: if condition then-statement else-statement
     Evaluate the boolean expression CONDITION.  If the result is true
     execute THEN-STATEMENT, otherwise, execute ELSE-STATEMENT.  Note
     that unlike the Common-Lisp version of `if' the ELSE-STATEMENT is
     not optional in STELLA.  Example:

          (if (> x y)
              (print "x is greater than y" EOL)
            (print "x is less than or equal to y" EOL))

 - Statement: when condition statement...
     Evaluate the boolean expression CONDITION.  Only if the result is
     true execute the STATEMENT's in the body.  Example:

          (when (symbol? x)
            (print "x is a symbol, ")
            (print "its name is " (symbol-name (cast x SYMBOL)) EOL))

 - Statement: unless condition statement...
     Evaluate the boolean expression CONDITION.  Only if the result is
     false execute the STATEMENT's in the body.  Therefore, `(unless
     TEST ...)' is equivalent to `(when (not TEST) ...)'.  Example:

          (unless (symbol? x)
            (print "x is not a symbol, ")
            (print "hence, its name is unknown" EOL))

 - Statement: cond clause...
     `cond' is a conditional with an arbitrary number of conditions each
     represented by a CLAUSE.  Each `cond' clause has to be of the
     following form:
          (CONDITION STATEMENT...)
     The first CLAUSE whose CONDITION evaluates to true will be
     selected and its STATEMENT's will be executed.  Each clause can
     have 0 or more statements.  The special condition `otherwise'
     always evaluates to true and can be used for the catch-all case.
     Example:

          (cond ((symbol? x)
                 (print "x is a symbol" EOL))
                ((cons? x)
                 (print "x is a cons" EOL))
                (otherwise
                 (print "x is an object" EOL)))

 - Expression: choose condition true-expression false-expression
     Evaluate the boolean expression CONDITION.  If the result is true
     return the value of TRUE-EXPRESSION, otherwise, return the value
     of FALSE-EXPRESSION.  STELLA computes the most specific common
     supertype of TRUE-EXPRESSION and FALSE-EXPRESSION and uses that as
     the type returned by the `choose' expression.  If no such type
     exists, a translation error will be signaled.  Example:

          (setq face (choose happy? :smile :frown))

 - Statement: case expression clause...
     Each `case' clause has to be of one of the following forms:

          (KEY STATEMENT...)
          ((KEY...) STATEMENT...)

     `case' selects the first CLAUSE whose KEY (or one of the listed
     KEY's) matches the result of EXPRESSION and executes the clause's
     STATEMENT's.  Each `case' KEY has to be a constant such as a
     number, character, string, symbol, keyword or surrogate.  Keys are
     compared with `eql?' (or `string-eql?' for strings).  All keys in
     a `case' statement have to be of the same type.  The special key
     `otherwise' can be used to catch everything.  It is a run-time
     error if no clause with a matching key exists.  Therefore, a
     STELLA `case' without an `otherwise' clause corresponds to a
     Common Lisp `ecase'.  An empty `otherwise' clause can always be
     specified via `(otherwise NULL)'.  Example:

          (case car-make
            ("Yugo"
             (setq price :cheap))
            ("VW"
             (setq price :medium))
            (("Ferrari" "Rolls Royce")
             (setq price :expensive))
            (otherwise
             (setq price :unknown)))

 - Statement: typecase expression clause...
     Each `typecase' clause has to be of one of the following forms:

          (TYPE STATEMENT...)
          ((TYPE...) STATEMENT...)

     `typecase' selects the first CLAUSE whose TYPE (or one of the
     listed TYPE's) equals or is a supertype of the run-time type of
     the result of EXPRESSION and then executes the clause's
     STATEMENT's.  Therefore, `typecase' can be used to implement a
     type dispatch for cases where the run-time type of an expression
     can be different from the static type known at translation time.
     Currently, the static type of EXPRESSION is required to be a
     subtype of `OBJECT'.

     Each TYPE expression has to be a symbol describing a simple type
     (i.e., parametric or anchored types are not allowed).  Similar to
     `case', the special key `otherwise' can be used to catch
     everything.  It is a run-time error if no clause with a matching
     type exists.  Therefore, a STELLA `typecase' without an `otherwise'
     clause corresponds to a Common Lisp `etypecase'.  An empty
     `otherwise' clause can always be specified via `(otherwise NULL)'.
     `typecase' does allow the value of EXPRESSION to be undefined, in
     which case the `otherwise' clause is selected.  Example:

          (typecase (first list)
            (CONS
             (print "it is a cons"))
            ((SYMBOL KEYWORD)
             (print "it is a symbol"))
            (STANDARD-OBJECT
             (print "it is a regular object"))
            (otherwise NULL))

     Note that in the example above it is important to list
     `STANDARD-OBJECT' after `SYMBOL' and `CONS', since it subsumes the
     preceding types.  Otherwise, it would always shadow the clauses
     with the more specific types.

     The semantics of `typecase' is slightly extended for the case where
     EXPRESSION is a local variable.  In that case each reference to
     the variable within a `typecase' clause is automatically casted to
     the appropriate narrower type.  For example, in the code snippet
     below method calls such as `first' or slot accesses such as
     `symbol-name' are translated correctly without needing to
     explicitly downcast `x' which is assumed to be of type `OBJECT':

          (typecase x
            (CONS
             (print "it is a cons with value " (first x)))
            ((SYMBOL KEYWORD)
             (print "it is a symbol with name " (symbol-name x)))
            (STANDARD-OBJECT
             (print "it is a regular object"))
            (otherwise NULL))

   Since the `typecase' EXPRESSION has to be a subtype of `OBJECT', a
`typecase' cannot be used to test against literal types such as
`STRING' or `INTEGER'.  If such type names are encountered as keys in a
`typecase', they are automatically converted to their wrapped version,
e.g., `STRING-WRAPPER', `INTEGER-WRAPPER', etc.


File: manual.info,  Node: Functions,  Next: Classes,  Prev: Control Structure,  Up: The STELLA Language

Functions (tbw)
===============

   To be written.


File: manual.info,  Node: Classes,  Next: Methods,  Prev: Functions,  Up: The STELLA Language

Classes (tbw)
=============

   To be written.


File: manual.info,  Node: Methods,  Next: Macros,  Prev: Classes,  Up: The STELLA Language

Methods (tbw)
=============

   To be written.


File: manual.info,  Node: Macros,  Next: Modules,  Prev: Methods,  Up: The STELLA Language

Macros (tbw)
============

   To be written.


File: manual.info,  Node: Modules,  Prev: Macros,  Up: The STELLA Language

Modules (tbw)
=============

   To be written.


File: manual.info,  Node: Programming in STELLA,  Next: Library Classes,  Prev: The STELLA Language,  Up: Top

Programming in STELLA
*********************

* Menu:

* Hello World in STELLA::
* Incrementally Developing STELLA Code::
* Performance Hints::


File: manual.info,  Node: Hello World in STELLA,  Next: Incrementally Developing STELLA Code,  Prev: Programming in STELLA,  Up: Programming in STELLA

Hello World in STELLA
=====================

   Included with the STELLA distribution is a simple Hello World
application that shows you how to organize your own STELLA code and
build a working STELLA application.  The sources for the Hello World
system consist of the following files:

     sources/systems/hello-world-system.ste
     sources/hello-world/file-a.ste
     sources/hello-world/file-b.ste

   STELLA organizes code modules with a simple system facility.
Translation always operates on a complete system, so you always need to
create a system definition for the STELLA files comprising your
application (somewhat similar to what you would put in a Unix Makefile).

   For the Hello World system the system definition already exists and
resides in the file `sources/systems/hello-world-system.ste'.  By
default, STELLA looks in the directory `sources/systems' to find the
definition of a particular system.  `hello-world-system.ste' defines
two things:

   (1) The `HELLO-WORLD' module which defines a namespace for all
objects in the Hello World systems.  STELLA modules are mapped onto
corresponding native namespace constructs, i.e., Lisp packages, C++
namespaces or Java packages.  The exact mapping for each language can be
defined via the keyword options `:lisp-package', `:cpp-package' and
`:java-package' in the module definition, for example:

     (defmodule "HELLO-WORLD"
       :lisp-package "STELLA"
       :cpp-package "hello_world"
       :java-package "edu.isi.hello_world"
       :uses ("STELLA"))

   The `:uses' directive tells STELLA from what other modules this one
inherits.

   (2) The actual system definitions defining what source files comprise
the system, and what parent systems this one depends on, plus a variety
of other options:

     (defsystem HELLO-WORLD
       :directory "hello-world"
       :required-systems ("stella")
       :cardinal-module "HELLO-WORLD"
       :production-settings (1 0 3 3)
       :development-settings (3 2 3 3)
       :files ("file-a"
               "file-b"))

* Menu:

* Hello World in Lisp::
* Hello World in C++::
* Hello World in Java::


File: manual.info,  Node: Hello World in Lisp,  Next: Hello World in C++,  Prev: Hello World in STELLA,  Up: Hello World in STELLA

Hello World in Lisp
-------------------

   To generate a Lisp translation of Hello World you can use either the
Lisp, C++ or Java version of STELLA.  Before you can translate you have
to make sure the following native directories exist:

     native/lisp/hello-world/
     bin/acl5.0/hello-world/

   The directory `native/lisp/hello-world/' will hold the Lisp
translations of the corresponding STELLA source files.  The directory
`bin/acl5.0/hello-world/' will hold the compiled Lisp files if you are
using Allegro CL 5.0.  If you are using a different Lisp, one of the
other binary directories as defined in the top-level file
`translations.lisp' will be used.  The directory
`bin/lisp/hello-world/' will be used as a fall-back if your version of
Lisp is not yet handled in `translations.lisp'.

   If you create your own system, you will need to create those
directories by hand (future versions of STELLA might do that
automatically).  For the Hello World system these directories already
exist.

   To generate a Lisp translation of Hello World using Lisp startup a
Lisp version of STELLA (see *Note Lisp Installation::).  The following
idiom will then translate the system into Lisp and also Lisp-compile
and load it.  The first argument to `make-system' is the name of the
system, and the second argument indicates into what language it should
be translated:

     STELLA(3): (make-system "hello-world" :common-lisp)
     Processing `/tmp/stella-3.1.0/sources/hello-world/file-a.ste':
     *** Pass 1, generating objects...
     Processing `/tmp/stella-3.1.0/sources/hello-world/file-b.ste':
     *** Pass 1, generating objects...
        .........................................
     ;;; Writing fasl file
     ;;;   /tmp/stella-3.1.0/bin/acl5.0/hello-world/startup-system.fasl
     ;;; Fasl write complete
     ; Fast loading
     ;    /tmp/stella-3.1.0/bin/acl5.0/hello-world/startup-system.fasl
     CL:T
     STELLA(4):

   After the system is loaded you can call its `main' function:

     STELLA(10): (main)
     Hello World A
     Hello World B
     bye
     ()
     STELLA(11):

   Using `main' in the Lisp version will not always make sense, since
you can call any function directly at the Lisp top level, but both C++
and Java always need a `main' function as a top-level entry point.

   While this would be somewhat unusual, you could also generate the
Lisp translation using the C++ or Java version of STELLA.  The easiest
way to do that is to run the `stella' script in the STELLA directory
like this:

     % ./stella -e '(make-system "hello-world" :common-lisp)'
     Welcome to STELLA 3.3.0
     Processing `sources/hello-world/file-a.ste':
     *** Pass 1, generating objects...
     Processing `sources/hello-world/file-b.ste':
     *** Pass 1, generating objects...
       ...............................................
     Translating `sources/hello-world/file-a.ste' to `Common Lisp'...
     Writing `native/lisp/hello-world/file-a.lisp'...
     Translating `sources/hello-world/startup-system.ste' to `Common Lisp'...
     Writing `native/lisp/hello-world/startup-system.lisp'...

   The `-e' command line option is used to evaluate an evaluable STELLA
command.  Conveniently, `make-system' is such a command, so you can
supply a `make-system' form to the C++ or Java version of STELLA just
as you would do in Lisp.  Note the extra quotes around the expression
to protect the characters from interpretation by the Unix shell.

   To compile and load the translated Lisp files into Lisp you then
have to startup a Lisp version of STELLA and call `make-system' again
which now will only compile and load the necessary files, since the
translations have already been generated in the previous step.


File: manual.info,  Node: Hello World in C++,  Next: Hello World in Java,  Prev: Hello World in Lisp,  Up: Hello World in STELLA

Hello World in C++
------------------

   To generate a C++ translation of Hello World you can use either the
Lisp, C++ or Java version of STELLA.  Before you can translate you have
to make sure the following native directory exists:

     native/cpp/hello-world/

   The directory `native/cpp/hello-world/' will hold the C++
translations of the corresponding STELLA source files.  If you create
your own system, you will need to create this directory by hand (future
versions of STELLA might do that automatically).  For the Hello World
system the directory already exist.

   To generate a C++ translation of Hello World using Lisp startup a
Lisp version of STELLA (see *Note Lisp Installation::).  The following
idiom will then translate the system into C++.  The first argument to
`make-system' is the name of the system, and the second argument
indicates into what language it should be translated:

     STELLA(4): (make-system "hello-world" :cpp)
     Processing `/tmp/stella-3.1.0/sources/hello-world/file-a.ste':
     *** Pass 1, generating objects...
     Processing `/tmp/stella-3.1.0/sources/hello-world/file-b.ste':
     *** Pass 1, generating objects...
       ...............................................
     Writing `/tmp/stella-3.1.0/native/cpp/hello-world/file-b.hh'...
     Writing `/tmp/stella-3.1.0/native/cpp/hello-world/file-b.cc'...
     Translating `/tmp/stella-3.1.0/sources/hello-world/startup-system.ste'.
     Writing `/tmp/stella-3.1.0/native/cpp/hello-world/startup-system.hh'...
     Writing `/tmp/stella-3.1.0/native/cpp/hello-world/startup-system.cc'...
     :VOID
     STELLA(5):

   Alternatively, you can generate the translation using the C++ or Java
version of STELLA.  The easiest way to do that is to run the `stella'
script in the STELLA directory like this:

     % ./stella -e '(make-system "hello-world" :cpp)'
     Welcome to STELLA 3.3.0
     Processing `sources/hello-world/file-a.ste':
     *** Pass 1, generating objects...
     Processing `sources/hello-world/file-b.ste':
     *** Pass 1, generating objects...
       ...............................................
     Writing `native/cpp/hello-world/file-b.hh'...
     Writing `native/cpp/hello-world/file-b.cc'...
     Translating `sources/hello-world/startup-system.ste'.
     Writing `native/cpp/hello-world/startup-system.hh'...
     Writing `native/cpp/hello-world/startup-system.cc'...

   The `-e' command line option is used to evaluate an evaluable STELLA
command.  Conveniently, `make-system' is such a command, so you can
supply a `make-system' form to the C++ or Java version of STELLA just
as you would do in Lisp.  Note the extra quotes around the expression
to protect the characters from interpretation by the Unix shell.

   Different from Lisp, neither of the above idioms will compile and
load the generated C++ code.  Instead you have to use the Unix `make'
facility to compile and link the C++ sources.  First change into the
native `hello-world' directory and then call `make' (*important*: the
generated Makefiles currently require the GNU version of `make'):

     % cd native/cpp/hello-world/
     % make
     g++ -w -g -O2  -DSTELLA_USE_GC -I../stella/cpp-lib/gc/include \
         -c -I.. main.cc
     g++ -w -g -O2  -DSTELLA_USE_GC -I../stella/cpp-lib/gc/include \
         -c -I.. file-a.cc
     g++ -w -g -O2  -DSTELLA_USE_GC -I../stella/cpp-lib/gc/include \
         -c -I.. file-b.cc
     g++ -w -g -O2  -DSTELLA_USE_GC -I../stella/cpp-lib/gc/include \
         -c -I.. startup-system.cc
       ..................................
     g++ -dynamic  -L../stella/cpp-lib/gc -Xlinker -rpath -Xlinker \
            '../lib:/tmp/stella-3.1.0/native/cpp/lib' \
            main.o -o hello-world \
            -L../lib -lhello-world -L../lib -lstella -lgc -lm

   The first time around this will also compile the C++ version of
STELLA and the C++ garbage collector and create a STELLA library file.
Future builds of the Hello World and other systems will use the STELLA
library file directly.  To run the Hello World system simply run the
`hello-world' executable that was built in the previous step:

     % ./hello-world
     Hello World A
     Hello World B
     bye


File: manual.info,  Node: Hello World in Java,  Prev: Hello World in C++,  Up: Hello World in STELLA

Hello World in Java
-------------------

   To generate a Java translation of Hello World you can use either the
Lisp, C++ or Java version of STELLA.  Before you can translate you have
to make sure the following native directory exists:

     native/java/edu/isi/hello-world/

   The directory `native/java/edu/isi/hello-world/' will hold the Java
translations of the corresponding STELLA source files.  If you create
your own system, you will need to create this directory by hand (future
versions of STELLA might do that automatically).  For the Hello World
system the directory already exist.

   Note that following Java convention we use the package
`edu.isi.hello_world' to hold the Hello World system.  This was
specified via the `:java-package' option in the definition of the
`HELLO-WORLD' module.  Also note that we use `hello_world' instead of
`hello-world' as the package name, since a dash cannot legally appear
as part of a Java identifier.

   To generate a Java translation of Hello World using Lisp startup a
Lisp version of STELLA (see *Note Lisp Installation::).  The following
idiom will then translate the system into Java.  The first argument to
`make-system' is the name of the system, and the second argument
indicates into what language it should be translated:

     STELLA(5): (make-system "hello-world" :java)
     Processing `/tmp/stella-3.1.0/sources/hello-world/file-a.ste':
     *** Pass 1, generating objects...
        ..............................................
     Writing `/tmp/stella-3.1.0/native/java/hello_world/Startup_Hello_...
     :VOID
     STELLA(6):

   Alternatively, you can generate the translation using the C++ or Java
version of STELLA.  The easiest way to do that is to run the `stella'
script in the STELLA directory like this:

     % ./stella -e '(make-system "hello-world" :java)'
     Welcome to STELLA 3.3.0
     Processing `sources/hello-world/file-a.ste':
     *** Pass 1, generating objects...
     Processing `sources/hello-world/file-b.ste':
     *** Pass 1, generating objects...
       ...............................................
     Writing `native/java/edu/isi/hello_world/HelloWorld.java'...
     Writing `native/java/edu/isi/hello_world/StartupFileA.java'...
     Writing `native/java/edu/isi/hello_world/StartupFileB.java'...
     Writing `native/java/edu/isi/hello_world/StartupHelloWorldSystem.java'...

   The `-e' command line option is used to evaluate an evaluable STELLA
command.  Conveniently, `make-system' is such a command, so you can
supply a `make-system' form to the C++ or Java version of STELLA just
as you would do in Lisp.  Note the extra quotes around the expression
to protect the characters from interpretation by the Unix shell.

   Different from Lisp, neither of the above idioms will compile and
load the generated C++ code.  Instead you have to use the Java compiler
to compile and Java to run the compiled Java sources.  First change into
the top-level native Java directory `native/java' and then compile and
run the Hello World system like this:

     % cd native/java/
     % javac edu/isi/hello_world/*.java
     % java edu.isi.hello_world.HelloWorld
     Hello World A
     Hello World B
     bye

   It is not necessary to Java-compile STELLA first, since STELLA
already ships with a Java compilation of the STELLA system.

