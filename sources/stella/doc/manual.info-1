This is manual.info, produced by makeinfo version 4.7 from manual.texi.

   This file documents the STELLA programming language.

   Copyright (C) 2006 University of Southern California, Information
Sciences Institute 4676 Admiralty Way Marina Del Rey, CA 90292

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.


File: manual.info,  Node: Top,  Next: Overview,  Prev: (dir),  Up: (dir)

1 STELLA Manual
***************

This document describes the STELLA programming language.  STELLA stands
for Strongly-TypEd, Lisp-like LAnguage.  It is an object-oriented
language that strongly supports symbolic programming tasks.  STELLA
programs can currently be translated into Common-Lisp, C++ and Java.
STELLA programming is best done in an Emacs-based Lisp development
environment, which leverages off Lisp's rapid prototyping and
incremental development features.  Once a STELLA program has matured, it
can be translated into C++ or Java to gain extra efficiency, to deliver
it as a stand-alone application, or to link it with other programs.

* Menu:

* Overview::
* Installation::
* The STELLA Language::
* Programming in STELLA::
* Library Classes::
* Library Functions::
* Function Index::
* Variable Index::
* Concept Index::


File: manual.info,  Node: Overview,  Next: Installation,  Prev: Top,  Up: Top

2 Introduction
**************

This document describes the STELLA programming language.  STELLA stands
for Strongly-TypEd, Lisp-like LAnguage.  It is an object-oriented
language that strongly supports symbolic programming tasks.  We
developed it, since none of the currently "healthy" languages such as
C++ or Java adequately support symbolic programming.  While Common-Lisp
would probably still be today's language of choice for many symbolic
programming applications, its dwindling vendor support and user base
make it more and more difficult to justify its use.

   When we started the development of the PowerLoom knowledge
representation system in 1995 we were faced with exactly this problem.
PowerLoom had to be delivered in C++, but it was simply incoceivable to
write such a large symbolic programming application directly in C++.
The solution was to invent a new programming language we called STELLA
and write PowerLoom in STELLA instead.

   STELLA is a strongly typed, object-oriented, Lisp-like language
specifically geared to support artificial intelligence applications.
STELLA preserves those features of Common Lisp deemed essential for
symbolic programming such as built-in support for dynamic data
structures, heterogeneous collections, first-class symbols, powerful
iteration constructs, name spaces, an object-oriented type system with a
simple meta-object protocol, exception handling, language extensibility
through macros and automatic memory management.  Maybe the biggest
difference between STELLA and Common Lisp is that STELLA is strongly
typed.  All externally visible interfaces such as slots, function
parameters and return values, etc. have to be explicitly typed.
Internal objects such as local variables, however, are mostly typed
implicitly supported by type inference.  This in conjunction with a
powerful type coercion mechanism significantly reduces the number of
explicit type information that needs to be supplied by the programmer
compared to languages such as C++ or Java.

   STELLA programs are first translated into a target language such as
Common Lisp, C++ or Java, and then compiled with the native target
language compiler to generate executable code. The language constructs
of STELLA are restricted to those that can be translated fairly directly
into native constructs of the intended target languages.  This allows
STELLA to be translated into efficient, conventional and readable Lisp,
C++ and Java code.  The resulting native code can be understood and to
some extent even maintained by programmers who don't know STELLA, and it
can easily be interfaced with other programs not written in STELLA.

   As of Fall 2000, we have programmed approximately 100,000 lines of
STELLA code - about 50% for the STELLA kernel itself and the other 50%
for the PowerLoom knowledge representation system and related systems.
Our subjective experience has been that it is only slightly more
difficult to write and debug a STELLA program than a Lisp program, and
that the inconvenience of having to supply some type information is
much outweighed by the benefits such as catching many errors during
compile time instead of at run time.

   The biggest benefit, however, seems to be that we can still leverage
all the incremental code development benefits of Lisp, since we use the
Common Lisp-based version of STELLA for prototyping.  This allows us to
incrementally define and redefine functions, methods and classes and to
inspect, debug and fix incorrect code on the fly.  Even the most
sophisticated C++ or Java IDE's don't yet seem to support this fully
incremental development style, i.e., a change in a class (every change
in Java is a change to a class) still requires recompilation and restart
of the application.  But it is the restart that can be the most time
consuming if one debugs a complex application that takes a significant
time to reach a certain state!

   Once a STELLA program has matured, it can be translated into C++ or
Java to gain extra efficiency, to deliver it as a stand-alone
application, or to link it with other programs.

* Menu:

* Credits and History::


File: manual.info,  Node: Credits and History,  Prev: Overview,  Up: Overview

2.1 Credits and History
=======================

Bob MacGregor invented STELLA in 1995 to implement the PowerLoom
knowledge representation system.  He wrote most of the first Lisp-based
kernel system of STELLA and still occasionally writes extensions or
provides fixes.  Today he is primarily a STELLA user writing his own
applications.

   Hans Chalupsky completed the first full STELLA bootstrap (STELLA
translating itself) in Spring 1996, and then went on to deal with all
the changes necessary to handle the many C++ and Java idiosyncrasies
that were discovered when the first versions of these translators came
online.  He is currently one of the principal maintainers of STELLA
supporting the STELLA code analyzer and the Lisp and C++ translators.

   Eric Melz wrote the first version of the C++ translator under very
trying circumstances (i.e., at a stage where the STELLA language
changed under him on a daily basis).  He got the first C++ version of
STELLA running in the Fall of 1996.

   Tom Russ wrote the Java translator and got the first Java version of
STELLA running in Spring 1999.  He is currently one of the principal
maintainers of STELLA supporting the STELLA code analyzer and the Lisp
and Java translators.  He is also still active writing occasional
extensions such as the STELLA XML parser.


File: manual.info,  Node: Installation,  Next: The STELLA Language,  Prev: Overview,  Up: Top

3 Installation
**************

* Menu:

* System Requirements::
* Unpacking the Sources::
* Lisp Installation::
* C++ Installation::
* Java Installation::
* X/Emacs Setup::
* Removing Unneeded Files::


File: manual.info,  Node: System Requirements,  Next: Unpacking the Sources,  Prev: Installation,  Up: Installation

3.1 System Requirements
=======================

To install and use STELLA you'll approximately need the following
amounts of disk space:

   * 8 MB for the tar-red or zip-ped archive file

   * 35 MB for the untarred sources, tanslations, compiled Java files
     and documentation

   * 8 MB to compile a Lisp version

   * 11 MB to compile the C++ version (without -g)

   * 3 MB to compile the Java version (already included)


   This means that you will need approximately 55 MB to work with one
Lisp, one C++ and one Java version of STELLA in parallel.  If you also
want to experiment with the Lisp translation variant that uses
structures instead of CLOS instances to implement STELLA objects, then
you will need an extra 8 MB to compile that.

   The full STELLA development tree is quite large, since for every
STELLA source file there are three to four translated versions and as
many compiled versions thereof.  The actual STELLA libraries that you
have to ship with an application, however, are quite small.  For
example, the Java jar file `stella.jar' is only about 1.3 MB in size.
The dynamic C++ library `libstella.so' compiled on a Linux platform is
about 4 MB.  Additionally, if you don't need all the different
translations of STELLA, you can delete some of the versions to keep your
development tree smaller (*Note Removing Unneeded Files::).

   To run the Lisp version of STELLA you need an ANSI Common-Lisp (or at
least one that supports CLOS and logical pathnames).  We have
successfully tested STELLA with Allegro-CL 4.2, 4.3, 5.0, 6.0 and 7.0,
Macintosh MCL 3.0, 4.0 and 5.1, OpenMCL 1.0, SBCL 0.9.4, CMUCL 19c,
LispWorks 4.4.6, CLisp 2.37, Lucid CL 4.1 (plus the necessary ANSI
extensions and Mark Kantrowitz's logical pathnames implementation) and
various others.  Our main development platform is Allegro CL running
under Sun Solaris and Linux, so, the closer your environment is to ours,
the higher are the chances that everything will work right out of the
box.  Lisp development under Windows should also be no problem.

   To run the C++ version of STELLA you need a C++ compiler such as g++
that supports templates and exception handling.  We have successfully
compiled and run STELLA with g++ 3.2 and later under Linux Redhat 8.0 &
9.0, SunOS and MacOS X, and with CygWin 5.0 and MinGW 5.0 under Windows
2000 and XP.  Both CygWin and MinGW provide a GNU Unix environment, but
MinGW can generate Windows executables that are fully standalone.  We've
also managed to compile STELLA under MS Visual C++, however, we never
got the Boehm garbage collector to work.  The GC claims to be very
portable, so this should be solvable for somebody with good knowledge of
MS Visual C++.

   For the Java version you will need Java JDK 1.2 or later. To get
reasonable performance, you should use J2SDK 1.4 or 1.5.  We've run the
Java version of STELLA on a variety of platforms without any problems.

   Any one of the Lisp, C++ or Java implementations of STELLA can be
used to develop your own STELLA code and translate it into all three
languages, but the most convenient development environment is the one
based on Lisp.  If you use the C++ or Java version, translating and
using your own STELLA macros is possible but not yet very well
supported.


File: manual.info,  Node: Unpacking the Sources,  Next: Lisp Installation,  Prev: System Requirements,  Up: Installation

3.2 Unpacking the Sources
=========================

Uncompress and untar the file `stella-X.Y.Z.tar.gz' (or unzip the file
`stella-X.Y.Z.zip') in the parent directory of where you want to
install STELLA (`X.Y.Z' are place holders for the actual version
numbers).  This will create the STELLA tree in the directory
`stella-X.Y.Z/'.  All pathnames mentioned below will be relative to that
directory which we will usually refer to as the "STELLA directory".


File: manual.info,  Node: Lisp Installation,  Next: C++ Installation,  Prev: Unpacking the Sources,  Up: Installation

3.3 Lisp Installation
=====================

To install the Lisp version startup Lisp and load the file
`load-stella.lisp' with:

     (CL:load "load-stella.lisp")

   The first time around this will compile all Lisp-translated STELLA
files before they are loaded.  During subsequent sessions the compiled
files will be loaded right away.

   If you want to use the version that uses Lisp structs instead of CLOS
objects to implement STELLA objects do the following:

     (CL:setq cl-user::*load-cl-struct-stella?* CL:t)
     (CL:load "load-stella.lisp")

   Alternatively, you can edit the initial value of the variable
`*load-cl-struct-stella?*' in the file `load-stella.lisp'.  Using
structs instead of CLOS objects greatly improves slot access speed,
however, it may cause problems with incremental re-definition of STELLA
classes.  It is therefore recommended to only use this for systems that
are in or near the production stage.

   Once all the files are loaded, you should see a message like this:

     Initializing STELLA...
     STELLA 3.4.0 loaded.
     Type `(in-package "STELLA")' to execute STELLA commands.
     USER(2):

   To reduce startup time, you might want to create a Lisp image that
has all of STELLA preloaded.

   Now type
     (in-package "STELLA")

   to enter the `STELLA' Lisp package where all the STELLA code resides.

   *IMPORTANT*: All unqualified Lisp symbols in this document are
assumed to be in the `STELLA' Lisp package.  Moreover, the `STELLA'
package does *NOT* inherit anything from the `COMMON-LISP' package (see
the file `sources/stella/cl-lib/cl-setup.lisp' for the few exceptions),
hence, you have to explicitly qualify every Lisp symbol you want to use
with `CL:'.  For example, to get the result of the previous evaluation
you have to type `CL:*' instead of `*'.


File: manual.info,  Node: C++ Installation,  Next: Java Installation,  Prev: Lisp Installation,  Up: Installation

3.4 C++ Installation
====================

To compile the C++ version of STELLA change to the native C++ directory
and run `make':

     % cd native/cpp/stella
     % make

   This will compile all STELLA files, the garbage collector and
generate a static or dynamic `libstella' library file in the directory
`native/cpp/lib' which can later be linked with your own C++-translated
STELLA (or other) code.  To test whether the compilation was successful
you can run STELLA from the top-level STELLA directory using the
`stella' script (or `stella.bat' under a Windows command prompt):

     % stella c++
     Running C++ version of STELLA...
     Welcome to STELLA 3.4.0
     Running kernel startup code...
     Initializing symbol tables...
     Initializing quoted constants...
     Initializing global variables...
     Creating class objects...
     Finalizing classes...
     Creating method objects...
     Finalizing methods...
     Running non-phased startup code...
     Starting up translators...
     Bye!

   This will simply run various STELLA startup code and exit.  *Note
Hello World in C++::, to see how you can use the STELLA C++ executable
to translate STELLA code.  The `c++' argument tells the script to run
the C++ version of STELLA.  If the argument is omitted and the C++
version is installed, it will be run automatically.  Otherwise, the Java
version will be run.


File: manual.info,  Node: Java Installation,  Next: X/Emacs Setup,  Prev: C++ Installation,  Up: Installation

3.5 Java Installation
=====================

Nothing needs to be done to install the Java version.  Since Java class
files are platform independent, they are already shipped with the STELLA
distribution and can be found in the directory `native/java' and its
subdirectories.  Additionally, they have been collected into the file
`native/java/lib/stella.jar'.  To try out the Java version of STELLA
run the `stella' script in the STELLA directory:

     % stella java
     Running Java version of STELLA...
     Welcome to STELLA 3.4.0
     Running kernel startup code...
     Initializing symbol tables...
     Initializing quoted constants...
     Initializing global variables...
     Creating class objects...
     Finalizing classes...
     Creating method objects...
     Finalizing methods...
     Running non-phased startup code...
     Starting up translators...
     Bye!

   Similar to the C++ executable, this will simply run various STELLA
startup code and exit.  *Note Hello World in Java::, to see how you can
use the STELLA Java executable to translate STELLA code.


File: manual.info,  Node: X/Emacs Setup,  Next: Removing Unneeded Files,  Prev: Java Installation,  Up: Installation

3.6 X/Emacs Setup
=================

STELLA development is very similar to Lisp development, and it is best
done in an X/Emacs-based Lisp development environment such as the
Allegro-CL Emacs interface plus Allegro Composer, or ILISP.  If you do
use X/Emacs with the Allegro CL interface, add the following to your
`.emacs' or `.xemacs/init.el' file:

     (setq auto-mode-alist
           (cons '("\\.ste$" . fi:common-lisp-mode) auto-mode-alist))

   If you are using the Allegro CL interface, you might want to install
the file `emacs/fi-stella.el', since it sets up proper indentation for
STELLA code and makes looking up STELLA definitions via the `C-c .' or
`M-.' commands work better.  Look at the file `emacs/fi-stella.el' for
specific installation instructions.


File: manual.info,  Node: Removing Unneeded Files,  Prev: X/Emacs Setup,  Up: Installation

3.7 Removing Unneeded Files
===========================

To save disk space you can remove files that you don't need.  For
example, if you are not interested in the C++ version of STELLA, you can
delete the directory `native/cpp'.  Similarly, you can remove
`native/java' to eliminate all Java-related files.  You could do the
same thing for the Lisp directory `native/lisp', but (in our opinion)
that would make it less convenient for you to develop new STELLA code.
Finally, if you don't need any of the STELLA sources, you can delete
the directory `sources/stella'.  If you don't need local copies of the
STELLA documentation, you can delete parts or all of the
`sources/stella/doc' directory.


File: manual.info,  Node: The STELLA Language,  Next: Programming in STELLA,  Prev: Installation,  Up: Top

4 The STELLA Language
*********************

* Menu:

* Language Overview::
* Basic Data Types::
* Control Structure::
* Functions::
* Classes::
* Methods::
* Macros::
* Modules::


File: manual.info,  Node: Language Overview,  Next: Basic Data Types,  Prev: The STELLA Language,  Up: The STELLA Language

4.1 Language Overview
=====================

STELLA is a strongly typed, object-oriented, Lisp-like language.  STELLA
programs are first translated into either Common Lisp, C++, or Java,
and then compiled with any conventional compiler for the chosen target
language to generate executable code.  Over 95% of the STELLA system is
written in STELLA itself, the rest is written in
target-language-specific native code.

   The design of STELLA borrows from a variety of programming
languages, most prominently from Common Lisp, and to a lesser degree
from other object-oriented languages such as Eiffel, Sather, and Dylan.
Since STELLA has to be translatable into C++ and Java, various
restrictions of these languages also influenced its design.

   In the following, we assume that the reader is familiar with basic
Common Lisp concepts, and has at least some familiarity with C++ or
Java.  Let us start with a cursory overview of STELLA's main features:

   *Syntax:* STELLA uses a parenthesized, uniform expression syntax
similar to Lisp.  Most definitional constructs and control structures
are similar to their Common Lisp analogues with variations to support
types.

   *Type system:* STELLA is strongly typed and supports efficient
static compilation similar to C++.  Types are required for the arguments
and return values of functions and methods, for global variables, and
for slot definitions.  Local, lexically scoped variables can be typed
implicitly by relying on type inference.

   *Object system:* Types are organized into a single inheritance class
hierarchy.  Restricted multiple inheritance is allowed via mixin
classes.  Dynamic method dispatch is based on the runtime type of the
first argument (similar to C++ and Java).  Slots can be static (native)
or dynamic.  Dynamic slots can be defined at runtime and do not occupy
any space until they are filled.  Slots can have both initial and
default values, and demons can be triggered by slot accesses.  A
meta-object protocol allows the control of object creation,
initialization, termination, and destruction.

   *Control structure:* Functions and methods are distinguished.  They
can have multiple (zero or more) return values and a variable number of
arguments.  Lisp-style macros are supported to facilitate syntax
extensions.  Expressions and statements are distinguished.  Local
variables are lexically scoped, but dynamically scoped variables
(specials) are also supported.  STELLA has an elegant, uniform, and
efficient iteration mechanism plus a built-in protocol for iterators.
An exception mechanism can be used for error handling and non-local
exits.

   *Symbolic programming:* Symbols are first-class objects, and
extensive support for dynamic datatypes such as cons-trees, lists, sets,
association lists, hash tables, extensible vectors, etc., is available.
A backquote mechanism facilitates macro writing and code generation.
Interpreted function call, method call, slot access, and object creation
is supported, and a restricted evaluator is also available.

   *Name spaces:* Functions, methods, variables, and classes occupy
separate name spaces (i.e., the same name can be used for a function and
a class).  A hierarchical module system compartmentalizes symbol tables
and supports large-scale programming.

   *Memory management:* STELLA relies on automatic memory management
via a garbage collector.  For Lisp and Java the native garbage collector
is used.  For the C++ version of STELLA we use the Boehm- Weiser
conservative garbage collector with good results.  Various built-in
support for explicit memory management is also available.

   The Common Lisp features most prominently absent from STELLA are
anonymous functions via lambda abstraction, lexical closures,
multi-methods, full-fledged eval (a restricted evaluator is available),
optional and keyword arguments, and a modifiable readtable.  STELLA
does also not allow dynamic re/definition of functions and classes,
even though the Lisp-based development environment provides this
facility (similar to Dylan).  The main influences of C++ and Java onto
STELLA are the strong typing, limited multiple inheritance,
first-argument polymorphism, and the distinction between statements and
expressions.


File: manual.info,  Node: Basic Data Types,  Next: Control Structure,  Prev: Language Overview,  Up: The STELLA Language

4.2 Basic Data Types (tbw)
==========================

To be written.


File: manual.info,  Node: Control Structure,  Next: Functions,  Prev: Basic Data Types,  Up: The STELLA Language

4.3 Control Structure (tbc)
===========================

To be completed.

* Menu:

* Conditionals::


File: manual.info,  Node: Conditionals,  Prev: Control Structure,  Up: Control Structure

4.3.1 Conditionals
------------------

STELLA conditionals are very similar to those found in Common-Lisp.
The main difference is that most STELLA conditionals are statements and
therefore do not return a value.  For this reason, a C++-style `choose'
directive has been added to the language to allow value
conditionalization based on a boolean expression.

 -- Statement: if condition then-statement else-statement
     Evaluate the boolean expression CONDITION.  If the result is true
     execute THEN-STATEMENT, otherwise, execute ELSE-STATEMENT.  Note
     that unlike the Common-Lisp version of `if' the ELSE-STATEMENT is
     not optional in STELLA.  Example:

          (if (> x y)
              (print "x is greater than y" EOL)
            (print "x is less than or equal to y" EOL))

 -- Statement: when condition statement...
     Evaluate the boolean expression CONDITION.  Only if the result is
     true execute the STATEMENT's in the body.  Example:

          (when (symbol? x)
            (print "x is a symbol, ")
            (print "its name is " (symbol-name (cast x SYMBOL)) EOL))

 -- Statement: unless condition statement...
     Evaluate the boolean expression CONDITION.  Only if the result is
     false execute the STATEMENT's in the body.  Therefore, `(unless
     TEST ...)' is equivalent to `(when (not TEST) ...)'.  Example:

          (unless (symbol? x)
            (print "x is not a symbol, ")
            (print "hence, its name is unknown" EOL))

 -- Statement: cond clause...
     `cond' is a conditional with an arbitrary number of conditions each
     represented by a CLAUSE.  Each `cond' clause has to be of the
     following form:
          (CONDITION STATEMENT...)
     The first CLAUSE whose CONDITION evaluates to true will be
     selected and its STATEMENT's will be executed.  Each clause can
     have 0 or more statements.  The special condition `otherwise'
     always evaluates to true and can be used for the catch-all case.
     Example:

          (cond ((symbol? x)
                 (print "x is a symbol" EOL))
                ((cons? x)
                 (print "x is a cons" EOL))
                (otherwise
                 (print "x is an object" EOL)))

 -- Expression: choose condition true-expression false-expression
     Evaluate the boolean expression CONDITION.  If the result is true
     return the value of TRUE-EXPRESSION, otherwise, return the value
     of FALSE-EXPRESSION.  STELLA computes the most specific common
     supertype of TRUE-EXPRESSION and FALSE-EXPRESSION and uses that as
     the type returned by the `choose' expression.  If no such type
     exists, a translation error will be signaled.  Example:

          (setq face (choose happy? :smile :frown))

 -- Statement: case expression clause...
     Each `case' clause has to be of one of the following forms:

          (KEY STATEMENT...)
          ((KEY...) STATEMENT...)

     `case' selects the first CLAUSE whose KEY (or one of the listed
     KEY's) matches the result of EXPRESSION and executes the clause's
     STATEMENT's.  Each `case' KEY has to be a constant such as a
     number, character, string, symbol, keyword or surrogate.  Keys are
     compared with `eql?' (or `string-eql?' for strings).  All keys in
     a `case' statement have to be of the same type.  The special key
     `otherwise' can be used to catch everything.  It is a run-time
     error if no clause with a matching key exists.  Therefore, a
     STELLA `case' without an `otherwise' clause corresponds to a
     Common Lisp `ecase'.  An empty `otherwise' clause can always be
     specified via `(otherwise NULL)'.  Example:

          (case car-make
            ("Yugo"
             (setq price :cheap))
            ("VW"
             (setq price :medium))
            (("Ferrari" "Rolls Royce")
             (setq price :expensive))
            (otherwise
             (setq price :unknown)))

 -- Statement: typecase expression clause...
     Each `typecase' clause has to be of one of the following forms:

          (TYPE STATEMENT...)
          ((TYPE...) STATEMENT...)

     `typecase' selects the first CLAUSE whose TYPE (or one of the
     listed TYPE's) equals or is a supertype of the run-time type of
     the result of EXPRESSION and then executes the clause's
     STATEMENT's.  Therefore, `typecase' can be used to implement a
     type dispatch for cases where the run-time type of an expression
     can be different from the static type known at translation time.
     Currently, the static type of EXPRESSION is required to be a
     subtype of `OBJECT'.

     Each TYPE expression has to be a symbol describing a simple type
     (i.e., parametric or anchored types are not allowed).  Similar to
     `case', the special key `otherwise' can be used to catch
     everything.  It is a run-time error if no clause with a matching
     type exists.  Therefore, a STELLA `typecase' without an `otherwise'
     clause corresponds to a Common Lisp `etypecase'.  An empty
     `otherwise' clause can always be specified via `(otherwise NULL)'.
     `typecase' does allow the value of EXPRESSION to be undefined, in
     which case the `otherwise' clause is selected.  Example:

          (typecase (first list)
            (CONS
             (print "it is a cons"))
            ((SYMBOL KEYWORD)
             (print "it is a symbol"))
            (STANDARD-OBJECT
             (print "it is a regular object"))
            (otherwise NULL))

     Note that in the example above it is important to list
     `STANDARD-OBJECT' after `SYMBOL' and `CONS', since it subsumes the
     preceding types.  Otherwise, it would always shadow the clauses
     with the more specific types.

     The semantics of `typecase' is slightly extended for the case where
     EXPRESSION is a local variable.  In that case each reference to
     the variable within a `typecase' clause is automatically casted to
     the appropriate narrower type.  For example, in the code snippet
     below method calls such as `first' or slot accesses such as
     `symbol-name' are translated correctly without needing to
     explicitly downcast `x' which is assumed to be of type `OBJECT':

          (typecase x
            (CONS
             (print "it is a cons with value " (first x)))
            ((SYMBOL KEYWORD)
             (print "it is a symbol with name " (symbol-name x)))
            (STANDARD-OBJECT
             (print "it is a regular object"))
            (otherwise NULL))

   Since the `typecase' EXPRESSION has to be a subtype of `OBJECT', a
`typecase' cannot be used to test against literal types such as
`STRING' or `INTEGER'.  If such type names are encountered as keys in a
`typecase', they are automatically converted to their wrapped version,
e.g., `STRING-WRAPPER', `INTEGER-WRAPPER', etc.


File: manual.info,  Node: Functions,  Next: Classes,  Prev: Control Structure,  Up: The STELLA Language

4.4 Functions (tbw)
===================

To be written.


File: manual.info,  Node: Classes,  Next: Methods,  Prev: Functions,  Up: The STELLA Language

4.5 Classes (tbw)
=================

To be written.


File: manual.info,  Node: Methods,  Next: Macros,  Prev: Classes,  Up: The STELLA Language

4.6 Methods (tbw)
=================

To be written.


File: manual.info,  Node: Macros,  Next: Modules,  Prev: Methods,  Up: The STELLA Language

4.7 Macros (tbw)
================

To be written.


File: manual.info,  Node: Modules,  Prev: Macros,  Up: The STELLA Language

4.8 Modules (tbw)
=================

To be written.


File: manual.info,  Node: Programming in STELLA,  Next: Library Classes,  Prev: The STELLA Language,  Up: Top

5 Programming in STELLA
***********************

* Menu:

* Hello World in STELLA::
* Incrementally Developing STELLA Code::
* Performance Hints::


File: manual.info,  Node: Hello World in STELLA,  Next: Incrementally Developing STELLA Code,  Prev: Programming in STELLA,  Up: Programming in STELLA

5.1 Hello World in STELLA
=========================

Included with the STELLA distribution is a simple Hello World
application that shows you how to organize your own STELLA code and
build a working STELLA application.  The sources for the Hello World
system consist of the following files:

     sources/systems/hello-world-system.ste
     sources/hello-world/file-a.ste
     sources/hello-world/file-b.ste

   STELLA organizes code modules with a simple system facility.
Translation always operates on a complete system, so you always need to
create a system definition for the STELLA files comprising your
application (somewhat similar to what you would put in a Unix Makefile).

   For the Hello World system the system definition already exists and
resides in the file `sources/systems/hello-world-system.ste'.  By
default, STELLA looks in the directory `sources/systems' to find the
definition of a particular system.  `hello-world-system.ste' defines
two things:

   (1) The `HELLO-WORLD' module which defines a namespace for all
objects in the Hello World systems.  STELLA modules are mapped onto
corresponding native namespace constructs, i.e., Lisp packages, C++
namespaces or Java packages.  The exact mapping for each language can be
defined via the keyword options `:lisp-package', `:cpp-package' and
`:java-package' in the module definition, for example:

     (defmodule "HELLO-WORLD"
       :lisp-package "STELLA"
       :cpp-package "hello_world"
       :java-package "edu.isi.hello_world"
       :uses ("STELLA"))

   The `:uses' directive tells STELLA from what other modules this one
inherits.

   (2) The actual system definitions defining what source files comprise
the system, and what parent systems this one depends on, plus a variety
of other options:

     (defsystem HELLO-WORLD
       :directory "hello-world"
       :required-systems ("stella")
       :cardinal-module "HELLO-WORLD"
       :production-settings (1 0 3 3)
       :development-settings (3 2 3 3)
       :files ("file-a"
               "file-b"))

* Menu:

* Hello World in Lisp::
* Hello World in C++::
* Hello World in Java::


File: manual.info,  Node: Hello World in Lisp,  Next: Hello World in C++,  Prev: Hello World in STELLA,  Up: Hello World in STELLA

5.1.1 Hello World in Lisp
-------------------------

To generate a Lisp translation of Hello World you can use either the
Lisp, C++ or Java version of STELLA.  Before you can translate you have
to make sure the following native directories exist:

     native/lisp/hello-world/
     bin/acl7.0/hello-world/

   The directory `native/lisp/hello-world/' will hold the Lisp
translations of the corresponding STELLA source files.  The directory
`bin/acl7.0/hello-world/' will hold the compiled Lisp files if you are
using Allegro CL 7.0.  If you are using a different Lisp, one of the
other binary directories as defined in the top-level file
`translations.lisp' will be used.  The directory
`bin/lisp/hello-world/' will be used as a fall-back if your version of
Lisp is not yet handled in `translations.lisp'.

   If you create your own system, you will need to create those
directories by hand (future versions of STELLA might do that
automatically).  For the Hello World system these directories already
exist.

   To generate a Lisp translation of Hello World using Lisp startup a
Lisp version of STELLA (see *Note Lisp Installation::).  The following
idiom will then translate the system into Lisp and also Lisp-compile
and load it.  The first argument to `make-system' is the name of the
system, and the second argument indicates into what language it should
be translated:

     STELLA(3): (make-system "hello-world" :common-lisp)
     Processing `/tmp/stella-3.1.0/sources/hello-world/file-a.ste':
     *** Pass 1, generating objects...
     Processing `/tmp/stella-3.1.0/sources/hello-world/file-b.ste':
     *** Pass 1, generating objects...
        .........................................
     ;;; Writing fasl file
     ;;;   /tmp/stella-3.1.0/native/lisp/bin/acl7.0/hello-world/startup-system.fasl
     ;;; Fasl write complete
     ; Fast loading
     ;    /tmp/stella-3.1.0/native/lisp/bin/acl7.0/hello-world/startup-system.fasl
     CL:T
     STELLA(4):

   After the system is loaded you can call its `main' function:

     STELLA(10): (main)
     Hello World A
     Hello World B
     bye
     ()
     STELLA(11):

   Using `main' in the Lisp version will not always make sense, since
you can call any function directly at the Lisp top level, but both C++
and Java always need a `main' function as a top-level entry point.

   While this would be somewhat unusual, you could also generate the
Lisp translation using the C++ or Java version of STELLA.  The easiest
way to do that is to run the `stella' script in the STELLA directory
like this:

     % ./stella -e '(make-system "hello-world" :common-lisp)'
     Running C++ version of STELLA...
     Welcome to STELLA 3.4.0
     Processing `sources/hello-world/file-a.ste':
     *** Pass 1, generating objects...
     Processing `sources/hello-world/file-b.ste':
     *** Pass 1, generating objects...
       ...............................................
     Translating `sources/hello-world/file-a.ste' to `Common Lisp'...
     Writing `native/lisp/hello-world/file-a.lisp'...
     Translating `sources/hello-world/startup-system.ste' to `Common Lisp'...
     Writing `native/lisp/hello-world/startup-system.lisp'...

   The `-e' command line option is used to evaluate an evaluable STELLA
command.  Conveniently, `make-system' is such a command, so you can
supply a `make-system' form to the C++ or Java version of STELLA just
as you would do in Lisp.  Note the extra quotes around the expression
to protect the characters from interpretation by the Unix shell.

   To compile and load the translated Lisp files into Lisp you then
have to startup a Lisp version of STELLA and call `make-system' again
which now will only compile and load the necessary files, since the
translations have already been generated in the previous step.


File: manual.info,  Node: Hello World in C++,  Next: Hello World in Java,  Prev: Hello World in Lisp,  Up: Hello World in STELLA

5.1.2 Hello World in C++
------------------------

To generate a C++ translation of Hello World you can use either the
Lisp, C++ or Java version of STELLA.  Before you can translate you have
to make sure the following native directory exists:

     native/cpp/hello-world/

   The directory `native/cpp/hello-world/' will hold the C++
translations of the corresponding STELLA source files.  If you create
your own system, you will need to create this directory by hand (future
versions of STELLA might do that automatically).  For the Hello World
system the directory already exist.

   To generate a C++ translation of Hello World using Lisp startup a
Lisp version of STELLA (see *Note Lisp Installation::).  The following
idiom will then translate the system into C++.  The first argument to
`make-system' is the name of the system, and the second argument
indicates into what language it should be translated:

     STELLA(4): (make-system "hello-world" :cpp)
     Processing `/tmp/stella-3.1.0/sources/hello-world/file-a.ste':
     *** Pass 1, generating objects...
     Processing `/tmp/stella-3.1.0/sources/hello-world/file-b.ste':
     *** Pass 1, generating objects...
       ...............................................
     Writing `/tmp/stella-3.1.0/native/cpp/hello-world/file-b.hh'...
     Writing `/tmp/stella-3.1.0/native/cpp/hello-world/file-b.cc'...
     Translating `/tmp/stella-3.1.0/sources/hello-world/startup-system.ste'.
     Writing `/tmp/stella-3.1.0/native/cpp/hello-world/startup-system.hh'...
     Writing `/tmp/stella-3.1.0/native/cpp/hello-world/startup-system.cc'...
     :VOID
     STELLA(5):

   Alternatively, you can generate the translation using the C++ or Java
version of STELLA.  The easiest way to do that is to run the `stella'
script in the STELLA directory like this:

     % ./stella -e '(make-system "hello-world" :cpp)'
     Running C++ version of STELLA...
     Welcome to STELLA 3.4.0
     Processing `sources/hello-world/file-a.ste':
     *** Pass 1, generating objects...
     Processing `sources/hello-world/file-b.ste':
     *** Pass 1, generating objects...
       ...............................................
     Writing `native/cpp/hello-world/file-b.hh'...
     Writing `native/cpp/hello-world/file-b.cc'...
     Translating `sources/hello-world/startup-system.ste'.
     Writing `native/cpp/hello-world/startup-system.hh'...
     Writing `native/cpp/hello-world/startup-system.cc'...

   The `-e' command line option is used to evaluate an evaluable STELLA
command.  Conveniently, `make-system' is such a command, so you can
supply a `make-system' form to the C++ or Java version of STELLA just
as you would do in Lisp.  Note the extra quotes around the expression
to protect the characters from interpretation by the Unix shell.

   Different from Lisp, neither of the above idioms will compile and
load the generated C++ code.  Instead you have to use the Unix `make'
facility to compile and link the C++ sources.  First change into the
native `hello-world' directory and then call `make' (*important*: the
generated Makefiles currently require the GNU version of `make'):

     % cd native/cpp/hello-world/
     % make
     g++ -w -g -O2  -DSTELLA_USE_GC -I../stella/cpp-lib/gc/include \
         -c -I.. main.cc
     g++ -w -g -O2  -DSTELLA_USE_GC -I../stella/cpp-lib/gc/include \
         -c -I.. file-a.cc
     g++ -w -g -O2  -DSTELLA_USE_GC -I../stella/cpp-lib/gc/include \
         -c -I.. file-b.cc
     g++ -w -g -O2  -DSTELLA_USE_GC -I../stella/cpp-lib/gc/include \
         -c -I.. startup-system.cc
       ..................................
     g++ -dynamic  -L../stella/cpp-lib/gc -Xlinker -rpath -Xlinker \
            '../lib:/tmp/stella-3.1.0/native/cpp/lib' \
            main.o -o hello-world \
            -L../lib -lhello-world -L../lib -lstella -lgc -lm

   The first time around this will also compile the C++ version of
STELLA and the C++ garbage collector and create a STELLA library file.
Future builds of the Hello World and other systems will use the STELLA
library file directly.  To run the Hello World system simply run the
`hello-world' executable that was built in the previous step:

     % ./hello-world
     Hello World A
     Hello World B
     bye


File: manual.info,  Node: Hello World in Java,  Prev: Hello World in C++,  Up: Hello World in STELLA

5.1.3 Hello World in Java
-------------------------

To generate a Java translation of Hello World you can use either the
Lisp, C++ or Java version of STELLA.  Before you can translate you have
to make sure the following native directory exists:

     native/java/edu/isi/hello-world/

   The directory `native/java/edu/isi/hello-world/' will hold the Java
translations of the corresponding STELLA source files.  If you create
your own system, you will need to create this directory by hand (future
versions of STELLA might do that automatically).  For the Hello World
system the directory already exist.

   Note that following Java convention we use the package
`edu.isi.hello_world' to hold the Hello World system.  This was
specified via the `:java-package' option in the definition of the
`HELLO-WORLD' module.  Also note that we use `hello_world' instead of
`hello-world' as the package name, since a dash cannot legally appear
as part of a Java identifier.

   To generate a Java translation of Hello World using Lisp startup a
Lisp version of STELLA (see *Note Lisp Installation::).  The following
idiom will then translate the system into Java.  The first argument to
`make-system' is the name of the system, and the second argument
indicates into what language it should be translated:

     STELLA(5): (make-system "hello-world" :java)
     Processing `/tmp/stella-3.1.0/sources/hello-world/file-a.ste':
     *** Pass 1, generating objects...
        ..............................................
     Writing `/tmp/stella-3.1.0/native/java/hello_world/Startup_Hello_...
     :VOID
     STELLA(6):

   Alternatively, you can generate the translation using the C++ or Java
version of STELLA.  The easiest way to do that is to run the `stella'
script in the STELLA directory like this:

     % ./stella -e '(make-system "hello-world" :java)'
     Running C++ version of STELLA...
     Welcome to STELLA 3.4.0
     Processing `sources/hello-world/file-a.ste':
     *** Pass 1, generating objects...
     Processing `sources/hello-world/file-b.ste':
     *** Pass 1, generating objects...
       ...............................................
     Writing `native/java/edu/isi/hello_world/HelloWorld.java'...
     Writing `native/java/edu/isi/hello_world/StartupFileA.java'...
     Writing `native/java/edu/isi/hello_world/StartupFileB.java'...
     Writing `native/java/edu/isi/hello_world/StartupHelloWorldSystem.java'...

   The `-e' command line option is used to evaluate an evaluable STELLA
command.  Conveniently, `make-system' is such a command, so you can
supply a `make-system' form to the C++ or Java version of STELLA just
as you would do in Lisp.  Note the extra quotes around the expression
to protect the characters from interpretation by the Unix shell.

   Different from Lisp, neither of the above idioms will compile and
load the generated C++ code.  Instead you have to use the Java compiler
to compile and Java to run the compiled Java sources.  First change into
the top-level native Java directory `native/java' and then compile and
run the Hello World system like this:

     % cd native/java/
     % javac edu/isi/hello_world/*.java
     % java edu.isi.hello_world.HelloWorld
     Hello World A
     Hello World B
     bye

   It is not necessary to Java-compile STELLA first, since STELLA
already ships with a Java compilation of the STELLA system.


File: manual.info,  Node: Incrementally Developing STELLA Code,  Next: Performance Hints,  Prev: Hello World in STELLA,  Up: Programming in STELLA

5.2 Incrementally Developing STELLA Code
========================================

The preferred method of STELLA code development is to use a Lisp-based
version of STELLA for all the prototyping and testing, since that allows
you to exploit most (or all) of the rapid-prototyping advantages of
Lisp.  Once a system has reached a certain point of stability, it can be
translated into C++ or Java for delivery or to interface it with other
C++ or Java code.

   In the following, we assume an X/Emacs-based Lisp development
environment such as the Allegro CL Emacs interface, where Lisp is run in
an Emacs subprocess, and Lisp source can be compiled and evaluated
directly from the source buffers.  By "Lisp buffer" we mean the listener
buffer in which Lisp is actually running, and by "source buffer" we mean
a buffer that is used to edit a file that contains STELLA source.

   Included in the distribution is the Hello World system comprised of
the files

     sources/systems/hello-world-system.ste
     sources/hello-world/file-a.ste
     sources/hello-world/file-b.ste

   To get started, simply add your code to either `file-a.ste' or
`file-b.ste', since all the necessary definitions and directories for
these files are already set up properly.  See section ??? on how to
setup your own system.

   Make sure the Hello World system is loaded into Lisp by doing the
following:

     (make-system "hello-world" :common-lisp)

   This will make sure that the system definition is loaded and the
necessary module definition is evaluated.

   Now suppose you add the following function to `file-a.ste':

     (defun (factorial INTEGER) ((n INTEGER))
       (if (eql? n 0)
           (return 1)
         (return (* n (factorial (1- n))))))

   There are various options for translating and evaluating this
definition.  For example, you can simply remake the complete system
similar to what you would do for a C++ or Java program:

     (make-system "hello-world" :common-lisp)

   This will retranslate the modified files, recompile them and reload
them into your Lisp image.

   Instead of retranslating and recompiling everything, you can
incrementally evaluate the definition of `factorial' from your
Emacs-to-Lisp interface.  Simply put your cursor somewhere inside the
definition in the source buffer and evaluate it by typing `M-C-x'.
This translates the STELLA code into Lisp and compiles (or evaluates)
the resulting Lisp code.  Now you can actually try it out in the Lisp
buffer, for example:

     STELLA(4): (factorial 6)
     720

   Finally, instead of evaluating the definition in the source buffer,
you can also enter it directly at the Lisp prompt with the same effect.

   The way this works is that the Lisp symbol `stella::defun' is
actually bound to a Lisp macro that calls all the necessary translation
machinery to convert the STELLA `defun' into Lisp code.  Look at the
file `sources/stella/cl-lib/stella-to-cl.ste' for the complete set of
such macros.  This might be a bit confusing, since there are now three
different bindings (or meanings) of `defun':

  1. The STELLA operator `defun' used to define STELLA functions.

  2. The Lisp macro `stella::defun' that resides in the `STELLA' Lisp
     package and is only available for convenience in Lisp versions of
     STELLA.

  3. The Lisp macro `CL:defun' which is the standard Common Lisp macro
     used to define Lisp functions.

   We'll try to explicitly qualify which meaning is used wherever there
might be some doubt which one is meant.  In general, every unqualified
symbol mentioned below is either part of the STELLA language or resides
in the STELLA Lisp package.

   Since a newly-written STELLA function might have errors, it is
prudent to first only translate it without actually executing the
result of the translation.  In the source buffer you can do that by
macro-expanding the `defun'.  For example, if you use the Allegro CL
interface you would position the cursor on the opening parenthesis of
the `defun' and then type `M-M'.  Any errors discovered by the STELLA
translator are reported in the Lisp buffer window.  The expansion will
be a `CL:progn' that contains the translated definition as the first
element plus various startup-time (initialization) code following it.

   In the Lisp buffer you can achieve a similar effect with the
`lptrans' macro.  For example, executing

     (lptrans
      (defun (factorial INTEGER) ((n INTEGER))
        (if (eql? n 0)
            (return 1)
          (return (* n (factorial (1- n)))))))

   in the Lisp buffer first Lisp-translates the definition, and then
prints the translation.  To see the C++ translation you can use
`cpptrans', calling `jptrans' will generate the Java translation.

   You can also use `lptrans'/`cpptrans'/`jptrans' to translate code
fragments that are not top-level definitions such as `defun' and its
friends.  For example:

     STELLA(8): (lptrans
                 (foreach element in (list 1 2 3)
                     do (print element EOL)))

     (CL:LET* ((ELEMENT NULL)
               (ITER-003
                (%THE-CONS-LIST (LIST (WRAP-INTEGER 1) (WRAP-INTEGER 2)
                                      (WRAP-INTEGER 3)))))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
                (CL:PROGN (SETQ ELEMENT (%%VALUE ITER-003))
                          (SETQ ITER-003 (%%REST ITER-003)))
                (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
                                ELEMENT EOL)))
     ()
     STELLA(9): (cpptrans
                 (foreach element in (list 1 2 3)
                     do (print element EOL)))
     { Object* element = NULL;
       Cons* iter004 = list(3, wrapInteger(1), wrapInteger(2),
                               wrapInteger(3))-> theConsList;

       while (!(iter004 == NIL)) {
         element = iter004->value;
         iter004 = iter004->rest;
         cout << element << endl;
       }
     }
     :VOID
     STELLA(10): (jptrans
                  (foreach element in (list 1 2 3)
                      do (print element EOL)))
     { Stella_Object element = null;
       Cons iter005 = Stella.list
                       (Stella_Object.cons
                         (IntegerWrapper.wrapInteger(1),
                          Stella_Object.cons
                           (IntegerWrapper.wrapInteger(2),
                            Stella_Object.cons
                             (IntegerWrapper.wrapInteger(3),
                              Stella.NIL)))).theConsList;

       while (!(iter005 == Stella.NIL)) {
         {
           element = iter005.value;
           iter005 = iter005.rest;
         }
         java.lang.System.out.println(element);
       }
     }
     :VOID

   The use of `lptrans' is really necessary here, since there is no
Lisp macro `foreach' that knows how to translate STELLA `foreach' loops
(those Lisp macros only exist for top-level definition commands such as
`defun').  In order to translate such code fragments without error
messages, they need to be self-contained, i.e., all referenced
variables have to be either bound by a surrounding `let', or they must
be globally defined variables.  Otherwise, the STELLA translator will
generate various "undefined variable" error messages.

   You can use the STELLA Lisp macro `eval' (i.e., `stella::eval' not
`CL:eval') to actually execute such a code fragment.  For example:

     STELLA(11): (eval
                  (foreach element in (list 1 2 3)
                      do (print element EOL)))
     |L|1
     |L|2
     |L|3
     ()

   This translates the loop and executes the result, which prints the
wrapped numbers (hence, the `|L|' prefix) to standard output.  The `()'
at the end is the resulting Lisp value returned by the loop (in Lisp
everything returns a value, even though for STELLA `foreach' is a
statement, not an expression).

   Make it a habit to wrap `eval' around any STELLA code you
incrementally evaluate in the Lips buffer.  This makes sure that all the
arguments to a function, etc., are translated into the appropriate
STELLA objects.  For example, evaluating

     (eval (list :a :b :c))

   in the Lisp buffer generates a STELLA list that points to the STELLA
keywords `:a', `:b' and `:c'.  If you don't use `eval', for example,

     (list :a :b :c)

   a STELLA list containing the Lisp keywords `:a', `:b' and `:c' will
be created.  Lisp keywords are a completely different data structure
than STELLA keywords, and any STELLA code expecting a STELLA keyword but
finding a Lisp keyword will break, since Lisp keywords are not a legal
STELLA data structure.  Unfortunately, such cases can be very confusing,
since Lisp and STELLA keywords look/print exactly alike.

   `eval' is also necessary to access STELLA symbols and surrogates in
the Lisp buffer.  For example, to access a STELLA symbol, you can use
`quote' (again, this is the STELLA `quote' not `CL:quote'):

     (eval (quote foo))

   This returns the STELLA symbol `foo'.  We explicitly used `quote'
here, since code typed at the Lisp prompt is first passed through the
Lisp reader before the STELLA translator sees it, and the default Lisp
reader interprets the `'' character differently than the STELLA reader.
Within a STELLA file you can use the syntax `'foo', since it will be
read directly by the STELLA reader that knows how to interpret it
correctly.

   `lptrans', `cpptrans' and `jptrans' are evaluable STELLA commands
that can also be evaluated by the C++ and Java version of STELLA.  For
example, to generate a Java translation of a little STELLA code
fragment you could run the `stella' script in the STELLA directory like
this (the output below has been additionally indented by hand for
clarity):

     % ./stella -e '(jptrans\
                      (foreach element in (list 1 2 3)\
                         do (print element EOL)))'
     Running C++ version of STELLA...
     Welcome to STELLA 3.4.0
     { Stella_Object element = null;
       Cons iter001 = Stella.list
                       (Stella_Object.cons
                         (IntegerWrapper.wrapInteger(1),
                          Stella_Object.cons
                           (IntegerWrapper.wrapInteger(2),
                            Stella_Object.cons
                             (IntegerWrapper.wrapInteger(3),
                              Stella.NIL)))).theConsList;

       while (!(iter001 == Stella.NIL)) {
         {
           element = iter001.value;
           iter001 = iter001.rest;
         }
         java.lang.System.out.println(element);
       }
     }


File: manual.info,  Node: Performance Hints,  Prev: Incrementally Developing STELLA Code,  Up: Programming in STELLA

5.3 Performance Hints
=====================

Here are a few things to watch out for once you get serious about the
performance of your translated STELLA programs:

   *Safety checks:* The STELLA variable `*safety*' controls whether
certain safety code is added to your translated STELLA program.  For
Lisp translations it also controls whether `cast''s will be translated
into run-time type checks or not.  There is no run-time type checking
performed in C++.  In Java native casts will always perform runtime
type tests.  The default `*safety*' level is 3 which enables the
translation of all `safety' clauses with level 3 or lower.  A safety
level of 1 or lower disables the generation of calls to the `cast'
function in Lisp.  `cast' performs run-time type checks which are
somewhat expensive.  However, you should not disable run-time type
checking in Lisp until you have fully debugged your program.  Once you
are confident that your program works correctly, you can set `*safety*'
to 0 before you translate it.  That way you will avoid the generation
and execution of any safety code at all.  All of the core STELLA system
was translated with `*safety*' set to 1.

   *Quoted cons trees:* Access to quoted constants that are not symbols
is somewhat slow, since it currently uses hashing to find them in a
table.  Hence, access to quoted constants such as `(quote (foo bar
fum))' should be avoided in inner loops.  Access to quoted symbols such
as `(quote foo)' is fast and does not cause any performance problems.
The use of `quote' for constant cons trees is rare in STELLA (and
somewhat deprecated), which is the reason why this mechanism is not all
that well supported.  Future versions of STELLA might re-implement the
handling of constants and alleviate this performance problem.

   *Equality tests:* The standard equality test in STELLA is `eql?',
which the translator will translate into the most efficient equality
test for the particular types of operands (`eql?' is somewhat similar
to the Lisp function `CL:eql' with the exception of comparing strings).
If the translator can determine that at least one of the operands is a
subtype of `STANDARD-OBJECT', it will translate the test into a fast
pointer comparison with the Lisp function `CL:eq' or the C++/Java `=='
operator.  However, if both operands are of type `OBJECT', they might
be wrapped literals such as wrapped integers or strings.  In that case
the equality test translates into a call to the function `eql?' which
in turn uses method calls to handle comparison of different types of
wrapped literals (two wrapped literals are equal if their wrapped
content is equal).  This is of course a lot less efficient than a
simple pointer comparison.  It also means that if you can restrict the
type of a variable that will be tested with `eql?' to
`STANDARD-OBJECT', you probably should do so for performance reasons.

   *Type tests:* Run-time type tests as used implicitly within a
`typecase' or explicitly with functions such as `cons?' have to use a
call to the method `primary-type'.  Hence, in performance-critical
portions of your code you should try to keep the number of such tests
as small as possible.

   *Wrapping and unwrapping literals:* The STELLA translator
automatically wraps (or objectifies) literals such as numbers or strings
when they are stored in a variable or slot of type `OBJECT'.
Similarly, it unwraps wrapped literals automatically to operate on the
literal directly.  This is very convenient, since it relieves the
programmer from having to perform these conversions by hand and makes
the code less cluttered.  For example, consider the following code
fragment:

     (let ((l (cons "foo" nil))
           (x (concatenate "bar" (first l))))
       (print x EOL)))
   Here is its C++ translation:
     { Cons* l = cons(wrapString("foo"), NIL);
        char* x = stringConcatenate
                   ("bar", ((StringWrapper*)(l->value))->wrapperValue, 0);

       std::cout << x << std::endl;
     }

   Notice how the string literal `"foo"' is first wrapped so it can be
inserted into the `CONS' list `l' and then automatically unwrapped in
the call to `concatenate'.  While this is very convenient, it does
cause a certain overhead that should be avoided in performance critical
loops, etc.  In such situations, it often helps to use auxiliary
variables of the appropriate literal type to avoid unnecessary
wrap/unwrap operations.

   *Lisp-style property lists:* Lisp programs often use property lists
for fast retrieval of information that is linked to symbols.  To
support the easy translation of existing Lisp programs that use this
paradigm into STELLA, a similar mechanism implemented by the functions
`symbol-value', `symbol-plist', and `symbol-property' is available that
preserves the performance benefits of this storage scheme (see the file
`sources/stella/symbols.ste').  However, property lists do not fit the
object-oriented programming paradigm supported by STELLA, and, hence,
are frowned upon.

   *Compiler optimization:* The optimization settings used with the
native Lisp or C++ compiler can greatly influence performance results.
In particular, using high optimization settings with the Lisp compiler
can greatly improve slot access time on STELLA objects.

* Menu:

* Lisp Performance Hints::


File: manual.info,  Node: Lisp Performance Hints,  Prev: Performance Hints,  Up: Performance Hints

5.3.1 Lisp Performance Hints
----------------------------

The standard Lisp implementation for STELLA objects are CLOS objects,
since CLOS provides the most natural Lisp implementation for the STELLA
object system.  However, there is a price to pay, since in Lisp slot
access on CLOS objects is a lot slower than slot access on structs.  For
example, in Allegro CL 4.3, the access to the `value' slot of a STELLA
CONS cell takes about 4 times longer on a CLOS object implementation of
`CONS' than on a struct implementation.  Unfortunately, the struct
implementation itself takes about 3 times longer than calling `CL:car'
on a Lisp cons, which is why we are actually using Lisp conses as the
Lisp implementation for STELLA `CONS'es.  Note, that in the C++ and
Java translation these slot-access performance problems are nonexistent.

   In order to get the maximum performance out of the Lisp version of
STELLA, you can tell the translator to use structs as the implementation
for STELLA objects.  It does so by using `CL:defstruct' instead of
`CL:defclass' and dispatches methods directly on the structure object.

   To use the struct translation scheme evaluate

     (set-stella-feature :use-common-lisp-structs)

   before you translate a STELLA system.  This will generate translated
files with a `.slisp' extension.  Make sure that after you translated
all the files you are interested in, you disable the above feature with

     (unset-stella-feature :use-common-lisp-structs)

   Otherwise, subsequent incremental translations in that Lisp image
might fail, since different translation schemes cannot be mixed.  If you
already are using the struct version of STELLA, all systems will be
translated in struct mode by default.

   To use the struct translation of your system you have to use the
struct version of STELLA.  To do so do the following:

     (CL:setq cl-user::*load-cl-struct-stella?* CL:t)
     (CL:load "load-stella.lisp")

   Alternatively, you can edit the initial value of the variable
`*load-cl-struct-stella?*' in the file `load-stella.lisp' (see also
*Note Lisp Installation::).

   The reasons why the struct translation scheme is not enabled by
default are the following:

   * Incremental redefinition of STELLA classes does not redefine any
     objects created with the old definition, and, hence, slot
     accessors might simply break or retrieve the value of a different
     slot when applied to such an old object.  The programmer therefore
     has to be very careful when redefining a STELLA class while in
     struct mode.  This means, that you should view the usage of the
     struct-translation scheme for Lisp as a kind of delivery option,
     similar to translating into C++.  Part of the reason why slot
     access on CLOS object is expensive is the indirection machinery
     that allows redefinition of classes and their associated instances.
     This is great for code development, but the flexibility and
     expense is usually not needed or warranted for delivered code.

   * The performance trade-offs between CLOS and struct versions might
     be different in different versions of Lisp.  For example, in older
     version of Allegro CL slot access on structs was fast, but method
     dispatch was significantly slower than for CLOS objects which
     eliminated some/all of the performance gains.


File: manual.info,  Node: Library Classes,  Next: Library Functions,  Prev: Programming in STELLA,  Up: Top

6 Library Classes (tbw)
***********************

To be written.


File: manual.info,  Node: Library Functions,  Next: Function Index,  Prev: Library Classes,  Up: Top

7 Library Functions
*******************

* Menu:

* Basic Constants and Predicates::
* Numbers::
* Characters::
* Strings::
* CONS Lists and Trees::
* Lists::
* Property and Key-Value Lists::
* Vectors::
* Hash Tables::
* Key Value Maps::
* Hash Sets::
* Iterators::
* Symbols::
* Contexts and Modules::
* Input and Output::
* Files::
* Dates and Times::
* XML Support::
* Miscellaneous::


File: manual.info,  Node: Basic Constants and Predicates,  Next: Numbers,  Prev: Library Functions,  Up: Library Functions

7.1 Basic Constants and Predicates
==================================

 -- ???: true
     Not yet implemented.

 -- ???: false
     Not yet implemented.

 -- Method on OBJECT: null? (x) : BOOLEAN
     Return true if X is undefined (handled specially by all
     translators).

 -- Method on SECOND-CLASS-OBJECT: null? (x) : BOOLEAN
     Return true if X is undefined (handled specially by all
     translators).

 -- Method on NATIVE-VECTOR: null? (x) : BOOLEAN
     Return true if X is undefined (handled specially by all
     translators).

 -- Method on STRING: null? (x) : BOOLEAN
     Return true if X is undefined (handled specially by all
     translators).

 -- Method on MUTABLE-STRING: null? (x) : BOOLEAN
     Return true if X is undefined (handled specially by all
     translators).

 -- Method on CHARACTER: null? (x) : BOOLEAN
     Return true if X is undefined (handled specially by all
     translators).

 -- Method on CODE: null? (x) : BOOLEAN
     Return true if X is undefined (handled specially by all
     translators).

 -- Method on INTEGER: null? (x) : BOOLEAN
     Return true if X is undefined (handled specially by all
     translators).

 -- Method on FLOAT: null? (x) : BOOLEAN
     Return true if X is undefined (handled specially by all
     translators).

 -- Method on OBJECT: defined? (x) : BOOLEAN
     Return true if X is defined (handled specially by all translators).

 -- Method on SECOND-CLASS-OBJECT: defined? (x) : BOOLEAN
     Return true if X is defined (handled specially by all translators).

 -- Method on NATIVE-VECTOR: defined? (x) : BOOLEAN
     Return true if X is defined (handled specially by all translators).

 -- Method on STRING: defined? (x) : BOOLEAN
     Return true if X is defined (handled specially by all translators).

 -- Method on MUTABLE-STRING: defined? (x) : BOOLEAN
     Return true if X is defined (handled specially by all translators).

 -- Method on CHARACTER: defined? (x) : BOOLEAN
     Return true if X is defined (handled specially by all translators).

 -- Method on CODE: defined? (x) : BOOLEAN
     Return true if X is defined (handled specially by all translators).

 -- Method on INTEGER: defined? (x) : BOOLEAN
     Return true if X is defined (handled specially by all translators).

 -- Method on FLOAT: defined? (x) : BOOLEAN
     Return true if X is defined (handled specially by all translators).

 -- Function: eq? ((x UNKNOWN) (y UNKNOWN)) : BOOLEAN
     Return true if X and Y are literally the same object (or simple
     number).  Analogue to the Common Lisp EQL and C++ and Java's ==.

 -- Function: eql? ((x OBJECT) (y OBJECT)) : BOOLEAN
     Return true if X and Y are `eq?' or equivalent literals such as
     strings that also might be wrapped in non-identical wrappers.  For
     the case where X or Y are plain literals such as strings or
     integers, the STELLA translator substitutes the equality test
     appropriate for the particular target language and does not
     actually call this function.  For cases where X or Y are known to
     be of type STANDARD-OBJECT, the STELLA translator substitutes the
     faster `eq?' test inline.

 -- Function: equal? ((x OBJECT) (y OBJECT)) : BOOLEAN
     Return true if X and Y are `eql?' or considered equal by a
     user-defined `object-equal?' method.  This implements a fully
     extensible equality test similar to Java's `equals' method.  Note
     that writers of custom `object-equal?' methods must also implement
     a corresponding `equal-hash-code' method.

 -- Method on OBJECT: object-equal? (x (y OBJECT)) : BOOLEAN
     Return true if X and Y are `eq?'.

 -- Method on WRAPPER: object-equal? (x (y OBJECT)) : BOOLEAN
     Return true if X and Y are literal wrappers whose literals are
     considered `eql?'.


File: manual.info,  Node: Numbers,  Next: Characters,  Prev: Basic Constants and Predicates,  Up: Library Functions

7.2 Numbers
===========

 -- Constant: pi : FLOAT
     A float approximation of the mathematical constant pi.

 -- Function: + (&rest (arguments NUMBER)) : NUMBER
     Return the sum of all ARGUMENTS.

 -- Function: - ((x NUMBER) &rest (arguments NUMBER)) : NUMBER
     If only X was supplied return the result of 0 - X.  Otherwise,
     return the result of (...((X - arg1) - arg2) - ... - argN).

 -- Function: * (&rest (arguments NUMBER)) : NUMBER
     Return the product of all ARGUMENTS.

 -- Function: / ((x NUMBER) &rest (arguments NUMBER)) : NUMBER
     If only X was supplied return the result of 1 / X.  Otherwise,
     return the result of (...((X / arg1) / arg2 ) / ... / argN).

 -- Macro: 1+ ((expression OBJECT)) : OBJECT
     Add 1 to EXPRESSION and return the result.

 -- Macro: 1- ((expression OBJECT)) : OBJECT
     Subtract 1 from EXPRESSION and return the result.

 -- Macro: ++ ((place OBJECT) &body (increment CONS)) : OBJECT
     Increment the value of PLACE and return the result.  PLACE can be
     either a variable name or a slot reference.  Increment by the
     optional INCREMENT (which can be a float) or 1 otherwise.

 -- Macro: - ((place OBJECT) &body (decrement CONS)) : OBJECT
     Decrement the value of PLACE and return the result.  PLACE can be
     either a variable name or a slot reference.  Decrement by the
     optional DECREMENT (which can be a float) or 1 otherwise.

 -- Function: = ((x NUMBER) (y NUMBER)) : BOOLEAN
     Return true if X and Y are numbers of exactly the same magnitude.

 -- Function: < ((x NUMBER) (y NUMBER)) : BOOLEAN
     Return true if X is less than Y.

 -- Function: <= ((x NUMBER) (y NUMBER)) : BOOLEAN
     Return true if X is less than or equal to Y.

 -- Function: >= ((x NUMBER) (y NUMBER)) : BOOLEAN
     Return true if X is greater than or equal to Y.

 -- Function: > ((x NUMBER) (y NUMBER)) : BOOLEAN
     Return true if X is greater than Y.

 -- Function: zero? ((x INTEGER)) : BOOLEAN
     Return true if X is 0.

 -- Function: plus? ((x INTEGER)) : BOOLEAN
     Return true if X is greater than 0.

 -- Function: even? ((x INTEGER)) : BOOLEAN
     Return true if X is an even number.

 -- Function: odd? ((x INTEGER)) : BOOLEAN
     Return true if X is an odd number.

 -- Function: div ((x INTEGER) (y INTEGER)) : INTEGER
     Return the integer quotient from dividing X by Y.

 -- Function: rem ((x INTEGER) (y INTEGER)) : INTEGER
     Return the remainder from dividing X by Y.  The sign of the result
     is always the same as the sign of X.  This has slightly different
     behavior than the `mod' function, and has less overhead in C++ and
     Java, which don't have direct support for a true modulus function.

 -- Function: mod ((x INTEGER) (modulus INTEGER)) : INTEGER
     True modulus.  Return the result of X mod `modulo'.  Note: In C++
     and Java, `mod' has more overhead than the similar function `rem'.
     The  answers returned by `mod' and `rem' are only different when
     the signs of X and `modulo' are different.

 -- Function: gcd ((x INTEGER) (y INTEGER)) : INTEGER
     Return the greatest common divisor of X and Y.

 -- Function: ceiling ((n NUMBER)) : INTEGER
     Return the smallest integer >= N.

 -- Function: floor ((n NUMBER)) : INTEGER
     Return the biggest integer <= N.

 -- Function: round ((n NUMBER)) : INTEGER
     Round N to the closest integer and return the result.

 -- Method on INTEGER: abs (x) : INTEGER
     Return the absolute value of X.

 -- Method on FLOAT: abs (x) : FLOAT
     Return the absolute value of X.

 -- Function: min ((x INTEGER) (y INTEGER)) : INTEGER
     Return the minimum of X and Y.  If either is NULL, return the
     other.

 -- Function: max ((x INTEGER) (y INTEGER)) : INTEGER
     Return the maximum of X and Y.  If either is NULL, return the
     other.

 -- Function: sqrt ((n FLOAT)) : FLOAT
     Return the square root of N.

 -- Function: exp ((n FLOAT)) : FLOAT
     Return the e to the power N.

 -- Function: expt ((x FLOAT) (y FLOAT)) : FLOAT
     Return X ^ Y.

 -- Function: log ((n FLOAT)) : FLOAT
     Return the natural logarithm (base e) of N.

 -- Function: log10 ((n FLOAT)) : FLOAT
     Return the logarithm (base 10) of N.

 -- Function: sin ((n FLOAT)) : FLOAT
     Return the sine of N radians.

 -- Function: cos ((n FLOAT)) : FLOAT
     Return the cosine of N radians.

 -- Function: tan ((n FLOAT)) : FLOAT
     Return the tangent of N radians.

 -- Function: asin ((n FLOAT)) : FLOAT
     Return the arcsine of N in radians.

 -- Function: acos ((n FLOAT)) : FLOAT
     Return the arccosine of N in radians.

 -- Function: atan ((n FLOAT)) : FLOAT
     Return the arc tangent of N in radians.

 -- Function: atan2 ((x FLOAT) (y FLOAT)) : FLOAT
     Return the arc tangent of X / Y in radians.

 -- Function: random ((n INTEGER)) : INTEGER
     Generate a random integer in the interval [0..n-1].

 -- Function: integer-to-string ((i INTEGER)) : STRING
     Convert I to its string representation and return the result.
     This is more efficient than using a string stream.

 -- Function: string-to-integer ((string STRING)) : INTEGER
     Convert a STRING representation of an integer into an integer.

 -- Function: float-to-string ((f FLOAT)) : STRING
     Convert F to its string representation and return the result.
     This is more efficient than using a string stream.

 -- Function: string-to-float ((string STRING)) : FLOAT
     Convert a STRING representation of a float into a float.

 -- Function: format-float ((f FLOAT) (nDecimals INTEGER)) : STRING
     Print F in fixed-point format with NDECIMALS behind the decimal
     point and return the result as a string.

 -- Function: wrap-integer ((value INTEGER)) : INTEGER-WRAPPER
     Return a literal object whose value is the INTEGER VALUE.

 -- Function: unwrap-integer ((wrapper INTEGER-WRAPPER)) : INTEGER
     Unwrap WRAPPER and return the result.  Return NULL if WRAPPER is
     NULL.

 -- Function: wrap-float ((value FLOAT)) : FLOAT-WRAPPER
     Return a literal object whose value is the FLOAT VALUE.

 -- Function: unwrap-float ((wrapper FLOAT-WRAPPER)) : FLOAT
     Unwrap WRAPPER and return the result.  Return NULL if WRAPPER is
     NULL.


File: manual.info,  Node: Characters,  Next: Strings,  Prev: Numbers,  Up: Library Functions

7.3 Characters
==============

 -- Function: character-code ((ch CHARACTER)) : INTEGER
     Return the 8-bit ASCII code of CH as an integer.

 -- Function: code-character ((code INTEGER)) : CHARACTER
     Return the character encoded by CODE (0 <= CODE <= 255).

 -- Function: digit-character? ((ch CHARACTER)) : BOOLEAN
     Return TRUE if CH represents a digit.

 -- Function: letter-character? ((ch CHARACTER)) : BOOLEAN
     Return TRUE if CH represents a letter.

 -- Function: upper-case-character? ((ch CHARACTER)) : BOOLEAN
     Return TRUE if CH represents an upper-case character.

 -- Function: lower-case-character? ((ch CHARACTER)) : BOOLEAN
     Return TRUE if CH represents a lower-case character.

 -- Function: white-space-character? ((ch CHARACTER)) : BOOLEAN
     Return TRUE if CH is a white space character.

 -- Function: character-downcase ((ch CHARACTER)) : CHARACTER
     If CH is lowercase, return its uppercase version, otherwise,
     return CH unmodified.

 -- Function: character-upcase ((ch CHARACTER)) : CHARACTER
     If CH is uppercase, return its lowercase version, otherwise,
     return CH unmodified.  If only the first character of a sequence
     of characters is to be capitalized, `character-capitalize' should
     be used instead.

 -- Function: character-capitalize ((ch CHARACTER)) : CHARACTER
     Return the capitalized character for CH.  This is generally the
     same as the uppercase character, except for obscure non-English
     characters in Java.  It should be used if only the first character
     of a sequence of characters is to be capitalized.

 -- Function: character-to-string ((c CHARACTER)) : STRING
     Convert C into a one-element string and return the result.

 -- Function: wrap-character ((value CHARACTER)) : CHARACTER-WRAPPER
     Return a literal object whose value is the CHARACTER VALUE.

 -- Function: unwrap-character ((wrapper CHARACTER-WRAPPER)) : CHARACTER
     Unwrap WRAPPER and return the result.  Return NULL if WRAPPER is
     NULL.


File: manual.info,  Node: Strings,  Next: CONS Lists and Trees,  Prev: Characters,  Up: Library Functions

7.4 Strings
===========

 -- Function: string-eql? ((x STRING) (y STRING)) : BOOLEAN
     Return true if X and Y are equal strings or are both undefined.
     This test is substituted automatically by the STELLA translator if
     `eql?' is applied to strings.

 -- Function: string-equal? ((x STRING) (y STRING)) : BOOLEAN
     Return true if X and Y are equal strings ignoring character case or
     are both undefined.

 -- Method on STRING: empty? (x) : BOOLEAN
     Return true if X is the empty string ""

 -- Method on STRING: non-empty? (x) : BOOLEAN
     Return true if X is not the empty string ""

 -- Function: string-compare ((x STRING) (y STRING)
          (case-sensitive? BOOLEAN)) : INTEGER
     Compare X and Y lexicographically, and return -1, 0, or 1,
     depending on whether X is less than, equal, or greater than Y.  If
     CASE-SENSITIVE? is true, then case does matter for the comparison

 -- Function: string< ((x STRING) (y STRING)) : BOOLEAN
     Return true if X is lexicographically < Y, considering case.

 -- Function: string<= ((x STRING) (y STRING)) : BOOLEAN
     Return true if X is lexicographically <= Y, considering case.

 -- Function: string>= ((x STRING) (y STRING)) : BOOLEAN
     Return true if X is lexicographically >= Y, considering case.

 -- Function: string> ((x STRING) (y STRING)) : BOOLEAN
     Return true if X is lexicographically > Y, considering case.

 -- Function: string-less? ((x STRING) (y STRING)) : BOOLEAN
     Return true if X is lexicographically < Y, ignoring case.

 -- Function: string-less-equal? ((x STRING) (y STRING)) : BOOLEAN
     Return true if X is lexicographically <= Y, ignoring case.

 -- Function: string-greater-equal? ((x STRING) (y STRING)) : BOOLEAN
     Return true if X is lexicographically >= Y, ignoring case.

 -- Function: string-greater? ((x STRING) (y STRING)) : BOOLEAN
     Return true if X is lexicographically > Y, ignoring case.

 -- Function: all-upper-case-string? ((s STRING)) : BOOLEAN
     Return TRUE if all letters in S are upper case.

 -- Function: all-lower-case-string? ((s STRING)) : BOOLEAN
     Return TRUE if all letters in S are lower case.

 -- Function: make-string ((size INTEGER) (initchar CHARACTER)) : STRING
     Return a new string filled with SIZE INITCHARs.

 -- Function: make-mutable-string ((size INTEGER) (initchar CHARACTER))
          : MUTABLE-STRING
     Return a new mutable string filled with SIZE INITCHARs.

 -- Function: make-raw-mutable-string ((size INTEGER)) : MUTABLE-STRING
     Return a new uninitialized mutable string of SIZE.

 -- Method on STRING: first (self) : CHARACTER
     Return the first character of SELF.

 -- Method on MUTABLE-STRING: first (self) : CHARACTER
     Return the first character of SELF (settable via `setf').

 -- Method on STRING: second (self) : CHARACTER
     Return the second character of SELF.

 -- Method on MUTABLE-STRING: second (self) : CHARACTER
     Return the second character of SELF (settable via `setf').

 -- Method on STRING: third (self) : CHARACTER
     Return the third character of SELF.

 -- Method on MUTABLE-STRING: third (self) : CHARACTER
     Return the third character of SELF (settable via `setf').

 -- Method on STRING: fourth (self) : CHARACTER
     Return the fourth character of SELF.

 -- Method on MUTABLE-STRING: fourth (self) : CHARACTER
     Return the fourth character of SELF (settable via `setf').

 -- Method on STRING: fifth (self) : CHARACTER
     Return the fifth character of SELF.

 -- Method on MUTABLE-STRING: fifth (self) : CHARACTER
     Return the fifth character of SELF (settable via `setf').

 -- Method on STRING: nth (self (position INTEGER)) : CHARACTER
     Return the character in SELF at POSITION.

 -- Method on MUTABLE-STRING: nth (self (position INTEGER)) : CHARACTER
     Return the character in SELF at POSITION.

 -- Method on STRING: rest (self) : STRING
     Not documented.

 -- Method on STRING: length (self) : INTEGER
     Return the length of the string SELF.

 -- Method on MUTABLE-STRING: length (self) : INTEGER
     Return the length of the string SELF.

 -- Method on STRING: member? (self (char CHARACTER)) : BOOLEAN
     Not documented.

 -- Method on STRING: position (string (character CHARACTER)
          (start INTEGER)) : INTEGER
     Return the position of CHARACTER within STRING (counting from
     zero); or return NULL if CHARACTER does not occur within STRING.
     If START was supplied as non-NULL, only consider the substring
     starting at START, however, the returned position will always be
     relative to the entire string.

 -- Method on STRING: last-position (string (character CHARACTER)
          (end INTEGER)) : INTEGER
     Return the last position of CHARACTER within STRING (counting from
     zero); or return NULL if CHARACTER does not occur within STRING.
     If END was supplied as non-NULL, only consider the substring
     ending at END, however, the returned position will always be
     relative to the entire string.

 -- Function: string-search ((string STRING) (substring STRING)
          (start INTEGER)) : INTEGER
     Return start position of the left-most occurrence of SUBSTRING in
     STRING, beginning from START.  Return NULL if it is not a
     substring.

 -- Method on STRING: copy (string) : STRING
     Return a copy of STRING.

 -- Function: string-upcase ((string STRING)) : STRING
     Return an upper-case copy of STRING.

 -- Function: string-downcase ((string STRING)) : STRING
     Return a lower-case copy of STRING.

 -- Function: string-capitalize ((string STRING)) : STRING
     Return a capitalized version of STRING.

 -- Method on STRING: concatenate (string1 (string2 STRING)
          &rest (otherStrings STRING)) : STRING
     Return a new string representing the concatenation of STRING1,
     STRING2, and OTHERSTRINGS.  The two mandatory parameters allow us
     to optimize the common binary case by not relying on the somewhat
     less efficient variable arguments mechanism.

 -- Method on STRING: subsequence (string (start INTEGER)
          (end INTEGER)) : STRING
     Return a substring of STRING beginning at position START and
     ending up to but not including position END, counting from zero.
     An END value of NULL stands for the rest of the string.

 -- Method on STRING: remove (string (char CHARACTER)) : STRING
     Remove all occurences of CHAR from STRING.

 -- Method on STRING: substitute (self (new-char CHARACTER)
          (old-char CHARACTER)) : STRING
     Substitute all occurences of OLD-CHAR with NEW-CHAR in the string
     SELF.

 -- Method on MUTABLE-STRING: substitute (self (new-char CHARACTER)
          (old-char CHARACTER)) : MUTABLE-STRING
     Substitute all occurences of OLD-CHAR with NEW-CHAR in the string
     SELF.

 -- Function: replace-substrings ((string STRING) (new STRING)
          (old STRING)) : STRING
     Replace all occurrences of OLD in STRING with NEW.

 -- Function: instantiate-string-template ((template STRING)
          &rest (vars&values STRING)) : STRING
     For each occurrence of a <var> string from VARS&VALUES in TEMPLATE
     replace it with its corresponding <value> string.  Replacement is
     done in sequence which means (part of) a value might be replaced
     further with a later <var> and <value>.

 -- Function: insert-string ((source STRING) (start INTEGER)
          (end INTEGER) (target MUTABLE-STRING) (target-index INTEGER)
          (case-conversion KEYWORD)) : INTEGER
     Inserts characters from SOURCE begining at START and ending at END
     into TARGET starting at TARGET-INDEX.  If END is `null', then the
     entire length of the string is used. The copy of characters is
     affected by the CASE-CONVERSION keyword which should be one of
     :UPCASE :DOWNCASE :CAPITALIZE :PRESERVE.

     The final value of target-index is returned.

 -- Function: wrap-string ((value STRING)) : STRING-WRAPPER
     Return a literal object whose value is the STRING VALUE.

 -- Function: wrap-mutable-string ((value MUTABLE-STRING)) :
          MUTABLE-STRING-WRAPPER
     Return a literal object whose value is the MUTABLE-STRING VALUE.

 -- Function: unwrap-string ((wrapper STRING-WRAPPER)) : STRING
     Unwrap WRAPPER and return the result.  Return NULL if WRAPPER is
     NULL.

 -- Function: unwrap-mutable-string ((wrapper MUTABLE-STRING-WRAPPER))
          : MUTABLE-STRING
     Unwrap WRAPPER and return the result.  Return NULL if WRAPPER is
     NULL.

 -- Function: string-to-mutable-string ((s STRING)) : MUTABLE-STRING
     Copy S into a mutable string with the same content.  In Lisp and
     C++ this simply copies S.

 -- Function: mutable-string-to-string ((s MUTABLE-STRING)) : STRING
     Convert S into a regular string with the same content.  In Lisp
     and C++ this is a no-op.

 -- Function: integer-to-string ((i INTEGER)) : STRING
     Convert I to its string representation and return the result.
     This is more efficient than using a string stream.

 -- Function: string-to-integer ((string STRING)) : INTEGER
     Convert a STRING representation of an integer into an integer.

 -- Function: float-to-string ((f FLOAT)) : STRING
     Convert F to its string representation and return the result.
     This is more efficient than using a string stream.

 -- Function: string-to-float ((string STRING)) : FLOAT
     Convert a STRING representation of a float into a float.

 -- Function: format-float ((f FLOAT) (nDecimals INTEGER)) : STRING
     Print F in fixed-point format with NDECIMALS behind the decimal
     point and return the result as a string.

 -- Function: character-to-string ((c CHARACTER)) : STRING
     Convert C into a one-element string and return the result.

 -- Function: stringify ((expression OBJECT)) : STRING
     Print EXPRESSION onto a string and return the result.  Printing is
     done with `*printReadably?*' set to true and with `*printPretty?*'
     set to false.

 -- Function: stringify-in-module ((tree OBJECT) (module MODULE)) :
          STRING
     Stringify a parse TREE relative to MODULE, or `*module*' if no
     module is specified.

 -- Function: unstringify ((string STRING)) : OBJECT
     Read a STELLA expression from STRING and return the result.  This
     is identical to `read-s-expression-from-string'.

 -- Function: unstringify-in-module ((string STRING) (module MODULE)) :
          OBJECT
     Unstringify relative to MODULE, or `*MODULE*' if no module is
     specified.


File: manual.info,  Node: CONS Lists and Trees,  Next: Lists,  Prev: Strings,  Up: Library Functions

7.5 `CONS' Lists and Trees
==========================

 -- Class: CONS : STANDARD-OBJECT
     Not documented.

      -- Class Parameter of : any-value : OBJECT
          Not documented.

      -- Slot of : value : (LIKE (ANY-VALUE SELF))
          Not documented.

      -- Slot of : rest : (CONS OF (LIKE (ANY-VALUE SELF)))
          Not documented.

 -- Variable: nil : CONS
     Not documented.

 -- Method on CONS: empty? (self) : BOOLEAN
     Return `true' iff SELF equals `nil'.

 -- Method on CONS: non-empty? (self) : BOOLEAN
     Return `true' iff SELF is not equal to `nil'.

 -- Function: nil? ((x OBJECT)) : BOOLEAN
     Return `true' iff X equals `nil'.

 -- Function: equal-cons-trees? ((tree1 OBJECT) (tree2 OBJECT)) :
          BOOLEAN
     Return `true' iff the cons trees TREE1 and TREE2 are structurally
     equivalent.  Uses an `eql?' test.

 -- Method on CONS: object-equal? (tree1 (tree2 OBJECT)) : BOOLEAN
     Return `true' iff the cons trees TREE1 and TREE2 are structurally
     equivalent.  Uses `equal?' to test equality of subtrees.

 -- Method on CONS: equal-hash-code (self) : INTEGER
     Return an `equal?' hash code for SELF.  Note that this is O(N) in
     the number of elements of SELF.

 -- Function: cons ((value OBJECT) (rest CONS)) : CONS
     Return a cons record that points to VALUE and REST.

 -- Method on CONS: first (self) : (LIKE (ANY-VALUE SELF))
     Return the first element of SELF.  The first element of SELF can
     be set with `setf'.  Note that `(first NIL)' = `null'.

 -- Method on CONS: second (self) : (LIKE (ANY-VALUE SELF))
     Return the second element of SELF.  The second element of SELF can
     be set with `setf'.  Note that `(second NIL)' = `null'.

 -- Method on CONS: third (self) : (LIKE (ANY-VALUE SELF))
     Return the third element of SELF.  The third element of SELF can
     be set with `setf'.  Note that `(third NIL)' = `null'.

 -- Method on CONS: fourth (self) : (LIKE (ANY-VALUE SELF))
     Return the fourth element of SELF.  The fourth element of SELF can
     be set with `setf'.  Note that `(fourth NIL)' = `null'.

 -- Method on CONS: fifth (self) : (LIKE (ANY-VALUE SELF))
     Return the fifth element of SELF.  The fifth element of SELF can
     be set with `setf'.  Note, that `(fifth NIL)' = `null'.

 -- Method on CONS: nth (self (position INTEGER)) : (LIKE (ANY-VALUE
          SELF))
     Return the element of SELF at POSITION.  The nth element of SELF
     can be set with `setf'.  Note, that `(nth NIL <pos>)' = `null'.

 -- Method on CONS: nth-rest (self (position INTEGER)) : (LIKE SELF)
     Apply `rest' POSITION times to SELF.

 -- Method on CONS: last (self) : (LIKE (ANY-VALUE SELF))
     Return the last element of SELF.

 -- Method on CONS: but-last (self) : (ITERATOR OF (LIKE (ANY-VALUE
          SELF)))
     Generate all but the last element of the cons list SELF.

 -- Function: last-cons ((self CONS)) : (CONS OF (LIKE (ANY-VALUE
          SELF)))
     Return the last cons of SELF.

 -- Method on CONS: length (self) : INTEGER
     Return the length of the CONS list SELF.

 -- Method on CONS: member? (self (object OBJECT)) : BOOLEAN
     Return `true' iff OBJECT is a member of the cons list SELF (uses
     an `eql?' test).

 -- Method on CONS: memb? (self (object OBJECT)) : BOOLEAN
     Return `true' iff OBJECT is a member of the cons list SELF (uses
     an `eq?' test).

 -- Method on CONS: position (self (object OBJECT) (start INTEGER)) :
          INTEGER
     Return the position of OBJECT within the cons-list SELF (counting
     from zero); or return `null' if OBJECT does not occur within SELF
     (uses an `eql?' test).  If START was supplied as non-`null', only
     consider the sublist starting at START, however, the returned
     position will always be relative to the entire list.

 -- Method on CONS: last-position (self (object OBJECT) (end INTEGER))
          : INTEGER
     Return the position of OBJECT within the cons-list SELF (counting
     from zero); or return `null' if OBJECT does not occur within SELF
     (uses an `eql?' test).  If `start' was supplied as non-`null', only
     consider the sublist ending at END, however, the returned position
     will always be relative to the entire list.

 -- Method on CONS: reverse (self) : (LIKE SELF)
     Destructively reverse the members of the cons list SELF.

 -- Method on CONS: remove (self (value OBJECT)) : (LIKE SELF)
     Destructively remove all entries in the cons list SELF that match
     VALUE.  Unless the remaining list is `nil', insure that the cons
     that heads the list is unchanged.

 -- Method on CONS: remove-duplicates (self) : (LIKE SELF)
     Destructively remove duplicates from SELF and return the result.
     Removes all but the first occurrence of items in the list.
     Preserves the original order of the remaining members.  Runs in
     linear time.

 -- Method on CONS: remove-if (self (test? FUNCTION-CODE)) : (LIKE SELF)
     Destructively removes all members of the cons list SELF for which
     TEST? evaluates to `true'.  `test' takes a single argument of type
     OBJECT and returns `true' or `false'.  Returns a cons list.  In
     case the first element is removed, the return result should be
     assigned to a variable.

 -- Method on CONS: substitute (self (inValue OBJECT)
          (outValue OBJECT)) : CONS
     Destructively replace each appearance of OUTVALUE by INVALUE in
     the cons list SELF.

 -- Method on CONS: concatenate (list1 (list2 CONS)
          &rest (otherLists CONS)) : CONS
     Return a cons list consisting of the concatenation of LIST1,
     LIST2, and OTHERLISTS.  The operation is destructive wrt all but
     the last list argument which is left intact.  The two mandatory
     parameters allow us to optimize the common binary case by not
     relying on the somewhat less efficient variable arguments
     mechanism.

 -- Function: append ((consList1 CONS) (consList2 CONS)) : CONS
     Return a cons list representing the concatenation of CONSLIST1 and
     CONSLIST2.  The concatenation is NOT destructive.

 -- Method on CONS: prepend (self (list1 CONS)) : CONS
     Return a cons list consisting of the concatenation of LIST1 and
     SELF.  A copy of LIST1 is prepended to SELF.  This operation
     results in structure sharing of SELF; to avoid this, SELF should
     not be pointed to by anything other than the tail of the prepended
     copy.

 -- Macro: pushq ((variable SYMBOL) (value OBJECT)) : OBJECT
     Push VALUE onto the cons list VARIABLE.

 -- Macro: pushq-new ((variable SYMBOL) (value OBJECT)) : OBJECT
     Push VALUE onto the cons list VARIABLE, unless VALUE is already a
     member of the list.

 -- Macro: popq ((variable SYMBOL)) : OBJECT
     Pops a value from the cons list VARIABLE.

 -- Function: cons-list (&rest (values OBJECT)) : CONS
     Return a cons list containing VALUES, in order.

 -- Function: list* (&rest (values OBJECT)) : CONS
     Return a list of conses that make up the list VALUES, terminated
     by the last value rather than by `nil'.  Assumes that at least one
     value is passed in.

 -- Function: copy-cons-list ((self CONS)) : (LIKE SELF)
     Return a copy of the cons list SELF.

 -- Function: copy-cons-tree ((self OBJECT)) : (LIKE SELF)
     Return a copy of the cons tree SELF.

 -- Function: substitute-cons-tree ((tree OBJECT) (newValue OBJECT)
          (oldValue OBJECT)) : OBJECT
     Destructively replace each appearance of OLDVALUE by NEWVALUE in
     the cons tree TREE.  Return the tree.  Uses an `eql?' test.

 -- Function: search-cons-tree? ((tree OBJECT) (value OBJECT)) : BOOLEAN
     Return `true' iff the value VALUE is embedded within the cons tree
     TREE.  Uses an `eql?' test.

 -- Function: tree-size ((self OBJECT)) : INTEGER
     Not documented.

 -- Function: safe-tree-size ((tree CONS)) : INTEGER STRING
     Not documented.

 -- Function: cons-tree-nth ((tree CONS) &rest (index INTEGER)) : OBJECT
     Access an arbitrary element of TREE identified by a path specified
     as a list of INDEX values.  The first INDEX specifies the INDEX-th
     element of TREE, the second INDEX the INDEX-th subelement of that
     element, etc.  Example:

            (cons-tree-nth (quote (a (b (c d e) f) g)) 1 1 2) => e


 -- Function: cons-tree-nth-rest ((tree CONS) &rest (index INTEGER)) :
          CONS
     Access an arbitrary sublist of TREE identified by a path specified
     as a list of INDEX values.  The first INDEX specifies the INDEX-th
     element of TREE, the second INDEX the INDEX-th subelement of that
     element, ..., the last index specifies the `nth-rest' of the
     previous element (different from `cons-tree-nth').  Example:

            (cons-tree-nth-rest (quote (a (b (c d e) f) g)) 1 1 1) => (d e)


 -- Function: match-cons-tree ((tree OBJECT) (pattern OBJECT)
          (bindings KEY-VALUE-LIST)) : KEY-VALUE-LIST
     Match PATTERN against TREE and return a list of variable bindings
     if they match, or NULL otherwise.  BINDINGS can be NULL or an
     initial list of bindings to consider.  Pattern variables use KIF
     syntax, i.e., they need to start with a `?' character.  A single
     question mark is interpreted as the anonymous variable. Example:

            (match-cons-tree (quote (a (b (a d) e) (a d) f g))
                             (quote (a (?x ?y ?) ?y ? g))
                             NULL)
            => |kv|(<?Y,(A D)> <?X,B>)

     Variables can't be quoted but quoting can effectively be achieved
     by inserting to-be-quoted variables bound to themselves into
     BINDINGS.

 -- Function: cons-tree-match? ((tree OBJECT) (pattern OBJECT)) :
          BOOLEAN
     Predicate version of `match-cons-tree' (which see).

 -- Method on CONS: consify (self) : (CONS OF (LIKE (ANY-VALUE SELF)))
     Return SELF.

 -- Method on CONS: allocate-iterator (self) : (CONS-ITERATOR OF (LIKE
          (ANY-VALUE SELF)))
     Not documented.

 -- Method on CONS-ITERATOR: next? (self) : BOOLEAN
     Not documented.

 -- Method on CONS: sort (self (predicate FUNCTION-CODE)) : (CONS OF
          (LIKE (ANY-VALUE SELF)))
     Perform a stable, destructive sort of SELF according to PREDICATE,
     and return the result.  If PREDICATE has a `<' semantics, the
     result will be in ascending order.  It is not guaranteed that SELF
     will point to the beginning of the sorted result.  If PREDICATE is
     `null', a suitable `<' predicate is chosen depending on the first
     element of SELF, and it is assumed that all elements of SELF have
     the same type (supported element types are GENERALIZED-SYMBOL,
     STRING, INTEGER, and FLOAT).

 -- Method on CONS: sort-tuples (self (n INTEGER)
          (predicate FUNCTION-CODE)) : (CONS OF (LIKE (ANY-VALUE SELF)))
     Just like `sort' but assumes each element of SELF is a tuple (a
     cons) whose N-th element (0-based) will be used for comparison.

 -- Function: map-null-to-nil ((self CONS)) : (LIKE SELF)
     Return `nil' iff SELF is `null' or SELF otherwise.

 -- Special Variable: *printpretty?* : BOOLEAN
     If `true' conses will be pretty printed.

 -- Special Variable: *printreadably?* : BOOLEAN
     If `true' conses will be printed as readable Stella code.

 -- Special Variable: *printprettycode?* : BOOLEAN
     When `true' pretty-print Stella and translated code.  Since (Lisp)
     pretty-printing is somewhat slow, turning this off speeds up file
     translation, but it also makes translated output very unreadable.

* Menu:

* CONS Lists as Sets::


File: manual.info,  Node: CONS Lists as Sets,  Prev: CONS Lists and Trees,  Up: CONS Lists and Trees

7.5.1 CONS Lists as Sets
------------------------

 -- Method on CONS: subset? (self (otherList CONS)) : BOOLEAN
     Return true if every element of SELF also occurs in OTHERLIST.
     Uses an `eql?' test and a simple quadratic-time algorithm.  Note
     that this does not check whether SELF and OTHERLIST actually are
     sets.

 -- Method on CONS: equivalent-sets? (self (otherList CONS)) : BOOLEAN
     Return true if every element of SELF occurs in OTHERLIST and vice
     versa.  Uses an `eql?' test and a simple quadratic-time algorithm.
     Note that this does not check whether SELF and OTHERLIST actually
     are sets.

 -- Method on CONS: union (self (otherList CONS)) : CONS
     Return the set union of SELF and OTHERLIST.  Uses an `eql?' test
     and a simple quadratic-time algorithm.  Note that the result is
     only guaranteed to be a set if both SELF and OTHERLIST are sets.

 -- Method on CONS: intersection (self (otherList CONS)) : CONS
     Return the set intersection of SELF and OTHERLIST.  Uses an `eql?'
     test and a simple quadratic-time algorithm.  Note that the result
     is only guaranteed to be a set if both SELF and OTHERLIST are sets.

 -- Method on CONS: difference (self (otherList CONS)) : CONS
     Return the set difference of SELF and OTHERLIST (i.e., all elements
     that are in SELF but not in `otherSet').  Uses an `eql?' test and
     a simple quadratic-time algorithm.  Note that the result is only
     guaranteed to be a set if both SELF and OTHERLIST are sets.

 -- Method on CONS: subtract (self (otherList CONS)) : CONS
     Return the set difference of SELF and OTHERLIST by destructively
     removing elements from SELF that also occur in OTHERLIST.  Uses an
     `eql?' test and a simple quadratic-time algorithm.  Note that the
     result is only guaranteed to be a set if SELF is a set.


File: manual.info,  Node: Lists,  Next: Property and Key-Value Lists,  Prev: CONS Lists and Trees,  Up: Library Functions

7.6 Lists
=========

 -- Class: LIST : SEQUENCE
     Not documented.

      -- Class Parameter of : any-value : OBJECT
          Not documented.

      -- Slot of : the-cons-list : (CONS OF (LIKE (ANY-VALUE SELF)))
          Not documented.

 -- Variable: nil-list : LIST
     Not documented.

 -- Function: defined-list? ((self LIST)) : BOOLEAN
     Return TRUE unless SELF is NULL or the `NIL-LIST'.

 -- Function: null-list? ((self LIST)) : BOOLEAN
     Return TRUE iff SELF is NULL or the `NIL-LIST'.

 -- Method on LIST: empty? (self) : BOOLEAN
     Return TRUE if the list SELF has no members.

 -- Method on LIST: non-empty? (self) : BOOLEAN
     Return TRUE if the list SELF has at least one member.

 -- Method on LIST: object-equal? (x (y OBJECT)) : BOOLEAN
     Return TRUE iff the lists X and Y are structurally equivalent.
     Uses `equal?' to test equality of elements.

 -- Method on LIST: equal-hash-code (self) : INTEGER
     Return an `equal?' hash code for SELF.  Note that this is O(N) in
     the number of elements of SELF.

 -- Function: list (&rest (values OBJECT)) : LIST
     Return a list containing VALUES, in order.

 -- Method on LIST: first (self) : (LIKE (ANY-VALUE SELF))
     Return the first item in the list SELF, or NULL if empty.

 -- Method on LIST: second (self) : (LIKE (ANY-VALUE SELF))
     Return the second item in the list SELF, or NULL if empty.

 -- Method on LIST: third (self) : (LIKE (ANY-VALUE SELF))
     Return the third item in the list SELF, or NULL if empty.

 -- Method on LIST: fourth (self) : (LIKE (ANY-VALUE SELF))
     Return the fourth item in the list SELF, or NULL if empty.

 -- Method on LIST: fifth (self) : (LIKE (ANY-VALUE SELF))
     Return the fifth item in the list SELF, or NULL if empty.

 -- Method on LIST: nth (self (position INTEGER)) : (LIKE (ANY-VALUE
          SELF))
     Return the nth item in the list SELF, or NULL if empty.

 -- Method on LIST: rest (self) : (CONS OF (LIKE (ANY-VALUE SELF)))
     Return a cons list of all but the first item in the list SELF.

 -- Method on LIST: last (self) : (LIKE (ANY-VALUE SELF))
     Return the last element of SELF.

 -- Method on LIST: but-last (self) : (ITERATOR OF (LIKE (ANY-VALUE
          SELF)))
     Generate all but the last element of the list SELF.

 -- Method on LIST: length (self) : INTEGER
     Not documented.

 -- Method on LIST: member? (self (object OBJECT)) : BOOLEAN
     Return TRUE iff OBJECT is a member of the list SELF (uses an
     `eql?' test).

 -- Method on LIST: memb? (self (object (LIKE (ANY-VALUE SELF)))) :
          BOOLEAN
     Return TRUE iff OBJECT is a member of the cons list SELF (uses an
     `eq?' test).

 -- Method on LIST: position (self (object OBJECT) (start INTEGER)) :
          INTEGER
     Return the position of OBJECT within the list SELF (counting from
     zero); or return NULL if OBJECT does not occur within SELF (uses
     an `eql?' test).  If START was supplied as non-NULL, only consider
     the sublist starting at START, however, the returned position will
     always be relative to the entire list.

 -- Method on LIST: last-position (self (object OBJECT) (end INTEGER))
          : INTEGER
     Return the position of OBJECT within the list SELF (counting from
     zero); or return NULL if OBJECT does not occur within SELF (uses
     an `eql?' test).  If END was supplied as non-NULL, only consider
     the sublist ending at END, however, the returned position will
     always be relative to the entire list.

 -- Method on LIST: insert (self (value (LIKE (ANY-VALUE SELF)))) :
     Add VALUE to the front of the list SELF.

 -- Method on LIST: push (self (value (LIKE (ANY-VALUE SELF)))) :
     Add VALUE to the front of the list SELF.

 -- Method on LIST: insert-new (self (value (LIKE (ANY-VALUE SELF)))) :
     Add VALUE to the front of the list SELF unless its already a
     member.

 -- Method on LIST: insert-last (self (value (LIKE (ANY-VALUE SELF)))) :
     Insert VALUE as the last entry in the list SELF.

 -- Method on LIST: reverse (self) : (LIKE SELF)
     Reverse the members of SELF (in place).

 -- Method on LIST: remove (self (value (LIKE (ANY-VALUE SELF)))) :
          (LIKE SELF)
     Destructively remove all entries in SELF that match VALUE.

 -- Method on LIST: remove-duplicates (self) : (LIKE SELF)
     Destructively remove duplicates from SELF and return the result.
     Preserves the original order of the remaining members.

 -- Method on LIST: remove-deleted-members (self) : (LIKE SELF)
     Not documented.

 -- Method on LIST: remove-if (self (test? FUNCTION-CODE)) : (LIKE SELF)
     Destructively remove all members of the list SELF for which TEST?
     evaluates to TRUE.  `test' takes a single argument of type OBJECT
     and returns TRUE or FALSE.  Returns SELF.

 -- Method on LIST: pop (self) : (LIKE (ANY-VALUE SELF))
     Remove and return the first element in the list SELF.  Return NULL
     if the list is empty.

 -- Method on LIST: substitute (self (inValue OBJECT)
          (outValue OBJECT)) : (LIKE SELF)
     Destructively replace each appearance of OUTVALUE by INVALUE in
     the list SELF.

 -- Method on LIST: concatenate (list1 (list2 LIST)
          &rest (otherLists LIST)) : LIST
     Copy LIST2 and all OTHERLISTS onto the end of LIST1.  The
     operation is destructive wrt LIST1, but leaves all other lists
     intact.  The two mandatory parameters allow us to optimize the
     common binary case by not relying on the somewhat less efficient
     variable arguments mechanism.

 -- Method on LIST: prepend (self (list2 LIST)) : (LIKE SELF)
     Copy LIST2 onto the front of the list SELF.  The operation is
     destructive wrt SELF, but leaves LIST2 intact.

 -- Method on LIST: copy (self) : (LIST OF (LIKE (ANY-VALUE SELF)))
     Return a copy of the list SELF.  The conses in the copy are
     freshly allocated.

 -- Method on LIST: clear (self) :
     Make SELF an empty list.

 -- Method on LIST: consify (self) : (CONS OF (LIKE (ANY-VALUE SELF)))
     Return a list of elements in SELF.

 -- Method on LIST: allocate-iterator (self) : (LIST-ITERATOR OF (LIKE
          (ANY-VALUE SELF)))
     Not documented.

 -- Method on LIST-ITERATOR: next? (self) : BOOLEAN
     Not documented.

 -- Method on LIST: sort (self (predicate FUNCTION-CODE)) : (LIST OF
          (LIKE (ANY-VALUE SELF)))
     Perform a stable, destructive sort of SELF according to PREDICATE,
     and return the result.  If PREDICATE has a `<' semantics, the
     result will be in ascending order.  If PREDICATE is NULL, a
     suitable `<' predicate is chosen depending on the first element of
     SELF, and it is assumed that all elements of SELF have the same
     type (supported element types are GENERALIZED-SYMBOL, STRING,
     INTEGER, and FLOAT).

 -- Function: map-null-to-nil-list ((self LIST)) : LIST
     Return NIL-LIST iff SELF is NULL or SELF otherwise.

* Menu:

* Lists as Sets::


File: manual.info,  Node: Lists as Sets,  Prev: Lists,  Up: Lists

7.6.1 Lists as Sets
-------------------

Similar to `CONS' lists `LIST''s can also be treated as sets and
support the set manipulations below.  Note that `LIST' constructors do
not check for proper set-hood and may have surprising results if a list
contains duplicate elements.

 -- Method on LIST: subset? (self (otherList LIST)) : BOOLEAN
     Return true if every element of SELF also occurs in OTHERLIST.
     Uses an `eql?' test and a simple quadratic-time algorithm.  Note
     that this does not check whether SELF and OTHERLIST actually are
     sets.

 -- Method on LIST: equivalent-sets? (self (otherList LIST)) : BOOLEAN
     Return true if every element of SELF occurs in OTHERLIST and vice
     versa.  Uses an `eql?' test and a simple quadratic-time algorithm.
     Note that this does not check whether SELF and OTHERLIST actually
     are sets.

 -- Method on LIST: union (self (otherList LIST)) : LIST
     Return the set union of SELF and OTHERLIST.  Uses an `eql?' test
     and a simple quadratic-time algorithm.  Note that the result is
     only guaranteed to be a set if both SELF and OTHERLIST are sets.

 -- Method on LIST: intersection (self (otherList LIST)) : LIST
     Return the set intersection of SELF and OTHERLIST.  Uses an `eql?'
     test and a simple quadratic-time algorithm.  Note that the result
     is only guaranteed to be a set if both SELF and OTHERLIST are sets.

 -- Method on LIST: difference (self (otherList LIST)) : LIST
     Return the set difference of SELF and OTHERLIST (i.e., all elements
     that are in SELF but not in `otherSet').  Uses an `eql?' test and
     a simple quadratic-time algorithm.  Note that the result is only
     guaranteed to be a set if both SELF and OTHERLIST are sets.

 -- Method on LIST: subtract (self (otherList LIST)) : LIST
     Return the set difference of SELF and OTHERLIST by destructively
     removing elements from SELF that also occur in OTHERLIST.  Uses an
     `eql?' test and a simple quadratic-time algorithm.  Note that the
     result is only guaranteed to be a set if SELF is a set.

   `SET' is a subclass of `LIST' that overrides certain `LIST'
operations to prevent duplicate elements.  The following additional or
modified operations are supported:

 -- Class: SET : LIST, SET-MIXIN
     Not documented.

      -- Class Parameter of : any-value : OBJECT
          Not documented.

 -- Method on SET: insert (self (value (LIKE (ANY-VALUE SELF)))) :
     Add VALUE to the set SELF unless it is already a member.

 -- Method on SET: push (self (value (LIKE (ANY-VALUE SELF)))) :
     Add VALUE to the front of set SELF unless it is already a member.

 -- Method on SET: insert-last (self (value (LIKE (ANY-VALUE SELF)))) :
     Add VALUE to the end of set SELF unless it is already a member.

 -- Method on SET: substitute (self (new OBJECT) (old OBJECT)) : (LIKE
          SELF)
     Destructively replace OLD with NEW in the set SELF unless NEW is
     already a member.

 -- Method on SET: concatenate (set1 (set2 LIST)
          &rest (otherSets LIST)) : SET
     Union SET2 and all OTHERSETS onto the end of SET1.  The operation
     is destructive wrt SET1, but leaves all other sets intact.  The
     two mandatory parameters allow us to optimize the common binary
     case by not relying on the somewhat less efficient variable
     arguments mechanism.

 -- Method on SET: object-equal? (x (y OBJECT)) : BOOLEAN
     Return TRUE iff X and Y are SET's with equivalent members.  Uses
     `equal?' to test equality of elements.  This is more general than
     `equivalent-sets?', since that only uses an `eql?' test.

 -- Method on SET: equal-hash-code (self) : INTEGER
     Return an `equal?' hash code for SELF.  Note that this is O(N) in
     the number of elements of SELF.

 -- Function: set (&rest (values OBJECT)) : SET
     Return a set containing VALUES, in order.


File: manual.info,  Node: Property and Key-Value Lists,  Next: Vectors,  Prev: Lists,  Up: Library Functions

7.7 Property and Key-Value Lists
================================

 -- Class: PROPERTY-LIST : DICTIONARY
     Not documented.

      -- Class Parameter of : any-key : OBJECT
          Not documented.

      -- Class Parameter of : any-value : OBJECT
          Not documented.

      -- Slot of : the-plist : CONS
          Not documented.

 -- Method on PROPERTY-LIST: empty? (self) : BOOLEAN
     Not documented.

 -- Method on PROPERTY-LIST: non-empty? (self) : BOOLEAN
     Not documented.

 -- Method on PROPERTY-LIST: object-equal? (x (y OBJECT)) : BOOLEAN
     Return TRUE if X and Y represent the same set of key/value pairs..

 -- Method on PROPERTY-LIST: equal-hash-code (self) : INTEGER
     Return an `equal?' hash code for SELF.  Note that this is O(N) in
     the number of entries of SELF.

 -- Method on PROPERTY-LIST: length (self) : INTEGER
     Not documented.

 -- Method on PROPERTY-LIST: lookup (self (key (LIKE (ANY-KEY SELF))))
          : (LIKE (ANY-VALUE SELF))
     Not documented.

 -- Method on PROPERTY-LIST: insert-at (self
          (key (LIKE (ANY-KEY SELF))) (value (LIKE (ANY-VALUE SELF)))) :
     Insert the entry <`key', VALUE> into the property list SELF.  If a
     previous entry existed with key KEY, that entry is replaced.

 -- Method on PROPERTY-LIST: remove-at (self
          (key (LIKE (ANY-KEY SELF)))) : OBJECT
     Remove the entry that matches the key KEY.  Return the value of
     the matching entry, or NULL if there is no matching entry.
     Assumes that at most one entry matches KEY.

 -- Method on PROPERTY-LIST: copy (self) : (LIKE SELF)
     Return a copy of the list SELF.  The conses in the copy are
     freshly allocated.

 -- Method on PROPERTY-LIST: clear (self) :
     Make SELF an empty property list.

 -- Method on PROPERTY-LIST: allocate-iterator (self) :
          (PROPERTY-LIST-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE
          (ANY-VALUE SELF)))
     Not documented.

 -- Method on PROPERTY-LIST-ITERATOR: next? (self) : BOOLEAN
     Not documented.

 -- Class: KV-CONS : STANDARD-OBJECT
     Not documented.

      -- Class Parameter of : any-key : OBJECT
          Not documented.

      -- Class Parameter of : any-value : OBJECT
          Not documented.

      -- Slot of : key : OBJECT
          Not documented.

      -- Slot of : value : OBJECT
          Not documented.

      -- Slot of : rest : KV-CONS
          Not documented.

 -- Function: kv-cons ((key OBJECT) (value OBJECT) (rest KV-CONS)) :
          KV-CONS
     Create, fill-in, and return a new KV-CONS.

 -- Function: copy-kv-cons-list ((kvconslist KV-CONS)) : KV-CONS
     Return a copy of the cons list `consList'.

 -- Class: KEY-VALUE-LIST : DICTIONARY
     Not documented.

      -- Class Parameter of : any-key : OBJECT
          Not documented.

      -- Class Parameter of : any-value : OBJECT
          Not documented.

      -- Slot of : the-kv-list : KV-CONS
          Not documented.

 -- Method on KEY-VALUE-LIST: empty? (self) : BOOLEAN
     Not documented.

 -- Method on KEY-VALUE-LIST: non-empty? (self) : BOOLEAN
     Not documented.

 -- Method on KEY-VALUE-LIST: object-equal? (x (y OBJECT)) : BOOLEAN
     Return TRUE if X and Y represent the same set of key/value pairs.

 -- Method on KEY-VALUE-LIST: equal-hash-code (self) : INTEGER
     Return an `equal?' hash code for SELF.  Note that this is O(N) in
     the number of entries of SELF.

 -- Method on KEY-VALUE-LIST: length (self) : INTEGER
     Not documented.

 -- Method on KEY-VALUE-LIST: lookup (self (key (LIKE (ANY-KEY SELF))))
          : (LIKE (ANY-VALUE SELF))
     Not documented.

 -- Method on KEY-VALUE-LIST: reverse (self) : (LIKE SELF)
     Destructively reverse the members of the list SELF.

 -- Method on KEY-VALUE-LIST: insert-at (self
          (key (LIKE (ANY-KEY SELF))) (value (LIKE (ANY-VALUE SELF)))) :
     Insert the entry <`key', VALUE> into the association SELF. If a
     previous entry existed with key KEY, that entry is replaced.

 -- Method on KEY-VALUE-LIST: remove-at (self
          (key (LIKE (ANY-KEY SELF)))) : OBJECT
     Remove the entry that matches the key KEY.  Return the value of
     the matching entry, or NULL if there is no matching entry.
     Assumes that at most one entry matches KEY.

 -- Method on KEY-VALUE-LIST: insert-entry (self
          (key (LIKE (ANY-KEY SELF))) (value (LIKE (ANY-VALUE SELF)))) :
     Insert an entry <`key',VALUE> to SELF unless an identical entry
     already exists.  This can generate duplicate entries for KEY.

 -- Method on KEY-VALUE-LIST: remove-entry (self
          (key (LIKE (ANY-KEY SELF))) (value (LIKE (ANY-VALUE SELF)))) :
     Remove the entry that matches <`key',VALUE>.  Assumes that more
     than one entry can match KEY.

 -- Method on KEY-VALUE-LIST: push (self (value KV-CONS)) :
     Make VALUE be the new first element of SELF.  Note that the `rest'
     slot of VALUE should be `null', since it will be overwritten.
     This might duplicate an existing entry. If a previous entry
     existed with the same key as VALUE, that entry is retained, but
     shadowed by this new entry.

 -- Method on KEY-VALUE-LIST: kv-push (self (key (LIKE (ANY-KEY SELF)))
          (value (LIKE (ANY-VALUE SELF)))) :
     Add a new entry <`key', VALUE> to the front of the association
     SELF. This might duplicate an existing entry. If a previous entry
     existed with key KEY, that entry is retained, but shadowed by this
     new entry.

 -- Method on KEY-VALUE-LIST: pop (self) : (LIKE (ANY-VALUE SELF))
     Remove and return the value of the first element of the kv-list
     SELF.  It does NOT return the KV-CONS object.  Return `null' if
     the list is empty.

 -- Method on KEY-VALUE-LIST: copy (self) : (LIKE SELF)
     Return a copy of the kv-list SELF.  The kv-conses in the copy are
     freshly allocated.

 -- Method on KEY-VALUE-LIST: clear (self) :
     Make SELF an empty dictionary.

 -- Method on KEY-VALUE-LIST: consify (self) : (CONS OF (LIKE
          (ANY-VALUE SELF)))
     Return a list of key-value pairs in SELF.

 -- Method on KEY-VALUE-LIST: allocate-iterator (self) :
          (KV-LIST-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE
          SELF)))
     Not documented.

 -- Method on KV-LIST-ITERATOR: next? (self) : BOOLEAN
     Not documented.


File: manual.info,  Node: Vectors,  Next: Hash Tables,  Prev: Property and Key-Value Lists,  Up: Library Functions

7.8 Vectors
===========

 -- Class: VECTOR : SEQUENCE
     Not documented.

      -- Class Parameter of : any-value : OBJECT
          Not documented.

      -- Slot of : array-size : INTEGER
          Not documented.

      -- Slot of : the-array : (NATIVE-VECTOR OF (LIKE (ANY-VALUE
               SELF)))
          Not documented.

 -- Class: EXTENSIBLE-VECTOR : VECTOR
     Not documented.

 -- Method on VECTOR: empty? (self) : BOOLEAN
     Return `true' if SELF has length 0.

 -- Method on VECTOR: non-empty? (self) : BOOLEAN
     Return `true' if SELF has length > 0.

 -- Method on VECTOR: object-equal? (x (y OBJECT)) : BOOLEAN
     Return TRUE iff the vectors X and Y are structurally equivalent.
     Uses `equal?' to test equality of elements.

 -- Method on VECTOR: equal-hash-code (self) : INTEGER
     Return an `equal?' hash code for SELF.

 -- Function: vector (&rest (values OBJECT)) : VECTOR
     Return a vector containing VALUES, in order.

 -- Method on VECTOR: first (self) : (LIKE (ANY-VALUE SELF))
     Not documented.

 -- Method on VECTOR: second (self) : (LIKE (ANY-VALUE SELF))
     Not documented.

 -- Method on VECTOR: third (self) : (LIKE (ANY-VALUE SELF))
     Not documented.

 -- Method on VECTOR: fourth (self) : (LIKE (ANY-VALUE SELF))
     Not documented.

 -- Method on VECTOR: fifth (self) : (LIKE (ANY-VALUE SELF))
     Not documented.

 -- Method on VECTOR: nth (self (position INTEGER)) : (LIKE (ANY-VALUE
          SELF))
     Not documented.

 -- Method on VECTOR: last (self) : (LIKE (ANY-VALUE SELF))
     Return the last item in the vector SELF.

 -- Method on VECTOR: but-last (self) : (ITERATOR OF (LIKE (ANY-VALUE
          SELF)))
     Generate all but the last element of the vector SELF.

 -- Method on VECTOR: length (self) : INTEGER
     Not documented.

 -- Method on VECTOR: member? (self (object OBJECT)) : BOOLEAN
     Not documented.

 -- Method on VECTOR: position (self (object OBJECT) (start INTEGER)) :
          INTEGER
     Return the position of OBJECT within the vector SELF (counting
     from zero); or return `null' if OBJECT does not occur within SELF
     (uses an `eql?' test).  If START was supplied as non-`null', only
     consider the portion starting at START, however, the returned
     position will always be relative to the entire vector.

 -- Method on VECTOR: last-position (self (object OBJECT)
          (end INTEGER)) : INTEGER
     Return the position of OBJECT within the vector SELF (counting
     from zero); or return `null' if OBJECT does not occur within SELF
     (uses an `eql?' test).  If END was supplied as non-`null', only
     consider the portion ending at index END, however, the returned
     position will always be relative to the entire vector.

 -- Method on VECTOR: insert-at (self (offset INTEGER)
          (value (LIKE (ANY-VALUE SELF)))) :
     Not documented.

 -- Method on VECTOR: copy (self) : (VECTOR OF (LIKE (ANY-VALUE SELF)))
     Return a copy of the vector SELF.

 -- Method on VECTOR: clear (self) :
     Not documented.

 -- Function: resize-vector ((self VECTOR) (size INTEGER)) :
     Change the size of SELF to SIZE.  If SIZE is smaller than the
     current size of SELF the vector will be truncated.  Otherwise, the
     internal array of SELF will be grown to SIZE and unused elements
     will be initialized to NULL.

 -- Method on VECTOR: consify (self) : (CONS OF (LIKE (ANY-VALUE SELF)))
     Return a list of elements in SELF.

 -- Method on EXTENSIBLE-VECTOR: insert-at (self (offset INTEGER)
          (value (LIKE (ANY-VALUE SELF)))) :
     Not documented.

 -- Method on VECTOR-SEQUENCE: insert (self
          (value (LIKE (ANY-VALUE SELF)))) :
     Append VALUE to the END of the sequence SELF.  Resize the array if
     necessary.

 -- Method on VECTOR-SEQUENCE: remove (self
          (value (LIKE (ANY-VALUE SELF)))) : VECTOR-SEQUENCE
     Remove VALUE from the sequence SELF, and left shift the values
     after it to close the gap.

 -- Method on VECTOR-SEQUENCE: length (self) : INTEGER
     Not documented.


File: manual.info,  Node: Hash Tables,  Next: Key Value Maps,  Prev: Vectors,  Up: Library Functions

7.9 Hash Tables
===============

 -- Class: HASH-TABLE : ABSTRACT-HASH-TABLE
     Not documented.

      -- Class Parameter of : any-key : OBJECT
          Not documented.

      -- Class Parameter of : any-value : OBJECT
          Not documented.

 -- Class: STRING-HASH-TABLE : ABSTRACT-HASH-TABLE
     Not documented.

      -- Class Parameter of : any-key : STRING
          Not documented.

      -- Class Parameter of : any-value : OBJECT
          Not documented.

 -- Class: STRING-TO-INTEGER-HASH-TABLE : ABSTRACT-HASH-TABLE
     Not documented.

      -- Class Parameter of : any-key : STRING
          Not documented.

      -- Class Parameter of : any-value : INTEGER
          Not documented.

 -- Class: INTEGER-HASH-TABLE : ABSTRACT-HASH-TABLE
     Not documented.

      -- Class Parameter of : any-key : INTEGER
          Not documented.

      -- Class Parameter of : any-value : OBJECT
          Not documented.

 -- Class: FLOAT-HASH-TABLE : ABSTRACT-HASH-TABLE
     Not documented.

      -- Class Parameter of : any-key : FLOAT
          Not documented.

      -- Class Parameter of : any-value : OBJECT
          Not documented.

 -- Method on HASH-TABLE: lookup (self (key (LIKE (ANY-KEY SELF)))) :
          (LIKE (ANY-VALUE SELF))
     Not documented.

 -- Method on HASH-TABLE: insert-at (self (key (LIKE (ANY-KEY SELF)))
          (value (LIKE (ANY-VALUE SELF)))) :
     Not documented.

 -- Method on HASH-TABLE: remove-at (self (key (LIKE (ANY-KEY SELF)))) :
     Not documented.

 -- Method on STRING-HASH-TABLE: lookup (self (key STRING)) : (LIKE
          (ANY-VALUE SELF))
     Not documented.

 -- Method on STRING-HASH-TABLE: insert-at (self (key STRING)
          (value OBJECT)) :
     Not documented.

 -- Method on STRING-HASH-TABLE: remove-at (self (key STRING)) :
     Not documented.

 -- Method on STRING-TO-INTEGER-HASH-TABLE: lookup (self (key STRING))
          : INTEGER
     Not documented.

 -- Method on STRING-TO-INTEGER-HASH-TABLE: insert-at (self
          (key STRING) (value INTEGER)) :
     Not documented.

 -- Method on INTEGER-HASH-TABLE: lookup (self (key INTEGER)) : (LIKE
          (ANY-VALUE SELF))
     Not documented.

 -- Method on INTEGER-HASH-TABLE: insert-at (self (key INTEGER)
          (value OBJECT)) :
     Not documented.

 -- Method on FLOAT-HASH-TABLE: insert-at (self (key FLOAT)
          (value OBJECT)) :
     Not documented.

   STELLA provides its own implementation of hash tables for cases where
language-native implementations are not available, or where additional
features are needed.

 -- Class: STELLA-HASH-TABLE : ABSTRACT-HASH-TABLE
     Not documented.

      -- Class Parameter of : any-key : OBJECT
          Not documented.

      -- Class Parameter of : any-value : OBJECT
          Not documented.

      -- Slot of : the-table : (ARRAY SIZE () OF KV-CONS)
          Not documented.

      -- Slot of : size : INTEGER
          Not documented.

      -- Slot of : initial-size : INTEGER
          If supplied, the initial hash table will be sized to hold at
          least that many elements.

      -- Slot of : free-elements : INTEGER
          Not documented.

      -- Slot of : equal-test? : BOOLEAN
          If true use `equal?' as the equality test and
          `equal-hash-code' as the hash function, otherwise, use `eql?'
          and `hash-code' (the default).

 -- Method on STELLA-HASH-TABLE: lookup (self
          (key (LIKE (ANY-KEY SELF)))) : (LIKE (ANY-VALUE SELF))
     Lookup the entry identified by KEY in SELF and return its value,
     or NULL if no such entry exists.    Uses an `eql?' test by default
     or `equal?' if `equal-test?' of SELF is TRUE.

 -- Method on STELLA-HASH-TABLE: insert-at (self
          (key (LIKE (ANY-KEY SELF))) (value (LIKE (ANY-VALUE SELF)))) :
     Set the value of the entry identified by KEY in SELF to VALUE or
     add a new entry if no entry with KEY exists yet.  Uses an `eql?'
     test by default or `equal?' if `equal-test?' of SELF is TRUE.

 -- Method on STELLA-HASH-TABLE: remove-at (self
          (key (LIKE (ANY-KEY SELF)))) :
     Remove the entry identified by KEY from SELF.  Uses an `eql?' test
     by default or `equal?' if `equal-test?' of SELF is TRUE.

 -- Method on STELLA-HASH-TABLE: length (self) : INTEGER
     Return the number of entries in SELF.

 -- Method on STELLA-HASH-TABLE: empty? (self) : BOOLEAN
     Return TRUE if SELF has zero entries.

 -- Method on STELLA-HASH-TABLE: non-empty? (self) : BOOLEAN
     Return TRUE if SELF has at least 1 entry.

 -- Method on STELLA-HASH-TABLE: copy (self) : (LIKE SELF)
     Return a copy of the hash table SELF.  The bucket table and
     buckets are freshly allocated, however, the keys and values of
     entries are not copied themselves (similar to what we do for
     lists, etc.).

 -- Method on STELLA-HASH-TABLE: clear (self) :
     Remove all entries from SELF.  This will result in a
     re-initialization of the table upon the first insertion into SELF.

 -- Method on STELLA-HASH-TABLE: consify (self) : (CONS OF CONS)
     Collect all entries of SELF into a cons list of `(<key> <value>)'
     pairs and return the result.

 -- Method on STELLA-HASH-TABLE: object-equal? (x (y OBJECT)) : BOOLEAN
     Return TRUE if X and Y represent the same set of key/value pairs.

 -- Method on STELLA-HASH-TABLE: equal-hash-code (self) : INTEGER
     Return an `equal?' hash code for SELF.  Note that this is O(N) in
     the number of entries of SELF.

 -- Method on STELLA-HASH-TABLE: allocate-iterator (self) :
          (STELLA-HASH-TABLE-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE
          (ANY-VALUE SELF)))
     Allocate an iterator for SELF.

   Hashing objects into STELLA hash tables is accomplished via
`hash-code' and `equal-hash-code' methods.  These methods are
implemented for all built-in STELLA types but are user extensible for
cases where special functionality on user-defined objects is needed.
Defining new `hash-code' methods should only be necessary if new
wrapper types are defined, since for all types descending from
`STANDARD-OBJECT' the built-in method should be adequate.

 -- Function: object-hash-code ((self OBJECT)) : INTEGER
     Return a hash code for SELF (can be negative).  Two objects that
     are `eq?' are guaranteed to generate the same hash code.  Two
     objects that are not `eq?' do not necessarily generate different
     hash codes.  Similar to `hash-code' but always hashes on the
     address of SELF even if it is a wrapper.

 -- Method on OBJECT: hash-code (self) : INTEGER
     Return a hash code for SELF (can be negative).  Two objects that
     are `eql?' are guaranteed to generate the same hash code.  Two
     objects that are not `eql?' do not necessarily generate different
     hash codes.

 -- Method on STANDARD-OBJECT: hash-code (self) : INTEGER
     Not documented.

 -- Method on STRING-WRAPPER: hash-code (self) : INTEGER
     Not documented.

 -- Method on INTEGER-WRAPPER: hash-code (self) : INTEGER
     Not documented.

 -- Method on FLOAT-WRAPPER: hash-code (self) : INTEGER
     Not documented.

 -- Method on CHARACTER-WRAPPER: hash-code (self) : INTEGER
     Not documented.

 -- Method on BOOLEAN-WRAPPER: hash-code (self) : INTEGER
     Not documented.

 -- Method on STRING: hash-code (self) : INTEGER
     Not documented.

 -- Method on INTEGER: hash-code (self) : INTEGER
     Not documented.

 -- Method on FLOAT: hash-code (self) : INTEGER
     Not documented.

 -- Method on CHARACTER: hash-code (self) : INTEGER
     Not documented.

 -- Method on OBJECT: equal-hash-code (self) : INTEGER
     Return a hash code for SELF (can be negative).  Two objects that
     are `equal?' are guaranteed to generate the same hash code
     (provided, that writers of `object-equal?' methods also
     implemented the appropriate `equal-hash-code' method).  Two
     objects that are not `equal?'do not necessarily generate different
     hash codes.

   The following low-level utilities are available to implement
specialized hashing schemes or for defining new versions of
`equal-hash-code'.

 -- Function: hashmod ((code INTEGER) (size INTEGER)) : INTEGER
     Map the hash code CODE onto a bucket index for a hash table of
     SIZE (i.e., onto the interval [0..size-1].  This is just like
     `rem' for positive hash codes but also works for negative hash
     codes by mapping those onto a positive number first.  Note, that
     the sign conversion mapping is not equivalent to calling the `abs'
     function (it simply masks the sign bit for speed) and therefore
     really only makes sense for hash codes.

 -- Function: rotate-hash-code ((arg INTEGER)) : INTEGER
     Rotate ARG to the right by 1 position.  This means shift ARG to
     the right by one and feed in ARGs bit zero from the left.  In Lisp
     the result will stay in positive FIXNUM range.  In C++ and Java
     this might return a negative value which might be equal to
     NULL-INTEGER.  Important: to make this inlinable, it must be
     called with an atom (i.e., constant or variable) as its argument.
     This function is primarily useful for hashing sequences of items
     where the hash code should take the sequential order of elements
     into account (e.g., lists).


File: manual.info,  Node: Key Value Maps,  Next: Hash Sets,  Prev: Hash Tables,  Up: Library Functions

7.10 Key Value Maps
===================

`KEY-VALUE-MAP' is a full-featured dictionary class that supports
`eql?' or extensible `equal?' equality tests, O(1) access operations
even for large numbers of entries by using a hash table, light-weight
`KV-CONS' representation for small tables and iteration even if the
dictionary is represented by a hash table (note that in STELLA we
cannot iterate over regular `HASH-TABLE''s, since native Lisp hash
tables do not allow us to implement a hash table iterator).  Since
large `KEY-VALUE-MAP''s are implemented via `STELLA-HASH-TABLE''s, we
can support iteration.

 -- Class: KEY-VALUE-MAP : DICTIONARY
     Full-featured dictionary class that supports `eql?' or `equal?'
     equality tests, O(1) access operations even for large numbers of
     entries by using a hash table, light-weight KV-CONS representation
     for small tables and iteration even if the dictionary is
     represented by a hash table.

      -- Slot of : the-map : OBJECT
          Not documented.

      -- Slot of : equal-test? : BOOLEAN
          If true use `equal?' as the equality test (and
          `equal-hash-code' as the hash function), otherwise, use
          `eql?' (and `hash-code') (the default).

      -- Slot of : initial-size : INTEGER
          If supplied, the initial table will be sized to hold at least
          that many elements.

      -- Slot of : crossover-point : INTEGER
          Not documented.

 -- Method on KEY-VALUE-MAP: lookup (self (key (LIKE (ANY-KEY SELF))))
          : (LIKE (ANY-VALUE SELF))
     Lookup the entry identified by KEY in SELF and return its value,
     or NULL if no such entry exists.    Uses an `eql?' test by default
     or `equal?' if `equal-test?' of SELF is TRUE.

 -- Method on KEY-VALUE-MAP: insert-at (self
          (key (LIKE (ANY-KEY SELF))) (value (LIKE (ANY-VALUE SELF)))) :
     Set the value of the entry identified by KEY in SELF to VALUE or
     add a new entry if no entry with KEY exists yet.  Uses an `eql?'
     test by default or `equal?' if `equal-test?' of SELF is TRUE.

 -- Method on KEY-VALUE-MAP: remove-at (self
          (key (LIKE (ANY-KEY SELF)))) :
     Remove the entry identified by KEY from SELF.  Uses an `eql?' test
     by default or `equal?' if `equal-test?' of SELF is TRUE.

 -- Method on KEY-VALUE-MAP: length (self) : INTEGER
     Return the number of entries in SELF.

 -- Method on KEY-VALUE-MAP: empty? (self) : BOOLEAN
     Return TRUE if SELF has zero entries.

 -- Method on KEY-VALUE-MAP: non-empty? (self) : BOOLEAN
     Return TRUE if SELF has at least 1 entry.

 -- Method on KEY-VALUE-MAP: copy (self) : (LIKE SELF)
     Return a copy of the map SELF.  All entries are freshly allocated,
     however, the keys and values of entries are not copied themselves
     (similar to what we do for lists, etc.).

 -- Method on KEY-VALUE-MAP: clear (self) :
     Reset SELF to have zero entries.

 -- Method on KEY-VALUE-MAP: allocate-iterator (self) :
          (DICTIONARY-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE
          (ANY-VALUE SELF)))
     Allocate an iterator for SELF.  The only modifying operations
     allowed during iteration are removal of the current element or
     changing its value.  All other removal or insertion operations
     might lead to corruption or undefined results.

 -- Method on KEY-VALUE-MAP: consify (self) : CONS
     Collect all entries of SELF into a cons list of `(<key> <value>)'
     pairs and return the result.

 -- Method on KEY-VALUE-MAP: object-equal? (x (y OBJECT)) : BOOLEAN
     Return TRUE if X and Y represent the same set of key/value pairs.

 -- Method on KEY-VALUE-MAP: equal-hash-code (self) : INTEGER
     Return an `equal?' hash code for SELF.  Note that this is O(N) in
     the number of entries of SELF.


File: manual.info,  Node: Hash Sets,  Next: Iterators,  Prev: Key Value Maps,  Up: Library Functions

7.11 Hash Sets
==============

`HASH-SET' is a full-featured set class that supports `eql?' or
extensible `equal?' equality tests, O(1) insert and `member?'
operations, O(N) `intersection' etc. operations even for large numbers
of entries by using a STELLA hash table, light-weight `KV-CONS'
representation for small sets and iteration even if the set is
represented by a hash table.  The only minor drawback right now is that
we waste one value slot per entry, since we piggy-back off
`KEY-VALUE-MAP''s, however, that wastes at most 25% space.

 -- Class: HASH-SET : KEY-VALUE-MAP, SET-MIXIN
     Full-featured set class that supports `eql?' or `equal?' equality
     tests, O(1) insert and `member?' operations & O(N) `intersection'
     etc. operations even for large numbers of entries by using a hash
     table, light-weight KV-CONS representation for small sets and
     iteration even if the set is represented by a hash table.  The
     only minor drawback right now is that this wastes a value slot per
     entry, since we piggy-back off KEY-VALUE-MAP's, however, that
     wastes at most 25% space.

 -- Function: hash-set (&rest (values OBJECT)) : HASH-SET
     Return an `eql?' HASH-SET containing VALUES.

 -- Method on HASH-SET: member? (self (object OBJECT)) : BOOLEAN
     Return TRUE iff OBJECT is a member of the set SELF.  Uses an
     `eql?' test by default or `equal?' if `equal-test?' of SELF is
     TRUE.

 -- Method on HASH-SET: insert (self (value (LIKE (ANY-VALUE SELF)))) :
     Add VALUE to the set SELF unless it is already a member.  Uses an
     `eql?' test by default or `equal?' if `equal-test?' of SELF is
     TRUE.

 -- Method on HASH-SET: remove (self (value (LIKE (ANY-VALUE SELF)))) :
          (LIKE SELF)
     Destructively remove VALUE from the set SELF if it is a member and
     return SELF.  Uses an `eql?' test by default or `equal?' if
     `equal-test?' of SELF is TRUE.

 -- Method on HASH-SET: remove-if (self (test? FUNCTION-CODE)) : (LIKE
          SELF)
     Destructively remove all elements of the set SELF for which TEST?
     evaluates to TRUE.  TEST? takes a single argument of type OBJECT
     and returns TRUE or FALSE.  Returns SELF.

 -- Method on HASH-SET: pop (self) : (LIKE (ANY-VALUE SELF))
     Remove and return an arbitrary element of the set SELF.  Return
     NULL if the set is empty.  Performance note: for large sets
     implemented via hash tables it takes O(N) to empty out the set
     with repeated calls to `pop', since the emptier the table gets,
     the longer it takes to find an element.  Therefore, it is usually
     better to use iteration with embedded removals for such cases.

 -- Method on HASH-SET: substitute (self (new OBJECT) (old OBJECT)) :
          (LIKE SELF)
     Destructively replace OLD with NEW in the set SELF unless NEW is
     already a member.  Uses an `eql?' test by default or `equal?' if
     `equal-test?' of SELF is TRUE.

 -- Method on HASH-SET: copy (self) : (LIKE SELF)
     Return a copy of the set SELF.  All entries are freshly allocated,
     however, the values are not copied themselves (similar to what we
     do for lists, etc.).

 -- Method on HASH-SET: consify (self) : (CONS OF (LIKE (ANY-VALUE
          SELF)))
     Collect all entries of SELF into a cons list and return the result.

 -- Method on HASH-SET: subset? (self (otherSet HASH-SET)) : BOOLEAN
     Return true if every element of SELF also occurs in OTHERSET.
     Uses an `eql?' test by default or `equal?' if `equal-test?' of
     SELF is TRUE.

 -- Method on HASH-SET: equivalent-sets? (self (otherSet HASH-SET)) :
          BOOLEAN
     Return true if every element of SELF occurs in OTHERSET and vice
     versa.  Uses an `eql?' test by default or `equal?' if
     `equal-test?' of SELF is TRUE.

 -- Method on HASH-SET: intersection (self (otherSet HASH-SET)) :
          HASH-SET
     Return the set intersection of SELF and OTHERSET as a new set.
     Uses an `eql?' test by default or `equal?' if `equal-test?' of
     SELF is TRUE.

 -- Method on HASH-SET: union (self (otherSet HASH-SET)) : HASH-SET
     Return the set union of SELF and OTHERSET as a new set.  Uses an
     `eql?' test by default or `equal?' if `equal-test?' of SELF is
     TRUE.

 -- Method on HASH-SET: difference (self (otherSet HASH-SET)) : HASH-SET
     Return the set difference of SELF and OTHERSET as a new set (i.e.,
     all elements that are in SELF but not in OTHERSET).  Uses an
     `eql?' test by default or `equal?' if `equal-test?' of SELF is
     TRUE.

 -- Method on HASH-SET: subtract (self (otherSet HASH-SET)) : HASH-SET
     Return the set difference of SELF and OTHERSET by destructively
     removing elements from SELF that also occur in OTHERSET.  Uses an
     `eql?' test by default or `equal?' if `equal-test?' of SELF is
     TRUE.

 -- Method on HASH-SET: object-equal? (x (y OBJECT)) : BOOLEAN
     Return TRUE iff sets X and Y are HASH-SET's with equivalent
     members.  Uses an `eql?' test by default or `equal?' if
     `equal-test?' of `self' is TRUE.  This is equivalent to calling
     `equivalent-sets?'.

 -- Method on HASH-SET: equal-hash-code (self) : INTEGER
     Return an `equal?' hash code for SELF.  Note that this is O(N) in
     the number of elements of SELF.


File: manual.info,  Node: Iterators,  Next: Symbols,  Prev: Hash Sets,  Up: Library Functions

7.12 Iterators
==============

 -- Method on ITERATOR: empty? (self) : BOOLEAN
     Return TRUE if the sequence represented by SELF has no elements.
     Side-effect free.

 -- Method on ITERATOR: member? (self (value OBJECT)) : BOOLEAN
     Iterate over values of SELF, returning TRUE if one of them is
     `eql' to 'value.

 -- Method on ABSTRACT-ITERATOR: length (self) : INTEGER
     Iterate over SELF, and count how many items there are.  Bad idea
     if SELF iterates over an infinite collection, since in that case
     it will run forever.'

 -- Method on ITERATOR: pop (self) : (LIKE (ANY-VALUE SELF))
     Return the first item of the sequence represented by SELF, or NULL
     if it is empty.  Destructively uses up the first iteration element.

 -- Method on ITERATOR: advance (self (n INTEGER)) : (LIKE SELF)
     Return SELF after skipping over the first N elements in the
     (remainder of the) iteration.

 -- Method on ITERATOR: concatenate (iterator1 (iterator2 ITERATOR)
          &rest (otherIterators ITERATOR)) : ALL-PURPOSE-ITERATOR
     Return an iterator that first generates all values of ITERATOR1,
     then those of ITERATOR2, and then those of all OTHERITERATORS.
     The generated values can be filtered by supplying a filter
     function to the resulting iterator.

 -- Method on ITERATOR: consify (self) : (CONS OF (LIKE (ANY-VALUE
          SELF)))
     Return a list of elements generated by SELF.

 -- Method on ALL-PURPOSE-ITERATOR: next? (self) : BOOLEAN
     Apply the stored `next?' function to SELF.


File: manual.info,  Node: Symbols,  Next: Contexts and Modules,  Prev: Iterators,  Up: Library Functions

7.13 Symbols
============

 -- Function: lookup-symbol ((name STRING)) : SYMBOL
     Return the first symbol with NAME visible from the current module.

 -- Function: intern-symbol ((name STRING)) : SYMBOL
     Return a newly-created or existing symbol with name NAME.

 -- Function: unintern-symbol ((self SYMBOL)) :
     Remove SELF from its home module and the symbol table.

 -- Function: lookup-symbol-in-module ((name STRING) (module MODULE)
          (local? BOOLEAN)) : SYMBOL
     Return the first symbol with NAME visible from MODULE.  If LOCAL?
     only consider symbols directly interned in MODULE.  If MODULE is
     `null', use `*MODULE*' instead.

 -- Function: intern-symbol-in-module ((name STRING) (module MODULE)
          (local? BOOLEAN)) : SYMBOL
     Look for a symbol named NAME in MODULE (if LOCAL? do not consider
     inherited modules).  If none exists, intern it locally in MODULE.
     Return the existing or newly-created symbol.

 -- Function: intern-derived-symbol ((baseSymbol GENERALIZED-SYMBOL)
          (newName STRING)) : SYMBOL
     Return a newly-created or existing symbol with name NEWNAME which
     is interned in the same module as BASESYMBOL.

 -- Function: visible-symbol? ((self SYMBOL)) : BOOLEAN
     Return `true' if SELF is visible from the current module.

 -- Function: lookup-visible-symbols-in-module ((name STRING)
          (module MODULE) (enforceShadowing? BOOLEAN)) : (CONS OF
          SYMBOL)
     Return the list of symbols with NAME visible from MODULE.  More
     specific symbols (relative to the module precedence order defined
     by `visible-modules') come earlier in the list.  If MODULE is
     `null', start from `*MODULE*' instead.  If ENFORCESHADOWING? is
     true, do not return any symbols that are shadowed due to some
     :SHADOW declaration.

 -- Function: import-symbol ((symbol SYMBOL) (module MODULE)) : SYMBOL
     Import SYMBOL into MODULE and return the imported SYMBOL.  Signal
     an error if a different symbol with the same name already exists
     locally in MODULE.  Any symbol with the same name visible in
     MODULE by inheritance will be shadowed by the newly imported
     SYMBOL.

 -- Function: safe-import-symbol ((symbol SYMBOL) (module MODULE)) :
          SYMBOL
     Safe version of `import-symbol' (which see).  Only imports SYMBOL
     if no symbol with that name is currently interned or visible in
     MODULE.  Returns SYMBOL if it was imported or the conflicting
     symbol in MODULE otherwise.

 -- Function: lookup-surrogate ((name STRING)) : SURROGATE
     Return the first surrogate with NAME visible from the current
     module.

 -- Function: intern-surrogate ((name STRING)) : SURROGATE
     Return a newly-created or existing surrogate with name NAME.

 -- Function: unintern-surrogate ((self SURROGATE)) :
     Remove SELF from its home module and the surrogate table.

 -- Function: lookup-surrogate-in-module ((name STRING) (module MODULE)
          (local? BOOLEAN)) : SURROGATE
     Return the first surrogate with NAME visible from MODULE.  If
     LOCAL? only consider surrogates directly interned in MODULE.  If
     MODULE is `null', use `*MODULE*' instead.

 -- Function: intern-surrogate-in-module ((name STRING) (module MODULE)
          (local? BOOLEAN)) : SURROGATE
     Look for a symbol named NAME in MODULE (if LOCAL? do not consider
     inherited modules).  If none exists, intern it locally in MODULE.
     Return the existing or newly-created symbol.

 -- Function: intern-derived-surrogate ((baseSymbol GENERALIZED-SYMBOL)
          (newName STRING)) : SURROGATE
     Return a newly-created or existing surrogate with name NEWNAME
     which is interned in the same module as BASESYMBOL.

 -- Function: visible-surrogate? ((self SURROGATE)) : BOOLEAN
     Return `true' if SELF is visible from the current module.

 -- Function: lookup-visible-surrogates-in-module ((name STRING)
          (module MODULE) (enforceShadowing? BOOLEAN)) : (CONS OF
          SURROGATE)
     Return the list of surrogates with NAME visible from MODULE.  More
     specific surrogates (relative to the module precedence order
     defined by `visible-modules') come earlier in the list.  If MODULE
     is `null', start from `*MODULE*' instead.  If ENFORCESHADOWING? is
     true, do not return any surrogates that are shadowed due to some
     :SHADOW declaration.

 -- Function: import-surrogate ((surrogate SURROGATE) (module MODULE))
          : SURROGATE
     Import SURROGATE into MODULE and return the imported SURROGATE.
     Signal an error if a different surrogate with the same name
     already exists locally in MODULE.  Any surrogate with the same
     name visible in MODULE by inheritance will be shadowed by the
     newly imported SURROGATE.

 -- Function: safe-import-surrogate ((surrogate SURROGATE)
          (module MODULE)) : SURROGATE
     Safe version of `import-surrogate' (which see).  Only imports
     SURROGATE if no surrogate with that name is currently interned or
     visible in MODULE.  Returns SURROGATE if it was imported or the
     conflicting surrogate in MODULE otherwise.

 -- Function: lookup-keyword ((name STRING)) : KEYWORD
     Return the keyword with NAME if it exists.

 -- Function: intern-keyword ((name STRING)) : KEYWORD
     Return a newly-created or existing keyword with name NAME.
     Storage note: a COPY of NAME is stored in the keyword

 -- Function: gensym ((prefix STRING)) : SYMBOL
     Return a transient symbol with a name beginning with PREFIX and
     ending with a globally gensym'd integer.

 -- Function: local-gensym ((prefix STRING)) : SYMBOL
     Not documented.

 -- Function: symbol-plist ((symbol SYMBOL)) : CONS
     Return the property list of SYMBOL.  The `symbol-plist' of a
     symbol can be set with `setf'.  IMPORTANT: Property list are
     modified destructively, hence, if you supply it as a whole make
     sure to always supply a modfiable copy, e.g., by using `bquote'.

 -- Function: symbol-property ((symbol SYMBOL) (key STANDARD-OBJECT)) :
          OBJECT
     Return the property of SYMBOL whose key is `eq?' to KEY.  Symbol
     properties can be set with `setf'.

 -- Function: symbol-value ((symbol SYMBOL)) : OBJECT
     Return the value of SYMBOL.  Note, that this value is not visible
     to code that references a variable with the same name as SYMBOL.
     The `symbol-value' is simply a special property that can always be
     accessed in constant time.  The `symbol-value' of a symbol can be
     changed with `setf'.

 -- Function: symbolize ((surrogate SURROGATE)) : SYMBOL
     Convert SURROGATE into a symbol with the same name and module.


File: manual.info,  Node: Contexts and Modules,  Next: Input and Output,  Prev: Symbols,  Up: Library Functions

7.14 Context and Modules
========================

 -- Function: get-stella-context ((pathName STRING) (error? BOOLEAN)) :
          CONTEXT
     Return the context located at PATHNAME, or `null' if no such
     context exists.  If ERROR? is `true', throw an exception if no
     context is found, otherwise silently return `null'.

 -- Function: clear-context ((self CONTEXT)) :
     Destroy all objects belonging to SELF or any of its subcontexts.

 -- Macro: within-context ((contextForm OBJECT) &body (body CONS)) :
          OBJECT
     Execute BODY within the context resulting from CONTEXTFORM.

 -- Method on CONTEXT: destroy-context (self) :
     Make the translator happy.

 -- Method on STRING: destroy-context (self) :
     Destroy the context SELF, and recursively destroy all contexts
     that inherit SELF.

 -- Method on CONTEXT: change-context (context) : CONTEXT
     Change the current context to be the context CONTEXT.

 -- Method on STRING: change-context (contextName) : CONTEXT
     Change the current context to be the context named CONTEXTNAME.

 -- N-Command: cc (&rest (name NAME)) : CONTEXT
     Change the current context to the one named NAME.  Return the
     value of the new current context.  If no NAME is supplied, return
     the pre-existing value of the current context.  `cc' is a no-op if
     the context reference cannot be successfully evaluated.

 -- N-Command: defmodule ((name NAME) &rest (options OBJECT)) :
     Define (or redefine) a module named NAME.  The accepted syntax is:

            (defmodule <module-name>
               [:documentation <docstring>]
               [:includes {<module-name> | (<module-name>*)}]
               [:uses {<module-name> | (<module-name>*)}]
               [:lisp-package <package-name-string>]
               [:java-package <package-specification-string>]
               [:cpp-namespace <namespace-name-string>]
               [:java-catchall-class
               [:api? {TRUE | FALSE}]
               [:case-sensitive? {TRUE | FALSE}]
               [:shadow (<symbol>*)]
               [:java-catchall-class <class-name-string>]
               [<other-options>*])

     NAME can be a string or a symbol.

     Modules include objects from other modules via two separate
     mechanisms: (1) they inherit from their parents specified via the
     `:includes' option and/or a fully qualified module name, and (2)
     they inherit from used modules specified via the `:uses' option.
     The main difference between the two mechanisms is that inheritance
     from parents is transitive, while uses-links are only followed one
     level deep.  I.e., a module A that uses B will see all objects of
     B (and any of B's parents) but not see anything from modules used
     by B.  Another difference is that only objects declared as public
     can be inherited via uses-links (this is not yet enforced).  Note
     that - contrary to Lisp - there are separate name spaces for
     classes, functions, and variables.  For example, a module could
     inherit the class `CONS' from the `STELLA' module, but shadow the
     function of the same name.

     The above discussion of `:includes' and `:uses' semantics keyed on
     the inheritance/visibility of symbols. The PowerLoom system makes
     another very important distinction: If a module `A' is inherited
     directly or indirectly via `:includes' specification(s) by a
     submodule `B', then all definitions and facts asserted in `A' are
     visible in `B'. This is not the cases for `:uses'; the `:uses'
     options does not impact inheritance of propositions at all.

     The list of modules specified in the `:includes' option plus (if
     supplied) the parent in the path used for NAME become the new
     module's parents. If no `:uses' option was supplied, the new
     module will use the `STELLA' module by default, otherwise, it will
     use the set of specified modules.  If `:case-sensitive?' is
     supplied as TRUE, symbols in the module will be interned
     case-sensitively, otherwise (the default), they will be converted
     to uppercase before they get interned. Modules can shadow
     definitions of functions and classes inherited from parents or used
     modules. Shadowing is done automatically, but generates a warning
     unless the shadowed type or function name is listed in the
     `:shadow' option of the module definition .

     Examples:

            (defmodule "PL-KERNEL/PL-USER"
              :uses ("LOGIC" "STELLA")
              :package "PL-USER")

            (defmodule PL-USER/GENEALOGY)

     The remaining options are relevant only for modules that contain
     STELLA code.  Modules used only to contain knowledge base
     definitions and assertions have no use for them:

     The keywords `:lisp-package', `:java-package', and `:cpp-package'
     specify the name of a native package or name space in which
     symbols of the module should be allocated when they get translated
     into one of Lisp, Java, or C++. By default, Lisp symbols are
     allocated in the `STELLA' package, and C++ names are translated
     without any prefixes. The rules that the STELLA translator uses to
     attach translated Java objects to classes and packages are
     somewhat complex. Use :java-package option to specify a list of
     package names (separated by periods) that prefix the Java object
     in this module.  Use :java-catchall-class to specify the name of
     the Java class to contain all global & special variables,
     parameter-less functions and functions defined on arguments that
     are not classes in the current module.  The default value will be
     the name of the module.

     When set to TRUE, the :api? option tells the PowerLoom User Manual
     generator that all functions defined in this module should be
     included in the API section. Additionally, the Java translator
     makes all API functions `synchronized'.


 -- Function: get-stella-module ((pathName STRING) (error? BOOLEAN)) :
          MODULE
     Return the module located at PATHNAME, or `null' if no such module
     exists.  The search looks at ancestors and top-most  (cardinal)
     modules.  If ERROR? is `true', throw an exception if no  module is
     found.

 -- Function: find-or-create-module ((pathname STRING)) : MODULE
     Return a module located at PATHNAME if one exists,   otherwise
     create one

 -- N-Command: clear-module (&rest (name NAME)) :
     Destroy all objects belonging to module NAME or any of its
     children.  If no NAME is supplied, the current module will be
     cleared after confirming with the user.  Important modules such as
     STELLA are protected against accidental clearing.

 -- Function: destroy-module ((self MODULE)) :
     Destroy the module SELF, and recursively destroy all contexts that
     inherit SELF.

 -- Method on MODULE: destroy-context (self) :
     Destroy the context SELF, and recursively destroy all contexts
     that inherit SELF.

 -- Function: visible-modules ((from MODULE)) : (CONS OF MODULE)
     Return a list of all modules visible from module FROM (or
     `*module*' if FROM is NULL.  The generated modules are generated
     from most to least-specific and will start with the module FROM.

 -- Macro: within-module ((moduleForm OBJECT) &body (body CONS)) :
          OBJECT
     Execute BODY within the module resulting from MODULEFORM.
     `*module*' is an acceptable MODULEFORM.  It will locally rebind
     `*module*' and `*context*' and shield the outer bindings from
     changes.

 -- N-Command: in-module ((name NAME)) : MODULE
     Change the current module to the module named NAME.

 -- Method on MODULE: change-module (module) : MODULE
     Change the current module to be the module MODULE.

 -- Method on STRING: change-module (moduleName) : MODULE
     Change the current module to be the module named MODULENAME.

 -- Function: create-world ((parentContext CONTEXT) (name STRING)) :
          WORLD
     Create a new world below the world or module PARENTCONTEXT.
     Optionally, specify a name.

 -- Function: push-world () : WORLD
     Spawn a new world that is a child of the current context, and
     change the current context to the new world.

 -- Function: pop-world () : CONTEXT
     Destroy the current world and change the current context to be its
     parent.  Return the current context. Nothing happens if there is
     no current world.

 -- Method on WORLD: destroy-context (self) :
     Destroy the context SELF, and recursively destroy all contexts
     that inherit SELF.

 -- Macro: within-world ((worldForm OBJECT) &body (body CONS)) : OBJECT
     Execute BODY within the world resulting from WORLDFORM.


File: manual.info,  Node: Input and Output,  Next: Files,  Prev: Contexts and Modules,  Up: Library Functions

7.15 Input and Output
=====================

 -- Function: read-s-expression ((stream INPUT-STREAM)) : OBJECT BOOLEAN
     Read one STELLA s-expression from STREAM and return the result.
     Return `true' as the second value on EOF.

 -- Function: read-s-expression-from-string ((string STRING)) : OBJECT
     Read one STELLA s-expression from STRING and return the result.

 -- Function: read-line ((stream INPUT-STREAM)) : STRING
     Read one line from STREAM and return the result.  This differs
     from `native-read-line' in that it is not platform-dependent.  It
     recognizes any of the three common line ending formats: CR, LF,
     CR-LF in any combination.  It is not as fast as
     `native-read-line', however.

 -- Function: read-character ((inputStream INPUT-STREAM)) : CHARACTER
          BOOLEAN
     Read one character from INPUTSTREAM and return the result.  Return
     `true' as the second value on EOF.

 -- Function: unread-character ((ch CHARACTER)
          (inputStream INPUT-STREAM)) :
     Unread CH from INPUTSTREAM.  Signal an error if CH was not the
     last character read.

 -- Function: y-or-n? ((message STRING)) : BOOLEAN
     Read a line of input from STANDARD-INPUT and return `true' if the
     input was `y' or `false' if the input was `n'.  Loop until either
     `y' or `n' was entered.  If MESSAGE is non-`null' prompt with it
     before the input is read.  See also special variable
     `*USER-QUERY-ACTION*'.

 -- Function: yes-or-no? ((message STRING)) : BOOLEAN
     Read a line of input from STANDARD-INPUT and return `true' if the
     input was `yes' or `false' if the input was `no'.  Loop until
     either `yes' or `no' was entered.  If MESSAGE is non-`null' prompt
     with it before the input is read.  See also special variable
     `*USER-QUERY-ACTION*'.

 -- Function: flush-output ((self OUTPUT-STREAM)) :
     Flush all buffered output of SELF.


File: manual.info,  Node: Files,  Next: Dates and Times,  Prev: Input and Output,  Up: Library Functions

7.16 Files
==========

 -- Function: open-input-file ((fileName STRING)
          &rest (options KEYWORD)) : FILE-INPUT-STREAM
     Open file FILENAME for input and return the resulting input stream.
     By default signal an error if the file does not exist.  The only
     legal option so far is `:IF-NOT-EXISTS' (or
     `:IF-NOT-EXISTS-ACTION') which specifies what to do in case the
     file does not exist.  If its value is `:ERROR' then an error will
     be signaled.  If it is `:ABORT' or `:PROBE' the opening operation
     will be aborted and NULL will be returned.

 -- Function: open-output-file ((fileName STRING)
          &rest (options KEYWORD)) : FILE-OUTPUT-STREAM
     Open file FILENAME for output and return the resulting output
     stream.  By default the file will be created or overwritten if it
     already exists.  If `:IF-EXISTS' (or `:IF-EXISTS-ACTION') is one
     of the OPTIONS its value specifies what to do in case the file
     already exists.  If the value is `:SUPERSEDE' the pre-existing
     file will be overwritten.  If the value is `:APPEND' the
     preexisting file will be appended to (if the file did not yet
     exist the file will simply be created).  If the value is `:ERROR'
     then an error will be signaled.  If it is `:ABORT' or `:PROBE' the
     opening operation will be aborted and NULL will be returned.

     If `:IF-NOT-EXISTS' (or `:IF-NOT-EXISTS-ACTION') is one of the
     OPTIONS its value specifies what to do in case the file does not
     already exist.  If the value is `:CREATE', the file will simply be
     created.  If the value is `:ERROR' then an error will be signaled.
     If it is `:ABORT' or `:PROBE' the opening operation will be
     aborted and NULL will be returned.

 -- Function: close-stream ((self STREAM)) :
     Close the stream SELF.

 -- Function: close-all-files () :
     Close all currently open file streams.  Use for emergencies or for
     cleanup.

 -- Macro: with-input-file ((binding CONS) &body (body CONS)) : OBJECT
     Sets up an unwind-protected form which opens a file for input and
     closes it afterwards.  The stream for reading is bound to the
     variable provided in the macro form.  Syntax is `(WITH-INPUT-FILE
     (var filename options*) body+)' where `options' can be any that
     are legal for `open-input-file' (which see).

 -- Macro: with-output-file ((binding CONS) &body (body CONS)) : OBJECT
     Sets up an unwind-protected form which opens a file for output and
     closes it afterwards.  The stream for writing is bound to the
     variable provided in the macro form.  Syntax is `(WITH-OUTPUT-FILE
     (var filename options*) body+)' where `options' can be any that
     are legal for `open-output-file' (which see).

 -- Function: probe-file? ((fileName FILE-NAME)) : BOOLEAN
     Return true if file FILENAME exists.  Note that this does not
     necessarily mean that the file can also be read.

 -- Function: file-write-date ((fileName FILE-NAME)) : CALENDAR-DATE
     Return the time at which file FILENAME was last modified or NULL
     if that cannot be determined.

 -- Function: file-length ((fileName FILE-NAME)) : INTEGER
     Return the length of file FILENAME in bytes or NULL if that cannot
     be determined.  Note that this will currently overrun for files
     that are longer than what can be represented by a STELLA integer.

 -- Function: copy-file ((fromFile FILE-NAME) (toFile FILE-NAME)) :
     Copy file FROMFILE to file TOFILE, clobbering any data already in
     TOFILE.

 -- Function: delete-file ((fileName FILE-NAME)) :
     Delete the file FILENAME.

 -- Function: directory-file-name ((directory FILE-NAME)) : FILE-NAME
     Return DIRECTORY as a file name, i.e., without a terminating
     directory separator.

 -- Function: directory-parent-directory ((directory FILE-NAME)
          (level INTEGER)) : FILE-NAME
     Return the LEVEL-th parent directory component of DIRECTORY
     including the final directory separator, or the empty string if
     DIRECTORY does not have that many parents.

 -- Function: file-name-as-directory ((file FILE-NAME)) : FILE-NAME
     Return FILE interpreted as a directory, i.e., with a terminating
     directory separator.  If FILE is the empty string simply return
     the empty string, i.e., interpret it as the current directory
     instead of the root directory.

 -- Function: file-name-directory ((file FILE-NAME)) : FILE-NAME
     Return the directory component of FILE including the final
     directory separator or the empty string if FILE does not include a
     directory.  Note that for purposes of this function, a logical
     host is considered part of the directory portion of FILE

 -- Function: file-name-without-directory ((file FILE-NAME)) : FILE-NAME
     Return the file name portion of FILE by removing any directory and
     logical host components.

 -- Function: file-name-without-extension ((file FILE-NAME)) : FILE-NAME
     Remove FILEs extension (or type) if there is any and return the
     result.

 -- Function: file-extension ((file FILE-NAME)) : STRING
     Return FILEs extension (or type) if it has any including the
     separator character.

 -- Function: file-base-name ((file FILE-NAME)) : FILE-NAME
     Remove FILEs directory (including logical host) and extension
     components and return the result.

 -- Function: absolute-pathname? ((pathname STRING)) : BOOLEAN
     Not documented.

 -- Function: logical-host? ((host STRING)) : BOOLEAN
     Not documented.

 -- Function: logical-pathname? ((pathname STRING)) : BOOLEAN
     Not documented.

 -- Function: translate-logical-pathname ((pathname STRING)) : STRING
     Not documented.

 -- Function: directory-separator () : CHARACTER
     Not documented.

 -- Function: directory-separator-string () : STRING
     Not documented.


File: manual.info,  Node: Dates and Times,  Next: XML Support,  Prev: Files,  Up: Library Functions

7.17 Dates and Times
====================

 -- Function: get-current-date-time () : INTEGER INTEGER INTEGER
          KEYWORD INTEGER INTEGER INTEGER INTEGER
     Returns the current time in UTC as multiple values of year month
     day day-of-week hour minute second millisecond.  Currently
     millisecond will always be zero (even in Java where it is
     technically available).

 -- Function: get-local-time-zone () : FLOAT
     Returns the current time zone offset from UTC as a float,
     considering the effects of daylight savings time.

 -- Function: make-current-date-time () : CALENDAR-DATE
     Create a calendar date with current time and date.

 -- Function: make-date-time ((year INTEGER) (month INTEGER)
          (day INTEGER) (hour INTEGER) (minute INTEGER)
          (second INTEGER) (millis INTEGER) (timezone FLOAT)) :
          CALENDAR-DATE
     Create a calendar date with the specified components.  YEAR must be
     the complete year (i.e., a year of 98 is 98 A.D in the 1st
     century).  TIMEZONE is a real number in the range -12.0 to +14.0
     where UTC is zone 0.0;  The number is the number of hours to add
     to UTC to arrive at local time.

 -- Function: parse-date-time ((date-time-string STRING)
          (start INTEGER) (end INTEGER) (error-on-mismatch? BOOLEAN)) :
          DECODED-DATE-TIME
     Tries very hard to make sense out of the argument DATE-TIME-STRING
     and returns a time structure if successful.  If not, it returns
     `null'.  If ERROR-ON-MISMATCH? is true, parse-date-time will
     signal an error instead of returning `null'.  Default values are
     00:00:00 local time on the current date

 -- Method on CALENDAR-DATE: decode-calendar-date (date
          (timezone FLOAT)) : DECODED-DATE-TIME
     Returns a decoded time object for DATE interpreted in TIMEZONE
     TIMEZONE is the number of hours added to UTC to get local time.
     It is in the range -12.0 to +14.0 where UTC is zone 0.0

 -- Method on DECODED-DATE-TIME: encode-calendar-date (time-structure)
          : CALENDAR-DATE
     Returns a calendar date object for TIME-STRUCTURE.

 -- ???: calendar-date-to-string
     Not yet implemented.

 -- Function: string-to-calendar-date ((input STRING)) : CALENDAR-DATE
     Returns a calendar date object representing the date and time
     parsed from the INPUT string.  If no valid parse is found, `null'
     is returned.

 -- ???: relative-date-to-string
     Not yet implemented.

 -- Function: compute-calendar-date ((julian-day INTEGER)) : INTEGER
          INTEGER INTEGER KEYWORD
     Returns the YEAR, MONTH, DAY, DAY-OF-WEEK on which the given
     JULIAN-DAY begins at noon.

 -- Function: compute-day-of-week ((yyyy INTEGER) (mm INTEGER)
          (dd INTEGER)) : KEYWORD
     Returns the day of the week for yyyy-mm-dd.

 -- Function: compute-day-of-week-julian ((julian-day INTEGER)) :
          KEYWORD
     Returns the day of the week for julian-day

 -- Function: compute-julian-day ((yyyy INTEGER) (mm INTEGER)
          (dd INTEGER)) : INTEGER
     Returns the Julian day that starts at noon on yyyy-mm-dd.  YYYY is
     the year.  MM is the month.  DD is the day of month.  Negative
     years are B.C.  Remember there is no year zero.

 -- Function: compute-next-moon-phase ((n INTEGER) (phase KEYWORD)) :
          INTEGER FLOAT
     Returns the Julian Day and fraction of day of the Nth occurence
     since January 1, 1900 of moon PHASE.  PHASE is one of :NEW-MOON,
     :FIRST-QUARTER, :FULL-MOON, :LAST-QUARTER

 -- Function: decode-time-in-millis ((time INTEGER)) : INTEGER INTEGER
          INTEGER INTEGER
     Returns multiple values of hours, minutes, seconds, milliseconds
     for TIME specified in milliseconds.

 -- Function: julian-day-to-modified-julian-day ((julian-day INTEGER))
          : INTEGER
     Returns the modified Julian day during which JULIAN-DAYstarts at
     noon.

 -- Function: modified-julian-day-to-julian-day
          ((modified-julian-day INTEGER)) : INTEGER
     Returns the modified Julian day during which `julian-day'starts at
     noon.

 -- Function: time-add ((t1 DATE-TIME-OBJECT) (t2 DATE-TIME-OBJECT)) :
          DATE-TIME-OBJECT
     Add T1 to T2.  If one of T1 or T2 is a calendar date, then the
     result is a calendar date.  If both T1 and T2 are relative dates,
     then the result is a relative date.  T1 and T2 cannot both be
     calendar dates.

 -- Function: time-divide ((t1 TIME-DURATION) (t2 OBJECT)) : OBJECT
     Divides the relative date T1 by T2.  T2 must be either a relative
     date or a wrapped number.  If T2 is a relative date, then the
     return value will be a wrapped float.  If T2 is a wrapped number,
     then the reutrn value will be a relative date.

 -- Function: time-multiply ((t1 OBJECT) (t2 OBJECT)) : TIME-DURATION
     Multiplies a relative date by a wrapped number.  One of T1 or T2
     must be a relative date and the other a wrapped number.

 -- Function: time-subtract ((t1 DATE-TIME-OBJECT)
          (t2 DATE-TIME-OBJECT)) : DATE-TIME-OBJECT
     Subtract T2 from T1.  If T1 is a calendar date, then T2 can be
     either a calendar date (in which case the return value is a
     relative date) or it can be a relative date (in which case the
     return value is a calendar date).  If T1 is a relative date, then
     T2 must also be a relative date and a relative date is returned.

 -- Function: get-ticktock () : TICKTOCK
     Return the current CPU time.  If the current OS/Language
     combination does not support measuring of CPU time, return real
     time instead.  Use `ticktock-difference' to measure the time
     difference between values returned by this function.  This is an
     attempt to provide some platform independent support to measure
     (at least approximately) consumed CPU time.

 -- Function: ticktock-difference ((t1 TICKTOCK) (t2 TICKTOCK)) : FLOAT
     The difference in two TICKTOCK time values in seconds where T1 is
     the earlier time.  The resolution is implementation dependent but
     will normally be some fractional value of a second.

 -- Function: ticktock-resolution () : FLOAT
     The minimum theoretically detectable resolution of the difference
     in two TICKTOCK time values in seconds.  This resolution is
     implementation dependent.  It may also not be realizable in
     practice, since the timing grain size may be larger than this
     resolution.

 -- Function: sleep ((seconds FLOAT)) :
     The program will sleep for the indicated number of seconds.
     Fractional values are allowed, but the results are implementation
     dependent: Common Lisp uses the fractions natively, Java with a
     resolution of 0.001, and C++ can only use integral values.


File: manual.info,  Node: XML Support,  Next: Miscellaneous,  Prev: Dates and Times,  Up: Library Functions

7.18 XML Support
================

 -- Function: make-xml-element ((name STRING) (namespace-name STRING)
          (namespace STRING)) : XML-ELEMENT
     Creates and interns an XML element object NAME using NAMESPACE-NAME
     to refer to  NAMESPACE.  If NAMESPACE is `null', then the element
     will be interned in the null namespace.   NAMESPACE must otherwise
     be a URI.

 -- Function: make-xml-global-attribute ((name STRING)
          (namespace-name STRING) (namespace STRING)) :
          XML-GLOBAL-ATTRIBUTE
     Creates and interns an XML global attribute object with NAME using
     NAMESPACE-NAME to refer to  NAMESPACE.  NAMESPACEmust be a URI.

 -- Function: make-xml-local-attribute ((name STRING)
          (element XML-ELEMENT)) : XML-LOCAL-ATTRIBUTE
     Make an XML-LOCAL-ATTRIBUTE named NAME associated with ELEMENT

 -- Function: get-xml-tag ((expression CONS)) : XML-ELEMENT
     Return the XML tag object of an XML EXPRESSION.

 -- Function: get-xml-attributes ((expression CONS)) : CONS
     Return the list of attributes of an XML EXPRESSION (may be empty).

 -- Function: get-xml-content ((expression CONS)) : CONS
     Return the list of content elements of an XML EXPRESSION (may be
     empty).

 -- Function: get-xml-cdata-content ((form CONS)) : STRING
     Return the CDATA content of a CDATA FORM.  Does NOT make sure that
     FORM actually is a CDATA form, so bad things can happen if it is
     given wrong input.

 -- Function: xml-declaration? ((item OBJECT)) : BOOLEAN
     Return `true' if ITEM is an XML declaration object

 -- Function: xml-element? ((item OBJECT)) : BOOLEAN
     Return `true' if ITEM is an XML element object

 -- Function: xml-attribute? ((item OBJECT)) : BOOLEAN
     Return `true' if ITEM is an XML attribute object

 -- Function: xml-cdata? ((item OBJECT)) : BOOLEAN
     Return `true' if ITEM is an XML CDATA tag object

 -- Function: xml-cdata-form? ((form OBJECT)) : BOOLEAN
     Return `true' if FORM is a CONS headed by a CDATA tag

 -- Method on XML-ELEMENT: xml-element-match? (tag (name STRING)
          (namespace STRING)) : BOOLEAN
     Returns `true' if TAG is an XML element with the name NAME in
     namespace NAMESPACE.  Note that NAMESPACE is the full URI, not an
     abbreviation.  Also, NAMESPACE may be `null', in which case TAG
     must not have a namespace associated with it.

 -- Method on XML-ATTRIBUTE: xml-attribute-match? (attribute
          (name STRING) (namespace STRING)) : BOOLEAN
     Return `true' if ATTRIBUTE is an XML attribute with name NAME in
     namespace NAMESPACE.  Note that NAMESPACE is the full URI, not an
     abbreviation.  Also, NAMESPACE may be `null', in which case
     ATTRIBUTE must not have a namespace associated with it.

 -- Method on XML-GLOBAL-ATTRIBUTE: xml-attribute-match? (attribute
          (name STRING) (namespace STRING)) : BOOLEAN
     Return `true' if ATTRIBUTE is a global  XML attribute with name
     NAME in namespace NAMESPACE.  Note that NAMESPACE is the full URI,
     not an abbreviation.  Also, NAMESPACE may be `null', in which case
     ATTRIBUTE must not have a namespace associated with it.

 -- Method on XML-LOCAL-ATTRIBUTE: xml-attribute-match? (attribute
          (name STRING) (namespace STRING)) : BOOLEAN
     Return `true' if ATTRIBUTE is a local XML attribute with name NAME.
     Note that NAMESPACE must be `null' and that the ATTRIBUTEs parent
     element element is not considered by the match.  To take the
     parent element into account use `xml-local-attribute-match?'.

 -- Function: xml-local-attribute-match?
          ((attribute XML-LOCAL-ATTRIBUTE) (name STRING)
          (element-name STRING) (element-namespace STRING)) : BOOLEAN
     Return true if ATTRIBUTE is a local attribute with NAME and whose
     parent element matches ELEMENT-NAME and ELEMENT-NAMESPACE.

 -- Function: xml-lookup-attribute ((attributes CONS) (name STRING)
          (namespace STRING)) : STRING
     Find the XML attribute in ATTRIBUTES with NAME and NAMESPACE and
     return its value.  Note that it is assumed that all ATTRIBUTES
     come from the same known tag, hence, the parent elements of any
     local attributes are not considered by the lookup.

 -- Macro: xml-tag-case ((item OBJECT) &body (clauses CONS)) : OBJECT
     A case form for matching ITEM against XML element tags.  Each
     element of CLAUSES should be a clause with the form   ("tagname"
     ...)     or   (("tagname" "namespace-uri") ...)  The clause heads
     can optionally be symbols instead of strings.  The key forms the
     parameters to the method `xml-element-match?', with a missing
     namespace argument passed as NULL.

     The namespace argument will be evaluated, so one can use bound
     variables in place of a fixed string.   As a special case, if the
     namespace argument is :ANY, then the test will be done for a match
     on the tag name alone.

 -- Function: read-xml-expression ((stream INPUT-STREAM)
          (start-tag OBJECT)) : OBJECT BOOLEAN
     Read one balanced XML expression from STREAM and return its
     s-expression representation (see
     `xml-token-list-to-s-expression').  If `startTagName' is
     non-`null', skip all tags until a start tag matching START-TAG is
     encountered.  XML namespaces are ignored for outside of the start
     tag.  Use s-expression representation to specify START-TAG, e.g.,
     `(KIF (:version "1.0"))'.  The tag can be an XML element object, a
     symbol, a string or a cons.  If the tag is a cons the first
     element can also be (name namespace) pair.

     Return `true' as the second value on EOF.

     CHANGE WARNING:  It is anticipated that this function will change
     to  a) Properly take XML namespaces into account and  b) require
     XML element objects instead of strings as the second argument.
     This change will not be backwards-compatible.

 -- Function: xml-expressions ((stream INPUT-STREAM)
          (regionTag OBJECT)) : XML-EXPRESSION-ITERATOR
     Return an XML-expression-iterator (which see) reading from STREAM.
     REGIONTAG can be used to define delimited regions from which
     expressions should be considered. Use s-expression representation
     to specify REGIONTAG, e.g., `(KIF (:version "1.0"))'.  The tag can
     be an XML element object, a symbol, a string or a cons.  If the
     tag is a cons the first element can also be (name namespace) pair.

 -- Function: print-xml-expression ((stream OUTPUT-STREAM)
          (xml-expression CONS) (indent INTEGER)) :
     Prints XML-EXPRESSION on STREAM.  Indentation begins with the
     value of INDENT.  If this is the `null' integer, no indentation is
     performed.  Otherwise it should normally be specified as 0 (zero)
     for top-level calls.

     It is assumed that the XML-EXPRESSION is a well-formed CONS-list
     representation of an XML  form.  It expects a form like that form
     returned by `read-XML-expression'.

     Also handles a list of xml forms such as that returned by
     `XML-expressions'.  In that case, each of the forms is indented by
     INDENT spaces.

 -- Function: reset-xml-hash-tables () :
     Resets Hashtables used for interning XML elements and global
     attribute objects.  This will allow garbage collection of
     no-longer used objects, but will also mean that newly parsed xml
     elements and global attributes will not be eq? to already existing
     ones with the same name.


File: manual.info,  Node: Miscellaneous,  Prev: XML Support,  Up: Library Functions

7.19 Miscellaneous
==================

This is a catch-all section for functions and methods that haven't been
categorized yet into any of the previous sections.  They are in random
order and many of them will never be part of the official STELLA
interface.  So beware!

 -- Function: operating-system () : KEYWORD
     Not documented.

 -- Function: activate-demon ((demon DEMON)) :
     Install DEMON in the location(s) specified by its internal
     structure.

 -- Method on POLYMORPHIC-RELATION: active? (self) : BOOLEAN
     True if SELF or a superslot of SELF is marked active.

 -- Function: add-configuration-property ((property STRING)
          (value OBJECT) (configuration CONFIGURATION-TABLE)) : OBJECT
     Add VALUE to PROPERTY in CONFIGURATION and return it.  If a
     previous value exists add VALUE to the end (listify the old value
     if it is not yet a list).  Otherwise, create a new list containing
     VALUE.  Use the global system configuration table if CONFIGURATION
     is NULL.

 -- Function: add-hook ((hookList HOOK-LIST) (hookFunction SYMBOL)) :
     Insert the function named HOOKFUNCTION into HOOKLIST.

 -- N-Command: add-trace (&rest (keywords GENERALIZED-SYMBOL)) : LIST
     Enable trace messages identified by any of the listed KEYWORDS.
     After calling (`add-trace' <keyword>) code guarded by (`trace-if'
     <keyword> ...)  will be executed when it is encountered.

 -- Function: advance-past-whitespace ((source STRING) (start INTEGER))
          : INTEGER
     Returns the first index into SOURCE, starting from START, of the
     first character that is not white space.

 -- Function: all-classes ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF CLASS)
     Iterate over all classes visible from MODULE.  If LOCAL?, return
     only classes interned in MODULE.  If MODULE is null, return all
     classes interned everywhere.

 -- Function: all-contexts () : (ITERATOR OF CONTEXT)
     Return an iterator that generates all contexts.

 -- Macro: all-defined? (&body (forms CONS)) : OBJECT
     Evaluate each of the forms in FORMS, and return TRUE if none of
     them are NULL.

 -- Function: all-functions ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF FUNCTION)
     Iterate over all functions visible from MODULE.  If LOCAL?, return
     only functions bound to symbols interned in MODULE.  If MODULE is
     null, return all functions defined everywhere.

 -- Function: all-included-modules ((self MODULE)) : (ITERATOR OF
          MODULE)
     Generate a sequence of all modules included by SELF, inclusive,
     starting from the highest ancestor and working down to SELF (which
     is last).

 -- Function: all-methods ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF METHOD-SLOT)
     Iterate over all methods visible from MODULE.  If LOCAL?, return
     only methods interned in MODULE.  If MODULE is null, return all
     methods interned everywhere.

 -- Function: all-modules () : (ITERATOR OF MODULE)
     Return an iterator that generates all modules.

 -- Function: all-public-functions ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF FUNCTION)
     Iterate over all functions visible from MODULE.  If LOCAL?, return
     only functions bound to symbols interned in MODULE.  If MODULE is
     null, return all functions defined everywhere.

 -- Function: all-public-methods ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF METHOD-SLOT)
     Iterate over all public methods visible from MODULE.  If LOCAL?,
     return only methods interned in MODULE.  If MODULE is null, return
     all methods interned everywhere.

 -- Function: all-required-systems ((system-name STRING)) : (CONS OF
          STRING-WRAPPER)
     Returns a CONS of all of the systems required by SYSTEM-NAME

 -- Function: all-slots ((module MODULE) (local? BOOLEAN)) : (ITERATOR
          OF SLOT)
     Iterate over all slots visible from MODULE.  If LOCAL?, return
     only methods interned in MODULE.  If MODULE is null, return all
     methods interned everywhere.

 -- Function: all-subcontexts ((context CONTEXT) (traversal KEYWORD)) :
          (ALL-PURPOSE-ITERATOR OF CONTEXT)
     Return an iterator that generates all subcontexts of `self' (not
     including `self') in the order specified by TRAVERSAL (one of
     :preorder, :inorder, :postorder or :topdown).

 -- Function: all-surrogates ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF SURROGATE)
     Iterate over all surrogates visible from MODULE.  If LOCAL?,
     return only surrogates interned in MODULE.  If MODULE is null,
     return all surrogates interned everywhere.

 -- Function: all-symbols ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF SYMBOL)
     Iterate over all symbols visible from MODULE.  If LOCAL?, return
     only symbols interned in MODULE.  If MODULE is null, return all
     symbols interned everywhere.

 -- Function: all-variables ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF GLOBAL-VARIABLE)
     Iterate over all variables visible from MODULE.  If LOCAL?, return
     only variables bound to symbols interned in MODULE.  If MODULE is
     null, return all variables defined everywhere.

 -- Method on ABSTRACT-ITERATOR: allocate-iterator (self) : (LIKE SELF)
     Iterator objects return themselves when asked for an iterator
     (they occupy the same position as a collection within a `foreach'
     statement).

 -- Method on MEMOIZABLE-ITERATOR: allocate-iterator (self) : (ITERATOR
          OF (LIKE (ANY-VALUE SELF)))
     Alias for `clone-memoized-iterator'.

 -- Method on STORAGE-SLOT: allocation (self) : KEYWORD
     Return the most specific :allocation facet, or :instance if all
     inherited values are NULL.

 -- Function: apply ((code FUNCTION-CODE) (arguments (CONS OF OBJECT)))
          : OBJECT
     Apply CODE to ARGUMENTS, returning a value of type OBJECT.

 -- Function: apply-boolean-method ((code METHOD-CODE)
          (arguments (CONS OF OBJECT))) : BOOLEAN
     Apply CODE to ARGUMENTS, returning a value of type BOOLEAN.

 -- Function: apply-float-method ((code METHOD-CODE)
          (arguments (CONS OF OBJECT))) : FLOAT
     Apply CODE to ARGUMENTS, returning a value of type FLOAT.

 -- Function: apply-integer-method ((code METHOD-CODE)
          (arguments (CONS OF OBJECT))) : INTEGER
     Apply CODE to ARGUMENTS, returning a value of type INTEGER.

 -- Function: apply-method ((code METHOD-CODE)
          (arguments (CONS OF OBJECT))) : OBJECT
     Apply CODE to ARGUMENTS, returning a value of type OBJECT.

 -- Function: apply-string-method ((code METHOD-CODE)
          (arguments (CONS OF OBJECT))) : STRING
     Apply CODE to ARGUMENTS, returning a value of type STRING.

 -- Function: base60-to-float ((l (CONS OF NUMBER-WRAPPER))) : FLOAT
     Converts (x y z) into a float.  The return value is x + y/60 +
     z/3600.  This can be used to convert from Degree-Minute-Second to
     decimal degrees or from Hour-Minute-Second format to decimal hours.

 -- Function: break-program ((message STRING)) :
     Interrupt the program and print MESSAGE.  Continue after
     confirmation with the user.

 -- Function: byte-array-read-sequence ((buffer TOKENIZER-BYTE-ARRAY)
          (stream INPUT-STREAM) (start INTEGER) (end INTEGER)) : INTEGER
     Read from STREAM filling BUFFER between START and END (depending
     on how many characters are available).  Return the actual end
     pointer to the input read into BUFFER.  EOF is indicated by the
     return value being equal to start.

 -- Function: byte-array-write-sequence ((buffer TOKENIZER-BYTE-ARRAY)
          (stream NATIVE-OUTPUT-STREAM) (start INTEGER) (end INTEGER)) :
     Write from BUFFER to STREAM, using data in the buffer starting at
     position START stopping just before END.

 -- Method on CALENDAR-DATE: calendar-date-to-date-string (date
          (timezone FLOAT) (numeric-month? BOOLEAN)) : STRING
     Returns the date part of the string representation of DATE
     adjusted for TIMEZONE.  Format is YYYY-MMM-DD, where MMM is a
     three letter English abbreviation of the month if NUMERIC-MONTH?
     is `false' and a two digit numeric value if NUMERIC-MONTH? is
     `true'.  The value `false' is recommended.

 -- Method on CALENDAR-DATE: calendar-date-to-iso8601-string (date
          (timezone FLOAT) (include-timezone? BOOLEAN)) : STRING
     Returns an ISO-8601 string representation of DATE adjusted for
     TIMEZONE.  The Format is YYYY-MM-DDThh:mm:ss z:zz.  The timezone
     as an offset hh:mm is included if INCLUDE-TIMEZONE? is `true'.

     Recommended values for the flag is `true'.

 -- Method on CALENDAR-DATE: calendar-date-to-string (date
          (timezone FLOAT) (numeric-month? BOOLEAN)
          (include-timezone? BOOLEAN)) : STRING
     Returns a string representation of DATE adjusted for TIMEZONE.
     The Format is YYYY-MMM-DD hh:mm:ss z.z, where MMM is a three letter
     English abbreviation of the month if NUMERIC-MONTH? is `false' and
     a two digit numeric value if NUMERIC-MONTH? is `true'.  The
     timezone as a float offset z.z is included if INCLUDE-TIMEZONE? is
     `true'.

     Recommended values for the flags are `false' and `true'
     respectively.

 -- Method on CALENDAR-DATE: calendar-date-to-time-string (date
          (timezone FLOAT) (include-timezone? BOOLEAN)
          (include-millis? BOOLEAN) (pad-hours? BOOLEAN)) : STRING
     Returns the time part of the string representation of DATE
     adjusted for TIMEZONE.  The timezone is included in the string if
     INCLUDE-TIMEZONE? is `true'.  The value `true' is recommended.
     Milliseconds will be included if INCLUDE-MILLIS? is `true'.  Hours
     will be zero-padded to length 2 if PAD-HOURS? is `true'.


 -- Command: call-clear-module (&rest (name NAME)) :
     Destroy all objects belonging to module NAME or any of its
     children.  If no NAME is supplied, the current module will be
     cleared after confirming with the user.  Important modules such as
     STELLA are protected against accidental clearing.

 -- Function: cast ((value OBJECT) (type TYPE)) : OBJECT
     Perform a run-time type check, and then return VALUE.

 -- N-Command: ccc (&rest (name NAME)) : CONTEXT
     Change the current context to the one named NAME.  Return the
     value of the new current context.  If no NAME is supplied, return
     the pre-existing value of the current context.  `cc' is a no-op if
     the context reference cannot be successfully evaluated.  In
     CommonLisp, if the new context is case sensitive, then change the
     readtable case to :INVERT, otherwise to :UPCASE.

 -- Function: cl-slot-value ((object OBJECT) (slotName STRING)
          (dontConvert? BOOLEAN)) : LISP-CODE
     Lookup slot SLOTNAME on OBJECT and return the lispified slot value
     (see `lispify').  If DONTCONVERT? is TRUE, the returned slot value
     will not be lispified.  Generate a warning if no such slot exists
     on OBJECT.  In a call directly from Lisp SLOTNAME can also be
     supplied as a Lisp symbol.

 -- Function: cl-slot-value-setter ((object OBJECT) (slotName STRING)
          (value LISP-CODE) (dontConvert? BOOLEAN)) : LISP-CODE
     Lookup slot SLOTNAME on OBJECT and set its value to the stellafied
     VALUE (see `stellafy').  If DONTCONVERT? is TRUE, VALUE will not
     be stellafied before it gets assigned.  Generate a warning if no
     such slot exists on OBJECT, or if VALUE has the wrong type.  In a
     call directly from Lisp SLOTNAME can also be supplied as a Lisp
     symbol.

 -- Function: cl-translate-file ((file FILE-NAME) (relative? BOOLEAN)) :
     Translate a Stella FILE to Common-Lisp.  If RELATIVE?, concatenate
     root directory to FILE.

 -- Function: cl-translate-system ((system-name STRING)) :
     Translate a Stella system named SYSTEM-NAME to Common Lisp.

 -- Function: cleanup-unfinalized-classes () :
     Remove all finalized classes from `*UNFINALIZED-CLASSES*', and set
     `*NEWLY-UNFINALIZED-CLASSES?*' to `false'.

 -- Function: clear-configuration-property ((property STRING)
          (configuration CONFIGURATION-TABLE)) : OBJECT
     Remove PROPERTY in CONFIGURATION and return the previous value.
     Use the global system configuration table if CONFIGURATION is NULL.

 -- Function: clear-recycle-list ((list RECYCLE-LIST)) :
     Reset LIST to its empty state.

 -- Function: clear-recycle-lists () :
     Reset all currently active recycle lists to their empty state.

 -- Function: clear-system ((name STRING)) :
     Clears out the system definition named NAME.  If NAME is `null',
     then clear out all system definitions.  This function is useful
     when changes have been made to the system definition, and one
     wants to have it reloaded from the standard location in the file
     system.

 -- Command: clear-trace () :
     Disable all tracing previously enabled with `add-trace'.

 -- Function: clone-memoized-iterator ((self MEMOIZABLE-ITERATOR)) :
          (ITERATOR OF (LIKE (ANY-VALUE SELF)))
     Clone the memoized iterator SELF so it can be used to iterate over
     the collection represented by SELF, while allowing to iterate over
     it multiple times via multiple clones.

 -- Macro: coerce-&rest-to-cons ((restVariable SYMBOL)) : OBJECT
     Coerce the argument list variable RESTVARIABLE into a CONS list
     containing all its elements (uses argument list iteration to do
     so).  If RESTVARIABLE already is a CONS due to argument
     listification, this is a no-op.

 -- Function: coerce-to-symbol ((name NAME)) : GENERALIZED-SYMBOL
     Return the (generalized) symbol represented by NAME.  Return
     `null' if NAME is undefined or does not represent a string.

 -- Macro: collect (&body (body CONS)) : OBJECT
     Use a VRLET to collect values.  Input can have one of the
     following forms:

            (collect <var> in <expression> [where <test> <var>])
            (collect <collect-expression>
                     foreach <var> in <expression>
                     {as ...}*
                     [where <test> <var>]
                     [do ...])

     The second form really accepts an arbitrary `foreach' expression
     following the `foreach' keyword.

 -- Method on SLOT: collection-valued? (self) : BOOLEAN
     True if slot values are collections.

 -- Function: command? ((method METHOD-SLOT)) : BOOLEAN
     Return `true' if METHOD is an evaluable command.

 -- Method on STORAGE-SLOT: component? (self) : BOOLEAN
     True if fillers of this slot are components of the owner slot, and
     therefore should be deleted if the owner is deleted.

 -- Function: compose-namestring
          ((name-components (CONS OF STRING-WRAPPER))
          &rest (options OBJECT)) : STRING
     NAME-COMPONENTS is a cons to be processed into a namestring.
     `:prefix' and `:suffix' are strings that will NOT be
     case-converted.  `:case' is one of :UPCASE :TitleCase :titleCaseX
     :downcase :Capitalize         default is :TitleCase `:separator'
     is a string that should separate word elements.  It does not
     separate the prefix or suffix.  Default is ""
     `:translation-table' should be a STRING-HASH-TABLE hash table that
     strings into their        desired printed representation as a
     string.  In general the argument        will be strings, but that
     is not strictly necessary.


 -- Function: compose-namestring-full
          ((strings (CONS OF STRING-WRAPPER)) (prefix STRING)
          (suffix STRING) (outputcase KEYWORD) (outputseparator STRING)
          (translationtable STRING-HASH-TABLE)
          (useacronymheuristics? BOOLEAN)) : STRING
     Non-keyword version of `compose-namestring', which will probably be
     easier to use when called from non-Lisp languages.

 -- Function: compute-module-and-bare-name ((name STRING)) : MODULE
          STRING
     Compute the module indicated by the STELLA name NAME and return
     it.  Return the bare symbol name as the second value.  NAME does
     not necessarily have to be qualified in which case the current
     module is returned.  NAME is assumed to be the printed
     representation of a STELLA symbol, surrogate or keyword.

 -- Function: configure-stella ((file FILE-NAME)) :
     Perform STELLA run-time configuration.  If supplied, load the
     configuration file FILE first which should be supplied with a
     physical pathname.

 -- Method on OBJECT: consify (self) : CONS
     If `object' is a CONS, return it.  Otherwise, return a singleton
     cons list containing it.

 -- Function: consify-command-line-arguments ((count INTEGER)
          (arguments (ARRAY () OF STRING))) : (CONS OF STRING-WRAPPER)
     Convert COUNT command line ARGUMENTS into a CONS list.

 -- Macro: continuable-error (&body (body CONS)) : OBJECT
     Signal error message, placing non-string arguments in quotes.

 -- Function: cpp-translate-system ((systemName STRING)) :
     Translate the system SYSTEMNAME to C++.

 -- N-Command: cpptrans ((statement OBJECT)) :
     Translate STATEMENT to C++ and print the result.

 -- Function: create-derived-list ((self LIST)) : LIST
     Create a new list object with the same type as SELF.

 -- Function: create-object ((type TYPE)
          &rest (initial-value-pairs OBJECT)) : OBJECT
     Funcallable version of the `new' operator.  Return an instance of
     the class named by TYPE.  If INITIAL-VALUE-PAIRS is supplied, it
     has to be a key/value list similar to what's accepted by `new' and
     the named slots will be initialized with the supplied values.
     Similar to `new', all required arguments for TYPE must be
     included.  Since all the slot initialization, etc. is handled
     dynamically at run time, `create-object' is much slower than
     `new'; therefore, it should only be used if TYPE cannot be known
     at translation time.

 -- Function: deactivate-demon ((demon DEMON)) :
     Detach DEMON from the location(s) specified by its internal
     structure.

 -- Method on DECODED-DATE-TIME: decoded-date-time-to-iso8601-string
          (date) : STRING
     Returns an ISO-8601 string representation of DATE The Format is
     YYYY-MM-DDThh:mm:ss+zz:zz, with the string stopping at when a null
     value is first encountered.  The time zone will only be included
     (if present) if a time value is given.

 -- Function: decompose-namestring ((namestring STRING)
          &rest (options OBJECT)) : (CONS OF STRING-WRAPPER)
     Keyword options:   :break-on-cap    one of  :YES :NO :CLEVER
      default is :CLEVER   :break-on-number one of  :YES :NO :CLEVER
          default is :CLEVER   :break-on-separators string
              default is "-_ "

     DECOMPOSE-NAMESTRING returns a cons of STRING-WRAPPERS that are
     the decomposition of the input STRING.  The arguments are used as
     follows:   NAMESTRING       is the input string.    :break-on-cap
      is a keyword controlling whether changes in capitalization is
     used                    to indicate word boundaries.  If :YES,
     then all capitalization                    changes delineate
     words.  If :CLEVER, then unbroken runs of
     capitalized letters are treated as acronyms and remain grouped.
                     If :NO or NULL, there is no breaking of words
     based on capitalization.    :break-on-number is a flag controlling
     whether encountering a number indicates                    a word
     boundary.  If :YES, then each run of numbers is treated as 		   a
     word separate from surrounding words.  If :CLEVER, then an
     attempt is made to recognize ordinal numbers (ie, 101st) and
     treat them as separate words.  If :NO or NULL, there is no breaking
                       of words when numbers are encountered.
     :break-on-separators   A string of characters which constitute
     word delimiters in                          the input word.  This
     is used to determine how to break                    the name into
     individual words.  Defaults are space, `-' and `_'.

 -- Function: decompose-namestring-full ((namestring STRING)
          (break-on-cap KEYWORD) (break-on-number KEYWORD)
          (break-on-separators STRING)) : (CONS OF STRING-WRAPPER)
     Non-keyword version of `decompose-namestring', which will probably
     be easier to use when called from non-Lisp languages.

 -- Method on STORAGE-SLOT: default-form (self) : OBJECT
     Returns the current value of default expression when the slot has
     not been assigned a value.

 -- Macro: defdemon ((name STRING-WRAPPER) (parameterstree CONS)
          &body (optionsandbody CONS)) : OBJECT
     Define a demon NAME and attach it to a class or slot.

 -- Function: define-demon ((name STRING) &rest (options OBJECT)) :
          DEMON
     Define a class or slot demon.  Options are :create, :destroy,
     :class, :slot, :guard?, :code, :method, :inherit?, and
     :documentation.

 -- Function: define-logical-host-property ((host STRING)
          (property KEYWORD) (value OBJECT)) :
     Define PROPERTY with VALUE for the logical host HOST.  As a
     side-effect, this also defines HOST as a logical host (both
     PROPERTY and VALUE can be supplied as NULL).  If :ROOT-DIRECTORY
     is specified, all pathnames with HOST are assumed to be relative to
     that directory (even if they are absolute) and will be rerooted
     upon translation.  :ROOT-DIRECTORY can be a logical or physical
     pathname.  If :LISP-TRANSLATIONS is specified, those will be used
     verbatimely as the value of `(CL:logical-pathname-translations
     host)' if we are running in Lisp, which allows us to depend on the
     native `CL:translate-logical-pathname' for more complex
     translation operations.

 -- Function: define-module ((name STRING) (options CONS)) : MODULE
     Define or redefine a module named NAME having the options OPTIONS.
     Return the new module.

 -- Function: define-stella-class ((name TYPE) (supers (LIST OF TYPE))
          (slots (LIST OF SLOT)) (options KEYWORD-KEY-VALUE-LIST)) :
          CLASS
     Return a Stella class with name NAME.  Caution:  If the class
     already exists, the Stella class object gets redefined, but the
     native C++ class is not redefined.

 -- Function: define-stella-method-slot ((inputname SYMBOL)
          (returntypes CONS) (function? BOOLEAN) (inputParameters CONS)
          (options KEYWORD-KEY-VALUE-LIST)) : METHOD-SLOT
     Define a new Stella method object (a slot), and attach it to the
     class identified by the first parameter in INPUTPARAMETERS.

 -- Method on ARRAY: defined? (x) : BOOLEAN
     Return true if X is defined (handled specially by all translators).

 -- Macro: defmain ((varList CONS) &body (body CONS)) : OBJECT
     Defines a function called MAIN which will have the appropriate
     signature for the target translation language.  The signature will
     be:   C++:   public static int main (int v1, char** v2) {<body>}
     Java:  public static void main (String [] v2) {<body>}   Lisp:
     (defun main (&rest args) <body>) The argument VARLIST must have
     two symbols, which will be the names for the INTEGER argument
     count and an array of STRINGs with the argument values.  It can
     also be empty to indicate that no command line arguments will be
     handled.  The startup function for the containing system will
     automatically be called before BODY is executed unless the option
     :STARTUP-SYSTEM? was supplied as FALSE.  There can only be one
     DEFMAIN per module.

 -- N-Command: defsystem ((name SYMBOL) &rest (options OBJECT)) :
          SYSTEM-DEFINITION
     Define a system of files that collectively define a Stella
     application.     Required options are:    :directory - the
     relative path from the respective source/native/binary root
     directory                  to the directory containing the system
     files.  Can be a string or a list                  of strings (do
     not include directory separators).     :files - a list of files in
     the system, containing strings and lists              of strings;
     the latter defines exploded paths to files              in
     subdirectories.     Optional options are:    :required-systems - a
     list of systems (strings) that should be loaded
         prior to loading this system.     :cardinal-module - the name
     (a string) of the principal module for this
     system.     :copyright-header - string with a header for inclusion
     into all translated                         files produced by
     Stella.     :lisp-only-files  - Like the :files keyword, but these
     are only included    :cpp-only-files      in the translation for
     the specific language, namely    :java-only-files     Common Lisp,
     C++ or Java

 -- Method on OBJECT: deleted? (self) : BOOLEAN
     Default `deleted?' method which always returns FALSE.  Objects
     that inherit DYNAMIC-SLOTS-MIXIN also inherit the
     dynamically-allocated slot `deleted-object?' which is
     read/writable with specializations of this method.

 -- N-Command: describe ((name OBJECT) &rest (mode OBJECT)) :
     Print a description of an object in :verbose, :terse, or :source
     modes.

 -- Method on OBJECT: describe-object (self (stream OUTPUT-STREAM)
          (mode KEYWORD)) :
     Prints a description of SELF to stream STREAM.  MODE can be
     :terse, :verbose, or :source.  The :terse mode is often equivalent
     to the standard print function.

 -- Method on CLASS: destroy-class (self) :
     Destroy the Stella class SELF.  Unfinalize its subclasses (if it
     has any).

 -- Function: destroy-class-and-subclasses ((self CLASS)) :
     Destroy the Stella class SELF and all its subclasses.

 -- Function: destructure-defmethod-tree ((method-tree CONS)
          (options-table KEY-VALUE-LIST)) : OBJECT CONS CONS
     Return three parse trees representing the name, parameters, and
     code body of the parse tree METHOD-TREE.  Fill OPTIONS-TABLE with
     a dictionary of method options.  Storage note:  Options are
     treated specially because the other return values are subtrees of
     METHOD-TREE, while OPTIONS-TABLE is a newly-created cons tree.
     Note also, the parameter and body trees are destructively removed
     from METHOD-TREE.

 -- Function: dictionary ((collectionType TYPE)
          &rest (alternatingkeysandvalues OBJECT)) :
          (ABSTRACT-DICTIONARY OF OBJECT OBJECT)
     Return a dictionary of COLLECTIONTYPE containing `values', in
     order.  Currently supported COLLECTIONTYPEs are @HASH-TABLE,
     @STELLA-HASH-TABLE, @KEY-VALUE-LIST, @KEY-VALUE-MAP and
     @PROPERTY-LIST.

 -- Method on CLASS: direct-super-classes (self) : (ITERATOR OF CLASS)
     Returns an iterator that generates all direct super classes of
     SELF.

 -- Command: disable-memoization () :
     Enable memoization and use of memoized expression results.

 -- Function: disabled-stella-feature? ((feature KEYWORD)) : BOOLEAN
     Return true if the STELLA FEATURE is currently disabled.

 -- Function: drop-hook ((hookList HOOK-LIST) (hookFunction SYMBOL)) :
     Remove the function named HOOKFUNCTION from HOOKLIST.

 -- N-Command: drop-trace (&rest (keywords GENERALIZED-SYMBOL)) : LIST
     Disable trace messages identified by any of the listed KEYWORDS.
     After calling (`drop-trace' <keyword>) code guarded by (`trace-if'
     <keyword> ...)  will not be executed when it is encountered.

 -- Macro: either ((value1 OBJECT) (value2 OBJECT)) : OBJECT
     If VALUE1 is defined, return that, else return VALUE2.

 -- Method on STRING-WRAPPER: empty? (x) : BOOLEAN
     Return true if X is the wrapped empty string ""

 -- Command: enable-memoization () :
     Enable memoization and use of memoized expression results.

 -- Function: enabled-stella-feature? ((feature KEYWORD)) : BOOLEAN
     Return true if the STELLA FEATURE is currently enabled.

 -- Function: ensure-file-does-not-exist ((filename STRING)
          (context STRING)) :
     Ensures that FILENAME does not exist.  If it does, an exception of
     type `FILE-ALREADY-EXISTS-EXCEPTION' is thrown with CONTEXT
     supplying context for the error message.

 -- Function: ensure-file-exists ((filename STRING) (context STRING)) :
     Ensures that FILENAME exists.  If not, an exception of type
     `NO-SUCH-FILE-EXCEPTION' is thrown with CONTEXT supplying context
     for the error message.

 -- Function: eql-except-in-whitespace? ((s1 STRING) (s2 STRING)) :
          BOOLEAN
     Return `true' if the strings S1 and S2 are the same except for the
     amounts of whitespace separating words.  Leading or trailing
     whitespace is also not considered.

 -- Macro: error (&body (body CONS)) : OBJECT
     Signal error message, placing non-string arguments in quotes.

 -- Function: evaluate ((expression OBJECT)) : OBJECT
     Evaluate the expression EXPRESSION and return the result.
     Currently, only the evaluation of (possibly nested) commands and
     global variables is supported.  The second return value indicates
     the actual type of the result (which might have been wrapped), and
     the third return value indicates whether an error occurred during
     the evaluation.  Expressions are simple to program in Common Lisp,
     since they are built into the language, and relatively awkward in
     Java and C++.  Users of either of those languages are more likely
     to want to call `evaluate-string'.

 -- Function: evaluate-string ((expression STRING)) : OBJECT
     Evaluate the expression represented by EXPRESSION and return the
     result.  This is equivalent to `(evaluate (unstringify
     expression))'.

 -- Function: exception-message ((e NATIVE-EXCEPTION)) : STRING
     Accesses the error message of the exception E.

 -- Method on CLASS: extension (self) : CLASS-EXTENSION
     Return the nearest class extension that records instances of the
     class SELF.

 -- Function: external-id-head? ((attribute OBJECT)) : BOOLEAN
     Checks to see if this ATTRIBUTE is the literal marking either a
     PUBLIC or SYSTEM literal for an XML Elternal ID.  (See 4.2.2)

 -- Function: fill-in-date-substitution
          ((substitution-list (KEY-VALUE-LIST OF STRING-WRAPPER STRING-WRAPPER)))
          :
     Fill in SUBSTITUTION-LIST with template variable substitions for
     the names YEAR and DATE which correspond to the current year and
     date.  These substitutions can then be used with
     `substitute-template-variables-in-string'

 -- Function: finalize-classes () :
     Finalize all currently unfinalized classes.

 -- Function: finalize-classes-and-slots () :
     Finalize all currently unfinalized classes and slots.

 -- Function: finalize-slots () :
     Finalize all currently unfinalized slots.

 -- Function: find-matching-prefix-length ((string1 STRING)
          (start1 INTEGER) (end1 INTEGER) (string2 STRING)
          (start2 INTEGER) (end2 INTEGER)) : INTEGER
     Finds the length of the matching prefix strings of STRING1 and
     STRING2, starting at position START1 and START2 respectively.  The
     search will end when END1 or END2 is reached.  If either END1 or
     END2 is null, then they will be set to the length of their
     respective strings.

 -- Function: find-mismatch ((string1 STRING) (start1 INTEGER)
          (end1 INTEGER) (string2 STRING) (start2 INTEGER)
          (end2 INTEGER)) : INTEGER INTEGER
     Finds the first position in each of STRING1 and STRING2 where they
     mismatch, starting at position START1 and START2 respectively.
     The search will end when END1 or END2 is reached.  If either END1
     or END2 is null, then they will be set to the length of their
     respective strings.  If there is no mismatch, then `null' values
     are returned.

 -- Macro: first-defined (&body (forms CONS)) : OBJECT
     Return the result of the first form in FORMS whose value is defined
     or NULL otherwise.

 -- Function: float-to-base60 ((x FLOAT) (all-integers? BOOLEAN)) :
          (CONS OF NUMBER-WRAPPER)
     Returns a cons of X in a base-60 form.  That means the first value
     will be the integer part of X, the next value the iteger value of
     the fraction part of X times 60 and the third value the fraction
     part of X time 3600.  If ALL-INTEGERS?  is `true', then the last
     value will be rounded to an integer.  This can be used to convert
     from decimal degree values to Degree-Minute-Second or from decimal
     hours to Hour-Minute-Second format.

 -- Function: fmod ((x FLOAT) (modulus FLOAT)) : FLOAT
     True modulus for floats.  Return the result of X mod `modulo'.
     Note: In C++ and Java, `mod' has more overhead than the similar
     function `rem'.  The  answers returned by `mod' and `rem' are only
     different when the signs of X and `modulo' are different.

 -- Function: format-with-padding ((input STRING) (length INTEGER)
          (padchar CHARACTER) (align KEYWORD) (truncate? BOOLEAN)) :
          STRING
     Formats INPUT to be (at least) LENGTH long, using PADCHAR to fill
     if necessary.  ALIGN must be one of :LEFT, :RIGHT, :CENTER and
     will control how INPUT will be justified in the resulting string.
     If TRUNCATE? is true, then then an overlength string will be
     truncated, using the opposite of ALIGN to pick the truncation
     direction.

 -- Method on ACTIVE-OBJECT: free (self) :
     Remove all pointers between SELF and other objects, and then
     deallocate the storage for self.

 -- Method on OBJECT: free (self) :
     Default method.  Deallocate storage for SELF.

 -- Method on ABSTRACT-HASH-TABLE: free-hash-table-values (self) :
     Call free on each value in the hash table SELF.

 -- Function: frem ((x FLOAT) (y FLOAT)) : FLOAT
     Return the floating point remainder from dividing X by Y.  The
     sign of the result is always the same as the sign of X.  This has
     slightly different behavior than the `mod' function, and has less
     overhead in C++ and Java, which don't have direct support for a
     true modulus function.

 -- Function: generate-random-uuid () : STRING
     Generates a random UUID (Type 4), according to the guidelines of
     IETF RFC 4122 (see http://www.ietf.org/rfc/rfc4122.txt )

     Take 16 random bytes (octets), put them all behind each other, for
     the description the numbering starts with byte 1 (most
     significant, first) to byte 16    (least significant, last). Then
     put in the version and variant.  To put in the version, take the
     7th byte and perform an and operation using 0x0f,    followed by
     an or operation with 0x40.  To put in the variant, take the 9th
     byte and perform an and operation using 0x3f,    followed by an or
     operation with 0x80.  To make the string representation, take the
     hexadecimal presentation of bytes 1-4    (without 0x in front of
     it) let them follow by a -, then take bytes 5 and 6, - bytes 7 and
     8, - bytes 9 and 10, - then followed by bytes 11-16.

 -- Function: generate-uuid ((uuid-type KEYWORD)) : STRING
     Generates a UUID of the specified type.  Legal types are a subset
     of the IETF RFC 4122 (see http://www.ietf.org/rfc/rfc4122.txt )
     UUID types.  Currently supported are:     :TYPE-4  :RANDOM       A
     type-4 (random) UUID.  These are synonyms.

 -- Method on CALENDAR-DATE: get-calendar-date (date (timezone FLOAT))
          : INTEGER INTEGER INTEGER KEYWORD
     Returns multiple values of year, month, day and day of week for
     DATE in TIMEZONE.  TIMEZONE is the number of hours added to UTC to
     get local time.  It is in the range -12.0 to +14.0 where UTC is
     zone 0.0

 -- Function: get-global-value ((self SURROGATE)) : OBJECT
     Return the (possibly-wrapped) value of the global variable for the
     surrogate SELF.

 -- Function: get-local-standard-time-zone () : FLOAT
     Returns the standard time zone offset from UTC as a float, without
     considering the effects of daylight savings time.

 -- Function: get-local-time-zone-for-date ((year INTEGER)
          (month INTEGER) (day INTEGER) (hour INTEGER) (minute INTEGER)
          (second INTEGER)) : FLOAT
     Returns the time zone offset from UTC (as a float) that is
     applicable to the given date.  Assumes that the date is one that
     is valid for the underlying programming language.  If not, then
     returns 0.0

 -- Function: get-quoted-tree ((tree-name STRING) (modulename STRING))
          : CONS
     Return the quoted tree with name TREE-NAME.

 -- Function: get-slot ((self STANDARD-OBJECT) (slot-name SYMBOL)) :
          SLOT
     Return the slot named SLOT-NAME on the class representing the type
     of SELF.

 -- Method on SURROGATE: get-stella-class (class-name (error? BOOLEAN))
          : CLASS
     Return a class with name CLASS-NAME.  If none exists, break if
     ERROR?, else return `null'.

 -- Method on SYMBOL: get-stella-class (class-name (error? BOOLEAN)) :
          CLASS
     Return a class with name CLASS-NAME.  If non exists, break if
     ERROR?, else return `null'.

 -- Method on STRING: get-stella-class (class-name (error? BOOLEAN)) :
          CLASS
     Return a class with name CLASS-NAME.  If none exists, break if
     ERROR?, else return `null'.

 -- Method on CALENDAR-DATE: get-time (date (timezone FLOAT)) : INTEGER
          INTEGER INTEGER INTEGER
     Returns multiple values of hours, minutes, seconds, milliseconds
     for the calendar date DATE in TIMEZONE.  TIMEZONE is the number of
     hours added to UTC to get local time.  It is in the range -12.0 to
     +14.0 where UTC is zone 0.0

 -- Function: global-variable-type-spec ((global GLOBAL-VARIABLE)) :
          TYPE-SPEC
     Return the type spec for the global variable GLOBAL.

 -- Function: hash-string ((string STRING) (seedCode INTEGER)) : INTEGER
     Generate a hash-code for STRING and return it.  Two strings that
     are equal but not eq will generate the same code.  The hash-code
     is based on SEEDCODE which usually will be 0.  However, SEEDCODE
     can also be used to supply the result of a previous hash operation
     to achieve hashing on sequences of strings without actually having
     to concatenate them.

 -- Function: help-advance-past-whitespace ((source STRING)
          (start INTEGER) (end INTEGER)) : INTEGER
     Helper for `advance-past-whitespace' that requires END to be
     properly set.

 -- Function: help-find-matching-prefix-length ((string1 STRING)
          (start1 INTEGER) (end1 INTEGER) (string2 STRING)
          (start2 INTEGER) (end2 INTEGER)) : INTEGER
     Helping function for `find-matching-prefix' that requires END1 and
     END2 to be properly set up.

 -- Function: help-get-stella-module ((pathName STRING)
          (error? BOOLEAN)) : MODULE
     Return the module located at PATHNAME, or `null' if no such module
     exists.  The search looks at ancestors and top-most  (cardinal)
     modules.  If ERROR? is `true', throw an exception if no  module is
     found.

 -- Method on CLASS: help-print-outline (top (stream OUTPUT-STREAM)
          (current-depth INTEGER) (depth INTEGER) (named? BOOLEAN)) :
     Helper method for `print-outline'

 -- Method on MODULE: help-print-outline (top (stream OUTPUT-STREAM)
          (current-depth INTEGER) (depth INTEGER) (named? BOOLEAN)) :
     Helper method for `print-outline'

 -- Method on OBJECT: help-print-outline (top (stream OUTPUT-STREAM)
          (current-depth INTEGER) (depth INTEGER) (named? BOOLEAN)) :
     Helper method for `print-outline'

 -- Method on SLOT: help-print-outline (top (stream OUTPUT-STREAM)
          (current-depth INTEGER) (depth INTEGER) (named? BOOLEAN)) :
     Helper method for `print-outline'

 -- Method on CONTEXT: help-print-outline (top (stream OUTPUT-STREAM)
          (current-depth INTEGER) (depth INTEGER) (named? BOOLEAN)) :
     Helper method for `print-outline'

 -- Method on OBJECT: home-module (self) : MODULE
     Return the home module of SELF.

 -- Macro: if-output-language ((language KEYWORD) (thenForm OBJECT)
          (elseForm OBJECT)) : OBJECT
     Expand to THENFORM if the current translator output language
     equals LANGUAGE.  Otherwise, expand to ELSEFORM.  This can be used
     to conditionally translate Stella code.

 -- Macro: if-stella-feature ((feature KEYWORD) (thenForm OBJECT)
          (elseForm OBJECT)) : OBJECT
     Expand to THENFORM if FEATURE is a currently enabled STELLA
     environment feature.  Otherwise, expand to ELSEFORM.  This can be
     used to conditionally translate Stella code.

 -- Macro: ignore (&body (variables CONS)) : OBJECT
     Ignore unused VARIABLES with NoOp `setq' statements.

 -- Function: incrementally-translate ((tree OBJECT)) : OBJECT
     Translate a single Stella expression TREE and return the result.
     For C++ and Java print the translation to standard output and
     return NIL instead.

 -- Function: indent-outline ((current-depth INTEGER)
          (stream OUTPUT-STREAM)) :
     Helper function that indents outline printings for level
     CURRENT-DEPTH on STREAM using the value of the global variable
     `*OUTLINE-INDENT-STRING*'

 -- Macro: inform (&body (body CONS)) : OBJECT
     Print informative message, placing non-string arguments in quotes,
     and terminating with a newline.

 -- Method on CLASS: initial-value (self) : OBJECT
     Return an initial value for the class SELF.

 -- Method on STORAGE-SLOT: initial-value (self) : OBJECT
     Return an initial value for SELF, or `null'.  The initial value
     can be defined by the slot itself, inherited from an equivalent
     slot, or inherit from the :initial-value option for the class
     representing the type of SELF.

 -- Method on STELLA-HASH-TABLE: initialize-hash-table (self) :
     Initialize the STELLA hash table SELF.  This is a no-op and
     primarily exists to shadow the standard initializer inherited from
     ABSTRACT-HASH-TABLE.  STELLA hash tables are initialized at the
     first insertion operation.

 -- Method on STORAGE-SLOT: initially (self) : OBJECT
     Defines the value of a slot before it has been assigned a value.

 -- Function: integer-to-hex-string ((i INTEGER)) : STRING
     Convert I to a string representation in hexadecimal notation and
     return the result.

 -- Function: integer-to-string-in-base ((i INTEGER) (base INTEGER)) :
          STRING
     Convert I to a string representation in BASE and return the
     result.  BASE must be positive and not more than 36.

     Note that in the C++ version, only 8, 10 and 16 will work as BASE
     arguments, since that is all the underlying implementation
     supports.  Other argument values will be treated as `10'.

 -- Function: integer-valued? ((x FLOAT)) : BOOLEAN
     Returns `true' if X is the floating point representation of an
     integer.

 -- Function: intern-stella-name ((name STRING)) : GENERALIZED-SYMBOL
     Parse NAME which is assumed to be the printed representation of a
     STELLA symbol, surrogate or keyword, intern it into the current or
     specified module and return the result.  This is identical to
     calling `unstringify' on NAME but 10-15 times faster.

 -- Function: interpret-command-line-arguments ((count INTEGER)
          (arguments (ARRAY () OF STRING))) :
     Interpret any STELLA-relevant command line ARGUMENTS.

 -- Function: isa? ((object OBJECT) (type TYPE)) : BOOLEAN
     Return `true' iff OBJECT is an instance of the class named TYPE.

 -- Function: java-translate-system ((systemName STRING)) :
     Translate the system SYSTEMNAME to Java.

 -- N-Command: jptrans ((statement OBJECT)) :
     Translate STATEMENT to C++ and print the result.

 -- Function: keyword-name? ((name STRING)) : BOOLEAN
     Return TRUE if name is prefixed by `:'.

 -- Function: kvlist-to-plist ((self KEY-VALUE-LIST)) : (PROPERTY-LIST
          OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))
     Convert SELF into a property list with identical and identically
     ordered keys and values.

 -- Method on CONS-ITERATOR: length (self) : INTEGER
     Iterate over SELF, and count how many items there are.

 -- Function: lispify ((thing UNKNOWN)) : LISP-CODE
     Convert a Stella THING as much as possible into a Common-Lisp
     analogue.  The currently supported THING types are CONS, LIST,
     KEY-VALUE-LIST, ITERATOR, SYMBOL, KEYWORD, and all wrapped and
     unwrapped literal types.  BOOLEANs are translated into Lisp's CL:T
     and CL:NIL logic.  Unsupported types are left unchanged.

 -- Function: lispify-boolean ((thing UNKNOWN)) : LISP-CODE
     Lispify THING which is assumed to be a (possibly wrapped) Stella
     boolean.

 -- Command: list-modules ((kb-only? BOOLEAN)) : (CONS OF MODULE)
     Returns a cons of all modules defined in PowerLoom.  If KB-ONLY?
     is `true', then any modules which are code only or just namespaces
     are not returned.

 -- Method on CONS: listify (self) : (LIST OF (LIKE (ANY-VALUE SELF)))
     Return a list of elements in SELF.

 -- Method on LIST: listify (self) : (LIST OF (LIKE (ANY-VALUE SELF)))
     Return SELF.

 -- Method on KEY-VALUE-LIST: listify (self) : (LIST OF (LIKE
          (ANY-VALUE SELF)))
     Return a list of key-value pairs in SELF.

 -- Method on VECTOR: listify (self) : (LIST OF (LIKE (ANY-VALUE SELF)))
     Return a list of elements in SELF.

 -- Method on ITERATOR: listify (self) : (LIST OF (LIKE (ANY-VALUE
          SELF)))
     Return a list of elements generated by SELF.

 -- Function: load-configuration-file ((file FILE-NAME)) :
          CONFIGURATION-TABLE
     Read a configuration FILE and return its content as a
     configuration table.  Also enter each property read into the
     global system configuration table.  Assumes Java-style property
     file syntax.  Each property name is represented as a wrapped
     string and each value as a wrapped string/integer/float or boolean.

 -- Command: load-file ((file STRING)) :
     Read STELLA commands from FILE and evaluate them.  The file should
     begin with an `in-module' declaration that specifies the module
     within which all remaining commands are to be evaluated The
     remaining commands are evaluated one-by-one, applying the function
     `evaluate' to each of them.

 -- Function: load-system ((systemName STRING) (language KEYWORD)
          &rest (options OBJECT)) : BOOLEAN
     Natively LANGUAGE-compile out-of-date translated files of system
     SYSTEMNAME and then load them into the running system (this is only
     supported/possible for Lisp at the moment).  Return true if at
     least one file was compiled. The following keyword/value OPTIONS
     are recognized:

     `:force-recompilation?' (default false): if true, files will be
     compiled whether or not their compilations are up-to-date.

     `:startup?' (default true): if true, the system startup function
     will be called once all files have been loaded.

 -- Function: log-level<= ((level OBJECT) (module STRING)) : BOOLEAN
     Return TRUE if LEVEL is lower than or equal to the current log
     level of MODULE.  Return FALSE if any of them are undefined.

 -- Function: log-message ((module STRING) (logLevel OBJECT)
          (message CONS)) :
     Log all elements of MESSAGE to MODULEs log stream if LOGLEVEL is
     the same or lower than the MODULEs log level.  Interprets `EOL' or
     :EOL to print a line terminator.

 -- Function: logmsg ((module STRING) (logLevel OBJECT)
          &rest (message OBJECT)) :
     Log all elements of MESSAGE to MODULEs log stream if LOGLEVEL is
     the same or lower than the MODULEs log level.  Interprets `EOL' or
     :EOL to print a line terminator.

 -- Method on SYMBOL: lookup-class (name) : CLASS
     Return a class with name NAME.  Scan all visible surrogates
     looking for one that has a class defined for it.

 -- Method on STRING: lookup-class (name) : CLASS
     Return a class with name NAME.  Scan all visible surrogates
     looking for one that has a class defined for it.

 -- Function: lookup-command ((name SYMBOL)) : METHOD-SLOT
     If NAME names an evaluable command return its associated command
     object;  otherwise, return `null'.  Currently, commands are not
     polymorphic, i.e., they can only be implemented by functions.

 -- Function: lookup-configuration-property ((property STRING)
          (defaultValue WRAPPER) (configuration CONFIGURATION-TABLE)) :
          OBJECT
     Lookup PROPERTY in CONFIGURATION and return its value.  Use the
     global system configuration table if CONFIGURATION is NULL.  Return
     DEFAULTVALUE if PROPERTY is not defined.

 -- Function: lookup-configuration-property-values ((property STRING)
          (defaultValue OBJECT) (configuration CONFIGURATION-TABLE)) :
          CONS
     Lookup PROPERTY in CONFIGURATION, assume it is a multi-valued
     property and return its value(s) as a list.  Use the global system
     configuration table if CONFIGURATION is NULL.  Return DEFAULTVALUE
     if PROPERTY is not defined or NIL is no default value is specified.

 -- Function: lookup-demon ((name STRING)) : DEMON
     Return the demon named NAME.

 -- Function: lookup-function ((functionSymbol SYMBOL)) : FUNCTION
     Return the function defined for FUNCTIONSYMBOL, if it exists.

 -- Function: lookup-function-by-name ((name STRING)) : FUNCTION
     Return a function with name NAME visible from the current module.
     Scan all visible symbols looking for one that has a function
     defined for it.

 -- Method on SURROGATE: lookup-global-variable (self) : GLOBAL-VARIABLE
     Return a global variable with name SELF.

 -- Method on GENERALIZED-SYMBOL: lookup-global-variable (self) :
          GLOBAL-VARIABLE
     Return a global variable with name SELF.

 -- Method on STRING: lookup-global-variable (self) : GLOBAL-VARIABLE
     Return a global variable with name SELF.

 -- Function: lookup-local-slot ((class CLASS) (slot-name SYMBOL)) :
          SLOT
     Lookup a local slot with SLOT-NAME on CLASS.

 -- Function: lookup-logging-parameter ((module STRING)
          (parameter KEYWORD) (default OBJECT)) : OBJECT
     Lookup logging PARAMETER for MODULE.  Use DEFAULT if no value is
     defined.

 -- Function: lookup-macro ((name SYMBOL)) : METHOD-SLOT
     If NAME has a macro definition, return the method object holding
     its expander function.

 -- Function: lookup-slot ((class CLASS) (slot-name SYMBOL)) : SLOT
     Return a slot owned by the class CLASS with name SLOT-NAME.
     Multiply inherited slots are disambiguated by a left-to-right class
     precedence order for classes with multiple parents (similar to
     CLOS).

 -- Method on PROPERTY-LIST: lookup-with-default (self
          (key (LIKE (ANY-KEY SELF)))
          (default (LIKE (ANY-VALUE SELF)))) : (LIKE (ANY-VALUE SELF))
     Lookup KEY in SELF and return the result.  Return DEFAULT if no
     value was found.

 -- Method on KEY-VALUE-LIST: lookup-with-default (self
          (key (LIKE (ANY-KEY SELF)))
          (default (LIKE (ANY-VALUE SELF)))) : (LIKE (ANY-VALUE SELF))
     Lookup KEY in SELF and return the result.  Return DEFAULT if no
     value was found.

 -- N-Command: lptrans ((statement OBJECT)) :
     Translate STATEMENT to Common-Lisp and print the result.

 -- Function: make-matching-name ((original STRING)
          &rest (options OBJECT)) : STRING
     Keyword options:   :break-on-cap    one of  :YES :NO :CLEVER
      default is :CLEVER   :break-on-number one of  :YES :NO :CLEVER
          default is :CLEVER   :break-on-separators string
              default is "-_ "   :remove-prefix   string
     :remove-suffix   string

     :case            one of  :UPCASE :TitleCase :titleCaseX :downcase
     :Capitalize :preserve
            default is :TitleCase   :separator       string
                    default is ""   :add-prefix      string
     :add-suffix      string

     MAKE-MATCHING-NAME returns a matching name (a string) for the
     input name (a string).  A matching name is constructed by breaking
     the input into `words' and then applying appropriate transforms.
     The arguments are used as follows:   ORIGINAL         is the input
     name.  It is a string.    :break-on-cap    is a keyword
     controlling whether changes in capitalization is used
          to indicate word boundaries.  If :YES, then all
     capitalization                    changes delineate words.  If
     :CLEVER, then unbroken runs of                    capitalized
     letters are treated as acronyms and remain grouped.
         If :NO or NULL, there is no breaking of words based on
     capitalization.    :break-on-number is a flag controlling whether
     encountering a number indicates                    a word
     boundary.  If :YES, then each run of numbers is treated as 		   a
     word separate from surrounding words.  If :CLEVER, then an
     attempt is made to recognize ordinal numbers (ie, 101st) and
     treat them as separate words.  If :NO or NULL, there is no breaking
                       of words when numbers are encountered.
     :break-on-separators   A string of characters which constitute
     word delimiters in                          the input word.  This
     is used to determine how to break                    the name into
     individual words.  Defaults are space, `-' and `_'.
     :remove-prefix   Specifies a prefix or suffix that is stripped
     from the input   :remove-suffix   name before any other
     processing.  This allows the removal of                    any
     naming convention dictated prefixes or suffixes.    :add-prefix
      Specifies a prefix or suffix that is added to the output name
     :add-suffix      after all other processing.  This allows the
     addition of any                    naming convention dictated
     prefixes or suffixes.    :case            The case of the
     resulting name.  This is applied to the name
     before adding prefixes or suffixes.  The two title case options
                    differ only in how the first word of the name is
     treated.                     :TitleCase capitalizes the first
     letter of the first word and                        also the first
     letter of all other words.                     :TitleCaseX does
     not capitalizes the first letter of the first 		       word but
     capitalizes the first letter of all subsequent words.
     :preserve results in no change in case.    :separator       This
     is a string specifying the word separator to use in the
            returned name.  An empty string (the default) means that
     the                    resulting words are concatenated without
     any separation.  This                    normally only makes sense
     when using one of the title case values                    for the
     case keyword.

 -- Function: make-matching-name-full ((originalname STRING)
          (breakoncap KEYWORD) (breakonnumber KEYWORD)
          (breakonseparators STRING) (removeprefix STRING)
          (removesuffix STRING) (addprefix STRING) (addsuffix STRING)
          (outputcase KEYWORD) (outputseparator STRING)) : STRING
     Non-keyword version of `make-matching-name', which will probably be
     easier to use when called from non-Lisp languages.

 -- Command: make-system ((systemName STRING) (language KEYWORD)
          &rest (options OBJECT)) : BOOLEAN
     Translate all out-of-date files of system SYSTEMNAME into LANGUAGE
     and then compile and load them (the latter is only possible for
     Lisp right now).  The following keyword/value OPTIONS are
     recognized:

     `:two-pass?': if true, all files will be scanned twice, once to
     load the signatures of objects defined in them, and once to
     actually translate the definitions.  Otherwise, the translator
     will make one pass in the case that the system is already loaded
     (and is being remade), and two passes otherwise.

     `:development-settings?' (default false): if true translation will
     favor safe, readable and debuggable code over efficiency
     (according to the value of `:development-settings' on the system
     definition).  If false, efficiency will be favored instead
     (according to the value of `:production-settings' on the system
     definition).

     `:production-settings?' (default true): inverse to
     `:development-settings?'.

     `:force-translation?' (default false): if true, files will be
     translated whether or not their translations are up-to-date.

     `:force-recompilation?' (default false): if true, translated files
     will be recompiled whether or not their compilations are
     up-to-date (only supported in Lisp right now).

     `:load-system?' (default true): if true, compiled files will be
     loaded into the current STELLA image (only supported in Lisp right
     now).

     `:startup?' (default true): if true, the system startup function
     will be called once all files have been loaded.

 -- Method on CONS-ITERATOR: member? (self (value OBJECT)) : BOOLEAN
     Iterate over values of SELF and return TRUE if one of them is
     `eql?' to 'value.

 -- Method on COLLECTION: member? (self (object OBJECT)) : BOOLEAN
     Return true iff OBJECT is a member of the collection SELF.

 -- Method on SEQUENCE: member? (self (value OBJECT)) : BOOLEAN
     Return TRUE if VALUE is a member of the sequence SELF.

 -- Macro: memoize ((inputArgs CONS) &body (body CONS)) : OBJECT
     Compute the value of an expression and memoize it relative to
     the values of INPUTARGS.  INPUTARGS should characterize the
     complete set of values upon which    the computation of the result
     depended.  Calls to `memoize' should be of the form

     (memoize (<arg>+) {:<option> <value>}* <expression>)

     and have the status of an expression.     The following options
     are supported:

     :timestamps   A single or list of keywords specifying the names of
                        timestamps which when bumped should invalidate
     all                     entries currently memoized in this table.
          :name         Names the memoization table so it can be
     shared by other                     memoization sites.  By
     default, a gensymed name is used.                      CAUTION: IT
     IS ASSUMED THAT ALL ENTRIES IN A MEMOZATION
     TABLE DEPEND ON THE SAME NUMBER OF ARGUMENTS!!        :max-values
     The maximum number of values to be memoized.  Only the
             `:max-values' most recently used values will be kept
                   in the memoization table, older values will be
     discarded                     and recomputed if needed.  Without a
     `:max-values'                     specification, the memoization
     table will grow                     indefinitely.

     PERFORMANCE NOTES: For most efficient lookup, input arguments that
     vary the most should be listed first.  Also, arguments of type
     STANDARD-OBJECT (and all its subtypes) can be memoized more
     efficiently than arguments of type OBJECT or wrapped literals
     (with the exception of BOOLEANs).

 -- Function: merge-file-names ((baseFile FILE-NAME)
          (defaults FILE-NAME)) : FILE-NAME
     Parse BASEFILE, supply any missing components from DEFAULTS if
     supplied and return the result.

 -- Method on DECODED-DATE-TIME: merge-null-fields (self
          (default DECODED-DATE-TIME)) :
     Replace any null valued fields in SELF with values from DEFAULT.
     The day of the week will be set consistently, if possible.

 -- Method on DECODED-DATE-TIME: merge-superior-null-fields (self
          (default DECODED-DATE-TIME)) :
     Replace only null valued fields in SELF that represent larger time
     units than the smallest non-null in SELF with values from DEFAULT.
     The day of the week will be set consistently, if possible.
     Example: if SELF just has the month being non-null, then only the
     year will be filled in from DEFAULT.  If the day and minute were
     non-null, then hour, month and year will be filled.

     This can be useful when one doesn't want to extend the precision
     of the answer.

 -- Method on CLASS: multiple-parents? (class) : BOOLEAN
     Return `true' if CLASS has more than one direct superclass.

 -- Method on MODULE: multiple-parents? (module) : BOOLEAN
     Return TRUE if MODULE has more than one parent.

 -- Method on WORLD: multiple-parents? (world) : BOOLEAN
     Return FALSE always, since worlds never have more than one parent.

 -- Function: name-to-string ((name OBJECT)) : STRING
     Return the string represented by NAME.  Return `null' if NAME is
     undefined or does not represent a string.

 -- Function: native-read-line ((inputStream INPUT-STREAM)) : STRING
     Read one line from INPUTSTREAM using the native language readline
     algorithm and return the result.  On EOF return `null'

 -- Method on MEMOIZABLE-ITERATOR: next? (self) : BOOLEAN
     Generate the next value of the memoized iterator SELF (or one of
     its clones) by either using one of the values generated so far or
     by generating and saving the next value of the `base-iterator'.

 -- Method on COLLECTION: no-duplicates? (self) : BOOLEAN
     Return `true' if the collection SELF forbids duplicate values.

 -- Method on STRING-WRAPPER: non-empty? (x) : BOOLEAN
     Return true if X is not the wrapped empty string ""

 -- Function: non-matching-position ((source STRING) (start INTEGER)
          (match STRING)) : INTEGER
     Returns the index into SOURCE, starting from START, of the first
     character that is not included in MATCH.

 -- Function: non-matching-position-helper ((source STRING)
          (start INTEGER) (end INTEGER) (match STRING)) : INTEGER
     Helper for `non-matching-position' that requires END to not be
     `null'.

 -- Method on NATIVE-VECTOR: nth (self (position INTEGER)) : (LIKE
          (ANY-VALUE SELF))
     Return the element in SELF at POSITION.

 -- Method on ARRAY: null? (x) : BOOLEAN
     Return true if X is undefined (handled specially by all
     translators).

 -- Macro: only-if ((test OBJECT) (expression OBJECT)) : OBJECT
     If TEST is TRUE, return the result of evaluating EXPRESSION.

 -- Function: open-network-stream ((host STRING) (port INTEGER)) :
          INPUT-STREAM OUTPUT-STREAM
     Open a TCP/IP network stream to HOST at PORT and return the result
     as an input/output stream pair.

 -- Method on COLLECTION: ordered? (self) : BOOLEAN
     Return `true' if the collection SELF is ordered.

 -- Function: outline-depth-exceeded? ((current-depth INTEGER)
          (depth-limit INTEGER)) : BOOLEAN
     Helper function that returns `true' if CURRENT-DEPTH exceeds
     DEPTH-LIMIT.  This functions uses the convention that a `null' or
     negative value of DEPTH-LIMIT means the depth is unlimited.  In
     those cases it always returns false.

 -- Method on CLASS: parameters (self) : (LIST OF SYMBOL)
     Returns the list of parameters names of SELF.

 -- Function: parse-date-time-in-time-zone ((date-time-string STRING)
          (time-zone FLOAT) (start INTEGER) (end INTEGER)
          (error-on-mismatch? BOOLEAN)) : DECODED-DATE-TIME
     Tries very hard to make sense out of the argument DATE-TIME-STRING
     and returns a time structure if successful.  If not, it returns
     `null'.  If ERROR-ON-MISMATCH? is true, parse-date-time will
     signal an error instead of returning `null'.  Default values are
     00:00:00 in the given timezone on the current date.  If the given
     TIME-ZONE value is `null', then the local time zone for the given
     date and time will be used as determined by the operating system.

 -- Function: parse-date-time-relative-to-base
          ((date-time-string STRING) (base-date-time DECODED-DATE-TIME)
          (start INTEGER) (end INTEGER) (error-on-mismatch? BOOLEAN)
          (merge-null-fields? BOOLEAN)) : DECODED-DATE-TIME
     Tries very hard to make sense out of the argument DATE-TIME-STRING
     and returns a time structure if successful.  If not, it returns
     `null'.  If ERROR-ON-MISMATCH? is true, parse-date-time will
     signal an error instead of returning `null'.  Default values are
     passed in via BASE-DATE-TIME.  If the timezone field that is
     passed in is NULL, then the local time zone for the parsed
     date/time will be used.  If MERGE-NULL-FIELDS? is `true', then
     default values from `base-time-date' will be merged into missing
     components.  If `false', then they won't be merged in for null
     components but can still be used as a basis for interpreatation of
     relative time strings like "now" or "yesterday"

 -- Function: parse-stella-name ((name STRING)
          (enableCaseConversion? BOOLEAN)) : STRING STRING KEYWORD
     Parse the printed representation NAME of a STELLA symbol,
     surrogate or keyword and return its symbol name, module name and
     type (which is either :SYMBOL, :SURROGATE or :KEYWORD).  NAME can
     be qualified and must use the exact same syntax and escape
     characters that would be used if it were to be read by
     `read-s-expression-from-string' (or `unstringify').  If
     ENABLECASECONVERSION? is TRUE, the returned symbol name will be
     upcased if the current module is case-insensitive; otherwise, it
     will be returned as is.  Raises a read exception if NAME does not
     represent a symbol.  This function is available primarily for
     efficiency, since it is about 10-15 times faster than
     `unstringify'.

 -- Function: pick-hash-table-size-prime ((minSize INTEGER)) : INTEGER
     Return a hash table prime of at least MINSIZE.

 -- Function: plist-to-kvlist ((self PROPERTY-LIST)) : (KEY-VALUE-LIST
          OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))
     Convert SELF into a key-value list with identical and identically
     ordered keys and values.

 -- Method on OBJECT: primary-type (self) : TYPE
     Returns the primary type of SELF.  Gets defined automatically for
     every non-abstract subclass of OBJECT.

 -- Method on RELATION: primitive? (self) : BOOLEAN
     Return `true' if SELF is not a defined relation.

 -- Macro: print (&body (body CONS)) : OBJECT
     Print arguments to the standard output stream.

 -- Function: print-exception-context ((e NATIVE-EXCEPTION)
          (stream OUTPUT-STREAM)) :
     Prints a system dependent information about the context of the
     specified exception.  For example, in Java it prints a stack
     trace.  In Lisp, it is vendor dependent.

 -- Command: print-outline ((thing OBJECT) (stream OUTPUT-STREAM)
          (depth INTEGER) (named? BOOLEAN)) :
     Print an outline of THING and its subparts on STREAM.  If DEPTH is
     greater than 0, only DEPTH levels will be printed.  If NAMED? is
     `TRUE', then only named entities will be printed.

     This function is intended to be used on things like modules,
     contexts, concepts, etc. that have hierarchical structure.  If
     THING doesn't have a hierarchical structure, it will just be
     printed.

 -- Function: print-recycle-lists () :
     Print the current state of all recycle lists.

 -- Macro: print-spaces (&body (body CONS)) : OBJECT
     (print-spaces [stream] N) prints N spaces onto stream.  If no
     stream form is provided, then STANDARD-OUTPUT will be used.

 -- Command: print-stella-features () :
     Print the list of enabled and disabled STELLA features.

 -- N-Command: print-unbound-surrogates (&rest (args OBJECT)) :
     Print all unbound surrogates visible from the module named by the
     first argument (a symbol or string).  Look at all modules if no
     module name or `null' was supplied.  If the second argument is
     `true', only consider surrogates interned in the specified module.

 -- Function: print-undefined-methods ((module MODULE)
          (local? BOOLEAN)) :
     Print all declared but not yet defined functions and methods in
     MODULE.  If LOCAL? is true, do not consider any parent modules of
     MODULE.  If MODULE is NULL, look at all modules in the system.
     This is handy to pinpoint forward declarations that haven't been
     followed up by actual definitions.

 -- N-Command: print-undefined-super-classes ((class NAME)) :
     Print all undefined or bad (indirect) super classes of CLASS.

 -- Function: private-class-methods ((class CLASS)) : (ITERATOR OF
          METHOD-SLOT)
     Iterate over all private methods attached to CLASS.

 -- Function: private-class-storage-slots ((class CLASS)) : (ITERATOR
          OF STORAGE-SLOT)
     Iterate over all private storage-slots attached to CLASS.

 -- Method on RELATION: private? (self) : BOOLEAN
     Return `true' if SELF is not public.

 -- Function: process-doctype ((doctype-declaration CONS)) : XML-DOCTYPE
     Takes an S-Expression representing a doctype and processes into a
     DOCTYPE object.

 -- N-Command: ptrans ((statement OBJECT)) :
     Translate STATEMENT to Common-Lisp and print the result.

 -- Function: public-class-methods ((class CLASS)) : (ITERATOR OF
          METHOD-SLOT)
     Iterate over all private methods attached to CLASS.

 -- Function: public-class-storage-slots ((class CLASS)) : (ITERATOR OF
          STORAGE-SLOT)
     Iterate over all public storage-slots attached to CLASS.

 -- Method on CLASS: public-slots (self) : (ITERATOR OF SLOT)
     Return an iterator over public slots of SELF.

 -- Method on OBJECT: public-slots (self) : (ITERATOR OF SLOT)
     Return an iterator over public slots of SELF.

 -- Method on SLOT: public? (self) : BOOLEAN
     True if SELF or one it its ancestors is marked public.

 -- Macro: pushf ((place CONS) (value OBJECT)) : OBJECT
     Push VALUE onto the cons list PLACE.

 -- Function: qualified-stella-name? ((name STRING)) : BOOLEAN
     Return TRUE if NAME is a symbol or surrogate qualified with a
     module pathname or a module pathname ending with a `/'.  Assumes
     that NAME is the printed representation of a STELLA symbol
     (potentially containing escape characters).

 -- Function: read-line2 ((stream INPUT-STREAM)) : STRING KEYWORD
     Read one line from STREAM and return the result and a keyword that
     indicates the terminator for that line ending: `:CR' `:LF' `:CRLF'
     or `:EOF'.   This is not platform-dependent and differs from
     `read-line' by returning a second value.  It may hang when used on
     interactive streams such as terminal or network streams with only
     CR line endings.  It should only be used on file or string input
     streams.

 -- Method on STORAGE-SLOT: reader (self) : SYMBOL
     Name of a method called to read the value of the slot SELF.

 -- Function: remove-configuration-property ((property STRING)
          (value OBJECT) (configuration CONFIGURATION-TABLE)) : OBJECT
     Remove VALUE from PROPERTY in CONFIGURATION and return it.  Use
     the global system configuration table if CONFIGURATION is NULL.

 -- Method on COLLECTION: remove-duplicates (self) : (LIKE SELF)
     Return SELF with duplicates removed.  Preserves the original order
     of the remaining members.

 -- Method on CLASS: required-slots (self) : (LIST OF SYMBOL)
     Returns a list of names of required slots for SELF.

 -- Method on STORAGE-SLOT: required? (self) : BOOLEAN
     True if a value must be assigned to this slot at creation time.

 -- Command: reset-stella-features () :
     Reset STELLA features to their default settings.

 -- Function: reverse-interval ((lowerbound INTEGER)
          (upperbound INTEGER)) : REVERSE-INTEGER-INTERVAL-ITERATOR
     Create a reverse interval object.

 -- Function: run-hooks ((hooklist HOOK-LIST) (argument OBJECT)) :
     Run all hook functions in HOOKLIST, applying each one to ARGUMENT.

 -- Function: running-as-lisp? () : BOOLEAN
     Return true if the executable code is a Common Lisp application.

 -- Function: running-in-language () : KEYWORD
     Returns the keyword for the language the current implementation is
     running in.

 -- Function: running-system-information () : STRING
     Returns an information string about the current running system
     environment.

 -- Function: safe-equal-hash-code ((self OBJECT)) : INTEGER
     Return a hash code for SELF.  Just like `equal-hash-code' - which
     see, but also works for NULL.  `equal-hash-code' methods that
     expect to handle NULL components should use this function for
     recursive calls.

 -- Function: safe-hash-code ((self OBJECT)) : INTEGER
     Return a hash code for SELF.  Just like `hash-code' - which see,
     but also works for NULL.

 -- Function: safe-lookup-slot ((class CLASS) (slot-name SYMBOL)) : SLOT
     Alias for `lookup-slot'.  Kept for backwards compatibility.

 -- Macro: safety ((level INTEGER-WRAPPER) (test OBJECT)
          &body (body CONS)) : OBJECT
     Signal warning message, placing non-string arguments in quotes.

 -- Function: save-configuration-file ((table CONFIGURATION-TABLE)
          (file FILE-NAME) (title STRING)) :
     Save TABLE as a configuration file.  Uses a Java-style property
     file syntax.

 -- Function: save-configuration-value ((stream OUTPUT-STREAM)
          (value OBJECT)) :
     Save VALUE to STREAM as a properly formatted configuration value.

 -- Function: search-cons-tree-with-filter? ((tree OBJECT)
          (value OBJECT) (filter CONS)) : BOOLEAN
     Return `true' iff the value VALUE is embedded within the cons tree
     TREE.  Uses an `eql?' test.  Does not descend into any cons whose
     first element matches an element of FILTER.

 -- Function: search-for-object ((self OBJECT) (typeref OBJECT)) :
          OBJECT
     If SELF is a string or a symbol, search for an object named SELF
     of type `type'.  Otherwise, if SELF is an object, return it.

 -- Function: seed-random-number-generator () :
     Seeds the random number generator with the current time.

 -- Function: sequence ((collectiontype TYPE) &rest (values OBJECT)) :
          (SEQUENCE OF OBJECT)
     Return a sequence containing VALUES, in order.

 -- Command: set-call-log-break-point ((count INTEGER)) :
     Set a call log break point to COUNT.  Execution will be
     interrupted right at the entry of the COUNTth logged function call.

 -- Function: set-configuration-property ((property STRING)
          (value OBJECT) (configuration CONFIGURATION-TABLE)) : OBJECT
     Set PROPERTY in CONFIGURATION to VALUE and return it.  Use the
     global system configuration table if CONFIGURATION is NULL.

 -- Method on DECODED-DATE-TIME: set-current-date (values-structure) :
     Sets the current date into VALUES-STRUCTURE

 -- Method on DECODED-DATE-TIME: set-current-date-time
          (values-structure) :
     Sets the current date and time into VALUES-STRUCTURE

 -- Method on DECODED-DATE-TIME: set-current-time (values-structure) :
     Sets the current time into VALUES-STRUCTURE

 -- Function: set-global-value ((self SURROGATE) (value OBJECT)) :
          OBJECT
     Set the value of the global variable for the surrogate SELF to
     VALUE.

 -- Function: set-logging-parameters ((module STRING)
          &rest (params&values OBJECT)) :
     Set logging parameters for MODULE.  The supported parameters are:
     :LOG-LEVELS - a cons list of legal levels in ascending log level
     order;                 for example, (:NONE :LOW :MEDIUM :HIGH) or
     (0 1 2 3).    :LEVEL      - the current log level for MODULE
     :STREAM     - the stream to log to (defaults to STANDARD-OUTPUT)
     :PREFIX     - the prefix to use to identify the module (defaults
     to MODULE)   :MAX-WIDTH  - logging output lines will be kept to
     approximately this width                 (defaults to 10000,
     minimum width of about 30 is used to                 print line
     header information).

 -- Function: set-optimization-levels ((safety INTEGER) (debug INTEGER)
          (speed INTEGER) (space INTEGER)) :
     Set optimization levels for the qualities SAFETY, DEBUG, SPEED,
     and SPACE.

 -- Command: set-stella-feature (&rest (features KEYWORD)) :
     Enable all listed STELLA FEATURES.

 -- Command: set-translator-output-language ((new-language KEYWORD)) :
          KEYWORD
     Set output language to NEW-LANGUAGE.  Return previous language.

 -- Macro: setq? ((variable SYMBOL) (expression CONS)) : OBJECT
     Assign VARIABLE the result of evaluating EXPRESSION, and return
     TRUE if EXPRESSION is not NULL else return FALSE.

 -- Function: shadowed-symbol? ((symbol GENERALIZED-SYMBOL)) : BOOLEAN
     Return `true' if SYMBOL is shadowed in its home module.

 -- Function: shift-right ((arg INTEGER) (count INTEGER)) : INTEGER
     Shift ARG to the right by COUNT positions and 0-extend from the
     left if ARG is positive or 1-extend if it is negative.  This is an
     arithmetic shift that preserve the sign of ARG and is equivalent
     to dividing ARG by 2** COUNT.

 -- Macro: signal ((type SYMBOL) &body (body CONS)) : OBJECT
     Signal error message, placing non-string arguments in quotes.

 -- Macro: signal-read-error (&body (body CONS)) : OBJECT
     Specialized version of `signal' that throws a READ-EXCEPTION.

 -- Command: start-function-call-logging ((fileName STRING)) :
     Start function call logging to FILENAME.

 -- Function: starts-with? ((string STRING) (prefix STRING)
          (start INTEGER)) : BOOLEAN
     Return TRUE if STRING starts with PREFIX starting from START
     (which defaults to 0 if it is supplied as NULL).

 -- Function: stella-collection? ((self OBJECT)) : BOOLEAN
     Return `true' if SELF is a native collection.

 -- Command: stella-information () : STRING
     Returns information about the current Stella implementation.
     Useful when reporting problems.

 -- Function: stella-object? ((self OBJECT)) : BOOLEAN
     Return true if SELF is a member of the STELLA class `OBJECT'.

 -- Function: stella-version-string () : STRING
     Return a string identifying the current version of STELLA.

 -- Function: stellafy ((thing LISP-CODE) (targetType TYPE)) : OBJECT
     Partial inverse to `lispify'.  Convert the Lisp object THING into
     a Stella analogue of type TARGETTYPE.  Note: See also `stellify'.
     it is similar, but guesses TARGETTYPE on its own, and makes
     somewhat different translations.

 -- Function: stellify ((self OBJECT)) : OBJECT
     Convert a Lisp object into a STELLA object.

 -- Command: stop-function-call-logging () :
     Stop function call logging and close the current log file.

 -- Method on INPUT-STREAM: stream-to-string (from) : STRING
     Read all of the input from `stream' and return it as a string.

 -- Function: string-to-calendar-date-with-default ((input-date STRING)
          (default-date DECODED-DATE-TIME)) : CALENDAR-DATE
     Returns a calendar date object representing the date and time
     parsed from the INPUT-DATE string.  Default values for missing
     fields and the interpretation of relative references come from
     DEFAULT-DATE.  If the DEFAULT-DATE is `null', the current date
     will be used.  If a null set of defaults is desired, use
     `*NULL-DECODED-DATE-TIME*'.  If no valid parse is found, `null' is
     returned.

 -- Function: string-to-decoded-date-time ((input STRING)) :
          DECODED-DATE-TIME
     Returns a decoded date-time object representing the date and time
     parsed from the INPUT string.  If no valid parse is found, `null'
     is returned.

 -- Function: string-to-surrogate ((self STRING)) : SURROGATE
     Return a surrogate with the name SELF visible in the current
     module.  Very tricky: The logic is designed to avoid returning an
     inherited surrogate that has no value.  In that case, a new local
     surrogate is created that shadows the inherited surrogate.

 -- Function: string-to-time-duration ((duration STRING)) :
          TIME-DURATION
     Parses and returns an time-duration object corresponding to
     DURATION.  The syntax for time duration strings is "{plus|minus} N
     days[; M ms]" where N and M are integer values for days and
     milliseconds.  If no valid parse is found, `null' is returned.

 -- Function: subclass-of? ((subClass CLASS) (superClass CLASS)) :
          BOOLEAN
     Return `true' if SUBCLASS is a subclass of SUPERCLASS.

 -- Method on MUTABLE-STRING: subsequence (string (start INTEGER)
          (end INTEGER)) : STRING
     Return a substring of STRING beginning at position START and
     ending up to but not including position END, counting from zero.
     An END value of NULL stands for the rest of the string.

 -- Method on STRING: substitute-characters (self (new-chars STRING)
          (old-chars STRING)) : STRING
     Substitute all occurences of of a member of OLD-CHARS with the
     corresponding member of NEW-CHARS in the string SELF.  Returns a
     new string.

 -- Method on MUTABLE-STRING: substitute-characters (self
          (new-chars STRING) (old-chars STRING)) : MUTABLE-STRING
     Substitute all occurences of of a member of OLD-CHARS with the
     corresponding member of NEW-CHARS in the string SELF.  IMPORTANT:
     The return value should be used instead of relying on destructive
     substitution, since the substitution will not be destructive in
     all translated languages.

 -- Function: subtype-of? ((sub-type TYPE) (super-type TYPE)) : BOOLEAN
     Return `true' iff the class named SUB-TYPE is a subclass of the
     class named SUPER-TYPE.

 -- Method on CLASS: super-classes (self) : (ITERATOR OF CLASS)
     Returns an iterator that generates all super classes of SELF.
     Non-reflexive.

 -- Function: surrogate-name? ((name STRING)) : BOOLEAN
     Return TRUE if name is prefixed by `SURROGATE-PREFIX-CHARACTER'.

 -- Method on SURROGATE: surrogatify (self) : SURROGATE
     Converts SELF into a surrogate.

 -- Method on SYMBOL: surrogatify (self) : SURROGATE
     Converts SELF into a surrogate (same semantics as
     `symbol-to-surrogate' which see).

 -- Method on STRING: surrogatify (self) : SURROGATE
     Converts SELF into a surrogate.

 -- Method on OBJECT: sweep (self) :
     Default method.  Sweep up all SELF-type objects.

 -- Function: symbol-to-surrogate ((self SYMBOL)) : SURROGATE
     Return a surrogate with the same name as SELF.  Very tricky: The
     logic is designed to avoid returning an inherited surrogate that
     has no value.  In that case, a new local surrogate is created that
     shadows the inherited surrogate.  Unlike `string-to-surrogate',
     the search starts first from the home context of SELF, and if that
     fails, then it restarts in *module*.

 -- Function: symbol-to-type ((self SYMBOL)) : SURROGATE
     Convert SELF into a surrogate with the same name and module.

 -- Method on STORAGE-SLOT: system-default-value (self) : OBJECT
     Return a default value expression, or if SELF has dynamic storage,
     an initial value expression.

 -- Method on SLOT: system-default-value (self) : OBJECT
     Return a default value expression, or if SELF has dynamic storage,
     an initial value expression.

 -- Function: system-loaded? ((name STRING)) : BOOLEAN
     Return `true' if system NAME has been loaded.

 -- Function: terminate-program () :
     Terminate and exit the program with normal exit code.

 -- Method on TIME-DURATION: time-duration-to-string (date) : STRING
     Returns a string representation of DATE

 -- Function: time-zone-format60 ((timezone FLOAT)) : STRING
     Format `zone' as an hh:mm string

 -- Function: toggle-output-language () : KEYWORD
     Switch between Common Lisp and C++ as output languages.

 -- Macro: trace-if ((keyword OBJECT) &body (body CONS)) : OBJECT
     If KEYWORD is a trace keyword that has been enabled with
     `add-trace' print all the elements in BODY to standard output.
     Otherwise, do nothing.  KEYWORD can also be a list of keywords in
     which case printing is done if one or more of them are trace
     enabled.

 -- Function: translate-system ((systemName STRING)
          (outputLanguage KEYWORD) &rest (options OBJECT)) : BOOLEAN
     Translate all of the STELLA source files in system SYSTEMNAME into
     OUTPUTLANGUAGE.  The following keyword/value OPTIONS are
     recognized:

     `:two-pass?' (default false): if true, all files will be scanned
     twice, once to load the signatures of objects defined in them, and
     once to actually translate the definitions.

     `:force-translation?' (default false): if true, files will be
     translated whether or not their translations are up-to-date.

     `:development-settings?' (default false): if true translation will
     favor safe, readable and debuggable code over efficiency
     (according to the value of `:development-settings' on the system
     definition).  If false, efficiency will be favored instead
     (according to the value of `:production-settings' on the system
     definition).

     `:production-settings?' (default true): inverse to
     `:development-settings?'.

 -- Function: translate-to-common-lisp? () : BOOLEAN
     Return `true' if current output language is Common-Lisp.

 -- Function: translate-to-cpp? () : BOOLEAN
     Return `true' if current output language is C++

 -- Function: translate-to-java? () : BOOLEAN
     Return `true' if current output language is Java

 -- Function: truncate ((n NUMBER)) : INTEGER
     Truncate N toward zero and return the result.

 -- Function: try-to-evaluate ((tree OBJECT)) : OBJECT
     Variant of `evaluate' that only evaluates TREE if it represents an
     evaluable expression.  If it does not, TREE is returned
     unmodified.  This can be used to implement commands with mixed
     argument evaluation strategies.

 -- Function: two-argument-least-common-superclass ((class1 CLASS)
          (class2 CLASS)) : CLASS
     Return the most specific class that is a superclass of both CLASS1
     and CLASS2.  If there is more than one, arbitrarily pick one.  If
     there is none, return `null'.

 -- Function: two-argument-least-common-supertype ((type1 TYPE-SPEC)
          (type2 TYPE-SPEC)) : TYPE-SPEC
     Return the most specific type that is a supertype of both TYPE1
     and TYPE2.  If there is more than one, arbitrarily pick one.  If
     there is none, return @VOID.  If one or both types are parametric,
     also try to generalize parameter types if necessary.

 -- Method on SLOT: type (self) : TYPE
     The type of a storage slot is its base type.

 -- Method on SLOT: type-specifier (self) : TYPE-SPEC
     If SELF has a complex type return its type specifier, otherwise,
     return `type' of SELF.

 -- Function: type-to-symbol ((type TYPE)) : SYMBOL
     Convert TYPE into a symbol with the same name and module.

 -- Method on SURROGATE: type-to-wrapped-type (self) : TYPE
     Return the wrapped type for the type SELF, or SELF if it is not a
     bare literal type.

 -- Function: unbound-surrogates ((module MODULE) (local? BOOLEAN)) :
          (ITERATOR OF SURROGATE)
     Iterate over all unbound surrogates visible from MODULE.  Look at
     all modules if MODULE is `null'.  If LOCAL?, only consider
     surrogates interned in MODULE.

 -- Function: unescape-html-string ((input STRING)) : STRING
     Replaces HTML escape sequences such as &amp; with their associated
     characters.

 -- Function: unescape-url-string ((input STRING)) : STRING
     Takes a string and replaces %-format URL escape sequences with
     their real character equivalent according to RFC 2396.

 -- Command: unset-stella-feature (&rest (features KEYWORD)) :
     Disable all listed STELLA FEATURES.

 -- Function: unsigned-shift-right-by-1 ((arg INTEGER)) : INTEGER
     Shift ARG to the right by 1 position and 0-extend from the left.
     This does not preserve the sign of ARG and shifts the sign-bit
     just like a regular bit.  In Common-Lisp we can't do that directly
     and need to do some extra masking.

 -- Function: unstringify-stella-source ((source STRING)
          (module MODULE)) : OBJECT
     Unstringify a STELLA SOURCE string relative to MODULE, or
     `*MODULE*' if no module is specified.  This function allocates
     transient objects as opposed to `unstringify-in-module' or the
     regular `unstringify'.

 -- Function: unwrap-boolean ((wrapper BOOLEAN-WRAPPER)) : BOOLEAN
     Unwrap WRAPPER and return its values as a regular BOOLEAN.  Map
     NULL onto FALSE.

 -- Function: unwrap-function-code ((wrapper FUNCTION-CODE-WRAPPER)) :
          FUNCTION-CODE
     Unwrap WRAPPER and return the result.  Return NULL if WRAPPER is
     NULL.

 -- Function: unwrap-method-code ((wrapper METHOD-CODE-WRAPPER)) :
          METHOD-CODE
     Unwrap WRAPPER and return the result.  Return NULL if WRAPPER is
     NULL.

 -- Method on ABSTRACT-DICTIONARY-ITERATOR: value-setter (self
          (value (LIKE (ANY-VALUE SELF)))) : (LIKE (ANY-VALUE SELF))
     Abstract method needed to allow application of this method on
     abstract iterator classes that do not implement it.  By having
     this here all `next?' methods of dictionary iterators MUST use the
     `slot-value' paradigm to set the iterator value.

 -- Macro: warn (&body (body CONS)) : OBJECT
     Signal warning message, placing non-string arguments in quotes.

 -- Macro: with-network-stream ((binding CONS) &body (body CONS)) :
          OBJECT
     Sets up an unwind-protected form which opens a network socket
     stream to a host and port for input and output and closes it
     afterwards.  Separate variables as provided in the call are bound
     to the input and output streams. Syntax is (WITH-NETWORK-STREAM
     (varIn varOut hostname port) body+)

 -- Macro: with-permanent-objects (&body (body CONS)) : OBJECT
     Allocate `permanent' (as opposed to `transient') objects within
     the scope of this declaration.

 -- Macro: with-system-definition ((systemnameexpression OBJECT)
          &body (body CONS)) : OBJECT
     Set *currentSystemDefinition* to the system definition named
     `system'.  Set *currentSystemDefinitionSubdirectory* to match.
     Execute BODY within that scope.

 -- Macro: with-transient-objects (&body (body CONS)) : OBJECT
     Allocate `transient' (as opposed to `permanent') objects within
     the scope of this declaration.  CAUTION: The default assumption is
     the allocation of permanent objects.  The scope of
     `with-transient-objects' should be as small as possible, and the
     user has to make sure that code that wasn't explicitly written to
     account for transient objects will continue to work correctly.

 -- Function: wrap-boolean ((value BOOLEAN)) : BOOLEAN-WRAPPER
     Return a literal object whose value is the BOOLEAN VALUE.

 -- Function: wrap-function-code ((value FUNCTION-CODE)) :
          FUNCTION-CODE-WRAPPER
     Return a literal object whose value is the FUNCTION-CODE VALUE.

 -- Function: wrap-method-code ((value METHOD-CODE)) :
          METHOD-CODE-WRAPPER
     Return a literal object whose value is the METHOD-CODE VALUE.

 -- Function: wrapped-type-to-type ((self TYPE)) : TYPE
     Return the unwrapped type for the wrapped type SELF, or SELF if it
     is not a wrapped type.

 -- Function: wrapper-value-type ((self WRAPPER)) : TYPE
     Return the type of the value stored in the wrapper SELF.

 -- Function: write-html-escaping-url-special-characters
          ((stream NATIVE-OUTPUT-STREAM) (input STRING)) :
     Writes a string and replaces unallowed URL characters according to
     RFC 2396 with %-format URL escape sequences.

 -- Method on STORAGE-SLOT: writer (self) : SYMBOL
     Name of a method called to write the value of the slot SELF.

 -- Function: xml-declaration-form? ((form OBJECT)) : BOOLEAN
     Return `true' if FORM is a CONS headed by an XML DECLARATION tag

 -- Function: xml-doctype-form? ((form OBJECT)) : BOOLEAN
     Return `true' if FORM is a CONS headed by a DOCTYPE tag

 -- Function: xml-element-form? ((form OBJECT)) : BOOLEAN
     Return `true' if FORM is a CONS headed by an XML ELEMENT tag

 -- Function: xml-processing-instruction-form? ((form OBJECT)) : BOOLEAN
     Return `true' if FORM is a CONS headed by an XML PROCESSING
     INSTRUCTION tag

 -- Function: xml-processing-instruction? ((item OBJECT)) : BOOLEAN
     Return `true' if ITEM is an XML processing instruction object

 -- Function: xml-token-list-to-s-expression
          ((tokenList TOKENIZER-TOKEN) (doctype XML-DOCTYPE)
          (doctype-definition? BOOLEAN)) : OBJECT
     Convert the XML TOKENLIST (using DOCTYPE for guidance) into a
     representative s-expression and return the result.    The DOCTYPE
     argument is currently only used for expansion of entity
     references.  It can be `null'.  The flag DOCTYPE-DEFINITION?
     should be true only when processing the DTD definition of a
     DOCTYPE tag, since it enables substitution of parameter entity
     values.

     Every XML tag is represented as a cons-list starting with the tag
     as its header, followed by a possibly empty list of keyword value
     pairs representing tag attributes, followed by a possibly empty
     list of content expressions which might themselves be XML
     expressions.  For example, the expression

     <a a1=v1 a2='v2'> foo <b a3=v3/> bar </a>

     becomes

     (<a> (<a1> "v1" <a2> "v2") "foo" (<b> (<a3> "v3")) "bar")

     when represented as an s-expression.  The tag names are subtypes
     of XML-OBJECT such as XML-ELEMENT, XML-LOCAL-ATTRIBUTE,
     XML-GLOBAL-ATTRIBUTE, etc.  ?, ! and [ prefixed tags are encoded
     as their own subtypes of XML-OBJECT, namely
     XML-PROCESSING-INSTRUCTION, XML-DECLARATION, XML-SPECIAL,
     XML-COMMENT, etc.  CDATA is an XML-SPECIAL tag with a name of
     CDATA.

     The name is available using class accessors.

 -- Function: yield-define-stella-class ((class CLASS)) : CONS
     Return a cons tree that (when evaluated) constructs a Stella class
     object.

 -- Function: zero-pad-integer ((value INTEGER) (size INTEGER)) : STRING
     Returns a string representing VALUE of at least length SIZE,
     padded if necessary with 0 characters.

