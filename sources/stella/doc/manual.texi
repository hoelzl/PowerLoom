\input texinfo.tex @c -*-texinfo-*-

@c DO NOT MODIFY THIS FILE, IT WAS GENERATED AUTOMATICALLY FROM A TEMPLATE!

@c Version: manual.texi.in,v 1.23 2006/05/21 07:23:37 hans Exp

@setfilename manual.info

@settitle STELLA Manual

@iftex
@finalout
@end iftex

@ifinfo
This file documents the STELLA programming language.

Copyright (C) 2006
University of Southern California, Information Sciences Institute
4676 Admiralty Way
Marina Del Rey, CA 90292

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission notice
identical to this one except for the removal of this paragraph (this
paragraph not being relevant to the printed manual).

@end ignore
@end ifinfo

@titlepage
@sp 6
@center @titlefont{STELLA Manual}
@sp 1
@center Painless symbolic programming with
@center delivery in Common-Lisp, C++ and Java
@sp 3
@center 1.23
@sp 1
@center This manual describes
@center STELLA 3.4 or later.
@sp 3
@center @strong{The STELLA Development Team}
@ifhtml
<br>
<blockquote>
@end ifhtml
@center Hans Chalupsky
@ifhtml
<br>
@end ifhtml
@center Robert M. MacGregor
@ifhtml
<br>
@end ifhtml
@center Thomas A. Russ
@ifhtml
<br>
@end ifhtml
@center @{hans,tar@}@@isi.edu
@ifhtml
</blockquote>
@end ifhtml
@sp 1
@center USC Information Sciences Institute
@page

@vskip 0pt plus 1fill
Copyright (C) 2006
University of Southern California, Information Sciences Institute@*
4676 Admiralty Way, Marina Del Rey, CA 90292

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission notice
identical to this one except for the removal of this paragraph (this
paragraph not being relevant to the printed manual).

@end ignore
@end titlepage

@c ===========================================================================

@contents

@c ===========================================================================

@ifinfo
@node Top, Overview, (dir), (dir)
@comment  node-name,  next,  previous,  up
@ichapter STELLA Manual

This document describes the STELLA programming language.  STELLA stands
for Strongly-TypEd, Lisp-like LAnguage.  It is an object-oriented
language that strongly supports symbolic programming tasks.  STELLA
programs can currently be translated into Common-Lisp, C++ and Java.
STELLA programming is best done in an Emacs-based Lisp development
environment, which leverages off Lisp's rapid prototyping and
incremental development features.  Once a STELLA program has matured, it
can be translated into C++ or Java to gain extra efficiency, to deliver
it as a stand-alone application, or to link it with other programs.

@end ifinfo

@c ===========================================================================

@menu
* Overview::                    
* Installation::                
* The STELLA Language::         
* Programming in STELLA::       
* Library Classes::             
* Library Functions::           
* Function Index::              
* Variable Index::              
* Concept Index::               
@end menu

@node  Overview, Installation, Top, Top
@comment  node-name,  next,  previous,  up
@chapter Introduction

This document describes the STELLA programming language.  STELLA stands
for Strongly-TypEd, Lisp-like LAnguage.  It is an object-oriented
language that strongly supports symbolic programming tasks.  We
developed it, since none of the currently ``healthy'' languages such as
C++ or Java adequately support symbolic programming.  While Common-Lisp
would probably still be today's language of choice for many symbolic
programming applications, its dwindling vendor support and user base
make it more and more difficult to justify its use.

When we started the development of the PowerLoom knowledge
representation system in 1995 we were faced with exactly this problem.
PowerLoom had to be delivered in C++, but it was simply incoceivable to
write such a large symbolic programming application directly in C++.
The solution was to invent a new programming language we called STELLA
and write PowerLoom in STELLA instead.

STELLA is a strongly typed, object-oriented, Lisp-like language
specifically geared to support artificial intelligence applications.
STELLA preserves those features of Common Lisp deemed essential for
symbolic programming such as built-in support for dynamic data
structures, heterogeneous collections, first-class symbols, powerful
iteration constructs, name spaces, an object-oriented type system with a
simple meta-object protocol, exception handling, language extensibility
through macros and automatic memory management.  Maybe the biggest
difference between STELLA and Common Lisp is that STELLA is strongly
typed.  All externally visible interfaces such as slots, function
parameters and return values, etc. have to be explicitly typed.
Internal objects such as local variables, however, are mostly typed
implicitly supported by type inference.  This in conjunction with a
powerful type coercion mechanism significantly reduces the number of
explicit type information that needs to be supplied by the programmer
compared to languages such as C++ or Java.

STELLA programs are first translated into a target language such as
Common Lisp, C++ or Java, and then compiled with the native target
language compiler to generate executable code. The language constructs
of STELLA are restricted to those that can be translated fairly directly
into native constructs of the intended target languages.  This allows
STELLA to be translated into efficient, conventional and readable Lisp,
C++ and Java code.  The resulting native code can be understood and to
some extent even maintained by programmers who don't know STELLA, and it
can easily be interfaced with other programs not written in STELLA.

As of Fall 2000, we have programmed approximately 100,000 lines of
STELLA code - about 50% for the STELLA kernel itself and the other 50%
for the PowerLoom knowledge representation system and related
systems. Our subjective experience has been that it is only slightly
more difficult to write and debug a STELLA program than a Lisp program,
and that the inconvenience of having to supply some type information is
much outweighed by the benefits such as catching many errors during
compile time instead of at run time.

The biggest benefit, however, seems to be that we can still leverage all
the incremental code development benefits of Lisp, since we use the
Common Lisp-based version of STELLA for prototyping.  This allows us to
incrementally define and redefine functions, methods and classes and to
inspect, debug and fix incorrect code on the fly.  Even the most
sophisticated C++ or Java IDE's don't yet seem to support this fully
incremental development style, i.e., a change in a class (every change
in Java is a change to a class) still requires recompilation and restart
of the application.  But it is the restart that can be the most time
consuming if one debugs a complex application that takes a significant
time to reach a certain state!

Once a STELLA program has matured, it can be translated into C++ or Java
to gain extra efficiency, to deliver it as a stand-alone application, or
to link it with other programs.

@c ---------------------------------------------------------------------------

@menu
* Credits and History::         
@end menu

@node Credits and History,  , Overview, Overview
@section Credits and History

Bob MacGregor invented STELLA in 1995 to implement the PowerLoom
knowledge representation system.  He wrote most of the first Lisp-based
kernel system of STELLA and still occasionally writes extensions or
provides fixes.  Today he is primarily a STELLA user writing his own
applications.

Hans Chalupsky completed the first full STELLA bootstrap (STELLA
translating itself) in Spring 1996, and then went on to deal with all
the changes necessary to handle the many C++ and Java idiosyncrasies
that were discovered when the first versions of these translators came
online.  He is currently one of the principal maintainers of STELLA
supporting the STELLA code analyzer and the Lisp and C++ translators.

Eric Melz wrote the first version of the C++ translator under very
trying circumstances (i.e., at a stage where the STELLA language
changed under him on a daily basis).  He got the first C++ version of
STELLA running in the Fall of 1996.

Tom Russ wrote the Java translator and got the first Java version of
STELLA running in Spring 1999.  He is currently one of the principal
maintainers of STELLA supporting the STELLA code analyzer and the Lisp
and Java translators.  He is also still active writing occasional
extensions such as the STELLA XML parser.

@c ===========================================================================

@node Installation, The STELLA Language, Overview, Top
@chapter Installation

@c ---------------------------------------------------------------------------

@menu
* System Requirements::         
* Unpacking the Sources::       
* Lisp Installation::           
* C++ Installation::            
* Java Installation::           
* X/Emacs Setup::               
* Removing Unneeded Files::     
@end menu

@node System Requirements, Unpacking the Sources, Installation, Installation
@section System Requirements

To install and use STELLA you'll approximately need the following amounts of
disk space:

@itemize
@item 
8 MB for the tar-red or zip-ped archive file

@item 
35 MB for the untarred sources, tanslations, compiled Java files and
documentation

@item 
8 MB to compile a Lisp version

@item 
11 MB to compile the C++ version (without -g)

@item 
3 MB to compile the Java version (already included)

@end itemize

This means that you will need approximately 55 MB to work with one Lisp,
one C++ and one Java version of STELLA in parallel.  If you also want to
experiment with the Lisp translation variant that uses structures
instead of CLOS instances to implement STELLA objects, then you will
need an extra 8 MB to compile that.

The full STELLA development tree is quite large, since for every STELLA
source file there are three to four translated versions and as many
compiled versions thereof.  The actual STELLA libraries that you have to
ship with an application, however, are quite small.  For example, the
Java jar file @file{stella.jar} is only about 1.3 MB in size.  The
dynamic C++ library @file{libstella.so} compiled on a Linux platform is
about 4 MB.  Additionally, if you don't need all the different
translations of STELLA, you can delete some of the versions to keep your
development tree smaller (@xref{Removing Unneeded Files}).

To run the Lisp version of STELLA you need an ANSI Common-Lisp (or at
least one that supports CLOS and logical pathnames).  We have
successfully tested STELLA with Allegro-CL 4.2, 4.3, 5.0, 6.0 and 7.0,
Macintosh MCL 3.0, 4.0 and 5.1, OpenMCL 1.0, SBCL 0.9.4, CMUCL 19c,
LispWorks 4.4.6, CLisp 2.37, Lucid CL 4.1 (plus the necessary ANSI
extensions and Mark Kantrowitz's logical pathnames implementation) and
various others.  Our main development platform is Allegro CL running
under Sun Solaris and Linux, so, the closer your environment is to ours,
the higher are the chances that everything will work right out of the
box.  Lisp development under Windows should also be no problem.

To run the C++ version of STELLA you need a C++ compiler such as g++
that supports templates and exception handling.  We have successfully
compiled and run STELLA with g++ 3.2 and later under Linux Redhat 8.0 &
9.0, SunOS and MacOS X, and with CygWin 5.0 and MinGW 5.0 under Windows
2000 and XP.  Both CygWin and MinGW provide a GNU Unix environment, but
MinGW can generate Windows executables that are fully standalone.  We've
also managed to compile STELLA under MS Visual C++, however, we never
got the Boehm garbage collector to work.  The GC claims to be very
portable, so this should be solvable for somebody with good knowledge of
MS Visual C++.

For the Java version you will need Java JDK 1.2 or later. To get
reasonable performance, you should use J2SDK 1.4 or 1.5.  We've run the
Java version of STELLA on a variety of platforms without any problems.

Any one of the Lisp, C++ or Java implementations of STELLA can be used
to develop your own STELLA code and translate it into all three languages,
but the most convenient development environment is the one based on
Lisp.  If you use the C++ or Java version, translating and using your
own STELLA macros is possible but not yet very well supported.

@c ---------------------------------------------------------------------------

@node Unpacking the Sources, Lisp Installation, System Requirements, Installation
@section Unpacking the Sources

Uncompress and untar the file @file{stella-X.Y.Z.tar.gz} (or unzip the
file @file{stella-X.Y.Z.zip}) in the parent directory of where you want
to install STELLA (`X.Y.Z' are place holders for the actual version
numbers).  This will create the STELLA tree in the directory
@file{stella-X.Y.Z/}.  All pathnames mentioned below will be relative to that
directory which we will usually refer to as the "STELLA directory".

@c ---------------------------------------------------------------------------

@node Lisp Installation, C++ Installation, Unpacking the Sources, Installation
@section Lisp Installation

To install the Lisp version startup Lisp and load the file
@file{load-stella.lisp} with:

@example
(CL:load "load-stella.lisp")
@end example

The first time around this will compile all Lisp-translated STELLA files
before they are loaded.  During subsequent sessions the compiled files
will be loaded right away.

If you want to use the version that uses Lisp structs instead of CLOS
objects to implement STELLA objects do the following:

@example
(CL:setq cl-user::*load-cl-struct-stella?* CL:t)
(CL:load "load-stella.lisp")
@end example

Alternatively, you can edit the initial value of the variable
@code{*load-cl-struct-stella?*} in the file @file{load-stella.lisp}.
Using structs instead of CLOS objects greatly improves slot access
speed, however, it may cause problems with incremental re-definition
of STELLA classes.  It is therefore recommended to only use this for
systems that are in or near the production stage.

Once all the files are loaded, you should see a message like this:

@example
Initializing STELLA...
STELLA 3.4.0 loaded.
Type `(in-package "STELLA")' to execute STELLA commands.
USER(2): 
@end example

To reduce startup time, you might want to create a Lisp image that has
all of STELLA preloaded.

Now type
@example
(in-package "STELLA")
@end example

to enter the @code{STELLA} Lisp package where all the STELLA code resides.

@strong{IMPORTANT}: All unqualified Lisp symbols in this document are
assumed to be in the @code{STELLA} Lisp package.  Moreover, the
@code{STELLA} package does @strong{NOT} inherit anything from the
@code{COMMON-LISP} package (see the file
@file{sources/stella/cl-lib/cl-setup.lisp} for the few exceptions),
hence, you have to explicitly qualify every Lisp symbol you want to use
with @code{CL:}.  For example, to get the result of the previous evaluation you
have to type @code{CL:*} instead of @code{*}.

@c ---------------------------------------------------------------------------

@node C++ Installation, Java Installation, Lisp Installation, Installation
@section C++ Installation

To compile the C++ version of STELLA change to the native C++ directory
and run @code{make}:

@example
% cd native/cpp/stella
% make
@end example

This will compile all STELLA files, the garbage collector and generate a
static or dynamic @file{libstella} library file in the directory
@file{native/cpp/lib} which can later be linked with your own
C++-translated STELLA (or other) code.  To test whether the compilation
was successful you can run STELLA from the top-level STELLA directory
using the @code{stella} script (or @code{stella.bat} under a Windows
command prompt):

@example
% stella c++
Running C++ version of STELLA...
Welcome to STELLA 3.4.0
Running kernel startup code...
Initializing symbol tables...
Initializing quoted constants...
Initializing global variables...
Creating class objects...
Finalizing classes...
Creating method objects...
Finalizing methods...
Running non-phased startup code...
Starting up translators...
Bye!
@end example

This will simply run various STELLA startup code and exit.  @xref{Hello
World in C++}, to see how you can use the STELLA C++ executable to
translate STELLA code.  The @code{c++} argument tells the script to run
the C++ version of STELLA.  If the argument is omitted and the C++
version is installed, it will be run automatically.  Otherwise, the Java
version will be run.

@c ---------------------------------------------------------------------------

@node Java Installation, X/Emacs Setup, C++ Installation, Installation
@section Java Installation

Nothing needs to be done to install the Java version.  Since Java class
files are platform independent, they are already shipped with the STELLA
distribution and can be found in the directory @file{native/java} and
its subdirectories.  Additionally, they have been collected into the
file @file{native/java/lib/stella.jar}.  To try out the Java version of
STELLA run the @code{stella} script in the STELLA directory:

@example
% stella java
Running Java version of STELLA...
Welcome to STELLA 3.4.0
Running kernel startup code...
Initializing symbol tables...
Initializing quoted constants...
Initializing global variables...
Creating class objects...
Finalizing classes...
Creating method objects...
Finalizing methods...
Running non-phased startup code...
Starting up translators...
Bye!
@end example

Similar to the C++ executable, this will simply run various STELLA
startup code and exit.  @xref{Hello World in Java}, to see how you can
use the STELLA Java executable to translate STELLA code.

@c ---------------------------------------------------------------------------

@node X/Emacs Setup, Removing Unneeded Files, Java Installation, Installation
@section X/Emacs Setup

STELLA development is very similar to Lisp development, and it is best
done in an X/Emacs-based Lisp development environment such as the
Allegro-CL Emacs interface plus Allegro Composer, or ILISP.  If you do
use X/Emacs with the Allegro CL interface, add the following to your
@file{.emacs} or @file{.xemacs/init.el} file:

@example
(setq auto-mode-alist
      (cons '("\\.ste$" . fi:common-lisp-mode) auto-mode-alist))
@end example

If you are using the Allegro CL interface, you might want to install the
file @file{emacs/fi-stella.el}, since it sets up proper indentation for
STELLA code and makes looking up STELLA definitions via the @kbd{C-c .} 
or @kbd{M-.} commands work better.  Look at the file
@file{emacs/fi-stella.el} for specific installation instructions.

@c ---------------------------------------------------------------------------

@node Removing Unneeded Files,  , X/Emacs Setup, Installation
@section Removing Unneeded Files

To save disk space you can remove files that you don't need.  For
example, if you are not interested in the C++ version of STELLA, you can
delete the directory @file{native/cpp}.  Similarly, you can remove
@file{native/java} to eliminate all Java-related files.  You could do
the same thing for the Lisp directory @file{native/lisp}, but (in our
opinion) that would make it less convenient for you to develop new STELLA
code.  Finally, if you don't need any of the STELLA sources, you can
delete the directory @file{sources/stella}.  If you don't need local
copies of the STELLA documentation, you can delete parts or all of the
@file{sources/stella/doc} directory.

@c ===========================================================================

@node The STELLA Language, Programming in STELLA, Installation, Top
@chapter The STELLA Language

@menu
* Language Overview::           
* Basic Data Types::            
* Control Structure::           
* Functions::                   
* Classes::                     
* Methods::                     
* Macros::                      
* Modules::                     
@end menu

@node Language Overview, Basic Data Types, The STELLA Language, The STELLA Language
@section Language Overview

STELLA is a strongly typed, object-oriented, Lisp-like language.  STELLA
programs are first translated into either Common Lisp, C++, or Java, and then
compiled with any conventional compiler for the chosen target language to
generate executable code.  Over 95% of the STELLA system is written in STELLA
itself, the rest is written in target-language-specific native code.

The design of STELLA borrows from a variety of programming languages, most
prominently from Common Lisp, and to a lesser degree from other
object-oriented languages such as Eiffel, Sather, and Dylan.  Since STELLA has
to be translatable into C++ and Java, various restrictions of these languages
also influenced its design.

In the following, we assume that the reader is familiar with basic Common Lisp
concepts, and has at least some familiarity with C++ or Java.  Let us start
with a cursory overview of STELLA's main features:

@strong{Syntax:} STELLA uses a parenthesized, uniform expression syntax
similar to Lisp.  Most definitional constructs and control structures
are similar to their Common Lisp analogues with variations to support
types.

@strong{Type system:} STELLA is strongly typed and supports efficient
static compilation similar to C++.  Types are required for the arguments
and return values of functions and methods, for global variables, and
for slot definitions.  Local, lexically scoped variables can be typed
implicitly by relying on type inference.

@strong{Object system:} Types are organized into a single inheritance
class hierarchy.  Restricted multiple inheritance is allowed via mixin
classes.  Dynamic method dispatch is based on the runtime type of the
first argument (similar to C++ and Java).  Slots can be static (native)
or dynamic.  Dynamic slots can be defined at runtime and do not occupy
any space until they are filled.  Slots can have both initial and
default values, and demons can be triggered by slot accesses.  A
meta-object protocol allows the control of object creation,
initialization, termination, and destruction.

@strong{Control structure:} Functions and methods are distinguished.
They can have multiple (zero or more) return values and a variable
number of arguments.  Lisp-style macros are supported to facilitate
syntax extensions.  Expressions and statements are distinguished.  Local
variables are lexically scoped, but dynamically scoped variables
(specials) are also supported.  STELLA has an elegant, uniform, and
efficient iteration mechanism plus a built-in protocol for iterators.
An exception mechanism can be used for error handling and non-local
exits.

@strong{Symbolic programming:} Symbols are first-class objects, and
extensive support for dynamic datatypes such as cons-trees, lists, sets,
association lists, hash tables, extensible vectors, etc., is available.
A backquote mechanism facilitates macro writing and code generation.
Interpreted function call, method call, slot access, and object creation
is supported, and a restricted evaluator is also available.

@strong{Name spaces:} Functions, methods, variables, and classes occupy
separate name spaces (i.e., the same name can be used for a function and
a class).  A hierarchical module system compartmentalizes symbol tables
and supports large-scale programming.

@strong{Memory management:} STELLA relies on automatic memory management
via a garbage collector.  For Lisp and Java the native garbage collector
is used.  For the C++ version of STELLA we use the Boehm- Weiser
conservative garbage collector with good results.  Various built-in
support for explicit memory management is also available.

The Common Lisp features most prominently absent from STELLA are anonymous
functions via lambda abstraction, lexical closures, multi-methods,
full-fledged eval (a restricted evaluator is available), optional and keyword
arguments, and a modifiable readtable.  STELLA does also not allow dynamic
re/definition of functions and classes, even though the Lisp-based development
environment provides this facility (similar to Dylan).  The main influences of
C++ and Java onto STELLA are the strong typing, limited multiple inheritance,
first-argument polymorphism, and the distinction between statements and
expressions.

@c ---------------------------------------------------------------------------
@node Basic Data Types, Control Structure, Language Overview, The STELLA Language
@section Basic Data Types (tbw)
To be written.

@c ---------------------------------------------------------------------------

@node Control Structure, Functions, Basic Data Types, The STELLA Language
@section Control Structure (tbc)
To be completed.

@menu
* Conditionals::                
@end menu

@node Conditionals,  , Control Structure, Control Structure
@subsection Conditionals

STELLA conditionals are very similar to those found in Common-Lisp.
The main difference is that most STELLA conditionals are statements and
therefore do not return a value.  For this reason, a C++-style
@code{choose} directive has been added to the language to allow value
conditionalization based on a boolean expression.

@deffn Statement if condition then-statement else-statement
Evaluate the boolean expression @var{condition}.  If the result is true
execute @var{then-statement}, otherwise, execute @var{else-statement}.
Note that unlike the Common-Lisp version of @code{if} the
@var{else-statement} is not optional in STELLA.  Example:

@example
(if (> x y)
    (print "x is greater than y" EOL)
  (print "x is less than or equal to y" EOL))
@end example
@end deffn

@deffn Statement when condition statement@dots{}
Evaluate the boolean expression @var{condition}.  Only if the result is
true execute the @var{statement'}s in the body.  Example:

@example
(when (symbol? x)
  (print "x is a symbol, ")
  (print "its name is " (symbol-name (cast x SYMBOL)) EOL))
@end example
@end deffn

@deffn Statement unless condition statement@dots{}
Evaluate the boolean expression @var{condition}.  Only if the result is
false execute the @var{statement'}s in the body.  Therefore,
@code{(unless @var{test} @dots{})} is equivalent to @code{(when (not
@var{test}) @dots{})}.  Example:

@example
(unless (symbol? x)
  (print "x is not a symbol, ")
  (print "hence, its name is unknown" EOL))
@end example
@end deffn

@deffn Statement cond clause@dots{}
@code{cond} is a conditional with an arbitrary number of conditions each
represented by a @var{clause}.  Each @code{cond} clause has to be of the
following form:
@example
(@var{condition} @var{statement}@dots{})
@end example
The first @var{clause} whose @var{condition} evaluates to true will be
selected and its @var{statement'}s will be executed.  Each clause can
have 0 or more statements.  The special condition @code{otherwise}
always evaluates to true and can be used for the catch-all case.
Example:

@example
(cond ((symbol? x)
       (print "x is a symbol" EOL))
      ((cons? x)
       (print "x is a cons" EOL))
      (otherwise
       (print "x is an object" EOL)))
@end example
@end deffn

@deffn Expression choose condition true-expression false-expression
Evaluate the boolean expression @var{condition}.  If the result is true
return the value of @var{true-expression}, otherwise, return the value
of @var{false-expression}.  STELLA computes the most specific common
supertype of @var{true-expression} and @var{false-expression} and uses
that as the type returned by the @code{choose} expression.  If no such
type exists, a translation error will be signaled.  Example:

@example
(setq face (choose happy? :smile :frown))
@end example
@end deffn

@deffn Statement case expression clause@dots{}
Each @code{case} clause has to be of one of
the following forms:

@example
(@var{key} @var{statement}@dots{})
((@var{key}@dots{}) @var{statement}@dots{})
@end example

@code{case} selects the first @var{clause} whose @var{key} (or one of
the listed @var{key'}s) matches the result of @var{expression} and
executes the clause's @var{statement'}s.  Each @code{case} @var{key} has
to be a constant such as a number, character, string, symbol, keyword or
surrogate.  Keys are compared with @code{eql?} (or @code{string-eql?} 
for strings).  All keys in a @code{case} statement have to be of the
same type.  The special key @code{otherwise} can be used to catch
everything.  It is a run-time error if no clause with a matching key
exists.  Therefore, a STELLA @code{case} without an @code{otherwise}
clause corresponds to a Common Lisp @code{ecase}.  An empty
@code{otherwise} clause can always be specified via @code{(otherwise
NULL)}.  Example:

@example
(case car-make
  ("Yugo" 
   (setq price :cheap))
  ("VW"   
   (setq price :medium))
  (("Ferrari" "Rolls Royce")
   (setq price :expensive))
  (otherwise 
   (setq price :unknown)))
@end example
@end deffn

@deffn Statement typecase expression clause@dots{}
Each @code{typecase} clause has to be of one of
the following forms:

@example
(@var{type} @var{statement}@dots{})
((@var{type}@dots{}) @var{statement}@dots{})
@end example

@code{typecase} selects the first @var{clause} whose @var{type} (or one
of the listed @var{type'}s) equals or is a supertype of the run-time
type of the result of @var{expression} and then executes the clause's
@var{statement'}s.  Therefore, @code{typecase} can be used to implement
a type dispatch for cases where the run-time type of an expression can
be different from the static type known at translation time.  Currently,
the static type of @var{expression} is required to be a subtype of
@code{OBJECT}.

Each @var{type} expression has to be a symbol describing a simple type
(i.e., parametric or anchored types are not allowed).  Similar to
@code{case}, the special key @code{otherwise} can be used to catch
everything.  It is a run-time error if no clause with a matching type
exists.  Therefore, a STELLA @code{typecase} without an @code{otherwise}
clause corresponds to a Common Lisp @code{etypecase}.  An empty
@code{otherwise} clause can always be specified via @code{(otherwise
NULL)}.  @code{typecase} does allow the value of @var{expression} to be
undefined, in which case the @code{otherwise} clause is selected.
Example:

@example
(typecase (first list)
  (CONS
   (print "it is a cons"))
  ((SYMBOL KEYWORD)
   (print "it is a symbol"))
  (STANDARD-OBJECT
   (print "it is a regular object"))
  (otherwise NULL))
@end example

Note that in the example above it is important to list
@code{STANDARD-OBJECT} after @code{SYMBOL} and @code{CONS}, since it
subsumes the preceding types.  Otherwise, it would always shadow the
clauses with the more specific types.

The semantics of @code{typecase} is slightly extended for the case where
@var{expression} is a local variable.  In that case each reference to
the variable within a @code{typecase} clause is automatically casted to
the appropriate narrower type.  For example, in the code snippet below
method calls such as @code{first} or slot accesses such as
@code{symbol-name} are translated correctly without needing to
explicitly downcast @code{x} which is assumed to be of type
@code{OBJECT}:

@example
(typecase x
  (CONS
   (print "it is a cons with value " (first x)))
  ((SYMBOL KEYWORD)
   (print "it is a symbol with name " (symbol-name x)))
  (STANDARD-OBJECT
   (print "it is a regular object"))
  (otherwise NULL))
@end example
@end deffn

Since the @code{typecase} @var{expression} has to be a subtype of
@code{OBJECT}, a @code{typecase} cannot be used to test against literal
types such as @code{STRING} or @code{INTEGER}.  If such type names are
encountered as keys in a @code{typecase}, they are automatically
converted to their wrapped version, e.g., @code{STRING-WRAPPER},
@code{INTEGER-WRAPPER}, etc.

@c ---------------------------------------------------------------------------

@node Functions, Classes, Control Structure, The STELLA Language
@section Functions (tbw)
To be written.

@c ---------------------------------------------------------------------------

@node Classes, Methods, Functions, The STELLA Language
@section Classes (tbw)
To be written.

@c ---------------------------------------------------------------------------

@node Methods, Macros, Classes, The STELLA Language
@section Methods (tbw)
To be written.

@c ---------------------------------------------------------------------------

@node Macros, Modules, Methods, The STELLA Language
@section Macros (tbw)
To be written.

@c ---------------------------------------------------------------------------

@node Modules,  , Macros, The STELLA Language
@section Modules (tbw)
To be written.

@c ===========================================================================

@node Programming in STELLA, Library Classes, The STELLA Language, Top
@chapter Programming in STELLA

@menu
* Hello World in STELLA::       
* Incrementally Developing STELLA Code::  
* Performance Hints::           
@end menu

@node Hello World in STELLA, Incrementally Developing STELLA Code, Programming in STELLA, Programming in STELLA
@section Hello World in STELLA

Included with the STELLA distribution is a simple Hello World
application that shows you how to organize your own STELLA code and
build a working STELLA application.  The sources for the Hello World
system consist of the following files:

@example
sources/systems/hello-world-system.ste
sources/hello-world/file-a.ste
sources/hello-world/file-b.ste
@end example

STELLA organizes code modules with a simple system facility.
Translation always operates on a complete system, so you always need to
create a system definition for the STELLA files comprising your
application (somewhat similar to what you would put in a Unix Makefile).

For the Hello World system the system definition already exists and
resides in the file @file{sources/systems/hello-world-system.ste}.  By
default, STELLA looks in the directory @file{sources/systems} to find
the definition of a particular system.  @file{hello-world-system.ste}
defines two things:

(1) The @code{HELLO-WORLD} module which defines a namespace for all
objects in the Hello World systems.  STELLA modules are mapped onto
corresponding native namespace constructs, i.e., Lisp packages, C++
namespaces or Java packages.  The exact mapping for each language can be
defined via the keyword options @code{:lisp-package},
@code{:cpp-package} and @code{:java-package} in the module definition,
for example:

@example
(defmodule "HELLO-WORLD"
  :lisp-package "STELLA"
  :cpp-package "hello_world"
  :java-package "edu.isi.hello_world"
  :uses ("STELLA"))
@end example

The @code{:uses} directive tells STELLA from what other modules this one
inherits.

(2) The actual system definitions defining what source files comprise
the system, and what parent systems this one depends on, plus a variety
of other options:

@example
(defsystem HELLO-WORLD
  :directory "hello-world"
  :required-systems ("stella")
  :cardinal-module "HELLO-WORLD"
  :production-settings (1 0 3 3)
  :development-settings (3 2 3 3)
  :files ("file-a"
          "file-b"))
@end example

@c ---------------------------------------------------------------------------

@menu
* Hello World in Lisp::         
* Hello World in C++::          
* Hello World in Java::         
@end menu

@node Hello World in Lisp, Hello World in C++, Hello World in STELLA, Hello World in STELLA
@subsection Hello World in Lisp

To generate a Lisp translation of Hello World you can use either the
Lisp, C++ or Java version of STELLA.  Before you can translate you have
to make sure the following native directories exist:

@example
native/lisp/hello-world/
bin/acl7.0/hello-world/
@end example

The directory @file{native/lisp/hello-world/} will hold the Lisp
translations of the corresponding STELLA source files.  The directory
@file{bin/acl7.0/hello-world/} will hold the compiled Lisp files if you
are using Allegro CL 7.0.  If you are using a different Lisp, one of the
other binary directories as defined in the top-level file
@file{translations.lisp} will be used.  The directory
@file{bin/lisp/hello-world/} will be used as a fall-back if your version
of Lisp is not yet handled in @file{translations.lisp}.

If you create your own system, you will need to create those directories
by hand (future versions of STELLA might do that automatically).  For
the Hello World system these directories already exist.

To generate a Lisp translation of Hello World using Lisp startup a Lisp
version of STELLA (see @ref{Lisp Installation}).  The following idiom
will then translate the system into Lisp and also Lisp-compile and load it.
The first argument to @code{make-system} is the name of the system, and
the second argument indicates into what language it should be
translated:

@example
STELLA(3): (make-system "hello-world" :common-lisp)
Processing `/tmp/stella-3.1.0/sources/hello-world/file-a.ste':
*** Pass 1, generating objects...
Processing `/tmp/stella-3.1.0/sources/hello-world/file-b.ste':
*** Pass 1, generating objects...
   .........................................
;;; Writing fasl file
;;;   /tmp/stella-3.1.0/native/lisp/bin/acl7.0/hello-world/startup-system.fasl
;;; Fasl write complete
; Fast loading
;    /tmp/stella-3.1.0/native/lisp/bin/acl7.0/hello-world/startup-system.fasl
CL:T
STELLA(4): 
@end example

After the system is loaded you can call its @code{main} function:

@example
STELLA(10): (main)
Hello World A
Hello World B
bye
()
STELLA(11): 
@end example

Using @code{main} in the Lisp version will not always make sense, since
you can call any function directly at the Lisp top level, but both C++
and Java always need a @code{main} function as a top-level entry point.

While this would be somewhat unusual, you could also generate the Lisp
translation using the C++ or Java version of STELLA.  The easiest way to
do that is to run the @code{stella} script in the STELLA directory like
this:

@example
% ./stella -e '(make-system "hello-world" :common-lisp)'
Running C++ version of STELLA...
Welcome to STELLA 3.4.0
Processing `sources/hello-world/file-a.ste':
*** Pass 1, generating objects...
Processing `sources/hello-world/file-b.ste':
*** Pass 1, generating objects...
  ...............................................
Translating `sources/hello-world/file-a.ste' to `Common Lisp'...
Writing `native/lisp/hello-world/file-a.lisp'...
Translating `sources/hello-world/startup-system.ste' to `Common Lisp'...
Writing `native/lisp/hello-world/startup-system.lisp'...
@end example

The @code{-e} command line option is used to evaluate an evaluable
STELLA command.  Conveniently, @code{make-system} is such a command, so
you can supply a @code{make-system} form to the C++ or Java version of
STELLA just as you would do in Lisp.  Note the extra quotes around the
expression to protect the characters from interpretation by the Unix
shell.

To compile and load the translated Lisp files into Lisp you then have to
startup a Lisp version of STELLA and call @code{make-system} again which
now will only compile and load the necessary files, since the
translations have already been generated in the previous step.

@c ---------------------------------------------------------------------------

@node Hello World in C++, Hello World in Java, Hello World in Lisp, Hello World in STELLA
@subsection Hello World in C++

To generate a C++ translation of Hello World you can use either the
Lisp, C++ or Java version of STELLA.  Before you can translate you have
to make sure the following native directory exists:

@example
native/cpp/hello-world/
@end example

The directory @file{native/cpp/hello-world/} will hold the C++
translations of the corresponding STELLA source files.  If you create
your own system, you will need to create this directory by hand (future
versions of STELLA might do that automatically).  For the Hello World
system the directory already exist.

To generate a C++ translation of Hello World using Lisp startup a Lisp
version of STELLA (see @ref{Lisp Installation}).  The following idiom
will then translate the system into C++.  The first argument to
@code{make-system} is the name of the system, and the second argument
indicates into what language it should be translated:

@example
STELLA(4): (make-system "hello-world" :cpp)
Processing `/tmp/stella-3.1.0/sources/hello-world/file-a.ste':
*** Pass 1, generating objects...
Processing `/tmp/stella-3.1.0/sources/hello-world/file-b.ste':
*** Pass 1, generating objects...
  ...............................................
Writing `/tmp/stella-3.1.0/native/cpp/hello-world/file-b.hh'...
Writing `/tmp/stella-3.1.0/native/cpp/hello-world/file-b.cc'...
Translating `/tmp/stella-3.1.0/sources/hello-world/startup-system.ste'.
Writing `/tmp/stella-3.1.0/native/cpp/hello-world/startup-system.hh'...
Writing `/tmp/stella-3.1.0/native/cpp/hello-world/startup-system.cc'...
:VOID
STELLA(5): 
@end example

Alternatively, you can generate the translation using the C++ or Java
version of STELLA.  The easiest way to do that is to run the
@code{stella} script in the STELLA directory like this:

@example
% ./stella -e '(make-system "hello-world" :cpp)'
Running C++ version of STELLA...
Welcome to STELLA 3.4.0
Processing `sources/hello-world/file-a.ste':
*** Pass 1, generating objects...
Processing `sources/hello-world/file-b.ste':
*** Pass 1, generating objects...
  ...............................................
Writing `native/cpp/hello-world/file-b.hh'...
Writing `native/cpp/hello-world/file-b.cc'...
Translating `sources/hello-world/startup-system.ste'.
Writing `native/cpp/hello-world/startup-system.hh'...
Writing `native/cpp/hello-world/startup-system.cc'...
@end example

The @code{-e} command line option is used to evaluate an evaluable
STELLA command.  Conveniently, @code{make-system} is such a command, so
you can supply a @code{make-system} form to the C++ or Java version of
STELLA just as you would do in Lisp.  Note the extra quotes around the
expression to protect the characters from interpretation by the Unix
shell.

Different from Lisp, neither of the above idioms will compile and load
the generated C++ code.  Instead you have to use the Unix @file{make}
facility to compile and link the C++ sources.  First change into the
native @file{hello-world} directory and then call @code{make}
(@strong{important}: the generated Makefiles currently require the GNU
version of @code{make}):

@example
% cd native/cpp/hello-world/
% make
g++ -w -g -O2  -DSTELLA_USE_GC -I../stella/cpp-lib/gc/include \ 
    -c -I.. main.cc
g++ -w -g -O2  -DSTELLA_USE_GC -I../stella/cpp-lib/gc/include \ 
    -c -I.. file-a.cc
g++ -w -g -O2  -DSTELLA_USE_GC -I../stella/cpp-lib/gc/include \ 
    -c -I.. file-b.cc
g++ -w -g -O2  -DSTELLA_USE_GC -I../stella/cpp-lib/gc/include \ 
    -c -I.. startup-system.cc
  ..................................
g++ -dynamic  -L../stella/cpp-lib/gc -Xlinker -rpath -Xlinker \
       '../lib:/tmp/stella-3.1.0/native/cpp/lib' \
       main.o -o hello-world \
       -L../lib -lhello-world -L../lib -lstella -lgc -lm
@end example

The first time around this will also compile the C++ version of STELLA
and the C++ garbage collector and create a STELLA library file.  Future
builds of the Hello World and other systems will use the STELLA library
file directly.  To run the Hello World system simply run the
@file{hello-world} executable that was built in the previous step:

@example
% ./hello-world
Hello World A
Hello World B
bye
@end example

@c ---------------------------------------------------------------------------

@node Hello World in Java,  , Hello World in C++, Hello World in STELLA
@subsection Hello World in Java

To generate a Java translation of Hello World you can use either the
Lisp, C++ or Java version of STELLA.  Before you can translate you have
to make sure the following native directory exists:

@example
native/java/edu/isi/hello-world/
@end example

The directory @file{native/java/edu/isi/hello-world/} will hold the Java
translations of the corresponding STELLA source files.  If you create
your own system, you will need to create this directory by hand (future
versions of STELLA might do that automatically).  For the Hello World
system the directory already exist.

Note that following Java convention we use the package
@code{edu.isi.hello_world} to hold the Hello World system.  This was
specified via the @code{:java-package} option in the definition of the
@code{HELLO-WORLD} module.  Also note that we use @code{hello_world}
instead of @code{hello-world} as the package name, since a dash cannot
legally appear as part of a Java identifier.

To generate a Java translation of Hello World using Lisp startup a Lisp
version of STELLA (see @ref{Lisp Installation}).  The following idiom
will then translate the system into Java.  The first argument to
@code{make-system} is the name of the system, and the second argument
indicates into what language it should be translated:

@example
STELLA(5): (make-system "hello-world" :java)
Processing `/tmp/stella-3.1.0/sources/hello-world/file-a.ste':
*** Pass 1, generating objects...
   ..............................................
Writing `/tmp/stella-3.1.0/native/java/hello_world/Startup_Hello_...
:VOID
STELLA(6): 
@end example

Alternatively, you can generate the translation using the C++ or Java
version of STELLA.  The easiest way to do that is to run the
@code{stella} script in the STELLA directory like this:

@example
% ./stella -e '(make-system "hello-world" :java)'
Running C++ version of STELLA...
Welcome to STELLA 3.4.0
Processing `sources/hello-world/file-a.ste':
*** Pass 1, generating objects...
Processing `sources/hello-world/file-b.ste':
*** Pass 1, generating objects...
  ...............................................
Writing `native/java/edu/isi/hello_world/HelloWorld.java'...
Writing `native/java/edu/isi/hello_world/StartupFileA.java'...
Writing `native/java/edu/isi/hello_world/StartupFileB.java'...
Writing `native/java/edu/isi/hello_world/StartupHelloWorldSystem.java'...
@end example

The @code{-e} command line option is used to evaluate an evaluable
STELLA command.  Conveniently, @code{make-system} is such a command, so
you can supply a @code{make-system} form to the C++ or Java version of
STELLA just as you would do in Lisp.  Note the extra quotes around the
expression to protect the characters from interpretation by the Unix
shell.

Different from Lisp, neither of the above idioms will compile and load
the generated C++ code.  Instead you have to use the Java compiler to
compile and Java to run the compiled Java sources.  First change into
the top-level native Java directory @file{native/java} and then compile
and run the Hello World system like this:

@example
% cd native/java/
% javac edu/isi/hello_world/*.java
% java edu.isi.hello_world.HelloWorld
Hello World A
Hello World B
bye
@end example

It is not necessary to Java-compile STELLA first, since STELLA already
ships with a Java compilation of the STELLA system.

@c ---------------------------------------------------------------------------

@node Incrementally Developing STELLA Code, Performance Hints, Hello World in STELLA, Programming in STELLA
@section Incrementally Developing STELLA Code

The preferred method of STELLA code development is to use a Lisp-based
version of STELLA for all the prototyping and testing, since that allows
you to exploit most (or all) of the rapid-prototyping advantages of
Lisp.  Once a system has reached a certain point of stability, it can be
translated into C++ or Java for delivery or to interface it with other
C++ or Java code.

In the following, we assume an X/Emacs-based Lisp development
environment such as the Allegro CL Emacs interface, where Lisp is run in
an Emacs subprocess, and Lisp source can be compiled and evaluated
directly from the source buffers.  By "Lisp buffer" we mean the listener
buffer in which Lisp is actually running, and by "source buffer" we mean
a buffer that is used to edit a file that contains STELLA source.

Included in the distribution is the Hello World system comprised of the
files

@example
sources/systems/hello-world-system.ste
sources/hello-world/file-a.ste
sources/hello-world/file-b.ste
@end example

To get started, simply add your code to either @file{file-a.ste} or
@file{file-b.ste}, since all the necessary definitions and directories
for these files are already set up properly.  See section ??? on how to
setup your own system.

Make sure the Hello World system is loaded into Lisp by doing the
following:

@example
(make-system "hello-world" :common-lisp)
@end example

This will make sure that the system definition is loaded and the
necessary module definition is evaluated.

Now suppose you add the following function to @file{file-a.ste}:

@example
(defun (factorial INTEGER) ((n INTEGER))
  (if (eql? n 0)
      (return 1)
    (return (* n (factorial (1- n))))))
@end example

There are various options for translating and evaluating this
definition.  For example, you can simply remake the complete system
similar to what you would do for a C++ or Java program:

@example
(make-system "hello-world" :common-lisp)
@end example

This will retranslate the modified files, recompile them and reload them
into your Lisp image.

Instead of retranslating and recompiling everything, you can
incrementally evaluate the definition of @code{factorial} from your
Emacs-to-Lisp interface.  Simply put your cursor somewhere inside the
definition in the source buffer and evaluate it by typing @kbd{M-C-x}.
This translates the STELLA code into Lisp and compiles (or evaluates)
the resulting Lisp code.  Now you can actually try it out in the Lisp
buffer, for example:

@example
STELLA(4): (factorial 6)
720
@end example

Finally, instead of evaluating the definition in the source buffer, you
can also enter it directly at the Lisp prompt with the same effect.  

The way this works is that the Lisp symbol @code{stella::defun} is
actually bound to a Lisp macro that calls all the necessary translation
machinery to convert the STELLA @code{defun} into Lisp code.  Look at
the file @file{sources/stella/cl-lib/stella-to-cl.ste} for the complete
set of such macros.  This might be a bit confusing, since there are now
three different bindings (or meanings) of @code{defun}:

@enumerate
@item
The STELLA operator @code{defun} used to define STELLA functions.

@item
The Lisp macro @code{stella::defun} that resides in the @code{STELLA}
Lisp package and is only available for convenience in Lisp versions of
STELLA.

@item
The Lisp macro @code{CL:defun} which is the standard Common Lisp macro
used to define Lisp functions.
@end enumerate

We'll try to explicitly qualify which meaning is used wherever there
might be some doubt which one is meant.  In general, every unqualified
symbol mentioned below is either part of the STELLA language or resides
in the STELLA Lisp package.

Since a newly-written STELLA function might have errors, it is prudent
to first only translate it without actually executing the result of the
translation.  In the source buffer you can do that by macro-expanding
the @code{defun}.  For example, if you use the Allegro CL interface you
would position the cursor on the opening parenthesis of the @code{defun}
and then type @kbd{M-M}.  Any errors discovered by the STELLA translator
are reported in the Lisp buffer window.  The expansion will be a
@code{CL:progn} that contains the translated definition as the first
element plus various startup-time (initialization) code following it.

In the Lisp buffer you can achieve a similar effect with the
@code{lptrans} macro.  For example, executing

@example
(lptrans
 (defun (factorial INTEGER) ((n INTEGER))
   (if (eql? n 0)
       (return 1)
     (return (* n (factorial (1- n)))))))
@end example

in the Lisp buffer first Lisp-translates the definition, and then prints
the translation.  To see the C++ translation you can use
@code{cpptrans}, calling @code{jptrans} will generate the Java
translation.

You can also use @code{lptrans}/@code{cpptrans}/@code{jptrans} to
translate code fragments that are not top-level definitions such as
@code{defun} and its friends.  For example:

@example
STELLA(8): (lptrans
            (foreach element in (list 1 2 3)
                do (print element EOL)))

(CL:LET* ((ELEMENT NULL)
          (ITER-003
           (%THE-CONS-LIST (LIST (WRAP-INTEGER 1) (WRAP-INTEGER 2)
                                 (WRAP-INTEGER 3)))))
  (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
           (CL:PROGN (SETQ ELEMENT (%%VALUE ITER-003))
                     (SETQ ITER-003 (%%REST ITER-003)))
           (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) 
                           ELEMENT EOL)))
()
STELLA(9): (cpptrans
            (foreach element in (list 1 2 3)
                do (print element EOL)))
@{ Object* element = NULL;
  Cons* iter004 = list(3, wrapInteger(1), wrapInteger(2),
                          wrapInteger(3))-> theConsList;

  while (!(iter004 == NIL)) @{
    element = iter004->value;
    iter004 = iter004->rest;
    cout << element << endl;
  @}
@}
:VOID
STELLA(10): (jptrans
             (foreach element in (list 1 2 3)
                 do (print element EOL)))
@{ Stella_Object element = null;
  Cons iter005 = Stella.list
                  (Stella_Object.cons
                    (IntegerWrapper.wrapInteger(1), 
                     Stella_Object.cons
                      (IntegerWrapper.wrapInteger(2), 
                       Stella_Object.cons
                        (IntegerWrapper.wrapInteger(3), 
                         Stella.NIL)))).theConsList;

  while (!(iter005 == Stella.NIL)) @{
    @{
      element = iter005.value;
      iter005 = iter005.rest;
    @}
    java.lang.System.out.println(element);
  @}
@}
:VOID
@end example

The use of @code{lptrans} is really necessary here, since there is no
Lisp macro @code{foreach} that knows how to translate STELLA
@code{foreach} loops (those Lisp macros only exist for top-level
definition commands such as @code{defun}).  In order to translate such
code fragments without error messages, they need to be self-contained,
i.e., all referenced variables have to be either bound by a surrounding
@code{let}, or they must be globally defined variables.  Otherwise, the
STELLA translator will generate various "undefined variable" error
messages.

You can use the STELLA Lisp macro @code{eval} (i.e., @code{stella::eval}
not @code{CL:eval}) to actually execute such a code fragment.  For
example:

@example
STELLA(11): (eval
             (foreach element in (list 1 2 3)
                 do (print element EOL)))
|L|1
|L|2
|L|3
()
@end example

This translates the loop and executes the result, which prints the
wrapped numbers (hence, the @code{|L|} prefix) to standard output.  The
@code{()} at the end is the resulting Lisp value returned by the loop
(in Lisp everything returns a value, even though for STELLA
@code{foreach} is a statement, not an expression).

Make it a habit to wrap @code{eval} around any STELLA code you
incrementally evaluate in the Lips buffer.  This makes sure that all the
arguments to a function, etc., are translated into the appropriate
STELLA objects.  For example, evaluating

@example
(eval (list :a :b :c))
@end example

in the Lisp buffer generates a STELLA list that points to the STELLA
keywords @code{:a}, @code{:b} and @code{:c}.  If you don't use
@code{eval}, for example,

@example
(list :a :b :c)
@end example

a STELLA list containing the Lisp keywords `:a', `:b' and `:c' will be
created.  Lisp keywords are a completely different data structure than
STELLA keywords, and any STELLA code expecting a STELLA keyword but
finding a Lisp keyword will break, since Lisp keywords are not a legal
STELLA data structure.  Unfortunately, such cases can be very confusing,
since Lisp and STELLA keywords look/print exactly alike.

@code{eval} is also necessary to access STELLA symbols and surrogates in
the Lisp buffer.  For example, to access a STELLA symbol, you can use
@code{quote} (again, this is the STELLA @code{quote} not
@code{CL:quote}):

@example
(eval (quote foo))
@end example

This returns the STELLA symbol @code{foo}.  We explicitly used
@code{quote} here, since code typed at the Lisp prompt is first passed
through the Lisp reader before the STELLA translator sees it, and the
default Lisp reader interprets the @code{'} character differently than
the STELLA reader.  Within a STELLA file you can use the syntax
@code{'foo}, since it will be read directly by the STELLA reader that
knows how to interpret it correctly.

@code{lptrans}, @code{cpptrans} and @code{jptrans} are evaluable STELLA
commands that can also be evaluated by the C++ and Java version of
STELLA.  For example, to generate a Java translation of a little STELLA
code fragment you could run the @code{stella} script in the STELLA
directory like this (the output below has been additionally indented by
hand for clarity):

@example
% ./stella -e '(jptrans\
                 (foreach element in (list 1 2 3)\
                    do (print element EOL)))'
Running C++ version of STELLA...
Welcome to STELLA 3.4.0
@{ Stella_Object element = null;
  Cons iter001 = Stella.list
                  (Stella_Object.cons
                    (IntegerWrapper.wrapInteger(1), 
                     Stella_Object.cons
                      (IntegerWrapper.wrapInteger(2), 
                       Stella_Object.cons
                        (IntegerWrapper.wrapInteger(3), 
                         Stella.NIL)))).theConsList;

  while (!(iter001 == Stella.NIL)) @{
    @{
      element = iter001.value;
      iter001 = iter001.rest;
    @}
    java.lang.System.out.println(element);
  @}
@}
@end example

@node Performance Hints,  , Incrementally Developing STELLA Code, Programming in STELLA
@section Performance Hints

Here are a few things to watch out for once you get serious about the
performance of your translated STELLA programs:

@strong{Safety checks:} The STELLA variable @code{*safety*} controls
whether certain safety code is added to your translated STELLA program.
For Lisp translations it also controls whether @code{cast}'s will be
translated into run-time type checks or not.  There is no run-time type
checking performed in C++.  In Java native casts will always perform
runtime type tests.  The default @code{*safety*} level is 3 which
enables the translation of all @code{safety} clauses with level 3 or
lower.  A safety level of 1 or lower disables the generation of calls to
the @code{cast} function in Lisp.  @code{cast} performs run-time type
checks which are somewhat expensive.  However, you should not disable
run-time type checking in Lisp until you have fully debugged your
program.  Once you are confident that your program works correctly, you
can set @code{*safety*} to 0 before you translate it.  That way you will
avoid the generation and execution of any safety code at all.  All of
the core STELLA system was translated with @code{*safety*} set to 1.

@strong{Quoted cons trees:} Access to quoted constants that are not
symbols is somewhat slow, since it currently uses hashing to find them
in a table.  Hence, access to quoted constants such as @code{(quote (foo
bar fum))} should be avoided in inner loops.  Access to quoted symbols
such as @code{(quote foo)} is fast and does not cause any performance
problems.  The use of @code{quote} for constant cons trees is rare in
STELLA (and somewhat deprecated), which is the reason why this mechanism
is not all that well supported.  Future versions of STELLA might
re-implement the handling of constants and alleviate this performance
problem.

@strong{Equality tests:} The standard equality test in STELLA is
@code{eql?}, which the translator will translate into the most efficient
equality test for the particular types of operands (@code{eql?} is
somewhat similar to the Lisp function @code{CL:eql} with the exception
of comparing strings).  If the translator can determine that at least
one of the operands is a subtype of @code{STANDARD-OBJECT}, it will
translate the test into a fast pointer comparison with the Lisp function
@code{CL:eq} or the C++/Java @code{==} operator.  However, if both
operands are of type @code{OBJECT}, they might be wrapped literals such
as wrapped integers or strings.  In that case the equality test
translates into a call to the function @code{eql?} which in turn uses
method calls to handle comparison of different types of wrapped literals
(two wrapped literals are equal if their wrapped content is equal).
This is of course a lot less efficient than a simple pointer comparison.
It also means that if you can restrict the type of a variable that will
be tested with @code{eql?} to @code{STANDARD-OBJECT}, you probably
should do so for performance reasons.

@strong{Type tests:} Run-time type tests as used implicitly within a
@code{typecase} or explicitly with functions such as @code{cons?} have
to use a call to the method @code{primary-type}.  Hence, in
performance-critical portions of your code you should try to keep the
number of such tests as small as possible.

@strong{Wrapping and unwrapping literals:} The STELLA translator
automatically wraps (or objectifies) literals such as numbers or strings
when they are stored in a variable or slot of type @code{OBJECT}.
Similarly, it unwraps wrapped literals automatically to operate on the
literal directly.  This is very convenient, since it relieves the
programmer from having to perform these conversions by hand and makes
the code less cluttered.  For example, consider the following code
fragment:

@example
(let ((l (cons "foo" nil))
      (x (concatenate "bar" (first l))))
  (print x EOL)))
@end example
Here is its C++ translation:
@example
@{ Cons* l = cons(wrapString("foo"), NIL);
   char* x = stringConcatenate
              ("bar", ((StringWrapper*)(l->value))->wrapperValue, 0);

  std::cout << x << std::endl;
@}
@end example

Notice how the string literal @code{"foo"} is first wrapped so it can be
inserted into the @code{CONS} list @code{l} and then automatically
unwrapped in the call to @code{concatenate}.  While this is very
convenient, it does cause a certain overhead that should be avoided in
performance critical loops, etc.  In such situations, it often helps to
use auxiliary variables of the appropriate literal type to avoid
unnecessary wrap/unwrap operations.

@strong{Lisp-style property lists:} Lisp programs often use property
lists for fast retrieval of information that is linked to symbols.  To
support the easy translation of existing Lisp programs that use this
paradigm into STELLA, a similar mechanism implemented by the functions
@code{symbol-value}, @code{symbol-plist}, and @code{symbol-property} is
available that preserves the performance benefits of this storage scheme
(see the file @code{sources/stella/symbols.ste}).  However, property
lists do not fit the object-oriented programming paradigm supported by
STELLA, and, hence, are frowned upon.

@strong{Compiler optimization:} The optimization settings used with the
native Lisp or C++ compiler can greatly influence performance results.
In particular, using high optimization settings with the Lisp compiler
can greatly improve slot access time on STELLA objects.

@menu
* Lisp Performance Hints::      
@end menu

@node Lisp Performance Hints,  , Performance Hints, Performance Hints
@subsection Lisp Performance Hints

The standard Lisp implementation for STELLA objects are CLOS objects,
since CLOS provides the most natural Lisp implementation for the STELLA
object system.  However, there is a price to pay, since in Lisp slot
access on CLOS objects is a lot slower than slot access on structs.  For
example, in Allegro CL 4.3, the access to the @code{value} slot of a
STELLA CONS cell takes about 4 times longer on a CLOS object
implementation of @code{CONS} than on a struct implementation.
Unfortunately, the struct implementation itself takes about 3 times
longer than calling @code{CL:car} on a Lisp cons, which is why we are
actually using Lisp conses as the Lisp implementation for STELLA
@code{CONS}es.  Note, that in the C++ and Java translation these
slot-access performance problems are nonexistent.

In order to get the maximum performance out of the Lisp version of
STELLA, you can tell the translator to use structs as the implementation
for STELLA objects.  It does so by using @code{CL:defstruct} instead of
@code{CL:defclass} and dispatches methods directly on the structure
object.

To use the struct translation scheme evaluate

@example
(set-stella-feature :use-common-lisp-structs)
@end example

before you translate a STELLA system.  This will generate translated
files with a @code{.slisp} extension.  Make sure that after you
translated all the files you are interested in, you disable the above
feature with

@example
(unset-stella-feature :use-common-lisp-structs)
@end example

Otherwise, subsequent incremental translations in that Lisp image might
fail, since different translation schemes cannot be mixed.  If you
already are using the struct version of STELLA, all systems will be
translated in struct mode by default.

To use the struct translation of your system you have to use the struct
version of STELLA.  To do so do the following:

@example
(CL:setq cl-user::*load-cl-struct-stella?* CL:t)
(CL:load "load-stella.lisp")
@end example

Alternatively, you can edit the initial value of the variable
@code{*load-cl-struct-stella?*} in the file @file{load-stella.lisp}
(see also @ref{Lisp Installation}).

The reasons why the struct translation scheme is not enabled by
default are the following:

@itemize
@item
Incremental redefinition of STELLA classes does not redefine any objects
created with the old definition, and, hence, slot accessors might simply
break or retrieve the value of a different slot when applied to such an
old object.  The programmer therefore has to be very careful when
redefining a STELLA class while in struct mode.  This means, that you
should view the usage of the struct-translation scheme for Lisp as a kind
of delivery option, similar to translating into C++.  Part of the reason
why slot access on CLOS object is expensive is the indirection machinery
that allows redefinition of classes and their associated instances.
This is great for code development, but the flexibility and expense is
usually not needed or warranted for delivered code.

@item
The performance trade-offs between CLOS and struct versions might be
different in different versions of Lisp.  For example, in older version
of Allegro CL slot access on structs was fast, but method dispatch was
significantly slower than for CLOS objects which eliminated some/all of
the performance gains.
@end itemize

@c ===========================================================================

@node Library Classes, Library Functions, Programming in STELLA, Top
@chapter Library Classes (tbw)
To be written.

@c ===========================================================================

@node Library Functions, Function Index, Library Classes, Top
@chapter Library Functions

@c ---------------------------------------------------------------------------

@menu
* Basic Constants and Predicates::  
* Numbers::                     
* Characters::                  
* Strings::                     
* CONS Lists and Trees::        
* Lists::                       
* Property and Key-Value Lists::  
* Vectors::                     
* Hash Tables::                 
* Key Value Maps::              
* Hash Sets::                   
* Iterators::                   
* Symbols::                     
* Contexts and Modules::        
* Input and Output::            
* Files::                       
* Dates and Times::             
* XML Support::                 
* Miscellaneous::               
@end menu

@node Basic Constants and Predicates, Numbers, Library Functions, Library Functions
@section Basic Constants and Predicates


@deffn ??? true
Not yet implemented.
@end deffn

@deffn ??? false
Not yet implemented.
@end deffn

@c # $(util/texinfo-insert-doc UNKNOWN.null?)
@defmethod @sc{object} null? (x) : @sc{boolean} 
Return true if @var{x} is undefined (handled specially by all translators).
@end defmethod

@defmethod @sc{second-class-object} null? (x) : @sc{boolean} 
Return true if @var{x} is undefined (handled specially by all translators).
@end defmethod

@defmethod @sc{native-vector} null? (x) : @sc{boolean} 
Return true if @var{x} is undefined (handled specially by all translators).
@end defmethod

@defmethod @sc{string} null? (x) : @sc{boolean} 
Return true if @var{x} is undefined (handled specially by all translators).
@end defmethod

@defmethod @sc{mutable-string} null? (x) : @sc{boolean} 
Return true if @var{x} is undefined (handled specially by all translators).
@end defmethod

@defmethod @sc{character} null? (x) : @sc{boolean} 
Return true if @var{x} is undefined (handled specially by all translators).
@end defmethod

@defmethod @sc{code} null? (x) : @sc{boolean} 
Return true if @var{x} is undefined (handled specially by all translators).
@end defmethod

@defmethod @sc{integer} null? (x) : @sc{boolean} 
Return true if @var{x} is undefined (handled specially by all translators).
@end defmethod

@defmethod @sc{float} null? (x) : @sc{boolean} 
Return true if @var{x} is undefined (handled specially by all translators).
@end defmethod

@c # $(util/texinfo-insert-doc UNKNOWN.defined?)
@defmethod @sc{object} defined? (x) : @sc{boolean} 
Return true if @var{x} is defined (handled specially by all translators).
@end defmethod

@defmethod @sc{second-class-object} defined? (x) : @sc{boolean} 
Return true if @var{x} is defined (handled specially by all translators).
@end defmethod

@defmethod @sc{native-vector} defined? (x) : @sc{boolean} 
Return true if @var{x} is defined (handled specially by all translators).
@end defmethod

@defmethod @sc{string} defined? (x) : @sc{boolean} 
Return true if @var{x} is defined (handled specially by all translators).
@end defmethod

@defmethod @sc{mutable-string} defined? (x) : @sc{boolean} 
Return true if @var{x} is defined (handled specially by all translators).
@end defmethod

@defmethod @sc{character} defined? (x) : @sc{boolean} 
Return true if @var{x} is defined (handled specially by all translators).
@end defmethod

@defmethod @sc{code} defined? (x) : @sc{boolean} 
Return true if @var{x} is defined (handled specially by all translators).
@end defmethod

@defmethod @sc{integer} defined? (x) : @sc{boolean} 
Return true if @var{x} is defined (handled specially by all translators).
@end defmethod

@defmethod @sc{float} defined? (x) : @sc{boolean} 
Return true if @var{x} is defined (handled specially by all translators).
@end defmethod

@deffn Function eq? (@w{(x @sc{unknown})} @w{(y @sc{unknown})}) : @sc{boolean} 
Return true if @var{x} and @var{y} are literally the same object (or
simple number).  Analogue to the Common Lisp EQL and C++ and Java's ==.
@end deffn

@deffn Function eql? (@w{(x @sc{object})} @w{(y @sc{object})}) : @sc{boolean} 
Return true if @var{x} and @var{y} are @code{eq?} or equivalent literals
such as strings that also might be wrapped in non-identical wrappers.  For
the case where @var{x} or @var{y} are plain literals such as strings or integers, the
STELLA translator substitutes the equality test appropriate for the particular
target language and does not actually call this function.  For cases where
@var{x} or @var{y} are known to be of type STANDARD-OBJECT, the STELLA translator
substitutes the faster @code{eq?} test inline.
@end deffn

@deffn Function equal? (@w{(x @sc{object})} @w{(y @sc{object})}) : @sc{boolean} 
Return true if @var{x} and @var{y} are @code{eql?} or considered equal
by a user-defined @code{object-equal?} method.  This implements a fully extensible
equality test similar to Java's @code{equals} method.  Note that writers of custom
@code{object-equal?} methods must also implement a corresponding @code{equal-hash-code}
method.
@end deffn

@defmethod @sc{object} object-equal? (x @w{(y @sc{object})}) : @sc{boolean} 
Return true if @var{x} and @var{y} are @code{eq?}.
@end defmethod

@defmethod @sc{wrapper} object-equal? (x @w{(y @sc{object})}) : @sc{boolean} 
Return true if @var{x} and @var{y} are literal wrappers whose
literals are considered @code{eql?}.
@end defmethod


@c ---------------------------------------------------------------------------

@node Numbers, Characters, Basic Constants and Predicates, Library Functions
@section Numbers

@defvr Constant pi : @sc{float}
A float approximation of the mathematical constant pi.
@end defvr

@deffn Function + (@w{&rest (arguments @sc{number})}) : @sc{number} 
Return the sum of all @var{arguments}.
@end deffn

@deffn Function - (@w{(x @sc{number})} @w{&rest (arguments @sc{number})}) : @sc{number} 
If only @var{x} was supplied return the result of 0 - @var{x}.
Otherwise, return the result of (...((@var{x} - arg1) - arg2) - ... - argN).
@end deffn

@deffn Function * (@w{&rest (arguments @sc{number})}) : @sc{number} 
Return the product of all @var{arguments}.
@end deffn

@deffn Function / (@w{(x @sc{number})} @w{&rest (arguments @sc{number})}) : @sc{number} 
If only @var{x} was supplied return the result of 1 / @var{x}.
Otherwise, return the result of (...((@var{x} / arg1) / arg2 ) / ... / argN).
@end deffn

@deffn Macro 1+ (@w{(expression @sc{object})}) : @sc{object} 
Add 1 to @var{expression} and return the result.
@end deffn

@deffn Macro 1- (@w{(expression @sc{object})}) : @sc{object} 
Subtract 1 from @var{expression} and return the result.
@end deffn

@deffn Macro ++ (@w{(place @sc{object})} @w{&body (increment @sc{cons})}) : @sc{object} 
Increment the value of @var{place} and return the result.
@var{place} can be either a variable name or a slot reference.  Increment by
the optional @var{increment} (which can be a float) or 1 otherwise.
@end deffn

@deffn Macro -- (@w{(place @sc{object})} @w{&body (decrement @sc{cons})}) : @sc{object} 
Decrement the value of @var{place} and return the result.
@var{place} can be either a variable name or a slot reference.  Decrement by
the optional @var{decrement} (which can be a float) or 1 otherwise.
@end deffn

@deffn Function = (@w{(x @sc{number})} @w{(y @sc{number})}) : @sc{boolean} 
Return true if @var{x} and @var{y} are numbers of exactly the same magnitude.
@end deffn

@deffn Function < (@w{(x @sc{number})} @w{(y @sc{number})}) : @sc{boolean} 
Return true if @var{x} is less than @var{y}.
@end deffn

@deffn Function <= (@w{(x @sc{number})} @w{(y @sc{number})}) : @sc{boolean} 
Return true if @var{x} is less than or equal to @var{y}.
@end deffn

@deffn Function >= (@w{(x @sc{number})} @w{(y @sc{number})}) : @sc{boolean} 
Return true if @var{x} is greater than or equal to @var{y}.
@end deffn

@deffn Function > (@w{(x @sc{number})} @w{(y @sc{number})}) : @sc{boolean} 
Return true if @var{x} is greater than @var{y}.
@end deffn

@deffn Function zero? (@w{(x @sc{integer})}) : @sc{boolean} 
Return true if @var{x} is 0.
@end deffn

@deffn Function plus? (@w{(x @sc{integer})}) : @sc{boolean} 
Return true if @var{x} is greater than 0.
@end deffn

@deffn Function even? (@w{(x @sc{integer})}) : @sc{boolean} 
Return true if @var{x} is an even number.
@end deffn

@deffn Function odd? (@w{(x @sc{integer})}) : @sc{boolean} 
Return true if @var{x} is an odd number.
@end deffn

@deffn Function div (@w{(x @sc{integer})} @w{(y @sc{integer})}) : @sc{integer} 
Return the integer quotient from dividing @var{x} by @var{y}.
@end deffn

@deffn Function rem (@w{(x @sc{integer})} @w{(y @sc{integer})}) : @sc{integer} 
Return the remainder from dividing @var{x} by @var{y}.  The
sign of the result is always the same as the sign of @var{x}.  This has slightly
different behavior than the @code{mod} function, and has less overhead in C++ and
Java, which don't have direct support for a true modulus function.
@end deffn

@deffn Function mod (@w{(x @sc{integer})} @w{(modulus @sc{integer})}) : @sc{integer} 
True modulus.  Return the result of @var{x} mod @code{modulo}.
Note: In C++ and Java, @code{mod} has more overhead than the similar
function @code{rem}.  The  answers returned by @code{mod} and @code{rem} are only
different when the signs of @var{x} and @code{modulo} are different.
@end deffn

@deffn Function gcd (@w{(x @sc{integer})} @w{(y @sc{integer})}) : @sc{integer} 
Return the greatest common divisor of @var{x} and @var{y}.
@end deffn

@deffn Function ceiling (@w{(n @sc{number})}) : @sc{integer} 
Return the smallest integer >= @var{n}.
@end deffn

@deffn Function floor (@w{(n @sc{number})}) : @sc{integer} 
Return the biggest integer <= @var{n}.
@end deffn

@deffn Function round (@w{(n @sc{number})}) : @sc{integer} 
Round @var{n} to the closest integer and return the result.
@end deffn

@defmethod @sc{integer} abs (x) : @sc{integer} 
Return the absolute value of @var{x}.
@end defmethod

@defmethod @sc{float} abs (x) : @sc{float} 
Return the absolute value of @var{x}.
@end defmethod

@deffn Function min (@w{(x @sc{integer})} @w{(y @sc{integer})}) : @sc{integer} 
Return the minimum of @var{x} and @var{y}.  If either is NULL, return the other.
@end deffn

@deffn Function max (@w{(x @sc{integer})} @w{(y @sc{integer})}) : @sc{integer} 
Return the maximum of @var{x} and @var{y}.  If either is NULL, return the other.
@end deffn

@deffn Function sqrt (@w{(n @sc{float})}) : @sc{float} 
Return the square root of @var{n}.
@end deffn

@deffn Function exp (@w{(n @sc{float})}) : @sc{float} 
Return the e to the power @var{n}.
@end deffn

@deffn Function expt (@w{(x @sc{float})} @w{(y @sc{float})}) : @sc{float} 
Return @var{x} ^ @var{y}.
@end deffn

@deffn Function log (@w{(n @sc{float})}) : @sc{float} 
Return the natural logarithm (base e) of @var{n}.
@end deffn

@deffn Function log10 (@w{(n @sc{float})}) : @sc{float} 
Return the logarithm (base 10) of @var{n}.
@end deffn

@deffn Function sin (@w{(n @sc{float})}) : @sc{float} 
Return the sine of @var{n} radians.
@end deffn

@deffn Function cos (@w{(n @sc{float})}) : @sc{float} 
Return the cosine of @var{n} radians.
@end deffn

@deffn Function tan (@w{(n @sc{float})}) : @sc{float} 
Return the tangent of @var{n} radians.
@end deffn

@deffn Function asin (@w{(n @sc{float})}) : @sc{float} 
Return the arcsine of @var{n} in radians.
@end deffn

@deffn Function acos (@w{(n @sc{float})}) : @sc{float} 
Return the arccosine of @var{n} in radians.
@end deffn

@deffn Function atan (@w{(n @sc{float})}) : @sc{float} 
Return the arc tangent of @var{n} in radians.
@end deffn

@deffn Function atan2 (@w{(x @sc{float})} @w{(y @sc{float})}) : @sc{float} 
Return the arc tangent of @var{x} / @var{y} in radians.
@end deffn

@deffn Function random (@w{(n @sc{integer})}) : @sc{integer} 
Generate a random integer in the interval [0..n-1].
@end deffn

@deffn Function integer-to-string (@w{(i @sc{integer})}) : @sc{string} 
Convert @var{i} to its string representation and return the result.
 This is more efficient than using a string stream.
@end deffn

@deffn Function string-to-integer (@w{(string @sc{string})}) : @sc{integer} 
Convert a @var{string} representation of an integer into an integer.
@end deffn

@deffn Function float-to-string (@w{(f @sc{float})}) : @sc{string} 
Convert @var{f} to its string representation and return the result.  This is more
efficient than using a string stream.
@end deffn

@deffn Function string-to-float (@w{(string @sc{string})}) : @sc{float} 
Convert a @var{string} representation of a float into a float.
@end deffn

@deffn Function format-float (@w{(f @sc{float})} @w{(nDecimals @sc{integer})}) : @sc{string} 
Print @var{f} in fixed-point format with @var{nDecimals} behind the decimal point
and return the result as a string.
@end deffn

@deffn Function wrap-integer (@w{(value @sc{integer})}) : @sc{integer-wrapper} 
Return a literal object whose value is the INTEGER @var{value}.
@end deffn

@deffn Function unwrap-integer (@w{(wrapper @sc{integer-wrapper})}) : @sc{integer} 
Unwrap @var{wrapper} and return the result.
Return NULL if @var{wrapper} is NULL.
@end deffn

@deffn Function wrap-float (@w{(value @sc{float})}) : @sc{float-wrapper} 
Return a literal object whose value is the FLOAT @var{value}.
@end deffn

@deffn Function unwrap-float (@w{(wrapper @sc{float-wrapper})}) : @sc{float} 
Unwrap @var{wrapper} and return the result.
Return NULL if @var{wrapper} is NULL.
@end deffn


@c ---------------------------------------------------------------------------

@node Characters, Strings, Numbers, Library Functions
@section Characters

@deffn Function character-code (@w{(ch @sc{character})}) : @sc{integer} 
Return the 8-bit ASCII code of @var{ch} as an integer.
@end deffn

@deffn Function code-character (@w{(code @sc{integer})}) : @sc{character} 
Return the character encoded by @var{code} (0 <= @var{code} <= 255).
@end deffn

@deffn Function digit-character? (@w{(ch @sc{character})}) : @sc{boolean} 
Return TRUE if @var{ch} represents a digit.
@end deffn

@deffn Function letter-character? (@w{(ch @sc{character})}) : @sc{boolean} 
Return TRUE if @var{ch} represents a letter.
@end deffn

@deffn Function upper-case-character? (@w{(ch @sc{character})}) : @sc{boolean} 
Return TRUE if @var{ch} represents an upper-case character.
@end deffn

@deffn Function lower-case-character? (@w{(ch @sc{character})}) : @sc{boolean} 
Return TRUE if @var{ch} represents a lower-case character.
@end deffn

@deffn Function white-space-character? (@w{(ch @sc{character})}) : @sc{boolean} 
Return TRUE if @var{ch} is a white space character.
@end deffn

@deffn Function character-downcase (@w{(ch @sc{character})}) : @sc{character} 
If @var{ch} is lowercase, return its uppercase version,
otherwise, return @var{ch} unmodified.
@end deffn

@deffn Function character-upcase (@w{(ch @sc{character})}) : @sc{character} 
If @var{ch} is uppercase, return its lowercase version,
otherwise, return @var{ch} unmodified.  If only the first character of
a sequence of characters is to be capitalized, @code{character-capitalize}
should be used instead.
@end deffn

@deffn Function character-capitalize (@w{(ch @sc{character})}) : @sc{character} 
Return the capitalized character for @var{ch}.  This is generally the same
as the uppercase character, except for obscure non-English characters in Java.  It should
be used if only the first character of a sequence of characters is to be capitalized.
@end deffn

@deffn Function character-to-string (@w{(c @sc{character})}) : @sc{string} 
Convert @var{c} into a one-element string and return the result.
@end deffn

@deffn Function wrap-character (@w{(value @sc{character})}) : @sc{character-wrapper} 
Return a literal object whose value is the CHARACTER @var{value}.
@end deffn

@deffn Function unwrap-character (@w{(wrapper @sc{character-wrapper})}) : @sc{character} 
Unwrap @var{wrapper} and return the result.
Return NULL if @var{wrapper} is NULL.
@end deffn


@c ---------------------------------------------------------------------------

@node Strings, CONS Lists and Trees, Characters, Library Functions
@section Strings

@deffn Function string-eql? (@w{(x @sc{string})} @w{(y @sc{string})}) : @sc{boolean} 
Return true if @var{x} and @var{y} are equal strings or are both undefined.  This
test is substituted automatically by the STELLA translator if @code{eql?} is applied
to strings.
@end deffn

@deffn Function string-equal? (@w{(x @sc{string})} @w{(y @sc{string})}) : @sc{boolean} 
Return true if @var{x} and @var{y} are equal strings ignoring character case or
are both undefined.
@end deffn

@defmethod @sc{string} empty? (x) : @sc{boolean} 
Return true if @var{x} is the empty string ""
@end defmethod

@defmethod @sc{string} non-empty? (x) : @sc{boolean} 
Return true if @var{x} is not the empty string ""
@end defmethod

@deffn Function string-compare (@w{(x @sc{string})} @w{(y @sc{string})} @w{(case-sensitive? @sc{boolean})}) : @sc{integer} 
Compare @var{x} and @var{y} lexicographically, and return -1, 0, 
or 1, depending on whether @var{x} is less than, equal, or greater than @var{y}.
If @var{case-sensitive?} is true, then case does matter for the comparison
@end deffn

@deffn Function string< (@w{(x @sc{string})} @w{(y @sc{string})}) : @sc{boolean} 
Return true if @var{x} is lexicographically < @var{y}, considering case.
@end deffn

@deffn Function string<= (@w{(x @sc{string})} @w{(y @sc{string})}) : @sc{boolean} 
Return true if @var{x} is lexicographically <= @var{y}, considering case.
@end deffn

@deffn Function string>= (@w{(x @sc{string})} @w{(y @sc{string})}) : @sc{boolean} 
Return true if @var{x} is lexicographically >= @var{y}, considering case.
@end deffn

@deffn Function string> (@w{(x @sc{string})} @w{(y @sc{string})}) : @sc{boolean} 
Return true if @var{x} is lexicographically > @var{y}, considering case.
@end deffn

@deffn Function string-less? (@w{(x @sc{string})} @w{(y @sc{string})}) : @sc{boolean} 
Return true if @var{x} is lexicographically < @var{y}, ignoring case.
@end deffn

@deffn Function string-less-equal? (@w{(x @sc{string})} @w{(y @sc{string})}) : @sc{boolean} 
Return true if @var{x} is lexicographically <= @var{y}, ignoring case.
@end deffn

@deffn Function string-greater-equal? (@w{(x @sc{string})} @w{(y @sc{string})}) : @sc{boolean} 
Return true if @var{x} is lexicographically >= @var{y}, ignoring case.
@end deffn

@deffn Function string-greater? (@w{(x @sc{string})} @w{(y @sc{string})}) : @sc{boolean} 
Return true if @var{x} is lexicographically > @var{y}, ignoring case.
@end deffn

@deffn Function all-upper-case-string? (@w{(s @sc{string})}) : @sc{boolean} 
Return TRUE if all letters in @var{s} are upper case.
@end deffn

@deffn Function all-lower-case-string? (@w{(s @sc{string})}) : @sc{boolean} 
Return TRUE if all letters in @var{s} are lower case.
@end deffn

@deffn Function make-string (@w{(size @sc{integer})} @w{(initchar @sc{character})}) : @sc{string} 
Return a new string filled with @var{size} @var{initchar}s.
@end deffn

@deffn Function make-mutable-string (@w{(size @sc{integer})} @w{(initchar @sc{character})}) : @sc{mutable-string} 
Return a new mutable string filled with @var{size} @var{initchar}s.
@end deffn

@deffn Function make-raw-mutable-string (@w{(size @sc{integer})}) : @sc{mutable-string} 
Return a new uninitialized mutable string of @var{size}.
@end deffn

@defmethod @sc{string} first (self) : @sc{character} 
Return the first character of @var{self}.
@end defmethod

@defmethod @sc{mutable-string} first (self) : @sc{character} 
Return the first character of @var{self} (settable via @code{setf}).
@end defmethod

@defmethod @sc{string} second (self) : @sc{character} 
Return the second character of @var{self}.
@end defmethod

@defmethod @sc{mutable-string} second (self) : @sc{character} 
Return the second character of @var{self} (settable via @code{setf}).
@end defmethod

@defmethod @sc{string} third (self) : @sc{character} 
Return the third character of @var{self}.
@end defmethod

@defmethod @sc{mutable-string} third (self) : @sc{character} 
Return the third character of @var{self} (settable via @code{setf}).
@end defmethod

@defmethod @sc{string} fourth (self) : @sc{character} 
Return the fourth character of @var{self}.
@end defmethod

@defmethod @sc{mutable-string} fourth (self) : @sc{character} 
Return the fourth character of @var{self} (settable via @code{setf}).
@end defmethod

@defmethod @sc{string} fifth (self) : @sc{character} 
Return the fifth character of @var{self}.
@end defmethod

@defmethod @sc{mutable-string} fifth (self) : @sc{character} 
Return the fifth character of @var{self} (settable via @code{setf}).
@end defmethod

@defmethod @sc{string} nth (self @w{(position @sc{integer})}) : @sc{character} 
Return the character in @var{self} at @var{position}.
@end defmethod

@defmethod @sc{mutable-string} nth (self @w{(position @sc{integer})}) : @sc{character} 
Return the character in @var{self} at @var{position}.
@end defmethod

@defmethod @sc{string} rest (self) : @sc{string} 
Not documented.
@end defmethod

@defmethod @sc{string} length (self) : @sc{integer} 
Return the length of the string @var{self}.
@end defmethod

@defmethod @sc{mutable-string} length (self) : @sc{integer} 
Return the length of the string @var{self}.
@end defmethod

@defmethod @sc{string} member? (self @w{(char @sc{character})}) : @sc{boolean} 
Not documented.
@end defmethod

@defmethod @sc{string} position (string @w{(character @sc{character})} @w{(start @sc{integer})}) : @sc{integer} 
Return the position of @var{character} within @var{string} (counting
from zero); or return NULL if @var{character} does not occur within @var{string}.
If @var{start} was supplied as non-NULL, only consider the substring starting
at @var{start}, however, the returned position will always be relative to the
entire string.
@end defmethod

@defmethod @sc{string} last-position (string @w{(character @sc{character})} @w{(end @sc{integer})}) : @sc{integer} 
Return the last position of @var{character} within @var{string}
(counting from zero); or return NULL if @var{character} does not occur 
within @var{string}.  If @var{end} was supplied as non-NULL, only consider
the substring ending at @var{end}, however, the returned position will
always be relative to the entire string.
@end defmethod

@deffn Function string-search (@w{(string @sc{string})} @w{(substring @sc{string})} @w{(start @sc{integer})}) : @sc{integer} 
Return start position of the left-most occurrence of
@var{substring} in @var{string}, beginning from @var{start}.  Return NULL if it is not
a substring.
@end deffn

@defmethod @sc{string} copy (string) : @sc{string} 
Return a copy of @var{string}.
@end defmethod

@deffn Function string-upcase (@w{(string @sc{string})}) : @sc{string} 
Return an upper-case copy of @var{string}.
@end deffn

@deffn Function string-downcase (@w{(string @sc{string})}) : @sc{string} 
Return a lower-case copy of @var{string}.
@end deffn

@deffn Function string-capitalize (@w{(string @sc{string})}) : @sc{string} 
Return a capitalized version of @var{string}.
@end deffn

@defmethod @sc{string} concatenate (string1 @w{(string2 @sc{string})} @w{&rest (otherStrings @sc{string})}) : @sc{string} 
Return a new string representing the concatenation
of @var{string1}, @var{string2}, and @var{otherStrings}.  The two mandatory parameters
allow us to optimize the common binary case by not relying on the somewhat
less efficient variable arguments mechanism.
@end defmethod

@defmethod @sc{string} subsequence (string @w{(start @sc{integer})} @w{(end @sc{integer})}) : @sc{string} 
Return a substring of @var{string} beginning at position @var{start}
and ending up to but not including position @var{end}, counting from zero.  An
@var{end} value of NULL stands for the rest of the string.
@end defmethod

@defmethod @sc{string} remove (string @w{(char @sc{character})}) : @sc{string} 
Remove all occurences of @var{char} from @var{string}.
@end defmethod

@defmethod @sc{string} substitute (self @w{(new-char @sc{character})} @w{(old-char @sc{character})}) : @sc{string} 
Substitute all occurences of @var{old-char} with @var{new-char}
in the string @var{self}.
@end defmethod

@defmethod @sc{mutable-string} substitute (self @w{(new-char @sc{character})} @w{(old-char @sc{character})}) : @sc{mutable-string} 
Substitute all occurences of @var{old-char} with @var{new-char}
in the string @var{self}.
@end defmethod

@deffn Function replace-substrings (@w{(string @sc{string})} @w{(new @sc{string})} @w{(old @sc{string})}) : @sc{string} 
Replace all occurrences of @var{old} in @var{string} with @var{new}.
@end deffn

@deffn Function instantiate-string-template (@w{(template @sc{string})} @w{&rest (vars&values @sc{string})}) : @sc{string} 
For each occurrence of a <var> string from @var{vars&values} in @var{template} replace it
with its corresponding <value> string.  Replacement is done in sequence which
means (part of) a value might be replaced further with a later <var> and <value>.
@end deffn

@deffn Function insert-string (@w{(source @sc{string})} @w{(start @sc{integer})} @w{(end @sc{integer})} @w{(target @sc{mutable-string})} @w{(target-index @sc{integer})} @w{(case-conversion @sc{keyword})}) : @sc{integer} 
Inserts characters from @var{source} begining at @var{start} and
ending at @var{end} into @var{target} starting at @var{target-index}.  If @var{end} is @code{null},
then the entire length of the string is used. The copy of characters is affected
by the @var{case-conversion} keyword which should be one of
   :UPCASE :DOWNCASE :CAPITALIZE :PRESERVE.

The final value of target-index is returned.
@end deffn

@deffn Function wrap-string (@w{(value @sc{string})}) : @sc{string-wrapper} 
Return a literal object whose value is the STRING @var{value}.
@end deffn

@deffn Function wrap-mutable-string (@w{(value @sc{mutable-string})}) : @sc{mutable-string-wrapper} 
Return a literal object whose value is the MUTABLE-STRING @var{value}.
@end deffn

@deffn Function unwrap-string (@w{(wrapper @sc{string-wrapper})}) : @sc{string} 
Unwrap @var{wrapper} and return the result.
Return NULL if @var{wrapper} is NULL.
@end deffn

@deffn Function unwrap-mutable-string (@w{(wrapper @sc{mutable-string-wrapper})}) : @sc{mutable-string} 
Unwrap @var{wrapper} and return the result.
Return NULL if @var{wrapper} is NULL.
@end deffn

@deffn Function string-to-mutable-string (@w{(s @sc{string})}) : @sc{mutable-string} 
Copy @var{s} into a mutable string with the same content.
In Lisp and C++ this simply copies @var{s}.
@end deffn

@deffn Function mutable-string-to-string (@w{(s @sc{mutable-string})}) : @sc{string} 
Convert @var{s} into a regular string with the same content.
In Lisp and C++ this is a no-op.
@end deffn

@deffn Function integer-to-string (@w{(i @sc{integer})}) : @sc{string} 
Convert @var{i} to its string representation and return the result.
 This is more efficient than using a string stream.
@end deffn

@deffn Function string-to-integer (@w{(string @sc{string})}) : @sc{integer} 
Convert a @var{string} representation of an integer into an integer.
@end deffn

@deffn Function float-to-string (@w{(f @sc{float})}) : @sc{string} 
Convert @var{f} to its string representation and return the result.  This is more
efficient than using a string stream.
@end deffn

@deffn Function string-to-float (@w{(string @sc{string})}) : @sc{float} 
Convert a @var{string} representation of a float into a float.
@end deffn

@deffn Function format-float (@w{(f @sc{float})} @w{(nDecimals @sc{integer})}) : @sc{string} 
Print @var{f} in fixed-point format with @var{nDecimals} behind the decimal point
and return the result as a string.
@end deffn

@deffn Function character-to-string (@w{(c @sc{character})}) : @sc{string} 
Convert @var{c} into a one-element string and return the result.
@end deffn

@deffn Function stringify (@w{(expression @sc{object})}) : @sc{string} 
Print @var{expression} onto a string and return the result.
Printing is done with @code{*printReadably?*} set to true and with @code{*printPretty?*}
set to false.
@end deffn

@deffn Function stringify-in-module (@w{(tree @sc{object})} @w{(module @sc{module})}) : @sc{string} 
Stringify a parse @var{tree} relative to @var{module}, or
@code{*module*} if no module is specified.
@end deffn

@deffn Function unstringify (@w{(string @sc{string})}) : @sc{object} 
Read a STELLA expression from @var{string} and return the result.
This is identical to @code{read-s-expression-from-string}.
@end deffn

@deffn Function unstringify-in-module (@w{(string @sc{string})} @w{(module @sc{module})}) : @sc{object} 
Unstringify relative to @var{module}, or @code{*MODULE*} if no
module is specified.
@end deffn


@c ---------------------------------------------------------------------------

@node CONS Lists and Trees, Lists, Strings, Library Functions
@section @code{CONS} Lists and Trees

@deftp Class @sc{cons} : @sc{standard-object}
Not documented.
@defcv @w{Class Parameter} {} any-value : @sc{object}
Not documented.
@end defcv
@defcv Slot {} value : @sc{(like (any-value self))}
Not documented.
@end defcv
@defcv Slot {} rest : @sc{(cons of (like (any-value self)))}
Not documented.
@end defcv
@end deftp

@defvr Variable nil : @sc{cons}
Not documented.
@end defvr

@defmethod @sc{cons} empty? (self) : @sc{boolean} 
Return @code{true} iff @var{self} equals @code{nil}.
@end defmethod

@defmethod @sc{cons} non-empty? (self) : @sc{boolean} 
Return @code{true} iff @var{self} is not equal to @code{nil}.
@end defmethod

@deffn Function nil? (@w{(x @sc{object})}) : @sc{boolean} 
Return @code{true} iff @var{x} equals @code{nil}.
@end deffn

@deffn Function equal-cons-trees? (@w{(tree1 @sc{object})} @w{(tree2 @sc{object})}) : @sc{boolean} 
Return @code{true} iff the cons trees @var{tree1} and @var{tree2} are
structurally equivalent.  Uses an @code{eql?} test.
@end deffn

@defmethod @sc{cons} object-equal? (tree1 @w{(tree2 @sc{object})}) : @sc{boolean} 
Return @code{true} iff the cons trees @var{tree1} and @var{tree2} are
structurally equivalent.  Uses @code{equal?} to test equality of subtrees.
@end defmethod

@defmethod @sc{cons} equal-hash-code (self) : @sc{integer} 
Return an @code{equal?} hash code for @var{self}.  Note that this
is O(N) in the number of elements of @var{self}.
@end defmethod

@deffn Function cons (@w{(value @sc{object})} @w{(rest @sc{cons})}) : @sc{cons} 
Return a cons record that points to @var{value} and @var{rest}.
@end deffn

@defmethod @sc{cons} first (self) : @sc{(like (any-value self))} 
Return the first element of @var{self}.  The first element
of @var{self} can be set with @code{setf}.  Note that @code{(first NIL)} = @code{null}.
@end defmethod

@defmethod @sc{cons} second (self) : @sc{(like (any-value self))} 
Return the second element of @var{self}.  The second element
of @var{self} can be set with @code{setf}.  Note that @code{(second NIL)} = @code{null}.
@end defmethod

@defmethod @sc{cons} third (self) : @sc{(like (any-value self))} 
Return the third element of @var{self}.  The third element
of @var{self} can be set with @code{setf}.  Note that @code{(third NIL)} = @code{null}.
@end defmethod

@defmethod @sc{cons} fourth (self) : @sc{(like (any-value self))} 
Return the fourth element of @var{self}.  The fourth element
of @var{self} can be set with @code{setf}.  Note that @code{(fourth NIL)} = @code{null}.
@end defmethod

@defmethod @sc{cons} fifth (self) : @sc{(like (any-value self))} 
Return the fifth element of @var{self}.  The fifth element
of @var{self} can be set with @code{setf}.  Note, that @code{(fifth NIL)} = @code{null}.
@end defmethod

@defmethod @sc{cons} nth (self @w{(position @sc{integer})}) : @sc{(like (any-value self))} 
Return the element of @var{self} at @var{position}.  The nth element
of @var{self} can be set with @code{setf}.  Note, that @code{(nth NIL <pos>)} = @code{null}.
@end defmethod

@defmethod @sc{cons} nth-rest (self @w{(position @sc{integer})}) : @sc{(like self)} 
Apply @code{rest} @var{position} times to @var{self}.
@end defmethod

@defmethod @sc{cons} last (self) : @sc{(like (any-value self))} 
Return the last element of @var{self}.
@end defmethod

@defmethod @sc{cons} but-last (self) : @sc{(iterator of (like (any-value self)))} 
Generate all but the last element of the cons list @var{self}.
@end defmethod

@deffn Function last-cons (@w{(self @sc{cons})}) : @sc{(cons of (like (any-value self)))} 
Return the last cons of @var{self}.
@end deffn

@defmethod @sc{cons} length (self) : @sc{integer} 
Return the length of the CONS list @var{self}.
@end defmethod

@defmethod @sc{cons} member? (self @w{(object @sc{object})}) : @sc{boolean} 
Return @code{true} iff @var{object} is a member of the cons list
@var{self} (uses an @code{eql?} test).
@end defmethod

@defmethod @sc{cons} memb? (self @w{(object @sc{object})}) : @sc{boolean} 
Return @code{true} iff @var{object} is a member of the cons list
@var{self} (uses an @code{eq?} test).
@end defmethod

@defmethod @sc{cons} position (self @w{(object @sc{object})} @w{(start @sc{integer})}) : @sc{integer} 
Return the position of @var{object} within the cons-list
@var{self} (counting from zero); or return @code{null} if @var{object} does not occur within 
@var{self} (uses an @code{eql?} test).  If @var{start} was supplied as non-`null', only 
consider the sublist starting at @var{start}, however, the returned position 
will always be relative to the entire list.
@end defmethod

@defmethod @sc{cons} last-position (self @w{(object @sc{object})} @w{(end @sc{integer})}) : @sc{integer} 
Return the position of @var{object} within the cons-list
@var{self} (counting from zero); or return @code{null} if @var{object} does not occur within 
@var{self} (uses an @code{eql?} test).  If @code{start} was supplied as non-`null', only 
consider the sublist ending at @var{end}, however, the returned position 
will always be relative to the entire list.
@end defmethod

@defmethod @sc{cons} reverse (self) : @sc{(like self)} 
Destructively reverse the members of the cons list @var{self}.
@end defmethod

@defmethod @sc{cons} remove (self @w{(value @sc{object})}) : @sc{(like self)} 
Destructively remove all entries in the cons list @var{self} that
match @var{value}.  Unless the remaining list is @code{nil}, insure that the cons that
heads the list is unchanged.
@end defmethod

@defmethod @sc{cons} remove-duplicates (self) : @sc{(like self)} 
Destructively remove duplicates from @var{self} and return the
result.  Removes all but the first occurrence of items in the list.
Preserves the original order of the remaining members.  Runs in linear time.
@end defmethod

@defmethod @sc{cons} remove-if (self @w{(test? @sc{function-code})}) : @sc{(like self)} 
Destructively removes all members of the cons list
@var{self} for which @var{test?} evaluates to @code{true}.  @code{test} takes a single 
argument of type OBJECT and returns @code{true} or @code{false}.  Returns a cons list.
In case the first element is removed, the return result should be
assigned to a variable.
@end defmethod

@defmethod @sc{cons} substitute (self @w{(inValue @sc{object})} @w{(outValue @sc{object})}) : @sc{cons} 
Destructively replace each appearance of @var{outValue} by
@var{inValue} in the cons list @var{self}.
@end defmethod

@defmethod @sc{cons} concatenate (list1 @w{(list2 @sc{cons})} @w{&rest (otherLists @sc{cons})}) : @sc{cons} 
Return a cons list consisting of the concatenation of 
@var{list1}, @var{list2}, and @var{otherLists}.  The operation is destructive wrt all
but the last list argument which is left intact.  The two mandatory
parameters allow us to optimize the common binary case by not relying on
the somewhat less efficient variable arguments mechanism.
@end defmethod

@deffn Function append (@w{(consList1 @sc{cons})} @w{(consList2 @sc{cons})}) : @sc{cons} 
Return a cons list representing the concatenation
of @var{consList1} and @var{consList2}.  The concatenation is NOT destructive.
@end deffn

@defmethod @sc{cons} prepend (self @w{(list1 @sc{cons})}) : @sc{cons} 
Return a cons list consisting of the concatenation of
@var{list1} and @var{self}.  A copy of @var{list1} is prepended to @var{self}.  This
operation results in structure sharing of @var{self}; to avoid this, @var{self}
should not be pointed to by anything other than the tail of the prepended
copy.
@end defmethod

@deffn Macro pushq (@w{(variable @sc{symbol})} @w{(value @sc{object})}) : @sc{object} 
Push @var{value} onto the cons list @var{variable}.
@end deffn

@deffn Macro pushq-new (@w{(variable @sc{symbol})} @w{(value @sc{object})}) : @sc{object} 
Push @var{value} onto the cons list @var{variable}, unless @var{value}
is already a member of the list.
@end deffn

@deffn Macro popq (@w{(variable @sc{symbol})}) : @sc{object} 
Pops a value from the cons list @var{variable}.
@end deffn

@deffn Function cons-list (@w{&rest (values @sc{object})}) : @sc{cons} 
Return a cons list containing @var{values}, in order.
@end deffn

@deffn Function list* (@w{&rest (values @sc{object})}) : @sc{cons} 
Return a list of conses that make up the list @var{values},
terminated by the last value rather than by @code{nil}.  Assumes that
at least one value is passed in.
@end deffn

@deffn Function copy-cons-list (@w{(self @sc{cons})}) : @sc{(like self)} 
Return a copy of the cons list @var{self}.
@end deffn

@deffn Function copy-cons-tree (@w{(self @sc{object})}) : @sc{(like self)} 
Return a copy of the cons tree @var{self}.
@end deffn

@deffn Function substitute-cons-tree (@w{(tree @sc{object})} @w{(newValue @sc{object})} @w{(oldValue @sc{object})}) : @sc{object} 
Destructively replace each appearance of @var{oldValue} by
@var{newValue} in the cons tree @var{tree}.  Return the tree.  Uses an @code{eql?} test.
@end deffn

@deffn Function search-cons-tree? (@w{(tree @sc{object})} @w{(value @sc{object})}) : @sc{boolean} 
Return @code{true} iff the value @var{value} is embedded within
the cons tree @var{tree}.  Uses an @code{eql?} test.
@end deffn

@deffn Function tree-size (@w{(self @sc{object})}) : @sc{integer} 
Not documented.
@end deffn

@deffn Function safe-tree-size (@w{(tree @sc{cons})}) : @sc{integer} @sc{string} 
Not documented.
@end deffn

@deffn Function cons-tree-nth (@w{(tree @sc{cons})} @w{&rest (index @sc{integer})}) : @sc{object} 
Access an arbitrary element of @var{tree} identified by a path
specified as a list of @var{index} values.  The first @var{index} specifies the
@var{index}-th element of @var{tree}, the second @var{index} the @var{index}-th subelement
of that element, etc.  Example:

@example 
  (cons-tree-nth (quote (a (b (c d e) f) g)) 1 1 2) => e
@end example


@end deffn

@deffn Function cons-tree-nth-rest (@w{(tree @sc{cons})} @w{&rest (index @sc{integer})}) : @sc{cons} 
Access an arbitrary sublist of @var{tree} identified by a path
specified as a list of @var{index} values.  The first @var{index} specifies the
@var{index}-th element of @var{tree}, the second @var{index} the @var{index}-th subelement
of that element, ..., the last index specifies the @code{nth-rest} of the previous
element (different from @code{cons-tree-nth}).  Example:

@example 
  (cons-tree-nth-rest (quote (a (b (c d e) f) g)) 1 1 1) => (d e)
@end example


@end deffn

@deffn Function match-cons-tree (@w{(tree @sc{object})} @w{(pattern @sc{object})} @w{(bindings @sc{key-value-list})}) : @sc{key-value-list} 
Match @var{pattern} against @var{tree} and return a list of
variable bindings if they match, or NULL otherwise.  @var{bindings} can
be NULL or an initial list of bindings to consider.  Pattern variables
use KIF syntax, i.e., they need to start with a @code{?} character.  A
single question mark is interpreted as the anonymous variable. Example:

@example 
  (match-cons-tree (quote (a (b (a d) e) (a d) f g))
                   (quote (a (?x ?y ?) ?y ? g))
                   NULL)
  => |kv|(<?Y,(A D)> <?X,B>)
@end example

Variables can't be quoted but quoting can effectively be achieved by
inserting to-be-quoted variables bound to themselves into @var{bindings}.
@end deffn

@deffn Function cons-tree-match? (@w{(tree @sc{object})} @w{(pattern @sc{object})}) : @sc{boolean} 
Predicate version of @code{match-cons-tree} (which see).
@end deffn

@defmethod @sc{cons} consify (self) : @sc{(cons of (like (any-value self)))} 
Return @var{self}.
@end defmethod

@defmethod @sc{cons} allocate-iterator (self) : @sc{(cons-iterator of (like (any-value self)))} 
Not documented.
@end defmethod

@defmethod @sc{cons-iterator} next? (self) : @sc{boolean} 
Not documented.
@end defmethod

@defmethod @sc{cons} sort (self @w{(predicate @sc{function-code})}) : @sc{(cons of (like (any-value self)))} 
Perform a stable, destructive sort of @var{self} according to
@var{predicate}, and return the result.  If @var{predicate} has a @code{<} semantics, the
result will be in ascending order.  It is not guaranteed that @var{self} will
point to the beginning of the sorted result.  If @var{predicate} is @code{null}, a
suitable @code{<} predicate is chosen depending on the first element of @var{self},
and it is assumed that all elements of @var{self} have the same type (supported
element types are GENERALIZED-SYMBOL, STRING, INTEGER, and FLOAT).
@end defmethod

@defmethod @sc{cons} sort-tuples (self @w{(n @sc{integer})} @w{(predicate @sc{function-code})}) : @sc{(cons of (like (any-value self)))} 
Just like @code{sort} but assumes each element of @var{self} is a tuple (a cons)
whose @var{n}-th element (0-based) will be used for comparison.
@end defmethod

@deffn Function map-null-to-nil (@w{(self @sc{cons})}) : @sc{(like self)} 
Return @code{nil} iff @var{self} is @code{null} or @var{self} otherwise.
@end deffn

@defvr @w{Special Variable} *printpretty?* : @sc{boolean}
If @code{true} conses will be pretty printed.
@end defvr

@defvr @w{Special Variable} *printreadably?* : @sc{boolean}
If @code{true} conses will be printed as readable Stella code.
@end defvr

@defvr @w{Special Variable} *printprettycode?* : @sc{boolean}
When @code{true} pretty-print Stella and translated code.
Since (Lisp) pretty-printing is somewhat slow, turning this off speeds up
file translation, but it also makes translated output very unreadable.
@end defvr


@menu
* CONS Lists as Sets::          
@end menu

@node CONS Lists as Sets,  , CONS Lists and Trees, CONS Lists and Trees
@subsection CONS Lists as Sets

@defmethod @sc{cons} subset? (self @w{(otherList @sc{cons})}) : @sc{boolean} 
Return true if every element of @var{self} also occurs in @var{otherList}.
Uses an @code{eql?} test and a simple quadratic-time algorithm.  Note that
this does not check whether @var{self} and @var{otherList} actually are sets.
@end defmethod

@defmethod @sc{cons} equivalent-sets? (self @w{(otherList @sc{cons})}) : @sc{boolean} 
Return true if every element of @var{self} occurs in @var{otherList} and vice versa.
Uses an @code{eql?} test and a simple quadratic-time algorithm.  Note that
this does not check whether @var{self} and @var{otherList} actually are sets.
@end defmethod

@defmethod @sc{cons} union (self @w{(otherList @sc{cons})}) : @sc{cons} 
Return the set union of @var{self} and @var{otherList}.  Uses an @code{eql?} test
and a simple quadratic-time algorithm.  Note that the result is only
guaranteed to be a set if both @var{self} and @var{otherList} are sets.
@end defmethod

@defmethod @sc{cons} intersection (self @w{(otherList @sc{cons})}) : @sc{cons} 
Return the set intersection of @var{self} and @var{otherList}.  Uses an @code{eql?}
test and a simple quadratic-time algorithm.  Note that the result is only
guaranteed to be a set if both @var{self} and @var{otherList} are sets.
@end defmethod

@defmethod @sc{cons} difference (self @w{(otherList @sc{cons})}) : @sc{cons} 
Return the set difference of @var{self} and @var{otherList} (i.e., all elements
that are in @var{self} but not in @code{otherSet}).  Uses an @code{eql?} test and a simple
quadratic-time algorithm.  Note that the result is only guaranteed to be a
set if both @var{self} and @var{otherList} are sets.
@end defmethod

@defmethod @sc{cons} subtract (self @w{(otherList @sc{cons})}) : @sc{cons} 
Return the set difference of @var{self} and @var{otherList} by destructively
removing elements from @var{self} that also occur in @var{otherList}.  Uses an @code{eql?}
test and a simple quadratic-time algorithm.  Note that the result is only
guaranteed to be a set if @var{self} is a set.
@end defmethod


@c ---------------------------------------------------------------------------

@node Lists, Property and Key-Value Lists, CONS Lists and Trees, Library Functions
@section Lists

@deftp Class @sc{list} : @sc{sequence}
Not documented.
@defcv @w{Class Parameter} {} any-value : @sc{object}
Not documented.
@end defcv
@defcv Slot {} the-cons-list : @sc{(cons of (like (any-value self)))}
Not documented.
@end defcv
@end deftp

@defvr Variable nil-list : @sc{list}
Not documented.
@end defvr

@deffn Function defined-list? (@w{(self @sc{list})}) : @sc{boolean} 
Return TRUE unless @var{self} is NULL or the @code{NIL-LIST}.
@end deffn

@deffn Function null-list? (@w{(self @sc{list})}) : @sc{boolean} 
Return TRUE iff @var{self} is NULL or the @code{NIL-LIST}.
@end deffn

@defmethod @sc{list} empty? (self) : @sc{boolean} 
Return TRUE if the list @var{self} has no members.
@end defmethod

@defmethod @sc{list} non-empty? (self) : @sc{boolean} 
Return TRUE if the list @var{self} has at least one member.
@end defmethod

@defmethod @sc{list} object-equal? (x @w{(y @sc{object})}) : @sc{boolean} 
Return TRUE iff the lists @var{x} and @var{y} are structurally
equivalent.  Uses @code{equal?} to test equality of elements.
@end defmethod

@defmethod @sc{list} equal-hash-code (self) : @sc{integer} 
Return an @code{equal?} hash code for @var{self}.  Note that this
is O(N) in the number of elements of @var{self}.
@end defmethod

@deffn Function list (@w{&rest (values @sc{object})}) : @sc{list} 
Return a list containing @var{values}, in order.
@end deffn

@defmethod @sc{list} first (self) : @sc{(like (any-value self))} 
Return the first item in the list @var{self}, or NULL if empty.
@end defmethod

@defmethod @sc{list} second (self) : @sc{(like (any-value self))} 
Return the second item in the list @var{self}, or NULL if empty.
@end defmethod

@defmethod @sc{list} third (self) : @sc{(like (any-value self))} 
Return the third item in the list @var{self}, or NULL if empty.
@end defmethod

@defmethod @sc{list} fourth (self) : @sc{(like (any-value self))} 
Return the fourth item in the list @var{self}, or NULL if empty.
@end defmethod

@defmethod @sc{list} fifth (self) : @sc{(like (any-value self))} 
Return the fifth item in the list @var{self}, or NULL if empty.
@end defmethod

@defmethod @sc{list} nth (self @w{(position @sc{integer})}) : @sc{(like (any-value self))} 
Return the nth item in the list @var{self}, or NULL if empty.
@end defmethod

@defmethod @sc{list} rest (self) : @sc{(cons of (like (any-value self)))} 
Return a cons list of all but the first item in the list @var{self}.
@end defmethod

@defmethod @sc{list} last (self) : @sc{(like (any-value self))} 
Return the last element of @var{self}.
@end defmethod

@defmethod @sc{list} but-last (self) : @sc{(iterator of (like (any-value self)))} 
Generate all but the last element of the list @var{self}.
@end defmethod

@defmethod @sc{list} length (self) : @sc{integer} 
Not documented.
@end defmethod

@defmethod @sc{list} member? (self @w{(object @sc{object})}) : @sc{boolean} 
Return TRUE iff @var{object} is a member of the list
@var{self} (uses an @code{eql?} test).
@end defmethod

@defmethod @sc{list} memb? (self @w{(object @sc{(like (any-value self))})}) : @sc{boolean} 
Return TRUE iff @var{object} is a member of the cons list
@var{self} (uses an @code{eq?} test).
@end defmethod

@defmethod @sc{list} position (self @w{(object @sc{object})} @w{(start @sc{integer})}) : @sc{integer} 
Return the position of @var{object} within the list
@var{self} (counting from zero); or return NULL if @var{object} does not occur within 
@var{self} (uses an @code{eql?} test).  If @var{start} was supplied as non-NULL, only 
consider the sublist starting at @var{start}, however, the returned position 
will always be relative to the entire list.
@end defmethod

@defmethod @sc{list} last-position (self @w{(object @sc{object})} @w{(end @sc{integer})}) : @sc{integer} 
Return the position of @var{object} within the list
@var{self} (counting from zero); or return NULL if @var{object} does not occur within 
@var{self} (uses an @code{eql?} test).  If @var{end} was supplied as non-NULL, only 
consider the sublist ending at @var{end}, however, the returned position 
will always be relative to the entire list.
@end defmethod

@defmethod @sc{list} insert (self @w{(value @sc{(like (any-value self))})}) : 
Add @var{value} to the front of the list @var{self}.
@end defmethod

@defmethod @sc{list} push (self @w{(value @sc{(like (any-value self))})}) : 
Add @var{value} to the front of the list @var{self}.
@end defmethod

@defmethod @sc{list} insert-new (self @w{(value @sc{(like (any-value self))})}) : 
Add @var{value} to the front of the list @var{self} unless its 
already a member.
@end defmethod

@defmethod @sc{list} insert-last (self @w{(value @sc{(like (any-value self))})}) : 
Insert @var{value} as the last entry in the list @var{self}.
@end defmethod

@defmethod @sc{list} reverse (self) : @sc{(like self)} 
Reverse the members of @var{self} (in place).
@end defmethod

@defmethod @sc{list} remove (self @w{(value @sc{(like (any-value self))})}) : @sc{(like self)} 
Destructively remove all entries in @var{self} that match @var{value}.
@end defmethod

@defmethod @sc{list} remove-duplicates (self) : @sc{(like self)} 
Destructively remove duplicates from @var{self} and return the result.
Preserves the original order of the remaining members.
@end defmethod

@defmethod @sc{list} remove-deleted-members (self) : @sc{(like self)} 
Not documented.
@end defmethod

@defmethod @sc{list} remove-if (self @w{(test? @sc{function-code})}) : @sc{(like self)} 
Destructively remove all members of the list @var{self} for which
@var{test?} evaluates to TRUE.  @code{test} takes a single argument of type OBJECT and
returns TRUE or FALSE.  Returns @var{self}.
@end defmethod

@defmethod @sc{list} pop (self) : @sc{(like (any-value self))} 
Remove and return the first element in the list @var{self}.
Return NULL if the list is empty.
@end defmethod

@defmethod @sc{list} substitute (self @w{(inValue @sc{object})} @w{(outValue @sc{object})}) : @sc{(like self)} 
Destructively replace each appearance of @var{outValue} by
@var{inValue} in the list @var{self}.
@end defmethod

@defmethod @sc{list} concatenate (list1 @w{(list2 @sc{list})} @w{&rest (otherLists @sc{list})}) : @sc{list} 
Copy @var{list2} and all @var{otherLists} onto the end of @var{list1}.
The operation is destructive wrt @var{list1}, but leaves all other lists intact.
The two mandatory parameters allow us to optimize the common binary case by
not relying on the somewhat less efficient variable arguments mechanism.
@end defmethod

@defmethod @sc{list} prepend (self @w{(list2 @sc{list})}) : @sc{(like self)} 
Copy @var{list2} onto the front of the list @var{self}.
The operation is destructive wrt @var{self}, but leaves @var{list2} intact.
@end defmethod

@defmethod @sc{list} copy (self) : @sc{(list of (like (any-value self)))} 
Return a copy of the list @var{self}.  The conses in the copy are
freshly allocated.
@end defmethod

@defmethod @sc{list} clear (self) : 
Make @var{self} an empty list.
@end defmethod

@defmethod @sc{list} consify (self) : @sc{(cons of (like (any-value self)))} 
Return a list of elements in @var{self}.
@end defmethod

@defmethod @sc{list} allocate-iterator (self) : @sc{(list-iterator of (like (any-value self)))} 
Not documented.
@end defmethod

@defmethod @sc{list-iterator} next? (self) : @sc{boolean} 
Not documented.
@end defmethod

@defmethod @sc{list} sort (self @w{(predicate @sc{function-code})}) : @sc{(list of (like (any-value self)))} 
Perform a stable, destructive sort of @var{self} according to
@var{predicate}, and return the result.  If @var{predicate} has a @code{<} semantics, the
result will be in ascending order.  If @var{predicate} is NULL, a suitable
@code{<} predicate is chosen depending on the first element of @var{self}, and it 
is assumed that all elements of @var{self} have the same type (supported
element types are GENERALIZED-SYMBOL, STRING, INTEGER, and FLOAT).
@end defmethod

@deffn Function map-null-to-nil-list (@w{(self @sc{list})}) : @sc{list} 
Return NIL-LIST iff @var{self} is NULL or @var{self} otherwise.
@end deffn


@menu
* Lists as Sets::               
@end menu

@node Lists as Sets,  , Lists, Lists
@subsection Lists as Sets

Similar to @code{CONS} lists @code{LIST}'s can also be treated as sets
and support the set manipulations below.  Note that @code{LIST}
constructors do not check for proper set-hood and may have surprising
results if a list contains duplicate elements.

@defmethod @sc{list} subset? (self @w{(otherList @sc{list})}) : @sc{boolean} 
Return true if every element of @var{self} also occurs in @var{otherList}.
Uses an @code{eql?} test and a simple quadratic-time algorithm.  Note that
this does not check whether @var{self} and @var{otherList} actually are sets.
@end defmethod

@defmethod @sc{list} equivalent-sets? (self @w{(otherList @sc{list})}) : @sc{boolean} 
Return true if every element of @var{self} occurs in @var{otherList} and vice versa.
Uses an @code{eql?} test and a simple quadratic-time algorithm.  Note that
this does not check whether @var{self} and @var{otherList} actually are sets.
@end defmethod

@defmethod @sc{list} union (self @w{(otherList @sc{list})}) : @sc{list} 
Return the set union of @var{self} and @var{otherList}.  Uses an @code{eql?} test
and a simple quadratic-time algorithm.  Note that the result is only
guaranteed to be a set if both @var{self} and @var{otherList} are sets.
@end defmethod

@defmethod @sc{list} intersection (self @w{(otherList @sc{list})}) : @sc{list} 
Return the set intersection of @var{self} and @var{otherList}.  Uses an @code{eql?}
test and a simple quadratic-time algorithm.  Note that the result is only
guaranteed to be a set if both @var{self} and @var{otherList} are sets.
@end defmethod

@defmethod @sc{list} difference (self @w{(otherList @sc{list})}) : @sc{list} 
Return the set difference of @var{self} and @var{otherList} (i.e., all elements
that are in @var{self} but not in @code{otherSet}).  Uses an @code{eql?} test and a simple
quadratic-time algorithm.  Note that the result is only guaranteed to be a
set if both @var{self} and @var{otherList} are sets.
@end defmethod

@defmethod @sc{list} subtract (self @w{(otherList @sc{list})}) : @sc{list} 
Return the set difference of @var{self} and @var{otherList} by destructively
removing elements from @var{self} that also occur in @var{otherList}.  Uses an @code{eql?}
test and a simple quadratic-time algorithm.  Note that the result is only
guaranteed to be a set if @var{self} is a set.
@end defmethod


@code{SET} is a subclass of @code{LIST} that overrides certain
@code{LIST} operations to prevent duplicate elements.  The following
additional or modified operations are supported:

@deftp Class @sc{set} : @sc{list}, @sc{set-mixin}
Not documented.
@defcv @w{Class Parameter} {} any-value : @sc{object}
Not documented.
@end defcv
@end deftp

@defmethod @sc{set} insert (self @w{(value @sc{(like (any-value self))})}) : 
Add @var{value} to the set @var{self} unless it is already a member.
@end defmethod

@defmethod @sc{set} push (self @w{(value @sc{(like (any-value self))})}) : 
Add @var{value} to the front of set @var{self} unless it is already a member.
@end defmethod

@defmethod @sc{set} insert-last (self @w{(value @sc{(like (any-value self))})}) : 
Add @var{value} to the end of set @var{self} unless it is already a member.
@end defmethod

@defmethod @sc{set} substitute (self @w{(new @sc{object})} @w{(old @sc{object})}) : @sc{(like self)} 
Destructively replace @var{old} with @var{new} in the set @var{self}
unless @var{new} is already a member.
@end defmethod

@defmethod @sc{set} concatenate (set1 @w{(set2 @sc{list})} @w{&rest (otherSets @sc{list})}) : @sc{set} 
Union @var{set2} and all @var{otherSets} onto the end of @var{set1}.
The operation is destructive wrt @var{set1}, but leaves all other sets intact.
The two mandatory parameters allow us to optimize the common binary case by
not relying on the somewhat less efficient variable arguments mechanism.
@end defmethod

@defmethod @sc{set} object-equal? (x @w{(y @sc{object})}) : @sc{boolean} 
Return TRUE iff @var{x} and @var{y} are SET's with equivalent members.
Uses @code{equal?} to test equality of elements.  This is more general than
@code{equivalent-sets?}, since that only uses an @code{eql?} test.
@end defmethod

@defmethod @sc{set} equal-hash-code (self) : @sc{integer} 
Return an @code{equal?} hash code for @var{self}.  Note that this
is O(N) in the number of elements of @var{self}.
@end defmethod

@deffn Function set (@w{&rest (values @sc{object})}) : @sc{set} 
Return a set containing @var{values}, in order.
@end deffn


@c ---------------------------------------------------------------------------

@node Property and Key-Value Lists, Vectors, Lists, Library Functions
@section Property and Key-Value Lists

@deftp Class @sc{property-list} : @sc{dictionary}
Not documented.
@defcv @w{Class Parameter} {} any-key : @sc{object}
Not documented.
@end defcv
@defcv @w{Class Parameter} {} any-value : @sc{object}
Not documented.
@end defcv
@defcv Slot {} the-plist : @sc{cons}
Not documented.
@end defcv
@end deftp

@defmethod @sc{property-list} empty? (self) : @sc{boolean} 
Not documented.
@end defmethod

@defmethod @sc{property-list} non-empty? (self) : @sc{boolean} 
Not documented.
@end defmethod

@defmethod @sc{property-list} object-equal? (x @w{(y @sc{object})}) : @sc{boolean} 
Return TRUE if @var{x} and @var{y} represent the same set of key/value pairs..
@end defmethod

@defmethod @sc{property-list} equal-hash-code (self) : @sc{integer} 
Return an @code{equal?} hash code for @var{self}.  Note that this
is O(N) in the number of entries of @var{self}.
@end defmethod

@defmethod @sc{property-list} length (self) : @sc{integer} 
Not documented.
@end defmethod

@c # $(util/texinfo-insert-doc search-plist)
@defmethod @sc{property-list} lookup (self @w{(key @sc{(like (any-key self))})}) : @sc{(like (any-value self))} 
Not documented.
@end defmethod

@defmethod @sc{property-list} insert-at (self @w{(key @sc{(like (any-key self))})} @w{(value @sc{(like (any-value self))})}) : 
Insert the entry <`key', @var{value}> into the property list @var{self}.
If a previous entry existed with key @var{key}, that entry is replaced.
@end defmethod

@defmethod @sc{property-list} remove-at (self @w{(key @sc{(like (any-key self))})}) : @sc{object} 
Remove the entry that matches the key @var{key}.  Return the
value of the matching entry, or NULL if there is no matching entry.  Assumes that at
most one entry matches @var{key}.
@end defmethod

@defmethod @sc{property-list} copy (self) : @sc{(like self)} 
Return a copy of the list @var{self}.  The conses in the copy are
freshly allocated.
@end defmethod

@defmethod @sc{property-list} clear (self) : 
Make @var{self} an empty property list.
@end defmethod

@defmethod @sc{property-list} allocate-iterator (self) : @sc{(property-list-iterator of (like (any-key self)) (like (any-value self)))} 
Not documented.
@end defmethod

@defmethod @sc{property-list-iterator} next? (self) : @sc{boolean} 
Not documented.
@end defmethod

@deftp Class @sc{kv-cons} : @sc{standard-object}
Not documented.
@defcv @w{Class Parameter} {} any-key : @sc{object}
Not documented.
@end defcv
@defcv @w{Class Parameter} {} any-value : @sc{object}
Not documented.
@end defcv
@defcv Slot {} key : @sc{object}
Not documented.
@end defcv
@defcv Slot {} value : @sc{object}
Not documented.
@end defcv
@defcv Slot {} rest : @sc{kv-cons}
Not documented.
@end defcv
@end deftp

@deffn Function kv-cons (@w{(key @sc{object})} @w{(value @sc{object})} @w{(rest @sc{kv-cons})}) : @sc{kv-cons} 
Create, fill-in, and return a new KV-CONS.
@end deffn

@deffn Function copy-kv-cons-list (@w{(kvconslist @sc{kv-cons})}) : @sc{kv-cons} 
Return a copy of the cons list @code{consList}.
@end deffn

@deftp Class @sc{key-value-list} : @sc{dictionary}
Not documented.
@defcv @w{Class Parameter} {} any-key : @sc{object}
Not documented.
@end defcv
@defcv @w{Class Parameter} {} any-value : @sc{object}
Not documented.
@end defcv
@defcv Slot {} the-kv-list : @sc{kv-cons}
Not documented.
@end defcv
@end deftp

@defmethod @sc{key-value-list} empty? (self) : @sc{boolean} 
Not documented.
@end defmethod

@defmethod @sc{key-value-list} non-empty? (self) : @sc{boolean} 
Not documented.
@end defmethod

@defmethod @sc{key-value-list} object-equal? (x @w{(y @sc{object})}) : @sc{boolean} 
Return TRUE if @var{x} and @var{y} represent the same set of key/value pairs.
@end defmethod

@defmethod @sc{key-value-list} equal-hash-code (self) : @sc{integer} 
Return an @code{equal?} hash code for @var{self}.  Note that this
is O(N) in the number of entries of @var{self}.
@end defmethod

@defmethod @sc{key-value-list} length (self) : @sc{integer} 
Not documented.
@end defmethod

@defmethod @sc{key-value-list} lookup (self @w{(key @sc{(like (any-key self))})}) : @sc{(like (any-value self))} 
Not documented.
@end defmethod

@defmethod @sc{key-value-list} reverse (self) : @sc{(like self)} 
Destructively reverse the members of the list @var{self}.
@end defmethod

@defmethod @sc{key-value-list} insert-at (self @w{(key @sc{(like (any-key self))})} @w{(value @sc{(like (any-value self))})}) : 
Insert the entry <`key', @var{value}> into the association
@var{self}. If a previous entry existed with key @var{key}, that entry is replaced.
@end defmethod

@defmethod @sc{key-value-list} remove-at (self @w{(key @sc{(like (any-key self))})}) : @sc{object} 
Remove the entry that matches the key @var{key}.
Return the value of the matching entry, or NULL if there is no matching entry.
Assumes that at most one entry matches @var{key}.
@end defmethod

@defmethod @sc{key-value-list} insert-entry (self @w{(key @sc{(like (any-key self))})} @w{(value @sc{(like (any-value self))})}) : 
Insert an entry <`key',@var{value}> to @var{self} unless an identical
entry already exists.  This can generate duplicate entries for @var{key}.
@end defmethod

@defmethod @sc{key-value-list} remove-entry (self @w{(key @sc{(like (any-key self))})} @w{(value @sc{(like (any-value self))})}) : 
Remove the entry that matches <`key',@var{value}>.
Assumes that more than one entry can match @var{key}.
@end defmethod

@defmethod @sc{key-value-list} push (self @w{(value @sc{kv-cons})}) : 
Make @var{value} be the new first element of @var{self}.  Note that
the @code{rest} slot of @var{value} should be @code{null}, since it will be overwritten.
This might duplicate an existing entry. If a previous entry existed with the
same key as @var{value}, that entry is retained, but shadowed by this new entry.
@end defmethod

@defmethod @sc{key-value-list} kv-push (self @w{(key @sc{(like (any-key self))})} @w{(value @sc{(like (any-value self))})}) : 
Add a new entry <`key', @var{value}> to the front of the association
@var{self}. This might duplicate an existing entry. If a previous entry existed with key
@var{key}, that entry is retained, but shadowed by this new entry.
@end defmethod

@defmethod @sc{key-value-list} pop (self) : @sc{(like (any-value self))} 
Remove and return the value of the first element of the
kv-list @var{self}.  It does NOT return the KV-CONS object.  Return @code{null} if
the list is empty.
@end defmethod

@defmethod @sc{key-value-list} copy (self) : @sc{(like self)} 
Return a copy of the kv-list @var{self}.  The kv-conses in
the copy are freshly allocated.
@end defmethod

@defmethod @sc{key-value-list} clear (self) : 
Make @var{self} an empty dictionary.
@end defmethod

@defmethod @sc{key-value-list} consify (self) : @sc{(cons of (like (any-value self)))} 
Return a list of key-value pairs in @var{self}.
@end defmethod

@defmethod @sc{key-value-list} allocate-iterator (self) : @sc{(kv-list-iterator of (like (any-key self)) (like (any-value self)))} 
Not documented.
@end defmethod

@defmethod @sc{kv-list-iterator} next? (self) : @sc{boolean} 
Not documented.
@end defmethod


@c ---------------------------------------------------------------------------

@node Vectors, Hash Tables, Property and Key-Value Lists, Library Functions
@section Vectors

@deftp Class @sc{vector} : @sc{sequence}
Not documented.
@defcv @w{Class Parameter} {} any-value : @sc{object}
Not documented.
@end defcv
@defcv Slot {} array-size : @sc{integer}
Not documented.
@end defcv
@defcv Slot {} the-array : @sc{(native-vector of (like (any-value self)))}
Not documented.
@end defcv
@end deftp

@deftp Class @sc{extensible-vector} : @sc{vector}
Not documented.
@end deftp

@defmethod @sc{vector} empty? (self) : @sc{boolean} 
Return @code{true} if @var{self} has length 0.
@end defmethod

@defmethod @sc{vector} non-empty? (self) : @sc{boolean} 
Return @code{true} if @var{self} has length > 0.
@end defmethod

@defmethod @sc{vector} object-equal? (x @w{(y @sc{object})}) : @sc{boolean} 
Return TRUE iff the vectors @var{x} and @var{y} are structurally
equivalent.  Uses @code{equal?} to test equality of elements.
@end defmethod

@defmethod @sc{vector} equal-hash-code (self) : @sc{integer} 
Return an @code{equal?} hash code for @var{self}.
@end defmethod

@deffn Function vector (@w{&rest (values @sc{object})}) : @sc{vector} 
Return a vector containing @var{values}, in order.
@end deffn

@defmethod @sc{vector} first (self) : @sc{(like (any-value self))} 
Not documented.
@end defmethod

@defmethod @sc{vector} second (self) : @sc{(like (any-value self))} 
Not documented.
@end defmethod

@defmethod @sc{vector} third (self) : @sc{(like (any-value self))} 
Not documented.
@end defmethod

@defmethod @sc{vector} fourth (self) : @sc{(like (any-value self))} 
Not documented.
@end defmethod

@defmethod @sc{vector} fifth (self) : @sc{(like (any-value self))} 
Not documented.
@end defmethod

@defmethod @sc{vector} nth (self @w{(position @sc{integer})}) : @sc{(like (any-value self))} 
Not documented.
@end defmethod

@defmethod @sc{vector} last (self) : @sc{(like (any-value self))} 
Return the last item in the vector @var{self}.
@end defmethod

@defmethod @sc{vector} but-last (self) : @sc{(iterator of (like (any-value self)))} 
Generate all but the last element of the vector @var{self}.
@end defmethod

@defmethod @sc{vector} length (self) : @sc{integer} 
Not documented.
@end defmethod

@defmethod @sc{vector} member? (self @w{(object @sc{object})}) : @sc{boolean} 
Not documented.
@end defmethod

@defmethod @sc{vector} position (self @w{(object @sc{object})} @w{(start @sc{integer})}) : @sc{integer} 
Return the position of @var{object} within the vector
@var{self} (counting from zero); or return @code{null} if @var{object} does not occur within 
@var{self} (uses an @code{eql?} test).  If @var{start} was supplied as non-`null', only 
consider the portion starting at @var{start}, however, the returned position 
will always be relative to the entire vector.
@end defmethod

@defmethod @sc{vector} last-position (self @w{(object @sc{object})} @w{(end @sc{integer})}) : @sc{integer} 
Return the position of @var{object} within the vector
@var{self} (counting from zero); or return @code{null} if @var{object} does not occur within 
@var{self} (uses an @code{eql?} test).  If @var{end} was supplied as non-`null', only 
consider the portion ending at index @var{end}, however, the returned position 
will always be relative to the entire vector.
@end defmethod

@defmethod @sc{vector} insert-at (self @w{(offset @sc{integer})} @w{(value @sc{(like (any-value self))})}) : 
Not documented.
@end defmethod

@defmethod @sc{vector} copy (self) : @sc{(vector of (like (any-value self)))} 
Return a copy of the vector @var{self}.
@end defmethod

@defmethod @sc{vector} clear (self) : 
Not documented.
@end defmethod

@deffn Function resize-vector (@w{(self @sc{vector})} @w{(size @sc{integer})}) : 
Change the size of @var{self} to @var{size}.  If @var{size} is smaller
than the current size of @var{self} the vector will be truncated.  Otherwise, 
the internal array of @var{self} will be grown to @var{size} and unused elements
will be initialized to NULL.
@end deffn

@defmethod @sc{vector} consify (self) : @sc{(cons of (like (any-value self)))} 
Return a list of elements in @var{self}.
@end defmethod

@defmethod @sc{extensible-vector} insert-at (self @w{(offset @sc{integer})} @w{(value @sc{(like (any-value self))})}) : 
Not documented.
@end defmethod

@defmethod @sc{vector-sequence} insert (self @w{(value @sc{(like (any-value self))})}) : 
Append @var{value} to the END of the sequence @var{self}.  
Resize the array if necessary.
@end defmethod

@defmethod @sc{vector-sequence} remove (self @w{(value @sc{(like (any-value self))})}) : @sc{vector-sequence} 
Remove @var{value} from the sequence @var{self}, and left shift
the values after it to close the gap.
@end defmethod

@defmethod @sc{vector-sequence} length (self) : @sc{integer} 
Not documented.
@end defmethod


@c ---------------------------------------------------------------------------

@node Hash Tables, Key Value Maps, Vectors, Library Functions
@section Hash Tables

@deftp Class @sc{hash-table} : @sc{abstract-hash-table}
Not documented.
@defcv @w{Class Parameter} {} any-key : @sc{object}
Not documented.
@end defcv
@defcv @w{Class Parameter} {} any-value : @sc{object}
Not documented.
@end defcv
@end deftp

@deftp Class @sc{string-hash-table} : @sc{abstract-hash-table}
Not documented.
@defcv @w{Class Parameter} {} any-key : @sc{string}
Not documented.
@end defcv
@defcv @w{Class Parameter} {} any-value : @sc{object}
Not documented.
@end defcv
@end deftp

@deftp Class @sc{string-to-integer-hash-table} : @sc{abstract-hash-table}
Not documented.
@defcv @w{Class Parameter} {} any-key : @sc{string}
Not documented.
@end defcv
@defcv @w{Class Parameter} {} any-value : @sc{integer}
Not documented.
@end defcv
@end deftp

@deftp Class @sc{integer-hash-table} : @sc{abstract-hash-table}
Not documented.
@defcv @w{Class Parameter} {} any-key : @sc{integer}
Not documented.
@end defcv
@defcv @w{Class Parameter} {} any-value : @sc{object}
Not documented.
@end defcv
@end deftp

@deftp Class @sc{float-hash-table} : @sc{abstract-hash-table}
Not documented.
@defcv @w{Class Parameter} {} any-key : @sc{float}
Not documented.
@end defcv
@defcv @w{Class Parameter} {} any-value : @sc{object}
Not documented.
@end defcv
@end deftp

@defmethod @sc{hash-table} lookup (self @w{(key @sc{(like (any-key self))})}) : @sc{(like (any-value self))} 
Not documented.
@end defmethod

@defmethod @sc{hash-table} insert-at (self @w{(key @sc{(like (any-key self))})} @w{(value @sc{(like (any-value self))})}) : 
Not documented.
@end defmethod

@defmethod @sc{hash-table} remove-at (self @w{(key @sc{(like (any-key self))})}) : 
Not documented.
@end defmethod

@defmethod @sc{string-hash-table} lookup (self @w{(key @sc{string})}) : @sc{(like (any-value self))} 
Not documented.
@end defmethod

@defmethod @sc{string-hash-table} insert-at (self @w{(key @sc{string})} @w{(value @sc{object})}) : 
Not documented.
@end defmethod

@defmethod @sc{string-hash-table} remove-at (self @w{(key @sc{string})}) : 
Not documented.
@end defmethod

@defmethod @sc{string-to-integer-hash-table} lookup (self @w{(key @sc{string})}) : @sc{integer} 
Not documented.
@end defmethod

@defmethod @sc{string-to-integer-hash-table} insert-at (self @w{(key @sc{string})} @w{(value @sc{integer})}) : 
Not documented.
@end defmethod

@defmethod @sc{integer-hash-table} lookup (self @w{(key @sc{integer})}) : @sc{(like (any-value self))} 
Not documented.
@end defmethod

@defmethod @sc{integer-hash-table} insert-at (self @w{(key @sc{integer})} @w{(value @sc{object})}) : 
Not documented.
@end defmethod

@defmethod @sc{float-hash-table} insert-at (self @w{(key @sc{float})} @w{(value @sc{object})}) : 
Not documented.
@end defmethod


STELLA provides its own implementation of hash tables for cases where
language-native implementations are not available, or where additional
features are needed.

@deftp Class @sc{stella-hash-table} : @sc{abstract-hash-table}
Not documented.
@defcv @w{Class Parameter} {} any-key : @sc{object}
Not documented.
@end defcv
@defcv @w{Class Parameter} {} any-value : @sc{object}
Not documented.
@end defcv
@defcv Slot {} the-table : @sc{(array size () of kv-cons)}
Not documented.
@end defcv
@defcv Slot {} size : @sc{integer}
Not documented.
@end defcv
@defcv Slot {} initial-size : @sc{integer}
If supplied, the initial hash table
will be sized to hold at least that many elements.
@end defcv
@defcv Slot {} free-elements : @sc{integer}
Not documented.
@end defcv
@defcv Slot {} equal-test? : @sc{boolean}
If true use @code{equal?} as the
equality test and @code{equal-hash-code} as the hash function, otherwise,
use @code{eql?} and @code{hash-code} (the default).
@end defcv
@end deftp

@defmethod @sc{stella-hash-table} lookup (self @w{(key @sc{(like (any-key self))})}) : @sc{(like (any-value self))} 
Lookup the entry identified by @var{key} in @var{self} and
return its value, or NULL if no such entry exists.    Uses an @code{eql?}
test by default or @code{equal?} if @code{equal-test?} of @var{self} is TRUE.
@end defmethod

@defmethod @sc{stella-hash-table} insert-at (self @w{(key @sc{(like (any-key self))})} @w{(value @sc{(like (any-value self))})}) : 
Set the value of the entry identified by @var{key} in @var{self}
to @var{value} or add a new entry if no entry with @var{key} exists yet.  Uses an
@code{eql?} test by default or @code{equal?} if @code{equal-test?} of @var{self} is TRUE.
@end defmethod

@defmethod @sc{stella-hash-table} remove-at (self @w{(key @sc{(like (any-key self))})}) : 
Remove the entry identified by @var{key} from @var{self}.  Uses an
@code{eql?} test by default or @code{equal?} if @code{equal-test?} of @var{self} is TRUE.
@end defmethod

@defmethod @sc{stella-hash-table} length (self) : @sc{integer} 
Return the number of entries in @var{self}.
@end defmethod

@defmethod @sc{stella-hash-table} empty? (self) : @sc{boolean} 
Return TRUE if @var{self} has zero entries.
@end defmethod

@defmethod @sc{stella-hash-table} non-empty? (self) : @sc{boolean} 
Return TRUE if @var{self} has at least 1 entry.
@end defmethod

@defmethod @sc{stella-hash-table} copy (self) : @sc{(like self)} 
Return a copy of the hash table @var{self}.  The bucket table
and buckets are freshly allocated, however, the keys and values of entries
are not copied themselves (similar to what we do for lists, etc.).
@end defmethod

@defmethod @sc{stella-hash-table} clear (self) : 
Remove all entries from @var{self}.  This will result in a
re-initialization of the table upon the first insertion into @var{self}.
@end defmethod

@defmethod @sc{stella-hash-table} consify (self) : @sc{(cons of cons)} 
Collect all entries of @var{self} into a cons list of
@code{(<key> <value>)} pairs and return the result.
@end defmethod

@defmethod @sc{stella-hash-table} object-equal? (x @w{(y @sc{object})}) : @sc{boolean} 
Return TRUE if @var{x} and @var{y} represent the same set of key/value pairs.
@end defmethod

@defmethod @sc{stella-hash-table} equal-hash-code (self) : @sc{integer} 
Return an @code{equal?} hash code for @var{self}.  Note that this
is O(N) in the number of entries of @var{self}.
@end defmethod

@defmethod @sc{stella-hash-table} allocate-iterator (self) : @sc{(stella-hash-table-iterator of (like (any-key self)) (like (any-value self)))} 
Allocate an iterator for @var{self}.
@end defmethod


Hashing objects into STELLA hash tables is accomplished via
@code{hash-code} and @code{equal-hash-code} methods.  These methods are
implemented for all built-in STELLA types but are user extensible for
cases where special functionality on user-defined objects is needed.
Defining new @code{hash-code} methods should only be necessary if new
wrapper types are defined, since for all types descending from
@code{STANDARD-OBJECT} the built-in method should be adequate.

@deffn Function object-hash-code (@w{(self @sc{object})}) : @sc{integer} 
Return a hash code for @var{self} (can be negative).  Two objects that are @code{eq?}
are guaranteed to generate the same hash code.  Two objects that are not @code{eq?}
do not necessarily generate different hash codes.  Similar to @code{hash-code} but
always hashes on the address of @var{self} even if it is a wrapper.
@end deffn

@defmethod @sc{object} hash-code (self) : @sc{integer} 
Return a hash code for @var{self} (can be negative).  Two objects that are @code{eql?}
are guaranteed to generate the same hash code.  Two objects that are not @code{eql?}
do not necessarily generate different hash codes.
@end defmethod

@defmethod @sc{standard-object} hash-code (self) : @sc{integer} 
Not documented.
@end defmethod

@defmethod @sc{string-wrapper} hash-code (self) : @sc{integer} 
Not documented.
@end defmethod

@defmethod @sc{integer-wrapper} hash-code (self) : @sc{integer} 
Not documented.
@end defmethod

@defmethod @sc{float-wrapper} hash-code (self) : @sc{integer} 
Not documented.
@end defmethod

@defmethod @sc{character-wrapper} hash-code (self) : @sc{integer} 
Not documented.
@end defmethod

@defmethod @sc{boolean-wrapper} hash-code (self) : @sc{integer} 
Not documented.
@end defmethod

@defmethod @sc{string} hash-code (self) : @sc{integer} 
Not documented.
@end defmethod

@defmethod @sc{integer} hash-code (self) : @sc{integer} 
Not documented.
@end defmethod

@defmethod @sc{float} hash-code (self) : @sc{integer} 
Not documented.
@end defmethod

@defmethod @sc{character} hash-code (self) : @sc{integer} 
Not documented.
@end defmethod

@defmethod @sc{object} equal-hash-code (self) : @sc{integer} 
Return a hash code for @var{self} (can be negative).  Two objects that are @code{equal?}
are guaranteed to generate the same hash code (provided, that writers of
@code{object-equal?} methods also implemented the appropriate @code{equal-hash-code}
method).  Two objects that are not @code{equal?}do not necessarily generate different
hash codes.
@end defmethod


The following low-level utilities are available to implement specialized
hashing schemes or for defining new versions of @code{equal-hash-code}.

@deffn Function hashmod (@w{(code @sc{integer})} @w{(size @sc{integer})}) : @sc{integer} 
Map the hash code @var{code} onto a bucket index for a hash table
of @var{size} (i.e., onto the interval [0..size-1].  This is just like @code{rem} for
positive hash codes but also works for negative hash codes by mapping those
onto a positive number first.  Note, that the sign conversion mapping is not
equivalent to calling the @code{abs} function (it simply masks the sign bit for
speed) and therefore really only makes sense for hash codes.
@end deffn

@deffn Function rotate-hash-code (@w{(arg @sc{integer})}) : @sc{integer} 
Rotate @var{arg} to the right by 1 position.  This means shift @var{arg} to the right
by one and feed in @var{arg}s bit zero from the left.  In Lisp the result will stay
in positive FIXNUM range.  In C++ and Java this might return a negative
value which might be equal to NULL-INTEGER.  Important: to make this inlinable,
it must be called with an atom (i.e., constant or variable) as its argument.
This function is primarily useful for hashing sequences of items where the hash
code should take the sequential order of elements into account (e.g., lists).
@end deffn


@node Key Value Maps, Hash Sets, Hash Tables, Library Functions
@section Key Value Maps

@code{KEY-VALUE-MAP} is a full-featured dictionary class that supports
@code{eql?} or extensible @code{equal?} equality tests, O(1) access
operations even for large numbers of entries by using a hash table,
light-weight @code{KV-CONS} representation for small tables and
iteration even if the dictionary is represented by a hash table (note
that in STELLA we cannot iterate over regular @code{HASH-TABLE}'s, since
native Lisp hash tables do not allow us to implement a hash table
iterator).  Since large @code{KEY-VALUE-MAP}'s are implemented via
@code{STELLA-HASH-TABLE}'s, we can support iteration.

@deftp Class @sc{key-value-map} : @sc{dictionary}
Full-featured dictionary class that supports @code{eql?} or
@code{equal?} equality tests, O(1) access operations even for large numbers
of entries by using a hash table, light-weight KV-CONS representation for
small tables and iteration even if the dictionary is represented by a
hash table.
@defcv Slot {} the-map : @sc{object}
Not documented.
@end defcv
@defcv Slot {} equal-test? : @sc{boolean}
If true use @code{equal?} as the
equality test (and @code{equal-hash-code} as the hash function), otherwise,
use @code{eql?} (and @code{hash-code}) (the default).
@end defcv
@defcv Slot {} initial-size : @sc{integer}
If supplied, the initial table
will be sized to hold at least that many elements.
@end defcv
@defcv Slot {} crossover-point : @sc{integer}
Not documented.
@end defcv
@end deftp

@defmethod @sc{key-value-map} lookup (self @w{(key @sc{(like (any-key self))})}) : @sc{(like (any-value self))} 
Lookup the entry identified by @var{key} in @var{self} and
return its value, or NULL if no such entry exists.    Uses an @code{eql?}
test by default or @code{equal?} if @code{equal-test?} of @var{self} is TRUE.
@end defmethod

@defmethod @sc{key-value-map} insert-at (self @w{(key @sc{(like (any-key self))})} @w{(value @sc{(like (any-value self))})}) : 
Set the value of the entry identified by @var{key} in @var{self}
to @var{value} or add a new entry if no entry with @var{key} exists yet.  Uses an
@code{eql?} test by default or @code{equal?} if @code{equal-test?} of @var{self} is TRUE.
@end defmethod

@defmethod @sc{key-value-map} remove-at (self @w{(key @sc{(like (any-key self))})}) : 
Remove the entry identified by @var{key} from @var{self}.  Uses an
@code{eql?} test by default or @code{equal?} if @code{equal-test?} of @var{self} is TRUE.
@end defmethod

@defmethod @sc{key-value-map} length (self) : @sc{integer} 
Return the number of entries in @var{self}.
@end defmethod

@defmethod @sc{key-value-map} empty? (self) : @sc{boolean} 
Return TRUE if @var{self} has zero entries.
@end defmethod

@defmethod @sc{key-value-map} non-empty? (self) : @sc{boolean} 
Return TRUE if @var{self} has at least 1 entry.
@end defmethod

@defmethod @sc{key-value-map} copy (self) : @sc{(like self)} 
Return a copy of the map @var{self}.  All entries are freshly
allocated, however, the keys and values of entries are not copied themselves
 (similar to what we do for lists, etc.).
@end defmethod

@defmethod @sc{key-value-map} clear (self) : 
Reset @var{self} to have zero entries.
@end defmethod

@defmethod @sc{key-value-map} allocate-iterator (self) : @sc{(dictionary-iterator of (like (any-key self)) (like (any-value self)))} 
Allocate an iterator for @var{self}.  The only modifying
operations allowed during iteration are removal of the current element or
changing its value.  All other removal or insertion operations might lead
to corruption or undefined results.
@end defmethod

@defmethod @sc{key-value-map} consify (self) : @sc{cons} 
Collect all entries of @var{self} into a cons list of
@code{(<key> <value>)} pairs and return the result.
@end defmethod

@defmethod @sc{key-value-map} object-equal? (x @w{(y @sc{object})}) : @sc{boolean} 
Return TRUE if @var{x} and @var{y} represent the same set of key/value pairs.
@end defmethod

@defmethod @sc{key-value-map} equal-hash-code (self) : @sc{integer} 
Return an @code{equal?} hash code for @var{self}.  Note that this
is O(N) in the number of entries of @var{self}.
@end defmethod


@node Hash Sets, Iterators, Key Value Maps, Library Functions
@section Hash Sets

@code{HASH-SET} is a full-featured set class that supports @code{eql?}
or extensible @code{equal?} equality tests, O(1) insert and
@code{member?} operations, O(N) @code{intersection} etc. operations even
for large numbers of entries by using a STELLA hash table, light-weight
@code{KV-CONS} representation for small sets and iteration even if the
set is represented by a hash table.  The only minor drawback right now
is that we waste one value slot per entry, since we piggy-back off
@code{KEY-VALUE-MAP}'s, however, that wastes at most 25% space.

@deftp Class @sc{hash-set} : @sc{key-value-map}, @sc{set-mixin}
Full-featured set class that supports @code{eql?} or @code{equal?}
equality tests, O(1) insert and @code{member?} operations & O(N) @code{intersection}
etc. operations even for large numbers of entries by using a hash table,
light-weight KV-CONS representation for small sets and iteration even if the
set is represented by a hash table.  The only minor drawback right now is that
this wastes a value slot per entry, since we piggy-back off KEY-VALUE-MAP's,
however, that wastes at most 25% space.
@end deftp

@deffn Function hash-set (@w{&rest (values @sc{object})}) : @sc{hash-set} 
Return an @code{eql?} HASH-SET containing @var{values}.
@end deffn

@defmethod @sc{hash-set} member? (self @w{(object @sc{object})}) : @sc{boolean} 
Return TRUE iff @var{object} is a member of the set @var{self}.
Uses an @code{eql?} test by default or @code{equal?} if @code{equal-test?} of @var{self} is TRUE.
@end defmethod

@defmethod @sc{hash-set} insert (self @w{(value @sc{(like (any-value self))})}) : 
Add @var{value} to the set @var{self} unless it is already a member.
Uses an @code{eql?} test by default or @code{equal?} if @code{equal-test?} of @var{self} is TRUE.
@end defmethod

@defmethod @sc{hash-set} remove (self @w{(value @sc{(like (any-value self))})}) : @sc{(like self)} 
Destructively remove @var{value} from the set @var{self} if it is a member and
return @var{self}.  Uses an @code{eql?} test by default or @code{equal?} if @code{equal-test?} of
@var{self} is TRUE.
@end defmethod

@defmethod @sc{hash-set} remove-if (self @w{(test? @sc{function-code})}) : @sc{(like self)} 
Destructively remove all elements of the set @var{self} for which
@var{test?} evaluates to TRUE.  @var{test?} takes a single argument of type OBJECT and
returns TRUE or FALSE.  Returns @var{self}.
@end defmethod

@defmethod @sc{hash-set} pop (self) : @sc{(like (any-value self))} 
Remove and return an arbitrary element of the set @var{self}.
Return NULL if the set is empty.  Performance note: for large sets implemented
via hash tables it takes O(N) to empty out the set with repeated calls to @code{pop},
since the emptier the table gets, the longer it takes to find an element.
Therefore, it is usually better to use iteration with embedded removals for
such cases.
@end defmethod

@defmethod @sc{hash-set} substitute (self @w{(new @sc{object})} @w{(old @sc{object})}) : @sc{(like self)} 
Destructively replace @var{old} with @var{new} in the set @var{self}
unless @var{new} is already a member.  Uses an @code{eql?} test by default or @code{equal?}
if @code{equal-test?} of @var{self} is TRUE.
@end defmethod

@defmethod @sc{hash-set} copy (self) : @sc{(like self)} 
Return a copy of the set @var{self}.  All entries are freshly
allocated, however, the values are not copied themselves (similar to what we
do for lists, etc.).
@end defmethod

@defmethod @sc{hash-set} consify (self) : @sc{(cons of (like (any-value self)))} 
Collect all entries of @var{self} into a cons list and return the result.
@end defmethod

@defmethod @sc{hash-set} subset? (self @w{(otherSet @sc{hash-set})}) : @sc{boolean} 
Return true if every element of @var{self} also occurs in @var{otherSet}.
Uses an @code{eql?} test by default or @code{equal?} if @code{equal-test?} of @var{self} is TRUE.
@end defmethod

@defmethod @sc{hash-set} equivalent-sets? (self @w{(otherSet @sc{hash-set})}) : @sc{boolean} 
Return true if every element of @var{self} occurs in @var{otherSet} and vice versa.
Uses an @code{eql?} test by default or @code{equal?} if @code{equal-test?} of @var{self} is TRUE.
@end defmethod

@defmethod @sc{hash-set} intersection (self @w{(otherSet @sc{hash-set})}) : @sc{hash-set} 
Return the set intersection of @var{self} and @var{otherSet} as a new set.
Uses an @code{eql?} test by default or @code{equal?} if @code{equal-test?} of @var{self} is TRUE.
@end defmethod

@defmethod @sc{hash-set} union (self @w{(otherSet @sc{hash-set})}) : @sc{hash-set} 
Return the set union of @var{self} and @var{otherSet} as a new set.
Uses an @code{eql?} test by default or @code{equal?} if @code{equal-test?} of @var{self} is TRUE.
@end defmethod

@defmethod @sc{hash-set} difference (self @w{(otherSet @sc{hash-set})}) : @sc{hash-set} 
Return the set difference of @var{self} and @var{otherSet} as a new set (i.e.,
all elements that are in @var{self} but not in @var{otherSet}).  Uses an @code{eql?} test
by default or @code{equal?} if @code{equal-test?} of @var{self} is TRUE.
@end defmethod

@defmethod @sc{hash-set} subtract (self @w{(otherSet @sc{hash-set})}) : @sc{hash-set} 
Return the set difference of @var{self} and @var{otherSet} by destructively
removing elements from @var{self} that also occur in @var{otherSet}.  Uses an @code{eql?}
test by default or @code{equal?} if @code{equal-test?} of @var{self} is TRUE.
@end defmethod

@defmethod @sc{hash-set} object-equal? (x @w{(y @sc{object})}) : @sc{boolean} 
Return TRUE iff sets @var{x} and @var{y} are HASH-SET's with equivalent members.
Uses an @code{eql?} test by default or @code{equal?} if @code{equal-test?} of @code{self} is TRUE.
This is equivalent to calling @code{equivalent-sets?}.
@end defmethod

@defmethod @sc{hash-set} equal-hash-code (self) : @sc{integer} 
Return an @code{equal?} hash code for @var{self}.  Note that this
is O(N) in the number of elements of @var{self}.
@end defmethod


@c ---------------------------------------------------------------------------

@node Iterators, Symbols, Hash Sets, Library Functions
@section Iterators

@defmethod @sc{iterator} empty? (self) : @sc{boolean} 
Return TRUE if the sequence represented by @var{self}
has no elements.  Side-effect free.
@end defmethod

@defmethod @sc{iterator} member? (self @w{(value @sc{object})}) : @sc{boolean} 
Iterate over values of @var{self}, returning TRUE
if one of them is @code{eql} to 'value.
@end defmethod

@defmethod @sc{abstract-iterator} length (self) : @sc{integer} 
Iterate over @var{self}, and count how many
items there are.  Bad idea if @var{self} iterates over an infinite
collection, since in that case it will run forever.'
@end defmethod

@defmethod @sc{iterator} pop (self) : @sc{(like (any-value self))} 
Return the first item of the sequence represented by @var{self},
or NULL if it is empty.  Destructively uses up the first iteration element.
@end defmethod

@defmethod @sc{iterator} advance (self @w{(n @sc{integer})}) : @sc{(like self)} 
Return @var{self} after skipping over the first
@var{n} elements in the (remainder of the) iteration.
@end defmethod

@defmethod @sc{iterator} concatenate (iterator1 @w{(iterator2 @sc{iterator})} @w{&rest (otherIterators @sc{iterator})}) : @sc{all-purpose-iterator} 
Return an iterator that first generates all values of
@var{iterator1}, then those of @var{iterator2}, and then those of all @var{otherIterators}.
The generated values can be filtered by supplying a filter function to the
resulting iterator.
@end defmethod

@defmethod @sc{iterator} consify (self) : @sc{(cons of (like (any-value self)))} 
Return a list of elements generated by @var{self}.
@end defmethod

@defmethod @sc{all-purpose-iterator} next? (self) : @sc{boolean} 
Apply the stored @code{next?} function to @var{self}.
@end defmethod


@c ---------------------------------------------------------------------------

@node Symbols, Contexts and Modules, Iterators, Library Functions
@section Symbols

@deffn Function lookup-symbol (@w{(name @sc{string})}) : @sc{symbol} 
Return the first symbol with @var{name} visible from the current module.
@end deffn

@deffn Function intern-symbol (@w{(name @sc{string})}) : @sc{symbol} 
Return a newly-created or existing symbol with name @var{name}.
@end deffn

@deffn Function unintern-symbol (@w{(self @sc{symbol})}) : 
Remove @var{self} from its home module and the symbol table.
@end deffn

@deffn Function lookup-symbol-in-module (@w{(name @sc{string})} @w{(module @sc{module})} @w{(local? @sc{boolean})}) : @sc{symbol} 
Return the first symbol with @var{name} visible from @var{module}.
If @var{local?} only consider symbols directly interned in @var{module}.
If @var{module} is @code{null}, use @code{*MODULE*} instead.
@end deffn

@deffn Function intern-symbol-in-module (@w{(name @sc{string})} @w{(module @sc{module})} @w{(local? @sc{boolean})}) : @sc{symbol} 
Look for a symbol named @var{name} in @var{module} (if @var{local?} do
not consider inherited modules).  If none exists, intern it locally in
@var{module}.  Return the existing or newly-created symbol.
@end deffn

@deffn Function intern-derived-symbol (@w{(baseSymbol @sc{generalized-symbol})} @w{(newName @sc{string})}) : @sc{symbol} 
Return a newly-created or existing symbol with name
@var{newName} which is interned in the same module as @var{baseSymbol}.
@end deffn

@deffn Function visible-symbol? (@w{(self @sc{symbol})}) : @sc{boolean} 
Return @code{true} if @var{self} is visible from the current module.
@end deffn

@deffn Function lookup-visible-symbols-in-module (@w{(name @sc{string})} @w{(module @sc{module})} @w{(enforceShadowing? @sc{boolean})}) : @sc{(cons of symbol)} 
Return the list of symbols with @var{name} visible from @var{module}.
More specific symbols (relative to the module precedence order defined by
@code{visible-modules}) come earlier in the list.  If @var{module} is @code{null}, start
from @code{*MODULE*} instead.  If @var{enforceShadowing?} is true, do not return any
symbols that are shadowed due to some :SHADOW declaration.
@end deffn

@deffn Function import-symbol (@w{(symbol @sc{symbol})} @w{(module @sc{module})}) : @sc{symbol} 
Import @var{symbol} into @var{module} and return the imported @var{symbol}.
Signal an error if a different symbol with the same name already exists
locally in @var{module}.  Any symbol with the same name visible in @var{module} by
inheritance will be shadowed by the newly imported @var{symbol}.
@end deffn

@deffn Function safe-import-symbol (@w{(symbol @sc{symbol})} @w{(module @sc{module})}) : @sc{symbol} 
Safe version of @code{import-symbol} (which see).  Only imports @var{symbol} if
no symbol with that name is currently interned or visible in @var{module}.
Returns @var{symbol} if it was imported or the conflicting symbol in @var{module}
otherwise.
@end deffn

@deffn Function lookup-surrogate (@w{(name @sc{string})}) : @sc{surrogate} 
Return the first surrogate with @var{name} visible from the current module.
@end deffn

@deffn Function intern-surrogate (@w{(name @sc{string})}) : @sc{surrogate} 
Return a newly-created or existing surrogate with name @var{name}.
@end deffn

@deffn Function unintern-surrogate (@w{(self @sc{surrogate})}) : 
Remove @var{self} from its home module and the surrogate table.
@end deffn

@deffn Function lookup-surrogate-in-module (@w{(name @sc{string})} @w{(module @sc{module})} @w{(local? @sc{boolean})}) : @sc{surrogate} 
Return the first surrogate with @var{name} visible from @var{module}.
If @var{local?} only consider surrogates directly interned in @var{module}.
If @var{module} is @code{null}, use @code{*MODULE*} instead.
@end deffn

@deffn Function intern-surrogate-in-module (@w{(name @sc{string})} @w{(module @sc{module})} @w{(local? @sc{boolean})}) : @sc{surrogate} 
Look for a symbol named @var{name} in @var{module} (if @var{local?} do
not consider inherited modules).  If none exists, intern it locally in
@var{module}.  Return the existing or newly-created symbol.
@end deffn

@deffn Function intern-derived-surrogate (@w{(baseSymbol @sc{generalized-symbol})} @w{(newName @sc{string})}) : @sc{surrogate} 
Return a newly-created or existing surrogate with name
@var{newName} which is interned in the same module as @var{baseSymbol}.
@end deffn

@deffn Function visible-surrogate? (@w{(self @sc{surrogate})}) : @sc{boolean} 
Return @code{true} if @var{self} is visible from the current module.
@end deffn

@deffn Function lookup-visible-surrogates-in-module (@w{(name @sc{string})} @w{(module @sc{module})} @w{(enforceShadowing? @sc{boolean})}) : @sc{(cons of surrogate)} 
Return the list of surrogates with @var{name} visible from @var{module}.
More specific surrogates (relative to the module precedence order defined by
@code{visible-modules}) come earlier in the list.  If @var{module} is @code{null}, start
from @code{*MODULE*} instead.  If @var{enforceShadowing?} is true, do not return any
surrogates that are shadowed due to some :SHADOW declaration.
@end deffn

@deffn Function import-surrogate (@w{(surrogate @sc{surrogate})} @w{(module @sc{module})}) : @sc{surrogate} 
Import @var{surrogate} into @var{module} and return the imported @var{surrogate}.
Signal an error if a different surrogate with the same name already exists
locally in @var{module}.  Any surrogate with the same name visible in @var{module} by
inheritance will be shadowed by the newly imported @var{surrogate}.
@end deffn

@deffn Function safe-import-surrogate (@w{(surrogate @sc{surrogate})} @w{(module @sc{module})}) : @sc{surrogate} 
Safe version of @code{import-surrogate} (which see).  Only imports @var{surrogate} if
no surrogate with that name is currently interned or visible in @var{module}.
Returns @var{surrogate} if it was imported or the conflicting surrogate in @var{module}
otherwise.
@end deffn

@deffn Function lookup-keyword (@w{(name @sc{string})}) : @sc{keyword} 
Return the keyword with @var{name} if it exists.
@end deffn

@deffn Function intern-keyword (@w{(name @sc{string})}) : @sc{keyword} 
Return a newly-created or existing keyword with name
@var{name}.  Storage note: a COPY of @var{name} is stored in the keyword
@end deffn

@deffn Function gensym (@w{(prefix @sc{string})}) : @sc{symbol} 
Return a transient symbol with a name beginning with
@var{prefix} and ending with a globally gensym'd integer.
@end deffn

@deffn Function local-gensym (@w{(prefix @sc{string})}) : @sc{symbol} 
Not documented.
@end deffn

@deffn Function symbol-plist (@w{(symbol @sc{symbol})}) : @sc{cons} 
Return the property list of @var{symbol}.  The @code{symbol-plist}
of a symbol can be set with @code{setf}.  IMPORTANT: Property list are modified 
destructively, hence, if you supply it as a whole make sure to always supply
a modfiable copy, e.g., by using @code{bquote}.
@end deffn

@deffn Function symbol-property (@w{(symbol @sc{symbol})} @w{(key @sc{standard-object})}) : @sc{object} 
Return the property of @var{symbol} whose key is @code{eq?} to @var{key}.
Symbol properties can be set with @code{setf}.
@end deffn

@deffn Function symbol-value (@w{(symbol @sc{symbol})}) : @sc{object} 
Return the value of @var{symbol}.  Note, that this value is not
visible to code that references a variable with the same name as @var{symbol}.
The @code{symbol-value} is simply a special property that can always be accessed
in constant time.  The @code{symbol-value} of a symbol can be changed with @code{setf}.
@end deffn

@deffn Function symbolize (@w{(surrogate @sc{surrogate})}) : @sc{symbol} 
Convert @var{surrogate} into a symbol with the same name and module.
@end deffn


@c ---------------------------------------------------------------------------

@node Contexts and Modules, Input and Output, Symbols, Library Functions
@section Context and Modules

@deffn Function get-stella-context (@w{(pathName @sc{string})} @w{(error? @sc{boolean})}) : @sc{context} 
Return the context located at @var{pathName}, or @code{null}
if no such context exists.  If @var{error?} is @code{true}, throw an exception
if no context is found, otherwise silently return @code{null}.
@end deffn

@deffn Function clear-context (@w{(self @sc{context})}) : 
Destroy all objects belonging to @var{self} or any of its subcontexts.
@end deffn

@deffn Macro within-context (@w{(contextForm @sc{object})} @w{&body (body @sc{cons})}) : @sc{object} 
Execute @var{body} within the context resulting from @var{contextForm}.
@end deffn

@defmethod @sc{context} destroy-context (self) : 
Make the translator happy.
@end defmethod

@defmethod @sc{string} destroy-context (self) : 
Destroy the context @var{self}, and recursively destroy
all contexts that inherit @var{self}.
@end defmethod

@defmethod @sc{context} change-context (context) : @sc{context} 
Change the current context to be the context
@var{context}.
@end defmethod

@defmethod @sc{string} change-context (contextName) : @sc{context} 
Change the current context to be the context named
@var{contextName}.
@end defmethod

@deffn N-Command cc (@w{&rest (name @sc{name})}) : @sc{context} 
Change the current context to the one named @var{name}.  Return the
value of the new current context.  If no @var{name} is supplied, return
the pre-existing value of the current context.  @code{cc} is a no-op if the
context reference cannot be successfully evaluated.
@end deffn

@deffn N-Command defmodule (@w{(name @sc{name})} @w{&rest (options @sc{object})}) : 
Define (or redefine) a module named @var{name}.
The accepted syntax is:

@example 
  (defmodule <module-name>
     [:documentation <docstring>]
     [:includes @{<module-name> | (<module-name>*)@}]
     [:uses @{<module-name> | (<module-name>*)@}]
     [:lisp-package <package-name-string>]
     [:java-package <package-specification-string>]
     [:cpp-namespace <namespace-name-string>]
     [:java-catchall-class
     [:api? @{TRUE | FALSE@}]
     [:case-sensitive? @{TRUE | FALSE@}]
     [:shadow (<symbol>*)]
     [:java-catchall-class <class-name-string>]
     [<other-options>*])
@end example

@var{name} can be a string or a symbol.

Modules include objects from other modules via two separate mechanisms:
(1) they inherit from their parents specified via the @code{:includes} option
and/or a fully qualified module name, and (2) they inherit from used
modules specified via the @code{:uses} option.  The main difference between
the two mechanisms is that inheritance from parents is transitive, while
uses-links are only followed one level deep.  I.e., a module A that uses
B will see all objects of B (and any of B's parents) but not see anything
from modules used by B.  Another difference is that only objects declared
as public can be inherited via uses-links (this is not yet enforced).
Note that - contrary to Lisp - there are separate name spaces for classes,
functions, and variables.  For example, a module could inherit the class
@code{CONS} from the @code{STELLA} module, but shadow the function of the same name.

The above discussion of @code{:includes} and @code{:uses} semantics keyed on the
inheritance/visibility of symbols. The PowerLoom system makes another
very important distinction: If a module @code{A} is inherited directly or
indirectly via @code{:includes} specification(s) by a submodule @code{B}, then all
definitions and facts asserted in @code{A} are visible in @code{B}. This is not the
cases for @code{:uses}; the @code{:uses} options does not impact inheritance of
propositions at all.

The list of modules specified in the
@code{:includes} option plus (if supplied) the parent in the path used for
@var{name} become the new module's parents. If no @code{:uses} option was
supplied, the new module will use the @code{STELLA} module by default,
otherwise, it will use the set of specified modules.
If @code{:case-sensitive?} is supplied as TRUE, symbols in the module will be
interned case-sensitively, otherwise (the default), they will be
converted to uppercase before they get interned. Modules can shadow
definitions of functions and classes inherited from parents or used
modules. Shadowing is done automatically, but generates a warning unless
the shadowed type or function name is listed in the @code{:shadow} option of
the module definition .

Examples:

@example 
  (defmodule "PL-KERNEL/PL-USER"
    :uses ("LOGIC" "STELLA")
    :package "PL-USER")

  (defmodule PL-USER/GENEALOGY)
@end example

The remaining options are relevant only for modules that contain STELLA
code.  Modules used only to contain knowledge base definitions and assertions
have no use for them:

The keywords @code{:lisp-package}, @code{:java-package}, and @code{:cpp-package} specify
the name of a native package or name space in which symbols of the module
should be allocated when they get translated into one of Lisp, Java, or
C++. By default, Lisp symbols are allocated in the @code{STELLA} package, and
C++ names are translated without any prefixes. The rules that the STELLA
translator uses to attach translated Java objects to classes and packages
are somewhat complex. Use :java-package option to specify a list of
package names (separated by periods) that prefix the Java object in this
module.  Use :java-catchall-class to specify the name of the Java class to
contain all global & special variables, parameter-less functions and functions 
defined on arguments that are not classes in the current module.
The default value will be the name of the module.

When set to TRUE, the :api? option tells the PowerLoom User Manual
generator that all functions defined in this module should be included in
the API section. Additionally, the Java translator makes all API
functions @code{synchronized}.

@end deffn

@deffn Function get-stella-module (@w{(pathName @sc{string})} @w{(error? @sc{boolean})}) : @sc{module} 
Return the module located at @var{pathName}, or @code{null}
if no such module exists.  The search looks at ancestors and top-most
 (cardinal) modules.  If @var{error?} is @code{true}, throw an exception if no
 module is found.
@end deffn

@deffn Function find-or-create-module (@w{(pathname @sc{string})}) : @sc{module} 
Return a module located at @var{pathname} if one exists,
  otherwise create one
@end deffn

@deffn N-Command clear-module (@w{&rest (name @sc{name})}) : 
Destroy all objects belonging to module @var{name} or any of its children.
If no @var{name} is supplied, the current module will be cleared after
confirming with the user.  Important modules such as STELLA are protected
against accidental clearing.
@end deffn

@deffn Function destroy-module (@w{(self @sc{module})}) : 
Destroy the module @var{self}, and recursively destroy
all contexts that inherit @var{self}.
@end deffn

@defmethod @sc{module} destroy-context (self) : 
Destroy the context @var{self}, and recursively destroy
all contexts that inherit @var{self}.
@end defmethod

@deffn Function visible-modules (@w{(from @sc{module})}) : @sc{(cons of module)} 
Return a list of all modules visible from module @var{from} (or @code{*module*}
if @var{from} is NULL.  The generated modules are generated from most to
least-specific and will start with the module @var{from}.
@end deffn

@deffn Macro within-module (@w{(moduleForm @sc{object})} @w{&body (body @sc{cons})}) : @sc{object} 
Execute @var{body} within the module resulting from @var{moduleForm}.
@code{*module*} is an acceptable @var{moduleForm}.  It will locally rebind 
@code{*module*} and @code{*context*} and shield the outer bindings from changes.
@end deffn

@deffn N-Command in-module (@w{(name @sc{name})}) : @sc{module} 
Change the current module to the module named @var{name}.
@end deffn

@defmethod @sc{module} change-module (module) : @sc{module} 
Change the current module to be the module
@var{module}.
@end defmethod

@defmethod @sc{string} change-module (moduleName) : @sc{module} 
Change the current module to be the module named
@var{moduleName}.
@end defmethod

@deffn Function create-world (@w{(parentContext @sc{context})} @w{(name @sc{string})}) : @sc{world} 
Create a new world below the world or module @var{parentContext}.
Optionally, specify a name.
@end deffn

@deffn Function push-world () : @sc{world} 
Spawn a new world that is a child of the current context,
and change the current context to the new world.
@end deffn

@deffn Function pop-world () : @sc{context} 
Destroy the current world and change the current
context to be its parent.  Return the current context. Nothing happens
if there is no current world.
@end deffn

@defmethod @sc{world} destroy-context (self) : 
Destroy the context @var{self}, and recursively destroy
all contexts that inherit @var{self}.
@end defmethod

@deffn Macro within-world (@w{(worldForm @sc{object})} @w{&body (body @sc{cons})}) : @sc{object} 
Execute @var{body} within the world resulting from @var{worldForm}.
@end deffn


@c ---------------------------------------------------------------------------

@node Input and Output, Files, Contexts and Modules, Library Functions
@section Input and Output 

@deffn Function read-s-expression (@w{(stream @sc{input-stream})}) : @sc{object} @sc{boolean} 
Read one STELLA s-expression from @var{stream} and return
the result.  Return @code{true} as the second value on EOF.
@end deffn

@deffn Function read-s-expression-from-string (@w{(string @sc{string})}) : @sc{object} 
Read one STELLA s-expression from @var{string} and
return the result.
@end deffn

@deffn Function read-line (@w{(stream @sc{input-stream})}) : @sc{string} 
Read one line from @var{stream} and return the result.
This differs from @code{native-read-line} in that it is not platform-dependent.
It recognizes any of the three common line ending formats: CR, LF, CR-LF
in any combination.  It is not as fast as @code{native-read-line}, however.
@end deffn

@deffn Function read-character (@w{(inputStream @sc{input-stream})}) : @sc{character} @sc{boolean} 
Read one character from @var{inputStream} and return the result.
Return @code{true} as the second value on EOF.
@end deffn

@deffn Function unread-character (@w{(ch @sc{character})} @w{(inputStream @sc{input-stream})}) : 
Unread @var{ch} from @var{inputStream}.  Signal an error if @var{ch}
was not the last character read.
@end deffn

@deffn Function y-or-n? (@w{(message @sc{string})}) : @sc{boolean} 
Read a line of input from STANDARD-INPUT and return @code{true}
if the input was @code{y} or @code{false} if the input was @code{n}.  Loop until either
@code{y} or @code{n} was entered.  If @var{message} is non-`null' prompt with it before
the input is read.  See also special variable @code{*USER-QUERY-ACTION*}.
@end deffn

@deffn Function yes-or-no? (@w{(message @sc{string})}) : @sc{boolean} 
Read a line of input from STANDARD-INPUT and return @code{true}
if the input was @code{yes} or @code{false} if the input was @code{no}.  Loop until either
@code{yes} or @code{no} was entered.  If @var{message} is non-`null' prompt with it before
the input is read.  See also special variable @code{*USER-QUERY-ACTION*}.
@end deffn

@deffn Function flush-output (@w{(self @sc{output-stream})}) : 
Flush all buffered output of @var{self}.
@end deffn


@c ---------------------------------------------------------------------------

@node Files, Dates and Times, Input and Output, Library Functions
@section Files

@deffn Function open-input-file (@w{(fileName @sc{string})} @w{&rest (options @sc{keyword})}) : @sc{file-input-stream} 
Open file @var{fileName} for input and return the resulting input stream.
By default signal an error if the file does not exist.  The only legal
option so far is @code{:IF-NOT-EXISTS} (or @code{:IF-NOT-EXISTS-ACTION}) which
specifies what to do in case the file does not exist.  If its value is
@code{:ERROR} then an error will be signaled.  If it is @code{:ABORT} or @code{:PROBE}
the opening operation will be aborted and NULL will be returned.
@end deffn

@deffn Function open-output-file (@w{(fileName @sc{string})} @w{&rest (options @sc{keyword})}) : @sc{file-output-stream} 
Open file @var{fileName} for output and return the resulting output stream.
By default the file will be created or overwritten if it already exists.
If @code{:IF-EXISTS} (or @code{:IF-EXISTS-ACTION}) is one of the @var{options} its value
specifies what to do in case the file already exists.  If the value is
@code{:SUPERSEDE} the pre-existing file will be overwritten.  If the value is
@code{:APPEND} the preexisting file will be appended to (if the file did not
yet exist the file will simply be created).  If the value is @code{:ERROR} then
an error will be signaled.  If it is @code{:ABORT} or @code{:PROBE} the opening operation
will be aborted and NULL will be returned.

If @code{:IF-NOT-EXISTS} (or @code{:IF-NOT-EXISTS-ACTION}) is one of the @var{options} its
value specifies what to do in case the file does not already exist.  If the
value is @code{:CREATE}, the file will simply be created.  If the value is
@code{:ERROR} then an error will be signaled.  If it is @code{:ABORT} or @code{:PROBE} the
opening operation will be aborted and NULL will be returned.
@end deffn

@deffn Function close-stream (@w{(self @sc{stream})}) : 
Close the stream @var{self}.
@end deffn

@deffn Function close-all-files () : 
Close all currently open file streams.  Use for emergencies or for cleanup.
@end deffn

@deffn Macro with-input-file (@w{(binding @sc{cons})} @w{&body (body @sc{cons})}) : @sc{object} 
Sets up an unwind-protected form which opens a file for
input and closes it afterwards.  The stream for reading is bound to the
variable provided in the macro form.
Syntax is @code{(WITH-INPUT-FILE (var filename options*) body+)} where @code{options}
can be any that are legal for @code{open-input-file} (which see).
@end deffn

@deffn Macro with-output-file (@w{(binding @sc{cons})} @w{&body (body @sc{cons})}) : @sc{object} 
Sets up an unwind-protected form which opens a file for
output and closes it afterwards.  The stream for writing is bound to the
variable provided in the macro form.
Syntax is @code{(WITH-OUTPUT-FILE (var filename options*) body+)} where @code{options}
can be any that are legal for @code{open-output-file} (which see).
@end deffn

@deffn Function probe-file? (@w{(fileName @sc{file-name})}) : @sc{boolean} 
Return true if file @var{fileName} exists.  Note that this does
not necessarily mean that the file can also be read.
@end deffn

@deffn Function file-write-date (@w{(fileName @sc{file-name})}) : @sc{calendar-date} 
Return the time at which file @var{fileName} was last modified or
NULL if that cannot be determined.
@end deffn

@deffn Function file-length (@w{(fileName @sc{file-name})}) : @sc{integer} 
Return the length of file @var{fileName} in bytes or NULL if that
cannot be determined.  Note that this will currently overrun for files that
are longer than what can be represented by a STELLA integer.
@end deffn

@deffn Function copy-file (@w{(fromFile @sc{file-name})} @w{(toFile @sc{file-name})}) : 
Copy file @var{fromFile} to file @var{toFile}, clobbering
any data already in @var{toFile}.
@end deffn

@deffn Function delete-file (@w{(fileName @sc{file-name})}) : 
Delete the file @var{fileName}.
@end deffn

@deffn Function directory-file-name (@w{(directory @sc{file-name})}) : @sc{file-name} 
Return @var{directory} as a file name, i.e., without a terminating
directory separator.
@end deffn

@deffn Function directory-parent-directory (@w{(directory @sc{file-name})} @w{(level @sc{integer})}) : @sc{file-name} 
Return the @var{level}-th parent directory component of @var{directory}
including the final directory separator, or the empty string if @var{directory} does
not have that many parents.
@end deffn

@deffn Function file-name-as-directory (@w{(file @sc{file-name})}) : @sc{file-name} 
Return @var{file} interpreted as a directory, i.e., with a
terminating directory separator.  If @var{file} is the empty string simply
return the empty string, i.e., interpret it as the current directory instead
of the root directory.
@end deffn

@deffn Function file-name-directory (@w{(file @sc{file-name})}) : @sc{file-name} 
Return the directory component of @var{file} including the final
directory separator or the empty string if @var{file} does not include a directory.
Note that for purposes of this function, a logical host is considered part of
the directory portion of @var{file}
@end deffn

@deffn Function file-name-without-directory (@w{(file @sc{file-name})}) : @sc{file-name} 
Return the file name portion of @var{file} by removing any
directory and logical host components.
@end deffn

@deffn Function file-name-without-extension (@w{(file @sc{file-name})}) : @sc{file-name} 
Remove @var{file}s extension (or type) if there is any and
return the result.
@end deffn

@deffn Function file-extension (@w{(file @sc{file-name})}) : @sc{string} 
Return @var{file}s extension (or type) if it has any including
the separator character.
@end deffn

@deffn Function file-base-name (@w{(file @sc{file-name})}) : @sc{file-name} 
Remove @var{file}s directory (including logical host) and
extension components and return the result.
@end deffn

@deffn Function absolute-pathname? (@w{(pathname @sc{string})}) : @sc{boolean} 
Not documented.
@end deffn

@deffn Function logical-host? (@w{(host @sc{string})}) : @sc{boolean} 
Not documented.
@end deffn

@deffn Function logical-pathname? (@w{(pathname @sc{string})}) : @sc{boolean} 
Not documented.
@end deffn

@deffn Function translate-logical-pathname (@w{(pathname @sc{string})}) : @sc{string} 
Not documented.
@end deffn

@deffn Function directory-separator () : @sc{character} 
Not documented.
@end deffn

@deffn Function directory-separator-string () : @sc{string} 
Not documented.
@end deffn


@c ---------------------------------------------------------------------------

@node Dates and Times, XML Support, Files, Library Functions
@section Dates and Times

@deffn Function get-current-date-time () : @sc{integer} @sc{integer} @sc{integer} @sc{keyword} @sc{integer} @sc{integer} @sc{integer} @sc{integer} 
Returns the current time in UTC as multiple values of
year month day day-of-week hour minute second millisecond.  Currently
millisecond will always be zero (even in Java where it is technically available).
@end deffn

@deffn Function get-local-time-zone () : @sc{float} 
Returns the current time zone offset from UTC as a float,
considering the effects of daylight savings time.
@end deffn

@c # $(util/texinfo-insert-doc FLOAT.get-calendar-date)
@c # $(util/texinfo-insert-doc FLOAT.get-time)
@deffn Function make-current-date-time () : @sc{calendar-date} 
Create a calendar date with current time and date.
@end deffn

@deffn Function make-date-time (@w{(year @sc{integer})} @w{(month @sc{integer})} @w{(day @sc{integer})} @w{(hour @sc{integer})} @w{(minute @sc{integer})} @w{(second @sc{integer})} @w{(millis @sc{integer})} @w{(timezone @sc{float})}) : @sc{calendar-date} 
Create a calendar date with the specified components.  @var{year} must be
the complete year (i.e., a year of 98 is 98 A.D in the 1st century).
@var{timezone} is a real number in the range -12.0 to +14.0 where UTC is zone 0.0;  The number
is the number of hours to add to UTC to arrive at local time.
@end deffn

@deffn Function parse-date-time (@w{(date-time-string @sc{string})} @w{(start @sc{integer})} @w{(end @sc{integer})} @w{(error-on-mismatch? @sc{boolean})}) : @sc{decoded-date-time} 
Tries very hard to make sense out of the argument @var{date-time-string} and
returns a time structure if successful.  If not, it returns @code{null}.
If @var{error-on-mismatch?} is true, parse-date-time will signal an error instead of
returning @code{null}.  
Default values are 00:00:00 local time on the current date
@end deffn

@defmethod @sc{calendar-date} decode-calendar-date (date @w{(timezone @sc{float})}) : @sc{decoded-date-time} 
Returns a decoded time object for @var{date} interpreted in @var{timezone}
@var{timezone} is the number of hours added to UTC to get local time.  It is 
in the range -12.0 to +14.0 where UTC is zone 0.0
@end defmethod

@defmethod @sc{decoded-date-time} encode-calendar-date (time-structure) : @sc{calendar-date} 
Returns a calendar date object for @var{time-structure}.
@end defmethod

@deffn ??? calendar-date-to-string
Not yet implemented.
@end deffn

@deffn Function string-to-calendar-date (@w{(input @sc{string})}) : @sc{calendar-date} 
Returns a calendar date object representing the date and time
parsed from the @var{input} string.  If no valid parse is found,
@code{null} is returned.
@end deffn

@deffn ??? relative-date-to-string
Not yet implemented.
@end deffn

@deffn Function compute-calendar-date (@w{(julian-day @sc{integer})}) : @sc{integer} @sc{integer} @sc{integer} @sc{keyword} 
Returns the YEAR, MONTH, DAY, DAY-OF-WEEK on which the given
@var{julian-day} begins at noon.
@end deffn

@deffn Function compute-day-of-week (@w{(yyyy @sc{integer})} @w{(mm @sc{integer})} @w{(dd @sc{integer})}) : @sc{keyword} 
Returns the day of the week for yyyy-mm-dd.
@end deffn

@deffn Function compute-day-of-week-julian (@w{(julian-day @sc{integer})}) : @sc{keyword} 
Returns the day of the week for julian-day
@end deffn

@deffn Function compute-julian-day (@w{(yyyy @sc{integer})} @w{(mm @sc{integer})} @w{(dd @sc{integer})}) : @sc{integer} 
Returns the Julian day that starts at noon on yyyy-mm-dd.
@var{yyyy} is the year.  @var{mm} is the month.  @var{dd} is the day of month.
Negative years are B.C.  Remember there is no year zero.
@end deffn

@deffn Function compute-next-moon-phase (@w{(n @sc{integer})} @w{(phase @sc{keyword})}) : @sc{integer} @sc{float} 
Returns the Julian Day and fraction of day of the Nth occurence
since January 1, 1900 of moon PHASE.  PHASE is one of :NEW-MOON, :FIRST-QUARTER,
:FULL-MOON, :LAST-QUARTER
@end deffn

@deffn Function decode-time-in-millis (@w{(time @sc{integer})}) : @sc{integer} @sc{integer} @sc{integer} @sc{integer} 
Returns multiple values of hours, minutes, seconds, milliseconds for
@var{time} specified in milliseconds.
@end deffn

@deffn Function julian-day-to-modified-julian-day (@w{(julian-day @sc{integer})}) : @sc{integer} 
Returns the modified Julian day during which @var{julian-day}starts at noon.
@end deffn

@deffn Function modified-julian-day-to-julian-day (@w{(modified-julian-day @sc{integer})}) : @sc{integer} 
Returns the modified Julian day during which @code{julian-day}starts at noon.
@end deffn

@deffn Function time-add (@w{(t1 @sc{date-time-object})} @w{(t2 @sc{date-time-object})}) : @sc{date-time-object} 
Add @var{t1} to @var{t2}.
If one of @var{t1} or @var{t2} is a calendar date, then the result is a calendar date.
If both @var{t1} and @var{t2} are relative dates, then the result is a relative date.
@var{t1} and @var{t2} cannot both be calendar dates.
@end deffn

@deffn Function time-divide (@w{(t1 @sc{time-duration})} @w{(t2 @sc{object})}) : @sc{object} 
Divides the relative date @var{t1} by @var{t2}.  @var{t2} must be
either a relative date or a wrapped number.  If @var{t2} is a relative date,
then the return value will be a wrapped float.  If @var{t2} is a wrapped number,
then the reutrn value will be a relative date.
@end deffn

@deffn Function time-multiply (@w{(t1 @sc{object})} @w{(t2 @sc{object})}) : @sc{time-duration} 
Multiplies a relative date by a wrapped number.  One of @var{t1} or @var{t2}
must be a relative date and the other a wrapped number.
@end deffn

@deffn Function time-subtract (@w{(t1 @sc{date-time-object})} @w{(t2 @sc{date-time-object})}) : @sc{date-time-object} 
Subtract @var{t2} from @var{t1}.  If @var{t1} is a calendar date, then @var{t2} can
be either a calendar date (in which case the return value is a relative date) or it
can be a relative date (in which case the return value is a calendar date).  If @var{t1}
is a relative date, then @var{t2} must also be a relative date and a relative date is returned.
@end deffn

@deffn Function get-ticktock () : @sc{ticktock} 
Return the current CPU time.  If the current OS/Language
combination does not support measuring of CPU time, return real time instead.
Use @code{ticktock-difference} to measure the time difference between values
returned by this function.  This is an attempt to provide some platform
independent support to measure (at least approximately) consumed CPU time.
@end deffn

@deffn Function ticktock-difference (@w{(t1 @sc{ticktock})} @w{(t2 @sc{ticktock})}) : @sc{float} 
The difference in two TICKTOCK time values in seconds where
@var{t1} is the earlier time.  The resolution is implementation dependent but will
normally be some fractional value of a second.
@end deffn

@deffn Function ticktock-resolution () : @sc{float} 
The minimum theoretically detectable resolution of the
difference in two TICKTOCK time values in seconds.  This
resolution is implementation dependent.  It may also not
be realizable in practice, since the timing grain size may
be larger than this resolution.
@end deffn

@deffn Function sleep (@w{(seconds @sc{float})}) : 
The program will sleep for the indicated number of seconds.
Fractional values are allowed, but the results are implementation dependent:
Common Lisp uses the fractions natively, Java with a resolution of 0.001,
and C++ can only use integral values.
@end deffn


@c ---------------------------------------------------------------------------

@node XML Support, Miscellaneous, Dates and Times, Library Functions
@section XML Support

@deffn Function make-xml-element (@w{(name @sc{string})} @w{(namespace-name @sc{string})} @w{(namespace @sc{string})}) : @sc{xml-element} 
Creates and interns an XML element object @var{name} using @var{namespace-name}
to refer to  @var{namespace}.  If @var{namespace} is @code{null}, then the element will
be interned in the null namespace.   @var{namespace} must otherwise be a URI.
@end deffn

@deffn Function make-xml-global-attribute (@w{(name @sc{string})} @w{(namespace-name @sc{string})} @w{(namespace @sc{string})}) : @sc{xml-global-attribute} 
Creates and interns an XML global attribute object with @var{name} using 
@var{namespace-name} to refer to  @var{namespace}.  @var{namespace}must be a URI.
@end deffn

@deffn Function make-xml-local-attribute (@w{(name @sc{string})} @w{(element @sc{xml-element})}) : @sc{xml-local-attribute} 
Make an XML-LOCAL-ATTRIBUTE named @var{name} associated with @var{element}
@end deffn

@deffn Function get-xml-tag (@w{(expression @sc{cons})}) : @sc{xml-element} 
Return the XML tag object of an XML @var{expression}.
@end deffn

@deffn Function get-xml-attributes (@w{(expression @sc{cons})}) : @sc{cons} 
Return the list of attributes of an XML @var{expression} (may be empty).
@end deffn

@deffn Function get-xml-content (@w{(expression @sc{cons})}) : @sc{cons} 
Return the list of content elements of an XML @var{expression} (may be empty).
@end deffn

@deffn Function get-xml-cdata-content (@w{(form @sc{cons})}) : @sc{string} 
Return the CDATA content of a CDATA @var{form}.  Does NOT make sure that @var{form}
actually is a CDATA form, so bad things can happen if it is given wrong input.
@end deffn

@deffn Function xml-declaration? (@w{(item @sc{object})}) : @sc{boolean} 
Return @code{true} if @var{item} is an XML declaration object
@end deffn

@deffn Function xml-element? (@w{(item @sc{object})}) : @sc{boolean} 
Return @code{true} if @var{item} is an XML element object
@end deffn

@deffn Function xml-attribute? (@w{(item @sc{object})}) : @sc{boolean} 
Return @code{true} if @var{item} is an XML attribute object
@end deffn

@deffn Function xml-cdata? (@w{(item @sc{object})}) : @sc{boolean} 
Return @code{true} if @var{item} is an XML CDATA tag object
@end deffn

@deffn Function xml-cdata-form? (@w{(form @sc{object})}) : @sc{boolean} 
Return @code{true} if @var{form} is a CONS headed by a CDATA tag
@end deffn

@defmethod @sc{xml-element} xml-element-match? (tag @w{(name @sc{string})} @w{(namespace @sc{string})}) : @sc{boolean} 
Returns @code{true} if @var{tag} is an XML element with the name @var{name}
in namespace @var{namespace}.  Note that @var{namespace} is the full URI, not an abbreviation.
Also, @var{namespace} may be @code{null}, in which case @var{tag} must not have a namespace
associated with it.
@end defmethod

@defmethod @sc{xml-attribute} xml-attribute-match? (attribute @w{(name @sc{string})} @w{(namespace @sc{string})}) : @sc{boolean} 
Return @code{true} if @var{attribute} is an XML attribute with name @var{name}
in namespace @var{namespace}.  Note that @var{namespace} is the full URI, not an
abbreviation.  Also, @var{namespace} may be @code{null}, in which case @var{attribute}
must not have a namespace associated with it.
@end defmethod

@defmethod @sc{xml-global-attribute} xml-attribute-match? (attribute @w{(name @sc{string})} @w{(namespace @sc{string})}) : @sc{boolean} 
Return @code{true} if @var{attribute} is a global  XML attribute with name @var{name}
in namespace @var{namespace}.  Note that @var{namespace} is the full URI, not an
abbreviation.  Also, @var{namespace} may be @code{null}, in which case @var{attribute}
must not have a namespace associated with it.
@end defmethod

@defmethod @sc{xml-local-attribute} xml-attribute-match? (attribute @w{(name @sc{string})} @w{(namespace @sc{string})}) : @sc{boolean} 
Return @code{true} if @var{attribute} is a local XML attribute with name @var{name}.
Note that @var{namespace} must be @code{null} and that the @var{attribute}s parent element
element is not considered by the match.  To take the parent element into
account use @code{xml-local-attribute-match?}.
@end defmethod

@deffn Function xml-local-attribute-match? (@w{(attribute @sc{xml-local-attribute})} @w{(name @sc{string})} @w{(element-name @sc{string})} @w{(element-namespace @sc{string})}) : @sc{boolean} 
Return true if @var{attribute} is a local attribute with @var{name} and whose
parent element matches @var{element-name} and @var{element-namespace}.
@end deffn

@deffn Function xml-lookup-attribute (@w{(attributes @sc{cons})} @w{(name @sc{string})} @w{(namespace @sc{string})}) : @sc{string} 
Find the XML attribute in @var{attributes} with @var{name} and @var{namespace} and
return its value.  Note that it is assumed that all @var{attributes} come from
the same known tag, hence, the parent elements of any local attributes are
not considered by the lookup.
@end deffn

@deffn Macro xml-tag-case (@w{(item @sc{object})} @w{&body (clauses @sc{cons})}) : @sc{object} 
A case form for matching @var{item} against XML element tags.  Each
element of @var{clauses} should be a clause with the form
  ("tagname" ...)     or
  (("tagname" "namespace-uri") ...)
The clause heads can optionally be symbols instead of strings.  The key forms the
parameters to the method @code{xml-element-match?}, with a missing namespace argument
passed as NULL.

The namespace argument will be evaluated, so one can use bound variables in
place of a fixed string.   As a special case, if the namespace argument is
:ANY, then the test will be done for a match on the tag name alone.
@end deffn

@c # $(util/texinfo-insert-doc xml-token-list-to-s-expression)
@deffn Function read-xml-expression (@w{(stream @sc{input-stream})} @w{(start-tag @sc{object})}) : @sc{object} @sc{boolean} 
Read one balanced XML expression from @var{stream} and return
its s-expression representation (see @code{xml-token-list-to-s-expression}).  If
@code{startTagName} is non-`null', skip all tags until a start tag matching @var{start-tag}
is encountered.  XML namespaces are ignored for outside of the start tag.
Use s-expression representation to specify @var{start-tag}, e.g., @code{(KIF (:version "1.0"))}.
The tag can be an XML element object, a symbol, a string or a cons.  If the tag is a cons
the first element can also be (name namespace) pair.

Return @code{true} as the second value on EOF.

CHANGE WARNING:  It is anticipated that this function will change to
 a) Properly take XML namespaces into account and
 b) require XML element objects instead of strings as the second argument.
This change will not be backwards-compatible.
@end deffn

@deffn Function xml-expressions (@w{(stream @sc{input-stream})} @w{(regionTag @sc{object})}) : @sc{xml-expression-iterator} 
Return an XML-expression-iterator (which see) reading from
@var{stream}.  @var{regionTag} can be used to define delimited regions from which
expressions should be considered. Use s-expression representation to specify
@var{regionTag}, e.g., @code{(KIF (:version "1.0"))}.  The tag can be an XML element
object, a symbol, a string or a cons.  If the tag is a cons the first element
can also be (name namespace) pair.
@end deffn

@deffn Function print-xml-expression (@w{(stream @sc{output-stream})} @w{(xml-expression @sc{cons})} @w{(indent @sc{integer})}) : 
Prints @var{xml-expression} on @var{stream}.  Indentation begins with the
value of @var{indent}.  If this is the @code{null} integer, no indentation is
performed.  Otherwise it should normally be specified as 0 (zero) for
top-level calls.

It is assumed that the @var{xml-expression} is a well-formed CONS-list
representation of an XML  form.  It expects a form like that form
returned by @code{read-XML-expression}.

Also handles a list of xml forms such as that returned by @code{XML-expressions}.
In that case, each of the forms is indented by @var{indent} spaces.
@end deffn

@deffn Function reset-xml-hash-tables () : 
Resets Hashtables used for interning XML elements and global
attribute objects.  This will allow garbage collection of no-longer used
objects, but will also mean that newly parsed xml elements and global attributes
will not be eq? to already existing ones with the same name.
@end deffn


@c ---------------------------------------------------------------------------

@node Miscellaneous,  , XML Support, Library Functions
@section Miscellaneous

This is a catch-all section for functions and methods that haven't been
categorized yet into any of the previous sections.  They are in random
order and many of them will never be part of the official STELLA
interface.  So beware!

@deffn Function operating-system () : @sc{keyword} 
Not documented.
@end deffn

@deffn Function activate-demon (@w{(demon @sc{demon})}) : 
Install @var{demon} in the location(s) specified by its internal
structure.
@end deffn

@defmethod @sc{polymorphic-relation} active? (self) : @sc{boolean} 
True if @var{self} or a superslot of @var{self} is marked active.
@end defmethod

@deffn Function add-configuration-property (@w{(property @sc{string})} @w{(value @sc{object})} @w{(configuration @sc{configuration-table})}) : @sc{object} 
Add @var{value} to @var{property} in @var{configuration} and return it.
If a previous value exists add @var{value} to the end (listify the old value
if it is not yet a list).  Otherwise, create a new list containing @var{value}.
Use the global system configuration table if @var{configuration} is NULL.
@end deffn

@deffn Function add-hook (@w{(hookList @sc{hook-list})} @w{(hookFunction @sc{symbol})}) : 
Insert the function named @var{hookFunction} into @var{hookList}.
@end deffn

@deffn N-Command add-trace (@w{&rest (keywords @sc{generalized-symbol})}) : @sc{list} 
Enable trace messages identified by any of the listed @var{keywords}.  After
calling (@code{add-trace} <keyword>) code guarded by (@code{trace-if} <keyword> ...)
will be executed when it is encountered.
@end deffn

@deffn Function advance-past-whitespace (@w{(source @sc{string})} @w{(start @sc{integer})}) : @sc{integer} 
Returns the first index into @var{source}, starting from @var{start}, of
the first character that is not white space.
@end deffn

@deffn Function all-classes (@w{(module @sc{module})} @w{(local? @sc{boolean})}) : @sc{(iterator of class)} 
Iterate over all classes visible from @var{module}.
If @var{local?}, return only classes interned in @var{module}.
If @var{module} is null, return all classes interned everywhere.
@end deffn

@deffn Function all-contexts () : @sc{(iterator of context)} 
Return an iterator that generates all contexts.
@end deffn

@deffn Macro all-defined? (@w{&body (forms @sc{cons})}) : @sc{object} 
Evaluate each of the forms in @var{forms}, and
return TRUE if none of them are NULL.
@end deffn

@deffn Function all-functions (@w{(module @sc{module})} @w{(local? @sc{boolean})}) : @sc{(iterator of function)} 
Iterate over all functions visible from @var{module}.
If @var{local?}, return only functions bound to symbols interned in @var{module}.
If @var{module} is null, return all functions defined everywhere.
@end deffn

@deffn Function all-included-modules (@w{(self @sc{module})}) : @sc{(iterator of module)} 
Generate a sequence of all modules included
by @var{self}, inclusive, starting from the highest ancestor and working
down to @var{self} (which is last).
@end deffn

@deffn Function all-methods (@w{(module @sc{module})} @w{(local? @sc{boolean})}) : @sc{(iterator of method-slot)} 
Iterate over all methods visible from @var{module}.
If @var{local?}, return only methods interned in @var{module}.
If @var{module} is null, return all methods interned everywhere.
@end deffn

@deffn Function all-modules () : @sc{(iterator of module)} 
Return an iterator that generates all modules.
@end deffn

@deffn Function all-public-functions (@w{(module @sc{module})} @w{(local? @sc{boolean})}) : @sc{(iterator of function)} 
Iterate over all functions visible from @var{module}.
If @var{local?}, return only functions bound to symbols interned in @var{module}.
If @var{module} is null, return all functions defined everywhere.
@end deffn

@deffn Function all-public-methods (@w{(module @sc{module})} @w{(local? @sc{boolean})}) : @sc{(iterator of method-slot)} 
Iterate over all public methods visible from @var{module}.
If @var{local?}, return only methods interned in @var{module}.
If @var{module} is null, return all methods interned everywhere.
@end deffn

@deffn Function all-required-systems (@w{(system-name @sc{string})}) : @sc{(cons of string-wrapper)} 
Returns a CONS of all of the systems required by @var{system-name}
@end deffn

@deffn Function all-slots (@w{(module @sc{module})} @w{(local? @sc{boolean})}) : @sc{(iterator of slot)} 
Iterate over all slots visible from @var{module}.
If @var{local?}, return only methods interned in @var{module}.
If @var{module} is null, return all methods interned everywhere.
@end deffn

@deffn Function all-subcontexts (@w{(context @sc{context})} @w{(traversal @sc{keyword})}) : @sc{(all-purpose-iterator of context)} 
Return an iterator that generates all subcontexts of
@code{self} (not including @code{self}) in the order specified by @var{traversal} (one
of :preorder, :inorder, :postorder or :topdown).
@end deffn

@deffn Function all-surrogates (@w{(module @sc{module})} @w{(local? @sc{boolean})}) : @sc{(iterator of surrogate)} 
Iterate over all surrogates visible from @var{module}.
If @var{local?}, return only surrogates interned in @var{module}.
If @var{module} is null, return all surrogates interned everywhere.
@end deffn

@deffn Function all-symbols (@w{(module @sc{module})} @w{(local? @sc{boolean})}) : @sc{(iterator of symbol)} 
Iterate over all symbols visible from @var{module}.
If @var{local?}, return only symbols interned in @var{module}.
If @var{module} is null, return all symbols interned everywhere.
@end deffn

@deffn Function all-variables (@w{(module @sc{module})} @w{(local? @sc{boolean})}) : @sc{(iterator of global-variable)} 
Iterate over all variables visible from @var{module}.
If @var{local?}, return only variables bound to symbols interned in @var{module}.
If @var{module} is null, return all variables defined everywhere.
@end deffn

@defmethod @sc{abstract-iterator} allocate-iterator (self) : @sc{(like self)} 
Iterator objects return themselves when asked
for an iterator (they occupy the same position as a collection
within a @code{foreach} statement).
@end defmethod

@defmethod @sc{memoizable-iterator} allocate-iterator (self) : @sc{(iterator of (like (any-value self)))} 
Alias for @code{clone-memoized-iterator}.
@end defmethod

@defmethod @sc{storage-slot} allocation (self) : @sc{keyword} 
Return the most specific :allocation facet, or
:instance if all inherited values are NULL.
@end defmethod

@deffn Function apply (@w{(code @sc{function-code})} @w{(arguments @sc{(cons of object)})}) : @sc{object} 
Apply @var{code} to @var{arguments}, returning a value of type
OBJECT.
@end deffn

@deffn Function apply-boolean-method (@w{(code @sc{method-code})} @w{(arguments @sc{(cons of object)})}) : @sc{boolean} 
Apply @var{code} to @var{arguments}, returning a value of type
BOOLEAN.
@end deffn

@deffn Function apply-float-method (@w{(code @sc{method-code})} @w{(arguments @sc{(cons of object)})}) : @sc{float} 
Apply @var{code} to @var{arguments}, returning a value of type
FLOAT.
@end deffn

@deffn Function apply-integer-method (@w{(code @sc{method-code})} @w{(arguments @sc{(cons of object)})}) : @sc{integer} 
Apply @var{code} to @var{arguments}, returning a value of type
INTEGER.
@end deffn

@deffn Function apply-method (@w{(code @sc{method-code})} @w{(arguments @sc{(cons of object)})}) : @sc{object} 
Apply @var{code} to @var{arguments}, returning a value of type
OBJECT.
@end deffn

@deffn Function apply-string-method (@w{(code @sc{method-code})} @w{(arguments @sc{(cons of object)})}) : @sc{string} 
Apply @var{code} to @var{arguments}, returning a value of type
STRING.
@end deffn

@deffn Function base60-to-float (@w{(l @sc{(cons of number-wrapper)})}) : @sc{float} 
Converts (x y z) into a float.  The return value
is x + y/60 + z/3600.
This can be used to convert from Degree-Minute-Second to decimal degrees
or from Hour-Minute-Second format to decimal hours.
@end deffn

@deffn Function break-program (@w{(message @sc{string})}) : 
Interrupt the program and print @var{message}.  Continue after
confirmation with the user.
@end deffn

@deffn Function byte-array-read-sequence (@w{(buffer @sc{tokenizer-byte-array})} @w{(stream @sc{input-stream})} @w{(start @sc{integer})} @w{(end @sc{integer})}) : @sc{integer} 
Read from @var{stream} filling @var{buffer} between @var{start} and @var{end} (depending
on how many characters are available).
Return the actual end pointer to the input read into @var{buffer}.  EOF is
indicated by the return value being equal to start.
@end deffn

@deffn Function byte-array-write-sequence (@w{(buffer @sc{tokenizer-byte-array})} @w{(stream @sc{native-output-stream})} @w{(start @sc{integer})} @w{(end @sc{integer})}) : 
Write from @var{buffer} to @var{stream}, using data in the buffer starting at position
@var{start} stopping just before @var{end}.
@end deffn

@defmethod @sc{calendar-date} calendar-date-to-date-string (date @w{(timezone @sc{float})} @w{(numeric-month? @sc{boolean})}) : @sc{string} 
Returns the date part of the string representation of @var{date} 
adjusted for @var{timezone}.  Format is YYYY-MMM-DD, where MMM is a three letter
English abbreviation of the month if @var{numeric-month?} is @code{false} and a two
digit numeric value if @var{numeric-month?} is @code{true}.  The value @code{false} is
recommended.
@end defmethod

@defmethod @sc{calendar-date} calendar-date-to-iso8601-string (date @w{(timezone @sc{float})} @w{(include-timezone? @sc{boolean})}) : @sc{string} 
Returns an ISO-8601 string representation of @var{date} adjusted for @var{timezone}.
The Format is YYYY-MM-DDThh:mm:ss z:zz.  The timezone as an offset
hh:mm is included if @var{include-timezone?} is @code{true}.

Recommended values for the flag is @code{true}.
@end defmethod

@defmethod @sc{calendar-date} calendar-date-to-string (date @w{(timezone @sc{float})} @w{(numeric-month? @sc{boolean})} @w{(include-timezone? @sc{boolean})}) : @sc{string} 
Returns a string representation of @var{date} adjusted for @var{timezone}.
The Format is YYYY-MMM-DD hh:mm:ss z.z, where MMM is a three letter
English abbreviation of the month if @var{numeric-month?} is @code{false} and a two
digit numeric value if @var{numeric-month?} is @code{true}.  The timezone as a
float offset z.z is included if @var{include-timezone?} is @code{true}.

Recommended values for the flags are @code{false} and @code{true} respectively.
@end defmethod

@defmethod @sc{calendar-date} calendar-date-to-time-string (date @w{(timezone @sc{float})} @w{(include-timezone? @sc{boolean})} @w{(include-millis? @sc{boolean})} @w{(pad-hours? @sc{boolean})}) : @sc{string} 
Returns the time part of the string representation of @var{date}
adjusted for @var{timezone}.  The timezone is included in the string if
@var{include-timezone?} is @code{true}.  The value @code{true} is recommended.
Milliseconds will be included if @var{include-millis?} is @code{true}.
Hours will be zero-padded to length 2 if @var{pad-hours?} is @code{true}.

@end defmethod

@deffn Command call-clear-module (@w{&rest (name @sc{name})}) : 
Destroy all objects belonging to module @var{name} or any of its children.
If no @var{name} is supplied, the current module will be cleared after
confirming with the user.  Important modules such as STELLA are protected
against accidental clearing.
@end deffn

@deffn Function cast (@w{(value @sc{object})} @w{(type @sc{type})}) : @sc{object} 
Perform a run-time type check, and then return @var{value}.
@end deffn

@deffn N-Command ccc (@w{&rest (name @sc{name})}) : @sc{context} 
Change the current context to the one named @var{name}.  Return the
value of the new current context.  If no @var{name} is supplied, return
the pre-existing value of the current context.  @code{cc} is a no-op if the
context reference cannot be successfully evaluated.
In CommonLisp, if the new context is case sensitive, then change
the readtable case to :INVERT, otherwise to :UPCASE.
@end deffn

@deffn Function cl-slot-value (@w{(object @sc{object})} @w{(slotName @sc{string})} @w{(dontConvert? @sc{boolean})}) : @sc{lisp-code} 
Lookup slot @var{slotName} on @var{object} and return the lispified
slot value (see @code{lispify}).  If @var{dontConvert?} is TRUE, the returned slot value
will not be lispified.  Generate a warning if no such slot exists on @var{object}.
In a call directly from Lisp @var{slotName} can also be supplied as a Lisp symbol.
@end deffn

@deffn Function cl-slot-value-setter (@w{(object @sc{object})} @w{(slotName @sc{string})} @w{(value @sc{lisp-code})} @w{(dontConvert? @sc{boolean})}) : @sc{lisp-code} 
Lookup slot @var{slotName} on @var{object} and set its value to
the stellafied @var{value} (see @code{stellafy}).  If @var{dontConvert?} is TRUE, @var{value}
will not be stellafied before it gets assigned.  Generate a warning if no
such slot exists on @var{object}, or if @var{value} has the wrong type.  In a call
directly from Lisp @var{slotName} can also be supplied as a Lisp symbol.
@end deffn

@deffn Function cl-translate-file (@w{(file @sc{file-name})} @w{(relative? @sc{boolean})}) : 
Translate a Stella @var{file} to Common-Lisp.  If
@var{relative?}, concatenate root directory to @var{file}.
@end deffn

@deffn Function cl-translate-system (@w{(system-name @sc{string})}) : 
Translate a Stella system named @var{system-name} to Common Lisp.
@end deffn

@deffn Function cleanup-unfinalized-classes () : 
Remove all finalized classes from @code{*UNFINALIZED-CLASSES*},
and set @code{*NEWLY-UNFINALIZED-CLASSES?*} to @code{false}.
@end deffn

@deffn Function clear-configuration-property (@w{(property @sc{string})} @w{(configuration @sc{configuration-table})}) : @sc{object} 
Remove @var{property} in @var{configuration} and return the previous
value.
Use the global system configuration table if @var{configuration} is NULL.
@end deffn

@deffn Function clear-recycle-list (@w{(list @sc{recycle-list})}) : 
Reset @var{list} to its empty state.
@end deffn

@deffn Function clear-recycle-lists () : 
Reset all currently active recycle lists to their empty state.
@end deffn

@deffn Function clear-system (@w{(name @sc{string})}) : 
Clears out the system definition named @var{name}.  If
@var{name} is @code{null}, then clear out all system definitions.  This function
is useful when changes have been made to the system definition, and one
wants to have it reloaded from the standard location in the file system.
@end deffn

@deffn Command clear-trace () : 
Disable all tracing previously enabled with @code{add-trace}.
@end deffn

@deffn Function clone-memoized-iterator (@w{(self @sc{memoizable-iterator})}) : @sc{(iterator of (like (any-value self)))} 
Clone the memoized iterator @var{self} so it can be used to
iterate over the collection represented by @var{self}, while allowing to iterate
over it multiple times via multiple clones.
@end deffn

@deffn Macro coerce-&rest-to-cons (@w{(restVariable @sc{symbol})}) : @sc{object} 
Coerce the argument list variable @var{restVariable} into a CONS
list containing all its elements (uses argument list iteration to do so).  If
@var{restVariable} already is a CONS due to argument listification, this is a no-op.
@end deffn

@deffn Function coerce-to-symbol (@w{(name @sc{name})}) : @sc{generalized-symbol} 
Return the (generalized) symbol represented by @var{name}.
Return @code{null} if @var{name} is undefined or does not represent a string.
@end deffn

@deffn Macro collect (@w{&body (body @sc{cons})}) : @sc{object} 
Use a VRLET to collect values.  Input can have one of
the following forms:

@example 
  (collect <var> in <expression> [where <test> <var>])
  (collect <collect-expression>
           foreach <var> in <expression>
           @{as ...@}*
           [where <test> <var>]
           [do ...])
@end example

The second form really accepts an arbitrary @code{foreach} expression following
the @code{foreach} keyword.
@end deffn

@defmethod @sc{slot} collection-valued? (self) : @sc{boolean} 
True if slot values are collections.
@end defmethod

@deffn Function command? (@w{(method @sc{method-slot})}) : @sc{boolean} 
Return @code{true} if @var{method} is an evaluable command.
@end deffn

@defmethod @sc{storage-slot} component? (self) : @sc{boolean} 
True if fillers of this slot are components of the
owner slot, and therefore should be deleted if the owner is deleted.
@end defmethod

@deffn Function compose-namestring (@w{(name-components @sc{(cons of string-wrapper)})} @w{&rest (options @sc{object})}) : @sc{string} 
@var{name-components} is a cons to be processed into a namestring.
@code{:prefix} and @code{:suffix} are strings that will NOT be case-converted.
@code{:case} is one of :UPCASE :TitleCase :titleCaseX :downcase :Capitalize
        default is :TitleCase
@code{:separator} is a string that should separate word elements.  It does not
       separate the prefix or suffix.  Default is ""
@code{:translation-table} should be a STRING-HASH-TABLE hash table that strings into their
       desired printed representation as a string.  In general the argument
       will be strings, but that is not strictly necessary.

@end deffn

@deffn Function compose-namestring-full (@w{(strings @sc{(cons of string-wrapper)})} @w{(prefix @sc{string})} @w{(suffix @sc{string})} @w{(outputcase @sc{keyword})} @w{(outputseparator @sc{string})} @w{(translationtable @sc{string-hash-table})} @w{(useacronymheuristics? @sc{boolean})}) : @sc{string} 
Non-keyword version of @code{compose-namestring}, which will probably be
easier to use when called from non-Lisp languages.
@end deffn

@deffn Function compute-module-and-bare-name (@w{(name @sc{string})}) : @sc{module} @sc{string} 
Compute the module indicated by the STELLA name
@var{name} and return it.  Return the bare symbol name as the second
value.  @var{name} does not necessarily have to be qualified in which
case the current module is returned.  @var{name} is assumed to be the
printed representation of a STELLA symbol, surrogate or keyword.
@end deffn

@deffn Function configure-stella (@w{(file @sc{file-name})}) : 
Perform STELLA run-time configuration.  If supplied, load the
configuration file @var{file} first which should be supplied with a physical pathname.
@end deffn

@defmethod @sc{object} consify (self) : @sc{cons} 
If @code{object} is a CONS, return it.  Otherwise, return
a singleton cons list containing it.
@end defmethod

@deffn Function consify-command-line-arguments (@w{(count @sc{integer})} @w{(arguments @sc{(array () of string)})}) : @sc{(cons of string-wrapper)} 
Convert @var{count} command line @var{arguments} into a CONS list.
@end deffn

@deffn Macro continuable-error (@w{&body (body @sc{cons})}) : @sc{object} 
Signal error message, placing non-string arguments in quotes.
@end deffn

@deffn Function cpp-translate-system (@w{(systemName @sc{string})}) : 
Translate the system @var{systemName} to C++.
@end deffn

@deffn N-Command cpptrans (@w{(statement @sc{object})}) : 
Translate @var{statement} to C++ and print the result.
@end deffn

@deffn Function create-derived-list (@w{(self @sc{list})}) : @sc{list} 
Create a new list object with the same type as @var{self}.
@end deffn

@deffn Function create-object (@w{(type @sc{type})} @w{&rest (initial-value-pairs @sc{object})}) : @sc{object} 
Funcallable version of the @code{new} operator.
Return an instance of the class named by @var{type}.  If @var{initial-value-pairs}
is supplied, it has to be a key/value list similar to what's accepted by @code{new}
and the named slots will be initialized with the supplied values.  Similar to
@code{new}, all required arguments for @var{type} must be included.  Since all the
slot initialization, etc. is handled dynamically at run time, @code{create-object}
is much slower than @code{new}; therefore, it should only be used if @var{type} cannot
be known at translation time.
@end deffn

@deffn Function deactivate-demon (@w{(demon @sc{demon})}) : 
Detach @var{demon} from the location(s) specified by its internal
structure.
@end deffn

@defmethod @sc{decoded-date-time} decoded-date-time-to-iso8601-string (date) : @sc{string} 
Returns an ISO-8601 string representation of @var{date}
The Format is YYYY-MM-DDThh:mm:ss+zz:zz, with the string stopping at
when a null value is first encountered.  The time zone will only
be included (if present) if a time value is given.
@end defmethod

@deffn Function decompose-namestring (@w{(namestring @sc{string})} @w{&rest (options @sc{object})}) : @sc{(cons of string-wrapper)} 
Keyword options:
  :break-on-cap    one of  :YES :NO :CLEVER         default is :CLEVER
  :break-on-number one of  :YES :NO :CLEVER         default is :CLEVER
  :break-on-separators string                       default is "-_ "

  DECOMPOSE-NAMESTRING returns a cons of STRING-WRAPPERS that are the decomposition of the
input STRING.  The arguments are used as follows:
  @var{namestring}       is the input string.
  :break-on-cap    is a keyword controlling whether changes in capitalization is used
                   to indicate word boundaries.  If :YES, then all capitalization
                   changes delineate words.  If :CLEVER, then unbroken runs of
                   capitalized letters are treated as acronyms and remain grouped.
                   If :NO or NULL, there is no breaking of words based on capitalization.
  :break-on-number is a flag controlling whether encountering a number indicates
                   a word boundary.  If :YES, then each run of numbers is treated as
		   a word separate from surrounding words.  If :CLEVER, then an 
		   attempt is made to recognize ordinal numbers (ie, 101st) and
		   treat them as separate words.  If :NO or NULL, there is no breaking
                   of words when numbers are encountered.
  :break-on-separators   A string of characters which constitute word delimiters in
                         the input word.  This is used to determine how to break
                   the name into individual words.  Defaults are space, @code{-} and @code{_}.
@end deffn

@deffn Function decompose-namestring-full (@w{(namestring @sc{string})} @w{(break-on-cap @sc{keyword})} @w{(break-on-number @sc{keyword})} @w{(break-on-separators @sc{string})}) : @sc{(cons of string-wrapper)} 
Non-keyword version of @code{decompose-namestring}, which will probably be
easier to use when called from non-Lisp languages.
@end deffn

@defmethod @sc{storage-slot} default-form (self) : @sc{object} 
Returns the current value of default expression when the
slot has not been assigned a value.
@end defmethod

@deffn Macro defdemon (@w{(name @sc{string-wrapper})} @w{(parameterstree @sc{cons})} @w{&body (optionsandbody @sc{cons})}) : @sc{object} 
Define a demon @var{name} and attach it to a class or slot.
@end deffn

@deffn Function define-demon (@w{(name @sc{string})} @w{&rest (options @sc{object})}) : @sc{demon} 
Define a class or slot demon.  Options are :create,
:destroy, :class, :slot, :guard?, :code, :method, :inherit?, and :documentation.
@end deffn

@deffn Function define-logical-host-property (@w{(host @sc{string})} @w{(property @sc{keyword})} @w{(value @sc{object})}) : 
Define @var{property} with @var{value} for the logical host @var{host}.
As a side-effect, this also defines @var{host} as a logical host (both
@var{property} and @var{value} can be supplied as NULL).  If :ROOT-DIRECTORY
is specified, all pathnames with @var{host} are assumed to be relative to
that directory (even if they are absolute) and will be rerooted upon
translation.  :ROOT-DIRECTORY can be a logical or physical pathname.
If :LISP-TRANSLATIONS is specified, those will be used verbatimely as
the value of @code{(CL:logical-pathname-translations host)} if we are
running in Lisp, which allows us to depend on the native
@code{CL:translate-logical-pathname} for more complex translation operations.
@end deffn

@deffn Function define-module (@w{(name @sc{string})} @w{(options @sc{cons})}) : @sc{module} 
Define or redefine a module named @var{name} having the
options @var{options}.  Return the new module.
@end deffn

@deffn Function define-stella-class (@w{(name @sc{type})} @w{(supers @sc{(list of type)})} @w{(slots @sc{(list of slot)})} @w{(options @sc{keyword-key-value-list})}) : @sc{class} 
Return a Stella class with name @var{name}.
Caution:  If the class already exists, the Stella class object gets
redefined, but the native C++ class is not redefined.
@end deffn

@deffn Function define-stella-method-slot (@w{(inputname @sc{symbol})} @w{(returntypes @sc{cons})} @w{(function? @sc{boolean})} @w{(inputParameters @sc{cons})} @w{(options @sc{keyword-key-value-list})}) : @sc{method-slot} 
Define a new Stella method object (a slot), and attach it
to the class identified by the first parameter in @var{inputParameters}.
@end deffn

@defmethod @sc{array} defined? (x) : @sc{boolean} 
Return true if @var{x} is defined (handled specially by all translators).
@end defmethod

@deffn Macro defmain (@w{(varList @sc{cons})} @w{&body (body @sc{cons})}) : @sc{object} 
Defines a function called MAIN which will have the appropriate
signature for the target translation language.  The signature will be:
  C++:   public static int main (int v1, char** v2) @{<body>@}
  Java:  public static void main (String [] v2) @{<body>@}
  Lisp:  (defun main (&rest args) <body>)
The argument @var{varList} must have two symbols, which will be the names for the
INTEGER argument count and an array of STRINGs with the argument values.  It
can also be empty to indicate that no command line arguments will be handled.
The startup function for the containing system will automatically be called
before @var{body} is executed unless the option :STARTUP-SYSTEM? was supplied as
FALSE.  There can only be one DEFMAIN per module.
@end deffn

@deffn N-Command defsystem (@w{(name @sc{symbol})} @w{&rest (options @sc{object})}) : @sc{system-definition} 
Define a system of files that collectively define
a Stella application.
   Required options are:
   :directory -- the relative path from the respective source/native/binary root directory
                 to the directory containing the system files.  Can be a string or a list
                 of strings (do not include directory separators).
   :files -- a list of files in the system, containing strings and lists
             of strings; the latter defines exploded paths to files
             in subdirectories.
   Optional options are:
   :required-systems -- a list of systems (strings) that should be loaded
                        prior to loading this system.
   :cardinal-module -- the name (a string) of the principal module for this
                       system.
   :copyright-header -- string with a header for inclusion into all translated
                        files produced by Stella.
   :lisp-only-files  -- Like the :files keyword, but these are only included
   :cpp-only-files      in the translation for the specific language, namely
   :java-only-files     Common Lisp, C++ or Java
@end deffn

@defmethod @sc{object} deleted? (self) : @sc{boolean} 
Default @code{deleted?} method which always returns FALSE.  Objects
that inherit DYNAMIC-SLOTS-MIXIN also inherit the dynamically-allocated slot
@code{deleted-object?} which is read/writable with specializations of this method.
@end defmethod

@deffn N-Command describe (@w{(name @sc{object})} @w{&rest (mode @sc{object})}) : 
Print a description of an object in :verbose, :terse,
or :source modes.
@end deffn

@defmethod @sc{object} describe-object (self @w{(stream @sc{output-stream})} @w{(mode @sc{keyword})}) : 
Prints a description of @var{self} to stream @var{stream}.  @var{mode}
can be :terse, :verbose, or :source.  The :terse mode is often equivalent
to the standard print function.
@end defmethod

@defmethod @sc{class} destroy-class (self) : 
Destroy the Stella class @var{self}.  
Unfinalize its subclasses (if it has any).
@end defmethod

@deffn Function destroy-class-and-subclasses (@w{(self @sc{class})}) : 
Destroy the Stella class @var{self} and all its subclasses.
@end deffn

@deffn Function destructure-defmethod-tree (@w{(method-tree @sc{cons})} @w{(options-table @sc{key-value-list})}) : @sc{object} @sc{cons} @sc{cons} 
Return three parse trees representing the name,
parameters, and code body of the parse tree @var{method-tree}.  Fill
@var{options-table} with a dictionary of method options.
Storage note:  Options are treated specially because the other return
values are subtrees of @var{method-tree}, while @var{options-table} is a newly-created
cons tree.  Note also, the parameter and body trees are destructively
removed from @var{method-tree}.
@end deffn

@deffn Function dictionary (@w{(collectionType @sc{type})} @w{&rest (alternatingkeysandvalues @sc{object})}) : @sc{(abstract-dictionary of object object)} 
Return a dictionary of @var{collectionType} containing @code{values}, in order.
Currently supported @var{collectionType}s are @@HASH-TABLE, @@STELLA-HASH-TABLE,
@@KEY-VALUE-LIST, @@KEY-VALUE-MAP and @@PROPERTY-LIST.
@end deffn

@defmethod @sc{class} direct-super-classes (self) : @sc{(iterator of class)} 
Returns an iterator that generates all direct
super classes of @var{self}.
@end defmethod

@deffn Command disable-memoization () : 
Enable memoization and use of memoized expression results.
@end deffn

@deffn Function disabled-stella-feature? (@w{(feature @sc{keyword})}) : @sc{boolean} 
Return true if the STELLA @var{feature} is currently disabled.
@end deffn

@deffn Function drop-hook (@w{(hookList @sc{hook-list})} @w{(hookFunction @sc{symbol})}) : 
Remove the function named @var{hookFunction} from @var{hookList}.
@end deffn

@deffn N-Command drop-trace (@w{&rest (keywords @sc{generalized-symbol})}) : @sc{list} 
Disable trace messages identified by any of the listed @var{keywords}.  After
calling (@code{drop-trace} <keyword>) code guarded by (@code{trace-if} <keyword> ...)
will not be executed when it is encountered.
@end deffn

@deffn Macro either (@w{(value1 @sc{object})} @w{(value2 @sc{object})}) : @sc{object} 
If @var{value1} is defined, return that, else return @var{value2}.
@end deffn

@defmethod @sc{string-wrapper} empty? (x) : @sc{boolean} 
Return true if @var{x} is the wrapped empty string ""
@end defmethod

@deffn Command enable-memoization () : 
Enable memoization and use of memoized expression results.
@end deffn

@deffn Function enabled-stella-feature? (@w{(feature @sc{keyword})}) : @sc{boolean} 
Return true if the STELLA @var{feature} is currently enabled.
@end deffn

@deffn Function ensure-file-does-not-exist (@w{(filename @sc{string})} @w{(context @sc{string})}) : 
Ensures that @var{filename} does not exist.  If it does,
an exception of type @code{FILE-ALREADY-EXISTS-EXCEPTION} is thrown
with @var{context} supplying context for the error message.
@end deffn

@deffn Function ensure-file-exists (@w{(filename @sc{string})} @w{(context @sc{string})}) : 
Ensures that @var{filename} exists.  If not, an exception of
type @code{NO-SUCH-FILE-EXCEPTION} is thrown with @var{context} supplying
context for the error message.
@end deffn

@deffn Function eql-except-in-whitespace? (@w{(s1 @sc{string})} @w{(s2 @sc{string})}) : @sc{boolean} 
Return @code{true} if the strings @var{s1} and @var{s2} are the same
except for the amounts of whitespace separating words.  Leading or
trailing whitespace is also not considered.
@end deffn

@deffn Macro error (@w{&body (body @sc{cons})}) : @sc{object} 
Signal error message, placing non-string arguments in quotes.
@end deffn

@deffn Function evaluate (@w{(expression @sc{object})}) : @sc{object} 
Evaluate the expression @var{expression} and return the result.
Currently, only the evaluation of (possibly nested) commands and global
variables is supported.  The second return value indicates the actual type 
of the result (which might have been wrapped), and the third return value
indicates whether an error occurred during the evaluation.  Expressions
are simple to program in Common Lisp, since they are built into the language,
and relatively awkward in Java and C++.  Users of either of those 
languages are more likely to want to call @code{evaluate-string}.
@end deffn

@deffn Function evaluate-string (@w{(expression @sc{string})}) : @sc{object} 
Evaluate the expression represented by @var{expression} and return the result.
This is equivalent to @code{(evaluate (unstringify expression))}.
@end deffn

@deffn Function exception-message (@w{(e @sc{native-exception})}) : @sc{string} 
Accesses the error message of the exception @var{e}.
@end deffn

@defmethod @sc{class} extension (self) : @sc{class-extension} 
Return the nearest class extension that records instances
of the class @var{self}.
@end defmethod

@deffn Function external-id-head? (@w{(attribute @sc{object})}) : @sc{boolean} 
Checks to see if this @var{attribute} is the literal marking either
a PUBLIC or SYSTEM literal for an XML Elternal ID.  (See 4.2.2)
@end deffn

@deffn Function fill-in-date-substitution (@w{(substitution-list @sc{(key-value-list of string-wrapper string-wrapper)})}) : 
Fill in @var{substitution-list} with template variable substitions
for the names YEAR and DATE which correspond to the current year and date.
These substitutions can then be used with @code{substitute-template-variables-in-string}
@end deffn

@deffn Function finalize-classes () : 
Finalize all currently unfinalized classes.
@end deffn

@deffn Function finalize-classes-and-slots () : 
Finalize all currently unfinalized classes and slots.
@end deffn

@deffn Function finalize-slots () : 
Finalize all currently unfinalized slots.
@end deffn

@deffn Function find-matching-prefix-length (@w{(string1 @sc{string})} @w{(start1 @sc{integer})} @w{(end1 @sc{integer})} @w{(string2 @sc{string})} @w{(start2 @sc{integer})} @w{(end2 @sc{integer})}) : @sc{integer} 
Finds the length of the matching prefix strings of @var{string1} and
@var{string2}, starting at position @var{start1} and @var{start2} respectively.
The search will end when @var{end1} or @var{end2} is reached.  If either @var{end1}
or @var{end2} is null, then they will be set to the length of their respective
strings.
@end deffn

@deffn Function find-mismatch (@w{(string1 @sc{string})} @w{(start1 @sc{integer})} @w{(end1 @sc{integer})} @w{(string2 @sc{string})} @w{(start2 @sc{integer})} @w{(end2 @sc{integer})}) : @sc{integer} @sc{integer} 
Finds the first position in each of @var{string1} and @var{string2} where
they mismatch, starting at position @var{start1} and @var{start2} respectively.
The search will end when @var{end1} or @var{end2} is reached.  If either @var{end1}
or @var{end2} is null, then they will be set to the length of their respective
strings.  If there is no mismatch, then @code{null} values are returned.
@end deffn

@deffn Macro first-defined (@w{&body (forms @sc{cons})}) : @sc{object} 
Return the result of the first form in @var{forms} whose value is defined
or NULL otherwise.
@end deffn

@deffn Function float-to-base60 (@w{(x @sc{float})} @w{(all-integers? @sc{boolean})}) : @sc{(cons of number-wrapper)} 
Returns a cons of @var{x} in a base-60 form.  That means
the first value will be the integer part of @var{x}, the next value
the iteger value of the fraction part of @var{x} times 60 and the
third value the fraction part of @var{x} time 3600.  If @var{all-integers?}
is @code{true}, then the last value will be rounded to an integer.
This can be used to convert from decimal degree values to Degree-Minute-Second
or from decimal hours to Hour-Minute-Second format.
@end deffn

@deffn Function fmod (@w{(x @sc{float})} @w{(modulus @sc{float})}) : @sc{float} 
True modulus for floats.  Return the result of @var{x} mod @code{modulo}.
Note: In C++ and Java, @code{mod} has more overhead than the similar
function @code{rem}.  The  answers returned by @code{mod} and @code{rem} are only
different when the signs of @var{x} and @code{modulo} are different.
@end deffn

@deffn Function format-with-padding (@w{(input @sc{string})} @w{(length @sc{integer})} @w{(padchar @sc{character})} @w{(align @sc{keyword})} @w{(truncate? @sc{boolean})}) : @sc{string} 
Formats @var{input} to be (at least) @var{length} long, using @var{padchar} to
fill if necessary.  @var{align} must be one of :LEFT, :RIGHT, :CENTER and will control
how @var{input} will be justified in the resulting string.  If @var{truncate?} is true, then
then an overlength string will be truncated, using the opposite of @var{align} to pick
the truncation direction.
@end deffn

@defmethod @sc{active-object} free (self) : 
Remove all pointers between @var{self} and other objects,
and then deallocate the storage for self.
@end defmethod

@defmethod @sc{object} free (self) : 
Default method.  Deallocate storage for @var{self}.
@end defmethod

@defmethod @sc{abstract-hash-table} free-hash-table-values (self) : 
Call free on each value in the hash table @var{self}.
@end defmethod

@deffn Function frem (@w{(x @sc{float})} @w{(y @sc{float})}) : @sc{float} 
Return the floating point remainder from dividing @var{x} by @var{y}.  The
sign of the result is always the same as the sign of @var{x}.  This has slightly
different behavior than the @code{mod} function, and has less overhead in C++ and
Java, which don't have direct support for a true modulus function.
@end deffn

@deffn Function generate-random-uuid () : @sc{string} 
Generates a random UUID (Type 4), according to the guidelines
of IETF RFC 4122 (see http://www.ietf.org/rfc/rfc4122.txt )

Take 16 random bytes (octets), put them all behind each other, for the description
the numbering starts with byte 1 (most significant, first) to byte 16 
   (least significant, last). Then put in the version and variant.
To put in the version, take the 7th byte and perform an and operation using 0x0f,
   followed by an or operation with 0x40. 
To put in the variant, take the 9th byte and perform an and operation using 0x3f,
   followed by an or operation with 0x80.
To make the string representation, take the hexadecimal presentation of bytes 1-4
   (without 0x in front of it) let them follow by a -, then take bytes 5 and 6, - 
bytes 7 and 8, - bytes 9 and 10, - then followed by bytes 11-16.
@end deffn

@deffn Function generate-uuid (@w{(uuid-type @sc{keyword})}) : @sc{string} 
Generates a UUID of the specified type.  Legal types are
a subset of the IETF RFC 4122 (see http://www.ietf.org/rfc/rfc4122.txt )
UUID types.  Currently supported are:
    :TYPE-4  :RANDOM       A type-4 (random) UUID.  These are synonyms.
@end deffn

@defmethod @sc{calendar-date} get-calendar-date (date @w{(timezone @sc{float})}) : @sc{integer} @sc{integer} @sc{integer} @sc{keyword} 
Returns multiple values of year, month, day and day of week for @var{date}
in @var{timezone}.  @var{timezone} is the number of hours added to UTC to get local time.  It
is in the range -12.0 to +14.0 where UTC is zone 0.0
@end defmethod

@deffn Function get-global-value (@w{(self @sc{surrogate})}) : @sc{object} 
Return the (possibly-wrapped) value of the global
variable for the surrogate @var{self}.
@end deffn

@deffn Function get-local-standard-time-zone () : @sc{float} 
Returns the standard time zone offset from UTC as a float,
without considering the effects of daylight savings time.
@end deffn

@deffn Function get-local-time-zone-for-date (@w{(year @sc{integer})} @w{(month @sc{integer})} @w{(day @sc{integer})} @w{(hour @sc{integer})} @w{(minute @sc{integer})} @w{(second @sc{integer})}) : @sc{float} 
Returns the time zone offset from UTC (as a float)
that is applicable to the given date.  Assumes that the date is one
that is valid for the underlying programming language.  If not, then
returns 0.0
@end deffn

@deffn Function get-quoted-tree (@w{(tree-name @sc{string})} @w{(modulename @sc{string})}) : @sc{cons} 
Return the quoted tree with name @var{tree-name}.
@end deffn

@deffn Function get-slot (@w{(self @sc{standard-object})} @w{(slot-name @sc{symbol})}) : @sc{slot} 
Return the slot named @var{slot-name} on the class
representing the type of @var{self}.
@end deffn

@defmethod @sc{surrogate} get-stella-class (class-name @w{(error? @sc{boolean})}) : @sc{class} 
Return a class with name @var{class-name}.  If none exists, break
if @var{error?}, else return @code{null}.
@end defmethod

@defmethod @sc{symbol} get-stella-class (class-name @w{(error? @sc{boolean})}) : @sc{class} 
Return a class with name @var{class-name}.  If non exists, break
if @var{error?}, else return @code{null}.
@end defmethod

@defmethod @sc{string} get-stella-class (class-name @w{(error? @sc{boolean})}) : @sc{class} 
Return a class with name @var{class-name}.  If none exists, break
if @var{error?}, else return @code{null}.
@end defmethod

@defmethod @sc{calendar-date} get-time (date @w{(timezone @sc{float})}) : @sc{integer} @sc{integer} @sc{integer} @sc{integer} 
Returns multiple values of hours, minutes, seconds, milliseconds for
the calendar date @var{date} in @var{timezone}.  @var{timezone} is the number of hours added to UTC
to get local time.  It is in the range -12.0 to +14.0 where UTC is zone 0.0
@end defmethod

@deffn Function global-variable-type-spec (@w{(global @sc{global-variable})}) : @sc{type-spec} 
Return the type spec for the global variable @var{global}.
@end deffn

@deffn Function hash-string (@w{(string @sc{string})} @w{(seedCode @sc{integer})}) : @sc{integer} 
Generate a hash-code for @var{string} and return it.
Two strings that are equal but not eq will generate the same code.
The hash-code is based on @var{seedCode} which usually will be 0.  However,
@var{seedCode} can also be used to supply the result of a previous hash
operation to achieve hashing on sequences of strings without actually
having to concatenate them.
@end deffn

@deffn Function help-advance-past-whitespace (@w{(source @sc{string})} @w{(start @sc{integer})} @w{(end @sc{integer})}) : @sc{integer} 
Helper for @code{advance-past-whitespace} that requires @var{end} to be properly set.
@end deffn

@deffn Function help-find-matching-prefix-length (@w{(string1 @sc{string})} @w{(start1 @sc{integer})} @w{(end1 @sc{integer})} @w{(string2 @sc{string})} @w{(start2 @sc{integer})} @w{(end2 @sc{integer})}) : @sc{integer} 
Helping function for @code{find-matching-prefix} that requires @var{end1} and @var{end2}
to be properly set up.
@end deffn

@deffn Function help-get-stella-module (@w{(pathName @sc{string})} @w{(error? @sc{boolean})}) : @sc{module} 
Return the module located at @var{pathName}, or @code{null}
if no such module exists.  The search looks at ancestors and top-most
 (cardinal) modules.  If @var{error?} is @code{true}, throw an exception if no
 module is found.
@end deffn

@defmethod @sc{class} help-print-outline (top @w{(stream @sc{output-stream})} @w{(current-depth @sc{integer})} @w{(depth @sc{integer})} @w{(named? @sc{boolean})}) : 
Helper method for @code{print-outline}
@end defmethod

@defmethod @sc{module} help-print-outline (top @w{(stream @sc{output-stream})} @w{(current-depth @sc{integer})} @w{(depth @sc{integer})} @w{(named? @sc{boolean})}) : 
Helper method for @code{print-outline}
@end defmethod

@defmethod @sc{object} help-print-outline (top @w{(stream @sc{output-stream})} @w{(current-depth @sc{integer})} @w{(depth @sc{integer})} @w{(named? @sc{boolean})}) : 
Helper method for @code{print-outline}
@end defmethod

@defmethod @sc{slot} help-print-outline (top @w{(stream @sc{output-stream})} @w{(current-depth @sc{integer})} @w{(depth @sc{integer})} @w{(named? @sc{boolean})}) : 
Helper method for @code{print-outline}
@end defmethod

@defmethod @sc{context} help-print-outline (top @w{(stream @sc{output-stream})} @w{(current-depth @sc{integer})} @w{(depth @sc{integer})} @w{(named? @sc{boolean})}) : 
Helper method for @code{print-outline}
@end defmethod

@defmethod @sc{object} home-module (self) : @sc{module} 
Return the home module of @var{self}.
@end defmethod

@deffn Macro if-output-language (@w{(language @sc{keyword})} @w{(thenForm @sc{object})} @w{(elseForm @sc{object})}) : @sc{object} 
Expand to @var{thenForm} if the current translator output
language equals @var{language}.  Otherwise, expand to @var{elseForm}.  This can
be used to conditionally translate Stella code.
@end deffn

@deffn Macro if-stella-feature (@w{(feature @sc{keyword})} @w{(thenForm @sc{object})} @w{(elseForm @sc{object})}) : @sc{object} 
Expand to @var{thenForm} if @var{feature} is a currently enabled
STELLA environment feature.  Otherwise, expand to @var{elseForm}.  This can
be used to conditionally translate Stella code.
@end deffn

@deffn Macro ignore (@w{&body (variables @sc{cons})}) : @sc{object} 
Ignore unused @var{variables} with NoOp @code{setq} statements.
@end deffn

@deffn Function incrementally-translate (@w{(tree @sc{object})}) : @sc{object} 
Translate a single Stella expression @var{tree} and return
the result.  For C++ and Java print the translation to standard output and
return NIL instead.
@end deffn

@deffn Function indent-outline (@w{(current-depth @sc{integer})} @w{(stream @sc{output-stream})}) : 
Helper function that indents outline printings for level
@var{current-depth} on @var{stream} using the value of the global
variable @code{*OUTLINE-INDENT-STRING*}
@end deffn

@deffn Macro inform (@w{&body (body @sc{cons})}) : @sc{object} 
Print informative message, placing non-string arguments in quotes,
and terminating with a newline.
@end deffn

@defmethod @sc{class} initial-value (self) : @sc{object} 
Return an initial value for the class @var{self}.
@end defmethod

@defmethod @sc{storage-slot} initial-value (self) : @sc{object} 
Return an initial value for @var{self}, or @code{null}.  The
initial value can be defined by the slot itself, inherited from an
equivalent slot, or inherit from the :initial-value option for the 
class representing the type of @var{self}.
@end defmethod

@defmethod @sc{stella-hash-table} initialize-hash-table (self) : 
Initialize the STELLA hash table @var{self}.  This is a
no-op and primarily exists to shadow the standard initializer inherited
from ABSTRACT-HASH-TABLE.  STELLA hash tables are initialized at the
first insertion operation.
@end defmethod

@defmethod @sc{storage-slot} initially (self) : @sc{object} 
Defines the value of a slot before it has been assigned
a value.
@end defmethod

@deffn Function integer-to-hex-string (@w{(i @sc{integer})}) : @sc{string} 
Convert @var{i} to a string representation in hexadecimal notation and return the result.
@end deffn

@deffn Function integer-to-string-in-base (@w{(i @sc{integer})} @w{(base @sc{integer})}) : @sc{string} 
Convert @var{i} to a string representation in @var{base} and return the
result.  @var{base} must be positive and not more than 36.

Note that in the C++ version, only 8, 10 and 16 will work as @var{base} arguments,
since that is all the underlying implementation supports.  Other argument
values will be treated as @code{10}.
@end deffn

@deffn Function integer-valued? (@w{(x @sc{float})}) : @sc{boolean} 
Returns @code{true} if @var{x} is the floating point representation of an integer.
@end deffn

@deffn Function intern-stella-name (@w{(name @sc{string})}) : @sc{generalized-symbol} 
Parse @var{name} which is assumed to be the printed
representation of a STELLA symbol, surrogate or keyword, intern
it into the current or specified module and return the result.
This is identical to calling @code{unstringify} on @var{name} but 10-15
times faster.
@end deffn

@deffn Function interpret-command-line-arguments (@w{(count @sc{integer})} @w{(arguments @sc{(array () of string)})}) : 
Interpret any STELLA-relevant command line @var{arguments}.
@end deffn

@deffn Function isa? (@w{(object @sc{object})} @w{(type @sc{type})}) : @sc{boolean} 
Return @code{true} iff @var{object} is an instance of the class named @var{type}.
@end deffn

@deffn Function java-translate-system (@w{(systemName @sc{string})}) : 
Translate the system @var{systemName} to Java.
@end deffn

@deffn N-Command jptrans (@w{(statement @sc{object})}) : 
Translate @var{statement} to C++ and print the result.
@end deffn

@deffn Function keyword-name? (@w{(name @sc{string})}) : @sc{boolean} 
Return TRUE if name is prefixed by @code{:}.
@end deffn

@deffn Function kvlist-to-plist (@w{(self @sc{key-value-list})}) : @sc{(property-list of (like (any-key self)) (like (any-value self)))} 
Convert @var{self} into a property list with identical and identically
ordered keys and values.
@end deffn

@defmethod @sc{cons-iterator} length (self) : @sc{integer} 
Iterate over @var{self}, and count how many items there are.
@end defmethod

@deffn Function lispify (@w{(thing @sc{unknown})}) : @sc{lisp-code} 
Convert a Stella @var{thing} as much as possible into a
Common-Lisp analogue.  The currently supported @var{thing} types are CONS, LIST,
KEY-VALUE-LIST, ITERATOR, SYMBOL, KEYWORD, and all wrapped and unwrapped
literal types.  BOOLEANs are translated into Lisp's CL:T and CL:NIL logic.
Unsupported types are left unchanged.
@end deffn

@deffn Function lispify-boolean (@w{(thing @sc{unknown})}) : @sc{lisp-code} 
Lispify @var{thing} which is assumed to be a (possibly wrapped) 
Stella boolean.
@end deffn

@deffn Command list-modules (@w{(kb-only? @sc{boolean})}) : @sc{(cons of module)} 
Returns a cons of all modules defined in PowerLoom.  If @var{kb-only?}
is @code{true}, then any modules which are code only or just namespaces are not returned.
@end deffn

@defmethod @sc{cons} listify (self) : @sc{(list of (like (any-value self)))} 
Return a list of elements in @var{self}.
@end defmethod

@defmethod @sc{list} listify (self) : @sc{(list of (like (any-value self)))} 
Return @var{self}.
@end defmethod

@defmethod @sc{key-value-list} listify (self) : @sc{(list of (like (any-value self)))} 
Return a list of key-value pairs in @var{self}.
@end defmethod

@defmethod @sc{vector} listify (self) : @sc{(list of (like (any-value self)))} 
Return a list of elements in @var{self}.
@end defmethod

@defmethod @sc{iterator} listify (self) : @sc{(list of (like (any-value self)))} 
Return a list of elements generated by @var{self}.
@end defmethod

@deffn Function load-configuration-file (@w{(file @sc{file-name})}) : @sc{configuration-table} 
Read a configuration @var{file} and return its content as a configuration table.
Also enter each property read into the global system configuration table.
Assumes Java-style property file syntax.  Each property name is represented
as a wrapped string and each value as a wrapped string/integer/float or boolean.
@end deffn

@deffn Command load-file (@w{(file @sc{string})}) : 
Read STELLA commands from @var{file} and evaluate them.
The file should begin with an @code{in-module} declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
@code{evaluate} to each of them.
@end deffn

@deffn Function load-system (@w{(systemName @sc{string})} @w{(language @sc{keyword})} @w{&rest (options @sc{object})}) : @sc{boolean} 
Natively @var{language}-compile out-of-date translated files of system
@var{systemName} and then load them into the running system (this is only
supported/possible for Lisp at the moment).  Return true if at least one
file was compiled. The following keyword/value @var{options} are recognized:

@code{:force-recompilation?} (default false): if true, files will be compiled
whether or not their compilations are up-to-date.

@code{:startup?} (default true): if true, the system startup function will
be called once all files have been loaded.
@end deffn

@deffn Function log-level<= (@w{(level @sc{object})} @w{(module @sc{string})}) : @sc{boolean} 
Return TRUE if @var{level} is lower than or equal to the current
log level of @var{module}.  Return FALSE if any of them are undefined.
@end deffn

@deffn Function log-message (@w{(module @sc{string})} @w{(logLevel @sc{object})} @w{(message @sc{cons})}) : 
Log all elements of @var{message} to @var{module}s log stream if
@var{logLevel} is the same or lower than the @var{module}s log level.  Interprets @code{EOL}
or :EOL to print a line terminator.
@end deffn

@deffn Function logmsg (@w{(module @sc{string})} @w{(logLevel @sc{object})} @w{&rest (message @sc{object})}) : 
Log all elements of @var{message} to @var{module}s log stream if
@var{logLevel} is the same or lower than the @var{module}s log level.  Interprets @code{EOL}
or :EOL to print a line terminator.
@end deffn

@defmethod @sc{symbol} lookup-class (name) : @sc{class} 
Return a class with name @var{name}.  Scan all
visible surrogates looking for one that has a class defined for it.
@end defmethod

@defmethod @sc{string} lookup-class (name) : @sc{class} 
Return a class with name @var{name}.  Scan all
visible surrogates looking for one that has a class defined for it.
@end defmethod

@deffn Function lookup-command (@w{(name @sc{symbol})}) : @sc{method-slot} 
If @var{name} names an evaluable command return its associated
command object;  otherwise, return @code{null}.  Currently, commands are not
polymorphic, i.e., they can only be implemented by functions.
@end deffn

@deffn Function lookup-configuration-property (@w{(property @sc{string})} @w{(defaultValue @sc{wrapper})} @w{(configuration @sc{configuration-table})}) : @sc{object} 
Lookup @var{property} in @var{configuration} and return its value.
Use the global system configuration table if @var{configuration} is NULL.  Return
@var{defaultValue} if @var{property} is not defined.
@end deffn

@deffn Function lookup-configuration-property-values (@w{(property @sc{string})} @w{(defaultValue @sc{object})} @w{(configuration @sc{configuration-table})}) : @sc{cons} 
Lookup @var{property} in @var{configuration}, assume it is a multi-valued
property and return its value(s) as a list.  Use the global system configuration table
if @var{configuration} is NULL.  Return @var{defaultValue} if @var{property} is not defined or
NIL is no default value is specified.
@end deffn

@deffn Function lookup-demon (@w{(name @sc{string})}) : @sc{demon} 
Return the demon named @var{name}.
@end deffn

@deffn Function lookup-function (@w{(functionSymbol @sc{symbol})}) : @sc{function} 
Return the function defined for @var{functionSymbol}, if it exists.
@end deffn

@deffn Function lookup-function-by-name (@w{(name @sc{string})}) : @sc{function} 
Return a function with name @var{name} visible from the current module.
Scan all visible symbols looking for one that has a function defined for it.
@end deffn

@defmethod @sc{surrogate} lookup-global-variable (self) : @sc{global-variable} 
Return a global variable with name @var{self}.
@end defmethod

@defmethod @sc{generalized-symbol} lookup-global-variable (self) : @sc{global-variable} 
Return a global variable with name @var{self}.
@end defmethod

@defmethod @sc{string} lookup-global-variable (self) : @sc{global-variable} 
Return a global variable with name @var{self}.
@end defmethod

@deffn Function lookup-local-slot (@w{(class @sc{class})} @w{(slot-name @sc{symbol})}) : @sc{slot} 
Lookup a local slot with @var{slot-name} on @var{class}.
@end deffn

@deffn Function lookup-logging-parameter (@w{(module @sc{string})} @w{(parameter @sc{keyword})} @w{(default @sc{object})}) : @sc{object} 
Lookup logging @var{parameter} for @var{module}.  Use @var{default} if no
value is defined.
@end deffn

@deffn Function lookup-macro (@w{(name @sc{symbol})}) : @sc{method-slot} 
If @var{name} has a macro definition, return the method object
holding its expander function.
@end deffn

@deffn Function lookup-slot (@w{(class @sc{class})} @w{(slot-name @sc{symbol})}) : @sc{slot} 
Return a slot owned by the class @var{class} with name @var{slot-name}.
Multiply inherited slots are disambiguated by a left-to-right class
precedence order for classes with multiple parents (similar to CLOS).
@end deffn

@defmethod @sc{property-list} lookup-with-default (self @w{(key @sc{(like (any-key self))})} @w{(default @sc{(like (any-value self))})}) : @sc{(like (any-value self))} 
Lookup @var{key} in @var{self} and return the result.
Return @var{default} if no value was found.
@end defmethod

@defmethod @sc{key-value-list} lookup-with-default (self @w{(key @sc{(like (any-key self))})} @w{(default @sc{(like (any-value self))})}) : @sc{(like (any-value self))} 
Lookup @var{key} in @var{self} and return the result.
Return @var{default} if no value was found.
@end defmethod

@deffn N-Command lptrans (@w{(statement @sc{object})}) : 
Translate @var{statement} to Common-Lisp and print the result.
@end deffn

@deffn Function make-matching-name (@w{(original @sc{string})} @w{&rest (options @sc{object})}) : @sc{string} 
Keyword options:
  :break-on-cap    one of  :YES :NO :CLEVER         default is :CLEVER
  :break-on-number one of  :YES :NO :CLEVER         default is :CLEVER
  :break-on-separators string                       default is "-_ "
  :remove-prefix   string
  :remove-suffix   string
  
  :case            one of  :UPCASE :TitleCase :titleCaseX :downcase :Capitalize :preserve
                                                     default is :TitleCase
  :separator       string                            default is ""
  :add-prefix      string
  :add-suffix      string

  MAKE-MATCHING-NAME returns a matching name (a string) for the input name (a string).
A matching name is constructed by breaking the input into @code{words} and then applying
appropriate transforms.  The arguments are used as follows:
  @var{original}         is the input name.  It is a string.
  :break-on-cap    is a keyword controlling whether changes in capitalization is used
                   to indicate word boundaries.  If :YES, then all capitalization
                   changes delineate words.  If :CLEVER, then unbroken runs of
                   capitalized letters are treated as acronyms and remain grouped.
                   If :NO or NULL, there is no breaking of words based on capitalization.
  :break-on-number is a flag controlling whether encountering a number indicates
                   a word boundary.  If :YES, then each run of numbers is treated as
		   a word separate from surrounding words.  If :CLEVER, then an 
		   attempt is made to recognize ordinal numbers (ie, 101st) and
		   treat them as separate words.  If :NO or NULL, there is no breaking
                   of words when numbers are encountered.
  :break-on-separators   A string of characters which constitute word delimiters in
                         the input word.  This is used to determine how to break
                   the name into individual words.  Defaults are space, @code{-} and @code{_}.
  :remove-prefix   Specifies a prefix or suffix that is stripped from the input
  :remove-suffix   name before any other processing.  This allows the removal of
                   any naming convention dictated prefixes or suffixes.
  :add-prefix      Specifies a prefix or suffix that is added to the output name
  :add-suffix      after all other processing.  This allows the addition of any
                   naming convention dictated prefixes or suffixes.
  :case            The case of the resulting name.  This is applied to the name 
                   before adding prefixes or suffixes.  The two title case options 
                   differ only in how the first word of the name is treated.
                   :TitleCase capitalizes the first letter of the first word and
                       also the first letter of all other words.
                   :TitleCaseX does not capitalizes the first letter of the first
		       word but capitalizes the first letter of all subsequent words.
		   :preserve results in no change in case.
  :separator       This is a string specifying the word separator to use in the
                   returned name.  An empty string (the default) means that the
                   resulting words are concatenated without any separation.  This
                   normally only makes sense when using one of the title case values
                   for the case keyword.
@end deffn

@deffn Function make-matching-name-full (@w{(originalname @sc{string})} @w{(breakoncap @sc{keyword})} @w{(breakonnumber @sc{keyword})} @w{(breakonseparators @sc{string})} @w{(removeprefix @sc{string})} @w{(removesuffix @sc{string})} @w{(addprefix @sc{string})} @w{(addsuffix @sc{string})} @w{(outputcase @sc{keyword})} @w{(outputseparator @sc{string})}) : @sc{string} 
Non-keyword version of @code{make-matching-name}, which will probably be
easier to use when called from non-Lisp languages.
@end deffn

@deffn Command make-system (@w{(systemName @sc{string})} @w{(language @sc{keyword})} @w{&rest (options @sc{object})}) : @sc{boolean} 
Translate all out-of-date files of system @var{systemName}
into @var{language} and then compile and load them (the latter is only possible
for Lisp right now).  The following keyword/value @var{options} are recognized:

@code{:two-pass?}: if true, all files will be scanned twice, once to
load the signatures of objects defined in them, and once to actually
translate the definitions.  Otherwise, the translator will make one pass in
the case that the system is already loaded (and is being remade), and two
passes otherwise.

@code{:development-settings?} (default false): if true translation will favor
safe, readable and debuggable code over efficiency (according to the value
of @code{:development-settings} on the system definition).  If false, efficiency
will be favored instead (according to the value of @code{:production-settings}
on the system definition).

@code{:production-settings?} (default true): inverse to @code{:development-settings?}.

@code{:force-translation?} (default false): if true, files will be translated
whether or not their translations are up-to-date.

@code{:force-recompilation?} (default false): if true, translated files will be
recompiled whether or not their compilations are up-to-date (only supported
in Lisp right now).

@code{:load-system?} (default true): if true, compiled files will be loaded into
the current STELLA image (only supported in Lisp right now).

@code{:startup?} (default true): if true, the system startup function will
be called once all files have been loaded.
@end deffn

@defmethod @sc{cons-iterator} member? (self @w{(value @sc{object})}) : @sc{boolean} 
Iterate over values of @var{self} and return TRUE
if one of them is @code{eql?} to 'value.
@end defmethod

@defmethod @sc{collection} member? (self @w{(object @sc{object})}) : @sc{boolean} 
Return true iff @var{object} is a member of the collection @var{self}.
@end defmethod

@defmethod @sc{sequence} member? (self @w{(value @sc{object})}) : @sc{boolean} 
Return TRUE if @var{value} is a member of the sequence @var{self}.
@end defmethod

@deffn Macro memoize (@w{(inputArgs @sc{cons})} @w{&body (body @sc{cons})}) : @sc{object} 
Compute the value of an expression and memoize it relative to
   the values of @var{inputArgs}.
@var{inputArgs} should characterize the complete set of values upon which
   the computation of the result depended.
Calls to @code{memoize} should be of the form

      (memoize (<arg>+) @{:<option> <value>@}* <expression>)

   and have the status of an expression.
   The following options are supported:

      :timestamps   A single or list of keywords specifying the names of
                    timestamps which when bumped should invalidate all
                    entries currently memoized in this table.
      :name         Names the memoization table so it can be shared by other
                    memoization sites.  By default, a gensymed name is used.
                    CAUTION: IT IS ASSUMED THAT ALL ENTRIES IN A MEMOZATION
                    TABLE DEPEND ON THE SAME NUMBER OF ARGUMENTS!!
      :max-values   The maximum number of values to be memoized.  Only the
                    @code{:max-values} most recently used values will be kept
                    in the memoization table, older values will be discarded
                    and recomputed if needed.  Without a @code{:max-values}
                    specification, the memoization table will grow
                    indefinitely.

PERFORMANCE NOTES: For most efficient lookup, input arguments that vary the most
should be listed first.  Also, arguments of type STANDARD-OBJECT (and all its
subtypes) can be memoized more efficiently than arguments of type OBJECT or
wrapped literals (with the exception of BOOLEANs).
@end deffn

@deffn Function merge-file-names (@w{(baseFile @sc{file-name})} @w{(defaults @sc{file-name})}) : @sc{file-name} 
Parse @var{baseFile}, supply any missing components from
@var{defaults} if supplied and return the result.
@end deffn

@defmethod @sc{decoded-date-time} merge-null-fields (self @w{(default @sc{decoded-date-time})}) : 
Replace any null valued fields in @var{self} with values from @var{default}.
The day of the week will be set consistently, if possible.
@end defmethod

@defmethod @sc{decoded-date-time} merge-superior-null-fields (self @w{(default @sc{decoded-date-time})}) : 
Replace only null valued fields in @var{self} that represent larger
time units than the smallest non-null in @var{self} with values from @var{default}.
The day of the week will be set consistently, if possible.
Example: if @var{self} just has the month being non-null, then only the year
will be filled in from @var{default}.  If the day and minute were non-null,
then hour, month and year will be filled.

This can be useful when one doesn't want to extend the precision
of the answer.
@end defmethod

@defmethod @sc{class} multiple-parents? (class) : @sc{boolean} 
Return @code{true} if @var{class} has more than one direct superclass.
@end defmethod

@defmethod @sc{module} multiple-parents? (module) : @sc{boolean} 
Return TRUE if @var{module} has more than one parent.
@end defmethod

@defmethod @sc{world} multiple-parents? (world) : @sc{boolean} 
Return FALSE always, since worlds never have more than one parent.
@end defmethod

@deffn Function name-to-string (@w{(name @sc{object})}) : @sc{string} 
Return the string represented by @var{name}.  Return @code{null}
if @var{name} is undefined or does not represent a string.
@end deffn

@deffn Function native-read-line (@w{(inputStream @sc{input-stream})}) : @sc{string} 
Read one line from @var{inputStream} using the native language
readline algorithm and return the result.  On EOF return @code{null}
@end deffn

@defmethod @sc{memoizable-iterator} next? (self) : @sc{boolean} 
Generate the next value of the memoized iterator @var{self} (or
one of its clones) by either using one of the values generated so far or by
generating and saving the next value of the @code{base-iterator}.
@end defmethod

@defmethod @sc{collection} no-duplicates? (self) : @sc{boolean} 
Return @code{true} if the collection @var{self} forbids duplicate values.
@end defmethod

@defmethod @sc{string-wrapper} non-empty? (x) : @sc{boolean} 
Return true if @var{x} is not the wrapped empty string ""
@end defmethod

@deffn Function non-matching-position (@w{(source @sc{string})} @w{(start @sc{integer})} @w{(match @sc{string})}) : @sc{integer} 
Returns the index into @var{source}, starting from @var{start}, of the first
character that is not included in @var{match}.
@end deffn

@deffn Function non-matching-position-helper (@w{(source @sc{string})} @w{(start @sc{integer})} @w{(end @sc{integer})} @w{(match @sc{string})}) : @sc{integer} 
Helper for @code{non-matching-position} that requires @var{end} to not be @code{null}.
@end deffn

@defmethod @sc{native-vector} nth (self @w{(position @sc{integer})}) : @sc{(like (any-value self))} 
Return the element in @var{self} at @var{position}.
@end defmethod

@defmethod @sc{array} null? (x) : @sc{boolean} 
Return true if @var{x} is undefined (handled specially by all translators).
@end defmethod

@deffn Macro only-if (@w{(test @sc{object})} @w{(expression @sc{object})}) : @sc{object} 
If @var{test} is TRUE, return the result of evaluating 
@var{expression}.
@end deffn

@deffn Function open-network-stream (@w{(host @sc{string})} @w{(port @sc{integer})}) : @sc{input-stream} @sc{output-stream} 
Open a TCP/IP network stream to @var{host} at @var{port} and return the result
as an input/output stream pair.
@end deffn

@defmethod @sc{collection} ordered? (self) : @sc{boolean} 
Return @code{true} if the collection @var{self} is ordered.
@end defmethod

@deffn Function outline-depth-exceeded? (@w{(current-depth @sc{integer})} @w{(depth-limit @sc{integer})}) : @sc{boolean} 
Helper function that returns @code{true} if @var{current-depth} exceeds @var{depth-limit}.
This functions uses the convention that a @code{null} or negative value of
@var{depth-limit} means the depth is unlimited.  In those cases it always
returns false.
@end deffn

@defmethod @sc{class} parameters (self) : @sc{(list of symbol)} 
Returns the list of parameters names of @var{self}.
@end defmethod

@deffn Function parse-date-time-in-time-zone (@w{(date-time-string @sc{string})} @w{(time-zone @sc{float})} @w{(start @sc{integer})} @w{(end @sc{integer})} @w{(error-on-mismatch? @sc{boolean})}) : @sc{decoded-date-time} 
Tries very hard to make sense out of the argument @var{date-time-string} and
returns a time structure if successful.  If not, it returns @code{null}.
If @var{error-on-mismatch?} is true, parse-date-time will signal an error instead of
returning @code{null}.  
Default values are 00:00:00 in the given timezone on the current date.  If the
given @var{time-zone} value is @code{null}, then the local time zone for the given date
and time will be used as determined by the operating system.
@end deffn

@deffn Function parse-date-time-relative-to-base (@w{(date-time-string @sc{string})} @w{(base-date-time @sc{decoded-date-time})} @w{(start @sc{integer})} @w{(end @sc{integer})} @w{(error-on-mismatch? @sc{boolean})} @w{(merge-null-fields? @sc{boolean})}) : @sc{decoded-date-time} 
Tries very hard to make sense out of the argument @var{date-time-string} and
returns a time structure if successful.  If not, it returns @code{null}.
If @var{error-on-mismatch?} is true, parse-date-time will signal an error instead of
returning @code{null}.
Default values are passed in via @var{base-date-time}.  If the timezone field that
is passed in is NULL, then the local time zone for the parsed date/time will
be used.
If @var{merge-null-fields?} is @code{true}, then default values from @code{base-time-date}
will be merged into missing components.  If @code{false}, then they won't be merged
in for null components but can still be used as a basis for interpreatation of
relative time strings like "now" or "yesterday"
@end deffn

@deffn Function parse-stella-name (@w{(name @sc{string})} @w{(enableCaseConversion? @sc{boolean})}) : @sc{string} @sc{string} @sc{keyword} 
Parse the printed representation @var{name} of a STELLA symbol, surrogate or
keyword and return its symbol name, module name and type (which is either
:SYMBOL, :SURROGATE or :KEYWORD).  @var{name} can be qualified and must use the
exact same syntax and escape characters that would be used if it were to be
read by @code{read-s-expression-from-string} (or @code{unstringify}).  If
@var{enableCaseConversion?} is TRUE, the returned symbol name will be upcased if
the current module is case-insensitive; otherwise, it will be returned as is.
Raises a read exception if @var{name} does not represent a symbol.
This function is available primarily for efficiency, since it is about
10-15 times faster than @code{unstringify}.
@end deffn

@deffn Function pick-hash-table-size-prime (@w{(minSize @sc{integer})}) : @sc{integer} 
Return a hash table prime of at least @var{minSize}.
@end deffn

@deffn Function plist-to-kvlist (@w{(self @sc{property-list})}) : @sc{(key-value-list of (like (any-key self)) (like (any-value self)))} 
Convert @var{self} into a key-value list with identical and identically
ordered keys and values.
@end deffn

@defmethod @sc{object} primary-type (self) : @sc{type} 
Returns the primary type of @var{self}.
Gets defined automatically for every non-abstract subclass of OBJECT.
@end defmethod

@defmethod @sc{relation} primitive? (self) : @sc{boolean} 
Return @code{true} if @var{self} is not a defined relation.
@end defmethod

@deffn Macro print (@w{&body (body @sc{cons})}) : @sc{object} 
Print arguments to the standard output stream.
@end deffn

@deffn Function print-exception-context (@w{(e @sc{native-exception})} @w{(stream @sc{output-stream})}) : 
Prints a system dependent information about the context of the specified
exception.  For example, in Java it prints a stack trace.  In Lisp, it is vendor dependent.
@end deffn

@deffn Command print-outline (@w{(thing @sc{object})} @w{(stream @sc{output-stream})} @w{(depth @sc{integer})} @w{(named? @sc{boolean})}) : 
Print an outline of @var{thing} and its subparts on @var{stream}.
If @var{depth} is greater than 0, only @var{depth} levels will be printed.
If @var{named?} is @code{TRUE}, then only named entities will be printed.

This function is intended to be used on things like modules, contexts,
concepts, etc. that have hierarchical structure.  If @var{thing} doesn't
have a hierarchical structure, it will just be printed.
@end deffn

@deffn Function print-recycle-lists () : 
Print the current state of all recycle lists.
@end deffn

@deffn Macro print-spaces (@w{&body (body @sc{cons})}) : @sc{object} 
(print-spaces [stream] N) prints N spaces onto stream.  If
no stream form is provided, then STANDARD-OUTPUT will be used.
@end deffn

@deffn Command print-stella-features () : 
Print the list of enabled and disabled STELLA features.
@end deffn

@deffn N-Command print-unbound-surrogates (@w{&rest (args @sc{object})}) : 
Print all unbound surrogates visible from the module named by the first
argument (a symbol or string).  Look at all modules if no module name or
@code{null} was supplied.  If the second argument is @code{true}, only consider
surrogates interned in the specified module.
@end deffn

@deffn Function print-undefined-methods (@w{(module @sc{module})} @w{(local? @sc{boolean})}) : 
Print all declared but not yet defined functions and methods
in @var{module}.  If @var{local?} is true, do not consider any parent modules of
@var{module}.  If @var{module} is NULL, look at all modules in the system.  This
is handy to pinpoint forward declarations that haven't been followed up
by actual definitions.
@end deffn

@deffn N-Command print-undefined-super-classes (@w{(class @sc{name})}) : 
Print all undefined or bad (indirect) super classes of @var{class}.
@end deffn

@deffn Function private-class-methods (@w{(class @sc{class})}) : @sc{(iterator of method-slot)} 
Iterate over all private methods attached to @var{class}.
@end deffn

@deffn Function private-class-storage-slots (@w{(class @sc{class})}) : @sc{(iterator of storage-slot)} 
Iterate over all private storage-slots attached to @var{class}.
@end deffn

@defmethod @sc{relation} private? (self) : @sc{boolean} 
Return @code{true} if @var{self} is not public.
@end defmethod

@deffn Function process-doctype (@w{(doctype-declaration @sc{cons})}) : @sc{xml-doctype} 
Takes an S-Expression representing a doctype and processes into
a DOCTYPE object.
@end deffn

@deffn N-Command ptrans (@w{(statement @sc{object})}) : 
Translate @var{statement} to Common-Lisp and print the result.
@end deffn

@deffn Function public-class-methods (@w{(class @sc{class})}) : @sc{(iterator of method-slot)} 
Iterate over all private methods attached to @var{class}.
@end deffn

@deffn Function public-class-storage-slots (@w{(class @sc{class})}) : @sc{(iterator of storage-slot)} 
Iterate over all public storage-slots attached to @var{class}.
@end deffn

@defmethod @sc{class} public-slots (self) : @sc{(iterator of slot)} 
Return an iterator over public slots of @var{self}.
@end defmethod

@defmethod @sc{object} public-slots (self) : @sc{(iterator of slot)} 
Return an iterator over public slots of @var{self}.
@end defmethod

@defmethod @sc{slot} public? (self) : @sc{boolean} 
True if @var{self} or one it its ancestors is marked public.
@end defmethod

@deffn Macro pushf (@w{(place @sc{cons})} @w{(value @sc{object})}) : @sc{object} 
Push @var{value} onto the cons list @var{place}.
@end deffn

@deffn Function qualified-stella-name? (@w{(name @sc{string})}) : @sc{boolean} 
Return TRUE if @var{name} is a symbol or surrogate qualified with a module
pathname or a module pathname ending with a @code{/}.  Assumes that @var{name}
is the printed representation of a STELLA symbol (potentially containing
escape characters).
@end deffn

@deffn Function read-line2 (@w{(stream @sc{input-stream})}) : @sc{string} @sc{keyword} 
Read one line from @var{stream} and return the result and
a keyword that indicates the terminator for that line ending:
@code{:CR} @code{:LF} @code{:CRLF} or @code{:EOF}.   This is not platform-dependent
and differs from @code{read-line} by returning a second value.  It
may hang when used on interactive streams such as terminal or
network streams with only CR line endings.  It should only be
used on file or string input streams.
@end deffn

@defmethod @sc{storage-slot} reader (self) : @sc{symbol} 
Name of a method called to read the value of the slot
@var{self}.
@end defmethod

@deffn Function remove-configuration-property (@w{(property @sc{string})} @w{(value @sc{object})} @w{(configuration @sc{configuration-table})}) : @sc{object} 
Remove @var{value} from @var{property} in @var{configuration} and return it.
Use the global system configuration table if @var{configuration} is NULL.
@end deffn

@defmethod @sc{collection} remove-duplicates (self) : @sc{(like self)} 
Return @var{self} with duplicates removed.  Preserves the
original order of the remaining members.
@end defmethod

@defmethod @sc{class} required-slots (self) : @sc{(list of symbol)} 
Returns a list of names of required slots for @var{self}.
@end defmethod

@defmethod @sc{storage-slot} required? (self) : @sc{boolean} 
True if a value must be assigned to this slot at
creation time.
@end defmethod

@deffn Command reset-stella-features () : 
Reset STELLA features to their default settings.
@end deffn

@deffn Function reverse-interval (@w{(lowerbound @sc{integer})} @w{(upperbound @sc{integer})}) : @sc{reverse-integer-interval-iterator} 
Create a reverse interval object.
@end deffn

@deffn Function run-hooks (@w{(hooklist @sc{hook-list})} @w{(argument @sc{object})}) : 
Run all hook functions in @var{hooklist}, applying
each one to @var{argument}.
@end deffn

@deffn Function running-as-lisp? () : @sc{boolean} 
Return true if the executable code is a Common Lisp application.
@end deffn

@deffn Function running-in-language () : @sc{keyword} 
Returns the keyword for the language the current implementation is running in.
@end deffn

@deffn Function running-system-information () : @sc{string} 
Returns an information string about the current running system environment.
@end deffn

@deffn Function safe-equal-hash-code (@w{(self @sc{object})}) : @sc{integer} 
Return a hash code for @var{self}.  Just like @code{equal-hash-code}
- which see, but also works for NULL.  @code{equal-hash-code} methods that expect to
handle NULL components should use this function for recursive calls.
@end deffn

@deffn Function safe-hash-code (@w{(self @sc{object})}) : @sc{integer} 
Return a hash code for @var{self}.  Just like @code{hash-code}
- which see, but also works for NULL.
@end deffn

@deffn Function safe-lookup-slot (@w{(class @sc{class})} @w{(slot-name @sc{symbol})}) : @sc{slot} 
Alias for @code{lookup-slot}.  Kept for backwards compatibility.
@end deffn

@deffn Macro safety (@w{(level @sc{integer-wrapper})} @w{(test @sc{object})} @w{&body (body @sc{cons})}) : @sc{object} 
Signal warning message, placing non-string arguments in quotes.
@end deffn

@deffn Function save-configuration-file (@w{(table @sc{configuration-table})} @w{(file @sc{file-name})} @w{(title @sc{string})}) : 
Save @var{table} as a configuration file.  Uses a Java-style property file syntax.
@end deffn

@deffn Function save-configuration-value (@w{(stream @sc{output-stream})} @w{(value @sc{object})}) : 
Save @var{value} to @var{stream} as a properly formatted configuration
value.
@end deffn

@deffn Function search-cons-tree-with-filter? (@w{(tree @sc{object})} @w{(value @sc{object})} @w{(filter @sc{cons})}) : @sc{boolean} 
Return @code{true} iff the value @var{value} is embedded within
the cons tree @var{tree}.  Uses an @code{eql?} test.  Does not descend into any
cons whose first element matches an element of @var{filter}.
@end deffn

@deffn Function search-for-object (@w{(self @sc{object})} @w{(typeref @sc{object})}) : @sc{object} 
If @var{self} is a string or a symbol, search for an object named
@var{self} of type @code{type}.  Otherwise, if @var{self} is an object, return it.
@end deffn

@deffn Function seed-random-number-generator () : 
Seeds the random number generator with the current time.
@end deffn

@deffn Function sequence (@w{(collectiontype @sc{type})} @w{&rest (values @sc{object})}) : @sc{(sequence of object)} 
Return a sequence containing @var{values}, in order.
@end deffn

@deffn Command set-call-log-break-point (@w{(count @sc{integer})}) : 
Set a call log break point to @var{count}.  Execution will be
interrupted right at the entry of the @var{count}th logged function call.
@end deffn

@deffn Function set-configuration-property (@w{(property @sc{string})} @w{(value @sc{object})} @w{(configuration @sc{configuration-table})}) : @sc{object} 
Set @var{property} in @var{configuration} to @var{value} and return it.
Use the global system configuration table if @var{configuration} is NULL.
@end deffn

@defmethod @sc{decoded-date-time} set-current-date (values-structure) : 
Sets the current date into @var{values-structure}
@end defmethod

@defmethod @sc{decoded-date-time} set-current-date-time (values-structure) : 
Sets the current date and time into @var{values-structure}
@end defmethod

@defmethod @sc{decoded-date-time} set-current-time (values-structure) : 
Sets the current time into @var{values-structure}
@end defmethod

@deffn Function set-global-value (@w{(self @sc{surrogate})} @w{(value @sc{object})}) : @sc{object} 
Set the value of the global variable for the surrogate
@var{self} to @var{value}.
@end deffn

@deffn Function set-logging-parameters (@w{(module @sc{string})} @w{&rest (params&values @sc{object})}) : 
Set logging parameters for @var{module}.  The supported parameters are:
  :LOG-LEVELS - a cons list of legal levels in ascending log level order;
                for example, (:NONE :LOW :MEDIUM :HIGH) or (0 1 2 3).
  :LEVEL      - the current log level for @var{module}
  :STREAM     - the stream to log to (defaults to STANDARD-OUTPUT)
  :PREFIX     - the prefix to use to identify the module (defaults to @var{module})
  :MAX-WIDTH  - logging output lines will be kept to approximately this width
                (defaults to 10000, minimum width of about 30 is used to
                print line header information).
@end deffn

@deffn Function set-optimization-levels (@w{(safety @sc{integer})} @w{(debug @sc{integer})} @w{(speed @sc{integer})} @w{(space @sc{integer})}) : 
Set optimization levels for the qualities @var{safety}, @var{debug},
@var{speed}, and @var{space}.
@end deffn

@deffn Command set-stella-feature (@w{&rest (features @sc{keyword})}) : 
Enable all listed STELLA @var{features}.
@end deffn

@deffn Command set-translator-output-language (@w{(new-language @sc{keyword})}) : @sc{keyword} 
Set output language to @var{new-language}.  Return previous language.
@end deffn

@deffn Macro setq? (@w{(variable @sc{symbol})} @w{(expression @sc{cons})}) : @sc{object} 
Assign @var{variable} the result of evaluating @var{expression}, 
and return TRUE if @var{expression} is not NULL else return FALSE.
@end deffn

@deffn Function shadowed-symbol? (@w{(symbol @sc{generalized-symbol})}) : @sc{boolean} 
Return @code{true} if @var{symbol} is shadowed in its home module.
@end deffn

@deffn Function shift-right (@w{(arg @sc{integer})} @w{(count @sc{integer})}) : @sc{integer} 
Shift @var{arg} to the right by @var{count} positions and
0-extend from the left if @var{arg} is positive or 1-extend if it is
negative.  This is an arithmetic shift that preserve the sign of @var{arg}
and is equivalent to dividing @var{arg} by 2** @var{count}.
@end deffn

@deffn Macro signal (@w{(type @sc{symbol})} @w{&body (body @sc{cons})}) : @sc{object} 
Signal error message, placing non-string arguments in quotes.
@end deffn

@deffn Macro signal-read-error (@w{&body (body @sc{cons})}) : @sc{object} 
Specialized version of @code{signal} that throws a READ-EXCEPTION.
@end deffn

@deffn Command start-function-call-logging (@w{(fileName @sc{string})}) : 
Start function call logging to @var{fileName}.
@end deffn

@deffn Function starts-with? (@w{(string @sc{string})} @w{(prefix @sc{string})} @w{(start @sc{integer})}) : @sc{boolean} 
Return TRUE if @var{string} starts with @var{prefix} starting from
@var{start} (which defaults to 0 if it is supplied as NULL).
@end deffn

@deffn Function stella-collection? (@w{(self @sc{object})}) : @sc{boolean} 
Return @code{true} if @var{self} is a native collection.
@end deffn

@deffn Command stella-information () : @sc{string} 
Returns information about the current Stella implementation.
Useful when reporting problems.
@end deffn

@deffn Function stella-object? (@w{(self @sc{object})}) : @sc{boolean} 
Return true if @var{self} is a member of the STELLA class @code{OBJECT}.
@end deffn

@deffn Function stella-version-string () : @sc{string} 
Return a string identifying the current version of STELLA.
@end deffn

@deffn Function stellafy (@w{(thing @sc{lisp-code})} @w{(targetType @sc{type})}) : @sc{object} 
Partial inverse to @code{lispify}.  Convert the Lisp object 
@var{thing} into a Stella analogue of type @var{targetType}.
Note: See also @code{stellify}. it is similar, but guesses @var{targetType} on its own,
and makes somewhat different translations.
@end deffn

@deffn Function stellify (@w{(self @sc{object})}) : @sc{object} 
Convert a Lisp object into a STELLA object.
@end deffn

@deffn Command stop-function-call-logging () : 
Stop function call logging and close the current log file.
@end deffn

@defmethod @sc{input-stream} stream-to-string (from) : @sc{string} 
Read all of the input from @code{stream} and return it as a string.
@end defmethod

@deffn Function string-to-calendar-date-with-default (@w{(input-date @sc{string})} @w{(default-date @sc{decoded-date-time})}) : @sc{calendar-date} 
Returns a calendar date object representing the date and time
parsed from the @var{input-date} string.  Default values for missing fields and
the interpretation of relative references come from @var{default-date}.  If the
@var{default-date} is @code{null}, the current date will be used.  If a null set of
defaults is desired, use @code{*NULL-DECODED-DATE-TIME*}.
If no valid parse is found, @code{null} is returned.
@end deffn

@deffn Function string-to-decoded-date-time (@w{(input @sc{string})}) : @sc{decoded-date-time} 
Returns a decoded date-time object representing the date
and time parsed from the @var{input} string.  If no valid parse is found,
@code{null} is returned.
@end deffn

@deffn Function string-to-surrogate (@w{(self @sc{string})}) : @sc{surrogate} 
Return a surrogate with the name @var{self} visible
in the current module.  Very tricky: The logic is designed to avoid
returning an inherited surrogate that has no value.  In that case,
a new local surrogate is created that shadows the inherited surrogate.
@end deffn

@deffn Function string-to-time-duration (@w{(duration @sc{string})}) : @sc{time-duration} 
Parses and returns an time-duration object corresponding to @var{duration}.
The syntax for time duration strings is "@{plus|minus@} N days[; M ms]" where N and M are
integer values for days and milliseconds.  If no valid parse is found, @code{null} is returned.
@end deffn

@deffn Function subclass-of? (@w{(subClass @sc{class})} @w{(superClass @sc{class})}) : @sc{boolean} 
Return @code{true} if @var{subClass} is a subclass of @var{superClass}.
@end deffn

@defmethod @sc{mutable-string} subsequence (string @w{(start @sc{integer})} @w{(end @sc{integer})}) : @sc{string} 
Return a substring of @var{string} beginning at position @var{start}
and ending up to but not including position @var{end}, counting from zero.  An
@var{end} value of NULL stands for the rest of the string.
@end defmethod

@defmethod @sc{string} substitute-characters (self @w{(new-chars @sc{string})} @w{(old-chars @sc{string})}) : @sc{string} 
Substitute all occurences of of a member of @var{old-chars} with the 
corresponding member of @var{new-chars} in the string @var{self}.  Returns a new string.
@end defmethod

@defmethod @sc{mutable-string} substitute-characters (self @w{(new-chars @sc{string})} @w{(old-chars @sc{string})}) : @sc{mutable-string} 
Substitute all occurences of of a member of @var{old-chars} with the 
corresponding member of @var{new-chars} in the string @var{self}.  IMPORTANT:  The return
value should be used instead of relying on destructive substitution, since the
substitution will not be destructive in all translated languages.
@end defmethod

@deffn Function subtype-of? (@w{(sub-type @sc{type})} @w{(super-type @sc{type})}) : @sc{boolean} 
Return @code{true} iff the class named @var{sub-type} is a subclass 
of the class named @var{super-type}.
@end deffn

@defmethod @sc{class} super-classes (self) : @sc{(iterator of class)} 
Returns an iterator that generates all super classes
of @var{self}.  Non-reflexive.
@end defmethod

@deffn Function surrogate-name? (@w{(name @sc{string})}) : @sc{boolean} 
Return TRUE if name is prefixed by @code{SURROGATE-PREFIX-CHARACTER}.
@end deffn

@defmethod @sc{surrogate} surrogatify (self) : @sc{surrogate} 
Converts @var{self} into a surrogate.
@end defmethod

@defmethod @sc{symbol} surrogatify (self) : @sc{surrogate} 
Converts @var{self} into a surrogate (same semantics
as @code{symbol-to-surrogate} which see).
@end defmethod

@defmethod @sc{string} surrogatify (self) : @sc{surrogate} 
Converts @var{self} into a surrogate.
@end defmethod

@defmethod @sc{object} sweep (self) : 
Default method.  Sweep up all @var{self}-type objects.
@end defmethod

@deffn Function symbol-to-surrogate (@w{(self @sc{symbol})}) : @sc{surrogate} 
Return a surrogate with the same name as @var{self}.
Very tricky: The logic is designed to avoid returning an inherited surrogate
that has no value.  In that case, a new local surrogate is created that shadows
the inherited surrogate.  Unlike @code{string-to-surrogate}, the search starts first
from the home context of @var{self}, and if that fails, then it restarts in
*module*.
@end deffn

@deffn Function symbol-to-type (@w{(self @sc{symbol})}) : @sc{surrogate} 
Convert @var{self} into a surrogate with the same name and module.
@end deffn

@defmethod @sc{storage-slot} system-default-value (self) : @sc{object} 
Return a default value expression, or if @var{self}
has dynamic storage, an initial value expression.
@end defmethod

@defmethod @sc{slot} system-default-value (self) : @sc{object} 
Return a default value expression, or if @var{self}
has dynamic storage, an initial value expression.
@end defmethod

@deffn Function system-loaded? (@w{(name @sc{string})}) : @sc{boolean} 
Return @code{true} if system @var{name} has been loaded.
@end deffn

@deffn Function terminate-program () : 
Terminate and exit the program with normal exit code.
@end deffn

@defmethod @sc{time-duration} time-duration-to-string (date) : @sc{string} 
Returns a string representation of @var{date}
@end defmethod

@deffn Function time-zone-format60 (@w{(timezone @sc{float})}) : @sc{string} 
Format @code{zone} as an hh:mm string
@end deffn

@deffn Function toggle-output-language () : @sc{keyword} 
Switch between Common Lisp and C++ as output languages.
@end deffn

@deffn Macro trace-if (@w{(keyword @sc{object})} @w{&body (body @sc{cons})}) : @sc{object} 
If @var{keyword} is a trace keyword that has been enabled with @code{add-trace}
print all the elements in @var{body} to standard output.  Otherwise, do nothing.
@var{keyword} can also be a list of keywords in which case printing is done if
one or more of them are trace enabled.
@end deffn

@deffn Function translate-system (@w{(systemName @sc{string})} @w{(outputLanguage @sc{keyword})} @w{&rest (options @sc{object})}) : @sc{boolean} 
Translate all of the STELLA source files in system @var{systemName} into
@var{outputLanguage}.  The following keyword/value @var{options} are recognized:

@code{:two-pass?} (default false): if true, all files will be scanned twice, once
to load the signatures of objects defined in them, and once to actually
translate the definitions.

@code{:force-translation?} (default false): if true, files will be translated
whether or not their translations are up-to-date.

@code{:development-settings?} (default false): if true translation will favor
safe, readable and debuggable code over efficiency (according to the value
of @code{:development-settings} on the system definition).  If false, efficiency
will be favored instead (according to the value of @code{:production-settings}
on the system definition).

@code{:production-settings?} (default true): inverse to @code{:development-settings?}.
@end deffn

@deffn Function translate-to-common-lisp? () : @sc{boolean} 
Return @code{true} if current output language is Common-Lisp.
@end deffn

@deffn Function translate-to-cpp? () : @sc{boolean} 
Return @code{true} if current output language is C++
@end deffn

@deffn Function translate-to-java? () : @sc{boolean} 
Return @code{true} if current output language is Java
@end deffn

@deffn Function truncate (@w{(n @sc{number})}) : @sc{integer} 
Truncate @var{n} toward zero and return the result.
@end deffn

@deffn Function try-to-evaluate (@w{(tree @sc{object})}) : @sc{object} 
Variant of @code{evaluate} that only evaluates @var{tree} if it
represents an evaluable expression.  If it does not, @var{tree} is returned
unmodified.  This can be used to implement commands with mixed argument
evaluation strategies.
@end deffn

@deffn Function two-argument-least-common-superclass (@w{(class1 @sc{class})} @w{(class2 @sc{class})}) : @sc{class} 
Return the most specific class that is a superclass of
both @var{class1} and @var{class2}.  If there is more than one, arbitrarily pick one.
If there is none, return @code{null}.
@end deffn

@deffn Function two-argument-least-common-supertype (@w{(type1 @sc{type-spec})} @w{(type2 @sc{type-spec})}) : @sc{type-spec} 
Return the most specific type that is a supertype of
both @var{type1} and @var{type2}.  If there is more than one, arbitrarily pick one.
If there is none, return @@VOID.  If one or both types are parametric,
also try to generalize parameter types if necessary.
@end deffn

@defmethod @sc{slot} type (self) : @sc{type} 
The type of a storage slot is its base type.
@end defmethod

@defmethod @sc{slot} type-specifier (self) : @sc{type-spec} 
If @var{self} has a complex type return its
type specifier, otherwise, return @code{type} of @var{self}.
@end defmethod

@deffn Function type-to-symbol (@w{(type @sc{type})}) : @sc{symbol} 
Convert @var{type} into a symbol with the same name and module.
@end deffn

@defmethod @sc{surrogate} type-to-wrapped-type (self) : @sc{type} 
Return the wrapped type for the type @var{self},
or @var{self} if it is not a bare literal type.
@end defmethod

@deffn Function unbound-surrogates (@w{(module @sc{module})} @w{(local? @sc{boolean})}) : @sc{(iterator of surrogate)} 
Iterate over all unbound surrogates visible from @var{module}.
Look at all modules if @var{module} is @code{null}.  If @var{local?}, only consider
surrogates interned in @var{module}.
@end deffn

@deffn Function unescape-html-string (@w{(input @sc{string})}) : @sc{string} 
Replaces HTML escape sequences such as &amp; with their
associated characters.
@end deffn

@deffn Function unescape-url-string (@w{(input @sc{string})}) : @sc{string} 
Takes a string and replaces %-format URL escape sequences with their real
character equivalent according to RFC 2396.
@end deffn

@deffn Command unset-stella-feature (@w{&rest (features @sc{keyword})}) : 
Disable all listed STELLA @var{features}.
@end deffn

@deffn Function unsigned-shift-right-by-1 (@w{(arg @sc{integer})}) : @sc{integer} 
Shift @var{arg} to the right by 1 position and 0-extend
from the left.  This does not preserve the sign of @var{arg} and shifts
the sign-bit just like a regular bit.  In Common-Lisp we can't do that
directly and need to do some extra masking.
@end deffn

@deffn Function unstringify-stella-source (@w{(source @sc{string})} @w{(module @sc{module})}) : @sc{object} 
Unstringify a STELLA @var{source} string relative to @var{module},
or @code{*MODULE*} if no module is specified.  This function allocates transient
objects as opposed to @code{unstringify-in-module} or the regular @code{unstringify}.
@end deffn

@deffn Function unwrap-boolean (@w{(wrapper @sc{boolean-wrapper})}) : @sc{boolean} 
Unwrap @var{wrapper} and return its values as a regular BOOLEAN.
Map NULL onto FALSE.
@end deffn

@deffn Function unwrap-function-code (@w{(wrapper @sc{function-code-wrapper})}) : @sc{function-code} 
Unwrap @var{wrapper} and return the result.
Return NULL if @var{wrapper} is NULL.
@end deffn

@deffn Function unwrap-method-code (@w{(wrapper @sc{method-code-wrapper})}) : @sc{method-code} 
Unwrap @var{wrapper} and return the result.
Return NULL if @var{wrapper} is NULL.
@end deffn

@defmethod @sc{abstract-dictionary-iterator} value-setter (self @w{(value @sc{(like (any-value self))})}) : @sc{(like (any-value self))} 
Abstract method needed to allow application of this
method on abstract iterator classes that do not implement it.  By having
this here all @code{next?} methods of dictionary iterators MUST use the @code{slot-value}
paradigm to set the iterator value.
@end defmethod

@deffn Macro warn (@w{&body (body @sc{cons})}) : @sc{object} 
Signal warning message, placing non-string arguments in quotes.
@end deffn

@deffn Macro with-network-stream (@w{(binding @sc{cons})} @w{&body (body @sc{cons})}) : @sc{object} 
Sets up an unwind-protected form which opens a network
socket stream to a host and port for input and output and closes it afterwards.
Separate variables as provided in the call are bound to the input and output
streams. Syntax is (WITH-NETWORK-STREAM (varIn varOut hostname port) body+)
@end deffn

@deffn Macro with-permanent-objects (@w{&body (body @sc{cons})}) : @sc{object} 
Allocate @code{permanent} (as opposed to @code{transient})
objects within the scope of this declaration.
@end deffn

@deffn Macro with-system-definition (@w{(systemnameexpression @sc{object})} @w{&body (body @sc{cons})}) : @sc{object} 
Set *currentSystemDefinition* to the system definition named @code{system}.
Set *currentSystemDefinitionSubdirectory* to match. Execute @var{body} within
that scope.
@end deffn

@deffn Macro with-transient-objects (@w{&body (body @sc{cons})}) : @sc{object} 
Allocate @code{transient} (as opposed to @code{permanent})
objects within the scope of this declaration.
CAUTION: The default assumption is the allocation of permanent objects.
The scope of @code{with-transient-objects} should be as small as possible, and
the user has to make sure that code that wasn't explicitly written to
account for transient objects will continue to work correctly.
@end deffn

@deffn Function wrap-boolean (@w{(value @sc{boolean})}) : @sc{boolean-wrapper} 
Return a literal object whose value is the BOOLEAN @var{value}.
@end deffn

@deffn Function wrap-function-code (@w{(value @sc{function-code})}) : @sc{function-code-wrapper} 
Return a literal object whose value is the FUNCTION-CODE @var{value}.
@end deffn

@deffn Function wrap-method-code (@w{(value @sc{method-code})}) : @sc{method-code-wrapper} 
Return a literal object whose value is the METHOD-CODE @var{value}.
@end deffn

@deffn Function wrapped-type-to-type (@w{(self @sc{type})}) : @sc{type} 
Return the unwrapped type for the wrapped type @var{self},
or @var{self} if it is not a wrapped type.
@end deffn

@deffn Function wrapper-value-type (@w{(self @sc{wrapper})}) : @sc{type} 
Return the type of the value stored in the wrapper @var{self}.
@end deffn

@deffn Function write-html-escaping-url-special-characters (@w{(stream @sc{native-output-stream})} @w{(input @sc{string})}) : 
Writes a string and replaces unallowed URL characters according to RFC 2396
with %-format URL escape sequences.
@end deffn

@defmethod @sc{storage-slot} writer (self) : @sc{symbol} 
Name of a method called to write the value of the slot
@var{self}.
@end defmethod

@deffn Function xml-declaration-form? (@w{(form @sc{object})}) : @sc{boolean} 
Return @code{true} if @var{form} is a CONS headed by an XML DECLARATION tag
@end deffn

@deffn Function xml-doctype-form? (@w{(form @sc{object})}) : @sc{boolean} 
Return @code{true} if @var{form} is a CONS headed by a DOCTYPE tag
@end deffn

@deffn Function xml-element-form? (@w{(form @sc{object})}) : @sc{boolean} 
Return @code{true} if @var{form} is a CONS headed by an XML ELEMENT tag
@end deffn

@deffn Function xml-processing-instruction-form? (@w{(form @sc{object})}) : @sc{boolean} 
Return @code{true} if @var{form} is a CONS headed by an XML PROCESSING INSTRUCTION tag
@end deffn

@deffn Function xml-processing-instruction? (@w{(item @sc{object})}) : @sc{boolean} 
Return @code{true} if @var{item} is an XML processing instruction object
@end deffn

@deffn Function xml-token-list-to-s-expression (@w{(tokenList @sc{tokenizer-token})} @w{(doctype @sc{xml-doctype})} @w{(doctype-definition? @sc{boolean})}) : @sc{object} 
Convert the XML @var{tokenList} (using @var{doctype} for guidance) into a
representative s-expression and return the result.    The @var{doctype} argument is
currently only used for expansion of entity references.  It can be @code{null}.  The
flag @var{doctype-definition?} should be true only when processing the DTD definition
of a DOCTYPE tag, since it enables substitution of parameter entity values.

Every XML tag is represented as a cons-list starting with the tag as its header,
followed by a possibly empty list of keyword value pairs representing tag attributes,
followed by a possibly empty list of content expressions which might themselves
be XML expressions.  For example, the expression

    <a a1=v1 a2='v2'> foo <b a3=v3/> bar </a>

becomes

   (<a> (<a1> "v1" <a2> "v2") "foo" (<b> (<a3> "v3")) "bar")

when represented as an s-expression.  The tag names are subtypes of XML-OBJECT
such as XML-ELEMENT, XML-LOCAL-ATTRIBUTE, XML-GLOBAL-ATTRIBUTE, etc.
?, ! and [ prefixed tags are encoded as their own subtypes of XML-OBJECT, namely
XML-PROCESSING-INSTRUCTION, XML-DECLARATION, XML-SPECIAL, XML-COMMENT, etc.
CDATA is an XML-SPECIAL tag with a name of CDATA.

The name is available using class accessors.
@end deffn

@deffn Function yield-define-stella-class (@w{(class @sc{class})}) : @sc{cons} 
Return a cons tree that (when evaluated) constructs
a Stella class object.
@end deffn

@deffn Function zero-pad-integer (@w{(value @sc{integer})} @w{(size @sc{integer})}) : @sc{string} 
Returns a string representing @var{value} of at least length
@var{size}, padded if necessary with 0 characters.
@end deffn



@c ===========================================================================

@node Function Index, Variable Index, Library Functions, Top
@comment  node-name,  next,  previous,  up
@unnumbered Function Index

@printindex fn

@c ---------------------------------------------------------------------------

@node Variable Index, Concept Index, Function Index, Top
@comment  node-name,  next,  previous,  up
@unnumbered Variable Index

@printindex vr

@c ---------------------------------------------------------------------------

@node Concept Index,  , Variable Index, Top
@comment  node-name,  next,  previous,  up
@unnumbered Concept Index

@printindex cp

@c ===========================================================================

@bye

Notes:
 - don't fiddle with nodes and menus before the overall structure isn't
   pretty much determined (can run makeinfo even without nodes)

 - to insert node lines with the titles taken from the sections do
   `C-x h C-u M-x texinfo-insert-node-lines'

 - to link all the nodes do `M-x texinfo-every-node-update'

 - then create/update menus with `M-x texinfo-all-menus-update'

 - node names have to be unique

 - node names should be short, keep details in their explanations -
   this makes the menus look better
