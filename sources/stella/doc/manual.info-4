This is manual.info, produced by makeinfo version 4.2 from manual.texi.

   This file documents the STELLA programming language.

   Copyright (C) 2003 University of Southern California, Information
Sciences Institute 4676 Admiralty Way Marina Del Rey, CA 90292

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.


File: manual.info,  Node: Contexts and Modules,  Next: Input and Output,  Prev: Symbols,  Up: Library Functions

Context and Modules
===================

 - Function: get-stella-context ((pathName STRING) (error? BOOLEAN)) :
          CONTEXT
     Return the context located at PATHNAME, or `null' if no such
     context exists.  If ERROR? is `true', throw an exception if no
     context is found, otherwise silently return `null'.

 - Function: clear-context ((self CONTEXT)) :
     Destroy all objects belonging to SELF or any of its subcontexts.

 - Macro: within-context ((contextForm OBJECT) &body (body CONS)) :
          OBJECT
     Execute BODY within the context resulting from CONTEXTFORM.

 - Method: destroy-context ((self CONTEXT)) :
     Make the translator happy.

 - Method: destroy-context ((self STRING)) :
     Destroy the context SELF, and recursively destroy all contexts
     that inherit SELF.

 - Method: change-context ((context CONTEXT)) : CONTEXT
     Change the current context to be the context CONTEXT.

 - Method: change-context ((contextName STRING)) : CONTEXT
     Change the current context to be the context named CONTEXTNAME.

 - Command: cc (&rest (name NAME)) : CONTEXT
     Change the current context to the one named NAME.  Return the
     value of the new current context.  If no NAME is supplied, return
     the pre-existing value of the current context.  `cc' is a no-op if
     the context reference cannot be successfully evaluated.

 - Command: defmodule ((name NAME) &rest (options OBJECT)) :
     Define (or redefine) a module named NAME.  The accepted syntax is:

            (defmodule <module-name>
               [:documentation <docstring>]
               [:includes {<module-name> | (<module-name>*)}]
               [:uses {<module-name> | (<module-name>*)}]
               [:lisp-package <package-name-string>]
               [:java-package <package-specification-string>]
               [:cpp-namespace <namespace-name-string>]
               [:java-catchall-class
               [:api? {TRUE | FALSE}]
               [:case-sensitive? {TRUE | FALSE}]
               [:shadow (<symbol>*)]
               [:java-catchall-class <class-name-string>]
               [<other-options>*])

     NAME can be a string or a symbol.

     Modules include objects from other modules via two separate
     mechanisms: (1) they inherit from their parents specified via the
     `:includes' option and/or a fully qualified module name, and (2)
     they inherit from used modules specified via the `:uses' option.
     The main difference between the two mechanisms is that inheritance
     from parents is transitive, while uses-links are only followed one
     level deep.  I.e., a module A that uses B will see all objects of
     B (and any of B's parents) but not see anything from modules used
     by B.  Another difference is that only objects declared as public
     can be inherited via uses-links (this is not yet enforced).  Note
     that - contrary to Lisp - there are separate name spaces for
     classes, functions, and variables.  For example, a module could
     inherit the class `CONS' from the `STELLA' module, but shadow the
     function of the same name.

     The above discussion of `:includes' and `:uses' semantics keyed on
     the inheritance/visibility of symbols. The PowerLoom system makes
     another very important distinction: If a module `A' is inherited
     directly or indirectly via `:includes' specification(s) by a
     submodule `B', then all definitions and facts asserted in `A' are
     visible in `B'. This is not the cases for `:uses'; the `:uses'
     options does not impact inheritance of propositions at all.

     The list of modules specified in the `:includes' option plus (if
     supplied) the parent in the path used for NAME become the new
     module's parents. If no `:uses' option was supplied, the new
     module will use the `STELLA' module by default, otherwise, it will
     use the set of specified modules.  If `:case-sensitive?' is
     supplied as TRUE, symbols in the module will be interned
     case-sensitively, otherwise (the default), they will be converted
     to uppercase before they get interned. Modules can shadow
     definitions of functions and classes inherited from parents or used
     modules. Shadowing is done automatically, but generates a warning
     unless the shadowed type or function name is listed in the
     `:shadow' option of the module definition .

     Examples:

            (defmodule "PL-KERNEL/PL-USER"
              :uses ("LOGIC" "STELLA")
              :package "PL-USER")
          
            (defmodule PL-USER/GENEALOGY)

     The remaining options are relevant only for modules that contain
     STELLA code.  Modules used only to contain knowledge base
     definitions and assertions have no use for them:

     The keywords `:lisp-package', `:java-package', and `:cpp-package'
     specify the name of a native package or name space in which
     symbols of the module should be allocated when they get translated
     into one of Lisp, Java, or C++. By default, Lisp symbols are
     allocated in the `STELLA' package, and C++ names are translated
     without any prefixes. The rules that the STELLA translator uses to
     attach translated Java objects to classes and packages are
     somewhat complex. Use :java-package option to specify a list of
     package names (separated by periods) that prefix the Java object
     in this module.  Use :java-catchall-class to specify the name of
     the Java class to contain all global & special variables,
     parameter-less functions and functions defined on arguments that
     are not classes in the current module.  The default value will be
     the name of the module.

     When set to TRUE, the :api? option tells the PowerLoom User Manual
     generator that all functions defined in this module should be
     included in the API section. Additionally, the Java translator
     makes all API functions `synchronized'.


 - Function: get-stella-module ((pathName STRING) (error? BOOLEAN)) :
          MODULE
     Return the module located at PATHNAME, or `null' if no such module
     exists.  The search looks at ancestors and top-most  (cardinal)
     modules.  If ERROR? is `true', throw an exception if no  module is
     found.

 - Function: find-or-create-module ((pathname STRING)) : MODULE
     Return a module located at PATHNAME if one exists,   otherwise
     create one

 - Command: clear-module (&rest (name NAME)) :
     Destroy all objects belonging to module NAME or any of its
     children.  If no NAME is supplied, the current module will be
     cleared after confirming with the user.  Important modules such as
     STELLA are protected against accidental clearing.

 - Function: destroy-module ((self MODULE)) :
     Destroy the module SELF, and recursively destroy all contexts that
     inherit SELF.

 - Method: destroy-context ((self MODULE)) :
     Destroy the context SELF, and recursively destroy all contexts
     that inherit SELF.

 - Function: visible-modules ((from MODULE)) : (CONS OF MODULE)
     Return a list of all modules visible from module FROM (or
     `*module*' if FROM is NULL.  The generated modules are generated
     from most to least-specific and will start with the module FROM.

 - Macro: within-module ((moduleForm OBJECT) &body (body CONS)) : OBJECT
     Execute BODY within the module resulting from MODULEFORM.
     `*module*' is an acceptable MODULEFORM.  It will locally rebind
     `*module*' and `*context*' and shield the outer bindings from
     changes.

 - Command: in-module ((name NAME)) : MODULE
     Change the current module to the module named NAME.

 - Method: change-module ((module MODULE)) : MODULE
     Change the current module to be the module MODULE.

 - Method: change-module ((moduleName STRING)) : MODULE
     Change the current module to be the module named MODULENAME.

 - Function: create-world ((parentContext CONTEXT) (name STRING)) :
          WORLD
     Create a new world below the world or module PARENTCONTEXT.
     Optionally, specify a name.

 - Function: push-world () : WORLD
     Spawn a new world that is a child of the current context, and
     change the current context to the new world.

 - Function: pop-world () : CONTEXT
     Destroy the current world and change the current context to be its
     parent.  Return the current context. Nothing happens if there is
     no current world.

 - Method: destroy-context ((self WORLD)) :
     Destroy the context SELF, and recursively destroy all contexts
     that inherit SELF.

 - Macro: within-world ((worldForm OBJECT) &body (body CONS)) : OBJECT
     Execute BODY within the world resulting from WORLDFORM.


File: manual.info,  Node: Input and Output,  Next: Files,  Prev: Contexts and Modules,  Up: Library Functions

Input and Output
================

 - Function: read-s-expression ((stream INPUT-STREAM)) : OBJECT BOOLEAN
     Read one STELLA s-expression from STREAM and return the result.
     Return `true' as the second value on EOF.

 - Function: read-s-expression-from-string ((string STRING)) : OBJECT
     Read one STELLA s-expression from STRING and return the result.

 - Function: read-line ((inputStream INPUT-STREAM)) : STRING BOOLEAN
     Read one line from INPUTSTREAM and return the result.  Return
     `true' as the second value on EOF.

 - Function: read-character ((inputStream INPUT-STREAM)) : CHARACTER
          BOOLEAN
     Read one character from INPUTSTREAM and return the result.  Return
     `true' as the second value on EOF.

 - Function: unread-character ((ch CHARACTER)
          (inputStream INPUT-STREAM)) :
     Unread CH from INPUTSTREAM.  Signal an error if CH was not the
     last character read.

 - Function: y-or-n? ((message STRING)) : BOOLEAN
     Read a line of input from STANDARD-INPUT and return `true' if the
     input was `y' or `false' if the input was `n'.  Loop until either
     `y' or `n' was entered.  If MESSAGE is non-`null' prompt with it
     before the input is read.  See also special variable
     `*USER-QUERY-ACTION*'.

 - Function: yes-or-no? ((message STRING)) : BOOLEAN
     Read a line of input from STANDARD-INPUT and return `true' if the
     input was `yes' or `false' if the input was `no'.  Loop until
     either `yes' or `no' was entered.  If MESSAGE is non-`null' prompt
     with it before the input is read.  See also special variable
     `*USER-QUERY-ACTION*'.


File: manual.info,  Node: Files,  Next: Dates and Times,  Prev: Input and Output,  Up: Library Functions

Files
=====

 - Function: probe-file? ((fileName FILE-NAME)) : BOOLEAN
     Return true if file FILENAME exists.  Note that this does not
     necessarily mean that the file can also be read.

 - Function: file-write-date ((fileName FILE-NAME)) : CALENDAR-DATE
     Return the time at which file FILENAME was last modified or NULL
     if that cannot be determined.

 - Function: file-length ((fileName FILE-NAME)) : INTEGER
     Return the length of file FILENAME in bytes or NULL if that cannot
     be determined.  Note that this will currently overrun for files
     that are longer than what can be represented by a STELLA integer.

 - Function: copy-file ((fromFile FILE-NAME) (toFile FILE-NAME)) :
     Copy file FROMFILE to file TOFILE, clobbering any data already in
     TOFILE.

 - Function: delete-file ((fileName FILE-NAME)) :
     Delete the file FILENAME.

 - Function: directory-file-name ((directory FILE-NAME)) : FILE-NAME
     Return DIRECTORY as a file name, i.e., without a terminating
     directory separator.

 - Function: directory-parent-directory ((directory FILE-NAME)
          (level INTEGER)) : FILE-NAME
     Return the LEVEL-th parent directory component of DIRECTORY
     including the final directory separator, or the empty string if
     DIRECTORY does not have that many parents.

 - Function: file-name-as-directory ((file FILE-NAME)) : FILE-NAME
     Return FILE interpreted as a directory, i.e., with a terminating
     directory separator.  If FILE is the empty string simply return
     the empty string, i.e., interpret it as the current directory
     instead of the root directory.

 - Function: file-name-directory ((file FILE-NAME)) : FILE-NAME
     Return the directory component of FILE including the final
     directory separator or the empty string if FILE does not include a
     directory.  Note that for purposes of this function, a logical
     host is considered part of the directory portion of FILE

 - Function: file-name-without-directory ((file FILE-NAME)) : FILE-NAME
     Return the file name portion of FILE by removing any directory and
     logical host components.

 - Function: file-name-without-extension ((file FILE-NAME)) : FILE-NAME
     Remove FILEs extension (or type) if there is any and return the
     result.

 - Function: file-extension ((file FILE-NAME)) : STRING
     Return FILEs extension (or type) if it has any including the
     separator character.

 - Function: file-base-name ((file FILE-NAME)) : FILE-NAME
     Remove FILEs directory (including logical host) and extension
     components and return the result.

 - Function: absolute-pathname? ((pathname STRING)) : BOOLEAN
     Not documented.

 - Function: logical-host? ((host STRING)) : BOOLEAN
     Not documented.

 - Function: logical-pathname? ((pathname STRING)) : BOOLEAN
     Not documented.

 - Function: translate-logical-pathname ((pathname STRING)) : STRING
     Not documented.

 - Function: directory-separator () : CHARACTER
     Not documented.

 - Function: directory-separator-string () : STRING
     Not documented.


File: manual.info,  Node: Dates and Times,  Next: XML Support,  Prev: Files,  Up: Library Functions

Dates and Times
===============

 - Function: get-current-date-time () : INTEGER INTEGER INTEGER KEYWORD
          INTEGER INTEGER INTEGER INTEGER
     Returns the current time in UTC as multiple values of year month
     day day-of-week hour minute second millisecond.  Currently
     millisecond will always be zero (even in Java where it is
     technically available).

 - Function: get-local-time-zone () : FLOAT
     Returns the current time zone offset from UTC as a float,
     considering the effects of daylight savings time.

 - Function: make-current-date-time () : CALENDAR-DATE
     Create a calendar date with current time and date.

 - Function: make-date-time ((year INTEGER) (month INTEGER)
          (day INTEGER) (hour INTEGER) (minute INTEGER)
          (second INTEGER) (millis INTEGER) (timezone FLOAT)) :
          CALENDAR-DATE
     Create a calendar date with the specified components.  YEAR must be
     the complete year (i.e., a year of 98 is 98 A.D in the 1st
     century).  TIMEZONE is a real number in the range -12.0 to +14.0
     where UTC is zone 0.0;  The number is the number of hours to add
     to UTC to arrive at local time.

 - Function: parse-date-time ((date-time-string STRING) (start INTEGER)
          (end INTEGER) (error-on-mismatch? BOOLEAN)) :
          DECODED-DATE-TIME
     Tries very hard to make sense out of the argument DATE-TIME-STRING
     and returns a time structure if successful.  If not, it returns
     `null'.  If ERROR-ON-MISMATCH? is true, parse-date-time will
     signal an error instead of returning `null'.  Default values are
     00:00:00 local time on the current date

 - Method: decode-calendar-date ((date CALENDAR-DATE) (timezone FLOAT))
          : DECODED-DATE-TIME
     Returns a decoded time object for DATE interpreted in TIMEZONE
     TIMEZONE is the number of hours added to UTC to get local time.
     It is in the range -12.0 to +14.0 where UTC is zone 0.0

 - Method: encode-calendar-date ((time-structure DECODED-DATE-TIME)) :
          CALENDAR-DATE
     Returns a calendar date object for TIME-STRUCTURE.

 - Function: calendar-date-to-string ((date CALENDAR-DATE)
          (timezone FLOAT) (include-timezone? BOOLEAN)) : STRING
     Returns a string representation of DATE adjusted for TIMEZONE

 - Function: string-to-calendar-date ((input STRING)) : CALENDAR-DATE
     Returns a calendar date object representing the date and time
     parsed from the INPUT string.  If no valid parse is found, `null'
     is returned.

 - ???: relative-date-to-string
     Not yet implemented.

 - Function: compute-calendar-date ((julian-day INTEGER)) : INTEGER
          INTEGER INTEGER KEYWORD
     Returns the YEAR, MONTH, DAY, DAY-OF-WEEK on which the given
     JULIAN-DAY begins at noon.

 - Function: compute-day-of-week ((yyyy INTEGER) (mm INTEGER)
          (dd INTEGER)) : KEYWORD
     Returns the day of the week for yyyy-mm-dd.

 - Function: compute-day-of-week-julian ((julian-day INTEGER)) : KEYWORD
     Returns the day of the week for julian-day

 - Function: compute-julian-day ((yyyy INTEGER) (mm INTEGER)
          (dd INTEGER)) : INTEGER
     Returns the Julian day that starts at noon on yyyy-mm-dd.  YYYY is
     the year.  MM is the month.  DD is the day of month.  Negative
     years are B.C.  Remember there is no year zero.

 - Function: compute-next-moon-phase ((n INTEGER) (phase KEYWORD)) :
          INTEGER FLOAT
     Returns the Julian Day and fraction of day of the Nth occurence
     since January 1, 1900 of moon PHASE.  PHASE is one of :NEW-MOON,
     :FIRST-QUARTER, :FULL-MOON, :LAST-QUARTER

 - Function: decode-time-in-millis ((time INTEGER)) : INTEGER INTEGER
          INTEGER INTEGER
     Returns multiple values of hours, minutes, seconds, milliseconds
     for TIME specified in milliseconds.

 - Function: julian-day-to-modified-julian-day ((julian-day INTEGER)) :
          INTEGER
     Returns the modified Julian day during which JULIAN-DAYstarts at
     noon.

 - Function: modified-julian-day-to-julian-day
          ((modified-julian-day INTEGER)) : INTEGER
     Returns the modified Julian day during which `julian-day'starts at
     noon.

 - Function: time-add ((t1 DATE-TIME-OBJECT) (t2 DATE-TIME-OBJECT)) :
          DATE-TIME-OBJECT
     Add T1 to T2.  If one of T1 or T2 is a calendar date, then the
     result is a calendar date.  If both T1 and T2 are relative dates,
     then the result is a relative date.  T1 and T2 cannot both be
     calendar dates.

 - Function: time-divide ((t1 TIME-DURATION) (t2 OBJECT)) : OBJECT
     Divides the relative date T1 by T2.  T2 must be either a relative
     date or a wrapped number.  If T2 is a relative date, then the
     return value will be a wrapped float.  If T2 is a wrapped number,
     then the reutrn value will be a relative date.

 - Function: time-multiply ((t1 OBJECT) (t2 OBJECT)) : TIME-DURATION
     Multiplies a relative date by a wrapped number.  One of T1 or T2
     must be a relative date and the other a wrapped number.

 - Function: time-subtract ((t1 DATE-TIME-OBJECT)
          (t2 DATE-TIME-OBJECT)) : DATE-TIME-OBJECT
     Subtract T2 from T1.  If T1 is a calendar date, then T2 can be
     either a calendar date (in which case the return value is a
     relative date) or it can be a relative date (in which case the
     return value is a calendar date).  If T1 is a relative date, then
     T2 must also be a relative date and a relative date is returned.

 - Function: get-ticktock () : TICKTOCK
     Return the current CPU time.  If the current OS/Language
     combination does not support measuring of CPU time, return real
     time instead.  Use `ticktock-difference' to measure the time
     difference between values returned by this function.  This is an
     attempt to provide some platform independent support to measure
     (at least approximately) consumed CPU time.

 - Function: ticktock-difference ((t1 TICKTOCK) (t2 TICKTOCK)) : FLOAT
     The difference in two TICKTOCK time values in seconds where T1 is
     the earlier time.  The resolution is implementation dependent but
     will normally be some fractional value of a second.

 - Function: ticktock-resolution () : FLOAT
     The minimum theoretically detectable resolution of the difference
     in two TICKTOCK time values in seconds.  This resolution is
     implementation dependent.  It may also not be realizable in
     practice, since the timing grain size may be larger than this
     resolution.

 - Function: sleep ((seconds FLOAT)) :
     The program will sleep for the indicated number of seconds.
     Fractional values are allowed, but the results are implementation
     dependent: Common Lisp uses the fractions natively, Java with a
     resolution of 0.001, and C++ can only use integral values.


File: manual.info,  Node: XML Support,  Next: Miscellaneous,  Prev: Dates and Times,  Up: Library Functions

XML Support
===========

 - Function: make-xml-element ((name STRING) (namespace-name STRING)
          (namespace STRING)) : XML-ELEMENT
     Creates and interns an XML element object NAME using NAMESPACE-NAME
     to refer to  NAMESPACE.  If NAMESPACE is `null', then the element
     will be interned in the null namespace.   NAMESPACE must otherwise
     be a URI.

 - Function: make-xml-global-attribute ((name STRING)
          (namespace-name STRING) (namespace STRING)) :
          XML-GLOBAL-ATTRIBUTE
     Creates and interns an XML global attribute object with NAME using
     NAMESPACE-NAME to refer to  NAMESPACE.  NAMESPACEmust be a URI.

 - Function: make-xml-local-attribute ((name STRING)
          (element XML-ELEMENT)) : XML-LOCAL-ATTRIBUTE
     Make an XML-LOCAL-ATTRIBUTE named NAME associated with ELEMENT

 - Function: get-xml-tag ((expression CONS)) : XML-ELEMENT
     Return the XML tag object of an XML EXPRESSION.

 - Function: get-xml-attributes ((expression CONS)) : CONS
     Return the list of attributes of an XML EXPRESSION (may be empty).

 - Function: get-xml-content ((expression CONS)) : CONS
     Return the list of content elements of an XML EXPRESSION (may be
     empty).

 - Function: get-xml-cdata-content ((form CONS)) : STRING
     Return the CDATA content of a CDATA FORM.  Does NOT make sure that
     FORM actually is a CDATA form, so bad things can happen if it is
     given wrong input.

 - Function: xml-declaration? ((item OBJECT)) : BOOLEAN
     Return `true' if ITEM is an XML declaration object

 - Function: xml-element? ((item OBJECT)) : BOOLEAN
     Return `true' if ITEM is an XML element object

 - Function: xml-attribute? ((item OBJECT)) : BOOLEAN
     Return `true' if ITEM is an XML attribute object

 - Function: xml-cdata? ((item OBJECT)) : BOOLEAN
     Return `true' if ITEM is an XML CDATA tag object

 - Function: xml-cdata-form? ((form OBJECT)) : BOOLEAN
     Return `true' if FORM is an CONS headed by a CDATA tag

 - Method: xml-element-match? ((tag XML-ELEMENT) (name STRING)
          (namespace STRING)) : BOOLEAN
     Returns `true' if TAG is an XML element with the name NAME in
     namespace NAMESPACE.  Note that NAMESPACE is the full URI, not an
     abbreviation.  Also, NAMESPACE may be `null', in which case TAG
     must not have a namespace associated with it.

 - Method: xml-attribute-match? ((attribute XML-ATTRIBUTE)
          (name STRING) (namespace STRING)) : BOOLEAN
     Return `true' if ATTRIBUTE is an XML attribute with name NAME in
     namespace NAMESPACE.  Note that NAMESPACE is the full URI, not an
     abbreviation.  Also, NAMESPACE may be `null', in which case
     ATTRIBUTE must not have a namespace associated with it.

 - Method: xml-attribute-match? ((attribute XML-GLOBAL-ATTRIBUTE)
          (name STRING) (namespace STRING)) : BOOLEAN
     Return `true' if ATTRIBUTE is a global  XML attribute with name
     NAME in namespace NAMESPACE.  Note that NAMESPACE is the full URI,
     not an abbreviation.  Also, NAMESPACE may be `null', in which case
     ATTRIBUTE must not have a namespace associated with it.

 - Method: xml-attribute-match? ((attribute XML-LOCAL-ATTRIBUTE)
          (name STRING) (namespace STRING)) : BOOLEAN
     Return `true' if ATTRIBUTE is a local XML attribute with name NAME.
     Note that NAMESPACE must be `null' and that the ATTRIBUTEs parent
     element element is not considered by the match.  To take the
     parent element into account use `xml-local-attribute-match?'.

 - Function: xml-local-attribute-match?
          ((attribute XML-LOCAL-ATTRIBUTE) (name STRING)
          (element-name STRING) (element-namespace STRING)) : BOOLEAN
     Return true if ATTRIBUTE is a local attribute with NAME and whose
     parent element matches ELEMENT-NAME and ELEMENT-NAMESPACE.

 - Function: xml-lookup-attribute ((attributes CONS) (name STRING)
          (namespace STRING)) : STRING
     Find the XML attribute in ATTRIBUTES with NAME and NAMESPACE and
     return its value.  Note that it is assumed that all ATTRIBUTES
     come from the same known tag, hence, the parent elements of any
     local attributes are not considered by the lookup.

 - Macro: xml-tag-case ((item OBJECT) &body (clauses CONS)) : OBJECT
     A case form for matching ITEM against XML element tags.  Each
     element of CLAUSES should be a clause with the form   ("tagname"
     ...)     or   (("tagname" "namespace-uri") ...)  The clause heads
     can optionally be symbols instead of strings.  The key forms the
     parameters to the method `xml-element-match?', with a missing
     namespace argument passed as NULL.

     The namespace argument will be evaluated, so one can use bound
     variables in place of a fixed string.   As a special case, if the
     namespace argument is :ANY, then the test will be done for a match
     on the tag name alone.

 - Function: read-xml-expression ((stream INPUT-STREAM)
          (start-tag OBJECT)) : OBJECT BOOLEAN
     Read one balanced XML expression from STREAM and return its
     s-expression representation (see
     `xml-token-list-to-s-expression').  If `startTagName' is
     non-`null', skip all tags until a start tag matching START-TAG is
     encountered.  XML namespaces are ignored for outside of the start
     tag.  Use s-expression representation to specify START-TAG, e.g.,
     `(KIF (:version "1.0"))'.  The tag can be an XML element object, a
     symbol, a string or a cons.  If the tag is a cons the first
     element can also be (name namespace) pair.

     Return `true' as the second value on EOF.

     CHANGE WARNING:  It is anticipated that this function will change
     to  a) Properly take XML namespaces into account and  b) require
     XML element objects instead of strings as the second argument.
     This change will not be backwards-compatible.

 - Function: xml-expressions ((stream INPUT-STREAM) (regionTag OBJECT))
          : XML-EXPRESSION-ITERATOR
     Return an XML-expression-iterator (which see) reading from STREAM.
     REGIONTAG can be used to define delimited regions from which
     expressions should be considered. Use s-expression representation
     to specify REGIONTAG, e.g., `(KIF (:version "1.0"))'.  The tag can
     be an XML element object, a symbol, a string or a cons.  If the
     tag is a cons the first element can also be (name namespace) pair.

 - Function: print-xml-expression ((stream OUTPUT-STREAM)
          (xml-expression CONS) (indent INTEGER)) :
     Prints XML-EXPRESSION on STREAM.  Indentation begins with the
     value of INDENT.  If this is the `null' integer, no indentation is
     performed.  Otherwise it should normally be specified as 0 (zero)
     for top-level calls.

     It is assumed that the XML-EXPRESSION is a well-formed CONS-list
     representation of an XML  form.  It expects a form like that form
     returned by `read-XML-expression'.

     Also handles a list of xml forms such as that returned by
     `XML-expressions'.  In that case, each of the forms is indented by
     INDENT spaces.

 - Function: reset-xml-hash-tables () :
     Resets Hashtables used for interning XML elements and global
     attribute objects.  This will allow garbage collection of
     no-longer used objects, but will also mean that newly parsed xml
     elements and global attributes will not be eq? to already existing
     ones with the same name.

