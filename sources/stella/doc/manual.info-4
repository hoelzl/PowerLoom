This is manual.info, produced by makeinfo version 4.3 from manual.texi.

   This file documents the STELLA programming language.

   Copyright (C) 2006 University of Southern California, Information
Sciences Institute 4676 Admiralty Way Marina Del Rey, CA 90292

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.


File: manual.info,  Node: Hash Sets,  Next: Iterators,  Prev: Key Value Maps,  Up: Library Functions

Hash Sets
=========

   `HASH-SET' is a full-featured set class that supports `eql?' or
extensible `equal?' equality tests, O(1) insert and `member?'
operations, O(N) `intersection' etc. operations even for large numbers
of entries by using a STELLA hash table, light-weight `KV-CONS'
representation for small sets and iteration even if the set is
represented by a hash table.  The only minor drawback right now is that
we waste one value slot per entry, since we piggy-back off
`KEY-VALUE-MAP''s, however, that wastes at most 25% space.

 - Class: HASH-SET : KEY-VALUE-MAP, SET-MIXIN
     Full-featured set class that supports `eql?' or `equal?' equality
     tests, O(1) insert and `member?' operations & O(N) `intersection'
     etc. operations even for large numbers of entries by using a hash
     table, light-weight KV-CONS representation for small sets and
     iteration even if the set is represented by a hash table.  The
     only minor drawback right now is that this wastes a value slot per
     entry, since we piggy-back off KEY-VALUE-MAP's, however, that
     wastes at most 25% space.

 - Function: hash-set (&rest (values OBJECT)) : HASH-SET
     Return an `eql?' HASH-SET containing VALUES.

 - Method on HASH-SET: member? (self (object OBJECT)) : BOOLEAN
     Return TRUE iff OBJECT is a member of the set SELF.  Uses an
     `eql?' test by default or `equal?' if `equal-test?' of SELF is
     TRUE.

 - Method on HASH-SET: insert (self (value (LIKE (ANY-VALUE SELF)))) :
     Add VALUE to the set SELF unless it is already a member.  Uses an
     `eql?' test by default or `equal?' if `equal-test?' of SELF is
     TRUE.

 - Method on HASH-SET: remove (self (value (LIKE (ANY-VALUE SELF)))) :
          (LIKE SELF)
     Destructively remove VALUE from the set SELF if it is a member and
     return SELF.  Uses an `eql?' test by default or `equal?' if
     `equal-test?' of SELF is TRUE.

 - Method on HASH-SET: remove-if (self (test? FUNCTION-CODE)) : (LIKE
          SELF)
     Destructively remove all elements of the set SELF for which TEST?
     evaluates to TRUE.  TEST? takes a single argument of type OBJECT
     and returns TRUE or FALSE.  Returns SELF.

 - Method on HASH-SET: pop (self) : (LIKE (ANY-VALUE SELF))
     Remove and return an arbitrary element of the set SELF.  Return
     NULL if the set is empty.  Performance note: for large sets
     implemented via hash tables it takes O(N) to empty out the set
     with repeated calls to `pop', since the emptier the table gets,
     the longer it takes to find an element.  Therefore, it is usually
     better to use iteration with embedded removals for such cases.

 - Method on HASH-SET: substitute (self (new OBJECT) (old OBJECT)) :
          (LIKE SELF)
     Destructively replace OLD with NEW in the set SELF unless NEW is
     already a member.  Uses an `eql?' test by default or `equal?' if
     `equal-test?' of SELF is TRUE.

 - Method on HASH-SET: copy (self) : (LIKE SELF)
     Return a copy of the set SELF.  All entries are freshly allocated,
     however, the values are not copied themselves (similar to what we
     do for lists, etc.).

 - Method on HASH-SET: consify (self) : (CONS OF (LIKE (ANY-VALUE
          SELF)))
     Collect all entries of SELF into a cons list and return the result.

 - Method on HASH-SET: subset? (self (otherSet HASH-SET)) : BOOLEAN
     Return true if every element of SELF also occurs in OTHERSET.
     Uses an `eql?' test by default or `equal?' if `equal-test?' of
     SELF is TRUE.

 - Method on HASH-SET: equivalent-sets? (self (otherSet HASH-SET)) :
          BOOLEAN
     Return true if every element of SELF occurs in OTHERSET and vice
     versa.  Uses an `eql?' test by default or `equal?' if
     `equal-test?' of SELF is TRUE.

 - Method on HASH-SET: intersection (self (otherSet HASH-SET)) :
          HASH-SET
     Return the set intersection of SELF and OTHERSET as a new set.
     Uses an `eql?' test by default or `equal?' if `equal-test?' of
     SELF is TRUE.

 - Method on HASH-SET: union (self (otherSet HASH-SET)) : HASH-SET
     Return the set union of SELF and OTHERSET as a new set.  Uses an
     `eql?' test by default or `equal?' if `equal-test?' of SELF is
     TRUE.

 - Method on HASH-SET: difference (self (otherSet HASH-SET)) : HASH-SET
     Return the set difference of SELF and OTHERSET as a new set (i.e.,
     all elements that are in SELF but not in OTHERSET).  Uses an
     `eql?' test by default or `equal?' if `equal-test?' of SELF is
     TRUE.

 - Method on HASH-SET: subtract (self (otherSet HASH-SET)) : HASH-SET
     Return the set difference of SELF and OTHERSET by destructively
     removing elements from SELF that also occur in OTHERSET.  Uses an
     `eql?' test by default or `equal?' if `equal-test?' of SELF is
     TRUE.

 - Method on HASH-SET: object-equal? (x (y OBJECT)) : BOOLEAN
     Return TRUE iff sets X and Y are HASH-SET's with equivalent
     members.  Uses an `eql?' test by default or `equal?' if
     `equal-test?' of `self' is TRUE.  This is equivalent to calling
     `equivalent-sets?'.

 - Method on HASH-SET: equal-hash-code (self) : INTEGER
     Return an `equal?' hash code for SELF.  Note that this is O(N) in
     the number of elements of SELF.


File: manual.info,  Node: Iterators,  Next: Symbols,  Prev: Hash Sets,  Up: Library Functions

Iterators
=========

 - Method on ITERATOR: empty? (self) : BOOLEAN
     Return TRUE if the sequence represented by SELF has no elements.
     Side-effect free.

 - Method on ITERATOR: member? (self (value OBJECT)) : BOOLEAN
     Iterate over values of SELF, returning TRUE if one of them is
     `eql' to 'value.

 - Method on ABSTRACT-ITERATOR: length (self) : INTEGER
     Iterate over SELF, and count how many items there are.  Bad idea
     if SELF iterates over an infinite collection, since in that case
     it will run forever.'

 - Method on ITERATOR: pop (self) : (LIKE (ANY-VALUE SELF))
     Return the first item of the sequence represented by SELF, or NULL
     if it is empty.  Destructively uses up the first iteration element.

 - Method on ITERATOR: advance (self (n INTEGER)) : (LIKE SELF)
     Return SELF after skipping over the first N elements in the
     (remainder of the) iteration.

 - Method on ITERATOR: concatenate (iterator1 (iterator2 ITERATOR)
          &rest (otherIterators ITERATOR)) : ALL-PURPOSE-ITERATOR
     Return an iterator that first generates all values of ITERATOR1,
     then those of ITERATOR2, and then those of all OTHERITERATORS.
     The generated values can be filtered by supplying a filter
     function to the resulting iterator.

 - Method on ITERATOR: consify (self) : (CONS OF (LIKE (ANY-VALUE
          SELF)))
     Return a list of elements generated by SELF.

 - Method on ALL-PURPOSE-ITERATOR: next? (self) : BOOLEAN
     Apply the stored `next?' function to SELF.


File: manual.info,  Node: Symbols,  Next: Contexts and Modules,  Prev: Iterators,  Up: Library Functions

Symbols
=======

 - Function: lookup-symbol ((name STRING)) : SYMBOL
     Return the first symbol with NAME visible from the current module.

 - Function: intern-symbol ((name STRING)) : SYMBOL
     Return a newly-created or existing symbol with name NAME.

 - Function: unintern-symbol ((self SYMBOL)) :
     Remove SELF from its home module and the symbol table.

 - Function: lookup-symbol-in-module ((name STRING) (module MODULE)
          (local? BOOLEAN)) : SYMBOL
     Return the first symbol with NAME visible from MODULE.  If LOCAL?
     only consider symbols directly interned in MODULE.  If MODULE is
     `null', use `*MODULE*' instead.

 - Function: intern-symbol-in-module ((name STRING) (module MODULE)
          (local? BOOLEAN)) : SYMBOL
     Look for a symbol named NAME in MODULE (if LOCAL? do not consider
     inherited modules).  If none exists, intern it locally in MODULE.
     Return the existing or newly-created symbol.

 - Function: intern-derived-symbol ((baseSymbol GENERALIZED-SYMBOL)
          (newName STRING)) : SYMBOL
     Return a newly-created or existing symbol with name NEWNAME which
     is interned in the same module as BASESYMBOL.

 - Function: visible-symbol? ((self SYMBOL)) : BOOLEAN
     Return `true' if SELF is visible from the current module.

 - Function: lookup-visible-symbols-in-module ((name STRING)
          (module MODULE) (enforceShadowing? BOOLEAN)) : (CONS OF
          SYMBOL)
     Return the list of symbols with NAME visible from MODULE.  More
     specific symbols (relative to the module precedence order defined
     by `visible-modules') come earlier in the list.  If MODULE is
     `null', start from `*MODULE*' instead.  If ENFORCESHADOWING? is
     true, do not return any symbols that are shadowed due to some
     :SHADOW declaration.

 - Function: import-symbol ((symbol SYMBOL) (module MODULE)) : SYMBOL
     Import SYMBOL into MODULE and return the imported SYMBOL.  Signal
     an error if a different symbol with the same name already exists
     locally in MODULE.  Any symbol with the same name visible in
     MODULE by inheritance will be shadowed by the newly imported
     SYMBOL.

 - Function: safe-import-symbol ((symbol SYMBOL) (module MODULE)) :
          SYMBOL
     Safe version of `import-symbol' (which see).  Only imports SYMBOL
     if no symbol with that name is currently interned or visible in
     MODULE.  Returns SYMBOL if it was imported or the conflicting
     symbol in MODULE otherwise.

 - Function: lookup-surrogate ((name STRING)) : SURROGATE
     Return the first surrogate with NAME visible from the current
     module.

 - Function: intern-surrogate ((name STRING)) : SURROGATE
     Return a newly-created or existing surrogate with name NAME.

 - Function: unintern-surrogate ((self SURROGATE)) :
     Remove SELF from its home module and the surrogate table.

 - Function: lookup-surrogate-in-module ((name STRING) (module MODULE)
          (local? BOOLEAN)) : SURROGATE
     Return the first surrogate with NAME visible from MODULE.  If
     LOCAL? only consider surrogates directly interned in MODULE.  If
     MODULE is `null', use `*MODULE*' instead.

 - Function: intern-surrogate-in-module ((name STRING) (module MODULE)
          (local? BOOLEAN)) : SURROGATE
     Look for a symbol named NAME in MODULE (if LOCAL? do not consider
     inherited modules).  If none exists, intern it locally in MODULE.
     Return the existing or newly-created symbol.

 - Function: intern-derived-surrogate ((baseSymbol GENERALIZED-SYMBOL)
          (newName STRING)) : SURROGATE
     Return a newly-created or existing surrogate with name NEWNAME
     which is interned in the same module as BASESYMBOL.

 - Function: visible-surrogate? ((self SURROGATE)) : BOOLEAN
     Return `true' if SELF is visible from the current module.

 - Function: lookup-visible-surrogates-in-module ((name STRING)
          (module MODULE) (enforceShadowing? BOOLEAN)) : (CONS OF
          SURROGATE)
     Return the list of surrogates with NAME visible from MODULE.  More
     specific surrogates (relative to the module precedence order
     defined by `visible-modules') come earlier in the list.  If MODULE
     is `null', start from `*MODULE*' instead.  If ENFORCESHADOWING? is
     true, do not return any surrogates that are shadowed due to some
     :SHADOW declaration.

 - Function: import-surrogate ((surrogate SURROGATE) (module MODULE)) :
          SURROGATE
     Import SURROGATE into MODULE and return the imported SURROGATE.
     Signal an error if a different surrogate with the same name
     already exists locally in MODULE.  Any surrogate with the same
     name visible in MODULE by inheritance will be shadowed by the
     newly imported SURROGATE.

 - Function: safe-import-surrogate ((surrogate SURROGATE)
          (module MODULE)) : SURROGATE
     Safe version of `import-surrogate' (which see).  Only imports
     SURROGATE if no surrogate with that name is currently interned or
     visible in MODULE.  Returns SURROGATE if it was imported or the
     conflicting surrogate in MODULE otherwise.

 - Function: lookup-keyword ((name STRING)) : KEYWORD
     Return the keyword with NAME if it exists.

 - Function: intern-keyword ((name STRING)) : KEYWORD
     Return a newly-created or existing keyword with name NAME.
     Storage note: a COPY of NAME is stored in the keyword

 - Function: gensym ((prefix STRING)) : SYMBOL
     Return a transient symbol with a name beginning with PREFIX and
     ending with a globally gensym'd integer.

 - Function: local-gensym ((prefix STRING)) : SYMBOL
     Not documented.

 - Function: symbol-plist ((symbol SYMBOL)) : CONS
     Return the property list of SYMBOL.  The `symbol-plist' of a
     symbol can be set with `setf'.  IMPORTANT: Property list are
     modified destructively, hence, if you supply it as a whole make
     sure to always supply a modfiable copy, e.g., by using `bquote'.

 - Function: symbol-property ((symbol SYMBOL) (key STANDARD-OBJECT)) :
          OBJECT
     Return the property of SYMBOL whose key is `eq?' to KEY.  Symbol
     properties can be set with `setf'.

 - Function: symbol-value ((symbol SYMBOL)) : OBJECT
     Return the value of SYMBOL.  Note, that this value is not visible
     to code that references a variable with the same name as SYMBOL.
     The `symbol-value' is simply a special property that can always be
     accessed in constant time.  The `symbol-value' of a symbol can be
     changed with `setf'.

 - Function: symbolize ((surrogate SURROGATE)) : SYMBOL
     Convert SURROGATE into a symbol with the same name and module.


File: manual.info,  Node: Contexts and Modules,  Next: Input and Output,  Prev: Symbols,  Up: Library Functions

Context and Modules
===================

 - Function: get-stella-context ((pathName STRING) (error? BOOLEAN)) :
          CONTEXT
     Return the context located at PATHNAME, or `null' if no such
     context exists.  If ERROR? is `true', throw an exception if no
     context is found, otherwise silently return `null'.

 - Function: clear-context ((self CONTEXT)) :
     Destroy all objects belonging to SELF or any of its subcontexts.

 - Macro: within-context ((contextForm OBJECT) &body (body CONS)) :
          OBJECT
     Execute BODY within the context resulting from CONTEXTFORM.

 - Method on CONTEXT: destroy-context (self) :
     Make the translator happy.

 - Method on STRING: destroy-context (self) :
     Destroy the context SELF, and recursively destroy all contexts
     that inherit SELF.

 - Method on CONTEXT: change-context (context) : CONTEXT
     Change the current context to be the context CONTEXT.

 - Method on STRING: change-context (contextName) : CONTEXT
     Change the current context to be the context named CONTEXTNAME.

 - N-Command: cc (&rest (name NAME)) : CONTEXT
     Change the current context to the one named NAME.  Return the
     value of the new current context.  If no NAME is supplied, return
     the pre-existing value of the current context.  `cc' is a no-op if
     the context reference cannot be successfully evaluated.

 - N-Command: defmodule ((name NAME) &rest (options OBJECT)) :
     Define (or redefine) a module named NAME.  The accepted syntax is:

            (defmodule <module-name>
               [:documentation <docstring>]
               [:includes {<module-name> | (<module-name>*)}]
               [:uses {<module-name> | (<module-name>*)}]
               [:lisp-package <package-name-string>]
               [:java-package <package-specification-string>]
               [:cpp-namespace <namespace-name-string>]
               [:java-catchall-class
               [:api? {TRUE | FALSE}]
               [:case-sensitive? {TRUE | FALSE}]
               [:shadow (<symbol>*)]
               [:java-catchall-class <class-name-string>]
               [<other-options>*])

     NAME can be a string or a symbol.

     Modules include objects from other modules via two separate
     mechanisms: (1) they inherit from their parents specified via the
     `:includes' option and/or a fully qualified module name, and (2)
     they inherit from used modules specified via the `:uses' option.
     The main difference between the two mechanisms is that inheritance
     from parents is transitive, while uses-links are only followed one
     level deep.  I.e., a module A that uses B will see all objects of
     B (and any of B's parents) but not see anything from modules used
     by B.  Another difference is that only objects declared as public
     can be inherited via uses-links (this is not yet enforced).  Note
     that - contrary to Lisp - there are separate name spaces for
     classes, functions, and variables.  For example, a module could
     inherit the class `CONS' from the `STELLA' module, but shadow the
     function of the same name.

     The above discussion of `:includes' and `:uses' semantics keyed on
     the inheritance/visibility of symbols. The PowerLoom system makes
     another very important distinction: If a module `A' is inherited
     directly or indirectly via `:includes' specification(s) by a
     submodule `B', then all definitions and facts asserted in `A' are
     visible in `B'. This is not the cases for `:uses'; the `:uses'
     options does not impact inheritance of propositions at all.

     The list of modules specified in the `:includes' option plus (if
     supplied) the parent in the path used for NAME become the new
     module's parents. If no `:uses' option was supplied, the new
     module will use the `STELLA' module by default, otherwise, it will
     use the set of specified modules.

     If `:case-sensitive?' is supplied as TRUE, symbols in the module
     will be interned case-sensitively, otherwise (the default), they
     will be converted to uppercase before they get interned.  That
     means that any reference from inside a case-sensitive module to a
     non-case-sensitive module will have to use uppercase names for
     symbols in the non-case-sensitive module.  The standard system
     modules are all NOT case sensitive.

     Modules can shadow definitions of functions and classes inherited
     from parents or used modules. Shadowing is done automatically, but
     generates a warning unless the shadowed type or function name is
     listed in the `:shadow' option of the module definition .

     Examples:

            (defmodule "PL-KERNEL/PL-USER"
              :uses ("LOGIC" "STELLA")
              :package "PL-USER")
          
            (defmodule PL-USER/GENEALOGY)

     The remaining options are relevant only for modules that contain
     STELLA code.  Modules used only to contain knowledge base
     definitions and assertions have no use for them:

     The keywords `:lisp-package', `:java-package', and `:cpp-package'
     specify the name of a native package or name space in which
     symbols of the module should be allocated when they get translated
     into one of Lisp, Java, or C++. By default, Lisp symbols are
     allocated in the `STELLA' package, and C++ names are translated
     without any prefixes. The rules that the STELLA translator uses to
     attach translated Java objects to classes and packages are
     somewhat complex. Use :java-package option to specify a list of
     package names (separated by periods) that prefix the Java object
     in this module.  Use :java-catchall-class to specify the name of
     the Java class to contain all global & special variables,
     parameter-less functions and functions defined on arguments that
     are not classes in the current module.  The default value will be
     the name of the module.

     When set to TRUE, the :api? option tells the PowerLoom User Manual
     generator that all functions defined in this module should be
     included in the API section. Additionally, the Java translator
     makes all API functions `synchronized'.


 - Function: get-stella-module ((pathName STRING) (error? BOOLEAN)) :
          MODULE
     Return the module located at PATHNAME, or `null' if no such module
     exists.  The search looks at ancestors and top-most  (cardinal)
     modules.  If ERROR? is `true', throw an exception if no  module is
     found.

 - Function: find-or-create-module ((pathname STRING)) : MODULE
     Return a module located at PATHNAME if one exists,   otherwise
     create one

 - N-Command: clear-module (&rest (name NAME)) :
     Destroy all objects belonging to module NAME or any of its
     children.  If no NAME is supplied, the current module will be
     cleared after confirming with the user.  Important modules such as
     STELLA are protected against accidental clearing.

 - Function: destroy-module ((self MODULE)) :
     Destroy the module SELF, and recursively destroy all contexts that
     inherit SELF.

 - Method on MODULE: destroy-context (self) :
     Destroy the context SELF, and recursively destroy all contexts
     that inherit SELF.

 - Function: visible-modules ((from MODULE)) : (CONS OF MODULE)
     Return a list of all modules visible from module FROM (or
     `*module*' if FROM is NULL.  The generated modules are generated
     from most to least-specific and will start with the module FROM.

 - Macro: within-module ((moduleForm OBJECT) &body (body CONS)) : OBJECT
     Execute BODY within the module resulting from MODULEFORM.
     `*module*' is an acceptable MODULEFORM.  It will locally rebind
     `*module*' and `*context*' and shield the outer bindings from
     changes.

 - N-Command: in-module ((name NAME)) : MODULE
     Change the current module to the module named NAME.

 - Method on MODULE: change-module (module) : MODULE
     Change the current module to be the module MODULE.

 - Method on STRING: change-module (moduleName) : MODULE
     Change the current module to be the module named MODULENAME.

 - Function: create-world ((parentContext CONTEXT) (name STRING)) :
          WORLD
     Create a new world below the world or module PARENTCONTEXT.
     Optionally, specify a name.

 - Command: push-world () : WORLD
     Spawn a new world that is a child of the current context, and
     change the current context to the new world.

 - Command: pop-world () : CONTEXT
     Destroy the current world and change the current context to be its
     parent.  Return the current context. Nothing happens if there is
     no current world.

 - Method on WORLD: destroy-context (self) :
     Destroy the context SELF, and recursively destroy all contexts
     that inherit SELF.

 - Macro: within-world ((worldForm OBJECT) &body (body CONS)) : OBJECT
     Execute BODY within the world resulting from WORLDFORM.


File: manual.info,  Node: Input and Output,  Next: Files,  Prev: Contexts and Modules,  Up: Library Functions

Input and Output
================

 - Function: read-s-expression ((stream INPUT-STREAM)) : OBJECT BOOLEAN
     Read one STELLA s-expression from STREAM and return the result.
     Return `true' as the second value on EOF.

 - Function: read-s-expression-from-string ((string STRING)) : OBJECT
     Read one STELLA s-expression from STRING and return the result.

 - Function: read-line ((stream INPUT-STREAM)) : STRING
     Read one line from STREAM and return the result.  This differs
     from `native-read-line' in that it is not platform-dependent.  It
     recognizes any of the three common line ending formats: CR, LF,
     CR-LF in any combination.  It is not as fast as
     `native-read-line', however.

 - Function: read-character ((inputStream INPUT-STREAM)) : CHARACTER
          BOOLEAN
     Read one character from INPUTSTREAM and return the result.  Return
     `true' as the second value on EOF.

 - Function: unread-character ((ch CHARACTER)
          (inputStream INPUT-STREAM)) :
     Unread CH from INPUTSTREAM.  Signal an error if CH was not the
     last character read.

 - Function: y-or-n? ((message STRING)) : BOOLEAN
     Read a line of input from STANDARD-INPUT and return `true' if the
     input was `y' or `false' if the input was `n'.  Loop until either
     `y' or `n' was entered.  If MESSAGE is non-`null' prompt with it
     before the input is read.  See also special variable
     `*USER-QUERY-ACTION*'.

 - Function: yes-or-no? ((message STRING)) : BOOLEAN
     Read a line of input from STANDARD-INPUT and return `true' if the
     input was `yes' or `false' if the input was `no'.  Loop until
     either `yes' or `no' was entered.  If MESSAGE is non-`null' prompt
     with it before the input is read.  See also special variable
     `*USER-QUERY-ACTION*'.

 - Function: flush-output ((self OUTPUT-STREAM)) :
     Flush all buffered output of SELF.


File: manual.info,  Node: Files,  Next: Dates and Times,  Prev: Input and Output,  Up: Library Functions

Files
=====

 - Function: open-input-file ((fileName STRING)
          &rest (options KEYWORD)) : FILE-INPUT-STREAM
     Open file FILENAME for input and return the resulting input stream.
     By default signal an error if the file does not exist.  The only
     legal option so far is `:IF-NOT-EXISTS' (or
     `:IF-NOT-EXISTS-ACTION') which specifies what to do in case the
     file does not exist.  If its value is `:ERROR' then an error will
     be signaled.  If it is `:ABORT' or `:PROBE' the opening operation
     will be aborted and NULL will be returned.

 - Function: open-output-file ((fileName STRING)
          &rest (options KEYWORD)) : FILE-OUTPUT-STREAM
     Open file FILENAME for output and return the resulting output
     stream.  By default the file will be created or overwritten if it
     already exists.  If `:IF-EXISTS' (or `:IF-EXISTS-ACTION') is one
     of the OPTIONS its value specifies what to do in case the file
     already exists.  If the value is `:SUPERSEDE' the pre-existing
     file will be overwritten.  If the value is `:APPEND' the
     preexisting file will be appended to (if the file did not yet
     exist the file will simply be created).  If the value is `:ERROR'
     then an error will be signaled.  If it is `:ABORT' or `:PROBE' the
     opening operation will be aborted and NULL will be returned.

     If `:IF-NOT-EXISTS' (or `:IF-NOT-EXISTS-ACTION') is one of the
     OPTIONS its value specifies what to do in case the file does not
     already exist.  If the value is `:CREATE', the file will simply be
     created.  If the value is `:ERROR' then an error will be signaled.
     If it is `:ABORT' or `:PROBE' the opening operation will be
     aborted and NULL will be returned.

 - Function: close-stream ((self STREAM)) :
     Close the stream SELF.

 - Function: close-all-files () :
     Close all currently open file streams.  Use for emergencies or for
     cleanup.

 - Macro: with-input-file ((binding CONS) &body (body CONS)) : OBJECT
     Sets up an unwind-protected form which opens a file for input and
     closes it afterwards.  The stream for reading is bound to the
     variable provided in the macro form.  Syntax is `(WITH-INPUT-FILE
     (var filename options*) body+)' where `options' can be any that
     are legal for `open-input-file' (which see).

 - Macro: with-output-file ((binding CONS) &body (body CONS)) : OBJECT
     Sets up an unwind-protected form which opens a file for output and
     closes it afterwards.  The stream for writing is bound to the
     variable provided in the macro form.  Syntax is `(WITH-OUTPUT-FILE
     (var filename options*) body+)' where `options' can be any that
     are legal for `open-output-file' (which see).

 - Function: probe-file? ((fileName FILE-NAME)) : BOOLEAN
     Return true if file FILENAME exists.  Note that this does not
     necessarily mean that the file can also be read.

 - Function: file-write-date ((fileName FILE-NAME)) : CALENDAR-DATE
     Return the time at which file FILENAME was last modified or NULL
     if that cannot be determined.

 - Function: file-length ((fileName FILE-NAME)) : LONG-INTEGER
     Return the length of file FILENAME in bytes or NULL if that cannot
     be determined.

 - Function: copy-file ((fromFile FILE-NAME) (toFile FILE-NAME)) :
     Copy file FROMFILE to file TOFILE, clobbering any data already in
     TOFILE.

 - Function: delete-file ((fileName FILE-NAME)) :
     Delete the file FILENAME.

 - Function: rename-file ((fromFile FILE-NAME) (toFile FILE-NAME)) :
     Rename the file FROMFILE to TOFILE.

 - Function: make-temporary-file-name ((prefix STRING) (suffix STRING))
          : STRING
     Return a file name of the form `<prefix>NNNNNN<suffix>' which is
     guaranteed to not refer to any existing file.  A null PREFIX
     defaults to `tmpfile', a null SUFFIX defaults to the empty string.
     The number portion NNNNNN will correpond to a random number
     between 0 and 999999.  If no qualifying filename can be found
     after 100 attempts, NULL will be returned.  Note that it is
     possible due to multi-threading or processing that the generated
     filename becomes used by another thread or OS process.  If
     necessary, this case can be handled by the caller.

 - Function: directory-file-name ((directory FILE-NAME)) : FILE-NAME
     Return DIRECTORY as a file name, i.e., without a terminating
     directory separator.

 - Function: directory-parent-directory ((directory FILE-NAME)
          (level INTEGER)) : FILE-NAME
     Return the LEVEL-th parent directory component of DIRECTORY
     including the final directory separator, or the empty string if
     DIRECTORY does not have that many parents.

 - Function: file-name-as-directory ((file FILE-NAME)) : FILE-NAME
     Return FILE interpreted as a directory, i.e., with a terminating
     directory separator.  If FILE is the empty string simply return
     the empty string, i.e., interpret it as the current directory
     instead of the root directory.

 - Function: file-name-directory ((file FILE-NAME)) : FILE-NAME
     Return the directory component of FILE including the final
     directory separator or the empty string if FILE does not include a
     directory.  Note that for purposes of this function, a logical
     host is considered part of the directory portion of FILE

 - Function: file-name-without-directory ((file FILE-NAME)) : FILE-NAME
     Return the file name portion of FILE by removing any directory and
     logical host components.

 - Function: file-name-without-extension ((file FILE-NAME)) : FILE-NAME
     Remove FILEs extension (or type) if there is any and return the
     result.

 - Function: file-extension ((file FILE-NAME)) : STRING
     Return FILEs extension (or type) if it has any including the
     separator character.

 - Function: file-base-name ((file FILE-NAME)) : FILE-NAME
     Remove FILEs directory (including logical host) and extension
     components and return the result.

 - Function: absolute-pathname? ((pathname STRING)) : BOOLEAN
     Not documented.

 - Function: logical-host? ((host STRING)) : BOOLEAN
     Not documented.

 - Function: logical-pathname? ((pathname STRING)) : BOOLEAN
     Not documented.

 - Function: translate-logical-pathname ((pathname STRING)) : STRING
     Not documented.

 - Function: directory-separator () : CHARACTER
     Not documented.

 - Function: directory-separator-string () : STRING
     Not documented.


File: manual.info,  Node: Dates and Times,  Next: XML Support,  Prev: Files,  Up: Library Functions

Dates and Times
===============

 - Function: get-current-date-time () : INTEGER INTEGER INTEGER KEYWORD
          INTEGER INTEGER INTEGER INTEGER
     Returns the current time in UTC as multiple values of year month
     day day-of-week hour minute second millisecond.  Currently
     millisecond will always be zero (even in Java where it is
     technically available).

 - Function: get-local-time-zone () : FLOAT
     Returns the current time zone offset from UTC as a float,
     considering the effects of daylight savings time.

 - Function: make-current-date-time () : CALENDAR-DATE
     Create a calendar date with current time and date.

 - Function: make-date-time ((year INTEGER) (month INTEGER)
          (day INTEGER) (hour INTEGER) (minute INTEGER)
          (second INTEGER) (millis INTEGER) (timezone FLOAT)) :
          CALENDAR-DATE
     Create a calendar date with the specified components.  YEAR must be
     the complete year (i.e., a year of 98 is 98 A.D in the 1st
     century).  TIMEZONE is a real number in the range -12.0 to +14.0
     where UTC is zone 0.0;  The number is the number of hours to add
     to UTC to arrive at local time.

 - Function: parse-date-time ((date-time-string STRING) (start INTEGER)
          (end INTEGER) (error-on-mismatch? BOOLEAN)) :
          DECODED-DATE-TIME
     Tries very hard to make sense out of the argument DATE-TIME-STRING
     and returns a time structure if successful.  If not, it returns
     `null'.  If ERROR-ON-MISMATCH? is true, parse-date-time will
     signal an error instead of returning `null'.  Default values are
     00:00:00 local time on the current date

 - Method on CALENDAR-DATE: decode-calendar-date (date
          (timezone FLOAT)) : DECODED-DATE-TIME
     Returns a decoded time object for DATE interpreted in TIMEZONE
     TIMEZONE is the number of hours added to UTC to get local time.
     It is in the range -12.0 to +14.0 where UTC is zone 0.0

 - Method on DECODED-DATE-TIME: encode-calendar-date (time-structure) :
          CALENDAR-DATE
     Returns a calendar date object for TIME-STRUCTURE.

 - ???: calendar-date-to-string
     Not yet implemented.

 - Function: string-to-calendar-date ((input STRING)) : CALENDAR-DATE
     Returns a calendar date object representing the date and time
     parsed from the INPUT string.  If no valid parse is found, `null'
     is returned.

 - ???: relative-date-to-string
     Not yet implemented.

 - Function: compute-calendar-date ((julian-day INTEGER)) : INTEGER
          INTEGER INTEGER KEYWORD
     Returns the YEAR, MONTH, DAY, DAY-OF-WEEK on which the given
     JULIAN-DAY begins at noon.

 - Function: compute-day-of-week ((yyyy INTEGER) (mm INTEGER)
          (dd INTEGER)) : KEYWORD
     Returns the day of the week for yyyy-mm-dd.

 - Function: compute-day-of-week-julian ((julian-day INTEGER)) : KEYWORD
     Returns the day of the week for julian-day

 - Function: compute-julian-day ((yyyy INTEGER) (mm INTEGER)
          (dd INTEGER)) : INTEGER
     Returns the Julian day that starts at noon on yyyy-mm-dd.  YYYY is
     the year.  MM is the month.  DD is the day of month.  Negative
     years are B.C.  Remember there is no year zero.

 - Function: compute-next-moon-phase ((n INTEGER) (phase KEYWORD)) :
          INTEGER FLOAT
     Returns the Julian Day and fraction of day of the Nth occurence
     since January 1, 1900 of moon PHASE.  PHASE is one of :NEW-MOON,
     :FIRST-QUARTER, :FULL-MOON, :LAST-QUARTER

 - Function: decode-time-in-millis ((time INTEGER)) : INTEGER INTEGER
          INTEGER INTEGER
     Returns multiple values of hours, minutes, seconds, milliseconds
     for TIME specified in milliseconds.

 - Function: julian-day-to-modified-julian-day ((julian-day INTEGER)) :
          INTEGER
     Returns the modified Julian day during which JULIAN-DAYstarts at
     noon.

 - Function: modified-julian-day-to-julian-day
          ((modified-julian-day INTEGER)) : INTEGER
     Returns the modified Julian day during which `julian-day'starts at
     noon.

 - Function: time-add ((t1 DATE-TIME-OBJECT) (t2 DATE-TIME-OBJECT)) :
          DATE-TIME-OBJECT
     Add T1 to T2.  If one of T1 or T2 is a calendar date, then the
     result is a calendar date.  If both T1 and T2 are relative dates,
     then the result is a relative date.  T1 and T2 cannot both be
     calendar dates.

 - Function: time-divide ((t1 TIME-DURATION) (t2 OBJECT)) : OBJECT
     Divides the relative date T1 by T2.  T2 must be either a relative
     date or a wrapped number.  If T2 is a relative date, then the
     return value will be a wrapped float.  If T2 is a wrapped number,
     then the reutrn value will be a relative date.

 - Function: time-multiply ((t1 OBJECT) (t2 OBJECT)) : TIME-DURATION
     Multiplies a relative date by a wrapped number.  One of T1 or T2
     must be a relative date and the other a wrapped number.

 - Function: time-subtract ((t1 DATE-TIME-OBJECT)
          (t2 DATE-TIME-OBJECT)) : DATE-TIME-OBJECT
     Subtract T2 from T1.  If T1 is a calendar date, then T2 can be
     either a calendar date (in which case the return value is a
     relative date) or it can be a relative date (in which case the
     return value is a calendar date).  If T1 is a relative date, then
     T2 must also be a relative date and a relative date is returned.

 - Function: get-ticktock () : TICKTOCK
     Return the current CPU time.  If the current OS/Language
     combination does not support measuring of CPU time, return real
     time instead.  Use `ticktock-difference' to measure the time
     difference between values returned by this function.  This is an
     attempt to provide some platform independent support to measure
     (at least approximately) consumed CPU time.

 - Function: ticktock-difference ((t1 TICKTOCK) (t2 TICKTOCK)) : FLOAT
     The difference in two TICKTOCK time values in seconds where T1 is
     the earlier time.  The resolution is implementation dependent but
     will normally be some fractional value of a second.

 - Function: ticktock-resolution () : FLOAT
     The minimum theoretically detectable resolution of the difference
     in two TICKTOCK time values in seconds.  This resolution is
     implementation dependent.  It may also not be realizable in
     practice, since the timing grain size may be larger than this
     resolution.

 - Function: sleep ((seconds FLOAT)) :
     The program will sleep for the indicated number of seconds.
     Fractional values are allowed, but the results are implementation
     dependent: Common Lisp uses the fractions natively, Java with a
     resolution of 0.001, and C++ can only use integral values.


File: manual.info,  Node: XML Support,  Next: Miscellaneous,  Prev: Dates and Times,  Up: Library Functions

XML Support
===========

 - Function: make-xml-element ((name STRING) (namespace-name STRING)
          (namespace STRING)) : XML-ELEMENT
     Creates and interns an XML element object NAME using NAMESPACE-NAME
     to refer to  NAMESPACE.  If NAMESPACE is `null', then the element
     will be interned in the null namespace.   NAMESPACE must otherwise
     be a URI.

 - Function: make-xml-global-attribute ((name STRING)
          (namespace-name STRING) (namespace STRING)) :
          XML-GLOBAL-ATTRIBUTE
     Creates and interns an XML global attribute object with NAME using
     NAMESPACE-NAME to refer to  NAMESPACE.  NAMESPACEmust be a URI.

 - Function: make-xml-local-attribute ((name STRING)
          (element XML-ELEMENT)) : XML-LOCAL-ATTRIBUTE
     Make an XML-LOCAL-ATTRIBUTE named NAME associated with ELEMENT

 - Function: get-xml-tag ((expression CONS)) : XML-ELEMENT
     Return the XML tag object of an XML EXPRESSION.

 - Function: get-xml-attributes ((expression CONS)) : CONS
     Return the list of attributes of an XML EXPRESSION (may be empty).

 - Function: get-xml-content ((expression CONS)) : CONS
     Return the list of content elements of an XML EXPRESSION (may be
     empty).

 - Function: get-xml-cdata-content ((form CONS)) : STRING
     Return the CDATA content of a CDATA FORM.  Does NOT make sure that
     FORM actually is a CDATA form, so bad things can happen if it is
     given wrong input.

 - Function: xml-declaration? ((item OBJECT)) : BOOLEAN
     Return `true' if ITEM is an XML declaration object

 - Function: xml-element? ((item OBJECT)) : BOOLEAN
     Return `true' if ITEM is an XML element object

 - Function: xml-attribute? ((item OBJECT)) : BOOLEAN
     Return `true' if ITEM is an XML attribute object

 - Function: xml-cdata? ((item OBJECT)) : BOOLEAN
     Return `true' if ITEM is an XML CDATA tag object

 - Function: xml-cdata-form? ((form OBJECT)) : BOOLEAN
     Return `true' if FORM is a CONS headed by a CDATA tag

 - Method on XML-ELEMENT: xml-element-match? (tag (name STRING)
          (namespace STRING)) : BOOLEAN
     Returns `true' if TAG is an XML element with the name NAME in
     namespace NAMESPACE.  Note that NAMESPACE is the full URI, not an
     abbreviation.  Also, NAMESPACE may be `null', in which case TAG
     must not have a namespace associated with it.

 - Method on XML-ATTRIBUTE: xml-attribute-match? (attribute
          (name STRING) (namespace STRING)) : BOOLEAN
     Return `true' if ATTRIBUTE is an XML attribute with name NAME in
     namespace NAMESPACE.  Note that NAMESPACE is the full URI, not an
     abbreviation.  Also, NAMESPACE may be `null', in which case
     ATTRIBUTE must not have a namespace associated with it.

 - Method on XML-GLOBAL-ATTRIBUTE: xml-attribute-match? (attribute
          (name STRING) (namespace STRING)) : BOOLEAN
     Return `true' if ATTRIBUTE is a global  XML attribute with name
     NAME in namespace NAMESPACE.  Note that NAMESPACE is the full URI,
     not an abbreviation.  Also, NAMESPACE may be `null', in which case
     ATTRIBUTE must not have a namespace associated with it.

 - Method on XML-LOCAL-ATTRIBUTE: xml-attribute-match? (attribute
          (name STRING) (namespace STRING)) : BOOLEAN
     Return `true' if ATTRIBUTE is a local XML attribute with name NAME.
     Note that NAMESPACE must be `null' and that the ATTRIBUTEs parent
     element element is not considered by the match.  To take the
     parent element into account use `xml-local-attribute-match?'.

 - Function: xml-local-attribute-match?
          ((attribute XML-LOCAL-ATTRIBUTE) (name STRING)
          (element-name STRING) (element-namespace STRING)) : BOOLEAN
     Return true if ATTRIBUTE is a local attribute with NAME and whose
     parent element matches ELEMENT-NAME and ELEMENT-NAMESPACE.

 - Function: xml-lookup-attribute ((attributes CONS) (name STRING)
          (namespace STRING)) : STRING
     Find the XML attribute in ATTRIBUTES with NAME and NAMESPACE and
     return its value.  Note that it is assumed that all ATTRIBUTES
     come from the same known tag, hence, the parent elements of any
     local attributes are not considered by the lookup.

 - Macro: xml-tag-case ((item OBJECT) &body (clauses CONS)) : OBJECT
     A case form for matching ITEM against XML element tags.  Each
     element of CLAUSES should be a clause with the form   ("tagname"
     ...)     or   (("tagname" "namespace-uri") ...)  The clause heads
     can optionally be symbols instead of strings.  The key forms the
     parameters to the method `xml-element-match?', with a missing
     namespace argument passed as NULL.

     The namespace argument will be evaluated, so one can use bound
     variables in place of a fixed string.   As a special case, if the
     namespace argument is :ANY, then the test will be done for a match
     on the tag name alone.

 - Function: read-xml-expression ((stream INPUT-STREAM)
          (start-tag OBJECT)) : OBJECT BOOLEAN
     Read one balanced XML expression from STREAM and return its
     s-expression representation (see
     `xml-token-list-to-s-expression').  If `startTagName' is
     non-`null', skip all tags until a start tag matching START-TAG is
     encountered.  XML namespaces are ignored for outside of the start
     tag.  Use s-expression representation to specify START-TAG, e.g.,
     `(KIF (:version "1.0"))'.  The tag can be an XML element object, a
     symbol, a string or a cons.  If the tag is a cons the first
     element can also be (name namespace) pair.

     Return `true' as the second value on EOF.

     CHANGE WARNING:  It is anticipated that this function will change
     to  a) Properly take XML namespaces into account and  b) require
     XML element objects instead of strings as the second argument.
     This change will not be backwards-compatible.

 - Function: xml-expressions ((stream INPUT-STREAM) (regionTag OBJECT))
          : XML-EXPRESSION-ITERATOR
     Return an XML-expression-iterator (which see) reading from STREAM.
     REGIONTAG can be used to define delimited regions from which
     expressions should be considered. Use s-expression representation
     to specify REGIONTAG, e.g., `(KIF (:version "1.0"))'.  The tag can
     be an XML element object, a symbol, a string or a cons.  If the
     tag is a cons the first element can also be (name namespace) pair.

 - Function: print-xml-expression ((stream OUTPUT-STREAM)
          (xml-expression CONS) (indent INTEGER)) :
     Prints XML-EXPRESSION on STREAM.  Indentation begins with the
     value of INDENT.  If this is the `null' integer, no indentation is
     performed.  Otherwise it should normally be specified as 0 (zero)
     for top-level calls.

     It is assumed that the XML-EXPRESSION is a well-formed CONS-list
     representation of an XML  form.  It expects a form like that form
     returned by `read-XML-expression'.

     Also handles a list of xml forms such as that returned by
     `XML-expressions'.  In that case, each of the forms is indented by
     INDENT spaces.

 - Function: reset-xml-hash-tables () :
     Resets Hashtables used for interning XML elements and global
     attribute objects.  This will allow garbage collection of
     no-longer used objects, but will also mean that newly parsed xml
     elements and global attributes will not be eq? to already existing
     ones with the same name.

