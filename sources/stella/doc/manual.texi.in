\input texinfo.tex @c -*-texinfo-*-

#$(util/texinfo-insert-preamble)

@c Version: manual.texi.in,v 1.23 2006/05/21 07:23:37 hans Exp

@setfilename manual.info

@settitle STELLA Manual

@iftex
@finalout
@end iftex

@ifinfo
This file documents the STELLA programming language.

Copyright (C) 2006
University of Southern California, Information Sciences Institute
4676 Admiralty Way
Marina Del Rey, CA 90292

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission notice
identical to this one except for the removal of this paragraph (this
paragraph not being relevant to the printed manual).

@end ignore
@end ifinfo

@titlepage
@sp 6
@center @titlefont{STELLA Manual}
@sp 1
@center Painless symbolic programming with
@center delivery in Common-Lisp, C++ and Java
@sp 3
@center 1.23
@sp 1
@center This manual describes
@center STELLA 3.4 or later.
@sp 3
@center @strong{The STELLA Development Team}
@ifhtml
<br>
<blockquote>
@end ifhtml
@center Hans Chalupsky
@ifhtml
<br>
@end ifhtml
@center Robert M. MacGregor
@ifhtml
<br>
@end ifhtml
@center Thomas A. Russ
@ifhtml
<br>
@end ifhtml
@center @{hans,tar@}@@isi.edu
@ifhtml
</blockquote>
@end ifhtml
@sp 1
@center USC Information Sciences Institute
@page

@vskip 0pt plus 1fill
Copyright (C) 2006
University of Southern California, Information Sciences Institute@*
4676 Admiralty Way, Marina Del Rey, CA 90292

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission notice
identical to this one except for the removal of this paragraph (this
paragraph not being relevant to the printed manual).

@end ignore
@end titlepage

@c ===========================================================================

@contents

@c ===========================================================================

@ifinfo
@node Top, Overview, (dir), (dir)
@comment  node-name,  next,  previous,  up
@ichapter STELLA Manual

This document describes the STELLA programming language.  STELLA stands
for Strongly-TypEd, Lisp-like LAnguage.  It is an object-oriented
language that strongly supports symbolic programming tasks.  STELLA
programs can currently be translated into Common-Lisp, C++ and Java.
STELLA programming is best done in an Emacs-based Lisp development
environment, which leverages off Lisp's rapid prototyping and
incremental development features.  Once a STELLA program has matured, it
can be translated into C++ or Java to gain extra efficiency, to deliver
it as a stand-alone application, or to link it with other programs.

@end ifinfo

@c ===========================================================================

@menu
* Overview::                    
* Installation::                
* The STELLA Language::         
* Programming in STELLA::       
* Library Classes::             
* Library Functions::           
* Function Index::              
* Variable Index::              
* Concept Index::               
@end menu

@node  Overview, Installation, Top, Top
@comment  node-name,  next,  previous,  up
@chapter Introduction

This document describes the STELLA programming language.  STELLA stands
for Strongly-TypEd, Lisp-like LAnguage.  It is an object-oriented
language that strongly supports symbolic programming tasks.  We
developed it, since none of the currently ``healthy'' languages such as
C++ or Java adequately support symbolic programming.  While Common-Lisp
would probably still be today's language of choice for many symbolic
programming applications, its dwindling vendor support and user base
make it more and more difficult to justify its use.

When we started the development of the PowerLoom knowledge
representation system in 1995 we were faced with exactly this problem.
PowerLoom had to be delivered in C++, but it was simply incoceivable to
write such a large symbolic programming application directly in C++.
The solution was to invent a new programming language we called STELLA
and write PowerLoom in STELLA instead.

STELLA is a strongly typed, object-oriented, Lisp-like language
specifically geared to support artificial intelligence applications.
STELLA preserves those features of Common Lisp deemed essential for
symbolic programming such as built-in support for dynamic data
structures, heterogeneous collections, first-class symbols, powerful
iteration constructs, name spaces, an object-oriented type system with a
simple meta-object protocol, exception handling, language extensibility
through macros and automatic memory management.  Maybe the biggest
difference between STELLA and Common Lisp is that STELLA is strongly
typed.  All externally visible interfaces such as slots, function
parameters and return values, etc. have to be explicitly typed.
Internal objects such as local variables, however, are mostly typed
implicitly supported by type inference.  This in conjunction with a
powerful type coercion mechanism significantly reduces the number of
explicit type information that needs to be supplied by the programmer
compared to languages such as C++ or Java.

STELLA programs are first translated into a target language such as
Common Lisp, C++ or Java, and then compiled with the native target
language compiler to generate executable code. The language constructs
of STELLA are restricted to those that can be translated fairly directly
into native constructs of the intended target languages.  This allows
STELLA to be translated into efficient, conventional and readable Lisp,
C++ and Java code.  The resulting native code can be understood and to
some extent even maintained by programmers who don't know STELLA, and it
can easily be interfaced with other programs not written in STELLA.

As of Fall 2000, we have programmed approximately 100,000 lines of
STELLA code - about 50% for the STELLA kernel itself and the other 50%
for the PowerLoom knowledge representation system and related
systems. Our subjective experience has been that it is only slightly
more difficult to write and debug a STELLA program than a Lisp program,
and that the inconvenience of having to supply some type information is
much outweighed by the benefits such as catching many errors during
compile time instead of at run time.

The biggest benefit, however, seems to be that we can still leverage all
the incremental code development benefits of Lisp, since we use the
Common Lisp-based version of STELLA for prototyping.  This allows us to
incrementally define and redefine functions, methods and classes and to
inspect, debug and fix incorrect code on the fly.  Even the most
sophisticated C++ or Java IDE's don't yet seem to support this fully
incremental development style, i.e., a change in a class (every change
in Java is a change to a class) still requires recompilation and restart
of the application.  But it is the restart that can be the most time
consuming if one debugs a complex application that takes a significant
time to reach a certain state!

Once a STELLA program has matured, it can be translated into C++ or Java
to gain extra efficiency, to deliver it as a stand-alone application, or
to link it with other programs.

@c ---------------------------------------------------------------------------

@menu
* Credits and History::         
@end menu

@node Credits and History,  , Overview, Overview
@section Credits and History

Bob MacGregor invented STELLA in 1995 to implement the PowerLoom
knowledge representation system.  He wrote most of the first Lisp-based
kernel system of STELLA and still occasionally writes extensions or
provides fixes.  Today he is primarily a STELLA user writing his own
applications.

Hans Chalupsky completed the first full STELLA bootstrap (STELLA
translating itself) in Spring 1996, and then went on to deal with all
the changes necessary to handle the many C++ and Java idiosyncrasies
that were discovered when the first versions of these translators came
online.  He is currently one of the principal maintainers of STELLA
supporting the STELLA code analyzer and the Lisp and C++ translators.

Eric Melz wrote the first version of the C++ translator under very
trying circumstances (i.e., at a stage where the STELLA language
changed under him on a daily basis).  He got the first C++ version of
STELLA running in the Fall of 1996.

Tom Russ wrote the Java translator and got the first Java version of
STELLA running in Spring 1999.  He is currently one of the principal
maintainers of STELLA supporting the STELLA code analyzer and the Lisp
and Java translators.  He is also still active writing occasional
extensions such as the STELLA XML parser.

@c ===========================================================================

@node Installation, The STELLA Language, Overview, Top
@chapter Installation

@c ---------------------------------------------------------------------------

@menu
* System Requirements::         
* Unpacking the Sources::       
* Lisp Installation::           
* C++ Installation::            
* Java Installation::           
* X/Emacs Setup::               
* Removing Unneeded Files::     
@end menu

@node System Requirements, Unpacking the Sources, Installation, Installation
@section System Requirements

To install and use STELLA you'll approximately need the following amounts of
disk space:

@itemize
@item 
8 MB for the tar-red or zip-ped archive file

@item 
35 MB for the untarred sources, tanslations, compiled Java files and
documentation

@item 
8 MB to compile a Lisp version

@item 
11 MB to compile the C++ version (without -g)

@item 
3 MB to compile the Java version (already included)

@end itemize

This means that you will need approximately 55 MB to work with one Lisp,
one C++ and one Java version of STELLA in parallel.  If you also want to
experiment with the Lisp translation variant that uses structures
instead of CLOS instances to implement STELLA objects, then you will
need an extra 8 MB to compile that.

The full STELLA development tree is quite large, since for every STELLA
source file there are three to four translated versions and as many
compiled versions thereof.  The actual STELLA libraries that you have to
ship with an application, however, are quite small.  For example, the
Java jar file @file{stella.jar} is only about 1.3 MB in size.  The
dynamic C++ library @file{libstella.so} compiled on a Linux platform is
about 4 MB.  Additionally, if you don't need all the different
translations of STELLA, you can delete some of the versions to keep your
development tree smaller (@xref{Removing Unneeded Files}).

To run the Lisp version of STELLA you need an ANSI Common-Lisp (or at
least one that supports CLOS and logical pathnames).  We have
successfully tested STELLA with Allegro-CL 4.2, 4.3, 5.0, 6.0 and 7.0,
Macintosh MCL 3.0, 4.0 and 5.1, OpenMCL 1.0, SBCL 0.9.4, CMUCL 19c,
LispWorks 4.4.6, CLisp 2.37, Lucid CL 4.1 (plus the necessary ANSI
extensions and Mark Kantrowitz's logical pathnames implementation) and
various others.  Our main development platform is Allegro CL running
under Sun Solaris and Linux, so, the closer your environment is to ours,
the higher are the chances that everything will work right out of the
box.  Lisp development under Windows should also be no problem.

To run the C++ version of STELLA you need a C++ compiler such as g++
that supports templates and exception handling.  We have successfully
compiled and run STELLA with g++ 3.2 and later under Linux Redhat 8.0 &
9.0, SunOS and MacOS X, and with CygWin 5.0 and MinGW 5.0 under Windows
2000 and XP.  Both CygWin and MinGW provide a GNU Unix environment, but
MinGW can generate Windows executables that are fully standalone.  We've
also managed to compile STELLA under MS Visual C++, however, we never
got the Boehm garbage collector to work.  The GC claims to be very
portable, so this should be solvable for somebody with good knowledge of
MS Visual C++.

For the Java version you will need Java JDK 1.2 or later. To get
reasonable performance, you should use J2SDK 1.4 or 1.5.  We've run the
Java version of STELLA on a variety of platforms without any problems.

Any one of the Lisp, C++ or Java implementations of STELLA can be used
to develop your own STELLA code and translate it into all three languages,
but the most convenient development environment is the one based on
Lisp.  If you use the C++ or Java version, translating and using your
own STELLA macros is possible but not yet very well supported.

@c ---------------------------------------------------------------------------

@node Unpacking the Sources, Lisp Installation, System Requirements, Installation
@section Unpacking the Sources

Uncompress and untar the file @file{stella-X.Y.Z.tar.gz} (or unzip the
file @file{stella-X.Y.Z.zip}) in the parent directory of where you want
to install STELLA (`X.Y.Z' are place holders for the actual version
numbers).  This will create the STELLA tree in the directory
@file{stella-X.Y.Z/}.  All pathnames mentioned below will be relative to that
directory which we will usually refer to as the "STELLA directory".

@c ---------------------------------------------------------------------------

@node Lisp Installation, C++ Installation, Unpacking the Sources, Installation
@section Lisp Installation

To install the Lisp version startup Lisp and load the file
@file{load-stella.lisp} with:

@example
(CL:load "load-stella.lisp")
@end example

The first time around this will compile all Lisp-translated STELLA files
before they are loaded.  During subsequent sessions the compiled files
will be loaded right away.

If you want to use the version that uses Lisp structs instead of CLOS
objects to implement STELLA objects do the following:

@example
(CL:setq cl-user::*load-cl-struct-stella?* CL:t)
(CL:load "load-stella.lisp")
@end example

Alternatively, you can edit the initial value of the variable
@code{*load-cl-struct-stella?*} in the file @file{load-stella.lisp}.
Using structs instead of CLOS objects greatly improves slot access
speed, however, it may cause problems with incremental re-definition
of STELLA classes.  It is therefore recommended to only use this for
systems that are in or near the production stage.

Once all the files are loaded, you should see a message like this:

@example
Initializing STELLA...
STELLA 3.4.0 loaded.
Type `(in-package "STELLA")' to execute STELLA commands.
USER(2): 
@end example

To reduce startup time, you might want to create a Lisp image that has
all of STELLA preloaded.

Now type
@example
(in-package "STELLA")
@end example

to enter the @code{STELLA} Lisp package where all the STELLA code resides.

@strong{IMPORTANT}: All unqualified Lisp symbols in this document are
assumed to be in the @code{STELLA} Lisp package.  Moreover, the
@code{STELLA} package does @strong{NOT} inherit anything from the
@code{COMMON-LISP} package (see the file
@file{sources/stella/cl-lib/cl-setup.lisp} for the few exceptions),
hence, you have to explicitly qualify every Lisp symbol you want to use
with @code{CL:}.  For example, to get the result of the previous evaluation you
have to type @code{CL:*} instead of @code{*}.

@c ---------------------------------------------------------------------------

@node C++ Installation, Java Installation, Lisp Installation, Installation
@section C++ Installation

To compile the C++ version of STELLA change to the native C++ directory
and run @code{make}:

@example
% cd native/cpp/stella
% make
@end example

This will compile all STELLA files, the garbage collector and generate a
static or dynamic @file{libstella} library file in the directory
@file{native/cpp/lib} which can later be linked with your own
C++-translated STELLA (or other) code.  To test whether the compilation
was successful you can run STELLA from the top-level STELLA directory
using the @code{stella} script (or @code{stella.bat} under a Windows
command prompt):

@example
% stella c++
Running C++ version of STELLA...
Welcome to STELLA 3.4.0
Running kernel startup code...
Initializing symbol tables...
Initializing quoted constants...
Initializing global variables...
Creating class objects...
Finalizing classes...
Creating method objects...
Finalizing methods...
Running non-phased startup code...
Starting up translators...
Bye!
@end example

This will simply run various STELLA startup code and exit.  @xref{Hello
World in C++}, to see how you can use the STELLA C++ executable to
translate STELLA code.  The @code{c++} argument tells the script to run
the C++ version of STELLA.  If the argument is omitted and the C++
version is installed, it will be run automatically.  Otherwise, the Java
version will be run.

@c ---------------------------------------------------------------------------

@node Java Installation, X/Emacs Setup, C++ Installation, Installation
@section Java Installation

Nothing needs to be done to install the Java version.  Since Java class
files are platform independent, they are already shipped with the STELLA
distribution and can be found in the directory @file{native/java} and
its subdirectories.  Additionally, they have been collected into the
file @file{native/java/lib/stella.jar}.  To try out the Java version of
STELLA run the @code{stella} script in the STELLA directory:

@example
% stella java
Running Java version of STELLA...
Welcome to STELLA 3.4.0
Running kernel startup code...
Initializing symbol tables...
Initializing quoted constants...
Initializing global variables...
Creating class objects...
Finalizing classes...
Creating method objects...
Finalizing methods...
Running non-phased startup code...
Starting up translators...
Bye!
@end example

Similar to the C++ executable, this will simply run various STELLA
startup code and exit.  @xref{Hello World in Java}, to see how you can
use the STELLA Java executable to translate STELLA code.

@c ---------------------------------------------------------------------------

@node X/Emacs Setup, Removing Unneeded Files, Java Installation, Installation
@section X/Emacs Setup

STELLA development is very similar to Lisp development, and it is best
done in an X/Emacs-based Lisp development environment such as the
Allegro-CL Emacs interface plus Allegro Composer, or ILISP.  If you do
use X/Emacs with the Allegro CL interface, add the following to your
@file{.emacs} or @file{.xemacs/init.el} file:

@example
(setq auto-mode-alist
      (cons '("\\.ste$" . fi:common-lisp-mode) auto-mode-alist))
@end example

If you are using the Allegro CL interface, you might want to install the
file @file{emacs/fi-stella.el}, since it sets up proper indentation for
STELLA code and makes looking up STELLA definitions via the @kbd{C-c .} 
or @kbd{M-.} commands work better.  Look at the file
@file{emacs/fi-stella.el} for specific installation instructions.

@c ---------------------------------------------------------------------------

@node Removing Unneeded Files,  , X/Emacs Setup, Installation
@section Removing Unneeded Files

To save disk space you can remove files that you don't need.  For
example, if you are not interested in the C++ version of STELLA, you can
delete the directory @file{native/cpp}.  Similarly, you can remove
@file{native/java} to eliminate all Java-related files.  You could do
the same thing for the Lisp directory @file{native/lisp}, but (in our
opinion) that would make it less convenient for you to develop new STELLA
code.  Finally, if you don't need any of the STELLA sources, you can
delete the directory @file{sources/stella}.  If you don't need local
copies of the STELLA documentation, you can delete parts or all of the
@file{sources/stella/doc} directory.

@c ===========================================================================

@node The STELLA Language, Programming in STELLA, Installation, Top
@chapter The STELLA Language

@menu
* Language Overview::           
* Basic Data Types::            
* Control Structure::           
* Functions::                   
* Classes::                     
* Methods::                     
* Macros::                      
* Modules::                     
@end menu

@node Language Overview, Basic Data Types, The STELLA Language, The STELLA Language
@section Language Overview

STELLA is a strongly typed, object-oriented, Lisp-like language.  STELLA
programs are first translated into either Common Lisp, C++, or Java, and then
compiled with any conventional compiler for the chosen target language to
generate executable code.  Over 95% of the STELLA system is written in STELLA
itself, the rest is written in target-language-specific native code.

The design of STELLA borrows from a variety of programming languages, most
prominently from Common Lisp, and to a lesser degree from other
object-oriented languages such as Eiffel, Sather, and Dylan.  Since STELLA has
to be translatable into C++ and Java, various restrictions of these languages
also influenced its design.

In the following, we assume that the reader is familiar with basic Common Lisp
concepts, and has at least some familiarity with C++ or Java.  Let us start
with a cursory overview of STELLA's main features:

@strong{Syntax:} STELLA uses a parenthesized, uniform expression syntax
similar to Lisp.  Most definitional constructs and control structures
are similar to their Common Lisp analogues with variations to support
types.

@strong{Type system:} STELLA is strongly typed and supports efficient
static compilation similar to C++.  Types are required for the arguments
and return values of functions and methods, for global variables, and
for slot definitions.  Local, lexically scoped variables can be typed
implicitly by relying on type inference.

@strong{Object system:} Types are organized into a single inheritance
class hierarchy.  Restricted multiple inheritance is allowed via mixin
classes.  Dynamic method dispatch is based on the runtime type of the
first argument (similar to C++ and Java).  Slots can be static (native)
or dynamic.  Dynamic slots can be defined at runtime and do not occupy
any space until they are filled.  Slots can have both initial and
default values, and demons can be triggered by slot accesses.  A
meta-object protocol allows the control of object creation,
initialization, termination, and destruction.

@strong{Control structure:} Functions and methods are distinguished.
They can have multiple (zero or more) return values and a variable
number of arguments.  Lisp-style macros are supported to facilitate
syntax extensions.  Expressions and statements are distinguished.  Local
variables are lexically scoped, but dynamically scoped variables
(specials) are also supported.  STELLA has an elegant, uniform, and
efficient iteration mechanism plus a built-in protocol for iterators.
An exception mechanism can be used for error handling and non-local
exits.

@strong{Symbolic programming:} Symbols are first-class objects, and
extensive support for dynamic datatypes such as cons-trees, lists, sets,
association lists, hash tables, extensible vectors, etc., is available.
A backquote mechanism facilitates macro writing and code generation.
Interpreted function call, method call, slot access, and object creation
is supported, and a restricted evaluator is also available.

@strong{Name spaces:} Functions, methods, variables, and classes occupy
separate name spaces (i.e., the same name can be used for a function and
a class).  A hierarchical module system compartmentalizes symbol tables
and supports large-scale programming.

@strong{Memory management:} STELLA relies on automatic memory management
via a garbage collector.  For Lisp and Java the native garbage collector
is used.  For the C++ version of STELLA we use the Boehm- Weiser
conservative garbage collector with good results.  Various built-in
support for explicit memory management is also available.

The Common Lisp features most prominently absent from STELLA are anonymous
functions via lambda abstraction, lexical closures, multi-methods,
full-fledged eval (a restricted evaluator is available), optional and keyword
arguments, and a modifiable readtable.  STELLA does also not allow dynamic
re/definition of functions and classes, even though the Lisp-based development
environment provides this facility (similar to Dylan).  The main influences of
C++ and Java onto STELLA are the strong typing, limited multiple inheritance,
first-argument polymorphism, and the distinction between statements and
expressions.

@c ---------------------------------------------------------------------------
@node Basic Data Types, Control Structure, Language Overview, The STELLA Language
@section Basic Data Types (tbw)
To be written.

@c ---------------------------------------------------------------------------

@node Control Structure, Functions, Basic Data Types, The STELLA Language
@section Control Structure (tbc)
To be completed.

@menu
* Conditionals::                
@end menu

@node Conditionals,  , Control Structure, Control Structure
@subsection Conditionals

STELLA conditionals are very similar to those found in Common-Lisp.
The main difference is that most STELLA conditionals are statements and
therefore do not return a value.  For this reason, a C++-style
@code{choose} directive has been added to the language to allow value
conditionalization based on a boolean expression.

@deffn Statement if condition then-statement else-statement
Evaluate the boolean expression @var{condition}.  If the result is true
execute @var{then-statement}, otherwise, execute @var{else-statement}.
Note that unlike the Common-Lisp version of @code{if} the
@var{else-statement} is not optional in STELLA.  Example:

@example
(if (> x y)
    (print "x is greater than y" EOL)
  (print "x is less than or equal to y" EOL))
@end example
@end deffn

@deffn Statement when condition statement@dots{}
Evaluate the boolean expression @var{condition}.  Only if the result is
true execute the @var{statement'}s in the body.  Example:

@example
(when (symbol? x)
  (print "x is a symbol, ")
  (print "its name is " (symbol-name (cast x SYMBOL)) EOL))
@end example
@end deffn

@deffn Statement unless condition statement@dots{}
Evaluate the boolean expression @var{condition}.  Only if the result is
false execute the @var{statement'}s in the body.  Therefore,
@code{(unless @var{test} @dots{})} is equivalent to @code{(when (not
@var{test}) @dots{})}.  Example:

@example
(unless (symbol? x)
  (print "x is not a symbol, ")
  (print "hence, its name is unknown" EOL))
@end example
@end deffn

@deffn Statement cond clause@dots{}
@code{cond} is a conditional with an arbitrary number of conditions each
represented by a @var{clause}.  Each @code{cond} clause has to be of the
following form:
@example
(@var{condition} @var{statement}@dots{})
@end example
The first @var{clause} whose @var{condition} evaluates to true will be
selected and its @var{statement'}s will be executed.  Each clause can
have 0 or more statements.  The special condition @code{otherwise}
always evaluates to true and can be used for the catch-all case.
Example:

@example
(cond ((symbol? x)
       (print "x is a symbol" EOL))
      ((cons? x)
       (print "x is a cons" EOL))
      (otherwise
       (print "x is an object" EOL)))
@end example
@end deffn

@deffn Expression choose condition true-expression false-expression
Evaluate the boolean expression @var{condition}.  If the result is true
return the value of @var{true-expression}, otherwise, return the value
of @var{false-expression}.  STELLA computes the most specific common
supertype of @var{true-expression} and @var{false-expression} and uses
that as the type returned by the @code{choose} expression.  If no such
type exists, a translation error will be signaled.  Example:

@example
(setq face (choose happy? :smile :frown))
@end example
@end deffn

@deffn Statement case expression clause@dots{}
Each @code{case} clause has to be of one of
the following forms:

@example
(@var{key} @var{statement}@dots{})
((@var{key}@dots{}) @var{statement}@dots{})
@end example

@code{case} selects the first @var{clause} whose @var{key} (or one of
the listed @var{key'}s) matches the result of @var{expression} and
executes the clause's @var{statement'}s.  Each @code{case} @var{key} has
to be a constant such as a number, character, string, symbol, keyword or
surrogate.  Keys are compared with @code{eql?} (or @code{string-eql?} 
for strings).  All keys in a @code{case} statement have to be of the
same type.  The special key @code{otherwise} can be used to catch
everything.  It is a run-time error if no clause with a matching key
exists.  Therefore, a STELLA @code{case} without an @code{otherwise}
clause corresponds to a Common Lisp @code{ecase}.  An empty
@code{otherwise} clause can always be specified via @code{(otherwise
NULL)}.  Example:

@example
(case car-make
  ("Yugo" 
   (setq price :cheap))
  ("VW"   
   (setq price :medium))
  (("Ferrari" "Rolls Royce")
   (setq price :expensive))
  (otherwise 
   (setq price :unknown)))
@end example
@end deffn

@deffn Statement typecase expression clause@dots{}
Each @code{typecase} clause has to be of one of
the following forms:

@example
(@var{type} @var{statement}@dots{})
((@var{type}@dots{}) @var{statement}@dots{})
@end example

@code{typecase} selects the first @var{clause} whose @var{type} (or one
of the listed @var{type'}s) equals or is a supertype of the run-time
type of the result of @var{expression} and then executes the clause's
@var{statement'}s.  Therefore, @code{typecase} can be used to implement
a type dispatch for cases where the run-time type of an expression can
be different from the static type known at translation time.  Currently,
the static type of @var{expression} is required to be a subtype of
@code{OBJECT}.

Each @var{type} expression has to be a symbol describing a simple type
(i.e., parametric or anchored types are not allowed).  Similar to
@code{case}, the special key @code{otherwise} can be used to catch
everything.  It is a run-time error if no clause with a matching type
exists.  Therefore, a STELLA @code{typecase} without an @code{otherwise}
clause corresponds to a Common Lisp @code{etypecase}.  An empty
@code{otherwise} clause can always be specified via @code{(otherwise
NULL)}.  @code{typecase} does allow the value of @var{expression} to be
undefined, in which case the @code{otherwise} clause is selected.
Example:

@example
(typecase (first list)
  (CONS
   (print "it is a cons"))
  ((SYMBOL KEYWORD)
   (print "it is a symbol"))
  (STANDARD-OBJECT
   (print "it is a regular object"))
  (otherwise NULL))
@end example

Note that in the example above it is important to list
@code{STANDARD-OBJECT} after @code{SYMBOL} and @code{CONS}, since it
subsumes the preceding types.  Otherwise, it would always shadow the
clauses with the more specific types.

The semantics of @code{typecase} is slightly extended for the case where
@var{expression} is a local variable.  In that case each reference to
the variable within a @code{typecase} clause is automatically casted to
the appropriate narrower type.  For example, in the code snippet below
method calls such as @code{first} or slot accesses such as
@code{symbol-name} are translated correctly without needing to
explicitly downcast @code{x} which is assumed to be of type
@code{OBJECT}:

@example
(typecase x
  (CONS
   (print "it is a cons with value " (first x)))
  ((SYMBOL KEYWORD)
   (print "it is a symbol with name " (symbol-name x)))
  (STANDARD-OBJECT
   (print "it is a regular object"))
  (otherwise NULL))
@end example
@end deffn

Since the @code{typecase} @var{expression} has to be a subtype of
@code{OBJECT}, a @code{typecase} cannot be used to test against literal
types such as @code{STRING} or @code{INTEGER}.  If such type names are
encountered as keys in a @code{typecase}, they are automatically
converted to their wrapped version, e.g., @code{STRING-WRAPPER},
@code{INTEGER-WRAPPER}, etc.

@c ---------------------------------------------------------------------------

@node Functions, Classes, Control Structure, The STELLA Language
@section Functions (tbw)
To be written.

@c ---------------------------------------------------------------------------

@node Classes, Methods, Functions, The STELLA Language
@section Classes (tbw)
To be written.

@c ---------------------------------------------------------------------------

@node Methods, Macros, Classes, The STELLA Language
@section Methods (tbw)
To be written.

@c ---------------------------------------------------------------------------

@node Macros, Modules, Methods, The STELLA Language
@section Macros (tbw)
To be written.

@c ---------------------------------------------------------------------------

@node Modules,  , Macros, The STELLA Language
@section Modules (tbw)
To be written.

@c ===========================================================================

@node Programming in STELLA, Library Classes, The STELLA Language, Top
@chapter Programming in STELLA

@menu
* Hello World in STELLA::       
* Incrementally Developing STELLA Code::  
* Performance Hints::           
@end menu

@node Hello World in STELLA, Incrementally Developing STELLA Code, Programming in STELLA, Programming in STELLA
@section Hello World in STELLA

Included with the STELLA distribution is a simple Hello World
application that shows you how to organize your own STELLA code and
build a working STELLA application.  The sources for the Hello World
system consist of the following files:

@example
sources/systems/hello-world-system.ste
sources/hello-world/file-a.ste
sources/hello-world/file-b.ste
@end example

STELLA organizes code modules with a simple system facility.
Translation always operates on a complete system, so you always need to
create a system definition for the STELLA files comprising your
application (somewhat similar to what you would put in a Unix Makefile).

For the Hello World system the system definition already exists and
resides in the file @file{sources/systems/hello-world-system.ste}.  By
default, STELLA looks in the directory @file{sources/systems} to find
the definition of a particular system.  @file{hello-world-system.ste}
defines two things:

(1) The @code{HELLO-WORLD} module which defines a namespace for all
objects in the Hello World systems.  STELLA modules are mapped onto
corresponding native namespace constructs, i.e., Lisp packages, C++
namespaces or Java packages.  The exact mapping for each language can be
defined via the keyword options @code{:lisp-package},
@code{:cpp-package} and @code{:java-package} in the module definition,
for example:

@example
(defmodule "HELLO-WORLD"
  :lisp-package "STELLA"
  :cpp-package "hello_world"
  :java-package "edu.isi.hello_world"
  :uses ("STELLA"))
@end example

The @code{:uses} directive tells STELLA from what other modules this one
inherits.

(2) The actual system definitions defining what source files comprise
the system, and what parent systems this one depends on, plus a variety
of other options:

@example
(defsystem HELLO-WORLD
  :directory "hello-world"
  :required-systems ("stella")
  :cardinal-module "HELLO-WORLD"
  :production-settings (1 0 3 3)
  :development-settings (3 2 3 3)
  :files ("file-a"
          "file-b"))
@end example

@c ---------------------------------------------------------------------------

@menu
* Hello World in Lisp::         
* Hello World in C++::          
* Hello World in Java::         
@end menu

@node Hello World in Lisp, Hello World in C++, Hello World in STELLA, Hello World in STELLA
@subsection Hello World in Lisp

To generate a Lisp translation of Hello World you can use either the
Lisp, C++ or Java version of STELLA.  Before you can translate you have
to make sure the following native directories exist:

@example
native/lisp/hello-world/
bin/acl7.0/hello-world/
@end example

The directory @file{native/lisp/hello-world/} will hold the Lisp
translations of the corresponding STELLA source files.  The directory
@file{bin/acl7.0/hello-world/} will hold the compiled Lisp files if you
are using Allegro CL 7.0.  If you are using a different Lisp, one of the
other binary directories as defined in the top-level file
@file{translations.lisp} will be used.  The directory
@file{bin/lisp/hello-world/} will be used as a fall-back if your version
of Lisp is not yet handled in @file{translations.lisp}.

If you create your own system, you will need to create those directories
by hand (future versions of STELLA might do that automatically).  For
the Hello World system these directories already exist.

To generate a Lisp translation of Hello World using Lisp startup a Lisp
version of STELLA (see @ref{Lisp Installation}).  The following idiom
will then translate the system into Lisp and also Lisp-compile and load it.
The first argument to @code{make-system} is the name of the system, and
the second argument indicates into what language it should be
translated:

@example
STELLA(3): (make-system "hello-world" :common-lisp)
Processing `/tmp/stella-3.1.0/sources/hello-world/file-a.ste':
*** Pass 1, generating objects...
Processing `/tmp/stella-3.1.0/sources/hello-world/file-b.ste':
*** Pass 1, generating objects...
   .........................................
;;; Writing fasl file
;;;   /tmp/stella-3.1.0/native/lisp/bin/acl7.0/hello-world/startup-system.fasl
;;; Fasl write complete
; Fast loading
;    /tmp/stella-3.1.0/native/lisp/bin/acl7.0/hello-world/startup-system.fasl
CL:T
STELLA(4): 
@end example

After the system is loaded you can call its @code{main} function:

@example
STELLA(10): (main)
Hello World A
Hello World B
bye
()
STELLA(11): 
@end example

Using @code{main} in the Lisp version will not always make sense, since
you can call any function directly at the Lisp top level, but both C++
and Java always need a @code{main} function as a top-level entry point.

While this would be somewhat unusual, you could also generate the Lisp
translation using the C++ or Java version of STELLA.  The easiest way to
do that is to run the @code{stella} script in the STELLA directory like
this:

@example
% ./stella -e '(make-system "hello-world" :common-lisp)'
Running C++ version of STELLA...
Welcome to STELLA 3.4.0
Processing `sources/hello-world/file-a.ste':
*** Pass 1, generating objects...
Processing `sources/hello-world/file-b.ste':
*** Pass 1, generating objects...
  ...............................................
Translating `sources/hello-world/file-a.ste' to `Common Lisp'...
Writing `native/lisp/hello-world/file-a.lisp'...
Translating `sources/hello-world/startup-system.ste' to `Common Lisp'...
Writing `native/lisp/hello-world/startup-system.lisp'...
@end example

The @code{-e} command line option is used to evaluate an evaluable
STELLA command.  Conveniently, @code{make-system} is such a command, so
you can supply a @code{make-system} form to the C++ or Java version of
STELLA just as you would do in Lisp.  Note the extra quotes around the
expression to protect the characters from interpretation by the Unix
shell.

To compile and load the translated Lisp files into Lisp you then have to
startup a Lisp version of STELLA and call @code{make-system} again which
now will only compile and load the necessary files, since the
translations have already been generated in the previous step.

@c ---------------------------------------------------------------------------

@node Hello World in C++, Hello World in Java, Hello World in Lisp, Hello World in STELLA
@subsection Hello World in C++

To generate a C++ translation of Hello World you can use either the
Lisp, C++ or Java version of STELLA.  Before you can translate you have
to make sure the following native directory exists:

@example
native/cpp/hello-world/
@end example

The directory @file{native/cpp/hello-world/} will hold the C++
translations of the corresponding STELLA source files.  If you create
your own system, you will need to create this directory by hand (future
versions of STELLA might do that automatically).  For the Hello World
system the directory already exist.

To generate a C++ translation of Hello World using Lisp startup a Lisp
version of STELLA (see @ref{Lisp Installation}).  The following idiom
will then translate the system into C++.  The first argument to
@code{make-system} is the name of the system, and the second argument
indicates into what language it should be translated:

@example
STELLA(4): (make-system "hello-world" :cpp)
Processing `/tmp/stella-3.1.0/sources/hello-world/file-a.ste':
*** Pass 1, generating objects...
Processing `/tmp/stella-3.1.0/sources/hello-world/file-b.ste':
*** Pass 1, generating objects...
  ...............................................
Writing `/tmp/stella-3.1.0/native/cpp/hello-world/file-b.hh'...
Writing `/tmp/stella-3.1.0/native/cpp/hello-world/file-b.cc'...
Translating `/tmp/stella-3.1.0/sources/hello-world/startup-system.ste'.
Writing `/tmp/stella-3.1.0/native/cpp/hello-world/startup-system.hh'...
Writing `/tmp/stella-3.1.0/native/cpp/hello-world/startup-system.cc'...
:VOID
STELLA(5): 
@end example

Alternatively, you can generate the translation using the C++ or Java
version of STELLA.  The easiest way to do that is to run the
@code{stella} script in the STELLA directory like this:

@example
% ./stella -e '(make-system "hello-world" :cpp)'
Running C++ version of STELLA...
Welcome to STELLA 3.4.0
Processing `sources/hello-world/file-a.ste':
*** Pass 1, generating objects...
Processing `sources/hello-world/file-b.ste':
*** Pass 1, generating objects...
  ...............................................
Writing `native/cpp/hello-world/file-b.hh'...
Writing `native/cpp/hello-world/file-b.cc'...
Translating `sources/hello-world/startup-system.ste'.
Writing `native/cpp/hello-world/startup-system.hh'...
Writing `native/cpp/hello-world/startup-system.cc'...
@end example

The @code{-e} command line option is used to evaluate an evaluable
STELLA command.  Conveniently, @code{make-system} is such a command, so
you can supply a @code{make-system} form to the C++ or Java version of
STELLA just as you would do in Lisp.  Note the extra quotes around the
expression to protect the characters from interpretation by the Unix
shell.

Different from Lisp, neither of the above idioms will compile and load
the generated C++ code.  Instead you have to use the Unix @file{make}
facility to compile and link the C++ sources.  First change into the
native @file{hello-world} directory and then call @code{make}
(@strong{important}: the generated Makefiles currently require the GNU
version of @code{make}):

@example
% cd native/cpp/hello-world/
% make
g++ -w -g -O2  -DSTELLA_USE_GC -I../stella/cpp-lib/gc/include \ 
    -c -I.. main.cc
g++ -w -g -O2  -DSTELLA_USE_GC -I../stella/cpp-lib/gc/include \ 
    -c -I.. file-a.cc
g++ -w -g -O2  -DSTELLA_USE_GC -I../stella/cpp-lib/gc/include \ 
    -c -I.. file-b.cc
g++ -w -g -O2  -DSTELLA_USE_GC -I../stella/cpp-lib/gc/include \ 
    -c -I.. startup-system.cc
  ..................................
g++ -dynamic  -L../stella/cpp-lib/gc -Xlinker -rpath -Xlinker \
       '../lib:/tmp/stella-3.1.0/native/cpp/lib' \
       main.o -o hello-world \
       -L../lib -lhello-world -L../lib -lstella -lgc -lm
@end example

The first time around this will also compile the C++ version of STELLA
and the C++ garbage collector and create a STELLA library file.  Future
builds of the Hello World and other systems will use the STELLA library
file directly.  To run the Hello World system simply run the
@file{hello-world} executable that was built in the previous step:

@example
% ./hello-world
Hello World A
Hello World B
bye
@end example

@c ---------------------------------------------------------------------------

@node Hello World in Java,  , Hello World in C++, Hello World in STELLA
@subsection Hello World in Java

To generate a Java translation of Hello World you can use either the
Lisp, C++ or Java version of STELLA.  Before you can translate you have
to make sure the following native directory exists:

@example
native/java/edu/isi/hello-world/
@end example

The directory @file{native/java/edu/isi/hello-world/} will hold the Java
translations of the corresponding STELLA source files.  If you create
your own system, you will need to create this directory by hand (future
versions of STELLA might do that automatically).  For the Hello World
system the directory already exist.

Note that following Java convention we use the package
@code{edu.isi.hello_world} to hold the Hello World system.  This was
specified via the @code{:java-package} option in the definition of the
@code{HELLO-WORLD} module.  Also note that we use @code{hello_world}
instead of @code{hello-world} as the package name, since a dash cannot
legally appear as part of a Java identifier.

To generate a Java translation of Hello World using Lisp startup a Lisp
version of STELLA (see @ref{Lisp Installation}).  The following idiom
will then translate the system into Java.  The first argument to
@code{make-system} is the name of the system, and the second argument
indicates into what language it should be translated:

@example
STELLA(5): (make-system "hello-world" :java)
Processing `/tmp/stella-3.1.0/sources/hello-world/file-a.ste':
*** Pass 1, generating objects...
   ..............................................
Writing `/tmp/stella-3.1.0/native/java/hello_world/Startup_Hello_...
:VOID
STELLA(6): 
@end example

Alternatively, you can generate the translation using the C++ or Java
version of STELLA.  The easiest way to do that is to run the
@code{stella} script in the STELLA directory like this:

@example
% ./stella -e '(make-system "hello-world" :java)'
Running C++ version of STELLA...
Welcome to STELLA 3.4.0
Processing `sources/hello-world/file-a.ste':
*** Pass 1, generating objects...
Processing `sources/hello-world/file-b.ste':
*** Pass 1, generating objects...
  ...............................................
Writing `native/java/edu/isi/hello_world/HelloWorld.java'...
Writing `native/java/edu/isi/hello_world/StartupFileA.java'...
Writing `native/java/edu/isi/hello_world/StartupFileB.java'...
Writing `native/java/edu/isi/hello_world/StartupHelloWorldSystem.java'...
@end example

The @code{-e} command line option is used to evaluate an evaluable
STELLA command.  Conveniently, @code{make-system} is such a command, so
you can supply a @code{make-system} form to the C++ or Java version of
STELLA just as you would do in Lisp.  Note the extra quotes around the
expression to protect the characters from interpretation by the Unix
shell.

Different from Lisp, neither of the above idioms will compile and load
the generated C++ code.  Instead you have to use the Java compiler to
compile and Java to run the compiled Java sources.  First change into
the top-level native Java directory @file{native/java} and then compile
and run the Hello World system like this:

@example
% cd native/java/
% javac edu/isi/hello_world/*.java
% java edu.isi.hello_world.HelloWorld
Hello World A
Hello World B
bye
@end example

It is not necessary to Java-compile STELLA first, since STELLA already
ships with a Java compilation of the STELLA system.

@c ---------------------------------------------------------------------------

@node Incrementally Developing STELLA Code, Performance Hints, Hello World in STELLA, Programming in STELLA
@section Incrementally Developing STELLA Code

The preferred method of STELLA code development is to use a Lisp-based
version of STELLA for all the prototyping and testing, since that allows
you to exploit most (or all) of the rapid-prototyping advantages of
Lisp.  Once a system has reached a certain point of stability, it can be
translated into C++ or Java for delivery or to interface it with other
C++ or Java code.

In the following, we assume an X/Emacs-based Lisp development
environment such as the Allegro CL Emacs interface, where Lisp is run in
an Emacs subprocess, and Lisp source can be compiled and evaluated
directly from the source buffers.  By "Lisp buffer" we mean the listener
buffer in which Lisp is actually running, and by "source buffer" we mean
a buffer that is used to edit a file that contains STELLA source.

Included in the distribution is the Hello World system comprised of the
files

@example
sources/systems/hello-world-system.ste
sources/hello-world/file-a.ste
sources/hello-world/file-b.ste
@end example

To get started, simply add your code to either @file{file-a.ste} or
@file{file-b.ste}, since all the necessary definitions and directories
for these files are already set up properly.  See section ??? on how to
setup your own system.

Make sure the Hello World system is loaded into Lisp by doing the
following:

@example
(make-system "hello-world" :common-lisp)
@end example

This will make sure that the system definition is loaded and the
necessary module definition is evaluated.

Now suppose you add the following function to @file{file-a.ste}:

@example
(defun (factorial INTEGER) ((n INTEGER))
  (if (eql? n 0)
      (return 1)
    (return (* n (factorial (1- n))))))
@end example

There are various options for translating and evaluating this
definition.  For example, you can simply remake the complete system
similar to what you would do for a C++ or Java program:

@example
(make-system "hello-world" :common-lisp)
@end example

This will retranslate the modified files, recompile them and reload them
into your Lisp image.

Instead of retranslating and recompiling everything, you can
incrementally evaluate the definition of @code{factorial} from your
Emacs-to-Lisp interface.  Simply put your cursor somewhere inside the
definition in the source buffer and evaluate it by typing @kbd{M-C-x}.
This translates the STELLA code into Lisp and compiles (or evaluates)
the resulting Lisp code.  Now you can actually try it out in the Lisp
buffer, for example:

@example
STELLA(4): (factorial 6)
720
@end example

Finally, instead of evaluating the definition in the source buffer, you
can also enter it directly at the Lisp prompt with the same effect.  

The way this works is that the Lisp symbol @code{stella::defun} is
actually bound to a Lisp macro that calls all the necessary translation
machinery to convert the STELLA @code{defun} into Lisp code.  Look at
the file @file{sources/stella/cl-lib/stella-to-cl.ste} for the complete
set of such macros.  This might be a bit confusing, since there are now
three different bindings (or meanings) of @code{defun}:

@enumerate
@item
The STELLA operator @code{defun} used to define STELLA functions.

@item
The Lisp macro @code{stella::defun} that resides in the @code{STELLA}
Lisp package and is only available for convenience in Lisp versions of
STELLA.

@item
The Lisp macro @code{CL:defun} which is the standard Common Lisp macro
used to define Lisp functions.
@end enumerate

We'll try to explicitly qualify which meaning is used wherever there
might be some doubt which one is meant.  In general, every unqualified
symbol mentioned below is either part of the STELLA language or resides
in the STELLA Lisp package.

Since a newly-written STELLA function might have errors, it is prudent
to first only translate it without actually executing the result of the
translation.  In the source buffer you can do that by macro-expanding
the @code{defun}.  For example, if you use the Allegro CL interface you
would position the cursor on the opening parenthesis of the @code{defun}
and then type @kbd{M-M}.  Any errors discovered by the STELLA translator
are reported in the Lisp buffer window.  The expansion will be a
@code{CL:progn} that contains the translated definition as the first
element plus various startup-time (initialization) code following it.

In the Lisp buffer you can achieve a similar effect with the
@code{lptrans} macro.  For example, executing

@example
(lptrans
 (defun (factorial INTEGER) ((n INTEGER))
   (if (eql? n 0)
       (return 1)
     (return (* n (factorial (1- n)))))))
@end example

in the Lisp buffer first Lisp-translates the definition, and then prints
the translation.  To see the C++ translation you can use
@code{cpptrans}, calling @code{jptrans} will generate the Java
translation.

You can also use @code{lptrans}/@code{cpptrans}/@code{jptrans} to
translate code fragments that are not top-level definitions such as
@code{defun} and its friends.  For example:

@example
STELLA(8): (lptrans
            (foreach element in (list 1 2 3)
                do (print element EOL)))

(CL:LET* ((ELEMENT NULL)
          (ITER-003
           (%THE-CONS-LIST (LIST (WRAP-INTEGER 1) (WRAP-INTEGER 2)
                                 (WRAP-INTEGER 3)))))
  (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
           (CL:PROGN (SETQ ELEMENT (%%VALUE ITER-003))
                     (SETQ ITER-003 (%%REST ITER-003)))
           (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) 
                           ELEMENT EOL)))
()
STELLA(9): (cpptrans
            (foreach element in (list 1 2 3)
                do (print element EOL)))
@{ Object* element = NULL;
  Cons* iter004 = list(3, wrapInteger(1), wrapInteger(2),
                          wrapInteger(3))-> theConsList;

  while (!(iter004 == NIL)) @{
    element = iter004->value;
    iter004 = iter004->rest;
    cout << element << endl;
  @}
@}
:VOID
STELLA(10): (jptrans
             (foreach element in (list 1 2 3)
                 do (print element EOL)))
@{ Stella_Object element = null;
  Cons iter005 = Stella.list
                  (Stella_Object.cons
                    (IntegerWrapper.wrapInteger(1), 
                     Stella_Object.cons
                      (IntegerWrapper.wrapInteger(2), 
                       Stella_Object.cons
                        (IntegerWrapper.wrapInteger(3), 
                         Stella.NIL)))).theConsList;

  while (!(iter005 == Stella.NIL)) @{
    @{
      element = iter005.value;
      iter005 = iter005.rest;
    @}
    java.lang.System.out.println(element);
  @}
@}
:VOID
@end example

The use of @code{lptrans} is really necessary here, since there is no
Lisp macro @code{foreach} that knows how to translate STELLA
@code{foreach} loops (those Lisp macros only exist for top-level
definition commands such as @code{defun}).  In order to translate such
code fragments without error messages, they need to be self-contained,
i.e., all referenced variables have to be either bound by a surrounding
@code{let}, or they must be globally defined variables.  Otherwise, the
STELLA translator will generate various "undefined variable" error
messages.

You can use the STELLA Lisp macro @code{eval} (i.e., @code{stella::eval}
not @code{CL:eval}) to actually execute such a code fragment.  For
example:

@example
STELLA(11): (eval
             (foreach element in (list 1 2 3)
                 do (print element EOL)))
|L|1
|L|2
|L|3
()
@end example

This translates the loop and executes the result, which prints the
wrapped numbers (hence, the @code{|L|} prefix) to standard output.  The
@code{()} at the end is the resulting Lisp value returned by the loop
(in Lisp everything returns a value, even though for STELLA
@code{foreach} is a statement, not an expression).

Make it a habit to wrap @code{eval} around any STELLA code you
incrementally evaluate in the Lips buffer.  This makes sure that all the
arguments to a function, etc., are translated into the appropriate
STELLA objects.  For example, evaluating

@example
(eval (list :a :b :c))
@end example

in the Lisp buffer generates a STELLA list that points to the STELLA
keywords @code{:a}, @code{:b} and @code{:c}.  If you don't use
@code{eval}, for example,

@example
(list :a :b :c)
@end example

a STELLA list containing the Lisp keywords `:a', `:b' and `:c' will be
created.  Lisp keywords are a completely different data structure than
STELLA keywords, and any STELLA code expecting a STELLA keyword but
finding a Lisp keyword will break, since Lisp keywords are not a legal
STELLA data structure.  Unfortunately, such cases can be very confusing,
since Lisp and STELLA keywords look/print exactly alike.

@code{eval} is also necessary to access STELLA symbols and surrogates in
the Lisp buffer.  For example, to access a STELLA symbol, you can use
@code{quote} (again, this is the STELLA @code{quote} not
@code{CL:quote}):

@example
(eval (quote foo))
@end example

This returns the STELLA symbol @code{foo}.  We explicitly used
@code{quote} here, since code typed at the Lisp prompt is first passed
through the Lisp reader before the STELLA translator sees it, and the
default Lisp reader interprets the @code{'} character differently than
the STELLA reader.  Within a STELLA file you can use the syntax
@code{'foo}, since it will be read directly by the STELLA reader that
knows how to interpret it correctly.

@code{lptrans}, @code{cpptrans} and @code{jptrans} are evaluable STELLA
commands that can also be evaluated by the C++ and Java version of
STELLA.  For example, to generate a Java translation of a little STELLA
code fragment you could run the @code{stella} script in the STELLA
directory like this (the output below has been additionally indented by
hand for clarity):

@example
% ./stella -e '(jptrans\
                 (foreach element in (list 1 2 3)\
                    do (print element EOL)))'
Running C++ version of STELLA...
Welcome to STELLA 3.4.0
@{ Stella_Object element = null;
  Cons iter001 = Stella.list
                  (Stella_Object.cons
                    (IntegerWrapper.wrapInteger(1), 
                     Stella_Object.cons
                      (IntegerWrapper.wrapInteger(2), 
                       Stella_Object.cons
                        (IntegerWrapper.wrapInteger(3), 
                         Stella.NIL)))).theConsList;

  while (!(iter001 == Stella.NIL)) @{
    @{
      element = iter001.value;
      iter001 = iter001.rest;
    @}
    java.lang.System.out.println(element);
  @}
@}
@end example

@node Performance Hints,  , Incrementally Developing STELLA Code, Programming in STELLA
@section Performance Hints

Here are a few things to watch out for once you get serious about the
performance of your translated STELLA programs:

@strong{Safety checks:} The STELLA variable @code{*safety*} controls
whether certain safety code is added to your translated STELLA program.
For Lisp translations it also controls whether @code{cast}'s will be
translated into run-time type checks or not.  There is no run-time type
checking performed in C++.  In Java native casts will always perform
runtime type tests.  The default @code{*safety*} level is 3 which
enables the translation of all @code{safety} clauses with level 3 or
lower.  A safety level of 1 or lower disables the generation of calls to
the @code{cast} function in Lisp.  @code{cast} performs run-time type
checks which are somewhat expensive.  However, you should not disable
run-time type checking in Lisp until you have fully debugged your
program.  Once you are confident that your program works correctly, you
can set @code{*safety*} to 0 before you translate it.  That way you will
avoid the generation and execution of any safety code at all.  All of
the core STELLA system was translated with @code{*safety*} set to 1.

@strong{Quoted cons trees:} Access to quoted constants that are not
symbols is somewhat slow, since it currently uses hashing to find them
in a table.  Hence, access to quoted constants such as @code{(quote (foo
bar fum))} should be avoided in inner loops.  Access to quoted symbols
such as @code{(quote foo)} is fast and does not cause any performance
problems.  The use of @code{quote} for constant cons trees is rare in
STELLA (and somewhat deprecated), which is the reason why this mechanism
is not all that well supported.  Future versions of STELLA might
re-implement the handling of constants and alleviate this performance
problem.

@strong{Equality tests:} The standard equality test in STELLA is
@code{eql?}, which the translator will translate into the most efficient
equality test for the particular types of operands (@code{eql?} is
somewhat similar to the Lisp function @code{CL:eql} with the exception
of comparing strings).  If the translator can determine that at least
one of the operands is a subtype of @code{STANDARD-OBJECT}, it will
translate the test into a fast pointer comparison with the Lisp function
@code{CL:eq} or the C++/Java @code{==} operator.  However, if both
operands are of type @code{OBJECT}, they might be wrapped literals such
as wrapped integers or strings.  In that case the equality test
translates into a call to the function @code{eql?} which in turn uses
method calls to handle comparison of different types of wrapped literals
(two wrapped literals are equal if their wrapped content is equal).
This is of course a lot less efficient than a simple pointer comparison.
It also means that if you can restrict the type of a variable that will
be tested with @code{eql?} to @code{STANDARD-OBJECT}, you probably
should do so for performance reasons.

@strong{Type tests:} Run-time type tests as used implicitly within a
@code{typecase} or explicitly with functions such as @code{cons?} have
to use a call to the method @code{primary-type}.  Hence, in
performance-critical portions of your code you should try to keep the
number of such tests as small as possible.

@strong{Wrapping and unwrapping literals:} The STELLA translator
automatically wraps (or objectifies) literals such as numbers or strings
when they are stored in a variable or slot of type @code{OBJECT}.
Similarly, it unwraps wrapped literals automatically to operate on the
literal directly.  This is very convenient, since it relieves the
programmer from having to perform these conversions by hand and makes
the code less cluttered.  For example, consider the following code
fragment:

@example
(let ((l (cons "foo" nil))
      (x (concatenate "bar" (first l))))
  (print x EOL)))
@end example
Here is its C++ translation:
@example
@{ Cons* l = cons(wrapString("foo"), NIL);
   char* x = stringConcatenate
              ("bar", ((StringWrapper*)(l->value))->wrapperValue, 0);

  std::cout << x << std::endl;
@}
@end example

Notice how the string literal @code{"foo"} is first wrapped so it can be
inserted into the @code{CONS} list @code{l} and then automatically
unwrapped in the call to @code{concatenate}.  While this is very
convenient, it does cause a certain overhead that should be avoided in
performance critical loops, etc.  In such situations, it often helps to
use auxiliary variables of the appropriate literal type to avoid
unnecessary wrap/unwrap operations.

@strong{Lisp-style property lists:} Lisp programs often use property
lists for fast retrieval of information that is linked to symbols.  To
support the easy translation of existing Lisp programs that use this
paradigm into STELLA, a similar mechanism implemented by the functions
@code{symbol-value}, @code{symbol-plist}, and @code{symbol-property} is
available that preserves the performance benefits of this storage scheme
(see the file @code{sources/stella/symbols.ste}).  However, property
lists do not fit the object-oriented programming paradigm supported by
STELLA, and, hence, are frowned upon.

@strong{Compiler optimization:} The optimization settings used with the
native Lisp or C++ compiler can greatly influence performance results.
In particular, using high optimization settings with the Lisp compiler
can greatly improve slot access time on STELLA objects.

@menu
* Lisp Performance Hints::      
@end menu

@node Lisp Performance Hints,  , Performance Hints, Performance Hints
@subsection Lisp Performance Hints

The standard Lisp implementation for STELLA objects are CLOS objects,
since CLOS provides the most natural Lisp implementation for the STELLA
object system.  However, there is a price to pay, since in Lisp slot
access on CLOS objects is a lot slower than slot access on structs.  For
example, in Allegro CL 4.3, the access to the @code{value} slot of a
STELLA CONS cell takes about 4 times longer on a CLOS object
implementation of @code{CONS} than on a struct implementation.
Unfortunately, the struct implementation itself takes about 3 times
longer than calling @code{CL:car} on a Lisp cons, which is why we are
actually using Lisp conses as the Lisp implementation for STELLA
@code{CONS}es.  Note, that in the C++ and Java translation these
slot-access performance problems are nonexistent.

In order to get the maximum performance out of the Lisp version of
STELLA, you can tell the translator to use structs as the implementation
for STELLA objects.  It does so by using @code{CL:defstruct} instead of
@code{CL:defclass} and dispatches methods directly on the structure
object.

To use the struct translation scheme evaluate

@example
(set-stella-feature :use-common-lisp-structs)
@end example

before you translate a STELLA system.  This will generate translated
files with a @code{.slisp} extension.  Make sure that after you
translated all the files you are interested in, you disable the above
feature with

@example
(unset-stella-feature :use-common-lisp-structs)
@end example

Otherwise, subsequent incremental translations in that Lisp image might
fail, since different translation schemes cannot be mixed.  If you
already are using the struct version of STELLA, all systems will be
translated in struct mode by default.

To use the struct translation of your system you have to use the struct
version of STELLA.  To do so do the following:

@example
(CL:setq cl-user::*load-cl-struct-stella?* CL:t)
(CL:load "load-stella.lisp")
@end example

Alternatively, you can edit the initial value of the variable
@code{*load-cl-struct-stella?*} in the file @file{load-stella.lisp}
(see also @ref{Lisp Installation}).

The reasons why the struct translation scheme is not enabled by
default are the following:

@itemize
@item
Incremental redefinition of STELLA classes does not redefine any objects
created with the old definition, and, hence, slot accessors might simply
break or retrieve the value of a different slot when applied to such an
old object.  The programmer therefore has to be very careful when
redefining a STELLA class while in struct mode.  This means, that you
should view the usage of the struct-translation scheme for Lisp as a kind
of delivery option, similar to translating into C++.  Part of the reason
why slot access on CLOS object is expensive is the indirection machinery
that allows redefinition of classes and their associated instances.
This is great for code development, but the flexibility and expense is
usually not needed or warranted for delivered code.

@item
The performance trade-offs between CLOS and struct versions might be
different in different versions of Lisp.  For example, in older version
of Allegro CL slot access on structs was fast, but method dispatch was
significantly slower than for CLOS objects which eliminated some/all of
the performance gains.
@end itemize

@c ===========================================================================

@node Library Classes, Library Functions, Programming in STELLA, Top
@chapter Library Classes (tbw)
To be written.

@c ===========================================================================

@node Library Functions, Function Index, Library Classes, Top
@chapter Library Functions

@c ---------------------------------------------------------------------------

@menu
* Basic Constants and Predicates::  
* Numbers::                     
* Characters::                  
* Strings::                     
* CONS Lists and Trees::        
* Lists::                       
* Property and Key-Value Lists::  
* Vectors::                     
* Hash Tables::                 
* Key Value Maps::              
* Hash Sets::                   
* Iterators::                   
* Symbols::                     
* Contexts and Modules::        
* Input and Output::            
* Files::                       
* Dates and Times::             
* XML Support::                 
* Miscellaneous::               
@end menu

@node Basic Constants and Predicates, Numbers, Library Functions, Library Functions
@section Basic Constants and Predicates

#$(util/texinfo-insert-doc NULL)
#$(util/texinfo-insert-doc TRUE)
#$(util/texinfo-insert-doc FALSE)
@c # $(util/texinfo-insert-doc UNKNOWN.null?)
#$(util/texinfo-insert-doc OBJECT.null?)
#$(util/texinfo-insert-doc SECOND-CLASS-OBJECT.null?)
#$(util/texinfo-insert-doc NATIVE-VECTOR.null?)
#$(util/texinfo-insert-doc STRING.null?)
#$(util/texinfo-insert-doc MUTABLE-STRING.null?)
#$(util/texinfo-insert-doc CHARACTER.null?)
#$(util/texinfo-insert-doc CODE.null?)
#$(util/texinfo-insert-doc INTEGER.null?)
#$(util/texinfo-insert-doc FLOAT.null?)
@c # $(util/texinfo-insert-doc UNKNOWN.defined?)
#$(util/texinfo-insert-doc OBJECT.defined?)
#$(util/texinfo-insert-doc SECOND-CLASS-OBJECT.defined?)
#$(util/texinfo-insert-doc NATIVE-VECTOR.defined?)
#$(util/texinfo-insert-doc STRING.defined?)
#$(util/texinfo-insert-doc MUTABLE-STRING.defined?)
#$(util/texinfo-insert-doc CHARACTER.defined?)
#$(util/texinfo-insert-doc CODE.defined?)
#$(util/texinfo-insert-doc INTEGER.defined?)
#$(util/texinfo-insert-doc FLOAT.defined?)
#$(util/texinfo-insert-doc eq?)
#$(util/texinfo-insert-doc eql?)
#$(util/texinfo-insert-doc equal?)
#$(util/texinfo-insert-doc OBJECT.object-equal?)
#$(util/texinfo-insert-doc WRAPPER.object-equal?)

@c ---------------------------------------------------------------------------

@node Numbers, Characters, Basic Constants and Predicates, Library Functions
@section Numbers

#$(util/texinfo-insert-doc PI)
#$(util/texinfo-insert-doc +)
#$(util/texinfo-insert-doc -)
#$(util/texinfo-insert-doc *)
#$(util/texinfo-insert-doc /)
#$(util/texinfo-insert-doc 1+)
#$(util/texinfo-insert-doc 1-)
#$(util/texinfo-insert-doc ++)
#$(util/texinfo-insert-doc --)
#$(util/texinfo-insert-doc =)
#$(util/texinfo-insert-doc <)
#$(util/texinfo-insert-doc <=)
#$(util/texinfo-insert-doc >=)
#$(util/texinfo-insert-doc >)
#$(util/texinfo-insert-doc zero?)
#$(util/texinfo-insert-doc plus?)
#$(util/texinfo-insert-doc even?)
#$(util/texinfo-insert-doc odd?)
#$(util/texinfo-insert-doc div)
#$(util/texinfo-insert-doc rem)
#$(util/texinfo-insert-doc mod)
#$(util/texinfo-insert-doc gcd)
#$(util/texinfo-insert-doc ceiling)
#$(util/texinfo-insert-doc floor)
#$(util/texinfo-insert-doc round)
#$(util/texinfo-insert-doc INTEGER.abs)
#$(util/texinfo-insert-doc FLOAT.abs)
#$(util/texinfo-insert-doc min)
#$(util/texinfo-insert-doc max)
#$(util/texinfo-insert-doc sqrt)
#$(util/texinfo-insert-doc exp)
#$(util/texinfo-insert-doc expt)
#$(util/texinfo-insert-doc log)
#$(util/texinfo-insert-doc log10)
#$(util/texinfo-insert-doc sin)
#$(util/texinfo-insert-doc cos)
#$(util/texinfo-insert-doc tan)
#$(util/texinfo-insert-doc asin)
#$(util/texinfo-insert-doc acos)
#$(util/texinfo-insert-doc atan)
#$(util/texinfo-insert-doc atan2)
#$(util/texinfo-insert-doc random)
#$(util/texinfo-insert-doc integer-to-string)
#$(util/texinfo-insert-doc string-to-integer)
#$(util/texinfo-insert-doc float-to-string)
#$(util/texinfo-insert-doc string-to-float)
#$(util/texinfo-insert-doc format-float)
#$(util/texinfo-insert-doc wrap-integer)
#$(util/texinfo-insert-doc unwrap-integer)
#$(util/texinfo-insert-doc wrap-float)
#$(util/texinfo-insert-doc unwrap-float)

@c ---------------------------------------------------------------------------

@node Characters, Strings, Numbers, Library Functions
@section Characters

#$(util/texinfo-insert-doc character-code)
#$(util/texinfo-insert-doc code-character)
#$(util/texinfo-insert-doc digit-character?)
#$(util/texinfo-insert-doc letter-character?)
#$(util/texinfo-insert-doc upper-case-character?)
#$(util/texinfo-insert-doc lower-case-character?)
#$(util/texinfo-insert-doc white-space-character?)
#$(util/texinfo-insert-doc character-downcase)
#$(util/texinfo-insert-doc character-upcase)
#$(util/texinfo-insert-doc character-capitalize)
#$(util/texinfo-insert-doc character-to-string)
#$(util/texinfo-insert-doc wrap-character)
#$(util/texinfo-insert-doc unwrap-character)

@c ---------------------------------------------------------------------------

@node Strings, CONS Lists and Trees, Characters, Library Functions
@section Strings

#$(util/texinfo-insert-doc string-eql?)
#$(util/texinfo-insert-doc string-equal?)
#$(util/texinfo-insert-doc STRING.empty?)
#$(util/texinfo-insert-doc STRING.non-empty?)
#$(util/texinfo-insert-doc string-compare)
#$(util/texinfo-insert-doc string<)
#$(util/texinfo-insert-doc string<=)
#$(util/texinfo-insert-doc string>=)
#$(util/texinfo-insert-doc string>)
#$(util/texinfo-insert-doc string-less?)
#$(util/texinfo-insert-doc string-less-equal?)
#$(util/texinfo-insert-doc string-greater-equal?)
#$(util/texinfo-insert-doc string-greater?)
#$(util/texinfo-insert-doc all-upper-case-string?)
#$(util/texinfo-insert-doc all-lower-case-string?)
#$(util/texinfo-insert-doc make-string)
#$(util/texinfo-insert-doc make-mutable-string)
#$(util/texinfo-insert-doc make-raw-mutable-string)
#$(util/texinfo-insert-doc STRING.first)
#$(util/texinfo-insert-doc MUTABLE-STRING.first)
#$(util/texinfo-insert-doc STRING.second)
#$(util/texinfo-insert-doc MUTABLE-STRING.second)
#$(util/texinfo-insert-doc STRING.third)
#$(util/texinfo-insert-doc MUTABLE-STRING.third)
#$(util/texinfo-insert-doc STRING.fourth)
#$(util/texinfo-insert-doc MUTABLE-STRING.fourth)
#$(util/texinfo-insert-doc STRING.fifth)
#$(util/texinfo-insert-doc MUTABLE-STRING.fifth)
#$(util/texinfo-insert-doc STRING.nth)
#$(util/texinfo-insert-doc MUTABLE-STRING.nth)
#$(util/texinfo-insert-doc STRING.rest)
#$(util/texinfo-insert-doc STRING.length)
#$(util/texinfo-insert-doc MUTABLE-STRING.length)
#$(util/texinfo-insert-doc STRING.member?)
#$(util/texinfo-insert-doc STRING.position)
#$(util/texinfo-insert-doc STRING.last-position)
#$(util/texinfo-insert-doc string-search)
#$(util/texinfo-insert-doc STRING.copy)
#$(util/texinfo-insert-doc string-upcase)
#$(util/texinfo-insert-doc string-downcase)
#$(util/texinfo-insert-doc string-capitalize)
#$(util/texinfo-insert-doc STRING.concatenate)
#$(util/texinfo-insert-doc STRING.subsequence)
#$(util/texinfo-insert-doc STRING.remove)
#$(util/texinfo-insert-doc STRING.substitute)
#$(util/texinfo-insert-doc MUTABLE-STRING.substitute)
#$(util/texinfo-insert-doc replace-substrings)
#$(util/texinfo-insert-doc instantiate-string-template)
#$(util/texinfo-insert-doc insert-string)
#$(util/texinfo-insert-doc wrap-string)
#$(util/texinfo-insert-doc wrap-mutable-string)
#$(util/texinfo-insert-doc unwrap-string)
#$(util/texinfo-insert-doc unwrap-mutable-string)
#$(util/texinfo-insert-doc string-to-mutable-string)
#$(util/texinfo-insert-doc mutable-string-to-string)
#$(util/texinfo-insert-doc integer-to-string)
#$(util/texinfo-insert-doc string-to-integer)
#$(util/texinfo-insert-doc float-to-string)
#$(util/texinfo-insert-doc string-to-float)
#$(util/texinfo-insert-doc format-float)
#$(util/texinfo-insert-doc character-to-string)
#$(util/texinfo-insert-doc stringify)
#$(util/texinfo-insert-doc stringify-in-module)
#$(util/texinfo-insert-doc unstringify)
#$(util/texinfo-insert-doc unstringify-in-module)

@c ---------------------------------------------------------------------------

@node CONS Lists and Trees, Lists, Strings, Library Functions
@section @code{CONS} Lists and Trees

#$(util/texinfo-insert-doc @CONS)
#$(util/texinfo-insert-doc NIL)
#$(util/texinfo-insert-doc CONS.empty?)
#$(util/texinfo-insert-doc CONS.non-empty?)
#$(util/texinfo-insert-doc nil?)
#$(util/texinfo-insert-doc equal-cons-trees?)
#$(util/texinfo-insert-doc CONS.object-equal?)
#$(util/texinfo-insert-doc CONS.equal-hash-code)
#$(util/texinfo-insert-doc cons)
#$(util/texinfo-insert-doc CONS.first)
#$(util/texinfo-insert-doc CONS.second)
#$(util/texinfo-insert-doc CONS.third)
#$(util/texinfo-insert-doc CONS.fourth)
#$(util/texinfo-insert-doc CONS.fifth)
#$(util/texinfo-insert-doc CONS.nth)
#$(util/texinfo-insert-doc CONS.nth-rest)
#$(util/texinfo-insert-doc CONS.last)
#$(util/texinfo-insert-doc CONS.but-last)
#$(util/texinfo-insert-doc last-cons)
#$(util/texinfo-insert-doc CONS.length)
#$(util/texinfo-insert-doc CONS.member?)
#$(util/texinfo-insert-doc CONS.memb?)
#$(util/texinfo-insert-doc CONS.position)
#$(util/texinfo-insert-doc CONS.last-position)
#$(util/texinfo-insert-doc CONS.reverse)
#$(util/texinfo-insert-doc CONS.remove)
#$(util/texinfo-insert-doc CONS.remove-duplicates)
#$(util/texinfo-insert-doc CONS.remove-if)
#$(util/texinfo-insert-doc CONS.substitute)
#$(util/texinfo-insert-doc CONS.concatenate)
#$(util/texinfo-insert-doc append)
#$(util/texinfo-insert-doc CONS.prepend)
#$(util/texinfo-insert-doc pushq)
#$(util/texinfo-insert-doc pushq-new)
#$(util/texinfo-insert-doc popq)
#$(util/texinfo-insert-doc cons-list)
#$(util/texinfo-insert-doc list*)
#$(util/texinfo-insert-doc copy-cons-list)
#$(util/texinfo-insert-doc copy-cons-tree)
#$(util/texinfo-insert-doc substitute-cons-tree)
#$(util/texinfo-insert-doc search-cons-tree?)
#$(util/texinfo-insert-doc tree-size)
#$(util/texinfo-insert-doc safe-tree-size)
#$(util/texinfo-insert-doc cons-tree-nth)
#$(util/texinfo-insert-doc cons-tree-nth-rest)
#$(util/texinfo-insert-doc match-cons-tree)
#$(util/texinfo-insert-doc cons-tree-match?)
#$(util/texinfo-insert-doc CONS.consify)
#$(util/texinfo-insert-doc CONS.allocate-iterator)
#$(util/texinfo-insert-doc CONS-ITERATOR.next?)
#$(util/texinfo-insert-doc CONS.sort)
#$(util/texinfo-insert-doc CONS.sort-tuples)
#$(util/texinfo-insert-doc map-null-to-nil)
#$(util/texinfo-insert-doc *printPretty?*)
#$(util/texinfo-insert-doc *printReadably?*)
#$(util/texinfo-insert-doc *printPrettyCode?*)

@menu
* CONS Lists as Sets::          
@end menu

@node CONS Lists as Sets,  , CONS Lists and Trees, CONS Lists and Trees
@subsection CONS Lists as Sets

#$(util/texinfo-insert-doc CONS.subset?)
#$(util/texinfo-insert-doc CONS.equivalent-sets?)
#$(util/texinfo-insert-doc CONS.union)
#$(util/texinfo-insert-doc CONS.intersection)
#$(util/texinfo-insert-doc CONS.difference)
#$(util/texinfo-insert-doc CONS.subtract)

@c ---------------------------------------------------------------------------

@node Lists, Property and Key-Value Lists, CONS Lists and Trees, Library Functions
@section Lists

#$(util/texinfo-insert-doc @LIST)
#$(util/texinfo-insert-doc NIL-LIST)
#$(util/texinfo-insert-doc defined-list?)
#$(util/texinfo-insert-doc null-list?)
#$(util/texinfo-insert-doc LIST.empty?)
#$(util/texinfo-insert-doc LIST.non-empty?)
#$(util/texinfo-insert-doc LIST.object-equal?)
#$(util/texinfo-insert-doc LIST.equal-hash-code)
#$(util/texinfo-insert-doc list)
#$(util/texinfo-insert-doc LIST.first)
#$(util/texinfo-insert-doc LIST.second)
#$(util/texinfo-insert-doc LIST.third)
#$(util/texinfo-insert-doc LIST.fourth)
#$(util/texinfo-insert-doc LIST.fifth)
#$(util/texinfo-insert-doc LIST.nth)
#$(util/texinfo-insert-doc LIST.rest)
#$(util/texinfo-insert-doc LIST.last)
#$(util/texinfo-insert-doc LIST.but-last)
#$(util/texinfo-insert-doc LIST.length)
#$(util/texinfo-insert-doc LIST.member?)
#$(util/texinfo-insert-doc LIST.memb?)
#$(util/texinfo-insert-doc LIST.position)
#$(util/texinfo-insert-doc LIST.last-position)
#$(util/texinfo-insert-doc LIST.insert)
#$(util/texinfo-insert-doc LIST.push)
#$(util/texinfo-insert-doc LIST.insert-new)
#$(util/texinfo-insert-doc LIST.insert-last)
#$(util/texinfo-insert-doc LIST.reverse)
#$(util/texinfo-insert-doc LIST.remove)
#$(util/texinfo-insert-doc LIST.remove-duplicates)
#$(util/texinfo-insert-doc LIST.remove-deleted-members)
#$(util/texinfo-insert-doc LIST.remove-if)
#$(util/texinfo-insert-doc LIST.pop)
#$(util/texinfo-insert-doc LIST.substitute)
#$(util/texinfo-insert-doc LIST.concatenate)
#$(util/texinfo-insert-doc LIST.prepend)
#$(util/texinfo-insert-doc LIST.copy)
#$(util/texinfo-insert-doc LIST.clear)
#$(util/texinfo-insert-doc LIST.consify)
#$(util/texinfo-insert-doc LIST.allocate-iterator)
#$(util/texinfo-insert-doc LIST-ITERATOR.next?)
#$(util/texinfo-insert-doc LIST.sort)
#$(util/texinfo-insert-doc map-null-to-nil-list)

@menu
* Lists as Sets::               
@end menu

@node Lists as Sets,  , Lists, Lists
@subsection Lists as Sets

Similar to @code{CONS} lists @code{LIST}'s can also be treated as sets
and support the set manipulations below.  Note that @code{LIST}
constructors do not check for proper set-hood and may have surprising
results if a list contains duplicate elements.

#$(util/texinfo-insert-doc LIST.subset?)
#$(util/texinfo-insert-doc LIST.equivalent-sets?)
#$(util/texinfo-insert-doc LIST.union)
#$(util/texinfo-insert-doc LIST.intersection)
#$(util/texinfo-insert-doc LIST.difference)
#$(util/texinfo-insert-doc LIST.subtract)

@code{SET} is a subclass of @code{LIST} that overrides certain
@code{LIST} operations to prevent duplicate elements.  The following
additional or modified operations are supported:

#$(util/texinfo-insert-doc @SET)
#$(util/texinfo-insert-doc SET.insert)
#$(util/texinfo-insert-doc SET.push)
#$(util/texinfo-insert-doc SET.insert-last)
#$(util/texinfo-insert-doc SET.substitute)
#$(util/texinfo-insert-doc SET.concatenate)
#$(util/texinfo-insert-doc SET.object-equal?)
#$(util/texinfo-insert-doc SET.equal-hash-code)
#$(util/texinfo-insert-doc set)

@c ---------------------------------------------------------------------------

@node Property and Key-Value Lists, Vectors, Lists, Library Functions
@section Property and Key-Value Lists

#$(util/texinfo-insert-doc @PROPERTY-LIST)
#$(util/texinfo-insert-doc PROPERTY-LIST.empty?)
#$(util/texinfo-insert-doc PROPERTY-LIST.non-empty?)
#$(util/texinfo-insert-doc PROPERTY-LIST.object-equal?)
#$(util/texinfo-insert-doc PROPERTY-LIST.equal-hash-code)
#$(util/texinfo-insert-doc PROPERTY-LIST.length)
@c # $(util/texinfo-insert-doc search-plist)
#$(util/texinfo-insert-doc PROPERTY-LIST.lookup)
#$(util/texinfo-insert-doc PROPERTY-LIST.insert-at)
#$(util/texinfo-insert-doc PROPERTY-LIST.remove-at)
#$(util/texinfo-insert-doc PROPERTY-LIST.copy)
#$(util/texinfo-insert-doc PROPERTY-LIST.clear)
#$(util/texinfo-insert-doc PROPERTY-LIST.allocate-iterator)
#$(util/texinfo-insert-doc PROPERTY-LIST-ITERATOR.next?)
#$(util/texinfo-insert-doc @KV-CONS)
#$(util/texinfo-insert-doc kv-cons)
#$(util/texinfo-insert-doc copy-kv-cons-list)
#$(util/texinfo-insert-doc @KEY-VALUE-LIST)
#$(util/texinfo-insert-doc KEY-VALUE-LIST.empty?)
#$(util/texinfo-insert-doc KEY-VALUE-LIST.non-empty?)
#$(util/texinfo-insert-doc KEY-VALUE-LIST.object-equal?)
#$(util/texinfo-insert-doc KEY-VALUE-LIST.equal-hash-code)
#$(util/texinfo-insert-doc KEY-VALUE-LIST.length)
#$(util/texinfo-insert-doc KEY-VALUE-LIST.lookup)
#$(util/texinfo-insert-doc KEY-VALUE-LIST.reverse)
#$(util/texinfo-insert-doc KEY-VALUE-LIST.insert-at)
#$(util/texinfo-insert-doc KEY-VALUE-LIST.remove-at)
#$(util/texinfo-insert-doc KEY-VALUE-LIST.insert-entry)
#$(util/texinfo-insert-doc KEY-VALUE-LIST.remove-entry)
#$(util/texinfo-insert-doc KEY-VALUE-LIST.push)
#$(util/texinfo-insert-doc KEY-VALUE-LIST.kv-push)
#$(util/texinfo-insert-doc KEY-VALUE-LIST.pop)
#$(util/texinfo-insert-doc KEY-VALUE-LIST.copy)
#$(util/texinfo-insert-doc KEY-VALUE-LIST.clear)
#$(util/texinfo-insert-doc KEY-VALUE-LIST.consify)
#$(util/texinfo-insert-doc KEY-VALUE-LIST.allocate-iterator)
#$(util/texinfo-insert-doc KV-LIST-ITERATOR.next?)

@c ---------------------------------------------------------------------------

@node Vectors, Hash Tables, Property and Key-Value Lists, Library Functions
@section Vectors

#$(util/texinfo-insert-doc @VECTOR)
#$(util/texinfo-insert-doc @EXTENSIBLE-VECTOR)
#$(util/texinfo-insert-doc VECTOR.empty?)
#$(util/texinfo-insert-doc VECTOR.non-empty?)
#$(util/texinfo-insert-doc VECTOR.object-equal?)
#$(util/texinfo-insert-doc VECTOR.equal-hash-code)
#$(util/texinfo-insert-doc vector)
#$(util/texinfo-insert-doc VECTOR.first)
#$(util/texinfo-insert-doc VECTOR.second)
#$(util/texinfo-insert-doc VECTOR.third)
#$(util/texinfo-insert-doc VECTOR.fourth)
#$(util/texinfo-insert-doc VECTOR.fifth)
#$(util/texinfo-insert-doc VECTOR.nth)
#$(util/texinfo-insert-doc VECTOR.last)
#$(util/texinfo-insert-doc VECTOR.but-last)
#$(util/texinfo-insert-doc VECTOR.length)
#$(util/texinfo-insert-doc VECTOR.member?)
#$(util/texinfo-insert-doc VECTOR.position)
#$(util/texinfo-insert-doc VECTOR.last-position)
#$(util/texinfo-insert-doc VECTOR.insert-at)
#$(util/texinfo-insert-doc VECTOR.copy)
#$(util/texinfo-insert-doc VECTOR.clear)
#$(util/texinfo-insert-doc resize-vector)
#$(util/texinfo-insert-doc VECTOR.consify)
#$(util/texinfo-insert-doc EXTENSIBLE-VECTOR.insert-at)
#$(util/texinfo-insert-doc VECTOR-SEQUENCE.insert)
#$(util/texinfo-insert-doc VECTOR-SEQUENCE.remove)
#$(util/texinfo-insert-doc VECTOR-SEQUENCE.length)

@c ---------------------------------------------------------------------------

@node Hash Tables, Key Value Maps, Vectors, Library Functions
@section Hash Tables

#$(util/texinfo-insert-doc @HASH-TABLE)
#$(util/texinfo-insert-doc @STRING-HASH-TABLE)
#$(util/texinfo-insert-doc @STRING-TO-INTEGER-HASH-TABLE)
#$(util/texinfo-insert-doc @INTEGER-HASH-TABLE)
#$(util/texinfo-insert-doc @FLOAT-HASH-TABLE)
#$(util/texinfo-insert-doc HASH-TABLE.lookup)
#$(util/texinfo-insert-doc HASH-TABLE.insert-at)
#$(util/texinfo-insert-doc HASH-TABLE.remove-at)
#$(util/texinfo-insert-doc STRING-HASH-TABLE.lookup)
#$(util/texinfo-insert-doc STRING-HASH-TABLE.insert-at)
#$(util/texinfo-insert-doc STRING-HASH-TABLE.remove-at)
#$(util/texinfo-insert-doc STRING-TO-INTEGER-HASH-TABLE.lookup)
#$(util/texinfo-insert-doc STRING-TO-INTEGER-HASH-TABLE.insert-at)
#$(util/texinfo-insert-doc INTEGER-HASH-TABLE.lookup)
#$(util/texinfo-insert-doc INTEGER-HASH-TABLE.insert-at)
#$(util/texinfo-insert-doc FLOAT-HASH-TABLE.insert-at)

STELLA provides its own implementation of hash tables for cases where
language-native implementations are not available, or where additional
features are needed.

#$(util/texinfo-insert-doc @STELLA-HASH-TABLE)
#$(util/texinfo-insert-doc STELLA-HASH-TABLE.lookup)
#$(util/texinfo-insert-doc STELLA-HASH-TABLE.insert-at)
#$(util/texinfo-insert-doc STELLA-HASH-TABLE.remove-at)
#$(util/texinfo-insert-doc STELLA-HASH-TABLE.length)
#$(util/texinfo-insert-doc STELLA-HASH-TABLE.empty?)
#$(util/texinfo-insert-doc STELLA-HASH-TABLE.non-empty?)
#$(util/texinfo-insert-doc STELLA-HASH-TABLE.copy)
#$(util/texinfo-insert-doc STELLA-HASH-TABLE.clear)
#$(util/texinfo-insert-doc STELLA-HASH-TABLE.consify)
#$(util/texinfo-insert-doc STELLA-HASH-TABLE.object-equal?)
#$(util/texinfo-insert-doc STELLA-HASH-TABLE.equal-hash-code)
#$(util/texinfo-insert-doc STELLA-HASH-TABLE.allocate-iterator)

Hashing objects into STELLA hash tables is accomplished via
@code{hash-code} and @code{equal-hash-code} methods.  These methods are
implemented for all built-in STELLA types but are user extensible for
cases where special functionality on user-defined objects is needed.
Defining new @code{hash-code} methods should only be necessary if new
wrapper types are defined, since for all types descending from
@code{STANDARD-OBJECT} the built-in method should be adequate.

#$(util/texinfo-insert-doc object-hash-code)
#$(util/texinfo-insert-doc OBJECT.hash-code)
#$(util/texinfo-insert-doc STANDARD-OBJECT.hash-code)
#$(util/texinfo-insert-doc STRING-WRAPPER.hash-code)
#$(util/texinfo-insert-doc INTEGER-WRAPPER.hash-code)
#$(util/texinfo-insert-doc FLOAT-WRAPPER.hash-code)
#$(util/texinfo-insert-doc CHARACTER-WRAPPER.hash-code)
#$(util/texinfo-insert-doc BOOLEAN-WRAPPER.hash-code)
#$(util/texinfo-insert-doc STRING.hash-code)
#$(util/texinfo-insert-doc INTEGER.hash-code)
#$(util/texinfo-insert-doc FLOAT.hash-code)
#$(util/texinfo-insert-doc CHARACTER.hash-code)
#$(util/texinfo-insert-doc OBJECT.equal-hash-code)

The following low-level utilities are available to implement specialized
hashing schemes or for defining new versions of @code{equal-hash-code}.

#$(util/texinfo-insert-doc hashmod)
#$(util/texinfo-insert-doc rotate-hash-code)

@node Key Value Maps, Hash Sets, Hash Tables, Library Functions
@section Key Value Maps

@code{KEY-VALUE-MAP} is a full-featured dictionary class that supports
@code{eql?} or extensible @code{equal?} equality tests, O(1) access
operations even for large numbers of entries by using a hash table,
light-weight @code{KV-CONS} representation for small tables and
iteration even if the dictionary is represented by a hash table (note
that in STELLA we cannot iterate over regular @code{HASH-TABLE}'s, since
native Lisp hash tables do not allow us to implement a hash table
iterator).  Since large @code{KEY-VALUE-MAP}'s are implemented via
@code{STELLA-HASH-TABLE}'s, we can support iteration.

#$(util/texinfo-insert-doc @KEY-VALUE-MAP)
#$(util/texinfo-insert-doc KEY-VALUE-MAP.lookup)
#$(util/texinfo-insert-doc KEY-VALUE-MAP.insert-at)
#$(util/texinfo-insert-doc KEY-VALUE-MAP.remove-at)
#$(util/texinfo-insert-doc KEY-VALUE-MAP.length)
#$(util/texinfo-insert-doc KEY-VALUE-MAP.empty?)
#$(util/texinfo-insert-doc KEY-VALUE-MAP.non-empty?)
#$(util/texinfo-insert-doc KEY-VALUE-MAP.copy)
#$(util/texinfo-insert-doc KEY-VALUE-MAP.clear)
#$(util/texinfo-insert-doc KEY-VALUE-MAP.allocate-iterator)
#$(util/texinfo-insert-doc KEY-VALUE-MAP.consify)
#$(util/texinfo-insert-doc KEY-VALUE-MAP.object-equal?)
#$(util/texinfo-insert-doc KEY-VALUE-MAP.equal-hash-code)

@node Hash Sets, Iterators, Key Value Maps, Library Functions
@section Hash Sets

@code{HASH-SET} is a full-featured set class that supports @code{eql?}
or extensible @code{equal?} equality tests, O(1) insert and
@code{member?} operations, O(N) @code{intersection} etc. operations even
for large numbers of entries by using a STELLA hash table, light-weight
@code{KV-CONS} representation for small sets and iteration even if the
set is represented by a hash table.  The only minor drawback right now
is that we waste one value slot per entry, since we piggy-back off
@code{KEY-VALUE-MAP}'s, however, that wastes at most 25% space.

#$(util/texinfo-insert-doc @HASH-SET)
#$(util/texinfo-insert-doc hash-set)
#$(util/texinfo-insert-doc HASH-SET.member?)
#$(util/texinfo-insert-doc HASH-SET.insert)
#$(util/texinfo-insert-doc HASH-SET.remove)
#$(util/texinfo-insert-doc HASH-SET.remove-if)
#$(util/texinfo-insert-doc HASH-SET.pop)
#$(util/texinfo-insert-doc HASH-SET.substitute)
#$(util/texinfo-insert-doc HASH-SET.copy)
#$(util/texinfo-insert-doc HASH-SET.consify)
#$(util/texinfo-insert-doc HASH-SET.subset?)
#$(util/texinfo-insert-doc HASH-SET.equivalent-sets?)
#$(util/texinfo-insert-doc HASH-SET.intersection)
#$(util/texinfo-insert-doc HASH-SET.union)
#$(util/texinfo-insert-doc HASH-SET.difference)
#$(util/texinfo-insert-doc HASH-SET.subtract)
#$(util/texinfo-insert-doc HASH-SET.object-equal?)
#$(util/texinfo-insert-doc HASH-SET.equal-hash-code)

@c ---------------------------------------------------------------------------

@node Iterators, Symbols, Hash Sets, Library Functions
@section Iterators

#$(util/texinfo-insert-doc ITERATOR.empty?)
#$(util/texinfo-insert-doc ITERATOR.member?)
#$(util/texinfo-insert-doc ABSTRACT-ITERATOR.length)
#$(util/texinfo-insert-doc ITERATOR.pop)
#$(util/texinfo-insert-doc ITERATOR.advance)
#$(util/texinfo-insert-doc ITERATOR.concatenate)
#$(util/texinfo-insert-doc ITERATOR.consify)
#$(util/texinfo-insert-doc ALL-PURPOSE-ITERATOR.next?)

@c ---------------------------------------------------------------------------

@node Symbols, Contexts and Modules, Iterators, Library Functions
@section Symbols

#$(util/texinfo-insert-doc lookup-symbol)
#$(util/texinfo-insert-doc intern-symbol)
#$(util/texinfo-insert-doc unintern-symbol)
#$(util/texinfo-insert-doc lookup-symbol-in-module)
#$(util/texinfo-insert-doc intern-symbol-in-module)
#$(util/texinfo-insert-doc intern-derived-symbol)
#$(util/texinfo-insert-doc visible-symbol?)
#$(util/texinfo-insert-doc lookup-visible-symbols-in-module)
#$(util/texinfo-insert-doc import-symbol)
#$(util/texinfo-insert-doc safe-import-symbol)
#$(util/texinfo-insert-doc lookup-surrogate)
#$(util/texinfo-insert-doc intern-surrogate)
#$(util/texinfo-insert-doc unintern-surrogate)
#$(util/texinfo-insert-doc lookup-surrogate-in-module)
#$(util/texinfo-insert-doc intern-surrogate-in-module)
#$(util/texinfo-insert-doc intern-derived-surrogate)
#$(util/texinfo-insert-doc visible-surrogate?)
#$(util/texinfo-insert-doc lookup-visible-surrogates-in-module)
#$(util/texinfo-insert-doc import-surrogate)
#$(util/texinfo-insert-doc safe-import-surrogate)
#$(util/texinfo-insert-doc lookup-keyword)
#$(util/texinfo-insert-doc intern-keyword)
#$(util/texinfo-insert-doc gensym)
#$(util/texinfo-insert-doc local-gensym)
#$(util/texinfo-insert-doc symbol-plist)
#$(util/texinfo-insert-doc symbol-property)
#$(util/texinfo-insert-doc symbol-value)
#$(util/texinfo-insert-doc symbolize)

@c ---------------------------------------------------------------------------

@node Contexts and Modules, Input and Output, Symbols, Library Functions
@section Context and Modules

#$(util/texinfo-insert-doc get-stella-context)
#$(util/texinfo-insert-doc clear-context)
#$(util/texinfo-insert-doc within-context)
#$(util/texinfo-insert-doc CONTEXT.destroy-context)
#$(util/texinfo-insert-doc STRING.destroy-context)
#$(util/texinfo-insert-doc CONTEXT.change-context)
#$(util/texinfo-insert-doc STRING.change-context)
#$(util/texinfo-insert-doc cc)
#$(util/texinfo-insert-doc defmodule)
#$(util/texinfo-insert-doc get-stella-module)
#$(util/texinfo-insert-doc find-or-create-module)
#$(util/texinfo-insert-doc clear-module)
#$(util/texinfo-insert-doc destroy-module)
#$(util/texinfo-insert-doc MODULE.destroy-context)
#$(util/texinfo-insert-doc visible-modules)
#$(util/texinfo-insert-doc within-module)
#$(util/texinfo-insert-doc in-module)
#$(util/texinfo-insert-doc MODULE.change-module)
#$(util/texinfo-insert-doc STRING.change-module)
#$(util/texinfo-insert-doc create-world)
#$(util/texinfo-insert-doc push-world)
#$(util/texinfo-insert-doc pop-world)
#$(util/texinfo-insert-doc WORLD.destroy-context)
#$(util/texinfo-insert-doc within-world)

@c ---------------------------------------------------------------------------

@node Input and Output, Files, Contexts and Modules, Library Functions
@section Input and Output 

#$(util/texinfo-insert-doc read-s-expression)
#$(util/texinfo-insert-doc read-s-expression-from-string)
#$(util/texinfo-insert-doc read-line)
#$(util/texinfo-insert-doc read-character)
#$(util/texinfo-insert-doc unread-character)
#$(util/texinfo-insert-doc y-or-n?)
#$(util/texinfo-insert-doc yes-or-no?)
#$(util/texinfo-insert-doc flush-output)

@c ---------------------------------------------------------------------------

@node Files, Dates and Times, Input and Output, Library Functions
@section Files

#$(util/texinfo-insert-doc open-input-file)
#$(util/texinfo-insert-doc open-output-file)
#$(util/texinfo-insert-doc close-stream)
#$(util/texinfo-insert-doc close-all-files)
#$(util/texinfo-insert-doc with-input-file)
#$(util/texinfo-insert-doc with-output-file)
#$(util/texinfo-insert-doc probe-file?)
#$(util/texinfo-insert-doc file-write-date)
#$(util/texinfo-insert-doc file-length)
#$(util/texinfo-insert-doc copy-file)
#$(util/texinfo-insert-doc delete-file)
#$(util/texinfo-insert-doc directory-file-name)
#$(util/texinfo-insert-doc directory-parent-directory)
#$(util/texinfo-insert-doc file-name-as-directory)
#$(util/texinfo-insert-doc file-name-directory)
#$(util/texinfo-insert-doc file-name-without-directory)
#$(util/texinfo-insert-doc file-name-without-extension)
#$(util/texinfo-insert-doc file-extension)
#$(util/texinfo-insert-doc file-base-name)
#$(util/texinfo-insert-doc absolute-pathname?)
#$(util/texinfo-insert-doc logical-host?)
#$(util/texinfo-insert-doc logical-pathname?)
#$(util/texinfo-insert-doc translate-logical-pathname)
#$(util/texinfo-insert-doc directory-separator)
#$(util/texinfo-insert-doc directory-separator-string)

@c ---------------------------------------------------------------------------

@node Dates and Times, XML Support, Files, Library Functions
@section Dates and Times

#$(util/texinfo-insert-doc get-current-date-time)
#$(util/texinfo-insert-doc get-local-time-zone)
@c # $(util/texinfo-insert-doc FLOAT.get-calendar-date)
@c # $(util/texinfo-insert-doc FLOAT.get-time)
#$(util/texinfo-insert-doc make-current-date-time)
#$(util/texinfo-insert-doc make-date-time)
#$(util/texinfo-insert-doc parse-date-time)
#$(util/texinfo-insert-doc CALENDAR-DATE.decode-calendar-date)
#$(util/texinfo-insert-doc DECODED-DATE-TIME.encode-calendar-date)
#$(util/texinfo-insert-doc calendar-date-to-string)
#$(util/texinfo-insert-doc string-to-calendar-date)
#$(util/texinfo-insert-doc relative-date-to-string)
#$(util/texinfo-insert-doc compute-calendar-date)
#$(util/texinfo-insert-doc compute-day-of-week)
#$(util/texinfo-insert-doc compute-day-of-week-julian)
#$(util/texinfo-insert-doc compute-julian-day)
#$(util/texinfo-insert-doc compute-next-moon-phase)
#$(util/texinfo-insert-doc decode-time-in-millis)
#$(util/texinfo-insert-doc julian-day-to-modified-julian-day)
#$(util/texinfo-insert-doc modified-julian-day-to-julian-day)
#$(util/texinfo-insert-doc time-add)
#$(util/texinfo-insert-doc time-divide)
#$(util/texinfo-insert-doc time-multiply)
#$(util/texinfo-insert-doc time-subtract)
#$(util/texinfo-insert-doc get-ticktock)
#$(util/texinfo-insert-doc ticktock-difference)
#$(util/texinfo-insert-doc ticktock-resolution)
#$(util/texinfo-insert-doc sleep)

@c ---------------------------------------------------------------------------

@node XML Support, Miscellaneous, Dates and Times, Library Functions
@section XML Support

#$(util/texinfo-insert-doc make-xml-element)
#$(util/texinfo-insert-doc make-xml-global-attribute)
#$(util/texinfo-insert-doc make-xml-local-attribute)
#$(util/texinfo-insert-doc get-xml-tag)
#$(util/texinfo-insert-doc get-xml-attributes)
#$(util/texinfo-insert-doc get-xml-content)
#$(util/texinfo-insert-doc get-xml-cdata-content)
#$(util/texinfo-insert-doc xml-declaration?)
#$(util/texinfo-insert-doc xml-element?)
#$(util/texinfo-insert-doc xml-attribute?)
#$(util/texinfo-insert-doc xml-cdata?)
#$(util/texinfo-insert-doc xml-cdata-form?)
#$(util/texinfo-insert-doc XML-ELEMENT.xml-element-match?)
#$(util/texinfo-insert-doc XML-ATTRIBUTE.xml-attribute-match?)
#$(util/texinfo-insert-doc XML-GLOBAL-ATTRIBUTE.xml-attribute-match?)
#$(util/texinfo-insert-doc XML-LOCAL-ATTRIBUTE.xml-attribute-match?)
#$(util/texinfo-insert-doc xml-local-attribute-match?)
#$(util/texinfo-insert-doc xml-lookup-attribute)
#$(util/texinfo-insert-doc xml-tag-case)
@c # $(util/texinfo-insert-doc xml-token-list-to-s-expression)
#$(util/texinfo-insert-doc read-xml-expression)
#$(util/texinfo-insert-doc xml-expressions)
#$(util/texinfo-insert-doc print-xml-expression)
#$(util/texinfo-insert-doc reset-xml-hash-tables)

@c ---------------------------------------------------------------------------

@node Miscellaneous,  , XML Support, Library Functions
@section Miscellaneous

This is a catch-all section for functions and methods that haven't been
categorized yet into any of the previous sections.  They are in random
order and many of them will never be part of the official STELLA
interface.  So beware!

#$(util/texinfo-insert-doc operating-system)
#$(util/texinfo-insert-doc "/STELLA")

@c ===========================================================================

@node Function Index, Variable Index, Library Functions, Top
@comment  node-name,  next,  previous,  up
@unnumbered Function Index

@printindex fn

@c ---------------------------------------------------------------------------

@node Variable Index, Concept Index, Function Index, Top
@comment  node-name,  next,  previous,  up
@unnumbered Variable Index

@printindex vr

@c ---------------------------------------------------------------------------

@node Concept Index,  , Variable Index, Top
@comment  node-name,  next,  previous,  up
@unnumbered Concept Index

@printindex cp

@c ===========================================================================

@bye

Notes:
 - don't fiddle with nodes and menus before the overall structure isn't
   pretty much determined (can run makeinfo even without nodes)

 - to insert node lines with the titles taken from the sections do
   `C-x h C-u M-x texinfo-insert-node-lines'

 - to link all the nodes do `M-x texinfo-every-node-update'

 - then create/update menus with `M-x texinfo-all-menus-update'

 - node names have to be unique

 - node names should be short, keep details in their explanations -
   this makes the menus look better
