<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<!-- Created on May, 21  2006 by texi2html 1.65 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>STELLA Manual: Library Functions</TITLE>

<META NAME="description" CONTENT="STELLA Manual: Library Functions">
<META NAME="keywords" CONTENT="STELLA Manual: Library Functions">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.65">

</HEAD>

<BODY LANG="en" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC30"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_5.html#SEC29"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC31"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_5.html#SEC29"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 6. Library Functions </H1>
<!--docid::SEC30::-->
<P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC31">6.1 Basic Constants and Predicates</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC32">6.2 Numbers</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC33">6.3 Characters</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC34">6.4 Strings</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC35">6.5 <CODE>CONS</CODE> Lists and Trees</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC37">6.6 Lists</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC39">6.7 Property and Key-Value Lists</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC40">6.8 Vectors</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC41">6.9 Hash Tables</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC42">6.10 Key Value Maps</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC43">6.11 Hash Sets</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC44">6.12 Iterators</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC45">6.13 Symbols</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC46">6.14 Context and Modules</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC47">6.15 Input and Output</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC48">6.16 Files</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC49">6.17 Dates and Times</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC50">6.18 XML Support</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC51">6.19 Miscellaneous</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Basic Constants and Predicates"></A>
<HR SIZE="6">
<A NAME="SEC31"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC32"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.1 Basic Constants and Predicates </H2>
<!--docid::SEC31::-->
<P>

<A NAME="IDX8"></A>
<DL>
<DT><U>???:</U> <B>true</B>
<DD>Not yet implemented.
</DL>
</P><P>

<A NAME="IDX9"></A>
<DL>
<DT><U>???:</U> <B>false</B>
<DD>Not yet implemented.
</DL>
</P><P>

<A NAME="IDX10"></A>
<DL>
<DT><U>Method:</U> OBJECT <B>null?</B> <I>(x) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is undefined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX11"></A>
<DL>
<DT><U>Method:</U> SECOND-CLASS-OBJECT <B>null?</B> <I>(x) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is undefined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX12"></A>
<DL>
<DT><U>Method:</U> NATIVE-VECTOR <B>null?</B> <I>(x) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is undefined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX13"></A>
<DL>
<DT><U>Method:</U> STRING <B>null?</B> <I>(x) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is undefined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX14"></A>
<DL>
<DT><U>Method:</U> MUTABLE-STRING <B>null?</B> <I>(x) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is undefined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX15"></A>
<DL>
<DT><U>Method:</U> CHARACTER <B>null?</B> <I>(x) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is undefined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX16"></A>
<DL>
<DT><U>Method:</U> CODE <B>null?</B> <I>(x) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is undefined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX17"></A>
<DL>
<DT><U>Method:</U> INTEGER <B>null?</B> <I>(x) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is undefined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX18"></A>
<DL>
<DT><U>Method:</U> FLOAT <B>null?</B> <I>(x) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is undefined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX19"></A>
<DL>
<DT><U>Method:</U> OBJECT <B>defined?</B> <I>(x) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is defined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX20"></A>
<DL>
<DT><U>Method:</U> SECOND-CLASS-OBJECT <B>defined?</B> <I>(x) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is defined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX21"></A>
<DL>
<DT><U>Method:</U> NATIVE-VECTOR <B>defined?</B> <I>(x) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is defined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX22"></A>
<DL>
<DT><U>Method:</U> STRING <B>defined?</B> <I>(x) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is defined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX23"></A>
<DL>
<DT><U>Method:</U> MUTABLE-STRING <B>defined?</B> <I>(x) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is defined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX24"></A>
<DL>
<DT><U>Method:</U> CHARACTER <B>defined?</B> <I>(x) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is defined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX25"></A>
<DL>
<DT><U>Method:</U> CODE <B>defined?</B> <I>(x) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is defined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX26"></A>
<DL>
<DT><U>Method:</U> INTEGER <B>defined?</B> <I>(x) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is defined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX27"></A>
<DL>
<DT><U>Method:</U> FLOAT <B>defined?</B> <I>(x) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is defined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX28"></A>
<DL>
<DT><U>Function:</U> <B>eq?</B> <I>((x UNKNOWN) (y UNKNOWN)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> and <VAR>y</VAR> are literally the same object (or
simple number).  Analogue to the Common Lisp EQL and C++ and Java's ==.
</DL>
</P><P>

<A NAME="IDX29"></A>
<DL>
<DT><U>Function:</U> <B>eql?</B> <I>((x OBJECT) (y OBJECT)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> and <VAR>y</VAR> are <CODE>eq?</CODE> or equivalent literals
such as strings that also might be wrapped in non-identical wrappers.  For
the case where <VAR>x</VAR> or <VAR>y</VAR> are plain literals such as strings or integers, the
STELLA translator substitutes the equality test appropriate for the particular
target language and does not actually call this function.  For cases where
<VAR>x</VAR> or <VAR>y</VAR> are known to be of type STANDARD-OBJECT, the STELLA translator
substitutes the faster <CODE>eq?</CODE> test inline.
</DL>
</P><P>

<A NAME="IDX30"></A>
<DL>
<DT><U>Function:</U> <B>equal?</B> <I>((x OBJECT) (y OBJECT)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> and <VAR>y</VAR> are <CODE>eql?</CODE> or considered equal
by a user-defined <CODE>object-equal?</CODE> method.  This implements a fully extensible
equality test similar to Java's <CODE>equals</CODE> method.  Note that writers of custom
<CODE>object-equal?</CODE> methods must also implement a corresponding <CODE>equal-hash-code</CODE>
method.
</DL>
</P><P>

<A NAME="IDX31"></A>
<DL>
<DT><U>Method:</U> OBJECT <B>object-equal?</B> <I>(x (y OBJECT)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> and <VAR>y</VAR> are <CODE>eq?</CODE>.
</DL>
</P><P>

<A NAME="IDX32"></A>
<DL>
<DT><U>Method:</U> WRAPPER <B>object-equal?</B> <I>(x (y OBJECT)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> and <VAR>y</VAR> are literal wrappers whose
literals are considered <CODE>eql?</CODE>.
</DL>
</P><P>

<A NAME="Numbers"></A>
<HR SIZE="6">
<A NAME="SEC32"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC31"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC33"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.2 Numbers </H2>
<!--docid::SEC32::-->
<P>

<A NAME="IDX33"></A>
<DL>
<DT><U>Constant:</U> <B>pi</B> <I>: FLOAT</I>
<DD>A float approximation of the mathematical constant pi.
</DL>
</P><P>

<A NAME="IDX34"></A>
<DL>
<DT><U>Function:</U> <B>+</B> <I>(&#38;rest (arguments NUMBER)) : NUMBER</I>
<DD>Return the sum of all <VAR>arguments</VAR>.
</DL>
</P><P>

<A NAME="IDX35"></A>
<DL>
<DT><U>Function:</U> <B>-</B> <I>((x NUMBER) &#38;rest (arguments NUMBER)) : NUMBER</I>
<DD>If only <VAR>x</VAR> was supplied return the result of 0 - <VAR>x</VAR>.
Otherwise, return the result of (...((<VAR>x</VAR> - arg1) - arg2) - ... - argN).
</DL>
</P><P>

<A NAME="IDX36"></A>
<DL>
<DT><U>Function:</U> <B>*</B> <I>(&#38;rest (arguments NUMBER)) : NUMBER</I>
<DD>Return the product of all <VAR>arguments</VAR>.
</DL>
</P><P>

<A NAME="IDX37"></A>
<DL>
<DT><U>Function:</U> <B>/</B> <I>((x NUMBER) &#38;rest (arguments NUMBER)) : NUMBER</I>
<DD>If only <VAR>x</VAR> was supplied return the result of 1 / <VAR>x</VAR>.
Otherwise, return the result of (...((<VAR>x</VAR> / arg1) / arg2 ) / ... / argN).
</DL>
</P><P>

<A NAME="IDX38"></A>
<DL>
<DT><U>Macro:</U> <B>1+</B> <I>((expression OBJECT)) : OBJECT</I>
<DD>Add 1 to <VAR>expression</VAR> and return the result.
</DL>
</P><P>

<A NAME="IDX39"></A>
<DL>
<DT><U>Macro:</U> <B>1-</B> <I>((expression OBJECT)) : OBJECT</I>
<DD>Subtract 1 from <VAR>expression</VAR> and return the result.
</DL>
</P><P>

<A NAME="IDX40"></A>
<DL>
<DT><U>Macro:</U> <B>++</B> <I>((place OBJECT) &#38;body (increment CONS)) : OBJECT</I>
<DD>Increment the value of <VAR>place</VAR> and return the result.
<VAR>place</VAR> can be either a variable name or a slot reference.  Increment by
the optional <VAR>increment</VAR> (which can be a float) or 1 otherwise.
</DL>
</P><P>

<A NAME="IDX41"></A>
<DL>
<DT><U>Macro:</U> <B>--</B> <I>((place OBJECT) &#38;body (decrement CONS)) : OBJECT</I>
<DD>Decrement the value of <VAR>place</VAR> and return the result.
<VAR>place</VAR> can be either a variable name or a slot reference.  Decrement by
the optional <VAR>decrement</VAR> (which can be a float) or 1 otherwise.
</DL>
</P><P>

<A NAME="IDX42"></A>
<DL>
<DT><U>Function:</U> <B>=</B> <I>((x NUMBER) (y NUMBER)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> and <VAR>y</VAR> are numbers of exactly the same magnitude.
</DL>
</P><P>

<A NAME="IDX43"></A>
<DL>
<DT><U>Function:</U> <B>&#60;</B> <I>((x NUMBER) (y NUMBER)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is less than <VAR>y</VAR>.
</DL>
</P><P>

<A NAME="IDX44"></A>
<DL>
<DT><U>Function:</U> <B>&#60;=</B> <I>((x NUMBER) (y NUMBER)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is less than or equal to <VAR>y</VAR>.
</DL>
</P><P>

<A NAME="IDX45"></A>
<DL>
<DT><U>Function:</U> <B>&#62;=</B> <I>((x NUMBER) (y NUMBER)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is greater than or equal to <VAR>y</VAR>.
</DL>
</P><P>

<A NAME="IDX46"></A>
<DL>
<DT><U>Function:</U> <B>&#62;</B> <I>((x NUMBER) (y NUMBER)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is greater than <VAR>y</VAR>.
</DL>
</P><P>

<A NAME="IDX47"></A>
<DL>
<DT><U>Function:</U> <B>zero?</B> <I>((x INTEGER)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is 0.
</DL>
</P><P>

<A NAME="IDX48"></A>
<DL>
<DT><U>Function:</U> <B>plus?</B> <I>((x INTEGER)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is greater than 0.
</DL>
</P><P>

<A NAME="IDX49"></A>
<DL>
<DT><U>Function:</U> <B>even?</B> <I>((x INTEGER)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is an even number.
</DL>
</P><P>

<A NAME="IDX50"></A>
<DL>
<DT><U>Function:</U> <B>odd?</B> <I>((x INTEGER)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is an odd number.
</DL>
</P><P>

<A NAME="IDX51"></A>
<DL>
<DT><U>Function:</U> <B>div</B> <I>((x INTEGER) (y INTEGER)) : INTEGER</I>
<DD>Return the integer quotient from dividing <VAR>x</VAR> by <VAR>y</VAR>.
</DL>
</P><P>

<A NAME="IDX52"></A>
<DL>
<DT><U>Function:</U> <B>rem</B> <I>((x INTEGER) (y INTEGER)) : INTEGER</I>
<DD>Return the remainder from dividing <VAR>x</VAR> by <VAR>y</VAR>.  The
sign of the result is always the same as the sign of <VAR>x</VAR>.  This has slightly
different behavior than the <CODE>mod</CODE> function, and has less overhead in C++ and
Java, which don't have direct support for a true modulus function.
</DL>
</P><P>

<A NAME="IDX53"></A>
<DL>
<DT><U>Function:</U> <B>mod</B> <I>((x INTEGER) (modulus INTEGER)) : INTEGER</I>
<DD>True modulus.  Return the result of <VAR>x</VAR> mod <CODE>modulo</CODE>.
Note: In C++ and Java, <CODE>mod</CODE> has more overhead than the similar
function <CODE>rem</CODE>.  The  answers returned by <CODE>mod</CODE> and <CODE>rem</CODE> are only
different when the signs of <VAR>x</VAR> and <CODE>modulo</CODE> are different.
</DL>
</P><P>

<A NAME="IDX54"></A>
<DL>
<DT><U>Function:</U> <B>gcd</B> <I>((x INTEGER) (y INTEGER)) : INTEGER</I>
<DD>Return the greatest common divisor of <VAR>x</VAR> and <VAR>y</VAR>.
</DL>
</P><P>

<A NAME="IDX55"></A>
<DL>
<DT><U>Function:</U> <B>ceiling</B> <I>((n NUMBER)) : INTEGER</I>
<DD>Return the smallest integer &#62;= <VAR>n</VAR>.
</DL>
</P><P>

<A NAME="IDX56"></A>
<DL>
<DT><U>Function:</U> <B>floor</B> <I>((n NUMBER)) : INTEGER</I>
<DD>Return the biggest integer &#60;= <VAR>n</VAR>.
</DL>
</P><P>

<A NAME="IDX57"></A>
<DL>
<DT><U>Function:</U> <B>round</B> <I>((n NUMBER)) : INTEGER</I>
<DD>Round <VAR>n</VAR> to the closest integer and return the result.
</DL>
</P><P>

<A NAME="IDX58"></A>
<DL>
<DT><U>Method:</U> INTEGER <B>abs</B> <I>(x) : INTEGER</I>
<DD>Return the absolute value of <VAR>x</VAR>.
</DL>
</P><P>

<A NAME="IDX59"></A>
<DL>
<DT><U>Method:</U> FLOAT <B>abs</B> <I>(x) : FLOAT</I>
<DD>Return the absolute value of <VAR>x</VAR>.
</DL>
</P><P>

<A NAME="IDX60"></A>
<DL>
<DT><U>Function:</U> <B>min</B> <I>((x INTEGER) (y INTEGER)) : INTEGER</I>
<DD>Return the minimum of <VAR>x</VAR> and <VAR>y</VAR>.  If either is NULL, return the other.
</DL>
</P><P>

<A NAME="IDX61"></A>
<DL>
<DT><U>Function:</U> <B>max</B> <I>((x INTEGER) (y INTEGER)) : INTEGER</I>
<DD>Return the maximum of <VAR>x</VAR> and <VAR>y</VAR>.  If either is NULL, return the other.
</DL>
</P><P>

<A NAME="IDX62"></A>
<DL>
<DT><U>Function:</U> <B>sqrt</B> <I>((n FLOAT)) : FLOAT</I>
<DD>Return the square root of <VAR>n</VAR>.
</DL>
</P><P>

<A NAME="IDX63"></A>
<DL>
<DT><U>Function:</U> <B>exp</B> <I>((n FLOAT)) : FLOAT</I>
<DD>Return the e to the power <VAR>n</VAR>.
</DL>
</P><P>

<A NAME="IDX64"></A>
<DL>
<DT><U>Function:</U> <B>expt</B> <I>((x FLOAT) (y FLOAT)) : FLOAT</I>
<DD>Return <VAR>x</VAR> ^ <VAR>y</VAR>.
</DL>
</P><P>

<A NAME="IDX65"></A>
<DL>
<DT><U>Function:</U> <B>log</B> <I>((n FLOAT)) : FLOAT</I>
<DD>Return the natural logarithm (base e) of <VAR>n</VAR>.
</DL>
</P><P>

<A NAME="IDX66"></A>
<DL>
<DT><U>Function:</U> <B>log10</B> <I>((n FLOAT)) : FLOAT</I>
<DD>Return the logarithm (base 10) of <VAR>n</VAR>.
</DL>
</P><P>

<A NAME="IDX67"></A>
<DL>
<DT><U>Function:</U> <B>sin</B> <I>((n FLOAT)) : FLOAT</I>
<DD>Return the sine of <VAR>n</VAR> radians.
</DL>
</P><P>

<A NAME="IDX68"></A>
<DL>
<DT><U>Function:</U> <B>cos</B> <I>((n FLOAT)) : FLOAT</I>
<DD>Return the cosine of <VAR>n</VAR> radians.
</DL>
</P><P>

<A NAME="IDX69"></A>
<DL>
<DT><U>Function:</U> <B>tan</B> <I>((n FLOAT)) : FLOAT</I>
<DD>Return the tangent of <VAR>n</VAR> radians.
</DL>
</P><P>

<A NAME="IDX70"></A>
<DL>
<DT><U>Function:</U> <B>asin</B> <I>((n FLOAT)) : FLOAT</I>
<DD>Return the arcsine of <VAR>n</VAR> in radians.
</DL>
</P><P>

<A NAME="IDX71"></A>
<DL>
<DT><U>Function:</U> <B>acos</B> <I>((n FLOAT)) : FLOAT</I>
<DD>Return the arccosine of <VAR>n</VAR> in radians.
</DL>
</P><P>

<A NAME="IDX72"></A>
<DL>
<DT><U>Function:</U> <B>atan</B> <I>((n FLOAT)) : FLOAT</I>
<DD>Return the arc tangent of <VAR>n</VAR> in radians.
</DL>
</P><P>

<A NAME="IDX73"></A>
<DL>
<DT><U>Function:</U> <B>atan2</B> <I>((x FLOAT) (y FLOAT)) : FLOAT</I>
<DD>Return the arc tangent of <VAR>x</VAR> / <VAR>y</VAR> in radians.
</DL>
</P><P>

<A NAME="IDX74"></A>
<DL>
<DT><U>Function:</U> <B>random</B> <I>((n INTEGER)) : INTEGER</I>
<DD>Generate a random integer in the interval [0..n-1].
</DL>
</P><P>

<A NAME="IDX75"></A>
<DL>
<DT><U>Function:</U> <B>integer-to-string</B> <I>((i INTEGER)) : STRING</I>
<DD>Convert <VAR>i</VAR> to its string representation and return the result.
 This is more efficient than using a string stream.
</DL>
</P><P>

<A NAME="IDX76"></A>
<DL>
<DT><U>Function:</U> <B>string-to-integer</B> <I>((string STRING)) : INTEGER</I>
<DD>Convert a <VAR>string</VAR> representation of an integer into an integer.
</DL>
</P><P>

<A NAME="IDX77"></A>
<DL>
<DT><U>Function:</U> <B>float-to-string</B> <I>((f FLOAT)) : STRING</I>
<DD>Convert <VAR>f</VAR> to its string representation and return the result.  This is more
efficient than using a string stream.
</DL>
</P><P>

<A NAME="IDX78"></A>
<DL>
<DT><U>Function:</U> <B>string-to-float</B> <I>((string STRING)) : FLOAT</I>
<DD>Convert a <VAR>string</VAR> representation of a float into a float.
</DL>
</P><P>

<A NAME="IDX79"></A>
<DL>
<DT><U>Function:</U> <B>format-float</B> <I>((f FLOAT) (nDecimals INTEGER)) : STRING</I>
<DD>Print <VAR>f</VAR> in fixed-point format with <VAR>nDecimals</VAR> behind the decimal point
and return the result as a string.
</DL>
</P><P>

<A NAME="IDX80"></A>
<DL>
<DT><U>Function:</U> <B>wrap-integer</B> <I>((value INTEGER)) : INTEGER-WRAPPER</I>
<DD>Return a literal object whose value is the INTEGER <VAR>value</VAR>.
</DL>
</P><P>

<A NAME="IDX81"></A>
<DL>
<DT><U>Function:</U> <B>unwrap-integer</B> <I>((wrapper INTEGER-WRAPPER)) : INTEGER</I>
<DD>Unwrap <VAR>wrapper</VAR> and return the result.
Return NULL if <VAR>wrapper</VAR> is NULL.
</DL>
</P><P>

<A NAME="IDX82"></A>
<DL>
<DT><U>Function:</U> <B>wrap-float</B> <I>((value FLOAT)) : FLOAT-WRAPPER</I>
<DD>Return a literal object whose value is the FLOAT <VAR>value</VAR>.
</DL>
</P><P>

<A NAME="IDX83"></A>
<DL>
<DT><U>Function:</U> <B>unwrap-float</B> <I>((wrapper FLOAT-WRAPPER)) : FLOAT</I>
<DD>Unwrap <VAR>wrapper</VAR> and return the result.
Return NULL if <VAR>wrapper</VAR> is NULL.
</DL>
</P><P>

<A NAME="Characters"></A>
<HR SIZE="6">
<A NAME="SEC33"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC32"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC34"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.3 Characters </H2>
<!--docid::SEC33::-->
<P>

<A NAME="IDX84"></A>
<DL>
<DT><U>Function:</U> <B>character-code</B> <I>((ch CHARACTER)) : INTEGER</I>
<DD>Return the 8-bit ASCII code of <VAR>ch</VAR> as an integer.
</DL>
</P><P>

<A NAME="IDX85"></A>
<DL>
<DT><U>Function:</U> <B>code-character</B> <I>((code INTEGER)) : CHARACTER</I>
<DD>Return the character encoded by <VAR>code</VAR> (0 &#60;= <VAR>code</VAR> &#60;= 255).
</DL>
</P><P>

<A NAME="IDX86"></A>
<DL>
<DT><U>Function:</U> <B>digit-character?</B> <I>((ch CHARACTER)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>ch</VAR> represents a digit.
</DL>
</P><P>

<A NAME="IDX87"></A>
<DL>
<DT><U>Function:</U> <B>letter-character?</B> <I>((ch CHARACTER)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>ch</VAR> represents a letter.
</DL>
</P><P>

<A NAME="IDX88"></A>
<DL>
<DT><U>Function:</U> <B>upper-case-character?</B> <I>((ch CHARACTER)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>ch</VAR> represents an upper-case character.
</DL>
</P><P>

<A NAME="IDX89"></A>
<DL>
<DT><U>Function:</U> <B>lower-case-character?</B> <I>((ch CHARACTER)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>ch</VAR> represents a lower-case character.
</DL>
</P><P>

<A NAME="IDX90"></A>
<DL>
<DT><U>Function:</U> <B>white-space-character?</B> <I>((ch CHARACTER)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>ch</VAR> is a white space character.
</DL>
</P><P>

<A NAME="IDX91"></A>
<DL>
<DT><U>Function:</U> <B>character-downcase</B> <I>((ch CHARACTER)) : CHARACTER</I>
<DD>If <VAR>ch</VAR> is lowercase, return its uppercase version,
otherwise, return <VAR>ch</VAR> unmodified.
</DL>
</P><P>

<A NAME="IDX92"></A>
<DL>
<DT><U>Function:</U> <B>character-upcase</B> <I>((ch CHARACTER)) : CHARACTER</I>
<DD>If <VAR>ch</VAR> is uppercase, return its lowercase version,
otherwise, return <VAR>ch</VAR> unmodified.  If only the first character of
a sequence of characters is to be capitalized, <CODE>character-capitalize</CODE>
should be used instead.
</DL>
</P><P>

<A NAME="IDX93"></A>
<DL>
<DT><U>Function:</U> <B>character-capitalize</B> <I>((ch CHARACTER)) : CHARACTER</I>
<DD>Return the capitalized character for <VAR>ch</VAR>.  This is generally the same
as the uppercase character, except for obscure non-English characters in Java.  It should
be used if only the first character of a sequence of characters is to be capitalized.
</DL>
</P><P>

<A NAME="IDX94"></A>
<DL>
<DT><U>Function:</U> <B>character-to-string</B> <I>((c CHARACTER)) : STRING</I>
<DD>Convert <VAR>c</VAR> into a one-element string and return the result.
</DL>
</P><P>

<A NAME="IDX95"></A>
<DL>
<DT><U>Function:</U> <B>wrap-character</B> <I>((value CHARACTER)) : CHARACTER-WRAPPER</I>
<DD>Return a literal object whose value is the CHARACTER <VAR>value</VAR>.
</DL>
</P><P>

<A NAME="IDX96"></A>
<DL>
<DT><U>Function:</U> <B>unwrap-character</B> <I>((wrapper CHARACTER-WRAPPER)) : CHARACTER</I>
<DD>Unwrap <VAR>wrapper</VAR> and return the result.
Return NULL if <VAR>wrapper</VAR> is NULL.
</DL>
</P><P>

<A NAME="Strings"></A>
<HR SIZE="6">
<A NAME="SEC34"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC33"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC35"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.4 Strings </H2>
<!--docid::SEC34::-->
<P>

<A NAME="IDX97"></A>
<DL>
<DT><U>Function:</U> <B>string-eql?</B> <I>((x STRING) (y STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> and <VAR>y</VAR> are equal strings or are both undefined.  This
test is substituted automatically by the STELLA translator if <CODE>eql?</CODE> is applied
to strings.
</DL>
</P><P>

<A NAME="IDX98"></A>
<DL>
<DT><U>Function:</U> <B>string-equal?</B> <I>((x STRING) (y STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> and <VAR>y</VAR> are equal strings ignoring character case or
are both undefined.
</DL>
</P><P>

<A NAME="IDX99"></A>
<DL>
<DT><U>Method:</U> STRING <B>empty?</B> <I>(x) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is the empty string ""
</DL>
</P><P>

<A NAME="IDX100"></A>
<DL>
<DT><U>Method:</U> STRING <B>non-empty?</B> <I>(x) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is not the empty string ""
</DL>
</P><P>

<A NAME="IDX101"></A>
<DL>
<DT><U>Function:</U> <B>string-compare</B> <I>((x STRING) (y STRING) (case-sensitive? BOOLEAN)) : INTEGER</I>
<DD>Compare <VAR>x</VAR> and <VAR>y</VAR> lexicographically, and return -1, 0, 
or 1, depending on whether <VAR>x</VAR> is less than, equal, or greater than <VAR>y</VAR>.
If <VAR>case-sensitive?</VAR> is true, then case does matter for the comparison
</DL>
</P><P>

<A NAME="IDX102"></A>
<DL>
<DT><U>Function:</U> <B>string&#60;</B> <I>((x STRING) (y STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is lexicographically &#60; <VAR>y</VAR>, considering case.
</DL>
</P><P>

<A NAME="IDX103"></A>
<DL>
<DT><U>Function:</U> <B>string&#60;=</B> <I>((x STRING) (y STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is lexicographically &#60;= <VAR>y</VAR>, considering case.
</DL>
</P><P>

<A NAME="IDX104"></A>
<DL>
<DT><U>Function:</U> <B>string&#62;=</B> <I>((x STRING) (y STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is lexicographically &#62;= <VAR>y</VAR>, considering case.
</DL>
</P><P>

<A NAME="IDX105"></A>
<DL>
<DT><U>Function:</U> <B>string&#62;</B> <I>((x STRING) (y STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is lexicographically &#62; <VAR>y</VAR>, considering case.
</DL>
</P><P>

<A NAME="IDX106"></A>
<DL>
<DT><U>Function:</U> <B>string-less?</B> <I>((x STRING) (y STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is lexicographically &#60; <VAR>y</VAR>, ignoring case.
</DL>
</P><P>

<A NAME="IDX107"></A>
<DL>
<DT><U>Function:</U> <B>string-less-equal?</B> <I>((x STRING) (y STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is lexicographically &#60;= <VAR>y</VAR>, ignoring case.
</DL>
</P><P>

<A NAME="IDX108"></A>
<DL>
<DT><U>Function:</U> <B>string-greater-equal?</B> <I>((x STRING) (y STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is lexicographically &#62;= <VAR>y</VAR>, ignoring case.
</DL>
</P><P>

<A NAME="IDX109"></A>
<DL>
<DT><U>Function:</U> <B>string-greater?</B> <I>((x STRING) (y STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is lexicographically &#62; <VAR>y</VAR>, ignoring case.
</DL>
</P><P>

<A NAME="IDX110"></A>
<DL>
<DT><U>Function:</U> <B>all-upper-case-string?</B> <I>((s STRING)) : BOOLEAN</I>
<DD>Return TRUE if all letters in <VAR>s</VAR> are upper case.
</DL>
</P><P>

<A NAME="IDX111"></A>
<DL>
<DT><U>Function:</U> <B>all-lower-case-string?</B> <I>((s STRING)) : BOOLEAN</I>
<DD>Return TRUE if all letters in <VAR>s</VAR> are lower case.
</DL>
</P><P>

<A NAME="IDX112"></A>
<DL>
<DT><U>Function:</U> <B>make-string</B> <I>((size INTEGER) (initchar CHARACTER)) : STRING</I>
<DD>Return a new string filled with <VAR>size</VAR> <VAR>initchar</VAR>s.
</DL>
</P><P>

<A NAME="IDX113"></A>
<DL>
<DT><U>Function:</U> <B>make-mutable-string</B> <I>((size INTEGER) (initchar CHARACTER)) : MUTABLE-STRING</I>
<DD>Return a new mutable string filled with <VAR>size</VAR> <VAR>initchar</VAR>s.
</DL>
</P><P>

<A NAME="IDX114"></A>
<DL>
<DT><U>Function:</U> <B>make-raw-mutable-string</B> <I>((size INTEGER)) : MUTABLE-STRING</I>
<DD>Return a new uninitialized mutable string of <VAR>size</VAR>.
</DL>
</P><P>

<A NAME="IDX115"></A>
<DL>
<DT><U>Method:</U> STRING <B>first</B> <I>(self) : CHARACTER</I>
<DD>Return the first character of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX116"></A>
<DL>
<DT><U>Method:</U> MUTABLE-STRING <B>first</B> <I>(self) : CHARACTER</I>
<DD>Return the first character of <VAR>self</VAR> (settable via <CODE>setf</CODE>).
</DL>
</P><P>

<A NAME="IDX117"></A>
<DL>
<DT><U>Method:</U> STRING <B>second</B> <I>(self) : CHARACTER</I>
<DD>Return the second character of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX118"></A>
<DL>
<DT><U>Method:</U> MUTABLE-STRING <B>second</B> <I>(self) : CHARACTER</I>
<DD>Return the second character of <VAR>self</VAR> (settable via <CODE>setf</CODE>).
</DL>
</P><P>

<A NAME="IDX119"></A>
<DL>
<DT><U>Method:</U> STRING <B>third</B> <I>(self) : CHARACTER</I>
<DD>Return the third character of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX120"></A>
<DL>
<DT><U>Method:</U> MUTABLE-STRING <B>third</B> <I>(self) : CHARACTER</I>
<DD>Return the third character of <VAR>self</VAR> (settable via <CODE>setf</CODE>).
</DL>
</P><P>

<A NAME="IDX121"></A>
<DL>
<DT><U>Method:</U> STRING <B>fourth</B> <I>(self) : CHARACTER</I>
<DD>Return the fourth character of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX122"></A>
<DL>
<DT><U>Method:</U> MUTABLE-STRING <B>fourth</B> <I>(self) : CHARACTER</I>
<DD>Return the fourth character of <VAR>self</VAR> (settable via <CODE>setf</CODE>).
</DL>
</P><P>

<A NAME="IDX123"></A>
<DL>
<DT><U>Method:</U> STRING <B>fifth</B> <I>(self) : CHARACTER</I>
<DD>Return the fifth character of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX124"></A>
<DL>
<DT><U>Method:</U> MUTABLE-STRING <B>fifth</B> <I>(self) : CHARACTER</I>
<DD>Return the fifth character of <VAR>self</VAR> (settable via <CODE>setf</CODE>).
</DL>
</P><P>

<A NAME="IDX125"></A>
<DL>
<DT><U>Method:</U> STRING <B>nth</B> <I>(self (position INTEGER)) : CHARACTER</I>
<DD>Return the character in <VAR>self</VAR> at <VAR>position</VAR>.
</DL>
</P><P>

<A NAME="IDX126"></A>
<DL>
<DT><U>Method:</U> MUTABLE-STRING <B>nth</B> <I>(self (position INTEGER)) : CHARACTER</I>
<DD>Return the character in <VAR>self</VAR> at <VAR>position</VAR>.
</DL>
</P><P>

<A NAME="IDX127"></A>
<DL>
<DT><U>Method:</U> STRING <B>rest</B> <I>(self) : STRING</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX128"></A>
<DL>
<DT><U>Method:</U> STRING <B>length</B> <I>(self) : INTEGER</I>
<DD>Return the length of the string <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX129"></A>
<DL>
<DT><U>Method:</U> MUTABLE-STRING <B>length</B> <I>(self) : INTEGER</I>
<DD>Return the length of the string <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX130"></A>
<DL>
<DT><U>Method:</U> STRING <B>member?</B> <I>(self (char CHARACTER)) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX131"></A>
<DL>
<DT><U>Method:</U> STRING <B>position</B> <I>(string (character CHARACTER) (start INTEGER)) : INTEGER</I>
<DD>Return the position of <VAR>character</VAR> within <VAR>string</VAR> (counting
from zero); or return NULL if <VAR>character</VAR> does not occur within <VAR>string</VAR>.
If <VAR>start</VAR> was supplied as non-NULL, only consider the substring starting
at <VAR>start</VAR>, however, the returned position will always be relative to the
entire string.
</DL>
</P><P>

<A NAME="IDX132"></A>
<DL>
<DT><U>Method:</U> STRING <B>last-position</B> <I>(string (character CHARACTER) (end INTEGER)) : INTEGER</I>
<DD>Return the last position of <VAR>character</VAR> within <VAR>string</VAR>
(counting from zero); or return NULL if <VAR>character</VAR> does not occur 
within <VAR>string</VAR>.  If <VAR>end</VAR> was supplied as non-NULL, only consider
the substring ending at <VAR>end</VAR>, however, the returned position will
always be relative to the entire string.
</DL>
</P><P>

<A NAME="IDX133"></A>
<DL>
<DT><U>Function:</U> <B>string-search</B> <I>((string STRING) (substring STRING) (start INTEGER)) : INTEGER</I>
<DD>Return start position of the left-most occurrence of
<VAR>substring</VAR> in <VAR>string</VAR>, beginning from <VAR>start</VAR>.  Return NULL if it is not
a substring.
</DL>
</P><P>

<A NAME="IDX134"></A>
<DL>
<DT><U>Method:</U> STRING <B>copy</B> <I>(string) : STRING</I>
<DD>Return a copy of <VAR>string</VAR>.
</DL>
</P><P>

<A NAME="IDX135"></A>
<DL>
<DT><U>Function:</U> <B>string-upcase</B> <I>((string STRING)) : STRING</I>
<DD>Return an upper-case copy of <VAR>string</VAR>.
</DL>
</P><P>

<A NAME="IDX136"></A>
<DL>
<DT><U>Function:</U> <B>string-downcase</B> <I>((string STRING)) : STRING</I>
<DD>Return a lower-case copy of <VAR>string</VAR>.
</DL>
</P><P>

<A NAME="IDX137"></A>
<DL>
<DT><U>Function:</U> <B>string-capitalize</B> <I>((string STRING)) : STRING</I>
<DD>Return a capitalized version of <VAR>string</VAR>.
</DL>
</P><P>

<A NAME="IDX138"></A>
<DL>
<DT><U>Method:</U> STRING <B>concatenate</B> <I>(string1 (string2 STRING) &#38;rest (otherStrings STRING)) : STRING</I>
<DD>Return a new string representing the concatenation
of <VAR>string1</VAR>, <VAR>string2</VAR>, and <VAR>otherStrings</VAR>.  The two mandatory parameters
allow us to optimize the common binary case by not relying on the somewhat
less efficient variable arguments mechanism.
</DL>
</P><P>

<A NAME="IDX139"></A>
<DL>
<DT><U>Method:</U> STRING <B>subsequence</B> <I>(string (start INTEGER) (end INTEGER)) : STRING</I>
<DD>Return a substring of <VAR>string</VAR> beginning at position <VAR>start</VAR>
and ending up to but not including position <VAR>end</VAR>, counting from zero.  An
<VAR>end</VAR> value of NULL stands for the rest of the string.
</DL>
</P><P>

<A NAME="IDX140"></A>
<DL>
<DT><U>Method:</U> STRING <B>remove</B> <I>(string (char CHARACTER)) : STRING</I>
<DD>Remove all occurences of <VAR>char</VAR> from <VAR>string</VAR>.
</DL>
</P><P>

<A NAME="IDX141"></A>
<DL>
<DT><U>Method:</U> STRING <B>substitute</B> <I>(self (new-char CHARACTER) (old-char CHARACTER)) : STRING</I>
<DD>Substitute all occurences of <VAR>old-char</VAR> with <VAR>new-char</VAR>
in the string <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX142"></A>
<DL>
<DT><U>Method:</U> MUTABLE-STRING <B>substitute</B> <I>(self (new-char CHARACTER) (old-char CHARACTER)) : MUTABLE-STRING</I>
<DD>Substitute all occurences of <VAR>old-char</VAR> with <VAR>new-char</VAR>
in the string <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX143"></A>
<DL>
<DT><U>Function:</U> <B>replace-substrings</B> <I>((string STRING) (new STRING) (old STRING)) : STRING</I>
<DD>Replace all occurrences of <VAR>old</VAR> in <VAR>string</VAR> with <VAR>new</VAR>.
</DL>
</P><P>

<A NAME="IDX144"></A>
<DL>
<DT><U>Function:</U> <B>instantiate-string-template</B> <I>((template STRING) &#38;rest (vars&#38;values STRING)) : STRING</I>
<DD>For each occurrence of a &#60;var&#62; string from <VAR>vars&#38;values</VAR> in <VAR>template</VAR> replace it
with its corresponding &#60;value&#62; string.  Replacement is done in sequence which
means (part of) a value might be replaced further with a later &#60;var&#62; and &#60;value&#62;.
</DL>
</P><P>

<A NAME="IDX145"></A>
<DL>
<DT><U>Function:</U> <B>insert-string</B> <I>((source STRING) (start INTEGER) (end INTEGER) (target MUTABLE-STRING) (target-index INTEGER) (case-conversion KEYWORD)) : INTEGER</I>
<DD>Inserts characters from <VAR>source</VAR> begining at <VAR>start</VAR> and
ending at <VAR>end</VAR> into <VAR>target</VAR> starting at <VAR>target-index</VAR>.  If <VAR>end</VAR> is <CODE>null</CODE>,
then the entire length of the string is used. The copy of characters is affected
by the <VAR>case-conversion</VAR> keyword which should be one of
   :UPCASE :DOWNCASE :CAPITALIZE :PRESERVE.
</P><P>

The final value of target-index is returned.
</DL>
</P><P>

<A NAME="IDX146"></A>
<DL>
<DT><U>Function:</U> <B>wrap-string</B> <I>((value STRING)) : STRING-WRAPPER</I>
<DD>Return a literal object whose value is the STRING <VAR>value</VAR>.
</DL>
</P><P>

<A NAME="IDX147"></A>
<DL>
<DT><U>Function:</U> <B>wrap-mutable-string</B> <I>((value MUTABLE-STRING)) : MUTABLE-STRING-WRAPPER</I>
<DD>Return a literal object whose value is the MUTABLE-STRING <VAR>value</VAR>.
</DL>
</P><P>

<A NAME="IDX148"></A>
<DL>
<DT><U>Function:</U> <B>unwrap-string</B> <I>((wrapper STRING-WRAPPER)) : STRING</I>
<DD>Unwrap <VAR>wrapper</VAR> and return the result.
Return NULL if <VAR>wrapper</VAR> is NULL.
</DL>
</P><P>

<A NAME="IDX149"></A>
<DL>
<DT><U>Function:</U> <B>unwrap-mutable-string</B> <I>((wrapper MUTABLE-STRING-WRAPPER)) : MUTABLE-STRING</I>
<DD>Unwrap <VAR>wrapper</VAR> and return the result.
Return NULL if <VAR>wrapper</VAR> is NULL.
</DL>
</P><P>

<A NAME="IDX150"></A>
<DL>
<DT><U>Function:</U> <B>string-to-mutable-string</B> <I>((s STRING)) : MUTABLE-STRING</I>
<DD>Copy <VAR>s</VAR> into a mutable string with the same content.
In Lisp and C++ this simply copies <VAR>s</VAR>.
</DL>
</P><P>

<A NAME="IDX151"></A>
<DL>
<DT><U>Function:</U> <B>mutable-string-to-string</B> <I>((s MUTABLE-STRING)) : STRING</I>
<DD>Convert <VAR>s</VAR> into a regular string with the same content.
In Lisp and C++ this is a no-op.
</DL>
</P><P>

<A NAME="IDX152"></A>
<DL>
<DT><U>Function:</U> <B>integer-to-string</B> <I>((i INTEGER)) : STRING</I>
<DD>Convert <VAR>i</VAR> to its string representation and return the result.
 This is more efficient than using a string stream.
</DL>
</P><P>

<A NAME="IDX153"></A>
<DL>
<DT><U>Function:</U> <B>string-to-integer</B> <I>((string STRING)) : INTEGER</I>
<DD>Convert a <VAR>string</VAR> representation of an integer into an integer.
</DL>
</P><P>

<A NAME="IDX154"></A>
<DL>
<DT><U>Function:</U> <B>float-to-string</B> <I>((f FLOAT)) : STRING</I>
<DD>Convert <VAR>f</VAR> to its string representation and return the result.  This is more
efficient than using a string stream.
</DL>
</P><P>

<A NAME="IDX155"></A>
<DL>
<DT><U>Function:</U> <B>string-to-float</B> <I>((string STRING)) : FLOAT</I>
<DD>Convert a <VAR>string</VAR> representation of a float into a float.
</DL>
</P><P>

<A NAME="IDX156"></A>
<DL>
<DT><U>Function:</U> <B>format-float</B> <I>((f FLOAT) (nDecimals INTEGER)) : STRING</I>
<DD>Print <VAR>f</VAR> in fixed-point format with <VAR>nDecimals</VAR> behind the decimal point
and return the result as a string.
</DL>
</P><P>

<A NAME="IDX157"></A>
<DL>
<DT><U>Function:</U> <B>character-to-string</B> <I>((c CHARACTER)) : STRING</I>
<DD>Convert <VAR>c</VAR> into a one-element string and return the result.
</DL>
</P><P>

<A NAME="IDX158"></A>
<DL>
<DT><U>Function:</U> <B>stringify</B> <I>((expression OBJECT)) : STRING</I>
<DD>Print <VAR>expression</VAR> onto a string and return the result.
Printing is done with <CODE>*printReadably?*</CODE> set to true and with <CODE>*printPretty?*</CODE>
set to false.
</DL>
</P><P>

<A NAME="IDX159"></A>
<DL>
<DT><U>Function:</U> <B>stringify-in-module</B> <I>((tree OBJECT) (module MODULE)) : STRING</I>
<DD>Stringify a parse <VAR>tree</VAR> relative to <VAR>module</VAR>, or
<CODE>*module*</CODE> if no module is specified.
</DL>
</P><P>

<A NAME="IDX160"></A>
<DL>
<DT><U>Function:</U> <B>unstringify</B> <I>((string STRING)) : OBJECT</I>
<DD>Read a STELLA expression from <VAR>string</VAR> and return the result.
This is identical to <CODE>read-s-expression-from-string</CODE>.
</DL>
</P><P>

<A NAME="IDX161"></A>
<DL>
<DT><U>Function:</U> <B>unstringify-in-module</B> <I>((string STRING) (module MODULE)) : OBJECT</I>
<DD>Unstringify relative to <VAR>module</VAR>, or <CODE>*MODULE*</CODE> if no
module is specified.
</DL>
</P><P>

<A NAME="CONS Lists and Trees"></A>
<HR SIZE="6">
<A NAME="SEC35"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC34"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC36"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC37"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.5 <CODE>CONS</CODE> Lists and Trees </H2>
<!--docid::SEC35::-->
<P>

<A NAME="IDX162"></A>
<DL>
<DT><U>Class:</U> <B>CONS</B> <I>: STANDARD-OBJECT</I>
<DD>Not documented.
<A NAME="IDX163"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-value</B> <I>: OBJECT</I>
<DD>Not documented.
</DL>
<A NAME="IDX164"></A>
<DL>
<DT><U>Slot:</U>  <B>value</B> <I>: (LIKE (ANY-VALUE SELF))</I>
<DD>Not documented.
</DL>
<A NAME="IDX165"></A>
<DL>
<DT><U>Slot:</U>  <B>rest</B> <I>: (CONS OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Not documented.
</DL>
</DL>
</P><P>

<A NAME="IDX166"></A>
<DL>
<DT><U>Variable:</U> <B>nil</B> <I>: CONS</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX167"></A>
<DL>
<DT><U>Method:</U> CONS <B>empty?</B> <I>(self) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> iff <VAR>self</VAR> equals <CODE>nil</CODE>.
</DL>
</P><P>

<A NAME="IDX168"></A>
<DL>
<DT><U>Method:</U> CONS <B>non-empty?</B> <I>(self) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> iff <VAR>self</VAR> is not equal to <CODE>nil</CODE>.
</DL>
</P><P>

<A NAME="IDX169"></A>
<DL>
<DT><U>Function:</U> <B>nil?</B> <I>((x OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> iff <VAR>x</VAR> equals <CODE>nil</CODE>.
</DL>
</P><P>

<A NAME="IDX170"></A>
<DL>
<DT><U>Function:</U> <B>equal-cons-trees?</B> <I>((tree1 OBJECT) (tree2 OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> iff the cons trees <VAR>tree1</VAR> and <VAR>tree2</VAR> are
structurally equivalent.  Uses an <CODE>eql?</CODE> test.
</DL>
</P><P>

<A NAME="IDX171"></A>
<DL>
<DT><U>Method:</U> CONS <B>object-equal?</B> <I>(tree1 (tree2 OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> iff the cons trees <VAR>tree1</VAR> and <VAR>tree2</VAR> are
structurally equivalent.  Uses <CODE>equal?</CODE> to test equality of subtrees.
</DL>
</P><P>

<A NAME="IDX172"></A>
<DL>
<DT><U>Method:</U> CONS <B>equal-hash-code</B> <I>(self) : INTEGER</I>
<DD>Return an <CODE>equal?</CODE> hash code for <VAR>self</VAR>.  Note that this
is O(N) in the number of elements of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX173"></A>
<DL>
<DT><U>Function:</U> <B>cons</B> <I>((value OBJECT) (rest CONS)) : CONS</I>
<DD>Return a cons record that points to <VAR>value</VAR> and <VAR>rest</VAR>.
</DL>
</P><P>

<A NAME="IDX174"></A>
<DL>
<DT><U>Method:</U> CONS <B>first</B> <I>(self) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the first element of <VAR>self</VAR>.  The first element
of <VAR>self</VAR> can be set with <CODE>setf</CODE>.  Note that <CODE>(first NIL)</CODE> = <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX175"></A>
<DL>
<DT><U>Method:</U> CONS <B>second</B> <I>(self) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the second element of <VAR>self</VAR>.  The second element
of <VAR>self</VAR> can be set with <CODE>setf</CODE>.  Note that <CODE>(second NIL)</CODE> = <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX176"></A>
<DL>
<DT><U>Method:</U> CONS <B>third</B> <I>(self) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the third element of <VAR>self</VAR>.  The third element
of <VAR>self</VAR> can be set with <CODE>setf</CODE>.  Note that <CODE>(third NIL)</CODE> = <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX177"></A>
<DL>
<DT><U>Method:</U> CONS <B>fourth</B> <I>(self) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the fourth element of <VAR>self</VAR>.  The fourth element
of <VAR>self</VAR> can be set with <CODE>setf</CODE>.  Note that <CODE>(fourth NIL)</CODE> = <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX178"></A>
<DL>
<DT><U>Method:</U> CONS <B>fifth</B> <I>(self) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the fifth element of <VAR>self</VAR>.  The fifth element
of <VAR>self</VAR> can be set with <CODE>setf</CODE>.  Note, that <CODE>(fifth NIL)</CODE> = <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX179"></A>
<DL>
<DT><U>Method:</U> CONS <B>nth</B> <I>(self (position INTEGER)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the element of <VAR>self</VAR> at <VAR>position</VAR>.  The nth element
of <VAR>self</VAR> can be set with <CODE>setf</CODE>.  Note, that <CODE>(nth NIL &#60;pos&#62;)</CODE> = <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX180"></A>
<DL>
<DT><U>Method:</U> CONS <B>nth-rest</B> <I>(self (position INTEGER)) : (LIKE SELF)</I>
<DD>Apply <CODE>rest</CODE> <VAR>position</VAR> times to <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX181"></A>
<DL>
<DT><U>Method:</U> CONS <B>last</B> <I>(self) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the last element of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX182"></A>
<DL>
<DT><U>Method:</U> CONS <B>but-last</B> <I>(self) : (ITERATOR OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Generate all but the last element of the cons list <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX183"></A>
<DL>
<DT><U>Function:</U> <B>last-cons</B> <I>((self CONS)) : (CONS OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return the last cons of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX184"></A>
<DL>
<DT><U>Method:</U> CONS <B>length</B> <I>(self) : INTEGER</I>
<DD>Return the length of the CONS list <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX185"></A>
<DL>
<DT><U>Method:</U> CONS <B>member?</B> <I>(self (object OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> iff <VAR>object</VAR> is a member of the cons list
<VAR>self</VAR> (uses an <CODE>eql?</CODE> test).
</DL>
</P><P>

<A NAME="IDX186"></A>
<DL>
<DT><U>Method:</U> CONS <B>memb?</B> <I>(self (object OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> iff <VAR>object</VAR> is a member of the cons list
<VAR>self</VAR> (uses an <CODE>eq?</CODE> test).
</DL>
</P><P>

<A NAME="IDX187"></A>
<DL>
<DT><U>Method:</U> CONS <B>position</B> <I>(self (object OBJECT) (start INTEGER)) : INTEGER</I>
<DD>Return the position of <VAR>object</VAR> within the cons-list
<VAR>self</VAR> (counting from zero); or return <CODE>null</CODE> if <VAR>object</VAR> does not occur within 
<VAR>self</VAR> (uses an <CODE>eql?</CODE> test).  If <VAR>start</VAR> was supplied as non-`null', only 
consider the sublist starting at <VAR>start</VAR>, however, the returned position 
will always be relative to the entire list.
</DL>
</P><P>

<A NAME="IDX188"></A>
<DL>
<DT><U>Method:</U> CONS <B>last-position</B> <I>(self (object OBJECT) (end INTEGER)) : INTEGER</I>
<DD>Return the position of <VAR>object</VAR> within the cons-list
<VAR>self</VAR> (counting from zero); or return <CODE>null</CODE> if <VAR>object</VAR> does not occur within 
<VAR>self</VAR> (uses an <CODE>eql?</CODE> test).  If <CODE>start</CODE> was supplied as non-`null', only 
consider the sublist ending at <VAR>end</VAR>, however, the returned position 
will always be relative to the entire list.
</DL>
</P><P>

<A NAME="IDX189"></A>
<DL>
<DT><U>Method:</U> CONS <B>reverse</B> <I>(self) : (LIKE SELF)</I>
<DD>Destructively reverse the members of the cons list <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX190"></A>
<DL>
<DT><U>Method:</U> CONS <B>remove</B> <I>(self (value OBJECT)) : (LIKE SELF)</I>
<DD>Destructively remove all entries in the cons list <VAR>self</VAR> that
match <VAR>value</VAR>.  Unless the remaining list is <CODE>nil</CODE>, insure that the cons that
heads the list is unchanged.
</DL>
</P><P>

<A NAME="IDX191"></A>
<DL>
<DT><U>Method:</U> CONS <B>remove-duplicates</B> <I>(self) : (LIKE SELF)</I>
<DD>Destructively remove duplicates from <VAR>self</VAR> and return the
result.  Removes all but the first occurrence of items in the list.
Preserves the original order of the remaining members.  Runs in linear time.
</DL>
</P><P>

<A NAME="IDX192"></A>
<DL>
<DT><U>Method:</U> CONS <B>remove-if</B> <I>(self (test? FUNCTION-CODE)) : (LIKE SELF)</I>
<DD>Destructively removes all members of the cons list
<VAR>self</VAR> for which <VAR>test?</VAR> evaluates to <CODE>true</CODE>.  <CODE>test</CODE> takes a single 
argument of type OBJECT and returns <CODE>true</CODE> or <CODE>false</CODE>.  Returns a cons list.
In case the first element is removed, the return result should be
assigned to a variable.
</DL>
</P><P>

<A NAME="IDX193"></A>
<DL>
<DT><U>Method:</U> CONS <B>substitute</B> <I>(self (inValue OBJECT) (outValue OBJECT)) : CONS</I>
<DD>Destructively replace each appearance of <VAR>outValue</VAR> by
<VAR>inValue</VAR> in the cons list <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX194"></A>
<DL>
<DT><U>Method:</U> CONS <B>concatenate</B> <I>(list1 (list2 CONS) &#38;rest (otherLists CONS)) : CONS</I>
<DD>Return a cons list consisting of the concatenation of 
<VAR>list1</VAR>, <VAR>list2</VAR>, and <VAR>otherLists</VAR>.  The operation is destructive wrt all
but the last list argument which is left intact.  The two mandatory
parameters allow us to optimize the common binary case by not relying on
the somewhat less efficient variable arguments mechanism.
</DL>
</P><P>

<A NAME="IDX195"></A>
<DL>
<DT><U>Function:</U> <B>append</B> <I>((consList1 CONS) (consList2 CONS)) : CONS</I>
<DD>Return a cons list representing the concatenation
of <VAR>consList1</VAR> and <VAR>consList2</VAR>.  The concatenation is NOT destructive.
</DL>
</P><P>

<A NAME="IDX196"></A>
<DL>
<DT><U>Method:</U> CONS <B>prepend</B> <I>(self (list1 CONS)) : CONS</I>
<DD>Return a cons list consisting of the concatenation of
<VAR>list1</VAR> and <VAR>self</VAR>.  A copy of <VAR>list1</VAR> is prepended to <VAR>self</VAR>.  This
operation results in structure sharing of <VAR>self</VAR>; to avoid this, <VAR>self</VAR>
should not be pointed to by anything other than the tail of the prepended
copy.
</DL>
</P><P>

<A NAME="IDX197"></A>
<DL>
<DT><U>Macro:</U> <B>pushq</B> <I>((variable SYMBOL) (value OBJECT)) : OBJECT</I>
<DD>Push <VAR>value</VAR> onto the cons list <VAR>variable</VAR>.
</DL>
</P><P>

<A NAME="IDX198"></A>
<DL>
<DT><U>Macro:</U> <B>pushq-new</B> <I>((variable SYMBOL) (value OBJECT)) : OBJECT</I>
<DD>Push <VAR>value</VAR> onto the cons list <VAR>variable</VAR>, unless <VAR>value</VAR>
is already a member of the list.
</DL>
</P><P>

<A NAME="IDX199"></A>
<DL>
<DT><U>Macro:</U> <B>popq</B> <I>((variable SYMBOL)) : OBJECT</I>
<DD>Pops a value from the cons list <VAR>variable</VAR>.
</DL>
</P><P>

<A NAME="IDX200"></A>
<DL>
<DT><U>Function:</U> <B>cons-list</B> <I>(&#38;rest (values OBJECT)) : CONS</I>
<DD>Return a cons list containing <VAR>values</VAR>, in order.
</DL>
</P><P>

<A NAME="IDX201"></A>
<DL>
<DT><U>Function:</U> <B>list*</B> <I>(&#38;rest (values OBJECT)) : CONS</I>
<DD>Return a list of conses that make up the list <VAR>values</VAR>,
terminated by the last value rather than by <CODE>nil</CODE>.  Assumes that
at least one value is passed in.
</DL>
</P><P>

<A NAME="IDX202"></A>
<DL>
<DT><U>Function:</U> <B>copy-cons-list</B> <I>((self CONS)) : (LIKE SELF)</I>
<DD>Return a copy of the cons list <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX203"></A>
<DL>
<DT><U>Function:</U> <B>copy-cons-tree</B> <I>((self OBJECT)) : (LIKE SELF)</I>
<DD>Return a copy of the cons tree <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX204"></A>
<DL>
<DT><U>Function:</U> <B>substitute-cons-tree</B> <I>((tree OBJECT) (newValue OBJECT) (oldValue OBJECT)) : OBJECT</I>
<DD>Destructively replace each appearance of <VAR>oldValue</VAR> by
<VAR>newValue</VAR> in the cons tree <VAR>tree</VAR>.  Return the tree.  Uses an <CODE>eql?</CODE> test.
</DL>
</P><P>

<A NAME="IDX205"></A>
<DL>
<DT><U>Function:</U> <B>search-cons-tree?</B> <I>((tree OBJECT) (value OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> iff the value <VAR>value</VAR> is embedded within
the cons tree <VAR>tree</VAR>.  Uses an <CODE>eql?</CODE> test.
</DL>
</P><P>

<A NAME="IDX206"></A>
<DL>
<DT><U>Function:</U> <B>tree-size</B> <I>((self OBJECT)) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX207"></A>
<DL>
<DT><U>Function:</U> <B>safe-tree-size</B> <I>((tree CONS)) : INTEGER STRING</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX208"></A>
<DL>
<DT><U>Function:</U> <B>cons-tree-nth</B> <I>((tree CONS) &#38;rest (index INTEGER)) : OBJECT</I>
<DD>Access an arbitrary element of <VAR>tree</VAR> identified by a path
specified as a list of <VAR>index</VAR> values.  The first <VAR>index</VAR> specifies the
<VAR>index</VAR>-th element of <VAR>tree</VAR>, the second <VAR>index</VAR> the <VAR>index</VAR>-th subelement
of that element, etc.  Example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  (cons-tree-nth (quote (a (b (c d e) f) g)) 1 1 2) =&#62; e
</pre></td></tr></table></P><P>

</DL>
</P><P>

<A NAME="IDX209"></A>
<DL>
<DT><U>Function:</U> <B>cons-tree-nth-rest</B> <I>((tree CONS) &#38;rest (index INTEGER)) : CONS</I>
<DD>Access an arbitrary sublist of <VAR>tree</VAR> identified by a path
specified as a list of <VAR>index</VAR> values.  The first <VAR>index</VAR> specifies the
<VAR>index</VAR>-th element of <VAR>tree</VAR>, the second <VAR>index</VAR> the <VAR>index</VAR>-th subelement
of that element, ..., the last index specifies the <CODE>nth-rest</CODE> of the previous
element (different from <CODE>cons-tree-nth</CODE>).  Example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  (cons-tree-nth-rest (quote (a (b (c d e) f) g)) 1 1 1) =&#62; (d e)
</pre></td></tr></table></P><P>

</DL>
</P><P>

<A NAME="IDX210"></A>
<DL>
<DT><U>Function:</U> <B>match-cons-tree</B> <I>((tree OBJECT) (pattern OBJECT) (bindings KEY-VALUE-LIST)) : KEY-VALUE-LIST</I>
<DD>Match <VAR>pattern</VAR> against <VAR>tree</VAR> and return a list of
variable bindings if they match, or NULL otherwise.  <VAR>bindings</VAR> can
be NULL or an initial list of bindings to consider.  Pattern variables
use KIF syntax, i.e., they need to start with a <CODE>?</CODE> character.  A
single question mark is interpreted as the anonymous variable. Example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  (match-cons-tree (quote (a (b (a d) e) (a d) f g))
                   (quote (a (?x ?y ?) ?y ? g))
                   NULL)
  =&#62; |kv|(&#60;?Y,(A D)&#62; &#60;?X,B&#62;)
</pre></td></tr></table></P><P>

Variables can't be quoted but quoting can effectively be achieved by
inserting to-be-quoted variables bound to themselves into <VAR>bindings</VAR>.
</DL>
</P><P>

<A NAME="IDX211"></A>
<DL>
<DT><U>Function:</U> <B>cons-tree-match?</B> <I>((tree OBJECT) (pattern OBJECT)) : BOOLEAN</I>
<DD>Predicate version of <CODE>match-cons-tree</CODE> (which see).
</DL>
</P><P>

<A NAME="IDX212"></A>
<DL>
<DT><U>Method:</U> CONS <B>consify</B> <I>(self) : (CONS OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX213"></A>
<DL>
<DT><U>Method:</U> CONS <B>allocate-iterator</B> <I>(self) : (CONS-ITERATOR OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX214"></A>
<DL>
<DT><U>Method:</U> CONS-ITERATOR <B>next?</B> <I>(self) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX215"></A>
<DL>
<DT><U>Method:</U> CONS <B>sort</B> <I>(self (predicate FUNCTION-CODE)) : (CONS OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Perform a stable, destructive sort of <VAR>self</VAR> according to
<VAR>predicate</VAR>, and return the result.  If <VAR>predicate</VAR> has a <CODE>&#60;</CODE> semantics, the
result will be in ascending order.  It is not guaranteed that <VAR>self</VAR> will
point to the beginning of the sorted result.  If <VAR>predicate</VAR> is <CODE>null</CODE>, a
suitable <CODE>&#60;</CODE> predicate is chosen depending on the first element of <VAR>self</VAR>,
and it is assumed that all elements of <VAR>self</VAR> have the same type (supported
element types are GENERALIZED-SYMBOL, STRING, INTEGER, and FLOAT).
</DL>
</P><P>

<A NAME="IDX216"></A>
<DL>
<DT><U>Method:</U> CONS <B>sort-tuples</B> <I>(self (n INTEGER) (predicate FUNCTION-CODE)) : (CONS OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Just like <CODE>sort</CODE> but assumes each element of <VAR>self</VAR> is a tuple (a cons)
whose <VAR>n</VAR>-th element (0-based) will be used for comparison.
</DL>
</P><P>

<A NAME="IDX217"></A>
<DL>
<DT><U>Function:</U> <B>map-null-to-nil</B> <I>((self CONS)) : (LIKE SELF)</I>
<DD>Return <CODE>nil</CODE> iff <VAR>self</VAR> is <CODE>null</CODE> or <VAR>self</VAR> otherwise.
</DL>
</P><P>

<A NAME="IDX218"></A>
<DL>
<DT><U>Special Variable:</U> <B>*printpretty?*</B> <I>: BOOLEAN</I>
<DD>If <CODE>true</CODE> conses will be pretty printed.
</DL>
</P><P>

<A NAME="IDX219"></A>
<DL>
<DT><U>Special Variable:</U> <B>*printreadably?*</B> <I>: BOOLEAN</I>
<DD>If <CODE>true</CODE> conses will be printed as readable Stella code.
</DL>
</P><P>

<A NAME="IDX220"></A>
<DL>
<DT><U>Special Variable:</U> <B>*printprettycode?*</B> <I>: BOOLEAN</I>
<DD>When <CODE>true</CODE> pretty-print Stella and translated code.
Since (Lisp) pretty-printing is somewhat slow, turning this off speeds up
file translation, but it also makes translated output very unreadable.
</DL>
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC36">6.5.1 CONS Lists as Sets</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="CONS Lists as Sets"></A>
<HR SIZE="6">
<A NAME="SEC36"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC35"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC37"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC34"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC35"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC37"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 6.5.1 CONS Lists as Sets </H3>
<!--docid::SEC36::-->
<P>

<A NAME="IDX221"></A>
<DL>
<DT><U>Method:</U> CONS <B>subset?</B> <I>(self (otherList CONS)) : BOOLEAN</I>
<DD>Return true if every element of <VAR>self</VAR> also occurs in <VAR>otherList</VAR>.
Uses an <CODE>eql?</CODE> test and a simple quadratic-time algorithm.  Note that
this does not check whether <VAR>self</VAR> and <VAR>otherList</VAR> actually are sets.
</DL>
</P><P>

<A NAME="IDX222"></A>
<DL>
<DT><U>Method:</U> CONS <B>equivalent-sets?</B> <I>(self (otherList CONS)) : BOOLEAN</I>
<DD>Return true if every element of <VAR>self</VAR> occurs in <VAR>otherList</VAR> and vice versa.
Uses an <CODE>eql?</CODE> test and a simple quadratic-time algorithm.  Note that
this does not check whether <VAR>self</VAR> and <VAR>otherList</VAR> actually are sets.
</DL>
</P><P>

<A NAME="IDX223"></A>
<DL>
<DT><U>Method:</U> CONS <B>union</B> <I>(self (otherList CONS)) : CONS</I>
<DD>Return the set union of <VAR>self</VAR> and <VAR>otherList</VAR>.  Uses an <CODE>eql?</CODE> test
and a simple quadratic-time algorithm.  Note that the result is only
guaranteed to be a set if both <VAR>self</VAR> and <VAR>otherList</VAR> are sets.
</DL>
</P><P>

<A NAME="IDX224"></A>
<DL>
<DT><U>Method:</U> CONS <B>intersection</B> <I>(self (otherList CONS)) : CONS</I>
<DD>Return the set intersection of <VAR>self</VAR> and <VAR>otherList</VAR>.  Uses an <CODE>eql?</CODE>
test and a simple quadratic-time algorithm.  Note that the result is only
guaranteed to be a set if both <VAR>self</VAR> and <VAR>otherList</VAR> are sets.
</DL>
</P><P>

<A NAME="IDX225"></A>
<DL>
<DT><U>Method:</U> CONS <B>difference</B> <I>(self (otherList CONS)) : CONS</I>
<DD>Return the set difference of <VAR>self</VAR> and <VAR>otherList</VAR> (i.e., all elements
that are in <VAR>self</VAR> but not in <CODE>otherSet</CODE>).  Uses an <CODE>eql?</CODE> test and a simple
quadratic-time algorithm.  Note that the result is only guaranteed to be a
set if both <VAR>self</VAR> and <VAR>otherList</VAR> are sets.
</DL>
</P><P>

<A NAME="IDX226"></A>
<DL>
<DT><U>Method:</U> CONS <B>subtract</B> <I>(self (otherList CONS)) : CONS</I>
<DD>Return the set difference of <VAR>self</VAR> and <VAR>otherList</VAR> by destructively
removing elements from <VAR>self</VAR> that also occur in <VAR>otherList</VAR>.  Uses an <CODE>eql?</CODE>
test and a simple quadratic-time algorithm.  Note that the result is only
guaranteed to be a set if <VAR>self</VAR> is a set.
</DL>
</P><P>

<A NAME="Lists"></A>
<HR SIZE="6">
<A NAME="SEC37"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC36"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC38"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC35"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC39"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.6 Lists </H2>
<!--docid::SEC37::-->
<P>

<A NAME="IDX227"></A>
<DL>
<DT><U>Class:</U> <B>LIST</B> <I>: SEQUENCE</I>
<DD>Not documented.
<A NAME="IDX228"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-value</B> <I>: OBJECT</I>
<DD>Not documented.
</DL>
<A NAME="IDX229"></A>
<DL>
<DT><U>Slot:</U>  <B>the-cons-list</B> <I>: (CONS OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Not documented.
</DL>
</DL>
</P><P>

<A NAME="IDX230"></A>
<DL>
<DT><U>Variable:</U> <B>nil-list</B> <I>: LIST</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX231"></A>
<DL>
<DT><U>Function:</U> <B>defined-list?</B> <I>((self LIST)) : BOOLEAN</I>
<DD>Return TRUE unless <VAR>self</VAR> is NULL or the <CODE>NIL-LIST</CODE>.
</DL>
</P><P>

<A NAME="IDX232"></A>
<DL>
<DT><U>Function:</U> <B>null-list?</B> <I>((self LIST)) : BOOLEAN</I>
<DD>Return TRUE iff <VAR>self</VAR> is NULL or the <CODE>NIL-LIST</CODE>.
</DL>
</P><P>

<A NAME="IDX233"></A>
<DL>
<DT><U>Method:</U> LIST <B>empty?</B> <I>(self) : BOOLEAN</I>
<DD>Return TRUE if the list <VAR>self</VAR> has no members.
</DL>
</P><P>

<A NAME="IDX234"></A>
<DL>
<DT><U>Method:</U> LIST <B>non-empty?</B> <I>(self) : BOOLEAN</I>
<DD>Return TRUE if the list <VAR>self</VAR> has at least one member.
</DL>
</P><P>

<A NAME="IDX235"></A>
<DL>
<DT><U>Method:</U> LIST <B>object-equal?</B> <I>(x (y OBJECT)) : BOOLEAN</I>
<DD>Return TRUE iff the lists <VAR>x</VAR> and <VAR>y</VAR> are structurally
equivalent.  Uses <CODE>equal?</CODE> to test equality of elements.
</DL>
</P><P>

<A NAME="IDX236"></A>
<DL>
<DT><U>Method:</U> LIST <B>equal-hash-code</B> <I>(self) : INTEGER</I>
<DD>Return an <CODE>equal?</CODE> hash code for <VAR>self</VAR>.  Note that this
is O(N) in the number of elements of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX237"></A>
<DL>
<DT><U>Function:</U> <B>list</B> <I>(&#38;rest (values OBJECT)) : LIST</I>
<DD>Return a list containing <VAR>values</VAR>, in order.
</DL>
</P><P>

<A NAME="IDX238"></A>
<DL>
<DT><U>Method:</U> LIST <B>first</B> <I>(self) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the first item in the list <VAR>self</VAR>, or NULL if empty.
</DL>
</P><P>

<A NAME="IDX239"></A>
<DL>
<DT><U>Method:</U> LIST <B>second</B> <I>(self) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the second item in the list <VAR>self</VAR>, or NULL if empty.
</DL>
</P><P>

<A NAME="IDX240"></A>
<DL>
<DT><U>Method:</U> LIST <B>third</B> <I>(self) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the third item in the list <VAR>self</VAR>, or NULL if empty.
</DL>
</P><P>

<A NAME="IDX241"></A>
<DL>
<DT><U>Method:</U> LIST <B>fourth</B> <I>(self) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the fourth item in the list <VAR>self</VAR>, or NULL if empty.
</DL>
</P><P>

<A NAME="IDX242"></A>
<DL>
<DT><U>Method:</U> LIST <B>fifth</B> <I>(self) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the fifth item in the list <VAR>self</VAR>, or NULL if empty.
</DL>
</P><P>

<A NAME="IDX243"></A>
<DL>
<DT><U>Method:</U> LIST <B>nth</B> <I>(self (position INTEGER)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the nth item in the list <VAR>self</VAR>, or NULL if empty.
</DL>
</P><P>

<A NAME="IDX244"></A>
<DL>
<DT><U>Method:</U> LIST <B>rest</B> <I>(self) : (CONS OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return a cons list of all but the first item in the list <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX245"></A>
<DL>
<DT><U>Method:</U> LIST <B>last</B> <I>(self) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the last element of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX246"></A>
<DL>
<DT><U>Method:</U> LIST <B>but-last</B> <I>(self) : (ITERATOR OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Generate all but the last element of the list <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX247"></A>
<DL>
<DT><U>Method:</U> LIST <B>length</B> <I>(self) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX248"></A>
<DL>
<DT><U>Method:</U> LIST <B>member?</B> <I>(self (object OBJECT)) : BOOLEAN</I>
<DD>Return TRUE iff <VAR>object</VAR> is a member of the list
<VAR>self</VAR> (uses an <CODE>eql?</CODE> test).
</DL>
</P><P>

<A NAME="IDX249"></A>
<DL>
<DT><U>Method:</U> LIST <B>memb?</B> <I>(self (object (LIKE (ANY-VALUE SELF)))) : BOOLEAN</I>
<DD>Return TRUE iff <VAR>object</VAR> is a member of the cons list
<VAR>self</VAR> (uses an <CODE>eq?</CODE> test).
</DL>
</P><P>

<A NAME="IDX250"></A>
<DL>
<DT><U>Method:</U> LIST <B>position</B> <I>(self (object OBJECT) (start INTEGER)) : INTEGER</I>
<DD>Return the position of <VAR>object</VAR> within the list
<VAR>self</VAR> (counting from zero); or return NULL if <VAR>object</VAR> does not occur within 
<VAR>self</VAR> (uses an <CODE>eql?</CODE> test).  If <VAR>start</VAR> was supplied as non-NULL, only 
consider the sublist starting at <VAR>start</VAR>, however, the returned position 
will always be relative to the entire list.
</DL>
</P><P>

<A NAME="IDX251"></A>
<DL>
<DT><U>Method:</U> LIST <B>last-position</B> <I>(self (object OBJECT) (end INTEGER)) : INTEGER</I>
<DD>Return the position of <VAR>object</VAR> within the list
<VAR>self</VAR> (counting from zero); or return NULL if <VAR>object</VAR> does not occur within 
<VAR>self</VAR> (uses an <CODE>eql?</CODE> test).  If <VAR>end</VAR> was supplied as non-NULL, only 
consider the sublist ending at <VAR>end</VAR>, however, the returned position 
will always be relative to the entire list.
</DL>
</P><P>

<A NAME="IDX252"></A>
<DL>
<DT><U>Method:</U> LIST <B>insert</B> <I>(self (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Add <VAR>value</VAR> to the front of the list <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX253"></A>
<DL>
<DT><U>Method:</U> LIST <B>push</B> <I>(self (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Add <VAR>value</VAR> to the front of the list <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX254"></A>
<DL>
<DT><U>Method:</U> LIST <B>insert-new</B> <I>(self (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Add <VAR>value</VAR> to the front of the list <VAR>self</VAR> unless its 
already a member.
</DL>
</P><P>

<A NAME="IDX255"></A>
<DL>
<DT><U>Method:</U> LIST <B>insert-last</B> <I>(self (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Insert <VAR>value</VAR> as the last entry in the list <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX256"></A>
<DL>
<DT><U>Method:</U> LIST <B>reverse</B> <I>(self) : (LIKE SELF)</I>
<DD>Reverse the members of <VAR>self</VAR> (in place).
</DL>
</P><P>

<A NAME="IDX257"></A>
<DL>
<DT><U>Method:</U> LIST <B>remove</B> <I>(self (value (LIKE (ANY-VALUE SELF)))) : (LIKE SELF)</I>
<DD>Destructively remove all entries in <VAR>self</VAR> that match <VAR>value</VAR>.
</DL>
</P><P>

<A NAME="IDX258"></A>
<DL>
<DT><U>Method:</U> LIST <B>remove-duplicates</B> <I>(self) : (LIKE SELF)</I>
<DD>Destructively remove duplicates from <VAR>self</VAR> and return the result.
Preserves the original order of the remaining members.
</DL>
</P><P>

<A NAME="IDX259"></A>
<DL>
<DT><U>Method:</U> LIST <B>remove-deleted-members</B> <I>(self) : (LIKE SELF)</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX260"></A>
<DL>
<DT><U>Method:</U> LIST <B>remove-if</B> <I>(self (test? FUNCTION-CODE)) : (LIKE SELF)</I>
<DD>Destructively remove all members of the list <VAR>self</VAR> for which
<VAR>test?</VAR> evaluates to TRUE.  <CODE>test</CODE> takes a single argument of type OBJECT and
returns TRUE or FALSE.  Returns <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX261"></A>
<DL>
<DT><U>Method:</U> LIST <B>pop</B> <I>(self) : (LIKE (ANY-VALUE SELF))</I>
<DD>Remove and return the first element in the list <VAR>self</VAR>.
Return NULL if the list is empty.
</DL>
</P><P>

<A NAME="IDX262"></A>
<DL>
<DT><U>Method:</U> LIST <B>substitute</B> <I>(self (inValue OBJECT) (outValue OBJECT)) : (LIKE SELF)</I>
<DD>Destructively replace each appearance of <VAR>outValue</VAR> by
<VAR>inValue</VAR> in the list <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX263"></A>
<DL>
<DT><U>Method:</U> LIST <B>concatenate</B> <I>(list1 (list2 LIST) &#38;rest (otherLists LIST)) : LIST</I>
<DD>Copy <VAR>list2</VAR> and all <VAR>otherLists</VAR> onto the end of <VAR>list1</VAR>.
The operation is destructive wrt <VAR>list1</VAR>, but leaves all other lists intact.
The two mandatory parameters allow us to optimize the common binary case by
not relying on the somewhat less efficient variable arguments mechanism.
</DL>
</P><P>

<A NAME="IDX264"></A>
<DL>
<DT><U>Method:</U> LIST <B>prepend</B> <I>(self (list2 LIST)) : (LIKE SELF)</I>
<DD>Copy <VAR>list2</VAR> onto the front of the list <VAR>self</VAR>.
The operation is destructive wrt <VAR>self</VAR>, but leaves <VAR>list2</VAR> intact.
</DL>
</P><P>

<A NAME="IDX265"></A>
<DL>
<DT><U>Method:</U> LIST <B>copy</B> <I>(self) : (LIST OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return a copy of the list <VAR>self</VAR>.  The conses in the copy are
freshly allocated.
</DL>
</P><P>

<A NAME="IDX266"></A>
<DL>
<DT><U>Method:</U> LIST <B>clear</B> <I>(self) :</I>
<DD>Make <VAR>self</VAR> an empty list.
</DL>
</P><P>

<A NAME="IDX267"></A>
<DL>
<DT><U>Method:</U> LIST <B>consify</B> <I>(self) : (CONS OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return a list of elements in <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX268"></A>
<DL>
<DT><U>Method:</U> LIST <B>allocate-iterator</B> <I>(self) : (LIST-ITERATOR OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX269"></A>
<DL>
<DT><U>Method:</U> LIST-ITERATOR <B>next?</B> <I>(self) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX270"></A>
<DL>
<DT><U>Method:</U> LIST <B>sort</B> <I>(self (predicate FUNCTION-CODE)) : (LIST OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Perform a stable, destructive sort of <VAR>self</VAR> according to
<VAR>predicate</VAR>, and return the result.  If <VAR>predicate</VAR> has a <CODE>&#60;</CODE> semantics, the
result will be in ascending order.  If <VAR>predicate</VAR> is NULL, a suitable
<CODE>&#60;</CODE> predicate is chosen depending on the first element of <VAR>self</VAR>, and it 
is assumed that all elements of <VAR>self</VAR> have the same type (supported
element types are GENERALIZED-SYMBOL, STRING, INTEGER, and FLOAT).
</DL>
</P><P>

<A NAME="IDX271"></A>
<DL>
<DT><U>Function:</U> <B>map-null-to-nil-list</B> <I>((self LIST)) : LIST</I>
<DD>Return NIL-LIST iff <VAR>self</VAR> is NULL or <VAR>self</VAR> otherwise.
</DL>
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC38">6.6.1 Lists as Sets</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Lists as Sets"></A>
<HR SIZE="6">
<A NAME="SEC38"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC37"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC39"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC35"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC37"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC39"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 6.6.1 Lists as Sets </H3>
<!--docid::SEC38::-->
<P>

Similar to <CODE>CONS</CODE> lists <CODE>LIST</CODE>'s can also be treated as sets
and support the set manipulations below.  Note that <CODE>LIST</CODE>
constructors do not check for proper set-hood and may have surprising
results if a list contains duplicate elements.
</P><P>

<A NAME="IDX272"></A>
<DL>
<DT><U>Method:</U> LIST <B>subset?</B> <I>(self (otherList LIST)) : BOOLEAN</I>
<DD>Return true if every element of <VAR>self</VAR> also occurs in <VAR>otherList</VAR>.
Uses an <CODE>eql?</CODE> test and a simple quadratic-time algorithm.  Note that
this does not check whether <VAR>self</VAR> and <VAR>otherList</VAR> actually are sets.
</DL>
</P><P>

<A NAME="IDX273"></A>
<DL>
<DT><U>Method:</U> LIST <B>equivalent-sets?</B> <I>(self (otherList LIST)) : BOOLEAN</I>
<DD>Return true if every element of <VAR>self</VAR> occurs in <VAR>otherList</VAR> and vice versa.
Uses an <CODE>eql?</CODE> test and a simple quadratic-time algorithm.  Note that
this does not check whether <VAR>self</VAR> and <VAR>otherList</VAR> actually are sets.
</DL>
</P><P>

<A NAME="IDX274"></A>
<DL>
<DT><U>Method:</U> LIST <B>union</B> <I>(self (otherList LIST)) : LIST</I>
<DD>Return the set union of <VAR>self</VAR> and <VAR>otherList</VAR>.  Uses an <CODE>eql?</CODE> test
and a simple quadratic-time algorithm.  Note that the result is only
guaranteed to be a set if both <VAR>self</VAR> and <VAR>otherList</VAR> are sets.
</DL>
</P><P>

<A NAME="IDX275"></A>
<DL>
<DT><U>Method:</U> LIST <B>intersection</B> <I>(self (otherList LIST)) : LIST</I>
<DD>Return the set intersection of <VAR>self</VAR> and <VAR>otherList</VAR>.  Uses an <CODE>eql?</CODE>
test and a simple quadratic-time algorithm.  Note that the result is only
guaranteed to be a set if both <VAR>self</VAR> and <VAR>otherList</VAR> are sets.
</DL>
</P><P>

<A NAME="IDX276"></A>
<DL>
<DT><U>Method:</U> LIST <B>difference</B> <I>(self (otherList LIST)) : LIST</I>
<DD>Return the set difference of <VAR>self</VAR> and <VAR>otherList</VAR> (i.e., all elements
that are in <VAR>self</VAR> but not in <CODE>otherSet</CODE>).  Uses an <CODE>eql?</CODE> test and a simple
quadratic-time algorithm.  Note that the result is only guaranteed to be a
set if both <VAR>self</VAR> and <VAR>otherList</VAR> are sets.
</DL>
</P><P>

<A NAME="IDX277"></A>
<DL>
<DT><U>Method:</U> LIST <B>subtract</B> <I>(self (otherList LIST)) : LIST</I>
<DD>Return the set difference of <VAR>self</VAR> and <VAR>otherList</VAR> by destructively
removing elements from <VAR>self</VAR> that also occur in <VAR>otherList</VAR>.  Uses an <CODE>eql?</CODE>
test and a simple quadratic-time algorithm.  Note that the result is only
guaranteed to be a set if <VAR>self</VAR> is a set.
</DL>
</P><P>

<CODE>SET</CODE> is a subclass of <CODE>LIST</CODE> that overrides certain
<CODE>LIST</CODE> operations to prevent duplicate elements.  The following
additional or modified operations are supported:
</P><P>

<A NAME="IDX278"></A>
<DL>
<DT><U>Class:</U> <B>SET</B> <I>: LIST, SET-MIXIN</I>
<DD>Not documented.
<A NAME="IDX279"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-value</B> <I>: OBJECT</I>
<DD>Not documented.
</DL>
</DL>
</P><P>

<A NAME="IDX280"></A>
<DL>
<DT><U>Method:</U> SET <B>insert</B> <I>(self (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Add <VAR>value</VAR> to the set <VAR>self</VAR> unless it is already a member.
</DL>
</P><P>

<A NAME="IDX281"></A>
<DL>
<DT><U>Method:</U> SET <B>push</B> <I>(self (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Add <VAR>value</VAR> to the front of set <VAR>self</VAR> unless it is already a member.
</DL>
</P><P>

<A NAME="IDX282"></A>
<DL>
<DT><U>Method:</U> SET <B>insert-last</B> <I>(self (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Add <VAR>value</VAR> to the end of set <VAR>self</VAR> unless it is already a member.
</DL>
</P><P>

<A NAME="IDX283"></A>
<DL>
<DT><U>Method:</U> SET <B>substitute</B> <I>(self (new OBJECT) (old OBJECT)) : (LIKE SELF)</I>
<DD>Destructively replace <VAR>old</VAR> with <VAR>new</VAR> in the set <VAR>self</VAR>
unless <VAR>new</VAR> is already a member.
</DL>
</P><P>

<A NAME="IDX284"></A>
<DL>
<DT><U>Method:</U> SET <B>concatenate</B> <I>(set1 (set2 LIST) &#38;rest (otherSets LIST)) : SET</I>
<DD>Union <VAR>set2</VAR> and all <VAR>otherSets</VAR> onto the end of <VAR>set1</VAR>.
The operation is destructive wrt <VAR>set1</VAR>, but leaves all other sets intact.
The two mandatory parameters allow us to optimize the common binary case by
not relying on the somewhat less efficient variable arguments mechanism.
</DL>
</P><P>

<A NAME="IDX285"></A>
<DL>
<DT><U>Method:</U> SET <B>object-equal?</B> <I>(x (y OBJECT)) : BOOLEAN</I>
<DD>Return TRUE iff <VAR>x</VAR> and <VAR>y</VAR> are SET's with equivalent members.
Uses <CODE>equal?</CODE> to test equality of elements.  This is more general than
<CODE>equivalent-sets?</CODE>, since that only uses an <CODE>eql?</CODE> test.
</DL>
</P><P>

<A NAME="IDX286"></A>
<DL>
<DT><U>Method:</U> SET <B>equal-hash-code</B> <I>(self) : INTEGER</I>
<DD>Return an <CODE>equal?</CODE> hash code for <VAR>self</VAR>.  Note that this
is O(N) in the number of elements of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX287"></A>
<DL>
<DT><U>Function:</U> <B>set</B> <I>(&#38;rest (values OBJECT)) : SET</I>
<DD>Return a set containing <VAR>values</VAR>, in order.
</DL>
</P><P>

<A NAME="Property and Key-Value Lists"></A>
<HR SIZE="6">
<A NAME="SEC39"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC38"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC40"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC37"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.7 Property and Key-Value Lists </H2>
<!--docid::SEC39::-->
<P>

<A NAME="IDX288"></A>
<DL>
<DT><U>Class:</U> <B>PROPERTY-LIST</B> <I>: DICTIONARY</I>
<DD>Not documented.
<A NAME="IDX289"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-key</B> <I>: OBJECT</I>
<DD>Not documented.
</DL>
<A NAME="IDX290"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-value</B> <I>: OBJECT</I>
<DD>Not documented.
</DL>
<A NAME="IDX291"></A>
<DL>
<DT><U>Slot:</U>  <B>the-plist</B> <I>: CONS</I>
<DD>Not documented.
</DL>
</DL>
</P><P>

<A NAME="IDX292"></A>
<DL>
<DT><U>Method:</U> PROPERTY-LIST <B>empty?</B> <I>(self) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX293"></A>
<DL>
<DT><U>Method:</U> PROPERTY-LIST <B>non-empty?</B> <I>(self) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX294"></A>
<DL>
<DT><U>Method:</U> PROPERTY-LIST <B>object-equal?</B> <I>(x (y OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>x</VAR> and <VAR>y</VAR> represent the same set of key/value pairs..
</DL>
</P><P>

<A NAME="IDX295"></A>
<DL>
<DT><U>Method:</U> PROPERTY-LIST <B>equal-hash-code</B> <I>(self) : INTEGER</I>
<DD>Return an <CODE>equal?</CODE> hash code for <VAR>self</VAR>.  Note that this
is O(N) in the number of entries of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX296"></A>
<DL>
<DT><U>Method:</U> PROPERTY-LIST <B>length</B> <I>(self) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX297"></A>
<DL>
<DT><U>Method:</U> PROPERTY-LIST <B>lookup</B> <I>(self (key (LIKE (ANY-KEY SELF)))) : (LIKE (ANY-VALUE SELF))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX298"></A>
<DL>
<DT><U>Method:</U> PROPERTY-LIST <B>insert-at</B> <I>(self (key (LIKE (ANY-KEY SELF))) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Insert the entry &#60;`key', <VAR>value</VAR>&#62; into the property list <VAR>self</VAR>.
If a previous entry existed with key <VAR>key</VAR>, that entry is replaced.
</DL>
</P><P>

<A NAME="IDX299"></A>
<DL>
<DT><U>Method:</U> PROPERTY-LIST <B>remove-at</B> <I>(self (key (LIKE (ANY-KEY SELF)))) : OBJECT</I>
<DD>Remove the entry that matches the key <VAR>key</VAR>.  Return the
value of the matching entry, or NULL if there is no matching entry.  Assumes that at
most one entry matches <VAR>key</VAR>.
</DL>
</P><P>

<A NAME="IDX300"></A>
<DL>
<DT><U>Method:</U> PROPERTY-LIST <B>copy</B> <I>(self) : (LIKE SELF)</I>
<DD>Return a copy of the list <VAR>self</VAR>.  The conses in the copy are
freshly allocated.
</DL>
</P><P>

<A NAME="IDX301"></A>
<DL>
<DT><U>Method:</U> PROPERTY-LIST <B>clear</B> <I>(self) :</I>
<DD>Make <VAR>self</VAR> an empty property list.
</DL>
</P><P>

<A NAME="IDX302"></A>
<DL>
<DT><U>Method:</U> PROPERTY-LIST <B>allocate-iterator</B> <I>(self) : (PROPERTY-LIST-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX303"></A>
<DL>
<DT><U>Method:</U> PROPERTY-LIST-ITERATOR <B>next?</B> <I>(self) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX304"></A>
<DL>
<DT><U>Class:</U> <B>KV-CONS</B> <I>: STANDARD-OBJECT</I>
<DD>Not documented.
<A NAME="IDX305"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-key</B> <I>: OBJECT</I>
<DD>Not documented.
</DL>
<A NAME="IDX306"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-value</B> <I>: OBJECT</I>
<DD>Not documented.
</DL>
<A NAME="IDX307"></A>
<DL>
<DT><U>Slot:</U>  <B>key</B> <I>: OBJECT</I>
<DD>Not documented.
</DL>
<A NAME="IDX308"></A>
<DL>
<DT><U>Slot:</U>  <B>value</B> <I>: OBJECT</I>
<DD>Not documented.
</DL>
<A NAME="IDX309"></A>
<DL>
<DT><U>Slot:</U>  <B>rest</B> <I>: KV-CONS</I>
<DD>Not documented.
</DL>
</DL>
</P><P>

<A NAME="IDX310"></A>
<DL>
<DT><U>Function:</U> <B>kv-cons</B> <I>((key OBJECT) (value OBJECT) (rest KV-CONS)) : KV-CONS</I>
<DD>Create, fill-in, and return a new KV-CONS.
</DL>
</P><P>

<A NAME="IDX311"></A>
<DL>
<DT><U>Function:</U> <B>copy-kv-cons-list</B> <I>((kvconslist KV-CONS)) : KV-CONS</I>
<DD>Return a copy of the cons list <CODE>consList</CODE>.
</DL>
</P><P>

<A NAME="IDX312"></A>
<DL>
<DT><U>Class:</U> <B>KEY-VALUE-LIST</B> <I>: DICTIONARY</I>
<DD>Not documented.
<A NAME="IDX313"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-key</B> <I>: OBJECT</I>
<DD>Not documented.
</DL>
<A NAME="IDX314"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-value</B> <I>: OBJECT</I>
<DD>Not documented.
</DL>
<A NAME="IDX315"></A>
<DL>
<DT><U>Slot:</U>  <B>the-kv-list</B> <I>: KV-CONS</I>
<DD>Not documented.
</DL>
</DL>
</P><P>

<A NAME="IDX316"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-LIST <B>empty?</B> <I>(self) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX317"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-LIST <B>non-empty?</B> <I>(self) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX318"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-LIST <B>object-equal?</B> <I>(x (y OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>x</VAR> and <VAR>y</VAR> represent the same set of key/value pairs.
</DL>
</P><P>

<A NAME="IDX319"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-LIST <B>equal-hash-code</B> <I>(self) : INTEGER</I>
<DD>Return an <CODE>equal?</CODE> hash code for <VAR>self</VAR>.  Note that this
is O(N) in the number of entries of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX320"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-LIST <B>length</B> <I>(self) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX321"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-LIST <B>lookup</B> <I>(self (key (LIKE (ANY-KEY SELF)))) : (LIKE (ANY-VALUE SELF))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX322"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-LIST <B>reverse</B> <I>(self) : (LIKE SELF)</I>
<DD>Destructively reverse the members of the list <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX323"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-LIST <B>insert-at</B> <I>(self (key (LIKE (ANY-KEY SELF))) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Insert the entry &#60;`key', <VAR>value</VAR>&#62; into the association
<VAR>self</VAR>. If a previous entry existed with key <VAR>key</VAR>, that entry is replaced.
</DL>
</P><P>

<A NAME="IDX324"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-LIST <B>remove-at</B> <I>(self (key (LIKE (ANY-KEY SELF)))) : OBJECT</I>
<DD>Remove the entry that matches the key <VAR>key</VAR>.
Return the value of the matching entry, or NULL if there is no matching entry.
Assumes that at most one entry matches <VAR>key</VAR>.
</DL>
</P><P>

<A NAME="IDX325"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-LIST <B>insert-entry</B> <I>(self (key (LIKE (ANY-KEY SELF))) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Insert an entry &#60;`key',<VAR>value</VAR>&#62; to <VAR>self</VAR> unless an identical
entry already exists.  This can generate duplicate entries for <VAR>key</VAR>.
</DL>
</P><P>

<A NAME="IDX326"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-LIST <B>remove-entry</B> <I>(self (key (LIKE (ANY-KEY SELF))) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Remove the entry that matches &#60;`key',<VAR>value</VAR>&#62;.
Assumes that more than one entry can match <VAR>key</VAR>.
</DL>
</P><P>

<A NAME="IDX327"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-LIST <B>push</B> <I>(self (value KV-CONS)) :</I>
<DD>Make <VAR>value</VAR> be the new first element of <VAR>self</VAR>.  Note that
the <CODE>rest</CODE> slot of <VAR>value</VAR> should be <CODE>null</CODE>, since it will be overwritten.
This might duplicate an existing entry. If a previous entry existed with the
same key as <VAR>value</VAR>, that entry is retained, but shadowed by this new entry.
</DL>
</P><P>

<A NAME="IDX328"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-LIST <B>kv-push</B> <I>(self (key (LIKE (ANY-KEY SELF))) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Add a new entry &#60;`key', <VAR>value</VAR>&#62; to the front of the association
<VAR>self</VAR>. This might duplicate an existing entry. If a previous entry existed with key
<VAR>key</VAR>, that entry is retained, but shadowed by this new entry.
</DL>
</P><P>

<A NAME="IDX329"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-LIST <B>pop</B> <I>(self) : (LIKE (ANY-VALUE SELF))</I>
<DD>Remove and return the value of the first element of the
kv-list <VAR>self</VAR>.  It does NOT return the KV-CONS object.  Return <CODE>null</CODE> if
the list is empty.
</DL>
</P><P>

<A NAME="IDX330"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-LIST <B>copy</B> <I>(self) : (LIKE SELF)</I>
<DD>Return a copy of the kv-list <VAR>self</VAR>.  The kv-conses in
the copy are freshly allocated.
</DL>
</P><P>

<A NAME="IDX331"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-LIST <B>clear</B> <I>(self) :</I>
<DD>Make <VAR>self</VAR> an empty dictionary.
</DL>
</P><P>

<A NAME="IDX332"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-LIST <B>consify</B> <I>(self) : (CONS OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return a list of key-value pairs in <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX333"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-LIST <B>allocate-iterator</B> <I>(self) : (KV-LIST-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX334"></A>
<DL>
<DT><U>Method:</U> KV-LIST-ITERATOR <B>next?</B> <I>(self) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="Vectors"></A>
<HR SIZE="6">
<A NAME="SEC40"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC39"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC41"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.8 Vectors </H2>
<!--docid::SEC40::-->
<P>

<A NAME="IDX335"></A>
<DL>
<DT><U>Class:</U> <B>VECTOR</B> <I>: SEQUENCE</I>
<DD>Not documented.
<A NAME="IDX336"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-value</B> <I>: OBJECT</I>
<DD>Not documented.
</DL>
<A NAME="IDX337"></A>
<DL>
<DT><U>Slot:</U>  <B>array-size</B> <I>: INTEGER</I>
<DD>Not documented.
</DL>
<A NAME="IDX338"></A>
<DL>
<DT><U>Slot:</U>  <B>the-array</B> <I>: (NATIVE-VECTOR OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Not documented.
</DL>
</DL>
</P><P>

<A NAME="IDX339"></A>
<DL>
<DT><U>Class:</U> <B>EXTENSIBLE-VECTOR</B> <I>: VECTOR</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX340"></A>
<DL>
<DT><U>Method:</U> VECTOR <B>empty?</B> <I>(self) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>self</VAR> has length 0.
</DL>
</P><P>

<A NAME="IDX341"></A>
<DL>
<DT><U>Method:</U> VECTOR <B>non-empty?</B> <I>(self) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>self</VAR> has length &#62; 0.
</DL>
</P><P>

<A NAME="IDX342"></A>
<DL>
<DT><U>Method:</U> VECTOR <B>object-equal?</B> <I>(x (y OBJECT)) : BOOLEAN</I>
<DD>Return TRUE iff the vectors <VAR>x</VAR> and <VAR>y</VAR> are structurally
equivalent.  Uses <CODE>equal?</CODE> to test equality of elements.
</DL>
</P><P>

<A NAME="IDX343"></A>
<DL>
<DT><U>Method:</U> VECTOR <B>equal-hash-code</B> <I>(self) : INTEGER</I>
<DD>Return an <CODE>equal?</CODE> hash code for <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX344"></A>
<DL>
<DT><U>Function:</U> <B>vector</B> <I>(&#38;rest (values OBJECT)) : VECTOR</I>
<DD>Return a vector containing <VAR>values</VAR>, in order.
</DL>
</P><P>

<A NAME="IDX345"></A>
<DL>
<DT><U>Method:</U> VECTOR <B>first</B> <I>(self) : (LIKE (ANY-VALUE SELF))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX346"></A>
<DL>
<DT><U>Method:</U> VECTOR <B>second</B> <I>(self) : (LIKE (ANY-VALUE SELF))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX347"></A>
<DL>
<DT><U>Method:</U> VECTOR <B>third</B> <I>(self) : (LIKE (ANY-VALUE SELF))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX348"></A>
<DL>
<DT><U>Method:</U> VECTOR <B>fourth</B> <I>(self) : (LIKE (ANY-VALUE SELF))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX349"></A>
<DL>
<DT><U>Method:</U> VECTOR <B>fifth</B> <I>(self) : (LIKE (ANY-VALUE SELF))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX350"></A>
<DL>
<DT><U>Method:</U> VECTOR <B>nth</B> <I>(self (position INTEGER)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX351"></A>
<DL>
<DT><U>Method:</U> VECTOR <B>last</B> <I>(self) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the last item in the vector <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX352"></A>
<DL>
<DT><U>Method:</U> VECTOR <B>but-last</B> <I>(self) : (ITERATOR OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Generate all but the last element of the vector <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX353"></A>
<DL>
<DT><U>Method:</U> VECTOR <B>length</B> <I>(self) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX354"></A>
<DL>
<DT><U>Method:</U> VECTOR <B>member?</B> <I>(self (object OBJECT)) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX355"></A>
<DL>
<DT><U>Method:</U> VECTOR <B>position</B> <I>(self (object OBJECT) (start INTEGER)) : INTEGER</I>
<DD>Return the position of <VAR>object</VAR> within the vector
<VAR>self</VAR> (counting from zero); or return <CODE>null</CODE> if <VAR>object</VAR> does not occur within 
<VAR>self</VAR> (uses an <CODE>eql?</CODE> test).  If <VAR>start</VAR> was supplied as non-`null', only 
consider the portion starting at <VAR>start</VAR>, however, the returned position 
will always be relative to the entire vector.
</DL>
</P><P>

<A NAME="IDX356"></A>
<DL>
<DT><U>Method:</U> VECTOR <B>last-position</B> <I>(self (object OBJECT) (end INTEGER)) : INTEGER</I>
<DD>Return the position of <VAR>object</VAR> within the vector
<VAR>self</VAR> (counting from zero); or return <CODE>null</CODE> if <VAR>object</VAR> does not occur within 
<VAR>self</VAR> (uses an <CODE>eql?</CODE> test).  If <VAR>end</VAR> was supplied as non-`null', only 
consider the portion ending at index <VAR>end</VAR>, however, the returned position 
will always be relative to the entire vector.
</DL>
</P><P>

<A NAME="IDX357"></A>
<DL>
<DT><U>Method:</U> VECTOR <B>insert-at</B> <I>(self (offset INTEGER) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX358"></A>
<DL>
<DT><U>Method:</U> VECTOR <B>copy</B> <I>(self) : (VECTOR OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return a copy of the vector <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX359"></A>
<DL>
<DT><U>Method:</U> VECTOR <B>clear</B> <I>(self) :</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX360"></A>
<DL>
<DT><U>Function:</U> <B>resize-vector</B> <I>((self VECTOR) (size INTEGER)) :</I>
<DD>Change the size of <VAR>self</VAR> to <VAR>size</VAR>.  If <VAR>size</VAR> is smaller
than the current size of <VAR>self</VAR> the vector will be truncated.  Otherwise, 
the internal array of <VAR>self</VAR> will be grown to <VAR>size</VAR> and unused elements
will be initialized to NULL.
</DL>
</P><P>

<A NAME="IDX361"></A>
<DL>
<DT><U>Method:</U> VECTOR <B>consify</B> <I>(self) : (CONS OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return a list of elements in <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX362"></A>
<DL>
<DT><U>Method:</U> EXTENSIBLE-VECTOR <B>insert-at</B> <I>(self (offset INTEGER) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX363"></A>
<DL>
<DT><U>Method:</U> VECTOR-SEQUENCE <B>insert</B> <I>(self (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Append <VAR>value</VAR> to the END of the sequence <VAR>self</VAR>.  
Resize the array if necessary.
</DL>
</P><P>

<A NAME="IDX364"></A>
<DL>
<DT><U>Method:</U> VECTOR-SEQUENCE <B>remove</B> <I>(self (value (LIKE (ANY-VALUE SELF)))) : VECTOR-SEQUENCE</I>
<DD>Remove <VAR>value</VAR> from the sequence <VAR>self</VAR>, and left shift
the values after it to close the gap.
</DL>
</P><P>

<A NAME="IDX365"></A>
<DL>
<DT><U>Method:</U> VECTOR-SEQUENCE <B>length</B> <I>(self) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="Hash Tables"></A>
<HR SIZE="6">
<A NAME="SEC41"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC40"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC42"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.9 Hash Tables </H2>
<!--docid::SEC41::-->
<P>

<A NAME="IDX366"></A>
<DL>
<DT><U>Class:</U> <B>HASH-TABLE</B> <I>: ABSTRACT-HASH-TABLE</I>
<DD>Not documented.
<A NAME="IDX367"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-key</B> <I>: OBJECT</I>
<DD>Not documented.
</DL>
<A NAME="IDX368"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-value</B> <I>: OBJECT</I>
<DD>Not documented.
</DL>
</DL>
</P><P>

<A NAME="IDX369"></A>
<DL>
<DT><U>Class:</U> <B>STRING-HASH-TABLE</B> <I>: ABSTRACT-HASH-TABLE</I>
<DD>Not documented.
<A NAME="IDX370"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-key</B> <I>: STRING</I>
<DD>Not documented.
</DL>
<A NAME="IDX371"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-value</B> <I>: OBJECT</I>
<DD>Not documented.
</DL>
</DL>
</P><P>

<A NAME="IDX372"></A>
<DL>
<DT><U>Class:</U> <B>STRING-TO-INTEGER-HASH-TABLE</B> <I>: ABSTRACT-HASH-TABLE</I>
<DD>Not documented.
<A NAME="IDX373"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-key</B> <I>: STRING</I>
<DD>Not documented.
</DL>
<A NAME="IDX374"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-value</B> <I>: INTEGER</I>
<DD>Not documented.
</DL>
</DL>
</P><P>

<A NAME="IDX375"></A>
<DL>
<DT><U>Class:</U> <B>INTEGER-HASH-TABLE</B> <I>: ABSTRACT-HASH-TABLE</I>
<DD>Not documented.
<A NAME="IDX376"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-key</B> <I>: INTEGER</I>
<DD>Not documented.
</DL>
<A NAME="IDX377"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-value</B> <I>: OBJECT</I>
<DD>Not documented.
</DL>
</DL>
</P><P>

<A NAME="IDX378"></A>
<DL>
<DT><U>Class:</U> <B>FLOAT-HASH-TABLE</B> <I>: ABSTRACT-HASH-TABLE</I>
<DD>Not documented.
<A NAME="IDX379"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-key</B> <I>: FLOAT</I>
<DD>Not documented.
</DL>
<A NAME="IDX380"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-value</B> <I>: OBJECT</I>
<DD>Not documented.
</DL>
</DL>
</P><P>

<A NAME="IDX381"></A>
<DL>
<DT><U>Method:</U> HASH-TABLE <B>lookup</B> <I>(self (key (LIKE (ANY-KEY SELF)))) : (LIKE (ANY-VALUE SELF))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX382"></A>
<DL>
<DT><U>Method:</U> HASH-TABLE <B>insert-at</B> <I>(self (key (LIKE (ANY-KEY SELF))) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX383"></A>
<DL>
<DT><U>Method:</U> HASH-TABLE <B>remove-at</B> <I>(self (key (LIKE (ANY-KEY SELF)))) :</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX384"></A>
<DL>
<DT><U>Method:</U> STRING-HASH-TABLE <B>lookup</B> <I>(self (key STRING)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX385"></A>
<DL>
<DT><U>Method:</U> STRING-HASH-TABLE <B>insert-at</B> <I>(self (key STRING) (value OBJECT)) :</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX386"></A>
<DL>
<DT><U>Method:</U> STRING-HASH-TABLE <B>remove-at</B> <I>(self (key STRING)) :</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX387"></A>
<DL>
<DT><U>Method:</U> STRING-TO-INTEGER-HASH-TABLE <B>lookup</B> <I>(self (key STRING)) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX388"></A>
<DL>
<DT><U>Method:</U> STRING-TO-INTEGER-HASH-TABLE <B>insert-at</B> <I>(self (key STRING) (value INTEGER)) :</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX389"></A>
<DL>
<DT><U>Method:</U> INTEGER-HASH-TABLE <B>lookup</B> <I>(self (key INTEGER)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX390"></A>
<DL>
<DT><U>Method:</U> INTEGER-HASH-TABLE <B>insert-at</B> <I>(self (key INTEGER) (value OBJECT)) :</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX391"></A>
<DL>
<DT><U>Method:</U> FLOAT-HASH-TABLE <B>insert-at</B> <I>(self (key FLOAT) (value OBJECT)) :</I>
<DD>Not documented.
</DL>
</P><P>

STELLA provides its own implementation of hash tables for cases where
language-native implementations are not available, or where additional
features are needed.
</P><P>

<A NAME="IDX392"></A>
<DL>
<DT><U>Class:</U> <B>STELLA-HASH-TABLE</B> <I>: ABSTRACT-HASH-TABLE</I>
<DD>Not documented.
<A NAME="IDX393"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-key</B> <I>: OBJECT</I>
<DD>Not documented.
</DL>
<A NAME="IDX394"></A>
<DL>
<DT><U>Class Parameter:</U>  <B>any-value</B> <I>: OBJECT</I>
<DD>Not documented.
</DL>
<A NAME="IDX395"></A>
<DL>
<DT><U>Slot:</U>  <B>the-table</B> <I>: (ARRAY SIZE () OF KV-CONS)</I>
<DD>Not documented.
</DL>
<A NAME="IDX396"></A>
<DL>
<DT><U>Slot:</U>  <B>size</B> <I>: INTEGER</I>
<DD>Not documented.
</DL>
<A NAME="IDX397"></A>
<DL>
<DT><U>Slot:</U>  <B>initial-size</B> <I>: INTEGER</I>
<DD>If supplied, the initial hash table
will be sized to hold at least that many elements.
</DL>
<A NAME="IDX398"></A>
<DL>
<DT><U>Slot:</U>  <B>free-elements</B> <I>: INTEGER</I>
<DD>Not documented.
</DL>
<A NAME="IDX399"></A>
<DL>
<DT><U>Slot:</U>  <B>equal-test?</B> <I>: BOOLEAN</I>
<DD>If true use <CODE>equal?</CODE> as the
equality test and <CODE>equal-hash-code</CODE> as the hash function, otherwise,
use <CODE>eql?</CODE> and <CODE>hash-code</CODE> (the default).
</DL>
</DL>
</P><P>

<A NAME="IDX400"></A>
<DL>
<DT><U>Method:</U> STELLA-HASH-TABLE <B>lookup</B> <I>(self (key (LIKE (ANY-KEY SELF)))) : (LIKE (ANY-VALUE SELF))</I>
<DD>Lookup the entry identified by <VAR>key</VAR> in <VAR>self</VAR> and
return its value, or NULL if no such entry exists.    Uses an <CODE>eql?</CODE>
test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX401"></A>
<DL>
<DT><U>Method:</U> STELLA-HASH-TABLE <B>insert-at</B> <I>(self (key (LIKE (ANY-KEY SELF))) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Set the value of the entry identified by <VAR>key</VAR> in <VAR>self</VAR>
to <VAR>value</VAR> or add a new entry if no entry with <VAR>key</VAR> exists yet.  Uses an
<CODE>eql?</CODE> test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX402"></A>
<DL>
<DT><U>Method:</U> STELLA-HASH-TABLE <B>remove-at</B> <I>(self (key (LIKE (ANY-KEY SELF)))) :</I>
<DD>Remove the entry identified by <VAR>key</VAR> from <VAR>self</VAR>.  Uses an
<CODE>eql?</CODE> test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX403"></A>
<DL>
<DT><U>Method:</U> STELLA-HASH-TABLE <B>length</B> <I>(self) : INTEGER</I>
<DD>Return the number of entries in <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX404"></A>
<DL>
<DT><U>Method:</U> STELLA-HASH-TABLE <B>empty?</B> <I>(self) : BOOLEAN</I>
<DD>Return TRUE if <VAR>self</VAR> has zero entries.
</DL>
</P><P>

<A NAME="IDX405"></A>
<DL>
<DT><U>Method:</U> STELLA-HASH-TABLE <B>non-empty?</B> <I>(self) : BOOLEAN</I>
<DD>Return TRUE if <VAR>self</VAR> has at least 1 entry.
</DL>
</P><P>

<A NAME="IDX406"></A>
<DL>
<DT><U>Method:</U> STELLA-HASH-TABLE <B>copy</B> <I>(self) : (LIKE SELF)</I>
<DD>Return a copy of the hash table <VAR>self</VAR>.  The bucket table
and buckets are freshly allocated, however, the keys and values of entries
are not copied themselves (similar to what we do for lists, etc.).
</DL>
</P><P>

<A NAME="IDX407"></A>
<DL>
<DT><U>Method:</U> STELLA-HASH-TABLE <B>clear</B> <I>(self) :</I>
<DD>Remove all entries from <VAR>self</VAR>.  This will result in a
re-initialization of the table upon the first insertion into <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX408"></A>
<DL>
<DT><U>Method:</U> STELLA-HASH-TABLE <B>consify</B> <I>(self) : (CONS OF CONS)</I>
<DD>Collect all entries of <VAR>self</VAR> into a cons list of
<CODE>(&#60;key&#62; &#60;value&#62;)</CODE> pairs and return the result.
</DL>
</P><P>

<A NAME="IDX409"></A>
<DL>
<DT><U>Method:</U> STELLA-HASH-TABLE <B>object-equal?</B> <I>(x (y OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>x</VAR> and <VAR>y</VAR> represent the same set of key/value pairs.
</DL>
</P><P>

<A NAME="IDX410"></A>
<DL>
<DT><U>Method:</U> STELLA-HASH-TABLE <B>equal-hash-code</B> <I>(self) : INTEGER</I>
<DD>Return an <CODE>equal?</CODE> hash code for <VAR>self</VAR>.  Note that this
is O(N) in the number of entries of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX411"></A>
<DL>
<DT><U>Method:</U> STELLA-HASH-TABLE <B>allocate-iterator</B> <I>(self) : (STELLA-HASH-TABLE-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))</I>
<DD>Allocate an iterator for <VAR>self</VAR>.
</DL>
</P><P>

Hashing objects into STELLA hash tables is accomplished via
<CODE>hash-code</CODE> and <CODE>equal-hash-code</CODE> methods.  These methods are
implemented for all built-in STELLA types but are user extensible for
cases where special functionality on user-defined objects is needed.
Defining new <CODE>hash-code</CODE> methods should only be necessary if new
wrapper types are defined, since for all types descending from
<CODE>STANDARD-OBJECT</CODE> the built-in method should be adequate.
</P><P>

<A NAME="IDX412"></A>
<DL>
<DT><U>Function:</U> <B>object-hash-code</B> <I>((self OBJECT)) : INTEGER</I>
<DD>Return a hash code for <VAR>self</VAR> (can be negative).  Two objects that are <CODE>eq?</CODE>
are guaranteed to generate the same hash code.  Two objects that are not <CODE>eq?</CODE>
do not necessarily generate different hash codes.  Similar to <CODE>hash-code</CODE> but
always hashes on the address of <VAR>self</VAR> even if it is a wrapper.
</DL>
</P><P>

<A NAME="IDX413"></A>
<DL>
<DT><U>Method:</U> OBJECT <B>hash-code</B> <I>(self) : INTEGER</I>
<DD>Return a hash code for <VAR>self</VAR> (can be negative).  Two objects that are <CODE>eql?</CODE>
are guaranteed to generate the same hash code.  Two objects that are not <CODE>eql?</CODE>
do not necessarily generate different hash codes.
</DL>
</P><P>

<A NAME="IDX414"></A>
<DL>
<DT><U>Method:</U> STANDARD-OBJECT <B>hash-code</B> <I>(self) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX415"></A>
<DL>
<DT><U>Method:</U> STRING-WRAPPER <B>hash-code</B> <I>(self) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX416"></A>
<DL>
<DT><U>Method:</U> INTEGER-WRAPPER <B>hash-code</B> <I>(self) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX417"></A>
<DL>
<DT><U>Method:</U> FLOAT-WRAPPER <B>hash-code</B> <I>(self) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX418"></A>
<DL>
<DT><U>Method:</U> CHARACTER-WRAPPER <B>hash-code</B> <I>(self) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX419"></A>
<DL>
<DT><U>Method:</U> BOOLEAN-WRAPPER <B>hash-code</B> <I>(self) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX420"></A>
<DL>
<DT><U>Method:</U> STRING <B>hash-code</B> <I>(self) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX421"></A>
<DL>
<DT><U>Method:</U> INTEGER <B>hash-code</B> <I>(self) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX422"></A>
<DL>
<DT><U>Method:</U> FLOAT <B>hash-code</B> <I>(self) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX423"></A>
<DL>
<DT><U>Method:</U> CHARACTER <B>hash-code</B> <I>(self) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX424"></A>
<DL>
<DT><U>Method:</U> OBJECT <B>equal-hash-code</B> <I>(self) : INTEGER</I>
<DD>Return a hash code for <VAR>self</VAR> (can be negative).  Two objects that are <CODE>equal?</CODE>
are guaranteed to generate the same hash code (provided, that writers of
<CODE>object-equal?</CODE> methods also implemented the appropriate <CODE>equal-hash-code</CODE>
method).  Two objects that are not <CODE>equal?</CODE>do not necessarily generate different
hash codes.
</DL>
</P><P>

The following low-level utilities are available to implement specialized
hashing schemes or for defining new versions of <CODE>equal-hash-code</CODE>.
</P><P>

<A NAME="IDX425"></A>
<DL>
<DT><U>Function:</U> <B>hashmod</B> <I>((code INTEGER) (size INTEGER)) : INTEGER</I>
<DD>Map the hash code <VAR>code</VAR> onto a bucket index for a hash table
of <VAR>size</VAR> (i.e., onto the interval [0..size-1].  This is just like <CODE>rem</CODE> for
positive hash codes but also works for negative hash codes by mapping those
onto a positive number first.  Note, that the sign conversion mapping is not
equivalent to calling the <CODE>abs</CODE> function (it simply masks the sign bit for
speed) and therefore really only makes sense for hash codes.
</DL>
</P><P>

<A NAME="IDX426"></A>
<DL>
<DT><U>Function:</U> <B>rotate-hash-code</B> <I>((arg INTEGER)) : INTEGER</I>
<DD>Rotate <VAR>arg</VAR> to the right by 1 position.  This means shift <VAR>arg</VAR> to the right
by one and feed in <VAR>arg</VAR>s bit zero from the left.  In Lisp the result will stay
in positive FIXNUM range.  In C++ and Java this might return a negative
value which might be equal to NULL-INTEGER.  Important: to make this inlinable,
it must be called with an atom (i.e., constant or variable) as its argument.
This function is primarily useful for hashing sequences of items where the hash
code should take the sequential order of elements into account (e.g., lists).
</DL>
</P><P>

<A NAME="Key Value Maps"></A>
<HR SIZE="6">
<A NAME="SEC42"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC41"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC43"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.10 Key Value Maps </H2>
<!--docid::SEC42::-->
<P>

<CODE>KEY-VALUE-MAP</CODE> is a full-featured dictionary class that supports
<CODE>eql?</CODE> or extensible <CODE>equal?</CODE> equality tests, O(1) access
operations even for large numbers of entries by using a hash table,
light-weight <CODE>KV-CONS</CODE> representation for small tables and
iteration even if the dictionary is represented by a hash table (note
that in STELLA we cannot iterate over regular <CODE>HASH-TABLE</CODE>'s, since
native Lisp hash tables do not allow us to implement a hash table
iterator).  Since large <CODE>KEY-VALUE-MAP</CODE>'s are implemented via
<CODE>STELLA-HASH-TABLE</CODE>'s, we can support iteration.
</P><P>

<A NAME="IDX427"></A>
<DL>
<DT><U>Class:</U> <B>KEY-VALUE-MAP</B> <I>: DICTIONARY</I>
<DD>Full-featured dictionary class that supports <CODE>eql?</CODE> or
<CODE>equal?</CODE> equality tests, O(1) access operations even for large numbers
of entries by using a hash table, light-weight KV-CONS representation for
small tables and iteration even if the dictionary is represented by a
hash table.
<A NAME="IDX428"></A>
<DL>
<DT><U>Slot:</U>  <B>the-map</B> <I>: OBJECT</I>
<DD>Not documented.
</DL>
<A NAME="IDX429"></A>
<DL>
<DT><U>Slot:</U>  <B>equal-test?</B> <I>: BOOLEAN</I>
<DD>If true use <CODE>equal?</CODE> as the
equality test (and <CODE>equal-hash-code</CODE> as the hash function), otherwise,
use <CODE>eql?</CODE> (and <CODE>hash-code</CODE>) (the default).
</DL>
<A NAME="IDX430"></A>
<DL>
<DT><U>Slot:</U>  <B>initial-size</B> <I>: INTEGER</I>
<DD>If supplied, the initial table
will be sized to hold at least that many elements.
</DL>
<A NAME="IDX431"></A>
<DL>
<DT><U>Slot:</U>  <B>crossover-point</B> <I>: INTEGER</I>
<DD>Not documented.
</DL>
</DL>
</P><P>

<A NAME="IDX432"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-MAP <B>lookup</B> <I>(self (key (LIKE (ANY-KEY SELF)))) : (LIKE (ANY-VALUE SELF))</I>
<DD>Lookup the entry identified by <VAR>key</VAR> in <VAR>self</VAR> and
return its value, or NULL if no such entry exists.    Uses an <CODE>eql?</CODE>
test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX433"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-MAP <B>insert-at</B> <I>(self (key (LIKE (ANY-KEY SELF))) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Set the value of the entry identified by <VAR>key</VAR> in <VAR>self</VAR>
to <VAR>value</VAR> or add a new entry if no entry with <VAR>key</VAR> exists yet.  Uses an
<CODE>eql?</CODE> test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX434"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-MAP <B>remove-at</B> <I>(self (key (LIKE (ANY-KEY SELF)))) :</I>
<DD>Remove the entry identified by <VAR>key</VAR> from <VAR>self</VAR>.  Uses an
<CODE>eql?</CODE> test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX435"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-MAP <B>length</B> <I>(self) : INTEGER</I>
<DD>Return the number of entries in <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX436"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-MAP <B>empty?</B> <I>(self) : BOOLEAN</I>
<DD>Return TRUE if <VAR>self</VAR> has zero entries.
</DL>
</P><P>

<A NAME="IDX437"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-MAP <B>non-empty?</B> <I>(self) : BOOLEAN</I>
<DD>Return TRUE if <VAR>self</VAR> has at least 1 entry.
</DL>
</P><P>

<A NAME="IDX438"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-MAP <B>copy</B> <I>(self) : (LIKE SELF)</I>
<DD>Return a copy of the map <VAR>self</VAR>.  All entries are freshly
allocated, however, the keys and values of entries are not copied themselves
 (similar to what we do for lists, etc.).
</DL>
</P><P>

<A NAME="IDX439"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-MAP <B>clear</B> <I>(self) :</I>
<DD>Reset <VAR>self</VAR> to have zero entries.
</DL>
</P><P>

<A NAME="IDX440"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-MAP <B>allocate-iterator</B> <I>(self) : (DICTIONARY-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))</I>
<DD>Allocate an iterator for <VAR>self</VAR>.  The only modifying
operations allowed during iteration are removal of the current element or
changing its value.  All other removal or insertion operations might lead
to corruption or undefined results.
</DL>
</P><P>

<A NAME="IDX441"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-MAP <B>consify</B> <I>(self) : CONS</I>
<DD>Collect all entries of <VAR>self</VAR> into a cons list of
<CODE>(&#60;key&#62; &#60;value&#62;)</CODE> pairs and return the result.
</DL>
</P><P>

<A NAME="IDX442"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-MAP <B>object-equal?</B> <I>(x (y OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>x</VAR> and <VAR>y</VAR> represent the same set of key/value pairs.
</DL>
</P><P>

<A NAME="IDX443"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-MAP <B>equal-hash-code</B> <I>(self) : INTEGER</I>
<DD>Return an <CODE>equal?</CODE> hash code for <VAR>self</VAR>.  Note that this
is O(N) in the number of entries of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="Hash Sets"></A>
<HR SIZE="6">
<A NAME="SEC43"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC42"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC44"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.11 Hash Sets </H2>
<!--docid::SEC43::-->
<P>

<CODE>HASH-SET</CODE> is a full-featured set class that supports <CODE>eql?</CODE>
or extensible <CODE>equal?</CODE> equality tests, O(1) insert and
<CODE>member?</CODE> operations, O(N) <CODE>intersection</CODE> etc. operations even
for large numbers of entries by using a STELLA hash table, light-weight
<CODE>KV-CONS</CODE> representation for small sets and iteration even if the
set is represented by a hash table.  The only minor drawback right now
is that we waste one value slot per entry, since we piggy-back off
<CODE>KEY-VALUE-MAP</CODE>'s, however, that wastes at most 25% space.
</P><P>

<A NAME="IDX444"></A>
<DL>
<DT><U>Class:</U> <B>HASH-SET</B> <I>: KEY-VALUE-MAP, SET-MIXIN</I>
<DD>Full-featured set class that supports <CODE>eql?</CODE> or <CODE>equal?</CODE>
equality tests, O(1) insert and <CODE>member?</CODE> operations &#38; O(N) <CODE>intersection</CODE>
etc. operations even for large numbers of entries by using a hash table,
light-weight KV-CONS representation for small sets and iteration even if the
set is represented by a hash table.  The only minor drawback right now is that
this wastes a value slot per entry, since we piggy-back off KEY-VALUE-MAP's,
however, that wastes at most 25% space.
</DL>
</P><P>

<A NAME="IDX445"></A>
<DL>
<DT><U>Function:</U> <B>hash-set</B> <I>(&#38;rest (values OBJECT)) : HASH-SET</I>
<DD>Return an <CODE>eql?</CODE> HASH-SET containing <VAR>values</VAR>.
</DL>
</P><P>

<A NAME="IDX446"></A>
<DL>
<DT><U>Method:</U> HASH-SET <B>member?</B> <I>(self (object OBJECT)) : BOOLEAN</I>
<DD>Return TRUE iff <VAR>object</VAR> is a member of the set <VAR>self</VAR>.
Uses an <CODE>eql?</CODE> test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX447"></A>
<DL>
<DT><U>Method:</U> HASH-SET <B>insert</B> <I>(self (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Add <VAR>value</VAR> to the set <VAR>self</VAR> unless it is already a member.
Uses an <CODE>eql?</CODE> test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX448"></A>
<DL>
<DT><U>Method:</U> HASH-SET <B>remove</B> <I>(self (value (LIKE (ANY-VALUE SELF)))) : (LIKE SELF)</I>
<DD>Destructively remove <VAR>value</VAR> from the set <VAR>self</VAR> if it is a member and
return <VAR>self</VAR>.  Uses an <CODE>eql?</CODE> test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of
<VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX449"></A>
<DL>
<DT><U>Method:</U> HASH-SET <B>remove-if</B> <I>(self (test? FUNCTION-CODE)) : (LIKE SELF)</I>
<DD>Destructively remove all elements of the set <VAR>self</VAR> for which
<VAR>test?</VAR> evaluates to TRUE.  <VAR>test?</VAR> takes a single argument of type OBJECT and
returns TRUE or FALSE.  Returns <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX450"></A>
<DL>
<DT><U>Method:</U> HASH-SET <B>pop</B> <I>(self) : (LIKE (ANY-VALUE SELF))</I>
<DD>Remove and return an arbitrary element of the set <VAR>self</VAR>.
Return NULL if the set is empty.  Performance note: for large sets implemented
via hash tables it takes O(N) to empty out the set with repeated calls to <CODE>pop</CODE>,
since the emptier the table gets, the longer it takes to find an element.
Therefore, it is usually better to use iteration with embedded removals for
such cases.
</DL>
</P><P>

<A NAME="IDX451"></A>
<DL>
<DT><U>Method:</U> HASH-SET <B>substitute</B> <I>(self (new OBJECT) (old OBJECT)) : (LIKE SELF)</I>
<DD>Destructively replace <VAR>old</VAR> with <VAR>new</VAR> in the set <VAR>self</VAR>
unless <VAR>new</VAR> is already a member.  Uses an <CODE>eql?</CODE> test by default or <CODE>equal?</CODE>
if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX452"></A>
<DL>
<DT><U>Method:</U> HASH-SET <B>copy</B> <I>(self) : (LIKE SELF)</I>
<DD>Return a copy of the set <VAR>self</VAR>.  All entries are freshly
allocated, however, the values are not copied themselves (similar to what we
do for lists, etc.).
</DL>
</P><P>

<A NAME="IDX453"></A>
<DL>
<DT><U>Method:</U> HASH-SET <B>consify</B> <I>(self) : (CONS OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Collect all entries of <VAR>self</VAR> into a cons list and return the result.
</DL>
</P><P>

<A NAME="IDX454"></A>
<DL>
<DT><U>Method:</U> HASH-SET <B>subset?</B> <I>(self (otherSet HASH-SET)) : BOOLEAN</I>
<DD>Return true if every element of <VAR>self</VAR> also occurs in <VAR>otherSet</VAR>.
Uses an <CODE>eql?</CODE> test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX455"></A>
<DL>
<DT><U>Method:</U> HASH-SET <B>equivalent-sets?</B> <I>(self (otherSet HASH-SET)) : BOOLEAN</I>
<DD>Return true if every element of <VAR>self</VAR> occurs in <VAR>otherSet</VAR> and vice versa.
Uses an <CODE>eql?</CODE> test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX456"></A>
<DL>
<DT><U>Method:</U> HASH-SET <B>intersection</B> <I>(self (otherSet HASH-SET)) : HASH-SET</I>
<DD>Return the set intersection of <VAR>self</VAR> and <VAR>otherSet</VAR> as a new set.
Uses an <CODE>eql?</CODE> test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX457"></A>
<DL>
<DT><U>Method:</U> HASH-SET <B>union</B> <I>(self (otherSet HASH-SET)) : HASH-SET</I>
<DD>Return the set union of <VAR>self</VAR> and <VAR>otherSet</VAR> as a new set.
Uses an <CODE>eql?</CODE> test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX458"></A>
<DL>
<DT><U>Method:</U> HASH-SET <B>difference</B> <I>(self (otherSet HASH-SET)) : HASH-SET</I>
<DD>Return the set difference of <VAR>self</VAR> and <VAR>otherSet</VAR> as a new set (i.e.,
all elements that are in <VAR>self</VAR> but not in <VAR>otherSet</VAR>).  Uses an <CODE>eql?</CODE> test
by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX459"></A>
<DL>
<DT><U>Method:</U> HASH-SET <B>subtract</B> <I>(self (otherSet HASH-SET)) : HASH-SET</I>
<DD>Return the set difference of <VAR>self</VAR> and <VAR>otherSet</VAR> by destructively
removing elements from <VAR>self</VAR> that also occur in <VAR>otherSet</VAR>.  Uses an <CODE>eql?</CODE>
test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX460"></A>
<DL>
<DT><U>Method:</U> HASH-SET <B>object-equal?</B> <I>(x (y OBJECT)) : BOOLEAN</I>
<DD>Return TRUE iff sets <VAR>x</VAR> and <VAR>y</VAR> are HASH-SET's with equivalent members.
Uses an <CODE>eql?</CODE> test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <CODE>self</CODE> is TRUE.
This is equivalent to calling <CODE>equivalent-sets?</CODE>.
</DL>
</P><P>

<A NAME="IDX461"></A>
<DL>
<DT><U>Method:</U> HASH-SET <B>equal-hash-code</B> <I>(self) : INTEGER</I>
<DD>Return an <CODE>equal?</CODE> hash code for <VAR>self</VAR>.  Note that this
is O(N) in the number of elements of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="Iterators"></A>
<HR SIZE="6">
<A NAME="SEC44"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC43"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC45"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.12 Iterators </H2>
<!--docid::SEC44::-->
<P>

<A NAME="IDX462"></A>
<DL>
<DT><U>Method:</U> ITERATOR <B>empty?</B> <I>(self) : BOOLEAN</I>
<DD>Return TRUE if the sequence represented by <VAR>self</VAR>
has no elements.  Side-effect free.
</DL>
</P><P>

<A NAME="IDX463"></A>
<DL>
<DT><U>Method:</U> ITERATOR <B>member?</B> <I>(self (value OBJECT)) : BOOLEAN</I>
<DD>Iterate over values of <VAR>self</VAR>, returning TRUE
if one of them is <CODE>eql</CODE> to 'value.
</DL>
</P><P>

<A NAME="IDX464"></A>
<DL>
<DT><U>Method:</U> ABSTRACT-ITERATOR <B>length</B> <I>(self) : INTEGER</I>
<DD>Iterate over <VAR>self</VAR>, and count how many
items there are.  Bad idea if <VAR>self</VAR> iterates over an infinite
collection, since in that case it will run forever.'
</DL>
</P><P>

<A NAME="IDX465"></A>
<DL>
<DT><U>Method:</U> ITERATOR <B>pop</B> <I>(self) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the first item of the sequence represented by <VAR>self</VAR>,
or NULL if it is empty.  Destructively uses up the first iteration element.
</DL>
</P><P>

<A NAME="IDX466"></A>
<DL>
<DT><U>Method:</U> ITERATOR <B>advance</B> <I>(self (n INTEGER)) : (LIKE SELF)</I>
<DD>Return <VAR>self</VAR> after skipping over the first
<VAR>n</VAR> elements in the (remainder of the) iteration.
</DL>
</P><P>

<A NAME="IDX467"></A>
<DL>
<DT><U>Method:</U> ITERATOR <B>concatenate</B> <I>(iterator1 (iterator2 ITERATOR) &#38;rest (otherIterators ITERATOR)) : ALL-PURPOSE-ITERATOR</I>
<DD>Return an iterator that first generates all values of
<VAR>iterator1</VAR>, then those of <VAR>iterator2</VAR>, and then those of all <VAR>otherIterators</VAR>.
The generated values can be filtered by supplying a filter function to the
resulting iterator.
</DL>
</P><P>

<A NAME="IDX468"></A>
<DL>
<DT><U>Method:</U> ITERATOR <B>consify</B> <I>(self) : (CONS OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return a list of elements generated by <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX469"></A>
<DL>
<DT><U>Method:</U> ALL-PURPOSE-ITERATOR <B>next?</B> <I>(self) : BOOLEAN</I>
<DD>Apply the stored <CODE>next?</CODE> function to <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="Symbols"></A>
<HR SIZE="6">
<A NAME="SEC45"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC44"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC46"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.13 Symbols </H2>
<!--docid::SEC45::-->
<P>

<A NAME="IDX470"></A>
<DL>
<DT><U>Function:</U> <B>lookup-symbol</B> <I>((name STRING)) : SYMBOL</I>
<DD>Return the first symbol with <VAR>name</VAR> visible from the current module.
</DL>
</P><P>

<A NAME="IDX471"></A>
<DL>
<DT><U>Function:</U> <B>intern-symbol</B> <I>((name STRING)) : SYMBOL</I>
<DD>Return a newly-created or existing symbol with name <VAR>name</VAR>.
</DL>
</P><P>

<A NAME="IDX472"></A>
<DL>
<DT><U>Function:</U> <B>unintern-symbol</B> <I>((self SYMBOL)) :</I>
<DD>Remove <VAR>self</VAR> from its home module and the symbol table.
</DL>
</P><P>

<A NAME="IDX473"></A>
<DL>
<DT><U>Function:</U> <B>lookup-symbol-in-module</B> <I>((name STRING) (module MODULE) (local? BOOLEAN)) : SYMBOL</I>
<DD>Return the first symbol with <VAR>name</VAR> visible from <VAR>module</VAR>.
If <VAR>local?</VAR> only consider symbols directly interned in <VAR>module</VAR>.
If <VAR>module</VAR> is <CODE>null</CODE>, use <CODE>*MODULE*</CODE> instead.
</DL>
</P><P>

<A NAME="IDX474"></A>
<DL>
<DT><U>Function:</U> <B>intern-symbol-in-module</B> <I>((name STRING) (module MODULE) (local? BOOLEAN)) : SYMBOL</I>
<DD>Look for a symbol named <VAR>name</VAR> in <VAR>module</VAR> (if <VAR>local?</VAR> do
not consider inherited modules).  If none exists, intern it locally in
<VAR>module</VAR>.  Return the existing or newly-created symbol.
</DL>
</P><P>

<A NAME="IDX475"></A>
<DL>
<DT><U>Function:</U> <B>intern-derived-symbol</B> <I>((baseSymbol GENERALIZED-SYMBOL) (newName STRING)) : SYMBOL</I>
<DD>Return a newly-created or existing symbol with name
<VAR>newName</VAR> which is interned in the same module as <VAR>baseSymbol</VAR>.
</DL>
</P><P>

<A NAME="IDX476"></A>
<DL>
<DT><U>Function:</U> <B>visible-symbol?</B> <I>((self SYMBOL)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>self</VAR> is visible from the current module.
</DL>
</P><P>

<A NAME="IDX477"></A>
<DL>
<DT><U>Function:</U> <B>lookup-visible-symbols-in-module</B> <I>((name STRING) (module MODULE) (enforceShadowing? BOOLEAN)) : (CONS OF SYMBOL)</I>
<DD>Return the list of symbols with <VAR>name</VAR> visible from <VAR>module</VAR>.
More specific symbols (relative to the module precedence order defined by
<CODE>visible-modules</CODE>) come earlier in the list.  If <VAR>module</VAR> is <CODE>null</CODE>, start
from <CODE>*MODULE*</CODE> instead.  If <VAR>enforceShadowing?</VAR> is true, do not return any
symbols that are shadowed due to some :SHADOW declaration.
</DL>
</P><P>

<A NAME="IDX478"></A>
<DL>
<DT><U>Function:</U> <B>import-symbol</B> <I>((symbol SYMBOL) (module MODULE)) : SYMBOL</I>
<DD>Import <VAR>symbol</VAR> into <VAR>module</VAR> and return the imported <VAR>symbol</VAR>.
Signal an error if a different symbol with the same name already exists
locally in <VAR>module</VAR>.  Any symbol with the same name visible in <VAR>module</VAR> by
inheritance will be shadowed by the newly imported <VAR>symbol</VAR>.
</DL>
</P><P>

<A NAME="IDX479"></A>
<DL>
<DT><U>Function:</U> <B>safe-import-symbol</B> <I>((symbol SYMBOL) (module MODULE)) : SYMBOL</I>
<DD>Safe version of <CODE>import-symbol</CODE> (which see).  Only imports <VAR>symbol</VAR> if
no symbol with that name is currently interned or visible in <VAR>module</VAR>.
Returns <VAR>symbol</VAR> if it was imported or the conflicting symbol in <VAR>module</VAR>
otherwise.
</DL>
</P><P>

<A NAME="IDX480"></A>
<DL>
<DT><U>Function:</U> <B>lookup-surrogate</B> <I>((name STRING)) : SURROGATE</I>
<DD>Return the first surrogate with <VAR>name</VAR> visible from the current module.
</DL>
</P><P>

<A NAME="IDX481"></A>
<DL>
<DT><U>Function:</U> <B>intern-surrogate</B> <I>((name STRING)) : SURROGATE</I>
<DD>Return a newly-created or existing surrogate with name <VAR>name</VAR>.
</DL>
</P><P>

<A NAME="IDX482"></A>
<DL>
<DT><U>Function:</U> <B>unintern-surrogate</B> <I>((self SURROGATE)) :</I>
<DD>Remove <VAR>self</VAR> from its home module and the surrogate table.
</DL>
</P><P>

<A NAME="IDX483"></A>
<DL>
<DT><U>Function:</U> <B>lookup-surrogate-in-module</B> <I>((name STRING) (module MODULE) (local? BOOLEAN)) : SURROGATE</I>
<DD>Return the first surrogate with <VAR>name</VAR> visible from <VAR>module</VAR>.
If <VAR>local?</VAR> only consider surrogates directly interned in <VAR>module</VAR>.
If <VAR>module</VAR> is <CODE>null</CODE>, use <CODE>*MODULE*</CODE> instead.
</DL>
</P><P>

<A NAME="IDX484"></A>
<DL>
<DT><U>Function:</U> <B>intern-surrogate-in-module</B> <I>((name STRING) (module MODULE) (local? BOOLEAN)) : SURROGATE</I>
<DD>Look for a symbol named <VAR>name</VAR> in <VAR>module</VAR> (if <VAR>local?</VAR> do
not consider inherited modules).  If none exists, intern it locally in
<VAR>module</VAR>.  Return the existing or newly-created symbol.
</DL>
</P><P>

<A NAME="IDX485"></A>
<DL>
<DT><U>Function:</U> <B>intern-derived-surrogate</B> <I>((baseSymbol GENERALIZED-SYMBOL) (newName STRING)) : SURROGATE</I>
<DD>Return a newly-created or existing surrogate with name
<VAR>newName</VAR> which is interned in the same module as <VAR>baseSymbol</VAR>.
</DL>
</P><P>

<A NAME="IDX486"></A>
<DL>
<DT><U>Function:</U> <B>visible-surrogate?</B> <I>((self SURROGATE)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>self</VAR> is visible from the current module.
</DL>
</P><P>

<A NAME="IDX487"></A>
<DL>
<DT><U>Function:</U> <B>lookup-visible-surrogates-in-module</B> <I>((name STRING) (module MODULE) (enforceShadowing? BOOLEAN)) : (CONS OF SURROGATE)</I>
<DD>Return the list of surrogates with <VAR>name</VAR> visible from <VAR>module</VAR>.
More specific surrogates (relative to the module precedence order defined by
<CODE>visible-modules</CODE>) come earlier in the list.  If <VAR>module</VAR> is <CODE>null</CODE>, start
from <CODE>*MODULE*</CODE> instead.  If <VAR>enforceShadowing?</VAR> is true, do not return any
surrogates that are shadowed due to some :SHADOW declaration.
</DL>
</P><P>

<A NAME="IDX488"></A>
<DL>
<DT><U>Function:</U> <B>import-surrogate</B> <I>((surrogate SURROGATE) (module MODULE)) : SURROGATE</I>
<DD>Import <VAR>surrogate</VAR> into <VAR>module</VAR> and return the imported <VAR>surrogate</VAR>.
Signal an error if a different surrogate with the same name already exists
locally in <VAR>module</VAR>.  Any surrogate with the same name visible in <VAR>module</VAR> by
inheritance will be shadowed by the newly imported <VAR>surrogate</VAR>.
</DL>
</P><P>

<A NAME="IDX489"></A>
<DL>
<DT><U>Function:</U> <B>safe-import-surrogate</B> <I>((surrogate SURROGATE) (module MODULE)) : SURROGATE</I>
<DD>Safe version of <CODE>import-surrogate</CODE> (which see).  Only imports <VAR>surrogate</VAR> if
no surrogate with that name is currently interned or visible in <VAR>module</VAR>.
Returns <VAR>surrogate</VAR> if it was imported or the conflicting surrogate in <VAR>module</VAR>
otherwise.
</DL>
</P><P>

<A NAME="IDX490"></A>
<DL>
<DT><U>Function:</U> <B>lookup-keyword</B> <I>((name STRING)) : KEYWORD</I>
<DD>Return the keyword with <VAR>name</VAR> if it exists.
</DL>
</P><P>

<A NAME="IDX491"></A>
<DL>
<DT><U>Function:</U> <B>intern-keyword</B> <I>((name STRING)) : KEYWORD</I>
<DD>Return a newly-created or existing keyword with name
<VAR>name</VAR>.  Storage note: a COPY of <VAR>name</VAR> is stored in the keyword
</DL>
</P><P>

<A NAME="IDX492"></A>
<DL>
<DT><U>Function:</U> <B>gensym</B> <I>((prefix STRING)) : SYMBOL</I>
<DD>Return a transient symbol with a name beginning with
<VAR>prefix</VAR> and ending with a globally gensym'd integer.
</DL>
</P><P>

<A NAME="IDX493"></A>
<DL>
<DT><U>Function:</U> <B>local-gensym</B> <I>((prefix STRING)) : SYMBOL</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX494"></A>
<DL>
<DT><U>Function:</U> <B>symbol-plist</B> <I>((symbol SYMBOL)) : CONS</I>
<DD>Return the property list of <VAR>symbol</VAR>.  The <CODE>symbol-plist</CODE>
of a symbol can be set with <CODE>setf</CODE>.  IMPORTANT: Property list are modified 
destructively, hence, if you supply it as a whole make sure to always supply
a modfiable copy, e.g., by using <CODE>bquote</CODE>.
</DL>
</P><P>

<A NAME="IDX495"></A>
<DL>
<DT><U>Function:</U> <B>symbol-property</B> <I>((symbol SYMBOL) (key STANDARD-OBJECT)) : OBJECT</I>
<DD>Return the property of <VAR>symbol</VAR> whose key is <CODE>eq?</CODE> to <VAR>key</VAR>.
Symbol properties can be set with <CODE>setf</CODE>.
</DL>
</P><P>

<A NAME="IDX496"></A>
<DL>
<DT><U>Function:</U> <B>symbol-value</B> <I>((symbol SYMBOL)) : OBJECT</I>
<DD>Return the value of <VAR>symbol</VAR>.  Note, that this value is not
visible to code that references a variable with the same name as <VAR>symbol</VAR>.
The <CODE>symbol-value</CODE> is simply a special property that can always be accessed
in constant time.  The <CODE>symbol-value</CODE> of a symbol can be changed with <CODE>setf</CODE>.
</DL>
</P><P>

<A NAME="IDX497"></A>
<DL>
<DT><U>Function:</U> <B>symbolize</B> <I>((surrogate SURROGATE)) : SYMBOL</I>
<DD>Convert <VAR>surrogate</VAR> into a symbol with the same name and module.
</DL>
</P><P>

<A NAME="Contexts and Modules"></A>
<HR SIZE="6">
<A NAME="SEC46"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC45"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC47"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.14 Context and Modules </H2>
<!--docid::SEC46::-->
<P>

<A NAME="IDX498"></A>
<DL>
<DT><U>Function:</U> <B>get-stella-context</B> <I>((pathName STRING) (error? BOOLEAN)) : CONTEXT</I>
<DD>Return the context located at <VAR>pathName</VAR>, or <CODE>null</CODE>
if no such context exists.  If <VAR>error?</VAR> is <CODE>true</CODE>, throw an exception
if no context is found, otherwise silently return <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX499"></A>
<DL>
<DT><U>Function:</U> <B>clear-context</B> <I>((self CONTEXT)) :</I>
<DD>Destroy all objects belonging to <VAR>self</VAR> or any of its subcontexts.
</DL>
</P><P>

<A NAME="IDX500"></A>
<DL>
<DT><U>Macro:</U> <B>within-context</B> <I>((contextForm OBJECT) &#38;body (body CONS)) : OBJECT</I>
<DD>Execute <VAR>body</VAR> within the context resulting from <VAR>contextForm</VAR>.
</DL>
</P><P>

<A NAME="IDX501"></A>
<DL>
<DT><U>Method:</U> CONTEXT <B>destroy-context</B> <I>(self) :</I>
<DD>Make the translator happy.
</DL>
</P><P>

<A NAME="IDX502"></A>
<DL>
<DT><U>Method:</U> STRING <B>destroy-context</B> <I>(self) :</I>
<DD>Destroy the context <VAR>self</VAR>, and recursively destroy
all contexts that inherit <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX503"></A>
<DL>
<DT><U>Method:</U> CONTEXT <B>change-context</B> <I>(context) : CONTEXT</I>
<DD>Change the current context to be the context
<VAR>context</VAR>.
</DL>
</P><P>

<A NAME="IDX504"></A>
<DL>
<DT><U>Method:</U> STRING <B>change-context</B> <I>(contextName) : CONTEXT</I>
<DD>Change the current context to be the context named
<VAR>contextName</VAR>.
</DL>
</P><P>

<A NAME="IDX505"></A>
<DL>
<DT><U>N-Command:</U> <B>cc</B> <I>(&#38;rest (name NAME)) : CONTEXT</I>
<DD>Change the current context to the one named <VAR>name</VAR>.  Return the
value of the new current context.  If no <VAR>name</VAR> is supplied, return
the pre-existing value of the current context.  <CODE>cc</CODE> is a no-op if the
context reference cannot be successfully evaluated.
</DL>
</P><P>

<A NAME="IDX506"></A>
<DL>
<DT><U>N-Command:</U> <B>defmodule</B> <I>((name NAME) &#38;rest (options OBJECT)) :</I>
<DD>Define (or redefine) a module named <VAR>name</VAR>.
The accepted syntax is:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  (defmodule &#60;module-name&#62;
     [:documentation &#60;docstring&#62;]
     [:includes {&#60;module-name&#62; | (&#60;module-name&#62;*)}]
     [:uses {&#60;module-name&#62; | (&#60;module-name&#62;*)}]
     [:lisp-package &#60;package-name-string&#62;]
     [:java-package &#60;package-specification-string&#62;]
     [:cpp-namespace &#60;namespace-name-string&#62;]
     [:java-catchall-class
     [:api? {TRUE | FALSE}]
     [:case-sensitive? {TRUE | FALSE}]
     [:shadow (&#60;symbol&#62;*)]
     [:java-catchall-class &#60;class-name-string&#62;]
     [&#60;other-options&#62;*])
</pre></td></tr></table></P><P>

<VAR>name</VAR> can be a string or a symbol.
</P><P>

Modules include objects from other modules via two separate mechanisms:
(1) they inherit from their parents specified via the <CODE>:includes</CODE> option
and/or a fully qualified module name, and (2) they inherit from used
modules specified via the <CODE>:uses</CODE> option.  The main difference between
the two mechanisms is that inheritance from parents is transitive, while
uses-links are only followed one level deep.  I.e., a module A that uses
B will see all objects of B (and any of B's parents) but not see anything
from modules used by B.  Another difference is that only objects declared
as public can be inherited via uses-links (this is not yet enforced).
Note that - contrary to Lisp - there are separate name spaces for classes,
functions, and variables.  For example, a module could inherit the class
<CODE>CONS</CODE> from the <CODE>STELLA</CODE> module, but shadow the function of the same name.
</P><P>

The above discussion of <CODE>:includes</CODE> and <CODE>:uses</CODE> semantics keyed on the
inheritance/visibility of symbols. The PowerLoom system makes another
very important distinction: If a module <CODE>A</CODE> is inherited directly or
indirectly via <CODE>:includes</CODE> specification(s) by a submodule <CODE>B</CODE>, then all
definitions and facts asserted in <CODE>A</CODE> are visible in <CODE>B</CODE>. This is not the
cases for <CODE>:uses</CODE>; the <CODE>:uses</CODE> options does not impact inheritance of
propositions at all.
</P><P>

The list of modules specified in the
<CODE>:includes</CODE> option plus (if supplied) the parent in the path used for
<VAR>name</VAR> become the new module's parents. If no <CODE>:uses</CODE> option was
supplied, the new module will use the <CODE>STELLA</CODE> module by default,
otherwise, it will use the set of specified modules.
If <CODE>:case-sensitive?</CODE> is supplied as TRUE, symbols in the module will be
interned case-sensitively, otherwise (the default), they will be
converted to uppercase before they get interned. Modules can shadow
definitions of functions and classes inherited from parents or used
modules. Shadowing is done automatically, but generates a warning unless
the shadowed type or function name is listed in the <CODE>:shadow</CODE> option of
the module definition .
</P><P>

Examples:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  (defmodule "PL-KERNEL/PL-USER"
    :uses ("LOGIC" "STELLA")
    :package "PL-USER")

  (defmodule PL-USER/GENEALOGY)
</pre></td></tr></table></P><P>

The remaining options are relevant only for modules that contain STELLA
code.  Modules used only to contain knowledge base definitions and assertions
have no use for them:
</P><P>

The keywords <CODE>:lisp-package</CODE>, <CODE>:java-package</CODE>, and <CODE>:cpp-package</CODE> specify
the name of a native package or name space in which symbols of the module
should be allocated when they get translated into one of Lisp, Java, or
C++. By default, Lisp symbols are allocated in the <CODE>STELLA</CODE> package, and
C++ names are translated without any prefixes. The rules that the STELLA
translator uses to attach translated Java objects to classes and packages
are somewhat complex. Use :java-package option to specify a list of
package names (separated by periods) that prefix the Java object in this
module.  Use :java-catchall-class to specify the name of the Java class to
contain all global &#38; special variables, parameter-less functions and functions 
defined on arguments that are not classes in the current module.
The default value will be the name of the module.
</P><P>

When set to TRUE, the :api? option tells the PowerLoom User Manual
generator that all functions defined in this module should be included in
the API section. Additionally, the Java translator makes all API
functions <CODE>synchronized</CODE>.
</P><P>

</DL>
</P><P>

<A NAME="IDX507"></A>
<DL>
<DT><U>Function:</U> <B>get-stella-module</B> <I>((pathName STRING) (error? BOOLEAN)) : MODULE</I>
<DD>Return the module located at <VAR>pathName</VAR>, or <CODE>null</CODE>
if no such module exists.  The search looks at ancestors and top-most
 (cardinal) modules.  If <VAR>error?</VAR> is <CODE>true</CODE>, throw an exception if no
 module is found.
</DL>
</P><P>

<A NAME="IDX508"></A>
<DL>
<DT><U>Function:</U> <B>find-or-create-module</B> <I>((pathname STRING)) : MODULE</I>
<DD>Return a module located at <VAR>pathname</VAR> if one exists,
  otherwise create one
</DL>
</P><P>

<A NAME="IDX509"></A>
<DL>
<DT><U>N-Command:</U> <B>clear-module</B> <I>(&#38;rest (name NAME)) :</I>
<DD>Destroy all objects belonging to module <VAR>name</VAR> or any of its children.
If no <VAR>name</VAR> is supplied, the current module will be cleared after
confirming with the user.  Important modules such as STELLA are protected
against accidental clearing.
</DL>
</P><P>

<A NAME="IDX510"></A>
<DL>
<DT><U>Function:</U> <B>destroy-module</B> <I>((self MODULE)) :</I>
<DD>Destroy the module <VAR>self</VAR>, and recursively destroy
all contexts that inherit <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX511"></A>
<DL>
<DT><U>Method:</U> MODULE <B>destroy-context</B> <I>(self) :</I>
<DD>Destroy the context <VAR>self</VAR>, and recursively destroy
all contexts that inherit <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX512"></A>
<DL>
<DT><U>Function:</U> <B>visible-modules</B> <I>((from MODULE)) : (CONS OF MODULE)</I>
<DD>Return a list of all modules visible from module <VAR>from</VAR> (or <CODE>*module*</CODE>
if <VAR>from</VAR> is NULL.  The generated modules are generated from most to
least-specific and will start with the module <VAR>from</VAR>.
</DL>
</P><P>

<A NAME="IDX513"></A>
<DL>
<DT><U>Macro:</U> <B>within-module</B> <I>((moduleForm OBJECT) &#38;body (body CONS)) : OBJECT</I>
<DD>Execute <VAR>body</VAR> within the module resulting from <VAR>moduleForm</VAR>.
<CODE>*module*</CODE> is an acceptable <VAR>moduleForm</VAR>.  It will locally rebind 
<CODE>*module*</CODE> and <CODE>*context*</CODE> and shield the outer bindings from changes.
</DL>
</P><P>

<A NAME="IDX514"></A>
<DL>
<DT><U>N-Command:</U> <B>in-module</B> <I>((name NAME)) : MODULE</I>
<DD>Change the current module to the module named <VAR>name</VAR>.
</DL>
</P><P>

<A NAME="IDX515"></A>
<DL>
<DT><U>Method:</U> MODULE <B>change-module</B> <I>(module) : MODULE</I>
<DD>Change the current module to be the module
<VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX516"></A>
<DL>
<DT><U>Method:</U> STRING <B>change-module</B> <I>(moduleName) : MODULE</I>
<DD>Change the current module to be the module named
<VAR>moduleName</VAR>.
</DL>
</P><P>

<A NAME="IDX517"></A>
<DL>
<DT><U>Function:</U> <B>create-world</B> <I>((parentContext CONTEXT) (name STRING)) : WORLD</I>
<DD>Create a new world below the world or module <VAR>parentContext</VAR>.
Optionally, specify a name.
</DL>
</P><P>

<A NAME="IDX518"></A>
<DL>
<DT><U>Function:</U> <B>push-world</B> <I>() : WORLD</I>
<DD>Spawn a new world that is a child of the current context,
and change the current context to the new world.
</DL>
</P><P>

<A NAME="IDX519"></A>
<DL>
<DT><U>Function:</U> <B>pop-world</B> <I>() : CONTEXT</I>
<DD>Destroy the current world and change the current
context to be its parent.  Return the current context. Nothing happens
if there is no current world.
</DL>
</P><P>

<A NAME="IDX520"></A>
<DL>
<DT><U>Method:</U> WORLD <B>destroy-context</B> <I>(self) :</I>
<DD>Destroy the context <VAR>self</VAR>, and recursively destroy
all contexts that inherit <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX521"></A>
<DL>
<DT><U>Macro:</U> <B>within-world</B> <I>((worldForm OBJECT) &#38;body (body CONS)) : OBJECT</I>
<DD>Execute <VAR>body</VAR> within the world resulting from <VAR>worldForm</VAR>.
</DL>
</P><P>

<A NAME="Input and Output"></A>
<HR SIZE="6">
<A NAME="SEC47"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC46"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC48"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.15 Input and Output </H2>
<!--docid::SEC47::-->
<P>

<A NAME="IDX522"></A>
<DL>
<DT><U>Function:</U> <B>read-s-expression</B> <I>((stream INPUT-STREAM)) : OBJECT BOOLEAN</I>
<DD>Read one STELLA s-expression from <VAR>stream</VAR> and return
the result.  Return <CODE>true</CODE> as the second value on EOF.
</DL>
</P><P>

<A NAME="IDX523"></A>
<DL>
<DT><U>Function:</U> <B>read-s-expression-from-string</B> <I>((string STRING)) : OBJECT</I>
<DD>Read one STELLA s-expression from <VAR>string</VAR> and
return the result.
</DL>
</P><P>

<A NAME="IDX524"></A>
<DL>
<DT><U>Function:</U> <B>read-line</B> <I>((stream INPUT-STREAM)) : STRING</I>
<DD>Read one line from <VAR>stream</VAR> and return the result.
This differs from <CODE>native-read-line</CODE> in that it is not platform-dependent.
It recognizes any of the three common line ending formats: CR, LF, CR-LF
in any combination.  It is not as fast as <CODE>native-read-line</CODE>, however.
</DL>
</P><P>

<A NAME="IDX525"></A>
<DL>
<DT><U>Function:</U> <B>read-character</B> <I>((inputStream INPUT-STREAM)) : CHARACTER BOOLEAN</I>
<DD>Read one character from <VAR>inputStream</VAR> and return the result.
Return <CODE>true</CODE> as the second value on EOF.
</DL>
</P><P>

<A NAME="IDX526"></A>
<DL>
<DT><U>Function:</U> <B>unread-character</B> <I>((ch CHARACTER) (inputStream INPUT-STREAM)) :</I>
<DD>Unread <VAR>ch</VAR> from <VAR>inputStream</VAR>.  Signal an error if <VAR>ch</VAR>
was not the last character read.
</DL>
</P><P>

<A NAME="IDX527"></A>
<DL>
<DT><U>Function:</U> <B>y-or-n?</B> <I>((message STRING)) : BOOLEAN</I>
<DD>Read a line of input from STANDARD-INPUT and return <CODE>true</CODE>
if the input was <CODE>y</CODE> or <CODE>false</CODE> if the input was <CODE>n</CODE>.  Loop until either
<CODE>y</CODE> or <CODE>n</CODE> was entered.  If <VAR>message</VAR> is non-`null' prompt with it before
the input is read.  See also special variable <CODE>*USER-QUERY-ACTION*</CODE>.
</DL>
</P><P>

<A NAME="IDX528"></A>
<DL>
<DT><U>Function:</U> <B>yes-or-no?</B> <I>((message STRING)) : BOOLEAN</I>
<DD>Read a line of input from STANDARD-INPUT and return <CODE>true</CODE>
if the input was <CODE>yes</CODE> or <CODE>false</CODE> if the input was <CODE>no</CODE>.  Loop until either
<CODE>yes</CODE> or <CODE>no</CODE> was entered.  If <VAR>message</VAR> is non-`null' prompt with it before
the input is read.  See also special variable <CODE>*USER-QUERY-ACTION*</CODE>.
</DL>
</P><P>

<A NAME="IDX529"></A>
<DL>
<DT><U>Function:</U> <B>flush-output</B> <I>((self OUTPUT-STREAM)) :</I>
<DD>Flush all buffered output of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="Files"></A>
<HR SIZE="6">
<A NAME="SEC48"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC47"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC49"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.16 Files </H2>
<!--docid::SEC48::-->
<P>

<A NAME="IDX530"></A>
<DL>
<DT><U>Function:</U> <B>open-input-file</B> <I>((fileName STRING) &#38;rest (options KEYWORD)) : FILE-INPUT-STREAM</I>
<DD>Open file <VAR>fileName</VAR> for input and return the resulting input stream.
By default signal an error if the file does not exist.  The only legal
option so far is <CODE>:IF-NOT-EXISTS</CODE> (or <CODE>:IF-NOT-EXISTS-ACTION</CODE>) which
specifies what to do in case the file does not exist.  If its value is
<CODE>:ERROR</CODE> then an error will be signaled.  If it is <CODE>:ABORT</CODE> or <CODE>:PROBE</CODE>
the opening operation will be aborted and NULL will be returned.
</DL>
</P><P>

<A NAME="IDX531"></A>
<DL>
<DT><U>Function:</U> <B>open-output-file</B> <I>((fileName STRING) &#38;rest (options KEYWORD)) : FILE-OUTPUT-STREAM</I>
<DD>Open file <VAR>fileName</VAR> for output and return the resulting output stream.
By default the file will be created or overwritten if it already exists.
If <CODE>:IF-EXISTS</CODE> (or <CODE>:IF-EXISTS-ACTION</CODE>) is one of the <VAR>options</VAR> its value
specifies what to do in case the file already exists.  If the value is
<CODE>:SUPERSEDE</CODE> the pre-existing file will be overwritten.  If the value is
<CODE>:APPEND</CODE> the preexisting file will be appended to (if the file did not
yet exist the file will simply be created).  If the value is <CODE>:ERROR</CODE> then
an error will be signaled.  If it is <CODE>:ABORT</CODE> or <CODE>:PROBE</CODE> the opening operation
will be aborted and NULL will be returned.
</P><P>

If <CODE>:IF-NOT-EXISTS</CODE> (or <CODE>:IF-NOT-EXISTS-ACTION</CODE>) is one of the <VAR>options</VAR> its
value specifies what to do in case the file does not already exist.  If the
value is <CODE>:CREATE</CODE>, the file will simply be created.  If the value is
<CODE>:ERROR</CODE> then an error will be signaled.  If it is <CODE>:ABORT</CODE> or <CODE>:PROBE</CODE> the
opening operation will be aborted and NULL will be returned.
</DL>
</P><P>

<A NAME="IDX532"></A>
<DL>
<DT><U>Function:</U> <B>close-stream</B> <I>((self STREAM)) :</I>
<DD>Close the stream <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX533"></A>
<DL>
<DT><U>Function:</U> <B>close-all-files</B> <I>() :</I>
<DD>Close all currently open file streams.  Use for emergencies or for cleanup.
</DL>
</P><P>

<A NAME="IDX534"></A>
<DL>
<DT><U>Macro:</U> <B>with-input-file</B> <I>((binding CONS) &#38;body (body CONS)) : OBJECT</I>
<DD>Sets up an unwind-protected form which opens a file for
input and closes it afterwards.  The stream for reading is bound to the
variable provided in the macro form.
Syntax is <CODE>(WITH-INPUT-FILE (var filename options*) body+)</CODE> where <CODE>options</CODE>
can be any that are legal for <CODE>open-input-file</CODE> (which see).
</DL>
</P><P>

<A NAME="IDX535"></A>
<DL>
<DT><U>Macro:</U> <B>with-output-file</B> <I>((binding CONS) &#38;body (body CONS)) : OBJECT</I>
<DD>Sets up an unwind-protected form which opens a file for
output and closes it afterwards.  The stream for writing is bound to the
variable provided in the macro form.
Syntax is <CODE>(WITH-OUTPUT-FILE (var filename options*) body+)</CODE> where <CODE>options</CODE>
can be any that are legal for <CODE>open-output-file</CODE> (which see).
</DL>
</P><P>

<A NAME="IDX536"></A>
<DL>
<DT><U>Function:</U> <B>probe-file?</B> <I>((fileName FILE-NAME)) : BOOLEAN</I>
<DD>Return true if file <VAR>fileName</VAR> exists.  Note that this does
not necessarily mean that the file can also be read.
</DL>
</P><P>

<A NAME="IDX537"></A>
<DL>
<DT><U>Function:</U> <B>file-write-date</B> <I>((fileName FILE-NAME)) : CALENDAR-DATE</I>
<DD>Return the time at which file <VAR>fileName</VAR> was last modified or
NULL if that cannot be determined.
</DL>
</P><P>

<A NAME="IDX538"></A>
<DL>
<DT><U>Function:</U> <B>file-length</B> <I>((fileName FILE-NAME)) : INTEGER</I>
<DD>Return the length of file <VAR>fileName</VAR> in bytes or NULL if that
cannot be determined.  Note that this will currently overrun for files that
are longer than what can be represented by a STELLA integer.
</DL>
</P><P>

<A NAME="IDX539"></A>
<DL>
<DT><U>Function:</U> <B>copy-file</B> <I>((fromFile FILE-NAME) (toFile FILE-NAME)) :</I>
<DD>Copy file <VAR>fromFile</VAR> to file <VAR>toFile</VAR>, clobbering
any data already in <VAR>toFile</VAR>.
</DL>
</P><P>

<A NAME="IDX540"></A>
<DL>
<DT><U>Function:</U> <B>delete-file</B> <I>((fileName FILE-NAME)) :</I>
<DD>Delete the file <VAR>fileName</VAR>.
</DL>
</P><P>

<A NAME="IDX541"></A>
<DL>
<DT><U>Function:</U> <B>directory-file-name</B> <I>((directory FILE-NAME)) : FILE-NAME</I>
<DD>Return <VAR>directory</VAR> as a file name, i.e., without a terminating
directory separator.
</DL>
</P><P>

<A NAME="IDX542"></A>
<DL>
<DT><U>Function:</U> <B>directory-parent-directory</B> <I>((directory FILE-NAME) (level INTEGER)) : FILE-NAME</I>
<DD>Return the <VAR>level</VAR>-th parent directory component of <VAR>directory</VAR>
including the final directory separator, or the empty string if <VAR>directory</VAR> does
not have that many parents.
</DL>
</P><P>

<A NAME="IDX543"></A>
<DL>
<DT><U>Function:</U> <B>file-name-as-directory</B> <I>((file FILE-NAME)) : FILE-NAME</I>
<DD>Return <VAR>file</VAR> interpreted as a directory, i.e., with a
terminating directory separator.  If <VAR>file</VAR> is the empty string simply
return the empty string, i.e., interpret it as the current directory instead
of the root directory.
</DL>
</P><P>

<A NAME="IDX544"></A>
<DL>
<DT><U>Function:</U> <B>file-name-directory</B> <I>((file FILE-NAME)) : FILE-NAME</I>
<DD>Return the directory component of <VAR>file</VAR> including the final
directory separator or the empty string if <VAR>file</VAR> does not include a directory.
Note that for purposes of this function, a logical host is considered part of
the directory portion of <VAR>file</VAR>
</DL>
</P><P>

<A NAME="IDX545"></A>
<DL>
<DT><U>Function:</U> <B>file-name-without-directory</B> <I>((file FILE-NAME)) : FILE-NAME</I>
<DD>Return the file name portion of <VAR>file</VAR> by removing any
directory and logical host components.
</DL>
</P><P>

<A NAME="IDX546"></A>
<DL>
<DT><U>Function:</U> <B>file-name-without-extension</B> <I>((file FILE-NAME)) : FILE-NAME</I>
<DD>Remove <VAR>file</VAR>s extension (or type) if there is any and
return the result.
</DL>
</P><P>

<A NAME="IDX547"></A>
<DL>
<DT><U>Function:</U> <B>file-extension</B> <I>((file FILE-NAME)) : STRING</I>
<DD>Return <VAR>file</VAR>s extension (or type) if it has any including
the separator character.
</DL>
</P><P>

<A NAME="IDX548"></A>
<DL>
<DT><U>Function:</U> <B>file-base-name</B> <I>((file FILE-NAME)) : FILE-NAME</I>
<DD>Remove <VAR>file</VAR>s directory (including logical host) and
extension components and return the result.
</DL>
</P><P>

<A NAME="IDX549"></A>
<DL>
<DT><U>Function:</U> <B>absolute-pathname?</B> <I>((pathname STRING)) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX550"></A>
<DL>
<DT><U>Function:</U> <B>logical-host?</B> <I>((host STRING)) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX551"></A>
<DL>
<DT><U>Function:</U> <B>logical-pathname?</B> <I>((pathname STRING)) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX552"></A>
<DL>
<DT><U>Function:</U> <B>translate-logical-pathname</B> <I>((pathname STRING)) : STRING</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX553"></A>
<DL>
<DT><U>Function:</U> <B>directory-separator</B> <I>() : CHARACTER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX554"></A>
<DL>
<DT><U>Function:</U> <B>directory-separator-string</B> <I>() : STRING</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="Dates and Times"></A>
<HR SIZE="6">
<A NAME="SEC49"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC48"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC50"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.17 Dates and Times </H2>
<!--docid::SEC49::-->
<P>

<A NAME="IDX555"></A>
<DL>
<DT><U>Function:</U> <B>get-current-date-time</B> <I>() : INTEGER INTEGER INTEGER KEYWORD INTEGER INTEGER INTEGER INTEGER</I>
<DD>Returns the current time in UTC as multiple values of
year month day day-of-week hour minute second millisecond.  Currently
millisecond will always be zero (even in Java where it is technically available).
</DL>
</P><P>

<A NAME="IDX556"></A>
<DL>
<DT><U>Function:</U> <B>get-local-time-zone</B> <I>() : FLOAT</I>
<DD>Returns the current time zone offset from UTC as a float,
considering the effects of daylight savings time.
</DL>
</P><P>

<A NAME="IDX557"></A>
<DL>
<DT><U>Function:</U> <B>make-current-date-time</B> <I>() : CALENDAR-DATE</I>
<DD>Create a calendar date with current time and date.
</DL>
</P><P>

<A NAME="IDX558"></A>
<DL>
<DT><U>Function:</U> <B>make-date-time</B> <I>((year INTEGER) (month INTEGER) (day INTEGER) (hour INTEGER) (minute INTEGER) (second INTEGER) (millis INTEGER) (timezone FLOAT)) : CALENDAR-DATE</I>
<DD>Create a calendar date with the specified components.  <VAR>year</VAR> must be
the complete year (i.e., a year of 98 is 98 A.D in the 1st century).
<VAR>timezone</VAR> is a real number in the range -12.0 to +14.0 where UTC is zone 0.0;  The number
is the number of hours to add to UTC to arrive at local time.
</DL>
</P><P>

<A NAME="IDX559"></A>
<DL>
<DT><U>Function:</U> <B>parse-date-time</B> <I>((date-time-string STRING) (start INTEGER) (end INTEGER) (error-on-mismatch? BOOLEAN)) : DECODED-DATE-TIME</I>
<DD>Tries very hard to make sense out of the argument <VAR>date-time-string</VAR> and
returns a time structure if successful.  If not, it returns <CODE>null</CODE>.
If <VAR>error-on-mismatch?</VAR> is true, parse-date-time will signal an error instead of
returning <CODE>null</CODE>.  
Default values are 00:00:00 local time on the current date
</DL>
</P><P>

<A NAME="IDX560"></A>
<DL>
<DT><U>Method:</U> CALENDAR-DATE <B>decode-calendar-date</B> <I>(date (timezone FLOAT)) : DECODED-DATE-TIME</I>
<DD>Returns a decoded time object for <VAR>date</VAR> interpreted in <VAR>timezone</VAR>
<VAR>timezone</VAR> is the number of hours added to UTC to get local time.  It is 
in the range -12.0 to +14.0 where UTC is zone 0.0
</DL>
</P><P>

<A NAME="IDX561"></A>
<DL>
<DT><U>Method:</U> DECODED-DATE-TIME <B>encode-calendar-date</B> <I>(time-structure) : CALENDAR-DATE</I>
<DD>Returns a calendar date object for <VAR>time-structure</VAR>.
</DL>
</P><P>

<A NAME="IDX562"></A>
<DL>
<DT><U>???:</U> <B>calendar-date-to-string</B>
<DD>Not yet implemented.
</DL>
</P><P>

<A NAME="IDX563"></A>
<DL>
<DT><U>Function:</U> <B>string-to-calendar-date</B> <I>((input STRING)) : CALENDAR-DATE</I>
<DD>Returns a calendar date object representing the date and time
parsed from the <VAR>input</VAR> string.  If no valid parse is found,
<CODE>null</CODE> is returned.
</DL>
</P><P>

<A NAME="IDX564"></A>
<DL>
<DT><U>???:</U> <B>relative-date-to-string</B>
<DD>Not yet implemented.
</DL>
</P><P>

<A NAME="IDX565"></A>
<DL>
<DT><U>Function:</U> <B>compute-calendar-date</B> <I>((julian-day INTEGER)) : INTEGER INTEGER INTEGER KEYWORD</I>
<DD>Returns the YEAR, MONTH, DAY, DAY-OF-WEEK on which the given
<VAR>julian-day</VAR> begins at noon.
</DL>
</P><P>

<A NAME="IDX566"></A>
<DL>
<DT><U>Function:</U> <B>compute-day-of-week</B> <I>((yyyy INTEGER) (mm INTEGER) (dd INTEGER)) : KEYWORD</I>
<DD>Returns the day of the week for yyyy-mm-dd.
</DL>
</P><P>

<A NAME="IDX567"></A>
<DL>
<DT><U>Function:</U> <B>compute-day-of-week-julian</B> <I>((julian-day INTEGER)) : KEYWORD</I>
<DD>Returns the day of the week for julian-day
</DL>
</P><P>

<A NAME="IDX568"></A>
<DL>
<DT><U>Function:</U> <B>compute-julian-day</B> <I>((yyyy INTEGER) (mm INTEGER) (dd INTEGER)) : INTEGER</I>
<DD>Returns the Julian day that starts at noon on yyyy-mm-dd.
<VAR>yyyy</VAR> is the year.  <VAR>mm</VAR> is the month.  <VAR>dd</VAR> is the day of month.
Negative years are B.C.  Remember there is no year zero.
</DL>
</P><P>

<A NAME="IDX569"></A>
<DL>
<DT><U>Function:</U> <B>compute-next-moon-phase</B> <I>((n INTEGER) (phase KEYWORD)) : INTEGER FLOAT</I>
<DD>Returns the Julian Day and fraction of day of the Nth occurence
since January 1, 1900 of moon PHASE.  PHASE is one of :NEW-MOON, :FIRST-QUARTER,
:FULL-MOON, :LAST-QUARTER
</DL>
</P><P>

<A NAME="IDX570"></A>
<DL>
<DT><U>Function:</U> <B>decode-time-in-millis</B> <I>((time INTEGER)) : INTEGER INTEGER INTEGER INTEGER</I>
<DD>Returns multiple values of hours, minutes, seconds, milliseconds for
<VAR>time</VAR> specified in milliseconds.
</DL>
</P><P>

<A NAME="IDX571"></A>
<DL>
<DT><U>Function:</U> <B>julian-day-to-modified-julian-day</B> <I>((julian-day INTEGER)) : INTEGER</I>
<DD>Returns the modified Julian day during which <VAR>julian-day</VAR>starts at noon.
</DL>
</P><P>

<A NAME="IDX572"></A>
<DL>
<DT><U>Function:</U> <B>modified-julian-day-to-julian-day</B> <I>((modified-julian-day INTEGER)) : INTEGER</I>
<DD>Returns the modified Julian day during which <CODE>julian-day</CODE>starts at noon.
</DL>
</P><P>

<A NAME="IDX573"></A>
<DL>
<DT><U>Function:</U> <B>time-add</B> <I>((t1 DATE-TIME-OBJECT) (t2 DATE-TIME-OBJECT)) : DATE-TIME-OBJECT</I>
<DD>Add <VAR>t1</VAR> to <VAR>t2</VAR>.
If one of <VAR>t1</VAR> or <VAR>t2</VAR> is a calendar date, then the result is a calendar date.
If both <VAR>t1</VAR> and <VAR>t2</VAR> are relative dates, then the result is a relative date.
<VAR>t1</VAR> and <VAR>t2</VAR> cannot both be calendar dates.
</DL>
</P><P>

<A NAME="IDX574"></A>
<DL>
<DT><U>Function:</U> <B>time-divide</B> <I>((t1 TIME-DURATION) (t2 OBJECT)) : OBJECT</I>
<DD>Divides the relative date <VAR>t1</VAR> by <VAR>t2</VAR>.  <VAR>t2</VAR> must be
either a relative date or a wrapped number.  If <VAR>t2</VAR> is a relative date,
then the return value will be a wrapped float.  If <VAR>t2</VAR> is a wrapped number,
then the reutrn value will be a relative date.
</DL>
</P><P>

<A NAME="IDX575"></A>
<DL>
<DT><U>Function:</U> <B>time-multiply</B> <I>((t1 OBJECT) (t2 OBJECT)) : TIME-DURATION</I>
<DD>Multiplies a relative date by a wrapped number.  One of <VAR>t1</VAR> or <VAR>t2</VAR>
must be a relative date and the other a wrapped number.
</DL>
</P><P>

<A NAME="IDX576"></A>
<DL>
<DT><U>Function:</U> <B>time-subtract</B> <I>((t1 DATE-TIME-OBJECT) (t2 DATE-TIME-OBJECT)) : DATE-TIME-OBJECT</I>
<DD>Subtract <VAR>t2</VAR> from <VAR>t1</VAR>.  If <VAR>t1</VAR> is a calendar date, then <VAR>t2</VAR> can
be either a calendar date (in which case the return value is a relative date) or it
can be a relative date (in which case the return value is a calendar date).  If <VAR>t1</VAR>
is a relative date, then <VAR>t2</VAR> must also be a relative date and a relative date is returned.
</DL>
</P><P>

<A NAME="IDX577"></A>
<DL>
<DT><U>Function:</U> <B>get-ticktock</B> <I>() : TICKTOCK</I>
<DD>Return the current CPU time.  If the current OS/Language
combination does not support measuring of CPU time, return real time instead.
Use <CODE>ticktock-difference</CODE> to measure the time difference between values
returned by this function.  This is an attempt to provide some platform
independent support to measure (at least approximately) consumed CPU time.
</DL>
</P><P>

<A NAME="IDX578"></A>
<DL>
<DT><U>Function:</U> <B>ticktock-difference</B> <I>((t1 TICKTOCK) (t2 TICKTOCK)) : FLOAT</I>
<DD>The difference in two TICKTOCK time values in seconds where
<VAR>t1</VAR> is the earlier time.  The resolution is implementation dependent but will
normally be some fractional value of a second.
</DL>
</P><P>

<A NAME="IDX579"></A>
<DL>
<DT><U>Function:</U> <B>ticktock-resolution</B> <I>() : FLOAT</I>
<DD>The minimum theoretically detectable resolution of the
difference in two TICKTOCK time values in seconds.  This
resolution is implementation dependent.  It may also not
be realizable in practice, since the timing grain size may
be larger than this resolution.
</DL>
</P><P>

<A NAME="IDX580"></A>
<DL>
<DT><U>Function:</U> <B>sleep</B> <I>((seconds FLOAT)) :</I>
<DD>The program will sleep for the indicated number of seconds.
Fractional values are allowed, but the results are implementation dependent:
Common Lisp uses the fractions natively, Java with a resolution of 0.001,
and C++ can only use integral values.
</DL>
</P><P>

<A NAME="XML Support"></A>
<HR SIZE="6">
<A NAME="SEC50"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC49"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC51"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.18 XML Support </H2>
<!--docid::SEC50::-->
<P>

<A NAME="IDX581"></A>
<DL>
<DT><U>Function:</U> <B>make-xml-element</B> <I>((name STRING) (namespace-name STRING) (namespace STRING)) : XML-ELEMENT</I>
<DD>Creates and interns an XML element object <VAR>name</VAR> using <VAR>namespace-name</VAR>
to refer to  <VAR>namespace</VAR>.  If <VAR>namespace</VAR> is <CODE>null</CODE>, then the element will
be interned in the null namespace.   <VAR>namespace</VAR> must otherwise be a URI.
</DL>
</P><P>

<A NAME="IDX582"></A>
<DL>
<DT><U>Function:</U> <B>make-xml-global-attribute</B> <I>((name STRING) (namespace-name STRING) (namespace STRING)) : XML-GLOBAL-ATTRIBUTE</I>
<DD>Creates and interns an XML global attribute object with <VAR>name</VAR> using 
<VAR>namespace-name</VAR> to refer to  <VAR>namespace</VAR>.  <VAR>namespace</VAR>must be a URI.
</DL>
</P><P>

<A NAME="IDX583"></A>
<DL>
<DT><U>Function:</U> <B>make-xml-local-attribute</B> <I>((name STRING) (element XML-ELEMENT)) : XML-LOCAL-ATTRIBUTE</I>
<DD>Make an XML-LOCAL-ATTRIBUTE named <VAR>name</VAR> associated with <VAR>element</VAR>
</DL>
</P><P>

<A NAME="IDX584"></A>
<DL>
<DT><U>Function:</U> <B>get-xml-tag</B> <I>((expression CONS)) : XML-ELEMENT</I>
<DD>Return the XML tag object of an XML <VAR>expression</VAR>.
</DL>
</P><P>

<A NAME="IDX585"></A>
<DL>
<DT><U>Function:</U> <B>get-xml-attributes</B> <I>((expression CONS)) : CONS</I>
<DD>Return the list of attributes of an XML <VAR>expression</VAR> (may be empty).
</DL>
</P><P>

<A NAME="IDX586"></A>
<DL>
<DT><U>Function:</U> <B>get-xml-content</B> <I>((expression CONS)) : CONS</I>
<DD>Return the list of content elements of an XML <VAR>expression</VAR> (may be empty).
</DL>
</P><P>

<A NAME="IDX587"></A>
<DL>
<DT><U>Function:</U> <B>get-xml-cdata-content</B> <I>((form CONS)) : STRING</I>
<DD>Return the CDATA content of a CDATA <VAR>form</VAR>.  Does NOT make sure that <VAR>form</VAR>
actually is a CDATA form, so bad things can happen if it is given wrong input.
</DL>
</P><P>

<A NAME="IDX588"></A>
<DL>
<DT><U>Function:</U> <B>xml-declaration?</B> <I>((item OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>item</VAR> is an XML declaration object
</DL>
</P><P>

<A NAME="IDX589"></A>
<DL>
<DT><U>Function:</U> <B>xml-element?</B> <I>((item OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>item</VAR> is an XML element object
</DL>
</P><P>

<A NAME="IDX590"></A>
<DL>
<DT><U>Function:</U> <B>xml-attribute?</B> <I>((item OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>item</VAR> is an XML attribute object
</DL>
</P><P>

<A NAME="IDX591"></A>
<DL>
<DT><U>Function:</U> <B>xml-cdata?</B> <I>((item OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>item</VAR> is an XML CDATA tag object
</DL>
</P><P>

<A NAME="IDX592"></A>
<DL>
<DT><U>Function:</U> <B>xml-cdata-form?</B> <I>((form OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>form</VAR> is a CONS headed by a CDATA tag
</DL>
</P><P>

<A NAME="IDX593"></A>
<DL>
<DT><U>Method:</U> XML-ELEMENT <B>xml-element-match?</B> <I>(tag (name STRING) (namespace STRING)) : BOOLEAN</I>
<DD>Returns <CODE>true</CODE> if <VAR>tag</VAR> is an XML element with the name <VAR>name</VAR>
in namespace <VAR>namespace</VAR>.  Note that <VAR>namespace</VAR> is the full URI, not an abbreviation.
Also, <VAR>namespace</VAR> may be <CODE>null</CODE>, in which case <VAR>tag</VAR> must not have a namespace
associated with it.
</DL>
</P><P>

<A NAME="IDX594"></A>
<DL>
<DT><U>Method:</U> XML-ATTRIBUTE <B>xml-attribute-match?</B> <I>(attribute (name STRING) (namespace STRING)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>attribute</VAR> is an XML attribute with name <VAR>name</VAR>
in namespace <VAR>namespace</VAR>.  Note that <VAR>namespace</VAR> is the full URI, not an
abbreviation.  Also, <VAR>namespace</VAR> may be <CODE>null</CODE>, in which case <VAR>attribute</VAR>
must not have a namespace associated with it.
</DL>
</P><P>

<A NAME="IDX595"></A>
<DL>
<DT><U>Method:</U> XML-GLOBAL-ATTRIBUTE <B>xml-attribute-match?</B> <I>(attribute (name STRING) (namespace STRING)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>attribute</VAR> is a global  XML attribute with name <VAR>name</VAR>
in namespace <VAR>namespace</VAR>.  Note that <VAR>namespace</VAR> is the full URI, not an
abbreviation.  Also, <VAR>namespace</VAR> may be <CODE>null</CODE>, in which case <VAR>attribute</VAR>
must not have a namespace associated with it.
</DL>
</P><P>

<A NAME="IDX596"></A>
<DL>
<DT><U>Method:</U> XML-LOCAL-ATTRIBUTE <B>xml-attribute-match?</B> <I>(attribute (name STRING) (namespace STRING)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>attribute</VAR> is a local XML attribute with name <VAR>name</VAR>.
Note that <VAR>namespace</VAR> must be <CODE>null</CODE> and that the <VAR>attribute</VAR>s parent element
element is not considered by the match.  To take the parent element into
account use <CODE>xml-local-attribute-match?</CODE>.
</DL>
</P><P>

<A NAME="IDX597"></A>
<DL>
<DT><U>Function:</U> <B>xml-local-attribute-match?</B> <I>((attribute XML-LOCAL-ATTRIBUTE) (name STRING) (element-name STRING) (element-namespace STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>attribute</VAR> is a local attribute with <VAR>name</VAR> and whose
parent element matches <VAR>element-name</VAR> and <VAR>element-namespace</VAR>.
</DL>
</P><P>

<A NAME="IDX598"></A>
<DL>
<DT><U>Function:</U> <B>xml-lookup-attribute</B> <I>((attributes CONS) (name STRING) (namespace STRING)) : STRING</I>
<DD>Find the XML attribute in <VAR>attributes</VAR> with <VAR>name</VAR> and <VAR>namespace</VAR> and
return its value.  Note that it is assumed that all <VAR>attributes</VAR> come from
the same known tag, hence, the parent elements of any local attributes are
not considered by the lookup.
</DL>
</P><P>

<A NAME="IDX599"></A>
<DL>
<DT><U>Macro:</U> <B>xml-tag-case</B> <I>((item OBJECT) &#38;body (clauses CONS)) : OBJECT</I>
<DD>A case form for matching <VAR>item</VAR> against XML element tags.  Each
element of <VAR>clauses</VAR> should be a clause with the form
  ("tagname" ...)     or
  (("tagname" "namespace-uri") ...)
The clause heads can optionally be symbols instead of strings.  The key forms the
parameters to the method <CODE>xml-element-match?</CODE>, with a missing namespace argument
passed as NULL.
</P><P>

The namespace argument will be evaluated, so one can use bound variables in
place of a fixed string.   As a special case, if the namespace argument is
:ANY, then the test will be done for a match on the tag name alone.
</DL>
</P><P>

<A NAME="IDX600"></A>
<DL>
<DT><U>Function:</U> <B>read-xml-expression</B> <I>((stream INPUT-STREAM) (start-tag OBJECT)) : OBJECT BOOLEAN</I>
<DD>Read one balanced XML expression from <VAR>stream</VAR> and return
its s-expression representation (see <CODE>xml-token-list-to-s-expression</CODE>).  If
<CODE>startTagName</CODE> is non-`null', skip all tags until a start tag matching <VAR>start-tag</VAR>
is encountered.  XML namespaces are ignored for outside of the start tag.
Use s-expression representation to specify <VAR>start-tag</VAR>, e.g., <CODE>(KIF (:version "1.0"))</CODE>.
The tag can be an XML element object, a symbol, a string or a cons.  If the tag is a cons
the first element can also be (name namespace) pair.
</P><P>

Return <CODE>true</CODE> as the second value on EOF.
</P><P>

CHANGE WARNING:  It is anticipated that this function will change to
 a) Properly take XML namespaces into account and
 b) require XML element objects instead of strings as the second argument.
This change will not be backwards-compatible.
</DL>
</P><P>

<A NAME="IDX601"></A>
<DL>
<DT><U>Function:</U> <B>xml-expressions</B> <I>((stream INPUT-STREAM) (regionTag OBJECT)) : XML-EXPRESSION-ITERATOR</I>
<DD>Return an XML-expression-iterator (which see) reading from
<VAR>stream</VAR>.  <VAR>regionTag</VAR> can be used to define delimited regions from which
expressions should be considered. Use s-expression representation to specify
<VAR>regionTag</VAR>, e.g., <CODE>(KIF (:version "1.0"))</CODE>.  The tag can be an XML element
object, a symbol, a string or a cons.  If the tag is a cons the first element
can also be (name namespace) pair.
</DL>
</P><P>

<A NAME="IDX602"></A>
<DL>
<DT><U>Function:</U> <B>print-xml-expression</B> <I>((stream OUTPUT-STREAM) (xml-expression CONS) (indent INTEGER)) :</I>
<DD>Prints <VAR>xml-expression</VAR> on <VAR>stream</VAR>.  Indentation begins with the
value of <VAR>indent</VAR>.  If this is the <CODE>null</CODE> integer, no indentation is
performed.  Otherwise it should normally be specified as 0 (zero) for
top-level calls.
</P><P>

It is assumed that the <VAR>xml-expression</VAR> is a well-formed CONS-list
representation of an XML  form.  It expects a form like that form
returned by <CODE>read-XML-expression</CODE>.
</P><P>

Also handles a list of xml forms such as that returned by <CODE>XML-expressions</CODE>.
In that case, each of the forms is indented by <VAR>indent</VAR> spaces.
</DL>
</P><P>

<A NAME="IDX603"></A>
<DL>
<DT><U>Function:</U> <B>reset-xml-hash-tables</B> <I>() :</I>
<DD>Resets Hashtables used for interning XML elements and global
attribute objects.  This will allow garbage collection of no-longer used
objects, but will also mean that newly parsed xml elements and global attributes
will not be eq? to already existing ones with the same name.
</DL>
</P><P>

<A NAME="Miscellaneous"></A>
<HR SIZE="6">
<A NAME="SEC51"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC50"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.19 Miscellaneous </H2>
<!--docid::SEC51::-->
<P>

This is a catch-all section for functions and methods that haven't been
categorized yet into any of the previous sections.  They are in random
order and many of them will never be part of the official STELLA
interface.  So beware!
</P><P>

<A NAME="IDX604"></A>
<DL>
<DT><U>Function:</U> <B>operating-system</B> <I>() : KEYWORD</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX605"></A>
<DL>
<DT><U>Function:</U> <B>activate-demon</B> <I>((demon DEMON)) :</I>
<DD>Install <VAR>demon</VAR> in the location(s) specified by its internal
structure.
</DL>
</P><P>

<A NAME="IDX606"></A>
<DL>
<DT><U>Method:</U> POLYMORPHIC-RELATION <B>active?</B> <I>(self) : BOOLEAN</I>
<DD>True if <VAR>self</VAR> or a superslot of <VAR>self</VAR> is marked active.
</DL>
</P><P>

<A NAME="IDX607"></A>
<DL>
<DT><U>Function:</U> <B>add-configuration-property</B> <I>((property STRING) (value OBJECT) (configuration CONFIGURATION-TABLE)) : OBJECT</I>
<DD>Add <VAR>value</VAR> to <VAR>property</VAR> in <VAR>configuration</VAR> and return it.
If a previous value exists add <VAR>value</VAR> to the end (listify the old value
if it is not yet a list).  Otherwise, create a new list containing <VAR>value</VAR>.
Use the global system configuration table if <VAR>configuration</VAR> is NULL.
</DL>
</P><P>

<A NAME="IDX608"></A>
<DL>
<DT><U>Function:</U> <B>add-hook</B> <I>((hookList HOOK-LIST) (hookFunction SYMBOL)) :</I>
<DD>Insert the function named <VAR>hookFunction</VAR> into <VAR>hookList</VAR>.
</DL>
</P><P>

<A NAME="IDX609"></A>
<DL>
<DT><U>N-Command:</U> <B>add-trace</B> <I>(&#38;rest (keywords GENERALIZED-SYMBOL)) : LIST</I>
<DD>Enable trace messages identified by any of the listed <VAR>keywords</VAR>.  After
calling (<CODE>add-trace</CODE> &#60;keyword&#62;) code guarded by (<CODE>trace-if</CODE> &#60;keyword&#62; ...)
will be executed when it is encountered.
</DL>
</P><P>

<A NAME="IDX610"></A>
<DL>
<DT><U>Function:</U> <B>advance-past-whitespace</B> <I>((source STRING) (start INTEGER)) : INTEGER</I>
<DD>Returns the first index into <VAR>source</VAR>, starting from <VAR>start</VAR>, of
the first character that is not white space.
</DL>
</P><P>

<A NAME="IDX611"></A>
<DL>
<DT><U>Function:</U> <B>all-classes</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF CLASS)</I>
<DD>Iterate over all classes visible from <VAR>module</VAR>.
If <VAR>local?</VAR>, return only classes interned in <VAR>module</VAR>.
If <VAR>module</VAR> is null, return all classes interned everywhere.
</DL>
</P><P>

<A NAME="IDX612"></A>
<DL>
<DT><U>Function:</U> <B>all-contexts</B> <I>() : (ITERATOR OF CONTEXT)</I>
<DD>Return an iterator that generates all contexts.
</DL>
</P><P>

<A NAME="IDX613"></A>
<DL>
<DT><U>Macro:</U> <B>all-defined?</B> <I>(&#38;body (forms CONS)) : OBJECT</I>
<DD>Evaluate each of the forms in <VAR>forms</VAR>, and
return TRUE if none of them are NULL.
</DL>
</P><P>

<A NAME="IDX614"></A>
<DL>
<DT><U>Function:</U> <B>all-functions</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF FUNCTION)</I>
<DD>Iterate over all functions visible from <VAR>module</VAR>.
If <VAR>local?</VAR>, return only functions bound to symbols interned in <VAR>module</VAR>.
If <VAR>module</VAR> is null, return all functions defined everywhere.
</DL>
</P><P>

<A NAME="IDX615"></A>
<DL>
<DT><U>Function:</U> <B>all-included-modules</B> <I>((self MODULE)) : (ITERATOR OF MODULE)</I>
<DD>Generate a sequence of all modules included
by <VAR>self</VAR>, inclusive, starting from the highest ancestor and working
down to <VAR>self</VAR> (which is last).
</DL>
</P><P>

<A NAME="IDX616"></A>
<DL>
<DT><U>Function:</U> <B>all-methods</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF METHOD-SLOT)</I>
<DD>Iterate over all methods visible from <VAR>module</VAR>.
If <VAR>local?</VAR>, return only methods interned in <VAR>module</VAR>.
If <VAR>module</VAR> is null, return all methods interned everywhere.
</DL>
</P><P>

<A NAME="IDX617"></A>
<DL>
<DT><U>Function:</U> <B>all-modules</B> <I>() : (ITERATOR OF MODULE)</I>
<DD>Return an iterator that generates all modules.
</DL>
</P><P>

<A NAME="IDX618"></A>
<DL>
<DT><U>Function:</U> <B>all-public-functions</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF FUNCTION)</I>
<DD>Iterate over all functions visible from <VAR>module</VAR>.
If <VAR>local?</VAR>, return only functions bound to symbols interned in <VAR>module</VAR>.
If <VAR>module</VAR> is null, return all functions defined everywhere.
</DL>
</P><P>

<A NAME="IDX619"></A>
<DL>
<DT><U>Function:</U> <B>all-public-methods</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF METHOD-SLOT)</I>
<DD>Iterate over all public methods visible from <VAR>module</VAR>.
If <VAR>local?</VAR>, return only methods interned in <VAR>module</VAR>.
If <VAR>module</VAR> is null, return all methods interned everywhere.
</DL>
</P><P>

<A NAME="IDX620"></A>
<DL>
<DT><U>Function:</U> <B>all-required-systems</B> <I>((system-name STRING)) : (CONS OF STRING-WRAPPER)</I>
<DD>Returns a CONS of all of the systems required by <VAR>system-name</VAR>
</DL>
</P><P>

<A NAME="IDX621"></A>
<DL>
<DT><U>Function:</U> <B>all-slots</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF SLOT)</I>
<DD>Iterate over all slots visible from <VAR>module</VAR>.
If <VAR>local?</VAR>, return only methods interned in <VAR>module</VAR>.
If <VAR>module</VAR> is null, return all methods interned everywhere.
</DL>
</P><P>

<A NAME="IDX622"></A>
<DL>
<DT><U>Function:</U> <B>all-subcontexts</B> <I>((context CONTEXT) (traversal KEYWORD)) : (ALL-PURPOSE-ITERATOR OF CONTEXT)</I>
<DD>Return an iterator that generates all subcontexts of
<CODE>self</CODE> (not including <CODE>self</CODE>) in the order specified by <VAR>traversal</VAR> (one
of :preorder, :inorder, :postorder or :topdown).
</DL>
</P><P>

<A NAME="IDX623"></A>
<DL>
<DT><U>Function:</U> <B>all-surrogates</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF SURROGATE)</I>
<DD>Iterate over all surrogates visible from <VAR>module</VAR>.
If <VAR>local?</VAR>, return only surrogates interned in <VAR>module</VAR>.
If <VAR>module</VAR> is null, return all surrogates interned everywhere.
</DL>
</P><P>

<A NAME="IDX624"></A>
<DL>
<DT><U>Function:</U> <B>all-symbols</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF SYMBOL)</I>
<DD>Iterate over all symbols visible from <VAR>module</VAR>.
If <VAR>local?</VAR>, return only symbols interned in <VAR>module</VAR>.
If <VAR>module</VAR> is null, return all symbols interned everywhere.
</DL>
</P><P>

<A NAME="IDX625"></A>
<DL>
<DT><U>Function:</U> <B>all-variables</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF GLOBAL-VARIABLE)</I>
<DD>Iterate over all variables visible from <VAR>module</VAR>.
If <VAR>local?</VAR>, return only variables bound to symbols interned in <VAR>module</VAR>.
If <VAR>module</VAR> is null, return all variables defined everywhere.
</DL>
</P><P>

<A NAME="IDX626"></A>
<DL>
<DT><U>Method:</U> ABSTRACT-ITERATOR <B>allocate-iterator</B> <I>(self) : (LIKE SELF)</I>
<DD>Iterator objects return themselves when asked
for an iterator (they occupy the same position as a collection
within a <CODE>foreach</CODE> statement).
</DL>
</P><P>

<A NAME="IDX627"></A>
<DL>
<DT><U>Method:</U> MEMOIZABLE-ITERATOR <B>allocate-iterator</B> <I>(self) : (ITERATOR OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Alias for <CODE>clone-memoized-iterator</CODE>.
</DL>
</P><P>

<A NAME="IDX628"></A>
<DL>
<DT><U>Method:</U> STORAGE-SLOT <B>allocation</B> <I>(self) : KEYWORD</I>
<DD>Return the most specific :allocation facet, or
:instance if all inherited values are NULL.
</DL>
</P><P>

<A NAME="IDX629"></A>
<DL>
<DT><U>Function:</U> <B>apply</B> <I>((code FUNCTION-CODE) (arguments (CONS OF OBJECT))) : OBJECT</I>
<DD>Apply <VAR>code</VAR> to <VAR>arguments</VAR>, returning a value of type
OBJECT.
</DL>
</P><P>

<A NAME="IDX630"></A>
<DL>
<DT><U>Function:</U> <B>apply-boolean-method</B> <I>((code METHOD-CODE) (arguments (CONS OF OBJECT))) : BOOLEAN</I>
<DD>Apply <VAR>code</VAR> to <VAR>arguments</VAR>, returning a value of type
BOOLEAN.
</DL>
</P><P>

<A NAME="IDX631"></A>
<DL>
<DT><U>Function:</U> <B>apply-float-method</B> <I>((code METHOD-CODE) (arguments (CONS OF OBJECT))) : FLOAT</I>
<DD>Apply <VAR>code</VAR> to <VAR>arguments</VAR>, returning a value of type
FLOAT.
</DL>
</P><P>

<A NAME="IDX632"></A>
<DL>
<DT><U>Function:</U> <B>apply-integer-method</B> <I>((code METHOD-CODE) (arguments (CONS OF OBJECT))) : INTEGER</I>
<DD>Apply <VAR>code</VAR> to <VAR>arguments</VAR>, returning a value of type
INTEGER.
</DL>
</P><P>

<A NAME="IDX633"></A>
<DL>
<DT><U>Function:</U> <B>apply-method</B> <I>((code METHOD-CODE) (arguments (CONS OF OBJECT))) : OBJECT</I>
<DD>Apply <VAR>code</VAR> to <VAR>arguments</VAR>, returning a value of type
OBJECT.
</DL>
</P><P>

<A NAME="IDX634"></A>
<DL>
<DT><U>Function:</U> <B>apply-string-method</B> <I>((code METHOD-CODE) (arguments (CONS OF OBJECT))) : STRING</I>
<DD>Apply <VAR>code</VAR> to <VAR>arguments</VAR>, returning a value of type
STRING.
</DL>
</P><P>

<A NAME="IDX635"></A>
<DL>
<DT><U>Function:</U> <B>base60-to-float</B> <I>((l (CONS OF NUMBER-WRAPPER))) : FLOAT</I>
<DD>Converts (x y z) into a float.  The return value
is x + y/60 + z/3600.
This can be used to convert from Degree-Minute-Second to decimal degrees
or from Hour-Minute-Second format to decimal hours.
</DL>
</P><P>

<A NAME="IDX636"></A>
<DL>
<DT><U>Function:</U> <B>break-program</B> <I>((message STRING)) :</I>
<DD>Interrupt the program and print <VAR>message</VAR>.  Continue after
confirmation with the user.
</DL>
</P><P>

<A NAME="IDX637"></A>
<DL>
<DT><U>Function:</U> <B>byte-array-read-sequence</B> <I>((buffer TOKENIZER-BYTE-ARRAY) (stream INPUT-STREAM) (start INTEGER) (end INTEGER)) : INTEGER</I>
<DD>Read from <VAR>stream</VAR> filling <VAR>buffer</VAR> between <VAR>start</VAR> and <VAR>end</VAR> (depending
on how many characters are available).
Return the actual end pointer to the input read into <VAR>buffer</VAR>.  EOF is
indicated by the return value being equal to start.
</DL>
</P><P>

<A NAME="IDX638"></A>
<DL>
<DT><U>Function:</U> <B>byte-array-write-sequence</B> <I>((buffer TOKENIZER-BYTE-ARRAY) (stream NATIVE-OUTPUT-STREAM) (start INTEGER) (end INTEGER)) :</I>
<DD>Write from <VAR>buffer</VAR> to <VAR>stream</VAR>, using data in the buffer starting at position
<VAR>start</VAR> stopping just before <VAR>end</VAR>.
</DL>
</P><P>

<A NAME="IDX639"></A>
<DL>
<DT><U>Method:</U> CALENDAR-DATE <B>calendar-date-to-date-string</B> <I>(date (timezone FLOAT) (numeric-month? BOOLEAN)) : STRING</I>
<DD>Returns the date part of the string representation of <VAR>date</VAR> 
adjusted for <VAR>timezone</VAR>.  Format is YYYY-MMM-DD, where MMM is a three letter
English abbreviation of the month if <VAR>numeric-month?</VAR> is <CODE>false</CODE> and a two
digit numeric value if <VAR>numeric-month?</VAR> is <CODE>true</CODE>.  The value <CODE>false</CODE> is
recommended.
</DL>
</P><P>

<A NAME="IDX640"></A>
<DL>
<DT><U>Method:</U> CALENDAR-DATE <B>calendar-date-to-iso8601-string</B> <I>(date (timezone FLOAT) (include-timezone? BOOLEAN)) : STRING</I>
<DD>Returns an ISO-8601 string representation of <VAR>date</VAR> adjusted for <VAR>timezone</VAR>.
The Format is YYYY-MM-DDThh:mm:ss z:zz.  The timezone as an offset
hh:mm is included if <VAR>include-timezone?</VAR> is <CODE>true</CODE>.
</P><P>

Recommended values for the flag is <CODE>true</CODE>.
</DL>
</P><P>

<A NAME="IDX641"></A>
<DL>
<DT><U>Method:</U> CALENDAR-DATE <B>calendar-date-to-string</B> <I>(date (timezone FLOAT) (numeric-month? BOOLEAN) (include-timezone? BOOLEAN)) : STRING</I>
<DD>Returns a string representation of <VAR>date</VAR> adjusted for <VAR>timezone</VAR>.
The Format is YYYY-MMM-DD hh:mm:ss z.z, where MMM is a three letter
English abbreviation of the month if <VAR>numeric-month?</VAR> is <CODE>false</CODE> and a two
digit numeric value if <VAR>numeric-month?</VAR> is <CODE>true</CODE>.  The timezone as a
float offset z.z is included if <VAR>include-timezone?</VAR> is <CODE>true</CODE>.
</P><P>

Recommended values for the flags are <CODE>false</CODE> and <CODE>true</CODE> respectively.
</DL>
</P><P>

<A NAME="IDX642"></A>
<DL>
<DT><U>Method:</U> CALENDAR-DATE <B>calendar-date-to-time-string</B> <I>(date (timezone FLOAT) (include-timezone? BOOLEAN) (include-millis? BOOLEAN) (pad-hours? BOOLEAN)) : STRING</I>
<DD>Returns the time part of the string representation of <VAR>date</VAR>
adjusted for <VAR>timezone</VAR>.  The timezone is included in the string if
<VAR>include-timezone?</VAR> is <CODE>true</CODE>.  The value <CODE>true</CODE> is recommended.
Milliseconds will be included if <VAR>include-millis?</VAR> is <CODE>true</CODE>.
Hours will be zero-padded to length 2 if <VAR>pad-hours?</VAR> is <CODE>true</CODE>.
</P><P>

</DL>
</P><P>

<A NAME="IDX643"></A>
<DL>
<DT><U>Command:</U> <B>call-clear-module</B> <I>(&#38;rest (name NAME)) :</I>
<DD>Destroy all objects belonging to module <VAR>name</VAR> or any of its children.
If no <VAR>name</VAR> is supplied, the current module will be cleared after
confirming with the user.  Important modules such as STELLA are protected
against accidental clearing.
</DL>
</P><P>

<A NAME="IDX644"></A>
<DL>
<DT><U>Function:</U> <B>cast</B> <I>((value OBJECT) (type TYPE)) : OBJECT</I>
<DD>Perform a run-time type check, and then return <VAR>value</VAR>.
</DL>
</P><P>

<A NAME="IDX645"></A>
<DL>
<DT><U>N-Command:</U> <B>ccc</B> <I>(&#38;rest (name NAME)) : CONTEXT</I>
<DD>Change the current context to the one named <VAR>name</VAR>.  Return the
value of the new current context.  If no <VAR>name</VAR> is supplied, return
the pre-existing value of the current context.  <CODE>cc</CODE> is a no-op if the
context reference cannot be successfully evaluated.
In CommonLisp, if the new context is case sensitive, then change
the readtable case to :INVERT, otherwise to :UPCASE.
</DL>
</P><P>

<A NAME="IDX646"></A>
<DL>
<DT><U>Function:</U> <B>cl-slot-value</B> <I>((object OBJECT) (slotName STRING) (dontConvert? BOOLEAN)) : LISP-CODE</I>
<DD>Lookup slot <VAR>slotName</VAR> on <VAR>object</VAR> and return the lispified
slot value (see <CODE>lispify</CODE>).  If <VAR>dontConvert?</VAR> is TRUE, the returned slot value
will not be lispified.  Generate a warning if no such slot exists on <VAR>object</VAR>.
In a call directly from Lisp <VAR>slotName</VAR> can also be supplied as a Lisp symbol.
</DL>
</P><P>

<A NAME="IDX647"></A>
<DL>
<DT><U>Function:</U> <B>cl-slot-value-setter</B> <I>((object OBJECT) (slotName STRING) (value LISP-CODE) (dontConvert? BOOLEAN)) : LISP-CODE</I>
<DD>Lookup slot <VAR>slotName</VAR> on <VAR>object</VAR> and set its value to
the stellafied <VAR>value</VAR> (see <CODE>stellafy</CODE>).  If <VAR>dontConvert?</VAR> is TRUE, <VAR>value</VAR>
will not be stellafied before it gets assigned.  Generate a warning if no
such slot exists on <VAR>object</VAR>, or if <VAR>value</VAR> has the wrong type.  In a call
directly from Lisp <VAR>slotName</VAR> can also be supplied as a Lisp symbol.
</DL>
</P><P>

<A NAME="IDX648"></A>
<DL>
<DT><U>Function:</U> <B>cl-translate-file</B> <I>((file FILE-NAME) (relative? BOOLEAN)) :</I>
<DD>Translate a Stella <VAR>file</VAR> to Common-Lisp.  If
<VAR>relative?</VAR>, concatenate root directory to <VAR>file</VAR>.
</DL>
</P><P>

<A NAME="IDX649"></A>
<DL>
<DT><U>Function:</U> <B>cl-translate-system</B> <I>((system-name STRING)) :</I>
<DD>Translate a Stella system named <VAR>system-name</VAR> to Common Lisp.
</DL>
</P><P>

<A NAME="IDX650"></A>
<DL>
<DT><U>Function:</U> <B>cleanup-unfinalized-classes</B> <I>() :</I>
<DD>Remove all finalized classes from <CODE>*UNFINALIZED-CLASSES*</CODE>,
and set <CODE>*NEWLY-UNFINALIZED-CLASSES?*</CODE> to <CODE>false</CODE>.
</DL>
</P><P>

<A NAME="IDX651"></A>
<DL>
<DT><U>Function:</U> <B>clear-configuration-property</B> <I>((property STRING) (configuration CONFIGURATION-TABLE)) : OBJECT</I>
<DD>Remove <VAR>property</VAR> in <VAR>configuration</VAR> and return the previous
value.
Use the global system configuration table if <VAR>configuration</VAR> is NULL.
</DL>
</P><P>

<A NAME="IDX652"></A>
<DL>
<DT><U>Function:</U> <B>clear-recycle-list</B> <I>((list RECYCLE-LIST)) :</I>
<DD>Reset <VAR>list</VAR> to its empty state.
</DL>
</P><P>

<A NAME="IDX653"></A>
<DL>
<DT><U>Function:</U> <B>clear-recycle-lists</B> <I>() :</I>
<DD>Reset all currently active recycle lists to their empty state.
</DL>
</P><P>

<A NAME="IDX654"></A>
<DL>
<DT><U>Function:</U> <B>clear-system</B> <I>((name STRING)) :</I>
<DD>Clears out the system definition named <VAR>name</VAR>.  If
<VAR>name</VAR> is <CODE>null</CODE>, then clear out all system definitions.  This function
is useful when changes have been made to the system definition, and one
wants to have it reloaded from the standard location in the file system.
</DL>
</P><P>

<A NAME="IDX655"></A>
<DL>
<DT><U>Command:</U> <B>clear-trace</B> <I>() :</I>
<DD>Disable all tracing previously enabled with <CODE>add-trace</CODE>.
</DL>
</P><P>

<A NAME="IDX656"></A>
<DL>
<DT><U>Function:</U> <B>clone-memoized-iterator</B> <I>((self MEMOIZABLE-ITERATOR)) : (ITERATOR OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Clone the memoized iterator <VAR>self</VAR> so it can be used to
iterate over the collection represented by <VAR>self</VAR>, while allowing to iterate
over it multiple times via multiple clones.
</DL>
</P><P>

<A NAME="IDX657"></A>
<DL>
<DT><U>Macro:</U> <B>coerce-&#38;rest-to-cons</B> <I>((restVariable SYMBOL)) : OBJECT</I>
<DD>Coerce the argument list variable <VAR>restVariable</VAR> into a CONS
list containing all its elements (uses argument list iteration to do so).  If
<VAR>restVariable</VAR> already is a CONS due to argument listification, this is a no-op.
</DL>
</P><P>

<A NAME="IDX658"></A>
<DL>
<DT><U>Function:</U> <B>coerce-to-symbol</B> <I>((name NAME)) : GENERALIZED-SYMBOL</I>
<DD>Return the (generalized) symbol represented by <VAR>name</VAR>.
Return <CODE>null</CODE> if <VAR>name</VAR> is undefined or does not represent a string.
</DL>
</P><P>

<A NAME="IDX659"></A>
<DL>
<DT><U>Macro:</U> <B>collect</B> <I>(&#38;body (body CONS)) : OBJECT</I>
<DD>Use a VRLET to collect values.  Input can have one of
the following forms:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  (collect &#60;var&#62; in &#60;expression&#62; [where &#60;test&#62; &#60;var&#62;])
  (collect &#60;collect-expression&#62;
           foreach &#60;var&#62; in &#60;expression&#62;
           {as ...}*
           [where &#60;test&#62; &#60;var&#62;]
           [do ...])
</pre></td></tr></table></P><P>

The second form really accepts an arbitrary <CODE>foreach</CODE> expression following
the <CODE>foreach</CODE> keyword.
</DL>
</P><P>

<A NAME="IDX660"></A>
<DL>
<DT><U>Method:</U> SLOT <B>collection-valued?</B> <I>(self) : BOOLEAN</I>
<DD>True if slot values are collections.
</DL>
</P><P>

<A NAME="IDX661"></A>
<DL>
<DT><U>Function:</U> <B>command?</B> <I>((method METHOD-SLOT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>method</VAR> is an evaluable command.
</DL>
</P><P>

<A NAME="IDX662"></A>
<DL>
<DT><U>Method:</U> STORAGE-SLOT <B>component?</B> <I>(self) : BOOLEAN</I>
<DD>True if fillers of this slot are components of the
owner slot, and therefore should be deleted if the owner is deleted.
</DL>
</P><P>

<A NAME="IDX663"></A>
<DL>
<DT><U>Function:</U> <B>compose-namestring</B> <I>((name-components (CONS OF STRING-WRAPPER)) &#38;rest (options OBJECT)) : STRING</I>
<DD><VAR>name-components</VAR> is a cons to be processed into a namestring.
<CODE>:prefix</CODE> and <CODE>:suffix</CODE> are strings that will NOT be case-converted.
<CODE>:case</CODE> is one of :UPCASE :TitleCase :titleCaseX :downcase :Capitalize
        default is :TitleCase
<CODE>:separator</CODE> is a string that should separate word elements.  It does not
       separate the prefix or suffix.  Default is ""
<CODE>:translation-table</CODE> should be a STRING-HASH-TABLE hash table that strings into their
       desired printed representation as a string.  In general the argument
       will be strings, but that is not strictly necessary.
</P><P>

</DL>
</P><P>

<A NAME="IDX664"></A>
<DL>
<DT><U>Function:</U> <B>compose-namestring-full</B> <I>((strings (CONS OF STRING-WRAPPER)) (prefix STRING) (suffix STRING) (outputcase KEYWORD) (outputseparator STRING) (translationtable STRING-HASH-TABLE) (useacronymheuristics? BOOLEAN)) : STRING</I>
<DD>Non-keyword version of <CODE>compose-namestring</CODE>, which will probably be
easier to use when called from non-Lisp languages.
</DL>
</P><P>

<A NAME="IDX665"></A>
<DL>
<DT><U>Function:</U> <B>compute-module-and-bare-name</B> <I>((name STRING)) : MODULE STRING</I>
<DD>Compute the module indicated by the STELLA name
<VAR>name</VAR> and return it.  Return the bare symbol name as the second
value.  <VAR>name</VAR> does not necessarily have to be qualified in which
case the current module is returned.  <VAR>name</VAR> is assumed to be the
printed representation of a STELLA symbol, surrogate or keyword.
</DL>
</P><P>

<A NAME="IDX666"></A>
<DL>
<DT><U>Function:</U> <B>configure-stella</B> <I>((file FILE-NAME)) :</I>
<DD>Perform STELLA run-time configuration.  If supplied, load the
configuration file <VAR>file</VAR> first which should be supplied with a physical pathname.
</DL>
</P><P>

<A NAME="IDX667"></A>
<DL>
<DT><U>Method:</U> OBJECT <B>consify</B> <I>(self) : CONS</I>
<DD>If <CODE>object</CODE> is a CONS, return it.  Otherwise, return
a singleton cons list containing it.
</DL>
</P><P>

<A NAME="IDX668"></A>
<DL>
<DT><U>Function:</U> <B>consify-command-line-arguments</B> <I>((count INTEGER) (arguments (ARRAY () OF STRING))) : (CONS OF STRING-WRAPPER)</I>
<DD>Convert <VAR>count</VAR> command line <VAR>arguments</VAR> into a CONS list.
</DL>
</P><P>

<A NAME="IDX669"></A>
<DL>
<DT><U>Macro:</U> <B>continuable-error</B> <I>(&#38;body (body CONS)) : OBJECT</I>
<DD>Signal error message, placing non-string arguments in quotes.
</DL>
</P><P>

<A NAME="IDX670"></A>
<DL>
<DT><U>Function:</U> <B>cpp-translate-system</B> <I>((systemName STRING)) :</I>
<DD>Translate the system <VAR>systemName</VAR> to C++.
</DL>
</P><P>

<A NAME="IDX671"></A>
<DL>
<DT><U>N-Command:</U> <B>cpptrans</B> <I>((statement OBJECT)) :</I>
<DD>Translate <VAR>statement</VAR> to C++ and print the result.
</DL>
</P><P>

<A NAME="IDX672"></A>
<DL>
<DT><U>Function:</U> <B>create-derived-list</B> <I>((self LIST)) : LIST</I>
<DD>Create a new list object with the same type as <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX673"></A>
<DL>
<DT><U>Function:</U> <B>create-object</B> <I>((type TYPE) &#38;rest (initial-value-pairs OBJECT)) : OBJECT</I>
<DD>Funcallable version of the <CODE>new</CODE> operator.
Return an instance of the class named by <VAR>type</VAR>.  If <VAR>initial-value-pairs</VAR>
is supplied, it has to be a key/value list similar to what's accepted by <CODE>new</CODE>
and the named slots will be initialized with the supplied values.  Similar to
<CODE>new</CODE>, all required arguments for <VAR>type</VAR> must be included.  Since all the
slot initialization, etc. is handled dynamically at run time, <CODE>create-object</CODE>
is much slower than <CODE>new</CODE>; therefore, it should only be used if <VAR>type</VAR> cannot
be known at translation time.
</DL>
</P><P>

<A NAME="IDX674"></A>
<DL>
<DT><U>Function:</U> <B>deactivate-demon</B> <I>((demon DEMON)) :</I>
<DD>Detach <VAR>demon</VAR> from the location(s) specified by its internal
structure.
</DL>
</P><P>

<A NAME="IDX675"></A>
<DL>
<DT><U>Method:</U> DECODED-DATE-TIME <B>decoded-date-time-to-iso8601-string</B> <I>(date) : STRING</I>
<DD>Returns an ISO-8601 string representation of <VAR>date</VAR>
The Format is YYYY-MM-DDThh:mm:ss+zz:zz, with the string stopping at
when a null value is first encountered.  The time zone will only
be included (if present) if a time value is given.
</DL>
</P><P>

<A NAME="IDX676"></A>
<DL>
<DT><U>Function:</U> <B>decompose-namestring</B> <I>((namestring STRING) &#38;rest (options OBJECT)) : (CONS OF STRING-WRAPPER)</I>
<DD>Keyword options:
  :break-on-cap    one of  :YES :NO :CLEVER         default is :CLEVER
  :break-on-number one of  :YES :NO :CLEVER         default is :CLEVER
  :break-on-separators string                       default is "-_ "
</P><P>

  DECOMPOSE-NAMESTRING returns a cons of STRING-WRAPPERS that are the decomposition of the
input STRING.  The arguments are used as follows:
  <VAR>namestring</VAR>       is the input string.
  :break-on-cap    is a keyword controlling whether changes in capitalization is used
                   to indicate word boundaries.  If :YES, then all capitalization
                   changes delineate words.  If :CLEVER, then unbroken runs of
                   capitalized letters are treated as acronyms and remain grouped.
                   If :NO or NULL, there is no breaking of words based on capitalization.
  :break-on-number is a flag controlling whether encountering a number indicates
                   a word boundary.  If :YES, then each run of numbers is treated as
		   a word separate from surrounding words.  If :CLEVER, then an 
		   attempt is made to recognize ordinal numbers (ie, 101st) and
		   treat them as separate words.  If :NO or NULL, there is no breaking
                   of words when numbers are encountered.
  :break-on-separators   A string of characters which constitute word delimiters in
                         the input word.  This is used to determine how to break
                   the name into individual words.  Defaults are space, <CODE>-</CODE> and <CODE>_</CODE>.
</DL>
</P><P>

<A NAME="IDX677"></A>
<DL>
<DT><U>Function:</U> <B>decompose-namestring-full</B> <I>((namestring STRING) (break-on-cap KEYWORD) (break-on-number KEYWORD) (break-on-separators STRING)) : (CONS OF STRING-WRAPPER)</I>
<DD>Non-keyword version of <CODE>decompose-namestring</CODE>, which will probably be
easier to use when called from non-Lisp languages.
</DL>
</P><P>

<A NAME="IDX678"></A>
<DL>
<DT><U>Method:</U> STORAGE-SLOT <B>default-form</B> <I>(self) : OBJECT</I>
<DD>Returns the current value of default expression when the
slot has not been assigned a value.
</DL>
</P><P>

<A NAME="IDX679"></A>
<DL>
<DT><U>Macro:</U> <B>defdemon</B> <I>((name STRING-WRAPPER) (parameterstree CONS) &#38;body (optionsandbody CONS)) : OBJECT</I>
<DD>Define a demon <VAR>name</VAR> and attach it to a class or slot.
</DL>
</P><P>

<A NAME="IDX680"></A>
<DL>
<DT><U>Function:</U> <B>define-demon</B> <I>((name STRING) &#38;rest (options OBJECT)) : DEMON</I>
<DD>Define a class or slot demon.  Options are :create,
:destroy, :class, :slot, :guard?, :code, :method, :inherit?, and :documentation.
</DL>
</P><P>

<A NAME="IDX681"></A>
<DL>
<DT><U>Function:</U> <B>define-logical-host-property</B> <I>((host STRING) (property KEYWORD) (value OBJECT)) :</I>
<DD>Define <VAR>property</VAR> with <VAR>value</VAR> for the logical host <VAR>host</VAR>.
As a side-effect, this also defines <VAR>host</VAR> as a logical host (both
<VAR>property</VAR> and <VAR>value</VAR> can be supplied as NULL).  If :ROOT-DIRECTORY
is specified, all pathnames with <VAR>host</VAR> are assumed to be relative to
that directory (even if they are absolute) and will be rerooted upon
translation.  :ROOT-DIRECTORY can be a logical or physical pathname.
If :LISP-TRANSLATIONS is specified, those will be used verbatimely as
the value of <CODE>(CL:logical-pathname-translations host)</CODE> if we are
running in Lisp, which allows us to depend on the native
<CODE>CL:translate-logical-pathname</CODE> for more complex translation operations.
</DL>
</P><P>

<A NAME="IDX682"></A>
<DL>
<DT><U>Function:</U> <B>define-module</B> <I>((name STRING) (options CONS)) : MODULE</I>
<DD>Define or redefine a module named <VAR>name</VAR> having the
options <VAR>options</VAR>.  Return the new module.
</DL>
</P><P>

<A NAME="IDX683"></A>
<DL>
<DT><U>Function:</U> <B>define-stella-class</B> <I>((name TYPE) (supers (LIST OF TYPE)) (slots (LIST OF SLOT)) (options KEYWORD-KEY-VALUE-LIST)) : CLASS</I>
<DD>Return a Stella class with name <VAR>name</VAR>.
Caution:  If the class already exists, the Stella class object gets
redefined, but the native C++ class is not redefined.
</DL>
</P><P>

<A NAME="IDX684"></A>
<DL>
<DT><U>Function:</U> <B>define-stella-method-slot</B> <I>((inputname SYMBOL) (returntypes CONS) (function? BOOLEAN) (inputParameters CONS) (options KEYWORD-KEY-VALUE-LIST)) : METHOD-SLOT</I>
<DD>Define a new Stella method object (a slot), and attach it
to the class identified by the first parameter in <VAR>inputParameters</VAR>.
</DL>
</P><P>

<A NAME="IDX685"></A>
<DL>
<DT><U>Method:</U> ARRAY <B>defined?</B> <I>(x) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is defined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX686"></A>
<DL>
<DT><U>Macro:</U> <B>defmain</B> <I>((varList CONS) &#38;body (body CONS)) : OBJECT</I>
<DD>Defines a function called MAIN which will have the appropriate
signature for the target translation language.  The signature will be:
  C++:   public static int main (int v1, char** v2) {&#60;body&#62;}
  Java:  public static void main (String [] v2) {&#60;body&#62;}
  Lisp:  (defun main (&#38;rest args) &#60;body&#62;)
The argument <VAR>varList</VAR> must have two symbols, which will be the names for the
INTEGER argument count and an array of STRINGs with the argument values.  It
can also be empty to indicate that no command line arguments will be handled.
The startup function for the containing system will automatically be called
before <VAR>body</VAR> is executed unless the option :STARTUP-SYSTEM? was supplied as
FALSE.  There can only be one DEFMAIN per module.
</DL>
</P><P>

<A NAME="IDX687"></A>
<DL>
<DT><U>N-Command:</U> <B>defsystem</B> <I>((name SYMBOL) &#38;rest (options OBJECT)) : SYSTEM-DEFINITION</I>
<DD>Define a system of files that collectively define
a Stella application.
   Required options are:
   :directory -- the relative path from the respective source/native/binary root directory
                 to the directory containing the system files.  Can be a string or a list
                 of strings (do not include directory separators).
   :files -- a list of files in the system, containing strings and lists
             of strings; the latter defines exploded paths to files
             in subdirectories.
   Optional options are:
   :required-systems -- a list of systems (strings) that should be loaded
                        prior to loading this system.
   :cardinal-module -- the name (a string) of the principal module for this
                       system.
   :copyright-header -- string with a header for inclusion into all translated
                        files produced by Stella.
   :lisp-only-files  -- Like the :files keyword, but these are only included
   :cpp-only-files      in the translation for the specific language, namely
   :java-only-files     Common Lisp, C++ or Java
</DL>
</P><P>

<A NAME="IDX688"></A>
<DL>
<DT><U>Method:</U> OBJECT <B>deleted?</B> <I>(self) : BOOLEAN</I>
<DD>Default <CODE>deleted?</CODE> method which always returns FALSE.  Objects
that inherit DYNAMIC-SLOTS-MIXIN also inherit the dynamically-allocated slot
<CODE>deleted-object?</CODE> which is read/writable with specializations of this method.
</DL>
</P><P>

<A NAME="IDX689"></A>
<DL>
<DT><U>N-Command:</U> <B>describe</B> <I>((name OBJECT) &#38;rest (mode OBJECT)) :</I>
<DD>Print a description of an object in :verbose, :terse,
or :source modes.
</DL>
</P><P>

<A NAME="IDX690"></A>
<DL>
<DT><U>Method:</U> OBJECT <B>describe-object</B> <I>(self (stream OUTPUT-STREAM) (mode KEYWORD)) :</I>
<DD>Prints a description of <VAR>self</VAR> to stream <VAR>stream</VAR>.  <VAR>mode</VAR>
can be :terse, :verbose, or :source.  The :terse mode is often equivalent
to the standard print function.
</DL>
</P><P>

<A NAME="IDX691"></A>
<DL>
<DT><U>Method:</U> CLASS <B>destroy-class</B> <I>(self) :</I>
<DD>Destroy the Stella class <VAR>self</VAR>.  
Unfinalize its subclasses (if it has any).
</DL>
</P><P>

<A NAME="IDX692"></A>
<DL>
<DT><U>Function:</U> <B>destroy-class-and-subclasses</B> <I>((self CLASS)) :</I>
<DD>Destroy the Stella class <VAR>self</VAR> and all its subclasses.
</DL>
</P><P>

<A NAME="IDX693"></A>
<DL>
<DT><U>Function:</U> <B>destructure-defmethod-tree</B> <I>((method-tree CONS) (options-table KEY-VALUE-LIST)) : OBJECT CONS CONS</I>
<DD>Return three parse trees representing the name,
parameters, and code body of the parse tree <VAR>method-tree</VAR>.  Fill
<VAR>options-table</VAR> with a dictionary of method options.
Storage note:  Options are treated specially because the other return
values are subtrees of <VAR>method-tree</VAR>, while <VAR>options-table</VAR> is a newly-created
cons tree.  Note also, the parameter and body trees are destructively
removed from <VAR>method-tree</VAR>.
</DL>
</P><P>

<A NAME="IDX694"></A>
<DL>
<DT><U>Function:</U> <B>dictionary</B> <I>((collectionType TYPE) &#38;rest (alternatingkeysandvalues OBJECT)) : (ABSTRACT-DICTIONARY OF OBJECT OBJECT)</I>
<DD>Return a dictionary of <VAR>collectionType</VAR> containing <CODE>values</CODE>, in order.
Currently supported <VAR>collectionType</VAR>s are @HASH-TABLE, @STELLA-HASH-TABLE,
@KEY-VALUE-LIST, @KEY-VALUE-MAP and @PROPERTY-LIST.
</DL>
</P><P>

<A NAME="IDX695"></A>
<DL>
<DT><U>Method:</U> CLASS <B>direct-super-classes</B> <I>(self) : (ITERATOR OF CLASS)</I>
<DD>Returns an iterator that generates all direct
super classes of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX696"></A>
<DL>
<DT><U>Command:</U> <B>disable-memoization</B> <I>() :</I>
<DD>Enable memoization and use of memoized expression results.
</DL>
</P><P>

<A NAME="IDX697"></A>
<DL>
<DT><U>Function:</U> <B>disabled-stella-feature?</B> <I>((feature KEYWORD)) : BOOLEAN</I>
<DD>Return true if the STELLA <VAR>feature</VAR> is currently disabled.
</DL>
</P><P>

<A NAME="IDX698"></A>
<DL>
<DT><U>Function:</U> <B>drop-hook</B> <I>((hookList HOOK-LIST) (hookFunction SYMBOL)) :</I>
<DD>Remove the function named <VAR>hookFunction</VAR> from <VAR>hookList</VAR>.
</DL>
</P><P>

<A NAME="IDX699"></A>
<DL>
<DT><U>N-Command:</U> <B>drop-trace</B> <I>(&#38;rest (keywords GENERALIZED-SYMBOL)) : LIST</I>
<DD>Disable trace messages identified by any of the listed <VAR>keywords</VAR>.  After
calling (<CODE>drop-trace</CODE> &#60;keyword&#62;) code guarded by (<CODE>trace-if</CODE> &#60;keyword&#62; ...)
will not be executed when it is encountered.
</DL>
</P><P>

<A NAME="IDX700"></A>
<DL>
<DT><U>Macro:</U> <B>either</B> <I>((value1 OBJECT) (value2 OBJECT)) : OBJECT</I>
<DD>If <VAR>value1</VAR> is defined, return that, else return <VAR>value2</VAR>.
</DL>
</P><P>

<A NAME="IDX701"></A>
<DL>
<DT><U>Method:</U> STRING-WRAPPER <B>empty?</B> <I>(x) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is the wrapped empty string ""
</DL>
</P><P>

<A NAME="IDX702"></A>
<DL>
<DT><U>Command:</U> <B>enable-memoization</B> <I>() :</I>
<DD>Enable memoization and use of memoized expression results.
</DL>
</P><P>

<A NAME="IDX703"></A>
<DL>
<DT><U>Function:</U> <B>enabled-stella-feature?</B> <I>((feature KEYWORD)) : BOOLEAN</I>
<DD>Return true if the STELLA <VAR>feature</VAR> is currently enabled.
</DL>
</P><P>

<A NAME="IDX704"></A>
<DL>
<DT><U>Function:</U> <B>ensure-file-does-not-exist</B> <I>((filename STRING) (context STRING)) :</I>
<DD>Ensures that <VAR>filename</VAR> does not exist.  If it does,
an exception of type <CODE>FILE-ALREADY-EXISTS-EXCEPTION</CODE> is thrown
with <VAR>context</VAR> supplying context for the error message.
</DL>
</P><P>

<A NAME="IDX705"></A>
<DL>
<DT><U>Function:</U> <B>ensure-file-exists</B> <I>((filename STRING) (context STRING)) :</I>
<DD>Ensures that <VAR>filename</VAR> exists.  If not, an exception of
type <CODE>NO-SUCH-FILE-EXCEPTION</CODE> is thrown with <VAR>context</VAR> supplying
context for the error message.
</DL>
</P><P>

<A NAME="IDX706"></A>
<DL>
<DT><U>Function:</U> <B>eql-except-in-whitespace?</B> <I>((s1 STRING) (s2 STRING)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if the strings <VAR>s1</VAR> and <VAR>s2</VAR> are the same
except for the amounts of whitespace separating words.  Leading or
trailing whitespace is also not considered.
</DL>
</P><P>

<A NAME="IDX707"></A>
<DL>
<DT><U>Macro:</U> <B>error</B> <I>(&#38;body (body CONS)) : OBJECT</I>
<DD>Signal error message, placing non-string arguments in quotes.
</DL>
</P><P>

<A NAME="IDX708"></A>
<DL>
<DT><U>Function:</U> <B>evaluate</B> <I>((expression OBJECT)) : OBJECT</I>
<DD>Evaluate the expression <VAR>expression</VAR> and return the result.
Currently, only the evaluation of (possibly nested) commands and global
variables is supported.  The second return value indicates the actual type 
of the result (which might have been wrapped), and the third return value
indicates whether an error occurred during the evaluation.  Expressions
are simple to program in Common Lisp, since they are built into the language,
and relatively awkward in Java and C++.  Users of either of those 
languages are more likely to want to call <CODE>evaluate-string</CODE>.
</DL>
</P><P>

<A NAME="IDX709"></A>
<DL>
<DT><U>Function:</U> <B>evaluate-string</B> <I>((expression STRING)) : OBJECT</I>
<DD>Evaluate the expression represented by <VAR>expression</VAR> and return the result.
This is equivalent to <CODE>(evaluate (unstringify expression))</CODE>.
</DL>
</P><P>

<A NAME="IDX710"></A>
<DL>
<DT><U>Function:</U> <B>exception-message</B> <I>((e NATIVE-EXCEPTION)) : STRING</I>
<DD>Accesses the error message of the exception <VAR>e</VAR>.
</DL>
</P><P>

<A NAME="IDX711"></A>
<DL>
<DT><U>Method:</U> CLASS <B>extension</B> <I>(self) : CLASS-EXTENSION</I>
<DD>Return the nearest class extension that records instances
of the class <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX712"></A>
<DL>
<DT><U>Function:</U> <B>external-id-head?</B> <I>((attribute OBJECT)) : BOOLEAN</I>
<DD>Checks to see if this <VAR>attribute</VAR> is the literal marking either
a PUBLIC or SYSTEM literal for an XML Elternal ID.  (See 4.2.2)
</DL>
</P><P>

<A NAME="IDX713"></A>
<DL>
<DT><U>Function:</U> <B>fill-in-date-substitution</B> <I>((substitution-list (KEY-VALUE-LIST OF STRING-WRAPPER STRING-WRAPPER))) :</I>
<DD>Fill in <VAR>substitution-list</VAR> with template variable substitions
for the names YEAR and DATE which correspond to the current year and date.
These substitutions can then be used with <CODE>substitute-template-variables-in-string</CODE>
</DL>
</P><P>

<A NAME="IDX714"></A>
<DL>
<DT><U>Function:</U> <B>finalize-classes</B> <I>() :</I>
<DD>Finalize all currently unfinalized classes.
</DL>
</P><P>

<A NAME="IDX715"></A>
<DL>
<DT><U>Function:</U> <B>finalize-classes-and-slots</B> <I>() :</I>
<DD>Finalize all currently unfinalized classes and slots.
</DL>
</P><P>

<A NAME="IDX716"></A>
<DL>
<DT><U>Function:</U> <B>finalize-slots</B> <I>() :</I>
<DD>Finalize all currently unfinalized slots.
</DL>
</P><P>

<A NAME="IDX717"></A>
<DL>
<DT><U>Function:</U> <B>find-matching-prefix-length</B> <I>((string1 STRING) (start1 INTEGER) (end1 INTEGER) (string2 STRING) (start2 INTEGER) (end2 INTEGER)) : INTEGER</I>
<DD>Finds the length of the matching prefix strings of <VAR>string1</VAR> and
<VAR>string2</VAR>, starting at position <VAR>start1</VAR> and <VAR>start2</VAR> respectively.
The search will end when <VAR>end1</VAR> or <VAR>end2</VAR> is reached.  If either <VAR>end1</VAR>
or <VAR>end2</VAR> is null, then they will be set to the length of their respective
strings.
</DL>
</P><P>

<A NAME="IDX718"></A>
<DL>
<DT><U>Function:</U> <B>find-mismatch</B> <I>((string1 STRING) (start1 INTEGER) (end1 INTEGER) (string2 STRING) (start2 INTEGER) (end2 INTEGER)) : INTEGER INTEGER</I>
<DD>Finds the first position in each of <VAR>string1</VAR> and <VAR>string2</VAR> where
they mismatch, starting at position <VAR>start1</VAR> and <VAR>start2</VAR> respectively.
The search will end when <VAR>end1</VAR> or <VAR>end2</VAR> is reached.  If either <VAR>end1</VAR>
or <VAR>end2</VAR> is null, then they will be set to the length of their respective
strings.  If there is no mismatch, then <CODE>null</CODE> values are returned.
</DL>
</P><P>

<A NAME="IDX719"></A>
<DL>
<DT><U>Macro:</U> <B>first-defined</B> <I>(&#38;body (forms CONS)) : OBJECT</I>
<DD>Return the result of the first form in <VAR>forms</VAR> whose value is defined
or NULL otherwise.
</DL>
</P><P>

<A NAME="IDX720"></A>
<DL>
<DT><U>Function:</U> <B>float-to-base60</B> <I>((x FLOAT) (all-integers? BOOLEAN)) : (CONS OF NUMBER-WRAPPER)</I>
<DD>Returns a cons of <VAR>x</VAR> in a base-60 form.  That means
the first value will be the integer part of <VAR>x</VAR>, the next value
the iteger value of the fraction part of <VAR>x</VAR> times 60 and the
third value the fraction part of <VAR>x</VAR> time 3600.  If <VAR>all-integers?</VAR>
is <CODE>true</CODE>, then the last value will be rounded to an integer.
This can be used to convert from decimal degree values to Degree-Minute-Second
or from decimal hours to Hour-Minute-Second format.
</DL>
</P><P>

<A NAME="IDX721"></A>
<DL>
<DT><U>Function:</U> <B>fmod</B> <I>((x FLOAT) (modulus FLOAT)) : FLOAT</I>
<DD>True modulus for floats.  Return the result of <VAR>x</VAR> mod <CODE>modulo</CODE>.
Note: In C++ and Java, <CODE>mod</CODE> has more overhead than the similar
function <CODE>rem</CODE>.  The  answers returned by <CODE>mod</CODE> and <CODE>rem</CODE> are only
different when the signs of <VAR>x</VAR> and <CODE>modulo</CODE> are different.
</DL>
</P><P>

<A NAME="IDX722"></A>
<DL>
<DT><U>Function:</U> <B>format-with-padding</B> <I>((input STRING) (length INTEGER) (padchar CHARACTER) (align KEYWORD) (truncate? BOOLEAN)) : STRING</I>
<DD>Formats <VAR>input</VAR> to be (at least) <VAR>length</VAR> long, using <VAR>padchar</VAR> to
fill if necessary.  <VAR>align</VAR> must be one of :LEFT, :RIGHT, :CENTER and will control
how <VAR>input</VAR> will be justified in the resulting string.  If <VAR>truncate?</VAR> is true, then
then an overlength string will be truncated, using the opposite of <VAR>align</VAR> to pick
the truncation direction.
</DL>
</P><P>

<A NAME="IDX723"></A>
<DL>
<DT><U>Method:</U> ACTIVE-OBJECT <B>free</B> <I>(self) :</I>
<DD>Remove all pointers between <VAR>self</VAR> and other objects,
and then deallocate the storage for self.
</DL>
</P><P>

<A NAME="IDX724"></A>
<DL>
<DT><U>Method:</U> OBJECT <B>free</B> <I>(self) :</I>
<DD>Default method.  Deallocate storage for <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX725"></A>
<DL>
<DT><U>Method:</U> ABSTRACT-HASH-TABLE <B>free-hash-table-values</B> <I>(self) :</I>
<DD>Call free on each value in the hash table <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX726"></A>
<DL>
<DT><U>Function:</U> <B>frem</B> <I>((x FLOAT) (y FLOAT)) : FLOAT</I>
<DD>Return the floating point remainder from dividing <VAR>x</VAR> by <VAR>y</VAR>.  The
sign of the result is always the same as the sign of <VAR>x</VAR>.  This has slightly
different behavior than the <CODE>mod</CODE> function, and has less overhead in C++ and
Java, which don't have direct support for a true modulus function.
</DL>
</P><P>

<A NAME="IDX727"></A>
<DL>
<DT><U>Function:</U> <B>generate-random-uuid</B> <I>() : STRING</I>
<DD>Generates a random UUID (Type 4), according to the guidelines
of IETF RFC 4122 (see http://www.ietf.org/rfc/rfc4122.txt )
</P><P>

Take 16 random bytes (octets), put them all behind each other, for the description
the numbering starts with byte 1 (most significant, first) to byte 16 
   (least significant, last). Then put in the version and variant.
To put in the version, take the 7th byte and perform an and operation using 0x0f,
   followed by an or operation with 0x40. 
To put in the variant, take the 9th byte and perform an and operation using 0x3f,
   followed by an or operation with 0x80.
To make the string representation, take the hexadecimal presentation of bytes 1-4
   (without 0x in front of it) let them follow by a -, then take bytes 5 and 6, - 
bytes 7 and 8, - bytes 9 and 10, - then followed by bytes 11-16.
</DL>
</P><P>

<A NAME="IDX728"></A>
<DL>
<DT><U>Function:</U> <B>generate-uuid</B> <I>((uuid-type KEYWORD)) : STRING</I>
<DD>Generates a UUID of the specified type.  Legal types are
a subset of the IETF RFC 4122 (see http://www.ietf.org/rfc/rfc4122.txt )
UUID types.  Currently supported are:
    :TYPE-4  :RANDOM       A type-4 (random) UUID.  These are synonyms.
</DL>
</P><P>

<A NAME="IDX729"></A>
<DL>
<DT><U>Method:</U> CALENDAR-DATE <B>get-calendar-date</B> <I>(date (timezone FLOAT)) : INTEGER INTEGER INTEGER KEYWORD</I>
<DD>Returns multiple values of year, month, day and day of week for <VAR>date</VAR>
in <VAR>timezone</VAR>.  <VAR>timezone</VAR> is the number of hours added to UTC to get local time.  It
is in the range -12.0 to +14.0 where UTC is zone 0.0
</DL>
</P><P>

<A NAME="IDX730"></A>
<DL>
<DT><U>Function:</U> <B>get-global-value</B> <I>((self SURROGATE)) : OBJECT</I>
<DD>Return the (possibly-wrapped) value of the global
variable for the surrogate <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX731"></A>
<DL>
<DT><U>Function:</U> <B>get-local-standard-time-zone</B> <I>() : FLOAT</I>
<DD>Returns the standard time zone offset from UTC as a float,
without considering the effects of daylight savings time.
</DL>
</P><P>

<A NAME="IDX732"></A>
<DL>
<DT><U>Function:</U> <B>get-local-time-zone-for-date</B> <I>((year INTEGER) (month INTEGER) (day INTEGER) (hour INTEGER) (minute INTEGER) (second INTEGER)) : FLOAT</I>
<DD>Returns the time zone offset from UTC (as a float)
that is applicable to the given date.  Assumes that the date is one
that is valid for the underlying programming language.  If not, then
returns 0.0
</DL>
</P><P>

<A NAME="IDX733"></A>
<DL>
<DT><U>Function:</U> <B>get-quoted-tree</B> <I>((tree-name STRING) (modulename STRING)) : CONS</I>
<DD>Return the quoted tree with name <VAR>tree-name</VAR>.
</DL>
</P><P>

<A NAME="IDX734"></A>
<DL>
<DT><U>Function:</U> <B>get-slot</B> <I>((self STANDARD-OBJECT) (slot-name SYMBOL)) : SLOT</I>
<DD>Return the slot named <VAR>slot-name</VAR> on the class
representing the type of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX735"></A>
<DL>
<DT><U>Method:</U> SURROGATE <B>get-stella-class</B> <I>(class-name (error? BOOLEAN)) : CLASS</I>
<DD>Return a class with name <VAR>class-name</VAR>.  If none exists, break
if <VAR>error?</VAR>, else return <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX736"></A>
<DL>
<DT><U>Method:</U> SYMBOL <B>get-stella-class</B> <I>(class-name (error? BOOLEAN)) : CLASS</I>
<DD>Return a class with name <VAR>class-name</VAR>.  If non exists, break
if <VAR>error?</VAR>, else return <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX737"></A>
<DL>
<DT><U>Method:</U> STRING <B>get-stella-class</B> <I>(class-name (error? BOOLEAN)) : CLASS</I>
<DD>Return a class with name <VAR>class-name</VAR>.  If none exists, break
if <VAR>error?</VAR>, else return <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX738"></A>
<DL>
<DT><U>Method:</U> CALENDAR-DATE <B>get-time</B> <I>(date (timezone FLOAT)) : INTEGER INTEGER INTEGER INTEGER</I>
<DD>Returns multiple values of hours, minutes, seconds, milliseconds for
the calendar date <VAR>date</VAR> in <VAR>timezone</VAR>.  <VAR>timezone</VAR> is the number of hours added to UTC
to get local time.  It is in the range -12.0 to +14.0 where UTC is zone 0.0
</DL>
</P><P>

<A NAME="IDX739"></A>
<DL>
<DT><U>Function:</U> <B>global-variable-type-spec</B> <I>((global GLOBAL-VARIABLE)) : TYPE-SPEC</I>
<DD>Return the type spec for the global variable <VAR>global</VAR>.
</DL>
</P><P>

<A NAME="IDX740"></A>
<DL>
<DT><U>Function:</U> <B>hash-string</B> <I>((string STRING) (seedCode INTEGER)) : INTEGER</I>
<DD>Generate a hash-code for <VAR>string</VAR> and return it.
Two strings that are equal but not eq will generate the same code.
The hash-code is based on <VAR>seedCode</VAR> which usually will be 0.  However,
<VAR>seedCode</VAR> can also be used to supply the result of a previous hash
operation to achieve hashing on sequences of strings without actually
having to concatenate them.
</DL>
</P><P>

<A NAME="IDX741"></A>
<DL>
<DT><U>Function:</U> <B>help-advance-past-whitespace</B> <I>((source STRING) (start INTEGER) (end INTEGER)) : INTEGER</I>
<DD>Helper for <CODE>advance-past-whitespace</CODE> that requires <VAR>end</VAR> to be properly set.
</DL>
</P><P>

<A NAME="IDX742"></A>
<DL>
<DT><U>Function:</U> <B>help-find-matching-prefix-length</B> <I>((string1 STRING) (start1 INTEGER) (end1 INTEGER) (string2 STRING) (start2 INTEGER) (end2 INTEGER)) : INTEGER</I>
<DD>Helping function for <CODE>find-matching-prefix</CODE> that requires <VAR>end1</VAR> and <VAR>end2</VAR>
to be properly set up.
</DL>
</P><P>

<A NAME="IDX743"></A>
<DL>
<DT><U>Function:</U> <B>help-get-stella-module</B> <I>((pathName STRING) (error? BOOLEAN)) : MODULE</I>
<DD>Return the module located at <VAR>pathName</VAR>, or <CODE>null</CODE>
if no such module exists.  The search looks at ancestors and top-most
 (cardinal) modules.  If <VAR>error?</VAR> is <CODE>true</CODE>, throw an exception if no
 module is found.
</DL>
</P><P>

<A NAME="IDX744"></A>
<DL>
<DT><U>Method:</U> CLASS <B>help-print-outline</B> <I>(top (stream OUTPUT-STREAM) (current-depth INTEGER) (depth INTEGER) (named? BOOLEAN)) :</I>
<DD>Helper method for <CODE>print-outline</CODE>
</DL>
</P><P>

<A NAME="IDX745"></A>
<DL>
<DT><U>Method:</U> MODULE <B>help-print-outline</B> <I>(top (stream OUTPUT-STREAM) (current-depth INTEGER) (depth INTEGER) (named? BOOLEAN)) :</I>
<DD>Helper method for <CODE>print-outline</CODE>
</DL>
</P><P>

<A NAME="IDX746"></A>
<DL>
<DT><U>Method:</U> OBJECT <B>help-print-outline</B> <I>(top (stream OUTPUT-STREAM) (current-depth INTEGER) (depth INTEGER) (named? BOOLEAN)) :</I>
<DD>Helper method for <CODE>print-outline</CODE>
</DL>
</P><P>

<A NAME="IDX747"></A>
<DL>
<DT><U>Method:</U> SLOT <B>help-print-outline</B> <I>(top (stream OUTPUT-STREAM) (current-depth INTEGER) (depth INTEGER) (named? BOOLEAN)) :</I>
<DD>Helper method for <CODE>print-outline</CODE>
</DL>
</P><P>

<A NAME="IDX748"></A>
<DL>
<DT><U>Method:</U> CONTEXT <B>help-print-outline</B> <I>(top (stream OUTPUT-STREAM) (current-depth INTEGER) (depth INTEGER) (named? BOOLEAN)) :</I>
<DD>Helper method for <CODE>print-outline</CODE>
</DL>
</P><P>

<A NAME="IDX749"></A>
<DL>
<DT><U>Method:</U> OBJECT <B>home-module</B> <I>(self) : MODULE</I>
<DD>Return the home module of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX750"></A>
<DL>
<DT><U>Macro:</U> <B>if-output-language</B> <I>((language KEYWORD) (thenForm OBJECT) (elseForm OBJECT)) : OBJECT</I>
<DD>Expand to <VAR>thenForm</VAR> if the current translator output
language equals <VAR>language</VAR>.  Otherwise, expand to <VAR>elseForm</VAR>.  This can
be used to conditionally translate Stella code.
</DL>
</P><P>

<A NAME="IDX751"></A>
<DL>
<DT><U>Macro:</U> <B>if-stella-feature</B> <I>((feature KEYWORD) (thenForm OBJECT) (elseForm OBJECT)) : OBJECT</I>
<DD>Expand to <VAR>thenForm</VAR> if <VAR>feature</VAR> is a currently enabled
STELLA environment feature.  Otherwise, expand to <VAR>elseForm</VAR>.  This can
be used to conditionally translate Stella code.
</DL>
</P><P>

<A NAME="IDX752"></A>
<DL>
<DT><U>Macro:</U> <B>ignore</B> <I>(&#38;body (variables CONS)) : OBJECT</I>
<DD>Ignore unused <VAR>variables</VAR> with NoOp <CODE>setq</CODE> statements.
</DL>
</P><P>

<A NAME="IDX753"></A>
<DL>
<DT><U>Function:</U> <B>incrementally-translate</B> <I>((tree OBJECT)) : OBJECT</I>
<DD>Translate a single Stella expression <VAR>tree</VAR> and return
the result.  For C++ and Java print the translation to standard output and
return NIL instead.
</DL>
</P><P>

<A NAME="IDX754"></A>
<DL>
<DT><U>Function:</U> <B>indent-outline</B> <I>((current-depth INTEGER) (stream OUTPUT-STREAM)) :</I>
<DD>Helper function that indents outline printings for level
<VAR>current-depth</VAR> on <VAR>stream</VAR> using the value of the global
variable <CODE>*OUTLINE-INDENT-STRING*</CODE>
</DL>
</P><P>

<A NAME="IDX755"></A>
<DL>
<DT><U>Macro:</U> <B>inform</B> <I>(&#38;body (body CONS)) : OBJECT</I>
<DD>Print informative message, placing non-string arguments in quotes,
and terminating with a newline.
</DL>
</P><P>

<A NAME="IDX756"></A>
<DL>
<DT><U>Method:</U> CLASS <B>initial-value</B> <I>(self) : OBJECT</I>
<DD>Return an initial value for the class <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX757"></A>
<DL>
<DT><U>Method:</U> STORAGE-SLOT <B>initial-value</B> <I>(self) : OBJECT</I>
<DD>Return an initial value for <VAR>self</VAR>, or <CODE>null</CODE>.  The
initial value can be defined by the slot itself, inherited from an
equivalent slot, or inherit from the :initial-value option for the 
class representing the type of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX758"></A>
<DL>
<DT><U>Method:</U> STELLA-HASH-TABLE <B>initialize-hash-table</B> <I>(self) :</I>
<DD>Initialize the STELLA hash table <VAR>self</VAR>.  This is a
no-op and primarily exists to shadow the standard initializer inherited
from ABSTRACT-HASH-TABLE.  STELLA hash tables are initialized at the
first insertion operation.
</DL>
</P><P>

<A NAME="IDX759"></A>
<DL>
<DT><U>Method:</U> STORAGE-SLOT <B>initially</B> <I>(self) : OBJECT</I>
<DD>Defines the value of a slot before it has been assigned
a value.
</DL>
</P><P>

<A NAME="IDX760"></A>
<DL>
<DT><U>Function:</U> <B>integer-to-hex-string</B> <I>((i INTEGER)) : STRING</I>
<DD>Convert <VAR>i</VAR> to a string representation in hexadecimal notation and return the result.
</DL>
</P><P>

<A NAME="IDX761"></A>
<DL>
<DT><U>Function:</U> <B>integer-to-string-in-base</B> <I>((i INTEGER) (base INTEGER)) : STRING</I>
<DD>Convert <VAR>i</VAR> to a string representation in <VAR>base</VAR> and return the
result.  <VAR>base</VAR> must be positive and not more than 36.
</P><P>

Note that in the C++ version, only 8, 10 and 16 will work as <VAR>base</VAR> arguments,
since that is all the underlying implementation supports.  Other argument
values will be treated as <CODE>10</CODE>.
</DL>
</P><P>

<A NAME="IDX762"></A>
<DL>
<DT><U>Function:</U> <B>integer-valued?</B> <I>((x FLOAT)) : BOOLEAN</I>
<DD>Returns <CODE>true</CODE> if <VAR>x</VAR> is the floating point representation of an integer.
</DL>
</P><P>

<A NAME="IDX763"></A>
<DL>
<DT><U>Function:</U> <B>intern-stella-name</B> <I>((name STRING)) : GENERALIZED-SYMBOL</I>
<DD>Parse <VAR>name</VAR> which is assumed to be the printed
representation of a STELLA symbol, surrogate or keyword, intern
it into the current or specified module and return the result.
This is identical to calling <CODE>unstringify</CODE> on <VAR>name</VAR> but 10-15
times faster.
</DL>
</P><P>

<A NAME="IDX764"></A>
<DL>
<DT><U>Function:</U> <B>interpret-command-line-arguments</B> <I>((count INTEGER) (arguments (ARRAY () OF STRING))) :</I>
<DD>Interpret any STELLA-relevant command line <VAR>arguments</VAR>.
</DL>
</P><P>

<A NAME="IDX765"></A>
<DL>
<DT><U>Function:</U> <B>isa?</B> <I>((object OBJECT) (type TYPE)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> iff <VAR>object</VAR> is an instance of the class named <VAR>type</VAR>.
</DL>
</P><P>

<A NAME="IDX766"></A>
<DL>
<DT><U>Function:</U> <B>java-translate-system</B> <I>((systemName STRING)) :</I>
<DD>Translate the system <VAR>systemName</VAR> to Java.
</DL>
</P><P>

<A NAME="IDX767"></A>
<DL>
<DT><U>N-Command:</U> <B>jptrans</B> <I>((statement OBJECT)) :</I>
<DD>Translate <VAR>statement</VAR> to C++ and print the result.
</DL>
</P><P>

<A NAME="IDX768"></A>
<DL>
<DT><U>Function:</U> <B>keyword-name?</B> <I>((name STRING)) : BOOLEAN</I>
<DD>Return TRUE if name is prefixed by <CODE>:</CODE>.
</DL>
</P><P>

<A NAME="IDX769"></A>
<DL>
<DT><U>Function:</U> <B>kvlist-to-plist</B> <I>((self KEY-VALUE-LIST)) : (PROPERTY-LIST OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))</I>
<DD>Convert <VAR>self</VAR> into a property list with identical and identically
ordered keys and values.
</DL>
</P><P>

<A NAME="IDX770"></A>
<DL>
<DT><U>Method:</U> CONS-ITERATOR <B>length</B> <I>(self) : INTEGER</I>
<DD>Iterate over <VAR>self</VAR>, and count how many items there are.
</DL>
</P><P>

<A NAME="IDX771"></A>
<DL>
<DT><U>Function:</U> <B>lispify</B> <I>((thing UNKNOWN)) : LISP-CODE</I>
<DD>Convert a Stella <VAR>thing</VAR> as much as possible into a
Common-Lisp analogue.  The currently supported <VAR>thing</VAR> types are CONS, LIST,
KEY-VALUE-LIST, ITERATOR, SYMBOL, KEYWORD, and all wrapped and unwrapped
literal types.  BOOLEANs are translated into Lisp's CL:T and CL:NIL logic.
Unsupported types are left unchanged.
</DL>
</P><P>

<A NAME="IDX772"></A>
<DL>
<DT><U>Function:</U> <B>lispify-boolean</B> <I>((thing UNKNOWN)) : LISP-CODE</I>
<DD>Lispify <VAR>thing</VAR> which is assumed to be a (possibly wrapped) 
Stella boolean.
</DL>
</P><P>

<A NAME="IDX773"></A>
<DL>
<DT><U>Command:</U> <B>list-modules</B> <I>((kb-only? BOOLEAN)) : (CONS OF MODULE)</I>
<DD>Returns a cons of all modules defined in PowerLoom.  If <VAR>kb-only?</VAR>
is <CODE>true</CODE>, then any modules which are code only or just namespaces are not returned.
</DL>
</P><P>

<A NAME="IDX774"></A>
<DL>
<DT><U>Method:</U> CONS <B>listify</B> <I>(self) : (LIST OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return a list of elements in <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX775"></A>
<DL>
<DT><U>Method:</U> LIST <B>listify</B> <I>(self) : (LIST OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX776"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-LIST <B>listify</B> <I>(self) : (LIST OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return a list of key-value pairs in <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX777"></A>
<DL>
<DT><U>Method:</U> VECTOR <B>listify</B> <I>(self) : (LIST OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return a list of elements in <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX778"></A>
<DL>
<DT><U>Method:</U> ITERATOR <B>listify</B> <I>(self) : (LIST OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return a list of elements generated by <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX779"></A>
<DL>
<DT><U>Function:</U> <B>load-configuration-file</B> <I>((file FILE-NAME)) : CONFIGURATION-TABLE</I>
<DD>Read a configuration <VAR>file</VAR> and return its content as a configuration table.
Also enter each property read into the global system configuration table.
Assumes Java-style property file syntax.  Each property name is represented
as a wrapped string and each value as a wrapped string/integer/float or boolean.
</DL>
</P><P>

<A NAME="IDX780"></A>
<DL>
<DT><U>Command:</U> <B>load-file</B> <I>((file STRING)) :</I>
<DD>Read STELLA commands from <VAR>file</VAR> and evaluate them.
The file should begin with an <CODE>in-module</CODE> declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
<CODE>evaluate</CODE> to each of them.
</DL>
</P><P>

<A NAME="IDX781"></A>
<DL>
<DT><U>Function:</U> <B>load-system</B> <I>((systemName STRING) (language KEYWORD) &#38;rest (options OBJECT)) : BOOLEAN</I>
<DD>Natively <VAR>language</VAR>-compile out-of-date translated files of system
<VAR>systemName</VAR> and then load them into the running system (this is only
supported/possible for Lisp at the moment).  Return true if at least one
file was compiled. The following keyword/value <VAR>options</VAR> are recognized:
</P><P>

<CODE>:force-recompilation?</CODE> (default false): if true, files will be compiled
whether or not their compilations are up-to-date.
</P><P>

<CODE>:startup?</CODE> (default true): if true, the system startup function will
be called once all files have been loaded.
</DL>
</P><P>

<A NAME="IDX782"></A>
<DL>
<DT><U>Function:</U> <B>log-level&#60;=</B> <I>((level OBJECT) (module STRING)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>level</VAR> is lower than or equal to the current
log level of <VAR>module</VAR>.  Return FALSE if any of them are undefined.
</DL>
</P><P>

<A NAME="IDX783"></A>
<DL>
<DT><U>Function:</U> <B>log-message</B> <I>((module STRING) (logLevel OBJECT) (message CONS)) :</I>
<DD>Log all elements of <VAR>message</VAR> to <VAR>module</VAR>s log stream if
<VAR>logLevel</VAR> is the same or lower than the <VAR>module</VAR>s log level.  Interprets <CODE>EOL</CODE>
or :EOL to print a line terminator.
</DL>
</P><P>

<A NAME="IDX784"></A>
<DL>
<DT><U>Function:</U> <B>logmsg</B> <I>((module STRING) (logLevel OBJECT) &#38;rest (message OBJECT)) :</I>
<DD>Log all elements of <VAR>message</VAR> to <VAR>module</VAR>s log stream if
<VAR>logLevel</VAR> is the same or lower than the <VAR>module</VAR>s log level.  Interprets <CODE>EOL</CODE>
or :EOL to print a line terminator.
</DL>
</P><P>

<A NAME="IDX785"></A>
<DL>
<DT><U>Method:</U> SYMBOL <B>lookup-class</B> <I>(name) : CLASS</I>
<DD>Return a class with name <VAR>name</VAR>.  Scan all
visible surrogates looking for one that has a class defined for it.
</DL>
</P><P>

<A NAME="IDX786"></A>
<DL>
<DT><U>Method:</U> STRING <B>lookup-class</B> <I>(name) : CLASS</I>
<DD>Return a class with name <VAR>name</VAR>.  Scan all
visible surrogates looking for one that has a class defined for it.
</DL>
</P><P>

<A NAME="IDX787"></A>
<DL>
<DT><U>Function:</U> <B>lookup-command</B> <I>((name SYMBOL)) : METHOD-SLOT</I>
<DD>If <VAR>name</VAR> names an evaluable command return its associated
command object;  otherwise, return <CODE>null</CODE>.  Currently, commands are not
polymorphic, i.e., they can only be implemented by functions.
</DL>
</P><P>

<A NAME="IDX788"></A>
<DL>
<DT><U>Function:</U> <B>lookup-configuration-property</B> <I>((property STRING) (defaultValue WRAPPER) (configuration CONFIGURATION-TABLE)) : OBJECT</I>
<DD>Lookup <VAR>property</VAR> in <VAR>configuration</VAR> and return its value.
Use the global system configuration table if <VAR>configuration</VAR> is NULL.  Return
<VAR>defaultValue</VAR> if <VAR>property</VAR> is not defined.
</DL>
</P><P>

<A NAME="IDX789"></A>
<DL>
<DT><U>Function:</U> <B>lookup-configuration-property-values</B> <I>((property STRING) (defaultValue OBJECT) (configuration CONFIGURATION-TABLE)) : CONS</I>
<DD>Lookup <VAR>property</VAR> in <VAR>configuration</VAR>, assume it is a multi-valued
property and return its value(s) as a list.  Use the global system configuration table
if <VAR>configuration</VAR> is NULL.  Return <VAR>defaultValue</VAR> if <VAR>property</VAR> is not defined or
NIL is no default value is specified.
</DL>
</P><P>

<A NAME="IDX790"></A>
<DL>
<DT><U>Function:</U> <B>lookup-demon</B> <I>((name STRING)) : DEMON</I>
<DD>Return the demon named <VAR>name</VAR>.
</DL>
</P><P>

<A NAME="IDX791"></A>
<DL>
<DT><U>Function:</U> <B>lookup-function</B> <I>((functionSymbol SYMBOL)) : FUNCTION</I>
<DD>Return the function defined for <VAR>functionSymbol</VAR>, if it exists.
</DL>
</P><P>

<A NAME="IDX792"></A>
<DL>
<DT><U>Function:</U> <B>lookup-function-by-name</B> <I>((name STRING)) : FUNCTION</I>
<DD>Return a function with name <VAR>name</VAR> visible from the current module.
Scan all visible symbols looking for one that has a function defined for it.
</DL>
</P><P>

<A NAME="IDX793"></A>
<DL>
<DT><U>Method:</U> SURROGATE <B>lookup-global-variable</B> <I>(self) : GLOBAL-VARIABLE</I>
<DD>Return a global variable with name <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX794"></A>
<DL>
<DT><U>Method:</U> GENERALIZED-SYMBOL <B>lookup-global-variable</B> <I>(self) : GLOBAL-VARIABLE</I>
<DD>Return a global variable with name <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX795"></A>
<DL>
<DT><U>Method:</U> STRING <B>lookup-global-variable</B> <I>(self) : GLOBAL-VARIABLE</I>
<DD>Return a global variable with name <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX796"></A>
<DL>
<DT><U>Function:</U> <B>lookup-local-slot</B> <I>((class CLASS) (slot-name SYMBOL)) : SLOT</I>
<DD>Lookup a local slot with <VAR>slot-name</VAR> on <VAR>class</VAR>.
</DL>
</P><P>

<A NAME="IDX797"></A>
<DL>
<DT><U>Function:</U> <B>lookup-logging-parameter</B> <I>((module STRING) (parameter KEYWORD) (default OBJECT)) : OBJECT</I>
<DD>Lookup logging <VAR>parameter</VAR> for <VAR>module</VAR>.  Use <VAR>default</VAR> if no
value is defined.
</DL>
</P><P>

<A NAME="IDX798"></A>
<DL>
<DT><U>Function:</U> <B>lookup-macro</B> <I>((name SYMBOL)) : METHOD-SLOT</I>
<DD>If <VAR>name</VAR> has a macro definition, return the method object
holding its expander function.
</DL>
</P><P>

<A NAME="IDX799"></A>
<DL>
<DT><U>Function:</U> <B>lookup-slot</B> <I>((class CLASS) (slot-name SYMBOL)) : SLOT</I>
<DD>Return a slot owned by the class <VAR>class</VAR> with name <VAR>slot-name</VAR>.
Multiply inherited slots are disambiguated by a left-to-right class
precedence order for classes with multiple parents (similar to CLOS).
</DL>
</P><P>

<A NAME="IDX800"></A>
<DL>
<DT><U>Method:</U> PROPERTY-LIST <B>lookup-with-default</B> <I>(self (key (LIKE (ANY-KEY SELF))) (default (LIKE (ANY-VALUE SELF)))) : (LIKE (ANY-VALUE SELF))</I>
<DD>Lookup <VAR>key</VAR> in <VAR>self</VAR> and return the result.
Return <VAR>default</VAR> if no value was found.
</DL>
</P><P>

<A NAME="IDX801"></A>
<DL>
<DT><U>Method:</U> KEY-VALUE-LIST <B>lookup-with-default</B> <I>(self (key (LIKE (ANY-KEY SELF))) (default (LIKE (ANY-VALUE SELF)))) : (LIKE (ANY-VALUE SELF))</I>
<DD>Lookup <VAR>key</VAR> in <VAR>self</VAR> and return the result.
Return <VAR>default</VAR> if no value was found.
</DL>
</P><P>

<A NAME="IDX802"></A>
<DL>
<DT><U>N-Command:</U> <B>lptrans</B> <I>((statement OBJECT)) :</I>
<DD>Translate <VAR>statement</VAR> to Common-Lisp and print the result.
</DL>
</P><P>

<A NAME="IDX803"></A>
<DL>
<DT><U>Function:</U> <B>make-matching-name</B> <I>((original STRING) &#38;rest (options OBJECT)) : STRING</I>
<DD>Keyword options:
  :break-on-cap    one of  :YES :NO :CLEVER         default is :CLEVER
  :break-on-number one of  :YES :NO :CLEVER         default is :CLEVER
  :break-on-separators string                       default is "-_ "
  :remove-prefix   string
  :remove-suffix   string
  
  :case            one of  :UPCASE :TitleCase :titleCaseX :downcase :Capitalize :preserve
                                                     default is :TitleCase
  :separator       string                            default is ""
  :add-prefix      string
  :add-suffix      string
</P><P>

  MAKE-MATCHING-NAME returns a matching name (a string) for the input name (a string).
A matching name is constructed by breaking the input into <CODE>words</CODE> and then applying
appropriate transforms.  The arguments are used as follows:
  <VAR>original</VAR>         is the input name.  It is a string.
  :break-on-cap    is a keyword controlling whether changes in capitalization is used
                   to indicate word boundaries.  If :YES, then all capitalization
                   changes delineate words.  If :CLEVER, then unbroken runs of
                   capitalized letters are treated as acronyms and remain grouped.
                   If :NO or NULL, there is no breaking of words based on capitalization.
  :break-on-number is a flag controlling whether encountering a number indicates
                   a word boundary.  If :YES, then each run of numbers is treated as
		   a word separate from surrounding words.  If :CLEVER, then an 
		   attempt is made to recognize ordinal numbers (ie, 101st) and
		   treat them as separate words.  If :NO or NULL, there is no breaking
                   of words when numbers are encountered.
  :break-on-separators   A string of characters which constitute word delimiters in
                         the input word.  This is used to determine how to break
                   the name into individual words.  Defaults are space, <CODE>-</CODE> and <CODE>_</CODE>.
  :remove-prefix   Specifies a prefix or suffix that is stripped from the input
  :remove-suffix   name before any other processing.  This allows the removal of
                   any naming convention dictated prefixes or suffixes.
  :add-prefix      Specifies a prefix or suffix that is added to the output name
  :add-suffix      after all other processing.  This allows the addition of any
                   naming convention dictated prefixes or suffixes.
  :case            The case of the resulting name.  This is applied to the name 
                   before adding prefixes or suffixes.  The two title case options 
                   differ only in how the first word of the name is treated.
                   :TitleCase capitalizes the first letter of the first word and
                       also the first letter of all other words.
                   :TitleCaseX does not capitalizes the first letter of the first
		       word but capitalizes the first letter of all subsequent words.
		   :preserve results in no change in case.
  :separator       This is a string specifying the word separator to use in the
                   returned name.  An empty string (the default) means that the
                   resulting words are concatenated without any separation.  This
                   normally only makes sense when using one of the title case values
                   for the case keyword.
</DL>
</P><P>

<A NAME="IDX804"></A>
<DL>
<DT><U>Function:</U> <B>make-matching-name-full</B> <I>((originalname STRING) (breakoncap KEYWORD) (breakonnumber KEYWORD) (breakonseparators STRING) (removeprefix STRING) (removesuffix STRING) (addprefix STRING) (addsuffix STRING) (outputcase KEYWORD) (outputseparator STRING)) : STRING</I>
<DD>Non-keyword version of <CODE>make-matching-name</CODE>, which will probably be
easier to use when called from non-Lisp languages.
</DL>
</P><P>

<A NAME="IDX805"></A>
<DL>
<DT><U>Command:</U> <B>make-system</B> <I>((systemName STRING) (language KEYWORD) &#38;rest (options OBJECT)) : BOOLEAN</I>
<DD>Translate all out-of-date files of system <VAR>systemName</VAR>
into <VAR>language</VAR> and then compile and load them (the latter is only possible
for Lisp right now).  The following keyword/value <VAR>options</VAR> are recognized:
</P><P>

<CODE>:two-pass?</CODE>: if true, all files will be scanned twice, once to
load the signatures of objects defined in them, and once to actually
translate the definitions.  Otherwise, the translator will make one pass in
the case that the system is already loaded (and is being remade), and two
passes otherwise.
</P><P>

<CODE>:development-settings?</CODE> (default false): if true translation will favor
safe, readable and debuggable code over efficiency (according to the value
of <CODE>:development-settings</CODE> on the system definition).  If false, efficiency
will be favored instead (according to the value of <CODE>:production-settings</CODE>
on the system definition).
</P><P>

<CODE>:production-settings?</CODE> (default true): inverse to <CODE>:development-settings?</CODE>.
</P><P>

<CODE>:force-translation?</CODE> (default false): if true, files will be translated
whether or not their translations are up-to-date.
</P><P>

<CODE>:force-recompilation?</CODE> (default false): if true, translated files will be
recompiled whether or not their compilations are up-to-date (only supported
in Lisp right now).
</P><P>

<CODE>:load-system?</CODE> (default true): if true, compiled files will be loaded into
the current STELLA image (only supported in Lisp right now).
</P><P>

<CODE>:startup?</CODE> (default true): if true, the system startup function will
be called once all files have been loaded.
</DL>
</P><P>

<A NAME="IDX806"></A>
<DL>
<DT><U>Method:</U> CONS-ITERATOR <B>member?</B> <I>(self (value OBJECT)) : BOOLEAN</I>
<DD>Iterate over values of <VAR>self</VAR> and return TRUE
if one of them is <CODE>eql?</CODE> to 'value.
</DL>
</P><P>

<A NAME="IDX807"></A>
<DL>
<DT><U>Method:</U> COLLECTION <B>member?</B> <I>(self (object OBJECT)) : BOOLEAN</I>
<DD>Return true iff <VAR>object</VAR> is a member of the collection <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX808"></A>
<DL>
<DT><U>Method:</U> SEQUENCE <B>member?</B> <I>(self (value OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>value</VAR> is a member of the sequence <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX809"></A>
<DL>
<DT><U>Macro:</U> <B>memoize</B> <I>((inputArgs CONS) &#38;body (body CONS)) : OBJECT</I>
<DD>Compute the value of an expression and memoize it relative to
   the values of <VAR>inputArgs</VAR>.
<VAR>inputArgs</VAR> should characterize the complete set of values upon which
   the computation of the result depended.
Calls to <CODE>memoize</CODE> should be of the form
</P><P>

      (memoize (&#60;arg&#62;+) {:&#60;option&#62; &#60;value&#62;}* &#60;expression&#62;)
</P><P>

   and have the status of an expression.
   The following options are supported:
</P><P>

      :timestamps   A single or list of keywords specifying the names of
                    timestamps which when bumped should invalidate all
                    entries currently memoized in this table.
      :name         Names the memoization table so it can be shared by other
                    memoization sites.  By default, a gensymed name is used.
                    CAUTION: IT IS ASSUMED THAT ALL ENTRIES IN A MEMOZATION
                    TABLE DEPEND ON THE SAME NUMBER OF ARGUMENTS!!
      :max-values   The maximum number of values to be memoized.  Only the
                    <CODE>:max-values</CODE> most recently used values will be kept
                    in the memoization table, older values will be discarded
                    and recomputed if needed.  Without a <CODE>:max-values</CODE>
                    specification, the memoization table will grow
                    indefinitely.
</P><P>

PERFORMANCE NOTES: For most efficient lookup, input arguments that vary the most
should be listed first.  Also, arguments of type STANDARD-OBJECT (and all its
subtypes) can be memoized more efficiently than arguments of type OBJECT or
wrapped literals (with the exception of BOOLEANs).
</DL>
</P><P>

<A NAME="IDX810"></A>
<DL>
<DT><U>Function:</U> <B>merge-file-names</B> <I>((baseFile FILE-NAME) (defaults FILE-NAME)) : FILE-NAME</I>
<DD>Parse <VAR>baseFile</VAR>, supply any missing components from
<VAR>defaults</VAR> if supplied and return the result.
</DL>
</P><P>

<A NAME="IDX811"></A>
<DL>
<DT><U>Method:</U> DECODED-DATE-TIME <B>merge-null-fields</B> <I>(self (default DECODED-DATE-TIME)) :</I>
<DD>Replace any null valued fields in <VAR>self</VAR> with values from <VAR>default</VAR>.
The day of the week will be set consistently, if possible.
</DL>
</P><P>

<A NAME="IDX812"></A>
<DL>
<DT><U>Method:</U> DECODED-DATE-TIME <B>merge-superior-null-fields</B> <I>(self (default DECODED-DATE-TIME)) :</I>
<DD>Replace only null valued fields in <VAR>self</VAR> that represent larger
time units than the smallest non-null in <VAR>self</VAR> with values from <VAR>default</VAR>.
The day of the week will be set consistently, if possible.
Example: if <VAR>self</VAR> just has the month being non-null, then only the year
will be filled in from <VAR>default</VAR>.  If the day and minute were non-null,
then hour, month and year will be filled.
</P><P>

This can be useful when one doesn't want to extend the precision
of the answer.
</DL>
</P><P>

<A NAME="IDX813"></A>
<DL>
<DT><U>Method:</U> CLASS <B>multiple-parents?</B> <I>(class) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>class</VAR> has more than one direct superclass.
</DL>
</P><P>

<A NAME="IDX814"></A>
<DL>
<DT><U>Method:</U> MODULE <B>multiple-parents?</B> <I>(module) : BOOLEAN</I>
<DD>Return TRUE if <VAR>module</VAR> has more than one parent.
</DL>
</P><P>

<A NAME="IDX815"></A>
<DL>
<DT><U>Method:</U> WORLD <B>multiple-parents?</B> <I>(world) : BOOLEAN</I>
<DD>Return FALSE always, since worlds never have more than one parent.
</DL>
</P><P>

<A NAME="IDX816"></A>
<DL>
<DT><U>Function:</U> <B>name-to-string</B> <I>((name OBJECT)) : STRING</I>
<DD>Return the string represented by <VAR>name</VAR>.  Return <CODE>null</CODE>
if <VAR>name</VAR> is undefined or does not represent a string.
</DL>
</P><P>

<A NAME="IDX817"></A>
<DL>
<DT><U>Function:</U> <B>native-read-line</B> <I>((inputStream INPUT-STREAM)) : STRING</I>
<DD>Read one line from <VAR>inputStream</VAR> using the native language
readline algorithm and return the result.  On EOF return <CODE>null</CODE>
</DL>
</P><P>

<A NAME="IDX818"></A>
<DL>
<DT><U>Method:</U> MEMOIZABLE-ITERATOR <B>next?</B> <I>(self) : BOOLEAN</I>
<DD>Generate the next value of the memoized iterator <VAR>self</VAR> (or
one of its clones) by either using one of the values generated so far or by
generating and saving the next value of the <CODE>base-iterator</CODE>.
</DL>
</P><P>

<A NAME="IDX819"></A>
<DL>
<DT><U>Method:</U> COLLECTION <B>no-duplicates?</B> <I>(self) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if the collection <VAR>self</VAR> forbids duplicate values.
</DL>
</P><P>

<A NAME="IDX820"></A>
<DL>
<DT><U>Method:</U> STRING-WRAPPER <B>non-empty?</B> <I>(x) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is not the wrapped empty string ""
</DL>
</P><P>

<A NAME="IDX821"></A>
<DL>
<DT><U>Function:</U> <B>non-matching-position</B> <I>((source STRING) (start INTEGER) (match STRING)) : INTEGER</I>
<DD>Returns the index into <VAR>source</VAR>, starting from <VAR>start</VAR>, of the first
character that is not included in <VAR>match</VAR>.
</DL>
</P><P>

<A NAME="IDX822"></A>
<DL>
<DT><U>Function:</U> <B>non-matching-position-helper</B> <I>((source STRING) (start INTEGER) (end INTEGER) (match STRING)) : INTEGER</I>
<DD>Helper for <CODE>non-matching-position</CODE> that requires <VAR>end</VAR> to not be <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX823"></A>
<DL>
<DT><U>Method:</U> NATIVE-VECTOR <B>nth</B> <I>(self (position INTEGER)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the element in <VAR>self</VAR> at <VAR>position</VAR>.
</DL>
</P><P>

<A NAME="IDX824"></A>
<DL>
<DT><U>Method:</U> ARRAY <B>null?</B> <I>(x) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is undefined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX825"></A>
<DL>
<DT><U>Macro:</U> <B>only-if</B> <I>((test OBJECT) (expression OBJECT)) : OBJECT</I>
<DD>If <VAR>test</VAR> is TRUE, return the result of evaluating 
<VAR>expression</VAR>.
</DL>
</P><P>

<A NAME="IDX826"></A>
<DL>
<DT><U>Function:</U> <B>open-network-stream</B> <I>((host STRING) (port INTEGER)) : INPUT-STREAM OUTPUT-STREAM</I>
<DD>Open a TCP/IP network stream to <VAR>host</VAR> at <VAR>port</VAR> and return the result
as an input/output stream pair.
</DL>
</P><P>

<A NAME="IDX827"></A>
<DL>
<DT><U>Method:</U> COLLECTION <B>ordered?</B> <I>(self) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if the collection <VAR>self</VAR> is ordered.
</DL>
</P><P>

<A NAME="IDX828"></A>
<DL>
<DT><U>Function:</U> <B>outline-depth-exceeded?</B> <I>((current-depth INTEGER) (depth-limit INTEGER)) : BOOLEAN</I>
<DD>Helper function that returns <CODE>true</CODE> if <VAR>current-depth</VAR> exceeds <VAR>depth-limit</VAR>.
This functions uses the convention that a <CODE>null</CODE> or negative value of
<VAR>depth-limit</VAR> means the depth is unlimited.  In those cases it always
returns false.
</DL>
</P><P>

<A NAME="IDX829"></A>
<DL>
<DT><U>Method:</U> CLASS <B>parameters</B> <I>(self) : (LIST OF SYMBOL)</I>
<DD>Returns the list of parameters names of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX830"></A>
<DL>
<DT><U>Function:</U> <B>parse-date-time-in-time-zone</B> <I>((date-time-string STRING) (time-zone FLOAT) (start INTEGER) (end INTEGER) (error-on-mismatch? BOOLEAN)) : DECODED-DATE-TIME</I>
<DD>Tries very hard to make sense out of the argument <VAR>date-time-string</VAR> and
returns a time structure if successful.  If not, it returns <CODE>null</CODE>.
If <VAR>error-on-mismatch?</VAR> is true, parse-date-time will signal an error instead of
returning <CODE>null</CODE>.  
Default values are 00:00:00 in the given timezone on the current date.  If the
given <VAR>time-zone</VAR> value is <CODE>null</CODE>, then the local time zone for the given date
and time will be used as determined by the operating system.
</DL>
</P><P>

<A NAME="IDX831"></A>
<DL>
<DT><U>Function:</U> <B>parse-date-time-relative-to-base</B> <I>((date-time-string STRING) (base-date-time DECODED-DATE-TIME) (start INTEGER) (end INTEGER) (error-on-mismatch? BOOLEAN) (merge-null-fields? BOOLEAN)) : DECODED-DATE-TIME</I>
<DD>Tries very hard to make sense out of the argument <VAR>date-time-string</VAR> and
returns a time structure if successful.  If not, it returns <CODE>null</CODE>.
If <VAR>error-on-mismatch?</VAR> is true, parse-date-time will signal an error instead of
returning <CODE>null</CODE>.
Default values are passed in via <VAR>base-date-time</VAR>.  If the timezone field that
is passed in is NULL, then the local time zone for the parsed date/time will
be used.
If <VAR>merge-null-fields?</VAR> is <CODE>true</CODE>, then default values from <CODE>base-time-date</CODE>
will be merged into missing components.  If <CODE>false</CODE>, then they won't be merged
in for null components but can still be used as a basis for interpreatation of
relative time strings like "now" or "yesterday"
</DL>
</P><P>

<A NAME="IDX832"></A>
<DL>
<DT><U>Function:</U> <B>parse-stella-name</B> <I>((name STRING) (enableCaseConversion? BOOLEAN)) : STRING STRING KEYWORD</I>
<DD>Parse the printed representation <VAR>name</VAR> of a STELLA symbol, surrogate or
keyword and return its symbol name, module name and type (which is either
:SYMBOL, :SURROGATE or :KEYWORD).  <VAR>name</VAR> can be qualified and must use the
exact same syntax and escape characters that would be used if it were to be
read by <CODE>read-s-expression-from-string</CODE> (or <CODE>unstringify</CODE>).  If
<VAR>enableCaseConversion?</VAR> is TRUE, the returned symbol name will be upcased if
the current module is case-insensitive; otherwise, it will be returned as is.
Raises a read exception if <VAR>name</VAR> does not represent a symbol.
This function is available primarily for efficiency, since it is about
10-15 times faster than <CODE>unstringify</CODE>.
</DL>
</P><P>

<A NAME="IDX833"></A>
<DL>
<DT><U>Function:</U> <B>pick-hash-table-size-prime</B> <I>((minSize INTEGER)) : INTEGER</I>
<DD>Return a hash table prime of at least <VAR>minSize</VAR>.
</DL>
</P><P>

<A NAME="IDX834"></A>
<DL>
<DT><U>Function:</U> <B>plist-to-kvlist</B> <I>((self PROPERTY-LIST)) : (KEY-VALUE-LIST OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))</I>
<DD>Convert <VAR>self</VAR> into a key-value list with identical and identically
ordered keys and values.
</DL>
</P><P>

<A NAME="IDX835"></A>
<DL>
<DT><U>Method:</U> OBJECT <B>primary-type</B> <I>(self) : TYPE</I>
<DD>Returns the primary type of <VAR>self</VAR>.
Gets defined automatically for every non-abstract subclass of OBJECT.
</DL>
</P><P>

<A NAME="IDX836"></A>
<DL>
<DT><U>Method:</U> RELATION <B>primitive?</B> <I>(self) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>self</VAR> is not a defined relation.
</DL>
</P><P>

<A NAME="IDX837"></A>
<DL>
<DT><U>Macro:</U> <B>print</B> <I>(&#38;body (body CONS)) : OBJECT</I>
<DD>Print arguments to the standard output stream.
</DL>
</P><P>

<A NAME="IDX838"></A>
<DL>
<DT><U>Function:</U> <B>print-exception-context</B> <I>((e NATIVE-EXCEPTION) (stream OUTPUT-STREAM)) :</I>
<DD>Prints a system dependent information about the context of the specified
exception.  For example, in Java it prints a stack trace.  In Lisp, it is vendor dependent.
</DL>
</P><P>

<A NAME="IDX839"></A>
<DL>
<DT><U>Command:</U> <B>print-outline</B> <I>((thing OBJECT) (stream OUTPUT-STREAM) (depth INTEGER) (named? BOOLEAN)) :</I>
<DD>Print an outline of <VAR>thing</VAR> and its subparts on <VAR>stream</VAR>.
If <VAR>depth</VAR> is greater than 0, only <VAR>depth</VAR> levels will be printed.
If <VAR>named?</VAR> is <CODE>TRUE</CODE>, then only named entities will be printed.
</P><P>

This function is intended to be used on things like modules, contexts,
concepts, etc. that have hierarchical structure.  If <VAR>thing</VAR> doesn't
have a hierarchical structure, it will just be printed.
</DL>
</P><P>

<A NAME="IDX840"></A>
<DL>
<DT><U>Function:</U> <B>print-recycle-lists</B> <I>() :</I>
<DD>Print the current state of all recycle lists.
</DL>
</P><P>

<A NAME="IDX841"></A>
<DL>
<DT><U>Macro:</U> <B>print-spaces</B> <I>(&#38;body (body CONS)) : OBJECT</I>
<DD>(print-spaces [stream] N) prints N spaces onto stream.  If
no stream form is provided, then STANDARD-OUTPUT will be used.
</DL>
</P><P>

<A NAME="IDX842"></A>
<DL>
<DT><U>Command:</U> <B>print-stella-features</B> <I>() :</I>
<DD>Print the list of enabled and disabled STELLA features.
</DL>
</P><P>

<A NAME="IDX843"></A>
<DL>
<DT><U>N-Command:</U> <B>print-unbound-surrogates</B> <I>(&#38;rest (args OBJECT)) :</I>
<DD>Print all unbound surrogates visible from the module named by the first
argument (a symbol or string).  Look at all modules if no module name or
<CODE>null</CODE> was supplied.  If the second argument is <CODE>true</CODE>, only consider
surrogates interned in the specified module.
</DL>
</P><P>

<A NAME="IDX844"></A>
<DL>
<DT><U>Function:</U> <B>print-undefined-methods</B> <I>((module MODULE) (local? BOOLEAN)) :</I>
<DD>Print all declared but not yet defined functions and methods
in <VAR>module</VAR>.  If <VAR>local?</VAR> is true, do not consider any parent modules of
<VAR>module</VAR>.  If <VAR>module</VAR> is NULL, look at all modules in the system.  This
is handy to pinpoint forward declarations that haven't been followed up
by actual definitions.
</DL>
</P><P>

<A NAME="IDX845"></A>
<DL>
<DT><U>N-Command:</U> <B>print-undefined-super-classes</B> <I>((class NAME)) :</I>
<DD>Print all undefined or bad (indirect) super classes of <VAR>class</VAR>.
</DL>
</P><P>

<A NAME="IDX846"></A>
<DL>
<DT><U>Function:</U> <B>private-class-methods</B> <I>((class CLASS)) : (ITERATOR OF METHOD-SLOT)</I>
<DD>Iterate over all private methods attached to <VAR>class</VAR>.
</DL>
</P><P>

<A NAME="IDX847"></A>
<DL>
<DT><U>Function:</U> <B>private-class-storage-slots</B> <I>((class CLASS)) : (ITERATOR OF STORAGE-SLOT)</I>
<DD>Iterate over all private storage-slots attached to <VAR>class</VAR>.
</DL>
</P><P>

<A NAME="IDX848"></A>
<DL>
<DT><U>Method:</U> RELATION <B>private?</B> <I>(self) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>self</VAR> is not public.
</DL>
</P><P>

<A NAME="IDX849"></A>
<DL>
<DT><U>Function:</U> <B>process-doctype</B> <I>((doctype-declaration CONS)) : XML-DOCTYPE</I>
<DD>Takes an S-Expression representing a doctype and processes into
a DOCTYPE object.
</DL>
</P><P>

<A NAME="IDX850"></A>
<DL>
<DT><U>N-Command:</U> <B>ptrans</B> <I>((statement OBJECT)) :</I>
<DD>Translate <VAR>statement</VAR> to Common-Lisp and print the result.
</DL>
</P><P>

<A NAME="IDX851"></A>
<DL>
<DT><U>Function:</U> <B>public-class-methods</B> <I>((class CLASS)) : (ITERATOR OF METHOD-SLOT)</I>
<DD>Iterate over all private methods attached to <VAR>class</VAR>.
</DL>
</P><P>

<A NAME="IDX852"></A>
<DL>
<DT><U>Function:</U> <B>public-class-storage-slots</B> <I>((class CLASS)) : (ITERATOR OF STORAGE-SLOT)</I>
<DD>Iterate over all public storage-slots attached to <VAR>class</VAR>.
</DL>
</P><P>

<A NAME="IDX853"></A>
<DL>
<DT><U>Method:</U> CLASS <B>public-slots</B> <I>(self) : (ITERATOR OF SLOT)</I>
<DD>Return an iterator over public slots of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX854"></A>
<DL>
<DT><U>Method:</U> OBJECT <B>public-slots</B> <I>(self) : (ITERATOR OF SLOT)</I>
<DD>Return an iterator over public slots of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX855"></A>
<DL>
<DT><U>Method:</U> SLOT <B>public?</B> <I>(self) : BOOLEAN</I>
<DD>True if <VAR>self</VAR> or one it its ancestors is marked public.
</DL>
</P><P>

<A NAME="IDX856"></A>
<DL>
<DT><U>Macro:</U> <B>pushf</B> <I>((place CONS) (value OBJECT)) : OBJECT</I>
<DD>Push <VAR>value</VAR> onto the cons list <VAR>place</VAR>.
</DL>
</P><P>

<A NAME="IDX857"></A>
<DL>
<DT><U>Function:</U> <B>qualified-stella-name?</B> <I>((name STRING)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>name</VAR> is a symbol or surrogate qualified with a module
pathname or a module pathname ending with a <CODE>/</CODE>.  Assumes that <VAR>name</VAR>
is the printed representation of a STELLA symbol (potentially containing
escape characters).
</DL>
</P><P>

<A NAME="IDX858"></A>
<DL>
<DT><U>Function:</U> <B>read-line2</B> <I>((stream INPUT-STREAM)) : STRING KEYWORD</I>
<DD>Read one line from <VAR>stream</VAR> and return the result and
a keyword that indicates the terminator for that line ending:
<CODE>:CR</CODE> <CODE>:LF</CODE> <CODE>:CRLF</CODE> or <CODE>:EOF</CODE>.   This is not platform-dependent
and differs from <CODE>read-line</CODE> by returning a second value.  It
may hang when used on interactive streams such as terminal or
network streams with only CR line endings.  It should only be
used on file or string input streams.
</DL>
</P><P>

<A NAME="IDX859"></A>
<DL>
<DT><U>Method:</U> STORAGE-SLOT <B>reader</B> <I>(self) : SYMBOL</I>
<DD>Name of a method called to read the value of the slot
<VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX860"></A>
<DL>
<DT><U>Function:</U> <B>remove-configuration-property</B> <I>((property STRING) (value OBJECT) (configuration CONFIGURATION-TABLE)) : OBJECT</I>
<DD>Remove <VAR>value</VAR> from <VAR>property</VAR> in <VAR>configuration</VAR> and return it.
Use the global system configuration table if <VAR>configuration</VAR> is NULL.
</DL>
</P><P>

<A NAME="IDX861"></A>
<DL>
<DT><U>Method:</U> COLLECTION <B>remove-duplicates</B> <I>(self) : (LIKE SELF)</I>
<DD>Return <VAR>self</VAR> with duplicates removed.  Preserves the
original order of the remaining members.
</DL>
</P><P>

<A NAME="IDX862"></A>
<DL>
<DT><U>Method:</U> CLASS <B>required-slots</B> <I>(self) : (LIST OF SYMBOL)</I>
<DD>Returns a list of names of required slots for <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX863"></A>
<DL>
<DT><U>Method:</U> STORAGE-SLOT <B>required?</B> <I>(self) : BOOLEAN</I>
<DD>True if a value must be assigned to this slot at
creation time.
</DL>
</P><P>

<A NAME="IDX864"></A>
<DL>
<DT><U>Command:</U> <B>reset-stella-features</B> <I>() :</I>
<DD>Reset STELLA features to their default settings.
</DL>
</P><P>

<A NAME="IDX865"></A>
<DL>
<DT><U>Function:</U> <B>reverse-interval</B> <I>((lowerbound INTEGER) (upperbound INTEGER)) : REVERSE-INTEGER-INTERVAL-ITERATOR</I>
<DD>Create a reverse interval object.
</DL>
</P><P>

<A NAME="IDX866"></A>
<DL>
<DT><U>Function:</U> <B>run-hooks</B> <I>((hooklist HOOK-LIST) (argument OBJECT)) :</I>
<DD>Run all hook functions in <VAR>hooklist</VAR>, applying
each one to <VAR>argument</VAR>.
</DL>
</P><P>

<A NAME="IDX867"></A>
<DL>
<DT><U>Function:</U> <B>running-as-lisp?</B> <I>() : BOOLEAN</I>
<DD>Return true if the executable code is a Common Lisp application.
</DL>
</P><P>

<A NAME="IDX868"></A>
<DL>
<DT><U>Function:</U> <B>running-in-language</B> <I>() : KEYWORD</I>
<DD>Returns the keyword for the language the current implementation is running in.
</DL>
</P><P>

<A NAME="IDX869"></A>
<DL>
<DT><U>Function:</U> <B>running-system-information</B> <I>() : STRING</I>
<DD>Returns an information string about the current running system environment.
</DL>
</P><P>

<A NAME="IDX870"></A>
<DL>
<DT><U>Function:</U> <B>safe-equal-hash-code</B> <I>((self OBJECT)) : INTEGER</I>
<DD>Return a hash code for <VAR>self</VAR>.  Just like <CODE>equal-hash-code</CODE>
- which see, but also works for NULL.  <CODE>equal-hash-code</CODE> methods that expect to
handle NULL components should use this function for recursive calls.
</DL>
</P><P>

<A NAME="IDX871"></A>
<DL>
<DT><U>Function:</U> <B>safe-hash-code</B> <I>((self OBJECT)) : INTEGER</I>
<DD>Return a hash code for <VAR>self</VAR>.  Just like <CODE>hash-code</CODE>
- which see, but also works for NULL.
</DL>
</P><P>

<A NAME="IDX872"></A>
<DL>
<DT><U>Function:</U> <B>safe-lookup-slot</B> <I>((class CLASS) (slot-name SYMBOL)) : SLOT</I>
<DD>Alias for <CODE>lookup-slot</CODE>.  Kept for backwards compatibility.
</DL>
</P><P>

<A NAME="IDX873"></A>
<DL>
<DT><U>Macro:</U> <B>safety</B> <I>((level INTEGER-WRAPPER) (test OBJECT) &#38;body (body CONS)) : OBJECT</I>
<DD>Signal warning message, placing non-string arguments in quotes.
</DL>
</P><P>

<A NAME="IDX874"></A>
<DL>
<DT><U>Function:</U> <B>save-configuration-file</B> <I>((table CONFIGURATION-TABLE) (file FILE-NAME) (title STRING)) :</I>
<DD>Save <VAR>table</VAR> as a configuration file.  Uses a Java-style property file syntax.
</DL>
</P><P>

<A NAME="IDX875"></A>
<DL>
<DT><U>Function:</U> <B>save-configuration-value</B> <I>((stream OUTPUT-STREAM) (value OBJECT)) :</I>
<DD>Save <VAR>value</VAR> to <VAR>stream</VAR> as a properly formatted configuration
value.
</DL>
</P><P>

<A NAME="IDX876"></A>
<DL>
<DT><U>Function:</U> <B>search-cons-tree-with-filter?</B> <I>((tree OBJECT) (value OBJECT) (filter CONS)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> iff the value <VAR>value</VAR> is embedded within
the cons tree <VAR>tree</VAR>.  Uses an <CODE>eql?</CODE> test.  Does not descend into any
cons whose first element matches an element of <VAR>filter</VAR>.
</DL>
</P><P>

<A NAME="IDX877"></A>
<DL>
<DT><U>Function:</U> <B>search-for-object</B> <I>((self OBJECT) (typeref OBJECT)) : OBJECT</I>
<DD>If <VAR>self</VAR> is a string or a symbol, search for an object named
<VAR>self</VAR> of type <CODE>type</CODE>.  Otherwise, if <VAR>self</VAR> is an object, return it.
</DL>
</P><P>

<A NAME="IDX878"></A>
<DL>
<DT><U>Function:</U> <B>seed-random-number-generator</B> <I>() :</I>
<DD>Seeds the random number generator with the current time.
</DL>
</P><P>

<A NAME="IDX879"></A>
<DL>
<DT><U>Function:</U> <B>sequence</B> <I>((collectiontype TYPE) &#38;rest (values OBJECT)) : (SEQUENCE OF OBJECT)</I>
<DD>Return a sequence containing <VAR>values</VAR>, in order.
</DL>
</P><P>

<A NAME="IDX880"></A>
<DL>
<DT><U>Command:</U> <B>set-call-log-break-point</B> <I>((count INTEGER)) :</I>
<DD>Set a call log break point to <VAR>count</VAR>.  Execution will be
interrupted right at the entry of the <VAR>count</VAR>th logged function call.
</DL>
</P><P>

<A NAME="IDX881"></A>
<DL>
<DT><U>Function:</U> <B>set-configuration-property</B> <I>((property STRING) (value OBJECT) (configuration CONFIGURATION-TABLE)) : OBJECT</I>
<DD>Set <VAR>property</VAR> in <VAR>configuration</VAR> to <VAR>value</VAR> and return it.
Use the global system configuration table if <VAR>configuration</VAR> is NULL.
</DL>
</P><P>

<A NAME="IDX882"></A>
<DL>
<DT><U>Method:</U> DECODED-DATE-TIME <B>set-current-date</B> <I>(values-structure) :</I>
<DD>Sets the current date into <VAR>values-structure</VAR>
</DL>
</P><P>

<A NAME="IDX883"></A>
<DL>
<DT><U>Method:</U> DECODED-DATE-TIME <B>set-current-date-time</B> <I>(values-structure) :</I>
<DD>Sets the current date and time into <VAR>values-structure</VAR>
</DL>
</P><P>

<A NAME="IDX884"></A>
<DL>
<DT><U>Method:</U> DECODED-DATE-TIME <B>set-current-time</B> <I>(values-structure) :</I>
<DD>Sets the current time into <VAR>values-structure</VAR>
</DL>
</P><P>

<A NAME="IDX885"></A>
<DL>
<DT><U>Function:</U> <B>set-global-value</B> <I>((self SURROGATE) (value OBJECT)) : OBJECT</I>
<DD>Set the value of the global variable for the surrogate
<VAR>self</VAR> to <VAR>value</VAR>.
</DL>
</P><P>

<A NAME="IDX886"></A>
<DL>
<DT><U>Function:</U> <B>set-logging-parameters</B> <I>((module STRING) &#38;rest (params&#38;values OBJECT)) :</I>
<DD>Set logging parameters for <VAR>module</VAR>.  The supported parameters are:
  :LOG-LEVELS - a cons list of legal levels in ascending log level order;
                for example, (:NONE :LOW :MEDIUM :HIGH) or (0 1 2 3).
  :LEVEL      - the current log level for <VAR>module</VAR>
  :STREAM     - the stream to log to (defaults to STANDARD-OUTPUT)
  :PREFIX     - the prefix to use to identify the module (defaults to <VAR>module</VAR>)
  :MAX-WIDTH  - logging output lines will be kept to approximately this width
                (defaults to 10000, minimum width of about 30 is used to
                print line header information).
</DL>
</P><P>

<A NAME="IDX887"></A>
<DL>
<DT><U>Function:</U> <B>set-optimization-levels</B> <I>((safety INTEGER) (debug INTEGER) (speed INTEGER) (space INTEGER)) :</I>
<DD>Set optimization levels for the qualities <VAR>safety</VAR>, <VAR>debug</VAR>,
<VAR>speed</VAR>, and <VAR>space</VAR>.
</DL>
</P><P>

<A NAME="IDX888"></A>
<DL>
<DT><U>Command:</U> <B>set-stella-feature</B> <I>(&#38;rest (features KEYWORD)) :</I>
<DD>Enable all listed STELLA <VAR>features</VAR>.
</DL>
</P><P>

<A NAME="IDX889"></A>
<DL>
<DT><U>Command:</U> <B>set-translator-output-language</B> <I>((new-language KEYWORD)) : KEYWORD</I>
<DD>Set output language to <VAR>new-language</VAR>.  Return previous language.
</DL>
</P><P>

<A NAME="IDX890"></A>
<DL>
<DT><U>Macro:</U> <B>setq?</B> <I>((variable SYMBOL) (expression CONS)) : OBJECT</I>
<DD>Assign <VAR>variable</VAR> the result of evaluating <VAR>expression</VAR>, 
and return TRUE if <VAR>expression</VAR> is not NULL else return FALSE.
</DL>
</P><P>

<A NAME="IDX891"></A>
<DL>
<DT><U>Function:</U> <B>shadowed-symbol?</B> <I>((symbol GENERALIZED-SYMBOL)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>symbol</VAR> is shadowed in its home module.
</DL>
</P><P>

<A NAME="IDX892"></A>
<DL>
<DT><U>Function:</U> <B>shift-right</B> <I>((arg INTEGER) (count INTEGER)) : INTEGER</I>
<DD>Shift <VAR>arg</VAR> to the right by <VAR>count</VAR> positions and
0-extend from the left if <VAR>arg</VAR> is positive or 1-extend if it is
negative.  This is an arithmetic shift that preserve the sign of <VAR>arg</VAR>
and is equivalent to dividing <VAR>arg</VAR> by 2** <VAR>count</VAR>.
</DL>
</P><P>

<A NAME="IDX893"></A>
<DL>
<DT><U>Macro:</U> <B>signal</B> <I>((type SYMBOL) &#38;body (body CONS)) : OBJECT</I>
<DD>Signal error message, placing non-string arguments in quotes.
</DL>
</P><P>

<A NAME="IDX894"></A>
<DL>
<DT><U>Macro:</U> <B>signal-read-error</B> <I>(&#38;body (body CONS)) : OBJECT</I>
<DD>Specialized version of <CODE>signal</CODE> that throws a READ-EXCEPTION.
</DL>
</P><P>

<A NAME="IDX895"></A>
<DL>
<DT><U>Command:</U> <B>start-function-call-logging</B> <I>((fileName STRING)) :</I>
<DD>Start function call logging to <VAR>fileName</VAR>.
</DL>
</P><P>

<A NAME="IDX896"></A>
<DL>
<DT><U>Function:</U> <B>starts-with?</B> <I>((string STRING) (prefix STRING) (start INTEGER)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>string</VAR> starts with <VAR>prefix</VAR> starting from
<VAR>start</VAR> (which defaults to 0 if it is supplied as NULL).
</DL>
</P><P>

<A NAME="IDX897"></A>
<DL>
<DT><U>Function:</U> <B>stella-collection?</B> <I>((self OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>self</VAR> is a native collection.
</DL>
</P><P>

<A NAME="IDX898"></A>
<DL>
<DT><U>Command:</U> <B>stella-information</B> <I>() : STRING</I>
<DD>Returns information about the current Stella implementation.
Useful when reporting problems.
</DL>
</P><P>

<A NAME="IDX899"></A>
<DL>
<DT><U>Function:</U> <B>stella-object?</B> <I>((self OBJECT)) : BOOLEAN</I>
<DD>Return true if <VAR>self</VAR> is a member of the STELLA class <CODE>OBJECT</CODE>.
</DL>
</P><P>

<A NAME="IDX900"></A>
<DL>
<DT><U>Function:</U> <B>stella-version-string</B> <I>() : STRING</I>
<DD>Return a string identifying the current version of STELLA.
</DL>
</P><P>

<A NAME="IDX901"></A>
<DL>
<DT><U>Function:</U> <B>stellafy</B> <I>((thing LISP-CODE) (targetType TYPE)) : OBJECT</I>
<DD>Partial inverse to <CODE>lispify</CODE>.  Convert the Lisp object 
<VAR>thing</VAR> into a Stella analogue of type <VAR>targetType</VAR>.
Note: See also <CODE>stellify</CODE>. it is similar, but guesses <VAR>targetType</VAR> on its own,
and makes somewhat different translations.
</DL>
</P><P>

<A NAME="IDX902"></A>
<DL>
<DT><U>Function:</U> <B>stellify</B> <I>((self OBJECT)) : OBJECT</I>
<DD>Convert a Lisp object into a STELLA object.
</DL>
</P><P>

<A NAME="IDX903"></A>
<DL>
<DT><U>Command:</U> <B>stop-function-call-logging</B> <I>() :</I>
<DD>Stop function call logging and close the current log file.
</DL>
</P><P>

<A NAME="IDX904"></A>
<DL>
<DT><U>Method:</U> INPUT-STREAM <B>stream-to-string</B> <I>(from) : STRING</I>
<DD>Read all of the input from <CODE>stream</CODE> and return it as a string.
</DL>
</P><P>

<A NAME="IDX905"></A>
<DL>
<DT><U>Function:</U> <B>string-to-calendar-date-with-default</B> <I>((input-date STRING) (default-date DECODED-DATE-TIME)) : CALENDAR-DATE</I>
<DD>Returns a calendar date object representing the date and time
parsed from the <VAR>input-date</VAR> string.  Default values for missing fields and
the interpretation of relative references come from <VAR>default-date</VAR>.  If the
<VAR>default-date</VAR> is <CODE>null</CODE>, the current date will be used.  If a null set of
defaults is desired, use <CODE>*NULL-DECODED-DATE-TIME*</CODE>.
If no valid parse is found, <CODE>null</CODE> is returned.
</DL>
</P><P>

<A NAME="IDX906"></A>
<DL>
<DT><U>Function:</U> <B>string-to-decoded-date-time</B> <I>((input STRING)) : DECODED-DATE-TIME</I>
<DD>Returns a decoded date-time object representing the date
and time parsed from the <VAR>input</VAR> string.  If no valid parse is found,
<CODE>null</CODE> is returned.
</DL>
</P><P>

<A NAME="IDX907"></A>
<DL>
<DT><U>Function:</U> <B>string-to-surrogate</B> <I>((self STRING)) : SURROGATE</I>
<DD>Return a surrogate with the name <VAR>self</VAR> visible
in the current module.  Very tricky: The logic is designed to avoid
returning an inherited surrogate that has no value.  In that case,
a new local surrogate is created that shadows the inherited surrogate.
</DL>
</P><P>

<A NAME="IDX908"></A>
<DL>
<DT><U>Function:</U> <B>string-to-time-duration</B> <I>((duration STRING)) : TIME-DURATION</I>
<DD>Parses and returns an time-duration object corresponding to <VAR>duration</VAR>.
The syntax for time duration strings is "{plus|minus} N days[; M ms]" where N and M are
integer values for days and milliseconds.  If no valid parse is found, <CODE>null</CODE> is returned.
</DL>
</P><P>

<A NAME="IDX909"></A>
<DL>
<DT><U>Function:</U> <B>subclass-of?</B> <I>((subClass CLASS) (superClass CLASS)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>subClass</VAR> is a subclass of <VAR>superClass</VAR>.
</DL>
</P><P>

<A NAME="IDX910"></A>
<DL>
<DT><U>Method:</U> MUTABLE-STRING <B>subsequence</B> <I>(string (start INTEGER) (end INTEGER)) : STRING</I>
<DD>Return a substring of <VAR>string</VAR> beginning at position <VAR>start</VAR>
and ending up to but not including position <VAR>end</VAR>, counting from zero.  An
<VAR>end</VAR> value of NULL stands for the rest of the string.
</DL>
</P><P>

<A NAME="IDX911"></A>
<DL>
<DT><U>Method:</U> STRING <B>substitute-characters</B> <I>(self (new-chars STRING) (old-chars STRING)) : STRING</I>
<DD>Substitute all occurences of of a member of <VAR>old-chars</VAR> with the 
corresponding member of <VAR>new-chars</VAR> in the string <VAR>self</VAR>.  Returns a new string.
</DL>
</P><P>

<A NAME="IDX912"></A>
<DL>
<DT><U>Method:</U> MUTABLE-STRING <B>substitute-characters</B> <I>(self (new-chars STRING) (old-chars STRING)) : MUTABLE-STRING</I>
<DD>Substitute all occurences of of a member of <VAR>old-chars</VAR> with the 
corresponding member of <VAR>new-chars</VAR> in the string <VAR>self</VAR>.  IMPORTANT:  The return
value should be used instead of relying on destructive substitution, since the
substitution will not be destructive in all translated languages.
</DL>
</P><P>

<A NAME="IDX913"></A>
<DL>
<DT><U>Function:</U> <B>subtype-of?</B> <I>((sub-type TYPE) (super-type TYPE)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> iff the class named <VAR>sub-type</VAR> is a subclass 
of the class named <VAR>super-type</VAR>.
</DL>
</P><P>

<A NAME="IDX914"></A>
<DL>
<DT><U>Method:</U> CLASS <B>super-classes</B> <I>(self) : (ITERATOR OF CLASS)</I>
<DD>Returns an iterator that generates all super classes
of <VAR>self</VAR>.  Non-reflexive.
</DL>
</P><P>

<A NAME="IDX915"></A>
<DL>
<DT><U>Function:</U> <B>surrogate-name?</B> <I>((name STRING)) : BOOLEAN</I>
<DD>Return TRUE if name is prefixed by <CODE>SURROGATE-PREFIX-CHARACTER</CODE>.
</DL>
</P><P>

<A NAME="IDX916"></A>
<DL>
<DT><U>Method:</U> SURROGATE <B>surrogatify</B> <I>(self) : SURROGATE</I>
<DD>Converts <VAR>self</VAR> into a surrogate.
</DL>
</P><P>

<A NAME="IDX917"></A>
<DL>
<DT><U>Method:</U> SYMBOL <B>surrogatify</B> <I>(self) : SURROGATE</I>
<DD>Converts <VAR>self</VAR> into a surrogate (same semantics
as <CODE>symbol-to-surrogate</CODE> which see).
</DL>
</P><P>

<A NAME="IDX918"></A>
<DL>
<DT><U>Method:</U> STRING <B>surrogatify</B> <I>(self) : SURROGATE</I>
<DD>Converts <VAR>self</VAR> into a surrogate.
</DL>
</P><P>

<A NAME="IDX919"></A>
<DL>
<DT><U>Method:</U> OBJECT <B>sweep</B> <I>(self) :</I>
<DD>Default method.  Sweep up all <VAR>self</VAR>-type objects.
</DL>
</P><P>

<A NAME="IDX920"></A>
<DL>
<DT><U>Function:</U> <B>symbol-to-surrogate</B> <I>((self SYMBOL)) : SURROGATE</I>
<DD>Return a surrogate with the same name as <VAR>self</VAR>.
Very tricky: The logic is designed to avoid returning an inherited surrogate
that has no value.  In that case, a new local surrogate is created that shadows
the inherited surrogate.  Unlike <CODE>string-to-surrogate</CODE>, the search starts first
from the home context of <VAR>self</VAR>, and if that fails, then it restarts in
*module*.
</DL>
</P><P>

<A NAME="IDX921"></A>
<DL>
<DT><U>Function:</U> <B>symbol-to-type</B> <I>((self SYMBOL)) : SURROGATE</I>
<DD>Convert <VAR>self</VAR> into a surrogate with the same name and module.
</DL>
</P><P>

<A NAME="IDX922"></A>
<DL>
<DT><U>Method:</U> STORAGE-SLOT <B>system-default-value</B> <I>(self) : OBJECT</I>
<DD>Return a default value expression, or if <VAR>self</VAR>
has dynamic storage, an initial value expression.
</DL>
</P><P>

<A NAME="IDX923"></A>
<DL>
<DT><U>Method:</U> SLOT <B>system-default-value</B> <I>(self) : OBJECT</I>
<DD>Return a default value expression, or if <VAR>self</VAR>
has dynamic storage, an initial value expression.
</DL>
</P><P>

<A NAME="IDX924"></A>
<DL>
<DT><U>Function:</U> <B>system-loaded?</B> <I>((name STRING)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if system <VAR>name</VAR> has been loaded.
</DL>
</P><P>

<A NAME="IDX925"></A>
<DL>
<DT><U>Function:</U> <B>terminate-program</B> <I>() :</I>
<DD>Terminate and exit the program with normal exit code.
</DL>
</P><P>

<A NAME="IDX926"></A>
<DL>
<DT><U>Method:</U> TIME-DURATION <B>time-duration-to-string</B> <I>(date) : STRING</I>
<DD>Returns a string representation of <VAR>date</VAR>
</DL>
</P><P>

<A NAME="IDX927"></A>
<DL>
<DT><U>Function:</U> <B>time-zone-format60</B> <I>((timezone FLOAT)) : STRING</I>
<DD>Format <CODE>zone</CODE> as an hh:mm string
</DL>
</P><P>

<A NAME="IDX928"></A>
<DL>
<DT><U>Function:</U> <B>toggle-output-language</B> <I>() : KEYWORD</I>
<DD>Switch between Common Lisp and C++ as output languages.
</DL>
</P><P>

<A NAME="IDX929"></A>
<DL>
<DT><U>Macro:</U> <B>trace-if</B> <I>((keyword OBJECT) &#38;body (body CONS)) : OBJECT</I>
<DD>If <VAR>keyword</VAR> is a trace keyword that has been enabled with <CODE>add-trace</CODE>
print all the elements in <VAR>body</VAR> to standard output.  Otherwise, do nothing.
<VAR>keyword</VAR> can also be a list of keywords in which case printing is done if
one or more of them are trace enabled.
</DL>
</P><P>

<A NAME="IDX930"></A>
<DL>
<DT><U>Function:</U> <B>translate-system</B> <I>((systemName STRING) (outputLanguage KEYWORD) &#38;rest (options OBJECT)) : BOOLEAN</I>
<DD>Translate all of the STELLA source files in system <VAR>systemName</VAR> into
<VAR>outputLanguage</VAR>.  The following keyword/value <VAR>options</VAR> are recognized:
</P><P>

<CODE>:two-pass?</CODE> (default false): if true, all files will be scanned twice, once
to load the signatures of objects defined in them, and once to actually
translate the definitions.
</P><P>

<CODE>:force-translation?</CODE> (default false): if true, files will be translated
whether or not their translations are up-to-date.
</P><P>

<CODE>:development-settings?</CODE> (default false): if true translation will favor
safe, readable and debuggable code over efficiency (according to the value
of <CODE>:development-settings</CODE> on the system definition).  If false, efficiency
will be favored instead (according to the value of <CODE>:production-settings</CODE>
on the system definition).
</P><P>

<CODE>:production-settings?</CODE> (default true): inverse to <CODE>:development-settings?</CODE>.
</DL>
</P><P>

<A NAME="IDX931"></A>
<DL>
<DT><U>Function:</U> <B>translate-to-common-lisp?</B> <I>() : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if current output language is Common-Lisp.
</DL>
</P><P>

<A NAME="IDX932"></A>
<DL>
<DT><U>Function:</U> <B>translate-to-cpp?</B> <I>() : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if current output language is C++
</DL>
</P><P>

<A NAME="IDX933"></A>
<DL>
<DT><U>Function:</U> <B>translate-to-java?</B> <I>() : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if current output language is Java
</DL>
</P><P>

<A NAME="IDX934"></A>
<DL>
<DT><U>Function:</U> <B>truncate</B> <I>((n NUMBER)) : INTEGER</I>
<DD>Truncate <VAR>n</VAR> toward zero and return the result.
</DL>
</P><P>

<A NAME="IDX935"></A>
<DL>
<DT><U>Function:</U> <B>try-to-evaluate</B> <I>((tree OBJECT)) : OBJECT</I>
<DD>Variant of <CODE>evaluate</CODE> that only evaluates <VAR>tree</VAR> if it
represents an evaluable expression.  If it does not, <VAR>tree</VAR> is returned
unmodified.  This can be used to implement commands with mixed argument
evaluation strategies.
</DL>
</P><P>

<A NAME="IDX936"></A>
<DL>
<DT><U>Function:</U> <B>two-argument-least-common-superclass</B> <I>((class1 CLASS) (class2 CLASS)) : CLASS</I>
<DD>Return the most specific class that is a superclass of
both <VAR>class1</VAR> and <VAR>class2</VAR>.  If there is more than one, arbitrarily pick one.
If there is none, return <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX937"></A>
<DL>
<DT><U>Function:</U> <B>two-argument-least-common-supertype</B> <I>((type1 TYPE-SPEC) (type2 TYPE-SPEC)) : TYPE-SPEC</I>
<DD>Return the most specific type that is a supertype of
both <VAR>type1</VAR> and <VAR>type2</VAR>.  If there is more than one, arbitrarily pick one.
If there is none, return @VOID.  If one or both types are parametric,
also try to generalize parameter types if necessary.
</DL>
</P><P>

<A NAME="IDX938"></A>
<DL>
<DT><U>Method:</U> SLOT <B>type</B> <I>(self) : TYPE</I>
<DD>The type of a storage slot is its base type.
</DL>
</P><P>

<A NAME="IDX939"></A>
<DL>
<DT><U>Method:</U> SLOT <B>type-specifier</B> <I>(self) : TYPE-SPEC</I>
<DD>If <VAR>self</VAR> has a complex type return its
type specifier, otherwise, return <CODE>type</CODE> of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX940"></A>
<DL>
<DT><U>Function:</U> <B>type-to-symbol</B> <I>((type TYPE)) : SYMBOL</I>
<DD>Convert <VAR>type</VAR> into a symbol with the same name and module.
</DL>
</P><P>

<A NAME="IDX941"></A>
<DL>
<DT><U>Method:</U> SURROGATE <B>type-to-wrapped-type</B> <I>(self) : TYPE</I>
<DD>Return the wrapped type for the type <VAR>self</VAR>,
or <VAR>self</VAR> if it is not a bare literal type.
</DL>
</P><P>

<A NAME="IDX942"></A>
<DL>
<DT><U>Function:</U> <B>unbound-surrogates</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF SURROGATE)</I>
<DD>Iterate over all unbound surrogates visible from <VAR>module</VAR>.
Look at all modules if <VAR>module</VAR> is <CODE>null</CODE>.  If <VAR>local?</VAR>, only consider
surrogates interned in <VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX943"></A>
<DL>
<DT><U>Function:</U> <B>unescape-html-string</B> <I>((input STRING)) : STRING</I>
<DD>Replaces HTML escape sequences such as &#38;amp; with their
associated characters.
</DL>
</P><P>

<A NAME="IDX944"></A>
<DL>
<DT><U>Function:</U> <B>unescape-url-string</B> <I>((input STRING)) : STRING</I>
<DD>Takes a string and replaces %-format URL escape sequences with their real
character equivalent according to RFC 2396.
</DL>
</P><P>

<A NAME="IDX945"></A>
<DL>
<DT><U>Command:</U> <B>unset-stella-feature</B> <I>(&#38;rest (features KEYWORD)) :</I>
<DD>Disable all listed STELLA <VAR>features</VAR>.
</DL>
</P><P>

<A NAME="IDX946"></A>
<DL>
<DT><U>Function:</U> <B>unsigned-shift-right-by-1</B> <I>((arg INTEGER)) : INTEGER</I>
<DD>Shift <VAR>arg</VAR> to the right by 1 position and 0-extend
from the left.  This does not preserve the sign of <VAR>arg</VAR> and shifts
the sign-bit just like a regular bit.  In Common-Lisp we can't do that
directly and need to do some extra masking.
</DL>
</P><P>

<A NAME="IDX947"></A>
<DL>
<DT><U>Function:</U> <B>unstringify-stella-source</B> <I>((source STRING) (module MODULE)) : OBJECT</I>
<DD>Unstringify a STELLA <VAR>source</VAR> string relative to <VAR>module</VAR>,
or <CODE>*MODULE*</CODE> if no module is specified.  This function allocates transient
objects as opposed to <CODE>unstringify-in-module</CODE> or the regular <CODE>unstringify</CODE>.
</DL>
</P><P>

<A NAME="IDX948"></A>
<DL>
<DT><U>Function:</U> <B>unwrap-boolean</B> <I>((wrapper BOOLEAN-WRAPPER)) : BOOLEAN</I>
<DD>Unwrap <VAR>wrapper</VAR> and return its values as a regular BOOLEAN.
Map NULL onto FALSE.
</DL>
</P><P>

<A NAME="IDX949"></A>
<DL>
<DT><U>Function:</U> <B>unwrap-function-code</B> <I>((wrapper FUNCTION-CODE-WRAPPER)) : FUNCTION-CODE</I>
<DD>Unwrap <VAR>wrapper</VAR> and return the result.
Return NULL if <VAR>wrapper</VAR> is NULL.
</DL>
</P><P>

<A NAME="IDX950"></A>
<DL>
<DT><U>Function:</U> <B>unwrap-method-code</B> <I>((wrapper METHOD-CODE-WRAPPER)) : METHOD-CODE</I>
<DD>Unwrap <VAR>wrapper</VAR> and return the result.
Return NULL if <VAR>wrapper</VAR> is NULL.
</DL>
</P><P>

<A NAME="IDX951"></A>
<DL>
<DT><U>Method:</U> ABSTRACT-DICTIONARY-ITERATOR <B>value-setter</B> <I>(self (value (LIKE (ANY-VALUE SELF)))) : (LIKE (ANY-VALUE SELF))</I>
<DD>Abstract method needed to allow application of this
method on abstract iterator classes that do not implement it.  By having
this here all <CODE>next?</CODE> methods of dictionary iterators MUST use the <CODE>slot-value</CODE>
paradigm to set the iterator value.
</DL>
</P><P>

<A NAME="IDX952"></A>
<DL>
<DT><U>Macro:</U> <B>warn</B> <I>(&#38;body (body CONS)) : OBJECT</I>
<DD>Signal warning message, placing non-string arguments in quotes.
</DL>
</P><P>

<A NAME="IDX953"></A>
<DL>
<DT><U>Macro:</U> <B>with-network-stream</B> <I>((binding CONS) &#38;body (body CONS)) : OBJECT</I>
<DD>Sets up an unwind-protected form which opens a network
socket stream to a host and port for input and output and closes it afterwards.
Separate variables as provided in the call are bound to the input and output
streams. Syntax is (WITH-NETWORK-STREAM (varIn varOut hostname port) body+)
</DL>
</P><P>

<A NAME="IDX954"></A>
<DL>
<DT><U>Macro:</U> <B>with-permanent-objects</B> <I>(&#38;body (body CONS)) : OBJECT</I>
<DD>Allocate <CODE>permanent</CODE> (as opposed to <CODE>transient</CODE>)
objects within the scope of this declaration.
</DL>
</P><P>

<A NAME="IDX955"></A>
<DL>
<DT><U>Macro:</U> <B>with-system-definition</B> <I>((systemnameexpression OBJECT) &#38;body (body CONS)) : OBJECT</I>
<DD>Set *currentSystemDefinition* to the system definition named <CODE>system</CODE>.
Set *currentSystemDefinitionSubdirectory* to match. Execute <VAR>body</VAR> within
that scope.
</DL>
</P><P>

<A NAME="IDX956"></A>
<DL>
<DT><U>Macro:</U> <B>with-transient-objects</B> <I>(&#38;body (body CONS)) : OBJECT</I>
<DD>Allocate <CODE>transient</CODE> (as opposed to <CODE>permanent</CODE>)
objects within the scope of this declaration.
CAUTION: The default assumption is the allocation of permanent objects.
The scope of <CODE>with-transient-objects</CODE> should be as small as possible, and
the user has to make sure that code that wasn't explicitly written to
account for transient objects will continue to work correctly.
</DL>
</P><P>

<A NAME="IDX957"></A>
<DL>
<DT><U>Function:</U> <B>wrap-boolean</B> <I>((value BOOLEAN)) : BOOLEAN-WRAPPER</I>
<DD>Return a literal object whose value is the BOOLEAN <VAR>value</VAR>.
</DL>
</P><P>

<A NAME="IDX958"></A>
<DL>
<DT><U>Function:</U> <B>wrap-function-code</B> <I>((value FUNCTION-CODE)) : FUNCTION-CODE-WRAPPER</I>
<DD>Return a literal object whose value is the FUNCTION-CODE <VAR>value</VAR>.
</DL>
</P><P>

<A NAME="IDX959"></A>
<DL>
<DT><U>Function:</U> <B>wrap-method-code</B> <I>((value METHOD-CODE)) : METHOD-CODE-WRAPPER</I>
<DD>Return a literal object whose value is the METHOD-CODE <VAR>value</VAR>.
</DL>
</P><P>

<A NAME="IDX960"></A>
<DL>
<DT><U>Function:</U> <B>wrapped-type-to-type</B> <I>((self TYPE)) : TYPE</I>
<DD>Return the unwrapped type for the wrapped type <VAR>self</VAR>,
or <VAR>self</VAR> if it is not a wrapped type.
</DL>
</P><P>

<A NAME="IDX961"></A>
<DL>
<DT><U>Function:</U> <B>wrapper-value-type</B> <I>((self WRAPPER)) : TYPE</I>
<DD>Return the type of the value stored in the wrapper <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX962"></A>
<DL>
<DT><U>Function:</U> <B>write-html-escaping-url-special-characters</B> <I>((stream NATIVE-OUTPUT-STREAM) (input STRING)) :</I>
<DD>Writes a string and replaces unallowed URL characters according to RFC 2396
with %-format URL escape sequences.
</DL>
</P><P>

<A NAME="IDX963"></A>
<DL>
<DT><U>Method:</U> STORAGE-SLOT <B>writer</B> <I>(self) : SYMBOL</I>
<DD>Name of a method called to write the value of the slot
<VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX964"></A>
<DL>
<DT><U>Function:</U> <B>xml-declaration-form?</B> <I>((form OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>form</VAR> is a CONS headed by an XML DECLARATION tag
</DL>
</P><P>

<A NAME="IDX965"></A>
<DL>
<DT><U>Function:</U> <B>xml-doctype-form?</B> <I>((form OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>form</VAR> is a CONS headed by a DOCTYPE tag
</DL>
</P><P>

<A NAME="IDX966"></A>
<DL>
<DT><U>Function:</U> <B>xml-element-form?</B> <I>((form OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>form</VAR> is a CONS headed by an XML ELEMENT tag
</DL>
</P><P>

<A NAME="IDX967"></A>
<DL>
<DT><U>Function:</U> <B>xml-processing-instruction-form?</B> <I>((form OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>form</VAR> is a CONS headed by an XML PROCESSING INSTRUCTION tag
</DL>
</P><P>

<A NAME="IDX968"></A>
<DL>
<DT><U>Function:</U> <B>xml-processing-instruction?</B> <I>((item OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>item</VAR> is an XML processing instruction object
</DL>
</P><P>

<A NAME="IDX969"></A>
<DL>
<DT><U>Function:</U> <B>xml-token-list-to-s-expression</B> <I>((tokenList TOKENIZER-TOKEN) (doctype XML-DOCTYPE) (doctype-definition? BOOLEAN)) : OBJECT</I>
<DD>Convert the XML <VAR>tokenList</VAR> (using <VAR>doctype</VAR> for guidance) into a
representative s-expression and return the result.    The <VAR>doctype</VAR> argument is
currently only used for expansion of entity references.  It can be <CODE>null</CODE>.  The
flag <VAR>doctype-definition?</VAR> should be true only when processing the DTD definition
of a DOCTYPE tag, since it enables substitution of parameter entity values.
</P><P>

Every XML tag is represented as a cons-list starting with the tag as its header,
followed by a possibly empty list of keyword value pairs representing tag attributes,
followed by a possibly empty list of content expressions which might themselves
be XML expressions.  For example, the expression
</P><P>

    &#60;a a1=v1 a2='v2'&#62; foo &#60;b a3=v3/&#62; bar &#60;/a&#62;
</P><P>

becomes
</P><P>

   (&#60;a&#62; (&#60;a1&#62; "v1" <a2> "v2") "foo" (&#60;b&#62; (&#60;a3&#62; "v3")) "bar")
</P><P>

when represented as an s-expression.  The tag names are subtypes of XML-OBJECT
such as XML-ELEMENT, XML-LOCAL-ATTRIBUTE, XML-GLOBAL-ATTRIBUTE, etc.
?, ! and [ prefixed tags are encoded as their own subtypes of XML-OBJECT, namely
XML-PROCESSING-INSTRUCTION, XML-DECLARATION, XML-SPECIAL, XML-COMMENT, etc.
CDATA is an XML-SPECIAL tag with a name of CDATA.
</P><P>

The name is available using class accessors.
</DL>
</P><P>

<A NAME="IDX970"></A>
<DL>
<DT><U>Function:</U> <B>yield-define-stella-class</B> <I>((class CLASS)) : CONS</I>
<DD>Return a cons tree that (when evaluated) constructs
a Stella class object.
</DL>
</P><P>

<A NAME="IDX971"></A>
<DL>
<DT><U>Function:</U> <B>zero-pad-integer</B> <I>((value INTEGER) (size INTEGER)) : STRING</I>
<DD>Returns a string representing <VAR>value</VAR> of at least length
<VAR>size</VAR>, padded if necessary with 0 characters.
</DL>
</P><P>

<A NAME="Function Index"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Hans Chalupsky</I> on <I>May, 21  2006</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>
</FONT>

</BODY>
</HTML>
