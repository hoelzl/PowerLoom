<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on October, 28  2003 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>STELLA Manual: Library Functions</TITLE>

<META NAME="description" CONTENT="STELLA Manual: Library Functions">
<META NAME="keywords" CONTENT="STELLA Manual: Library Functions">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC30"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_5.html#SEC29"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC31"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_5.html#SEC29"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 6. Library Functions </H1>
<!--docid::SEC30::-->
<P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC31">6.1 Basic Constants and Predicates</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC32">6.2 Numbers</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC33">6.3 Characters</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC34">6.4 Strings</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC35">6.5 <CODE>CONS</CODE> Lists and Trees</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC37">6.6 Lists</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC39">6.7 Property and Key-Value Lists</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC40">6.8 Vectors</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC41">6.9 Hash Tables</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC42">6.10 Key Value Maps</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC43">6.11 Hash Sets</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC44">6.12 Iterators</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC45">6.13 Symbols</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC46">6.14 Context and Modules</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC47">6.15 Input and Output</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC48">6.16 Files</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC49">6.17 Dates and Times</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC50">6.18 XML Support</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC51">6.19 Miscellaneous</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Basic Constants and Predicates"></A>
<HR SIZE="6">
<A NAME="SEC31"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC32"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.1 Basic Constants and Predicates </H2>
<!--docid::SEC31::-->
<P>

<A NAME="IDX8"></A>
<DL>
<DT><U>Constant:</U> <B>true</B> <I>: BOOLEAN</I>
<DD>Represents the boolean true truth value.
</DL>
</P><P>

<A NAME="IDX9"></A>
<DL>
<DT><U>Constant:</U> <B>false</B> <I>: BOOLEAN</I>
<DD>Represents the boolean false truth value.
</DL>
</P><P>

<A NAME="IDX10"></A>
<DL>
<DT><U>Method:</U> <B>null?</B> <I>((x OBJECT)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is undefined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX11"></A>
<DL>
<DT><U>Method:</U> <B>null?</B> <I>((x SECOND-CLASS-OBJECT)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is undefined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX12"></A>
<DL>
<DT><U>Method:</U> <B>null?</B> <I>((x NATIVE-VECTOR)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is undefined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX13"></A>
<DL>
<DT><U>Method:</U> <B>null?</B> <I>((x STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is undefined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX14"></A>
<DL>
<DT><U>Method:</U> <B>null?</B> <I>((x MUTABLE-STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is undefined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX15"></A>
<DL>
<DT><U>Method:</U> <B>null?</B> <I>((x CHARACTER)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is undefined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX16"></A>
<DL>
<DT><U>Method:</U> <B>null?</B> <I>((x CODE)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is undefined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX17"></A>
<DL>
<DT><U>Method:</U> <B>null?</B> <I>((x INTEGER)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is undefined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX18"></A>
<DL>
<DT><U>Method:</U> <B>null?</B> <I>((x FLOAT)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is undefined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX19"></A>
<DL>
<DT><U>Method:</U> <B>defined?</B> <I>((x OBJECT)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is defined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX20"></A>
<DL>
<DT><U>Method:</U> <B>defined?</B> <I>((x SECOND-CLASS-OBJECT)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is defined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX21"></A>
<DL>
<DT><U>Method:</U> <B>defined?</B> <I>((x NATIVE-VECTOR)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is defined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX22"></A>
<DL>
<DT><U>Method:</U> <B>defined?</B> <I>((x STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is defined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX23"></A>
<DL>
<DT><U>Method:</U> <B>defined?</B> <I>((x MUTABLE-STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is defined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX24"></A>
<DL>
<DT><U>Method:</U> <B>defined?</B> <I>((x CHARACTER)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is defined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX25"></A>
<DL>
<DT><U>Method:</U> <B>defined?</B> <I>((x CODE)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is defined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX26"></A>
<DL>
<DT><U>Method:</U> <B>defined?</B> <I>((x INTEGER)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is defined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX27"></A>
<DL>
<DT><U>Method:</U> <B>defined?</B> <I>((x FLOAT)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is defined (handled specially by all translators).
</DL>
</P><P>

<A NAME="IDX28"></A>
<DL>
<DT><U>Function:</U> <B>eq?</B> <I>((x UNKNOWN) (y UNKNOWN)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> and <VAR>y</VAR> are literally the same object (or
simple number).  Analogue to the Common Lisp EQL and C++ and Java's ==.
</DL>
</P><P>

<A NAME="IDX29"></A>
<DL>
<DT><U>Function:</U> <B>eql?</B> <I>((x OBJECT) (y OBJECT)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> and <VAR>y</VAR> are <CODE>eq?</CODE> or equivalent literals
such as strings that also might be wrapped in non-identical wrappers.  For
the case where <VAR>x</VAR> or <VAR>y</VAR> are plain literals such as strings or integers, the
STELLA translator substitutes the equality test appropriate for the particular
target language and does not actually call this function.  For cases where
<VAR>x</VAR> or <VAR>y</VAR> are known to be of type STANDARD-OBJECT, the STELLA translator
substitutes the faster <CODE>eq?</CODE> test inline.
</DL>
</P><P>

<A NAME="IDX30"></A>
<DL>
<DT><U>Function:</U> <B>equal?</B> <I>((x OBJECT) (y OBJECT)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> and <VAR>y</VAR> are <CODE>eql?</CODE> or considered equal
by a user-defined <CODE>object-equal?</CODE> method.  This implements a fully extensible
equality test similar to Java's <CODE>equals</CODE> method.  Note that writers of custom
<CODE>object-equal?</CODE> methods must also implement a corresponding <CODE>equal-hash-code</CODE>
method.
</DL>
</P><P>

<A NAME="IDX31"></A>
<DL>
<DT><U>Method:</U> <B>object-equal?</B> <I>((x OBJECT) (y OBJECT)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> and <VAR>y</VAR> are <CODE>eq?</CODE>.
</DL>
</P><P>

<A NAME="IDX32"></A>
<DL>
<DT><U>Method:</U> <B>object-equal?</B> <I>((x WRAPPER) (y OBJECT)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> and <VAR>y</VAR> are literal wrappers whose
literals are considered <CODE>eql?</CODE>.
</DL>
</P><P>

<A NAME="Numbers"></A>
<HR SIZE="6">
<A NAME="SEC32"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC31"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC33"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.2 Numbers </H2>
<!--docid::SEC32::-->
<P>

<A NAME="IDX33"></A>
<DL>
<DT><U>Constant:</U> <B>pi</B> <I>: FLOAT</I>
<DD>A float approximation of the mathematical constant pi.
</DL>
</P><P>

<A NAME="IDX34"></A>
<DL>
<DT><U>Function:</U> <B>+</B> <I>(&#38;rest (arguments NUMBER)) : NUMBER</I>
<DD>Return the sum of all <VAR>arguments</VAR>.
</DL>
</P><P>

<A NAME="IDX35"></A>
<DL>
<DT><U>Function:</U> <B>-</B> <I>((x NUMBER) &#38;rest (arguments NUMBER)) : NUMBER</I>
<DD>If only <VAR>x</VAR> was supplied return the result of 0 - <VAR>x</VAR>.
Otherwise, return the result of (...((<VAR>x</VAR> - arg1) - arg2) - ... - argN).
</DL>
</P><P>

<A NAME="IDX36"></A>
<DL>
<DT><U>Function:</U> <B>*</B> <I>(&#38;rest (arguments NUMBER)) : NUMBER</I>
<DD>Return the product of all <VAR>arguments</VAR>.
</DL>
</P><P>

<A NAME="IDX37"></A>
<DL>
<DT><U>Function:</U> <B>/</B> <I>((x NUMBER) &#38;rest (arguments NUMBER)) : NUMBER</I>
<DD>If only <VAR>x</VAR> was supplied return the result of 1 / <VAR>x</VAR>.
Otherwise, return the result of (...((<VAR>x</VAR> / arg1) / arg2 ) / ... / argN).
</DL>
</P><P>

<A NAME="IDX38"></A>
<DL>
<DT><U>Macro:</U> <B>1+</B> <I>((expression OBJECT)) : OBJECT</I>
<DD>Add 1 to <VAR>expression</VAR> and return the result.
</DL>
</P><P>

<A NAME="IDX39"></A>
<DL>
<DT><U>Macro:</U> <B>1-</B> <I>((expression OBJECT)) : OBJECT</I>
<DD>Subtract 1 from <VAR>expression</VAR> and return the result.
</DL>
</P><P>

<A NAME="IDX40"></A>
<DL>
<DT><U>Macro:</U> <B>++</B> <I>((place OBJECT) &#38;body (increment CONS)) : OBJECT</I>
<DD>Increment the value of <VAR>place</VAR> and return the result.
<VAR>place</VAR> can be either a variable name or a slot reference.  Increment by
the optional <VAR>increment</VAR> (which can be a float) or 1 otherwise.
</DL>
</P><P>

<A NAME="IDX41"></A>
<DL>
<DT><U>Macro:</U> <B>--</B> <I>((place OBJECT) &#38;body (decrement CONS)) : OBJECT</I>
<DD>Decrement the value of <VAR>place</VAR> and return the result.
<VAR>place</VAR> can be either a variable name or a slot reference.  Decrement by
the optional <VAR>decrement</VAR> (which can be a float) or 1 otherwise.
</DL>
</P><P>

<A NAME="IDX42"></A>
<DL>
<DT><U>Function:</U> <B>=</B> <I>((x NUMBER) (y NUMBER)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> and <VAR>y</VAR> are numbers of exactly the same magnitude.
</DL>
</P><P>

<A NAME="IDX43"></A>
<DL>
<DT><U>Function:</U> <B>&#60;</B> <I>((x NUMBER) (y NUMBER)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is less than <VAR>y</VAR>.
</DL>
</P><P>

<A NAME="IDX44"></A>
<DL>
<DT><U>Function:</U> <B>&#60;=</B> <I>((x NUMBER) (y NUMBER)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is less than or equal to <VAR>y</VAR>.
</DL>
</P><P>

<A NAME="IDX45"></A>
<DL>
<DT><U>Function:</U> <B>&#62;=</B> <I>((x NUMBER) (y NUMBER)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is greater than or equal to <VAR>y</VAR>.
</DL>
</P><P>

<A NAME="IDX46"></A>
<DL>
<DT><U>Function:</U> <B>&#62;</B> <I>((x NUMBER) (y NUMBER)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is greater than <VAR>y</VAR>.
</DL>
</P><P>

<A NAME="IDX47"></A>
<DL>
<DT><U>Function:</U> <B>zero?</B> <I>((x INTEGER)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is 0.
</DL>
</P><P>

<A NAME="IDX48"></A>
<DL>
<DT><U>Function:</U> <B>plus?</B> <I>((x INTEGER)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is greater than 0.
</DL>
</P><P>

<A NAME="IDX49"></A>
<DL>
<DT><U>Function:</U> <B>even?</B> <I>((x INTEGER)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is an even number.
</DL>
</P><P>

<A NAME="IDX50"></A>
<DL>
<DT><U>Function:</U> <B>odd?</B> <I>((x INTEGER)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is an odd number.
</DL>
</P><P>

<A NAME="IDX51"></A>
<DL>
<DT><U>Function:</U> <B>div</B> <I>((x INTEGER) (y INTEGER)) : INTEGER</I>
<DD>Return the integer quotient from dividing <VAR>x</VAR> by <VAR>y</VAR>.
</DL>
</P><P>

<A NAME="IDX52"></A>
<DL>
<DT><U>Function:</U> <B>rem</B> <I>((x INTEGER) (y INTEGER)) : INTEGER</I>
<DD>Return the remainder from dividing <VAR>x</VAR> by <VAR>y</VAR>.  The
sign of the result is always the same as the sign of <VAR>x</VAR>.  This has slightly
different behavior than the <CODE>mod</CODE> function, and has less overhead in C++ and
Java, which don't have direct support for a true modulus function.
</DL>
</P><P>

<A NAME="IDX53"></A>
<DL>
<DT><U>Function:</U> <B>mod</B> <I>((x INTEGER) (modulus INTEGER)) : INTEGER</I>
<DD>True modulus.  Return the result of <VAR>x</VAR> mod <CODE>modulo</CODE>.
Note: In C++ and Java, <CODE>mod</CODE> has more overhead than the similar
function <CODE>rem</CODE>.  The  answers returned by <CODE>mod</CODE> and <CODE>rem</CODE> are only
different when the signs of <VAR>x</VAR> and <CODE>modulo</CODE> are different.
</DL>
</P><P>

<A NAME="IDX54"></A>
<DL>
<DT><U>Function:</U> <B>gcd</B> <I>((x INTEGER) (y INTEGER)) : INTEGER</I>
<DD>Return the greatest common divisor of <VAR>x</VAR> and <VAR>y</VAR>.
</DL>
</P><P>

<A NAME="IDX55"></A>
<DL>
<DT><U>Function:</U> <B>ceiling</B> <I>((n NUMBER)) : INTEGER</I>
<DD>Return the smallest integer &#62;= <VAR>n</VAR>.
</DL>
</P><P>

<A NAME="IDX56"></A>
<DL>
<DT><U>Function:</U> <B>floor</B> <I>((n NUMBER)) : INTEGER</I>
<DD>Return the biggest integer &#60;= <VAR>n</VAR>.
</DL>
</P><P>

<A NAME="IDX57"></A>
<DL>
<DT><U>Function:</U> <B>round</B> <I>((n NUMBER)) : INTEGER</I>
<DD>Round <VAR>n</VAR> to the closest integer and return the result.
</DL>
</P><P>

<A NAME="IDX58"></A>
<DL>
<DT><U>Method:</U> <B>abs</B> <I>((x INTEGER)) : INTEGER</I>
<DD>Return the absolute value of <VAR>x</VAR>.
</DL>
</P><P>

<A NAME="IDX59"></A>
<DL>
<DT><U>Method:</U> <B>abs</B> <I>((x FLOAT)) : FLOAT</I>
<DD>Return the absolute value of <VAR>x</VAR>.
</DL>
</P><P>

<A NAME="IDX60"></A>
<DL>
<DT><U>Function:</U> <B>min</B> <I>((x INTEGER) (y INTEGER)) : INTEGER</I>
<DD>Return the minimum of <VAR>x</VAR> and <VAR>y</VAR>.  If either is NULL, return the other.
</DL>
</P><P>

<A NAME="IDX61"></A>
<DL>
<DT><U>Function:</U> <B>max</B> <I>((x INTEGER) (y INTEGER)) : INTEGER</I>
<DD>Return the maximum of <VAR>x</VAR> and <VAR>y</VAR>.  If either is NULL, return the other.
</DL>
</P><P>

<A NAME="IDX62"></A>
<DL>
<DT><U>Function:</U> <B>sqrt</B> <I>((n FLOAT)) : FLOAT</I>
<DD>Return the square root of <VAR>n</VAR>.
</DL>
</P><P>

<A NAME="IDX63"></A>
<DL>
<DT><U>Function:</U> <B>exp</B> <I>((n FLOAT)) : FLOAT</I>
<DD>Return the e to the power <VAR>n</VAR>.
</DL>
</P><P>

<A NAME="IDX64"></A>
<DL>
<DT><U>Function:</U> <B>expt</B> <I>((x FLOAT) (y FLOAT)) : FLOAT</I>
<DD>Return <VAR>x</VAR> ^ <VAR>y</VAR>.
</DL>
</P><P>

<A NAME="IDX65"></A>
<DL>
<DT><U>Function:</U> <B>log</B> <I>((n FLOAT)) : FLOAT</I>
<DD>Return the natural logarithm (base e) of <VAR>n</VAR>.
</DL>
</P><P>

<A NAME="IDX66"></A>
<DL>
<DT><U>Function:</U> <B>log10</B> <I>((n FLOAT)) : FLOAT</I>
<DD>Return the logarithm (base 10) of <VAR>n</VAR>.
</DL>
</P><P>

<A NAME="IDX67"></A>
<DL>
<DT><U>Function:</U> <B>sin</B> <I>((n FLOAT)) : FLOAT</I>
<DD>Return the sine of <VAR>n</VAR> radians.
</DL>
</P><P>

<A NAME="IDX68"></A>
<DL>
<DT><U>Function:</U> <B>cos</B> <I>((n FLOAT)) : FLOAT</I>
<DD>Return the cosine of <VAR>n</VAR> radians.
</DL>
</P><P>

<A NAME="IDX69"></A>
<DL>
<DT><U>Function:</U> <B>tan</B> <I>((n FLOAT)) : FLOAT</I>
<DD>Return the tangent of <VAR>n</VAR> radians.
</DL>
</P><P>

<A NAME="IDX70"></A>
<DL>
<DT><U>Function:</U> <B>asin</B> <I>((n FLOAT)) : FLOAT</I>
<DD>Return the arcsine of <VAR>n</VAR> in radians.
</DL>
</P><P>

<A NAME="IDX71"></A>
<DL>
<DT><U>Function:</U> <B>acos</B> <I>((n FLOAT)) : FLOAT</I>
<DD>Return the arccosine of <VAR>n</VAR> in radians.
</DL>
</P><P>

<A NAME="IDX72"></A>
<DL>
<DT><U>Function:</U> <B>atan</B> <I>((n FLOAT)) : FLOAT</I>
<DD>Return the arc tangent of <VAR>n</VAR> in radians.
</DL>
</P><P>

<A NAME="IDX73"></A>
<DL>
<DT><U>Function:</U> <B>atan2</B> <I>((x FLOAT) (y FLOAT)) : FLOAT</I>
<DD>Return the arc tangent of <VAR>x</VAR> / <VAR>y</VAR> in radians.
</DL>
</P><P>

<A NAME="IDX74"></A>
<DL>
<DT><U>Function:</U> <B>random</B> <I>((n INTEGER)) : INTEGER</I>
<DD>Generate a random integer in the interval [0..n-1].
<VAR>n</VAR> must be &#60;= 2^15.
</DL>
</P><P>

<A NAME="IDX75"></A>
<DL>
<DT><U>Function:</U> <B>integer-to-string</B> <I>((i INTEGER)) : STRING</I>
<DD>Print <VAR>i</VAR> to a string and return the result.  This is more
efficient than using a string stream.
</DL>
</P><P>

<A NAME="IDX76"></A>
<DL>
<DT><U>Function:</U> <B>string-to-integer</B> <I>((string STRING)) : INTEGER</I>
<DD>Convert a <VAR>string</VAR> representation of an integer into an integer.
</DL>
</P><P>

<A NAME="IDX77"></A>
<DL>
<DT><U>Function:</U> <B>float-to-string</B> <I>((f FLOAT)) : STRING</I>
<DD>Print <VAR>f</VAR> to a string and return the result.  This is more
efficient than using a string stream.
</DL>
</P><P>

<A NAME="IDX78"></A>
<DL>
<DT><U>Function:</U> <B>string-to-float</B> <I>((string STRING)) : FLOAT</I>
<DD>Convert a <VAR>string</VAR> representation of a float into a float.
</DL>
</P><P>

<A NAME="IDX79"></A>
<DL>
<DT><U>Function:</U> <B>format-float</B> <I>((f FLOAT) (nDecimals INTEGER)) : STRING</I>
<DD>Print <VAR>f</VAR> in fixed-point format with <VAR>nDecimals</VAR> behind the decimal point
and return the result as a string.
</DL>
</P><P>

<A NAME="IDX80"></A>
<DL>
<DT><U>Function:</U> <B>wrap-integer</B> <I>((value INTEGER)) : INTEGER-WRAPPER</I>
<DD>Return a literal object whose value is the INTEGER <VAR>value</VAR>.
</DL>
</P><P>

<A NAME="IDX81"></A>
<DL>
<DT><U>Function:</U> <B>unwrap-integer</B> <I>((wrapper INTEGER-WRAPPER)) : INTEGER</I>
<DD>Unwrap <VAR>wrapper</VAR> and return the result.
Return NULL if <VAR>wrapper</VAR> is NULL.
</DL>
</P><P>

<A NAME="IDX82"></A>
<DL>
<DT><U>Function:</U> <B>wrap-float</B> <I>((value FLOAT)) : FLOAT-WRAPPER</I>
<DD>Return a literal object whose value is the FLOAT <VAR>value</VAR>.
</DL>
</P><P>

<A NAME="IDX83"></A>
<DL>
<DT><U>Function:</U> <B>unwrap-float</B> <I>((wrapper FLOAT-WRAPPER)) : FLOAT</I>
<DD>Unwrap <VAR>wrapper</VAR> and return the result.
Return NULL if <VAR>wrapper</VAR> is NULL.
</DL>
</P><P>

<A NAME="Characters"></A>
<HR SIZE="6">
<A NAME="SEC33"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC32"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC34"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.3 Characters </H2>
<!--docid::SEC33::-->
<P>

<A NAME="IDX84"></A>
<DL>
<DT><U>Function:</U> <B>character-code</B> <I>((ch CHARACTER)) : INTEGER</I>
<DD>Return the 8-bit ASCII code of <VAR>ch</VAR> as an integer.
</DL>
</P><P>

<A NAME="IDX85"></A>
<DL>
<DT><U>Function:</U> <B>code-character</B> <I>((code INTEGER)) : CHARACTER</I>
<DD>Return the character encoded by <VAR>code</VAR> (0 &#60;= <VAR>code</VAR> &#60;= 255).
</DL>
</P><P>

<A NAME="IDX86"></A>
<DL>
<DT><U>Function:</U> <B>digit-character?</B> <I>((ch CHARACTER)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>ch</VAR> represents a digit.
</DL>
</P><P>

<A NAME="IDX87"></A>
<DL>
<DT><U>Function:</U> <B>letter-character?</B> <I>((ch CHARACTER)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>ch</VAR> represents a letter.
</DL>
</P><P>

<A NAME="IDX88"></A>
<DL>
<DT><U>Function:</U> <B>upper-case-character?</B> <I>((ch CHARACTER)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>ch</VAR> represents an upper-case character.
</DL>
</P><P>

<A NAME="IDX89"></A>
<DL>
<DT><U>Function:</U> <B>lower-case-character?</B> <I>((ch CHARACTER)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>ch</VAR> represents a lower-case character.
</DL>
</P><P>

<A NAME="IDX90"></A>
<DL>
<DT><U>Function:</U> <B>white-space-character?</B> <I>((ch CHARACTER)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>ch</VAR> is a white space character.
</DL>
</P><P>

<A NAME="IDX91"></A>
<DL>
<DT><U>Function:</U> <B>character-downcase</B> <I>((ch CHARACTER)) : CHARACTER</I>
<DD>If <VAR>ch</VAR> is lowercase, return its uppercase version,
otherwise, return <VAR>ch</VAR> unmodified.
</DL>
</P><P>

<A NAME="IDX92"></A>
<DL>
<DT><U>Function:</U> <B>character-upcase</B> <I>((ch CHARACTER)) : CHARACTER</I>
<DD>If <VAR>ch</VAR> is uppercase, return its lowercase version,
otherwise, return <VAR>ch</VAR> unmodified.  If only the first character of
a sequence of characters is to be capitalized, <CODE>character-capitalize</CODE>
should be used instead.
</DL>
</P><P>

<A NAME="IDX93"></A>
<DL>
<DT><U>Function:</U> <B>character-capitalize</B> <I>((ch CHARACTER)) : CHARACTER</I>
<DD>Return the capitalized character for <VAR>ch</VAR>.  This is generally the same
as the uppercase character, except for obscure non-English characters in Java.  It should
be used if only the first character of a sequence of characters is to be capitalized.
</DL>
</P><P>

<A NAME="IDX94"></A>
<DL>
<DT><U>Function:</U> <B>character-to-string</B> <I>((c CHARACTER)) : STRING</I>
<DD>Convert <VAR>c</VAR> into a one-element string and return the result.
</DL>
</P><P>

<A NAME="IDX95"></A>
<DL>
<DT><U>Function:</U> <B>wrap-character</B> <I>((value CHARACTER)) : CHARACTER-WRAPPER</I>
<DD>Return a literal object whose value is the CHARACTER <VAR>value</VAR>.
</DL>
</P><P>

<A NAME="IDX96"></A>
<DL>
<DT><U>Function:</U> <B>unwrap-character</B> <I>((wrapper CHARACTER-WRAPPER)) : CHARACTER</I>
<DD>Unwrap <VAR>wrapper</VAR> and return the result.
Return NULL if <VAR>wrapper</VAR> is NULL.
</DL>
</P><P>

<A NAME="Strings"></A>
<HR SIZE="6">
<A NAME="SEC34"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC33"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC35"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.4 Strings </H2>
<!--docid::SEC34::-->
<P>

<A NAME="IDX97"></A>
<DL>
<DT><U>Function:</U> <B>string-eql?</B> <I>((x STRING) (y STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> and <VAR>y</VAR> are equal strings or are both undefined.  This
test is substituted automatically by the STELLA translator if <CODE>eql?</CODE> is applied
to strings.
</DL>
</P><P>

<A NAME="IDX98"></A>
<DL>
<DT><U>Function:</U> <B>string-equal?</B> <I>((x STRING) (y STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> and <VAR>y</VAR> are equal strings ignoring character case or
are both undefined.
</DL>
</P><P>

<A NAME="IDX99"></A>
<DL>
<DT><U>Method:</U> <B>empty?</B> <I>((x STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is the empty string ""
</DL>
</P><P>

<A NAME="IDX100"></A>
<DL>
<DT><U>Method:</U> <B>non-empty?</B> <I>((x STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is not the empty string ""
</DL>
</P><P>

<A NAME="IDX101"></A>
<DL>
<DT><U>Function:</U> <B>string-compare</B> <I>((x STRING) (y STRING) (case-sensitive? BOOLEAN)) : INTEGER</I>
<DD>Compare <VAR>x</VAR> and <VAR>y</VAR> lexicographically, and return -1, 0, 
or 1, depending on whether <VAR>x</VAR> is less than, equal, or greater than <VAR>y</VAR>.
If <VAR>case-sensitive?</VAR> is true, then case does matter for the comparison
</DL>
</P><P>

<A NAME="IDX102"></A>
<DL>
<DT><U>Function:</U> <B>string&#60;</B> <I>((x STRING) (y STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is lexicographically &#60; <VAR>y</VAR>, considering case.
</DL>
</P><P>

<A NAME="IDX103"></A>
<DL>
<DT><U>Function:</U> <B>string&#60;=</B> <I>((x STRING) (y STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is lexicographically &#60;= <VAR>y</VAR>, considering case.
</DL>
</P><P>

<A NAME="IDX104"></A>
<DL>
<DT><U>Function:</U> <B>string&#62;=</B> <I>((x STRING) (y STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is lexicographically &#62;= <VAR>y</VAR>, considering case.
</DL>
</P><P>

<A NAME="IDX105"></A>
<DL>
<DT><U>Function:</U> <B>string&#62;</B> <I>((x STRING) (y STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is lexicographically &#62; <VAR>y</VAR>, considering case.
</DL>
</P><P>

<A NAME="IDX106"></A>
<DL>
<DT><U>Function:</U> <B>string-less?</B> <I>((x STRING) (y STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is lexicographically &#60; <VAR>y</VAR>, ignoring case.
</DL>
</P><P>

<A NAME="IDX107"></A>
<DL>
<DT><U>Function:</U> <B>string-less-equal?</B> <I>((x STRING) (y STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is lexicographically &#60;= <VAR>y</VAR>, ignoring case.
</DL>
</P><P>

<A NAME="IDX108"></A>
<DL>
<DT><U>Function:</U> <B>string-greater-equal?</B> <I>((x STRING) (y STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is lexicographically &#62;= <VAR>y</VAR>, ignoring case.
</DL>
</P><P>

<A NAME="IDX109"></A>
<DL>
<DT><U>Function:</U> <B>string-greater?</B> <I>((x STRING) (y STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is lexicographically &#62; <VAR>y</VAR>, ignoring case.
</DL>
</P><P>

<A NAME="IDX110"></A>
<DL>
<DT><U>Function:</U> <B>all-upper-case-string?</B> <I>((s STRING)) : BOOLEAN</I>
<DD>Return TRUE if all letters in <VAR>s</VAR> are upper case.
</DL>
</P><P>

<A NAME="IDX111"></A>
<DL>
<DT><U>Function:</U> <B>all-lower-case-string?</B> <I>((s STRING)) : BOOLEAN</I>
<DD>Return TRUE if all letters in <VAR>s</VAR> are lower case.
</DL>
</P><P>

<A NAME="IDX112"></A>
<DL>
<DT><U>Function:</U> <B>make-string</B> <I>((size INTEGER) (initchar CHARACTER)) : STRING</I>
<DD>Return a new string filled with <VAR>size</VAR> <VAR>initchar</VAR>s.
</DL>
</P><P>

<A NAME="IDX113"></A>
<DL>
<DT><U>Function:</U> <B>make-mutable-string</B> <I>((size INTEGER) (initchar CHARACTER)) : MUTABLE-STRING</I>
<DD>Return a new mutable string filled with <VAR>size</VAR> <VAR>initchar</VAR>s.
</DL>
</P><P>

<A NAME="IDX114"></A>
<DL>
<DT><U>Function:</U> <B>make-raw-mutable-string</B> <I>((size INTEGER)) : MUTABLE-STRING</I>
<DD>Return a new uninitialized mutable string of <VAR>size</VAR>.
</DL>
</P><P>

<A NAME="IDX115"></A>
<DL>
<DT><U>Method:</U> <B>first</B> <I>((self STRING)) : CHARACTER</I>
<DD>Return the first character of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX116"></A>
<DL>
<DT><U>Method:</U> <B>first</B> <I>((self MUTABLE-STRING)) : CHARACTER</I>
<DD>Return the first character of <VAR>self</VAR> (settable via <CODE>setf</CODE>).
</DL>
</P><P>

<A NAME="IDX117"></A>
<DL>
<DT><U>Method:</U> <B>second</B> <I>((self STRING)) : CHARACTER</I>
<DD>Return the second character of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX118"></A>
<DL>
<DT><U>Method:</U> <B>second</B> <I>((self MUTABLE-STRING)) : CHARACTER</I>
<DD>Return the second character of <VAR>self</VAR> (settable via <CODE>setf</CODE>).
</DL>
</P><P>

<A NAME="IDX119"></A>
<DL>
<DT><U>Method:</U> <B>third</B> <I>((self STRING)) : CHARACTER</I>
<DD>Return the third character of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX120"></A>
<DL>
<DT><U>Method:</U> <B>third</B> <I>((self MUTABLE-STRING)) : CHARACTER</I>
<DD>Return the third character of <VAR>self</VAR> (settable via <CODE>setf</CODE>).
</DL>
</P><P>

<A NAME="IDX121"></A>
<DL>
<DT><U>Method:</U> <B>fourth</B> <I>((self STRING)) : CHARACTER</I>
<DD>Return the fourth character of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX122"></A>
<DL>
<DT><U>Method:</U> <B>fourth</B> <I>((self MUTABLE-STRING)) : CHARACTER</I>
<DD>Return the fourth character of <VAR>self</VAR> (settable via <CODE>setf</CODE>).
</DL>
</P><P>

<A NAME="IDX123"></A>
<DL>
<DT><U>Method:</U> <B>fifth</B> <I>((self STRING)) : CHARACTER</I>
<DD>Return the fifth character of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX124"></A>
<DL>
<DT><U>Method:</U> <B>fifth</B> <I>((self MUTABLE-STRING)) : CHARACTER</I>
<DD>Return the fifth character of <VAR>self</VAR> (settable via <CODE>setf</CODE>).
</DL>
</P><P>

<A NAME="IDX125"></A>
<DL>
<DT><U>Method:</U> <B>nth</B> <I>((self STRING) (position INTEGER)) : CHARACTER</I>
<DD>Return the character in <VAR>self</VAR> at <VAR>position</VAR>.
</DL>
</P><P>

<A NAME="IDX126"></A>
<DL>
<DT><U>Method:</U> <B>nth</B> <I>((self MUTABLE-STRING) (position INTEGER)) : CHARACTER</I>
<DD>Return the character in <VAR>self</VAR> at <VAR>position</VAR>.
</DL>
</P><P>

<A NAME="IDX127"></A>
<DL>
<DT><U>Method:</U> <B>rest</B> <I>((self STRING)) : STRING</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX128"></A>
<DL>
<DT><U>Method:</U> <B>length</B> <I>((self STRING)) : INTEGER</I>
<DD>Return the length of the string <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX129"></A>
<DL>
<DT><U>Method:</U> <B>length</B> <I>((self MUTABLE-STRING)) : INTEGER</I>
<DD>Return the length of the string <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX130"></A>
<DL>
<DT><U>Method:</U> <B>member?</B> <I>((self STRING) (char CHARACTER)) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX131"></A>
<DL>
<DT><U>Method:</U> <B>position</B> <I>((string STRING) (character CHARACTER) (start INTEGER)) : INTEGER</I>
<DD>Return the position of <VAR>character</VAR> within <VAR>string</VAR> (counting
from zero); or return NULL if <VAR>character</VAR> does not occur within <VAR>string</VAR>.
If <VAR>start</VAR> was supplied as non-NULL, only consider the substring starting
at <VAR>start</VAR>, however, the returned position will always be relative to the
entire string.
</DL>
</P><P>

<A NAME="IDX132"></A>
<DL>
<DT><U>Function:</U> <B>string-search</B> <I>((string STRING) (substring STRING) (start INTEGER)) : INTEGER</I>
<DD>Return start position of the left-most occurrence of
<VAR>substring</VAR> in <VAR>string</VAR>, beginning from <VAR>start</VAR>.  Return NULL if it is not
a substring.
</DL>
</P><P>

<A NAME="IDX133"></A>
<DL>
<DT><U>Method:</U> <B>copy</B> <I>((string STRING)) : STRING</I>
<DD>Return a copy of <VAR>string</VAR>.
</DL>
</P><P>

<A NAME="IDX134"></A>
<DL>
<DT><U>Function:</U> <B>string-upcase</B> <I>((string STRING)) : STRING</I>
<DD>Return an upper-case copy of <VAR>string</VAR>.
</DL>
</P><P>

<A NAME="IDX135"></A>
<DL>
<DT><U>Function:</U> <B>string-downcase</B> <I>((string STRING)) : STRING</I>
<DD>Return a lower-case copy of <VAR>string</VAR>.
</DL>
</P><P>

<A NAME="IDX136"></A>
<DL>
<DT><U>Function:</U> <B>string-capitalize</B> <I>((string STRING)) : STRING</I>
<DD>Return a capitalized version of <VAR>string</VAR>.
</DL>
</P><P>

<A NAME="IDX137"></A>
<DL>
<DT><U>Method:</U> <B>concatenate</B> <I>((string1 STRING) (string2 STRING) &#38;rest (otherStrings STRING)) : STRING</I>
<DD>Return a new string representing the concatenation
of <VAR>string1</VAR>, <VAR>string2</VAR>, and <VAR>otherStrings</VAR>.  The two mandatory parameters
allow us to optimize the common binary case by not relying on the somewhat
less efficient variable arguments mechanism.
</DL>
</P><P>

<A NAME="IDX138"></A>
<DL>
<DT><U>Method:</U> <B>subsequence</B> <I>((string STRING) (start INTEGER) (end INTEGER)) : STRING</I>
<DD>Return a substring of <VAR>string</VAR> beginning at position <VAR>start</VAR>
and ending up to but not including position <VAR>end</VAR>, counting from zero.  An
<VAR>end</VAR> value of NULL stands for the rest of the string.
</DL>
</P><P>

<A NAME="IDX139"></A>
<DL>
<DT><U>Method:</U> <B>remove</B> <I>((string STRING) (char CHARACTER)) : STRING</I>
<DD>Remove all occurences of <VAR>char</VAR> from <VAR>string</VAR>.
</DL>
</P><P>

<A NAME="IDX140"></A>
<DL>
<DT><U>Method:</U> <B>substitute</B> <I>((self STRING) (new-char CHARACTER) (old-char CHARACTER)) : STRING</I>
<DD>Substitute all occurences of <VAR>old-char</VAR> with <VAR>new-char</VAR>
in the string <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX141"></A>
<DL>
<DT><U>Method:</U> <B>substitute</B> <I>((self MUTABLE-STRING) (new-char CHARACTER) (old-char CHARACTER)) : MUTABLE-STRING</I>
<DD>Substitute all occurences of <VAR>old-char</VAR> with <VAR>new-char</VAR>
in the string <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX142"></A>
<DL>
<DT><U>Function:</U> <B>replace-substrings</B> <I>((string STRING) (new STRING) (old STRING)) : STRING</I>
<DD>Replace all occurrences of <VAR>old</VAR> in <VAR>string</VAR> with <VAR>new</VAR>.
</DL>
</P><P>

<A NAME="IDX143"></A>
<DL>
<DT><U>Function:</U> <B>insert-string</B> <I>((source STRING) (start INTEGER) (end INTEGER) (target MUTABLE-STRING) (target-index INTEGER) (case-conversion KEYWORD)) : INTEGER</I>
<DD>Inserts characters from <VAR>source</VAR> begining at <VAR>start</VAR> and
ending at <VAR>end</VAR> into <VAR>target</VAR> starting at <VAR>target-index</VAR>.  If <VAR>end</VAR> is <CODE>null</CODE>,
then the entire length of the string is used. The copy of characters is affected
by the <VAR>case-conversion</VAR> keyword which should be one of
   :UPCASE :DOWNCASE :CAPITALIZE :PRESERVE.
</P><P>

The final value of target-index is returned.
</DL>
</P><P>

<A NAME="IDX144"></A>
<DL>
<DT><U>Function:</U> <B>wrap-string</B> <I>((value STRING)) : STRING-WRAPPER</I>
<DD>Return a literal object whose value is the STRING <VAR>value</VAR>.
</DL>
</P><P>

<A NAME="IDX145"></A>
<DL>
<DT><U>Function:</U> <B>wrap-mutable-string</B> <I>((value MUTABLE-STRING)) : MUTABLE-STRING-WRAPPER</I>
<DD>Return a literal object whose value is the MUTABLE-STRING <VAR>value</VAR>.
</DL>
</P><P>

<A NAME="IDX146"></A>
<DL>
<DT><U>Function:</U> <B>unwrap-string</B> <I>((wrapper STRING-WRAPPER)) : STRING</I>
<DD>Unwrap <VAR>wrapper</VAR> and return the result.
Return NULL if <VAR>wrapper</VAR> is NULL.
</DL>
</P><P>

<A NAME="IDX147"></A>
<DL>
<DT><U>Function:</U> <B>unwrap-mutable-string</B> <I>((wrapper MUTABLE-STRING-WRAPPER)) : MUTABLE-STRING</I>
<DD>Unwrap <VAR>wrapper</VAR> and return the result.
Return NULL if <VAR>wrapper</VAR> is NULL.
</DL>
</P><P>

<A NAME="IDX148"></A>
<DL>
<DT><U>Function:</U> <B>string-to-mutable-string</B> <I>((s STRING)) : MUTABLE-STRING</I>
<DD>Copy <VAR>s</VAR> into a mutable string with the same content.
In Lisp and C++ this simply copies <VAR>s</VAR>.
</DL>
</P><P>

<A NAME="IDX149"></A>
<DL>
<DT><U>Function:</U> <B>mutable-string-to-string</B> <I>((s MUTABLE-STRING)) : STRING</I>
<DD>Convert <VAR>s</VAR> into a regular string with the same content.
In Lisp and C++ this is a no-op.
</DL>
</P><P>

<A NAME="IDX150"></A>
<DL>
<DT><U>Function:</U> <B>integer-to-string</B> <I>((i INTEGER)) : STRING</I>
<DD>Print <VAR>i</VAR> to a string and return the result.  This is more
efficient than using a string stream.
</DL>
</P><P>

<A NAME="IDX151"></A>
<DL>
<DT><U>Function:</U> <B>string-to-integer</B> <I>((string STRING)) : INTEGER</I>
<DD>Convert a <VAR>string</VAR> representation of an integer into an integer.
</DL>
</P><P>

<A NAME="IDX152"></A>
<DL>
<DT><U>Function:</U> <B>float-to-string</B> <I>((f FLOAT)) : STRING</I>
<DD>Print <VAR>f</VAR> to a string and return the result.  This is more
efficient than using a string stream.
</DL>
</P><P>

<A NAME="IDX153"></A>
<DL>
<DT><U>Function:</U> <B>string-to-float</B> <I>((string STRING)) : FLOAT</I>
<DD>Convert a <VAR>string</VAR> representation of a float into a float.
</DL>
</P><P>

<A NAME="IDX154"></A>
<DL>
<DT><U>Function:</U> <B>format-float</B> <I>((f FLOAT) (nDecimals INTEGER)) : STRING</I>
<DD>Print <VAR>f</VAR> in fixed-point format with <VAR>nDecimals</VAR> behind the decimal point
and return the result as a string.
</DL>
</P><P>

<A NAME="IDX155"></A>
<DL>
<DT><U>Function:</U> <B>character-to-string</B> <I>((c CHARACTER)) : STRING</I>
<DD>Convert <VAR>c</VAR> into a one-element string and return the result.
</DL>
</P><P>

<A NAME="IDX156"></A>
<DL>
<DT><U>Function:</U> <B>stringify</B> <I>((expression OBJECT)) : STRING</I>
<DD>Print <VAR>expression</VAR> onto a string and return the result.
Printing is done with <CODE>*printReadably?*</CODE> set to true and with <CODE>*printPretty?*</CODE>
set to false.
</DL>
</P><P>

<A NAME="IDX157"></A>
<DL>
<DT><U>Function:</U> <B>stringify-in-module</B> <I>((tree OBJECT) (module MODULE)) : STRING</I>
<DD>Stringify a parse <VAR>tree</VAR> relative to <VAR>module</VAR>, or
<CODE>*module*</CODE> if no module is specified.
</DL>
</P><P>

<A NAME="IDX158"></A>
<DL>
<DT><U>Function:</U> <B>unstringify</B> <I>((string STRING)) : OBJECT</I>
<DD>Read a STELLA expression from <VAR>string</VAR> and return the result.
This is identical to <CODE>read-s-expression-from-string</CODE>.
</DL>
</P><P>

<A NAME="IDX159"></A>
<DL>
<DT><U>Function:</U> <B>unstringify-in-module</B> <I>((string STRING) (module MODULE)) : OBJECT</I>
<DD>Unstringify relative to <VAR>module</VAR>, or <CODE>*MODULE*</CODE> if no
module is specified.
</DL>
</P><P>

<A NAME="CONS Lists and Trees"></A>
<HR SIZE="6">
<A NAME="SEC35"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC34"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC36"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC37"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.5 <CODE>CONS</CODE> Lists and Trees </H2>
<!--docid::SEC35::-->
<P>

<A NAME="IDX160"></A>
<DL>
<DT><U>Variable:</U> <B>nil</B> <I>: CONS</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX161"></A>
<DL>
<DT><U>Method:</U> <B>empty?</B> <I>((self CONS)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> iff <VAR>self</VAR> equals <CODE>nil</CODE>.
</DL>
</P><P>

<A NAME="IDX162"></A>
<DL>
<DT><U>Method:</U> <B>non-empty?</B> <I>((self CONS)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> iff <VAR>self</VAR> is not equal to <CODE>nil</CODE>.
</DL>
</P><P>

<A NAME="IDX163"></A>
<DL>
<DT><U>Function:</U> <B>nil?</B> <I>((x OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> iff <VAR>x</VAR> equals <CODE>nil</CODE>.
</DL>
</P><P>

<A NAME="IDX164"></A>
<DL>
<DT><U>Function:</U> <B>equal-cons-trees?</B> <I>((tree1 OBJECT) (tree2 OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> iff the cons trees <VAR>tree1</VAR> and <VAR>tree2</VAR> are
structurally equivalent.  Uses an <CODE>eql?</CODE> test.
</DL>
</P><P>

<A NAME="IDX165"></A>
<DL>
<DT><U>Method:</U> <B>object-equal?</B> <I>((tree1 CONS) (tree2 OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> iff the cons trees <VAR>tree1</VAR> and <VAR>tree2</VAR> are
structurally equivalent.  Uses <CODE>equal?</CODE> to test equality of subtrees.
</DL>
</P><P>

<A NAME="IDX166"></A>
<DL>
<DT><U>Method:</U> <B>equal-hash-code</B> <I>((self CONS)) : INTEGER</I>
<DD>Return an <CODE>equal?</CODE> hash code for <VAR>self</VAR>.  Note that this
is O(N) in the number of elements of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX167"></A>
<DL>
<DT><U>Function:</U> <B>cons</B> <I>((value OBJECT) (rest CONS)) : CONS</I>
<DD>Return a cons record that points to <VAR>value</VAR> and <VAR>rest</VAR>.
</DL>
</P><P>

<A NAME="IDX168"></A>
<DL>
<DT><U>Method:</U> <B>first</B> <I>((self CONS)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the first element of <VAR>self</VAR>.  The first element
of <VAR>self</VAR> can be set with <CODE>setf</CODE>.  Note that <CODE>(first NIL)</CODE> = <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX169"></A>
<DL>
<DT><U>Method:</U> <B>second</B> <I>((self CONS)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the second element of <VAR>self</VAR>.  The second element
of <VAR>self</VAR> can be set with <CODE>setf</CODE>.  Note that <CODE>(second NIL)</CODE> = <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX170"></A>
<DL>
<DT><U>Method:</U> <B>third</B> <I>((self CONS)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the third element of <VAR>self</VAR>.  The third element
of <VAR>self</VAR> can be set with <CODE>setf</CODE>.  Note that <CODE>(third NIL)</CODE> = <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX171"></A>
<DL>
<DT><U>Method:</U> <B>fourth</B> <I>((self CONS)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the fourth element of <VAR>self</VAR>.  The fourth element
of <VAR>self</VAR> can be set with <CODE>setf</CODE>.  Note that <CODE>(fourth NIL)</CODE> = <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX172"></A>
<DL>
<DT><U>Method:</U> <B>fifth</B> <I>((self CONS)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the fifth element of <VAR>self</VAR>.  The fifth element
of <VAR>self</VAR> can be set with <CODE>setf</CODE>.  Note, that <CODE>(fifth NIL)</CODE> = <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX173"></A>
<DL>
<DT><U>Method:</U> <B>nth</B> <I>((self CONS) (position INTEGER)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the element of <VAR>self</VAR> at <VAR>position</VAR>.  The nth element
of <VAR>self</VAR> can be set with <CODE>setf</CODE>.  Note, that <CODE>(nth NIL &#60;pos&#62;)</CODE> = <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX174"></A>
<DL>
<DT><U>Method:</U> <B>nth-rest</B> <I>((self CONS) (position INTEGER)) : (LIKE SELF)</I>
<DD>Apply <CODE>rest</CODE> <VAR>position</VAR> times to <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX175"></A>
<DL>
<DT><U>Method:</U> <B>last</B> <I>((self CONS)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the last element of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX176"></A>
<DL>
<DT><U>Method:</U> <B>but-last</B> <I>((self CONS)) : (ITERATOR OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Generate all but the last element of the cons list <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX177"></A>
<DL>
<DT><U>Function:</U> <B>last-cons</B> <I>((self CONS)) : (CONS OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return the last cons of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX178"></A>
<DL>
<DT><U>Method:</U> <B>length</B> <I>((self CONS)) : INTEGER</I>
<DD>Return the length of the CONS list <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX179"></A>
<DL>
<DT><U>Method:</U> <B>member?</B> <I>((self CONS) (object OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> iff <VAR>object</VAR> is a member of the cons list
<VAR>self</VAR> (uses an <CODE>eql?</CODE> test).
</DL>
</P><P>

<A NAME="IDX180"></A>
<DL>
<DT><U>Method:</U> <B>memb?</B> <I>((self CONS) (object OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> iff <VAR>object</VAR> is a member of the cons list
<VAR>self</VAR> (uses an <CODE>eq?</CODE> test).
</DL>
</P><P>

<A NAME="IDX181"></A>
<DL>
<DT><U>Method:</U> <B>position</B> <I>((self CONS) (object OBJECT) (start INTEGER)) : INTEGER</I>
<DD>Return the position of <VAR>object</VAR> within the cons-list
<VAR>self</VAR> (counting from zero); or return <CODE>null</CODE> if <VAR>object</VAR> does not occur within 
<VAR>self</VAR> (uses an <CODE>eql?</CODE> test).  If <VAR>start</VAR> was supplied as non-`null', only 
consider the sublist starting at <VAR>start</VAR>, however, the returned position 
will always be relative to the entire list.
</DL>
</P><P>

<A NAME="IDX182"></A>
<DL>
<DT><U>Method:</U> <B>reverse</B> <I>((self CONS)) : (LIKE SELF)</I>
<DD>Destructively reverse the members of the cons list <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX183"></A>
<DL>
<DT><U>Method:</U> <B>remove</B> <I>((self CONS) (value OBJECT)) : (LIKE SELF)</I>
<DD>Destructively remove all entries in the cons list <VAR>self</VAR> that
match <VAR>value</VAR>.  Unless the remaining list is <CODE>nil</CODE>, insure that the cons that
heads the list is unchanged.
</DL>
</P><P>

<A NAME="IDX184"></A>
<DL>
<DT><U>Method:</U> <B>remove-duplicates</B> <I>((self CONS)) : (LIKE SELF)</I>
<DD>Destructively remove duplicates from <VAR>self</VAR> and return the
result.  Removes all but the first occurrence of items in the list.
Preserves the original order of the remaining members.  Runs in linear time.
</DL>
</P><P>

<A NAME="IDX185"></A>
<DL>
<DT><U>Method:</U> <B>remove-if</B> <I>((self CONS) (test? FUNCTION-CODE)) : (LIKE SELF)</I>
<DD>Destructively removes all members of the cons list
<VAR>self</VAR> for which <VAR>test?</VAR> evaluates to <CODE>true</CODE>.  <CODE>test</CODE> takes a single 
argument of type OBJECT and returns <CODE>true</CODE> or <CODE>false</CODE>.  Returns a cons list.
In case the first element is removed, the return result should be
assigned to a variable.
</DL>
</P><P>

<A NAME="IDX186"></A>
<DL>
<DT><U>Method:</U> <B>substitute</B> <I>((self CONS) (inValue OBJECT) (outValue OBJECT)) : CONS</I>
<DD>Destructively replace each appearance of <VAR>outValue</VAR> by
<VAR>inValue</VAR> in the cons list <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX187"></A>
<DL>
<DT><U>Method:</U> <B>concatenate</B> <I>((list1 CONS) (list2 CONS) &#38;rest (otherLists CONS)) : CONS</I>
<DD>Return a cons list consisting of the concatenation of 
<VAR>list1</VAR>, <VAR>list2</VAR>, and <VAR>otherLists</VAR>.  The operation is destructive wrt all
but the last list argument which is left intact.  The two mandatory
parameters allow us to optimize the common binary case by not relying on
the somewhat less efficient variable arguments mechanism.
</DL>
</P><P>

<A NAME="IDX188"></A>
<DL>
<DT><U>Function:</U> <B>append</B> <I>((consList1 CONS) (consList2 CONS)) : CONS</I>
<DD>Return a cons list representing the concatenation
of <VAR>consList1</VAR> and <VAR>consList2</VAR>.  The concatenation is NOT destructive.
</DL>
</P><P>

<A NAME="IDX189"></A>
<DL>
<DT><U>Method:</U> <B>prepend</B> <I>((self CONS) (list1 CONS)) : CONS</I>
<DD>Return a cons list consisting of the concatenation of
<VAR>list1</VAR> and <VAR>self</VAR>.  A copy of <VAR>list1</VAR> is prepended to <VAR>self</VAR>.  This
operation results in structure sharing of <VAR>self</VAR>; to avoid this, <VAR>self</VAR>
should not be pointed to by anything other than the tail of the prepended
copy.
</DL>
</P><P>

<A NAME="IDX190"></A>
<DL>
<DT><U>Macro:</U> <B>pushq</B> <I>((variable SYMBOL) (value OBJECT)) : OBJECT</I>
<DD>Push <VAR>value</VAR> onto the cons list <VAR>variable</VAR>.
</DL>
</P><P>

<A NAME="IDX191"></A>
<DL>
<DT><U>Macro:</U> <B>pushq-new</B> <I>((variable SYMBOL) (value OBJECT)) : OBJECT</I>
<DD>Push <VAR>value</VAR> onto the cons list <VAR>variable</VAR>, unless <VAR>value</VAR>
is already a member of the list.
</DL>
</P><P>

<A NAME="IDX192"></A>
<DL>
<DT><U>Macro:</U> <B>popq</B> <I>((variable SYMBOL)) : OBJECT</I>
<DD>Pops a value from the cons list <VAR>variable</VAR>.
</DL>
</P><P>

<A NAME="IDX193"></A>
<DL>
<DT><U>Function:</U> <B>cons-list</B> <I>(&#38;rest (values OBJECT)) : CONS</I>
<DD>Return a cons list containing <VAR>values</VAR>, in order.
</DL>
</P><P>

<A NAME="IDX194"></A>
<DL>
<DT><U>Function:</U> <B>list*</B> <I>(&#38;rest (values OBJECT)) : CONS</I>
<DD>Return a list of conses that make up the list <VAR>values</VAR>,
terminated by the last value rather than by <CODE>nil</CODE>.  Assumes that
at least one value is passed in.
</DL>
</P><P>

<A NAME="IDX195"></A>
<DL>
<DT><U>Function:</U> <B>copy-cons-list</B> <I>((self CONS)) : (LIKE SELF)</I>
<DD>Return a copy of the cons list <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX196"></A>
<DL>
<DT><U>Function:</U> <B>copy-cons-tree</B> <I>((self OBJECT)) : (LIKE SELF)</I>
<DD>Return a copy of the cons tree <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX197"></A>
<DL>
<DT><U>Function:</U> <B>substitute-cons-tree</B> <I>((tree OBJECT) (newValue OBJECT) (oldValue OBJECT)) : OBJECT</I>
<DD>Destructively replace each appearance of <VAR>oldValue</VAR> by
<VAR>newValue</VAR> in the cons tree <VAR>tree</VAR>.  Return the tree.  Uses an <CODE>eql?</CODE> test.
</DL>
</P><P>

<A NAME="IDX198"></A>
<DL>
<DT><U>Function:</U> <B>search-cons-tree?</B> <I>((tree OBJECT) (value OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> iff the value <VAR>value</VAR> is embedded within
the cons tree <VAR>tree</VAR>.  Uses an <CODE>eql?</CODE> test.
</DL>
</P><P>

<A NAME="IDX199"></A>
<DL>
<DT><U>Function:</U> <B>tree-size</B> <I>((self OBJECT)) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX200"></A>
<DL>
<DT><U>Function:</U> <B>safe-tree-size</B> <I>((tree CONS)) : INTEGER STRING</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX201"></A>
<DL>
<DT><U>Method:</U> <B>consify</B> <I>((self CONS)) : (CONS OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX202"></A>
<DL>
<DT><U>Method:</U> <B>allocate-iterator</B> <I>((self CONS)) : (CONS-ITERATOR OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX203"></A>
<DL>
<DT><U>Method:</U> <B>next?</B> <I>((self CONS-ITERATOR)) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX204"></A>
<DL>
<DT><U>Method:</U> <B>sort</B> <I>((self CONS) (predicate FUNCTION-CODE)) : (CONS OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Perform a stable, destructive sort of <VAR>self</VAR> according to
<VAR>predicate</VAR>, and return the result.  If <VAR>predicate</VAR> has a <CODE>&#60;</CODE> semantics, the
result will be in ascending order.  It is not guaranteed that <VAR>self</VAR> will
point to the beginning of the sorted result.  If <VAR>predicate</VAR> is <CODE>null</CODE>, a
suitable <CODE>&#60;</CODE> predicate is chosen depending on the first element of <VAR>self</VAR>,
and it is assumed that all elements of <VAR>self</VAR> have the same type (supported
element types are GENERALIZED-SYMBOL, STRING, INTEGER, and FLOAT).
</DL>
</P><P>

<A NAME="IDX205"></A>
<DL>
<DT><U>Function:</U> <B>map-null-to-nil</B> <I>((self CONS)) : (LIKE SELF)</I>
<DD>Return <CODE>nil</CODE> iff <VAR>self</VAR> is <CODE>null</CODE> or <VAR>self</VAR> otherwise.
</DL>
</P><P>

<A NAME="IDX206"></A>
<DL>
<DT><U>Special Variable:</U> <B>*printpretty?*</B> <I>: BOOLEAN</I>
<DD>If <CODE>true</CODE> conses will be pretty printed.
</DL>
</P><P>

<A NAME="IDX207"></A>
<DL>
<DT><U>Special Variable:</U> <B>*printreadably?*</B> <I>: BOOLEAN</I>
<DD>If <CODE>true</CODE> conses will be printed as readable Stella code.
</DL>
</P><P>

<A NAME="IDX208"></A>
<DL>
<DT><U>Special Variable:</U> <B>*printprettycode?*</B> <I>: BOOLEAN</I>
<DD>When <CODE>true</CODE> pretty-print Stella and translated code.
Since (Lisp) pretty-printing is somewhat slow, turning this off speeds up
file translation, but it also makes translated output very unreadable.
</DL>
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC36">6.5.1 CONS Lists as Sets</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="CONS Lists as Sets"></A>
<HR SIZE="6">
<A NAME="SEC36"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC35"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC37"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC34"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC35"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC37"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 6.5.1 CONS Lists as Sets </H3>
<!--docid::SEC36::-->
<P>

<A NAME="IDX209"></A>
<DL>
<DT><U>Method:</U> <B>subset?</B> <I>((self CONS) (otherList CONS)) : BOOLEAN</I>
<DD>Return true if every element of <VAR>self</VAR> also occurs in <VAR>otherList</VAR>.
Uses an <CODE>eql?</CODE> test and a simple quadratic-time algorithm.  Note that
this does not check whether <VAR>self</VAR> and <VAR>otherList</VAR> actually are sets.
</DL>
</P><P>

<A NAME="IDX210"></A>
<DL>
<DT><U>Method:</U> <B>equivalent-sets?</B> <I>((self CONS) (otherList CONS)) : BOOLEAN</I>
<DD>Return true if every element of <VAR>self</VAR> occurs in <VAR>otherList</VAR> and vice versa.
Uses an <CODE>eql?</CODE> test and a simple quadratic-time algorithm.  Note that
this does not check whether <VAR>self</VAR> and <VAR>otherList</VAR> actually are sets.
</DL>
</P><P>

<A NAME="IDX211"></A>
<DL>
<DT><U>Method:</U> <B>union</B> <I>((self CONS) (otherList CONS)) : CONS</I>
<DD>Return the set union of <VAR>self</VAR> and <VAR>otherList</VAR>.  Uses an <CODE>eql?</CODE> test
and a simple quadratic-time algorithm.  Note that the result is only
guaranteed to be a set if both <VAR>self</VAR> and <VAR>otherList</VAR> are sets.
</DL>
</P><P>

<A NAME="IDX212"></A>
<DL>
<DT><U>Method:</U> <B>intersection</B> <I>((self CONS) (otherList CONS)) : CONS</I>
<DD>Return the set intersection of <VAR>self</VAR> and <VAR>otherList</VAR>.  Uses an <CODE>eql?</CODE>
test and a simple quadratic-time algorithm.  Note that the result is only
guaranteed to be a set if both <VAR>self</VAR> and <VAR>otherList</VAR> are sets.
</DL>
</P><P>

<A NAME="IDX213"></A>
<DL>
<DT><U>Method:</U> <B>difference</B> <I>((self CONS) (otherList CONS)) : CONS</I>
<DD>Return the set difference of <VAR>self</VAR> and <VAR>otherList</VAR> (i.e., all elements
that are in <VAR>self</VAR> but not in <CODE>otherSet</CODE>).  Uses an <CODE>eql?</CODE> test and a simple
quadratic-time algorithm.  Note that the result is only guaranteed to be a
set if both <VAR>self</VAR> and <VAR>otherList</VAR> are sets.
</DL>
</P><P>

<A NAME="IDX214"></A>
<DL>
<DT><U>Method:</U> <B>subtract</B> <I>((self CONS) (otherList CONS)) : CONS</I>
<DD>Return the set difference of <VAR>self</VAR> and <VAR>otherList</VAR> by destructively
removing elements from <VAR>self</VAR> that also occur in <VAR>otherList</VAR>.  Uses an <CODE>eql?</CODE>
test and a simple quadratic-time algorithm.  Note that the result is only
guaranteed to be a set if <VAR>self</VAR> is a set.
</DL>
</P><P>

<A NAME="Lists"></A>
<HR SIZE="6">
<A NAME="SEC37"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC36"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC38"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC35"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC39"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.6 Lists </H2>
<!--docid::SEC37::-->
<P>

<A NAME="IDX215"></A>
<DL>
<DT><U>Variable:</U> <B>nil-list</B> <I>: LIST</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX216"></A>
<DL>
<DT><U>Function:</U> <B>defined-list?</B> <I>((self LIST)) : BOOLEAN</I>
<DD>Return TRUE unless <VAR>self</VAR> is NULL or the <CODE>NIL-LIST</CODE>.
</DL>
</P><P>

<A NAME="IDX217"></A>
<DL>
<DT><U>Function:</U> <B>null-list?</B> <I>((self LIST)) : BOOLEAN</I>
<DD>Return TRUE iff <VAR>self</VAR> is NULL or the <CODE>NIL-LIST</CODE>.
</DL>
</P><P>

<A NAME="IDX218"></A>
<DL>
<DT><U>Method:</U> <B>empty?</B> <I>((self LIST)) : BOOLEAN</I>
<DD>Return TRUE if the list <VAR>self</VAR> has no members.
</DL>
</P><P>

<A NAME="IDX219"></A>
<DL>
<DT><U>Method:</U> <B>non-empty?</B> <I>((self LIST)) : BOOLEAN</I>
<DD>Return TRUE if the list <VAR>self</VAR> has at least one member.
</DL>
</P><P>

<A NAME="IDX220"></A>
<DL>
<DT><U>Method:</U> <B>object-equal?</B> <I>((x LIST) (y OBJECT)) : BOOLEAN</I>
<DD>Return TRUE iff the lists <VAR>x</VAR> and <VAR>y</VAR> are structurally
equivalent.  Uses <CODE>equal?</CODE> to test equality of elements.
</DL>
</P><P>

<A NAME="IDX221"></A>
<DL>
<DT><U>Method:</U> <B>equal-hash-code</B> <I>((self LIST)) : INTEGER</I>
<DD>Return an <CODE>equal?</CODE> hash code for <VAR>self</VAR>.  Note that this
is O(N) in the number of elements of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX222"></A>
<DL>
<DT><U>Function:</U> <B>list</B> <I>(&#38;rest (values OBJECT)) : LIST</I>
<DD>Return a list containing <VAR>values</VAR>, in order.
</DL>
</P><P>

<A NAME="IDX223"></A>
<DL>
<DT><U>Method:</U> <B>first</B> <I>((self LIST)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the first item in the list <VAR>self</VAR>, or NULL if empty.
</DL>
</P><P>

<A NAME="IDX224"></A>
<DL>
<DT><U>Method:</U> <B>second</B> <I>((self LIST)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the second item in the list <VAR>self</VAR>, or NULL if empty.
</DL>
</P><P>

<A NAME="IDX225"></A>
<DL>
<DT><U>Method:</U> <B>third</B> <I>((self LIST)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the third item in the list <VAR>self</VAR>, or NULL if empty.
</DL>
</P><P>

<A NAME="IDX226"></A>
<DL>
<DT><U>Method:</U> <B>fourth</B> <I>((self LIST)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the fourth item in the list <VAR>self</VAR>, or NULL if empty.
</DL>
</P><P>

<A NAME="IDX227"></A>
<DL>
<DT><U>Method:</U> <B>fifth</B> <I>((self LIST)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the fifth item in the list <VAR>self</VAR>, or NULL if empty.
</DL>
</P><P>

<A NAME="IDX228"></A>
<DL>
<DT><U>Method:</U> <B>nth</B> <I>((self LIST) (position INTEGER)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the nth item in the list <VAR>self</VAR>, or NULL if empty.
</DL>
</P><P>

<A NAME="IDX229"></A>
<DL>
<DT><U>Method:</U> <B>rest</B> <I>((self LIST)) : (CONS OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return a cons list of all but the first item in the list <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX230"></A>
<DL>
<DT><U>Method:</U> <B>last</B> <I>((self LIST)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the last element of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX231"></A>
<DL>
<DT><U>Method:</U> <B>but-last</B> <I>((self LIST)) : (ITERATOR OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Generate all but the last element of the list <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX232"></A>
<DL>
<DT><U>Method:</U> <B>length</B> <I>((self LIST)) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX233"></A>
<DL>
<DT><U>Method:</U> <B>member?</B> <I>((self LIST) (object OBJECT)) : BOOLEAN</I>
<DD>Return TRUE iff <VAR>object</VAR> is a member of the list
<VAR>self</VAR> (uses an <CODE>eql?</CODE> test).
</DL>
</P><P>

<A NAME="IDX234"></A>
<DL>
<DT><U>Method:</U> <B>memb?</B> <I>((self LIST) (object (LIKE (ANY-VALUE SELF)))) : BOOLEAN</I>
<DD>Return TRUE iff <VAR>object</VAR> is a member of the cons list
<VAR>self</VAR> (uses an <CODE>eq?</CODE> test).
</DL>
</P><P>

<A NAME="IDX235"></A>
<DL>
<DT><U>Method:</U> <B>position</B> <I>((self LIST) (object OBJECT) (start INTEGER)) : INTEGER</I>
<DD>Return the position of <VAR>object</VAR> within the list
<VAR>self</VAR> (counting from zero); or return NULL if <VAR>object</VAR> does not occur within 
<VAR>self</VAR> (uses an <CODE>eql?</CODE> test).  If <VAR>start</VAR> was supplied as non-NULL, only 
consider the sublist starting at <VAR>start</VAR>, however, the returned position 
will always be relative to the entire list.
</DL>
</P><P>

<A NAME="IDX236"></A>
<DL>
<DT><U>Method:</U> <B>insert</B> <I>((self LIST) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Add <VAR>value</VAR> to the front of the list <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX237"></A>
<DL>
<DT><U>Method:</U> <B>push</B> <I>((self LIST) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Add <VAR>value</VAR> to the front of the list <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX238"></A>
<DL>
<DT><U>Method:</U> <B>insert-new</B> <I>((self LIST) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Add <VAR>value</VAR> to the front of the list <VAR>self</VAR> unless its 
already a member.
</DL>
</P><P>

<A NAME="IDX239"></A>
<DL>
<DT><U>Method:</U> <B>insert-last</B> <I>((self LIST) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Insert <VAR>value</VAR> as the last entry in the list <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX240"></A>
<DL>
<DT><U>Method:</U> <B>reverse</B> <I>((self LIST)) : (LIKE SELF)</I>
<DD>Reverse the members of <VAR>self</VAR> (in place).
</DL>
</P><P>

<A NAME="IDX241"></A>
<DL>
<DT><U>Method:</U> <B>remove</B> <I>((self LIST) (value (LIKE (ANY-VALUE SELF)))) : (LIKE SELF)</I>
<DD>Destructively remove all entries in <VAR>self</VAR> that match <VAR>value</VAR>.
</DL>
</P><P>

<A NAME="IDX242"></A>
<DL>
<DT><U>Method:</U> <B>remove-duplicates</B> <I>((self LIST)) : (LIKE SELF)</I>
<DD>Destructively remove duplicates from <VAR>self</VAR> and return the result.
Preserves the original order of the remaining members.
</DL>
</P><P>

<A NAME="IDX243"></A>
<DL>
<DT><U>Method:</U> <B>remove-deleted-members</B> <I>((self LIST)) : (LIKE SELF)</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX244"></A>
<DL>
<DT><U>Method:</U> <B>remove-if</B> <I>((self LIST) (test? FUNCTION-CODE)) : (LIKE SELF)</I>
<DD>Destructively remove all members of the list <VAR>self</VAR> for which
<VAR>test?</VAR> evaluates to TRUE.  <CODE>test</CODE> takes a single argument of type OBJECT and
returns TRUE or FALSE.  Returns <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX245"></A>
<DL>
<DT><U>Method:</U> <B>pop</B> <I>((self LIST)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Remove and return the first element in the list <VAR>self</VAR>.
Return NULL if the list is empty.
</DL>
</P><P>

<A NAME="IDX246"></A>
<DL>
<DT><U>Method:</U> <B>substitute</B> <I>((self LIST) (inValue OBJECT) (outValue OBJECT)) : (LIKE SELF)</I>
<DD>Destructively replace each appearance of <VAR>outValue</VAR> by
<VAR>inValue</VAR> in the list <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX247"></A>
<DL>
<DT><U>Method:</U> <B>concatenate</B> <I>((list1 LIST) (list2 LIST) &#38;rest (otherLists LIST)) : LIST</I>
<DD>Copy <VAR>list2</VAR> and all <VAR>otherLists</VAR> onto the end of <VAR>list1</VAR>.
The operation is destructive wrt <VAR>list1</VAR>, but leaves all other lists intact.
The two mandatory parameters allow us to optimize the common binary case by
not relying on the somewhat less efficient variable arguments mechanism.
</DL>
</P><P>

<A NAME="IDX248"></A>
<DL>
<DT><U>Method:</U> <B>prepend</B> <I>((self LIST) (list2 LIST)) : (LIKE SELF)</I>
<DD>Copy <VAR>list2</VAR> onto the front of the list <VAR>self</VAR>.
The operation is destructive wrt <VAR>self</VAR>, but leaves <VAR>list2</VAR> intact.
</DL>
</P><P>

<A NAME="IDX249"></A>
<DL>
<DT><U>Method:</U> <B>copy</B> <I>((self LIST)) : (LIST OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return a copy of the list <VAR>self</VAR>.  The conses in the copy are
freshly allocated.
</DL>
</P><P>

<A NAME="IDX250"></A>
<DL>
<DT><U>Method:</U> <B>clear</B> <I>((self LIST)) :</I>
<DD>Make <VAR>self</VAR> an empty list.
</DL>
</P><P>

<A NAME="IDX251"></A>
<DL>
<DT><U>Method:</U> <B>consify</B> <I>((self LIST)) : (CONS OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return a list of elements in <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX252"></A>
<DL>
<DT><U>Method:</U> <B>allocate-iterator</B> <I>((self LIST)) : (LIST-ITERATOR OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX253"></A>
<DL>
<DT><U>Method:</U> <B>next?</B> <I>((self LIST-ITERATOR)) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX254"></A>
<DL>
<DT><U>Method:</U> <B>sort</B> <I>((self LIST) (predicate FUNCTION-CODE)) : (LIST OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Perform a stable, destructive sort of <VAR>self</VAR> according to
<VAR>predicate</VAR>, and return the result.  If <VAR>predicate</VAR> has a <CODE>&#60;</CODE> semantics, the
result will be in ascending order.  If <VAR>predicate</VAR> is NULL, a suitable
<CODE>&#60;</CODE> predicate is chosen depending on the first element of <VAR>self</VAR>, and it 
is assumed that all elements of <VAR>self</VAR> have the same type (supported
element types are GENERALIZED-SYMBOL, STRING, INTEGER, and FLOAT).
</DL>
</P><P>

<A NAME="IDX255"></A>
<DL>
<DT><U>Function:</U> <B>map-null-to-nil-list</B> <I>((self LIST)) : LIST</I>
<DD>Return NIL-LIST iff <VAR>self</VAR> is NULL or <VAR>self</VAR> otherwise.
</DL>
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_6.html#SEC38">6.6.1 Lists as Sets</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Lists as Sets"></A>
<HR SIZE="6">
<A NAME="SEC38"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC37"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC39"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC35"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC37"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC39"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 6.6.1 Lists as Sets </H3>
<!--docid::SEC38::-->
<P>

Similar to <CODE>CONS</CODE> lists <CODE>LIST</CODE>'s can also be treated as sets
and support the set manipulations below.  Note that <CODE>LIST</CODE>
constructors do not check for proper set-hood and may have surprising
results if a list contains duplicate elements.
</P><P>

<A NAME="IDX256"></A>
<DL>
<DT><U>Method:</U> <B>subset?</B> <I>((self LIST) (otherList LIST)) : BOOLEAN</I>
<DD>Return true if every element of <VAR>self</VAR> also occurs in <VAR>otherList</VAR>.
Uses an <CODE>eql?</CODE> test and a simple quadratic-time algorithm.  Note that
this does not check whether <VAR>self</VAR> and <VAR>otherList</VAR> actually are sets.
</DL>
</P><P>

<A NAME="IDX257"></A>
<DL>
<DT><U>Method:</U> <B>equivalent-sets?</B> <I>((self LIST) (otherList LIST)) : BOOLEAN</I>
<DD>Return true if every element of <VAR>self</VAR> occurs in <VAR>otherList</VAR> and vice versa.
Uses an <CODE>eql?</CODE> test and a simple quadratic-time algorithm.  Note that
this does not check whether <VAR>self</VAR> and <VAR>otherList</VAR> actually are sets.
</DL>
</P><P>

<A NAME="IDX258"></A>
<DL>
<DT><U>Method:</U> <B>union</B> <I>((self LIST) (otherList LIST)) : LIST</I>
<DD>Return the set union of <VAR>self</VAR> and <VAR>otherList</VAR>.  Uses an <CODE>eql?</CODE> test
and a simple quadratic-time algorithm.  Note that the result is only
guaranteed to be a set if both <VAR>self</VAR> and <VAR>otherList</VAR> are sets.
</DL>
</P><P>

<A NAME="IDX259"></A>
<DL>
<DT><U>Method:</U> <B>intersection</B> <I>((self LIST) (otherList LIST)) : LIST</I>
<DD>Return the set intersection of <VAR>self</VAR> and <VAR>otherList</VAR>.  Uses an <CODE>eql?</CODE>
test and a simple quadratic-time algorithm.  Note that the result is only
guaranteed to be a set if both <VAR>self</VAR> and <VAR>otherList</VAR> are sets.
</DL>
</P><P>

<A NAME="IDX260"></A>
<DL>
<DT><U>Method:</U> <B>difference</B> <I>((self LIST) (otherList LIST)) : LIST</I>
<DD>Return the set difference of <VAR>self</VAR> and <VAR>otherList</VAR> (i.e., all elements
that are in <VAR>self</VAR> but not in <CODE>otherSet</CODE>).  Uses an <CODE>eql?</CODE> test and a simple
quadratic-time algorithm.  Note that the result is only guaranteed to be a
set if both <VAR>self</VAR> and <VAR>otherList</VAR> are sets.
</DL>
</P><P>

<A NAME="IDX261"></A>
<DL>
<DT><U>Method:</U> <B>subtract</B> <I>((self LIST) (otherList LIST)) : LIST</I>
<DD>Return the set difference of <VAR>self</VAR> and <VAR>otherList</VAR> by destructively
removing elements from <VAR>self</VAR> that also occur in <VAR>otherList</VAR>.  Uses an <CODE>eql?</CODE>
test and a simple quadratic-time algorithm.  Note that the result is only
guaranteed to be a set if <VAR>self</VAR> is a set.
</DL>
</P><P>

<CODE>SET</CODE> is a subclass of <CODE>LIST</CODE> that overrides certain
<CODE>LIST</CODE> operations to prevent duplicate elements.  The following
additional or modified operations are supported:
</P><P>

<A NAME="IDX262"></A>
<DL>
<DT><U>Method:</U> <B>insert</B> <I>((self SET) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Add <VAR>value</VAR> to the set <VAR>self</VAR> unless it is already a member.
</DL>
</P><P>

<A NAME="IDX263"></A>
<DL>
<DT><U>Method:</U> <B>push</B> <I>((self SET) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Add <VAR>value</VAR> to the front of set <VAR>self</VAR> unless it is already a member.
</DL>
</P><P>

<A NAME="IDX264"></A>
<DL>
<DT><U>Method:</U> <B>insert-last</B> <I>((self SET) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Add <VAR>value</VAR> to the end of set <VAR>self</VAR> unless it is already a member.
</DL>
</P><P>

<A NAME="IDX265"></A>
<DL>
<DT><U>Method:</U> <B>substitute</B> <I>((self SET) (new OBJECT) (old OBJECT)) : (LIKE SELF)</I>
<DD>Destructively replace <VAR>old</VAR> with <VAR>new</VAR> in the set <VAR>self</VAR>
unless <VAR>new</VAR> is already a member.
</DL>
</P><P>

<A NAME="IDX266"></A>
<DL>
<DT><U>Method:</U> <B>concatenate</B> <I>((set1 SET) (set2 LIST) &#38;rest (otherSets LIST)) : SET</I>
<DD>Union <VAR>set2</VAR> and all <VAR>otherSets</VAR> onto the end of <VAR>set1</VAR>.
The operation is destructive wrt <VAR>set1</VAR>, but leaves all other sets intact.
The two mandatory parameters allow us to optimize the common binary case by
not relying on the somewhat less efficient variable arguments mechanism.
</DL>
</P><P>

<A NAME="IDX267"></A>
<DL>
<DT><U>Method:</U> <B>object-equal?</B> <I>((x SET) (y OBJECT)) : BOOLEAN</I>
<DD>Return TRUE iff <VAR>x</VAR> and <VAR>y</VAR> are SET's with equivalent members.
Uses <CODE>equal?</CODE> to test equality of elements.  This is more general than
<CODE>equivalent-sets?</CODE>, since that only uses an <CODE>eql?</CODE> test.
</DL>
</P><P>

<A NAME="IDX268"></A>
<DL>
<DT><U>Method:</U> <B>equal-hash-code</B> <I>((self SET)) : INTEGER</I>
<DD>Return an <CODE>equal?</CODE> hash code for <VAR>self</VAR>.  Note that this
is O(N) in the number of elements of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX269"></A>
<DL>
<DT><U>Function:</U> <B>set</B> <I>(&#38;rest (values OBJECT)) : SET</I>
<DD>Return a set containing <VAR>values</VAR>, in order.
</DL>
</P><P>

<A NAME="Property and Key-Value Lists"></A>
<HR SIZE="6">
<A NAME="SEC39"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC38"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC40"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC37"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.7 Property and Key-Value Lists </H2>
<!--docid::SEC39::-->
<P>

<A NAME="IDX270"></A>
<DL>
<DT><U>Method:</U> <B>empty?</B> <I>((self PROPERTY-LIST)) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX271"></A>
<DL>
<DT><U>Method:</U> <B>non-empty?</B> <I>((self PROPERTY-LIST)) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX272"></A>
<DL>
<DT><U>Method:</U> <B>object-equal?</B> <I>((x PROPERTY-LIST) (y OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>x</VAR> and <VAR>y</VAR> represent the same set of key/value pairs..
</DL>
</P><P>

<A NAME="IDX273"></A>
<DL>
<DT><U>Method:</U> <B>equal-hash-code</B> <I>((self PROPERTY-LIST)) : INTEGER</I>
<DD>Return an <CODE>equal?</CODE> hash code for <VAR>self</VAR>.  Note that this
is O(N) in the number of entries of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX274"></A>
<DL>
<DT><U>Method:</U> <B>length</B> <I>((self PROPERTY-LIST)) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX275"></A>
<DL>
<DT><U>Method:</U> <B>lookup</B> <I>((self PROPERTY-LIST) (key (LIKE (ANY-KEY SELF)))) : (LIKE (ANY-VALUE SELF))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX276"></A>
<DL>
<DT><U>Method:</U> <B>insert-at</B> <I>((self PROPERTY-LIST) (key (LIKE (ANY-KEY SELF))) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Insert the entry &#60;`key', <VAR>value</VAR>&#62; into the property list <VAR>self</VAR>.
If a previous entry existed with key <VAR>key</VAR>, that entry is replaced.
</DL>
</P><P>

<A NAME="IDX277"></A>
<DL>
<DT><U>Method:</U> <B>remove-at</B> <I>((self PROPERTY-LIST) (key (LIKE (ANY-KEY SELF)))) : OBJECT</I>
<DD>Remove the entry that matches the key <VAR>key</VAR>.  Return the
value of the matching entry, or NULL if there is no matching entry.  Assumes that at
most one entry matches <VAR>key</VAR>.
</DL>
</P><P>

<A NAME="IDX278"></A>
<DL>
<DT><U>Method:</U> <B>copy</B> <I>((self PROPERTY-LIST)) : (LIKE SELF)</I>
<DD>Return a copy of the list <VAR>self</VAR>.  The conses in the copy are
freshly allocated.
</DL>
</P><P>

<A NAME="IDX279"></A>
<DL>
<DT><U>Method:</U> <B>clear</B> <I>((self PROPERTY-LIST)) :</I>
<DD>Make <VAR>self</VAR> an empty property list.
</DL>
</P><P>

<A NAME="IDX280"></A>
<DL>
<DT><U>Method:</U> <B>allocate-iterator</B> <I>((self PROPERTY-LIST)) : (PROPERTY-LIST-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX281"></A>
<DL>
<DT><U>Method:</U> <B>next?</B> <I>((self PROPERTY-LIST-ITERATOR)) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX282"></A>
<DL>
<DT><U>Function:</U> <B>kv-cons</B> <I>((key OBJECT) (value OBJECT) (rest KV-CONS)) : KV-CONS</I>
<DD>Create, fill-in, and return a new KV-CONS.
</DL>
</P><P>

<A NAME="IDX283"></A>
<DL>
<DT><U>Function:</U> <B>copy-kv-cons-list</B> <I>((kvconslist KV-CONS)) : KV-CONS</I>
<DD>Return a copy of the cons list <CODE>consList</CODE>.
</DL>
</P><P>

<A NAME="IDX284"></A>
<DL>
<DT><U>Method:</U> <B>empty?</B> <I>((self KEY-VALUE-LIST)) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX285"></A>
<DL>
<DT><U>Method:</U> <B>non-empty?</B> <I>((self KEY-VALUE-LIST)) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX286"></A>
<DL>
<DT><U>Method:</U> <B>object-equal?</B> <I>((x KEY-VALUE-LIST) (y OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>x</VAR> and <VAR>y</VAR> represent the same set of key/value pairs.
</DL>
</P><P>

<A NAME="IDX287"></A>
<DL>
<DT><U>Method:</U> <B>equal-hash-code</B> <I>((self KEY-VALUE-LIST)) : INTEGER</I>
<DD>Return an <CODE>equal?</CODE> hash code for <VAR>self</VAR>.  Note that this
is O(N) in the number of entries of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX288"></A>
<DL>
<DT><U>Method:</U> <B>length</B> <I>((self KEY-VALUE-LIST)) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX289"></A>
<DL>
<DT><U>Method:</U> <B>lookup</B> <I>((self KEY-VALUE-LIST) (key (LIKE (ANY-KEY SELF)))) : (LIKE (ANY-VALUE SELF))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX290"></A>
<DL>
<DT><U>Method:</U> <B>reverse</B> <I>((self KEY-VALUE-LIST)) : (LIKE SELF)</I>
<DD>Destructively reverse the members of the list <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX291"></A>
<DL>
<DT><U>Method:</U> <B>insert-at</B> <I>((self KEY-VALUE-LIST) (key (LIKE (ANY-KEY SELF))) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Insert the entry &#60;`key', <VAR>value</VAR>&#62; into the association
<VAR>self</VAR>. If a previous entry existed with key <VAR>key</VAR>, that entry is replaced.
</DL>
</P><P>

<A NAME="IDX292"></A>
<DL>
<DT><U>Method:</U> <B>remove-at</B> <I>((self KEY-VALUE-LIST) (key (LIKE (ANY-KEY SELF)))) : OBJECT</I>
<DD>Remove the entry that matches the key <VAR>key</VAR>.
Return the value of the matching entry, or NULL if there is no matching entry.
Assumes that at most one entry matches <VAR>key</VAR>.
</DL>
</P><P>

<A NAME="IDX293"></A>
<DL>
<DT><U>Method:</U> <B>insert-entry</B> <I>((self KEY-VALUE-LIST) (key (LIKE (ANY-KEY SELF))) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Insert an entry &#60;`key',<VAR>value</VAR>&#62; to <VAR>self</VAR> unless an identical
entry already exists.  This can generate duplicate entries for <VAR>key</VAR>.
</DL>
</P><P>

<A NAME="IDX294"></A>
<DL>
<DT><U>Method:</U> <B>remove-entry</B> <I>((self KEY-VALUE-LIST) (key (LIKE (ANY-KEY SELF))) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Remove the entry that matches &#60;`key',<VAR>value</VAR>&#62;.
Assumes that more than one entry can match <VAR>key</VAR>.
</DL>
</P><P>

<A NAME="IDX295"></A>
<DL>
<DT><U>Method:</U> <B>push</B> <I>((self KEY-VALUE-LIST) (value KV-CONS)) :</I>
<DD>Make <VAR>value</VAR> be the new first element of <VAR>self</VAR>.  Note that
the <CODE>rest</CODE> slot of <VAR>value</VAR> should be <CODE>null</CODE>, since it will be overwritten.
This might duplicate an existing entry. If a previous entry existed with the
same key as <VAR>value</VAR>, that entry is retained, but shadowed by this new entry.
</DL>
</P><P>

<A NAME="IDX296"></A>
<DL>
<DT><U>Method:</U> <B>kv-push</B> <I>((self KEY-VALUE-LIST) (key (LIKE (ANY-KEY SELF))) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Add a new entry &#60;`key', <VAR>value</VAR>&#62; to the front of the association
<VAR>self</VAR>. This might duplicate an existing entry. If a previous entry existed with key
<VAR>key</VAR>, that entry is retained, but shadowed by this new entry.
</DL>
</P><P>

<A NAME="IDX297"></A>
<DL>
<DT><U>Method:</U> <B>pop</B> <I>((self KEY-VALUE-LIST)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Remove and return the value of the first element of the
kv-list <VAR>self</VAR>.  It does NOT return the KV-CONS object.  Return <CODE>null</CODE> if
the list is empty.
</DL>
</P><P>

<A NAME="IDX298"></A>
<DL>
<DT><U>Method:</U> <B>copy</B> <I>((self KEY-VALUE-LIST)) : (LIKE SELF)</I>
<DD>Return a copy of the kv-list <VAR>self</VAR>.  The kv-conses in
the copy are freshly allocated.
</DL>
</P><P>

<A NAME="IDX299"></A>
<DL>
<DT><U>Method:</U> <B>clear</B> <I>((self KEY-VALUE-LIST)) :</I>
<DD>Make <VAR>self</VAR> an empty dictionary.
</DL>
</P><P>

<A NAME="IDX300"></A>
<DL>
<DT><U>Method:</U> <B>consify</B> <I>((self KEY-VALUE-LIST)) : (CONS OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return a list of key-value pairs in <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX301"></A>
<DL>
<DT><U>Method:</U> <B>allocate-iterator</B> <I>((self KEY-VALUE-LIST)) : (KV-LIST-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX302"></A>
<DL>
<DT><U>Method:</U> <B>next?</B> <I>((self KV-LIST-ITERATOR)) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="Vectors"></A>
<HR SIZE="6">
<A NAME="SEC40"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC39"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC41"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.8 Vectors </H2>
<!--docid::SEC40::-->
<P>

<A NAME="IDX303"></A>
<DL>
<DT><U>Method:</U> <B>empty?</B> <I>((self VECTOR)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>self</VAR> has length 0.
</DL>
</P><P>

<A NAME="IDX304"></A>
<DL>
<DT><U>Method:</U> <B>non-empty?</B> <I>((self VECTOR)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>self</VAR> has length &#62; 0.
</DL>
</P><P>

<A NAME="IDX305"></A>
<DL>
<DT><U>Method:</U> <B>object-equal?</B> <I>((x VECTOR) (y OBJECT)) : BOOLEAN</I>
<DD>Return TRUE iff the vectors <VAR>x</VAR> and <VAR>y</VAR> are structurally
equivalent.  Uses <CODE>equal?</CODE> to test equality of elements.
</DL>
</P><P>

<A NAME="IDX306"></A>
<DL>
<DT><U>Method:</U> <B>equal-hash-code</B> <I>((self VECTOR)) : INTEGER</I>
<DD>Return an <CODE>equal?</CODE> hash code for <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX307"></A>
<DL>
<DT><U>Function:</U> <B>vector</B> <I>(&#38;rest (values OBJECT)) : VECTOR</I>
<DD>Return a vector containing <VAR>values</VAR>, in order.
</DL>
</P><P>

<A NAME="IDX308"></A>
<DL>
<DT><U>Method:</U> <B>first</B> <I>((self VECTOR)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX309"></A>
<DL>
<DT><U>Method:</U> <B>second</B> <I>((self VECTOR)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX310"></A>
<DL>
<DT><U>Method:</U> <B>third</B> <I>((self VECTOR)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX311"></A>
<DL>
<DT><U>Method:</U> <B>fourth</B> <I>((self VECTOR)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX312"></A>
<DL>
<DT><U>Method:</U> <B>fifth</B> <I>((self VECTOR)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX313"></A>
<DL>
<DT><U>Method:</U> <B>nth</B> <I>((self VECTOR) (position INTEGER)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX314"></A>
<DL>
<DT><U>Method:</U> <B>last</B> <I>((self VECTOR)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the last item in the vector <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX315"></A>
<DL>
<DT><U>Method:</U> <B>but-last</B> <I>((self VECTOR)) : (ITERATOR OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Generate all but the last element of the vector <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX316"></A>
<DL>
<DT><U>Method:</U> <B>length</B> <I>((self VECTOR)) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX317"></A>
<DL>
<DT><U>Method:</U> <B>member?</B> <I>((self VECTOR) (object OBJECT)) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX318"></A>
<DL>
<DT><U>Method:</U> <B>position</B> <I>((self VECTOR) (object OBJECT) (start INTEGER)) : INTEGER</I>
<DD>Return the position of <VAR>object</VAR> within the vector
<VAR>self</VAR> (counting from zero); or return <CODE>null</CODE> if <VAR>object</VAR> does not occur within 
<VAR>self</VAR> (uses an <CODE>eql?</CODE> test).  If <VAR>start</VAR> was supplied as non-`null', only 
consider the portion starting at <VAR>start</VAR>, however, the returned position 
will always be relative to the entire vector.
</DL>
</P><P>

<A NAME="IDX319"></A>
<DL>
<DT><U>Method:</U> <B>insert-at</B> <I>((self VECTOR) (offset INTEGER) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX320"></A>
<DL>
<DT><U>Method:</U> <B>copy</B> <I>((self VECTOR)) : (VECTOR OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return a copy of the vector <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX321"></A>
<DL>
<DT><U>Method:</U> <B>clear</B> <I>((self VECTOR)) :</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX322"></A>
<DL>
<DT><U>Function:</U> <B>resize-vector</B> <I>((self VECTOR) (size INTEGER)) :</I>
<DD>Change the size of <VAR>self</VAR> to <VAR>size</VAR>.  If <VAR>size</VAR> is smaller
than the current size of <VAR>self</VAR> the vector will be truncated.  Otherwise, 
the internal array of <VAR>self</VAR> will be grown to <VAR>size</VAR> and unused elements
will be initialized to NULL.
</DL>
</P><P>

<A NAME="IDX323"></A>
<DL>
<DT><U>Method:</U> <B>consify</B> <I>((self VECTOR)) : (CONS OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return a list of elements in <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX324"></A>
<DL>
<DT><U>Method:</U> <B>insert-at</B> <I>((self EXTENSIBLE-VECTOR) (offset INTEGER) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX325"></A>
<DL>
<DT><U>Method:</U> <B>insert</B> <I>((self VECTOR-SEQUENCE) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Append <VAR>value</VAR> to the END of the sequence <VAR>self</VAR>.  
Resize the array if necessary.
</DL>
</P><P>

<A NAME="IDX326"></A>
<DL>
<DT><U>Method:</U> <B>remove</B> <I>((self VECTOR-SEQUENCE) (value (LIKE (ANY-VALUE SELF)))) : VECTOR-SEQUENCE</I>
<DD>Remove <VAR>value</VAR> from the sequence <VAR>self</VAR>, and left shift
the values after it to close the gap.
</DL>
</P><P>

<A NAME="IDX327"></A>
<DL>
<DT><U>Method:</U> <B>length</B> <I>((self VECTOR-SEQUENCE)) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="Hash Tables"></A>
<HR SIZE="6">
<A NAME="SEC41"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC40"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC42"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.9 Hash Tables </H2>
<!--docid::SEC41::-->
<P>

<A NAME="IDX328"></A>
<DL>
<DT><U>Method:</U> <B>lookup</B> <I>((self HASH-TABLE) (key (LIKE (ANY-KEY SELF)))) : (LIKE (ANY-VALUE SELF))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX329"></A>
<DL>
<DT><U>Method:</U> <B>insert-at</B> <I>((self HASH-TABLE) (key (LIKE (ANY-KEY SELF))) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX330"></A>
<DL>
<DT><U>Method:</U> <B>remove-at</B> <I>((self HASH-TABLE) (key (LIKE (ANY-KEY SELF)))) :</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX331"></A>
<DL>
<DT><U>Method:</U> <B>lookup</B> <I>((self STRING-HASH-TABLE) (key STRING)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX332"></A>
<DL>
<DT><U>Method:</U> <B>insert-at</B> <I>((self STRING-HASH-TABLE) (key STRING) (value OBJECT)) :</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX333"></A>
<DL>
<DT><U>Method:</U> <B>remove-at</B> <I>((self STRING-HASH-TABLE) (key STRING)) :</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX334"></A>
<DL>
<DT><U>Method:</U> <B>lookup</B> <I>((self STRING-TO-INTEGER-HASH-TABLE) (key STRING)) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX335"></A>
<DL>
<DT><U>Method:</U> <B>insert-at</B> <I>((self STRING-TO-INTEGER-HASH-TABLE) (key STRING) (value INTEGER)) :</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX336"></A>
<DL>
<DT><U>Method:</U> <B>lookup</B> <I>((self INTEGER-HASH-TABLE) (key INTEGER)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX337"></A>
<DL>
<DT><U>Method:</U> <B>insert-at</B> <I>((self INTEGER-HASH-TABLE) (key INTEGER) (value OBJECT)) :</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX338"></A>
<DL>
<DT><U>Method:</U> <B>insert-at</B> <I>((self FLOAT-HASH-TABLE) (key FLOAT) (value OBJECT)) :</I>
<DD>Not documented.
</DL>
</P><P>

STELLA provides its own implementation of hash tables for cases where
language-native implementations are not available, or where additional
features are needed.
</P><P>

<A NAME="IDX339"></A>
<DL>
<DT><U>Method:</U> <B>lookup</B> <I>((self STELLA-HASH-TABLE) (key (LIKE (ANY-KEY SELF)))) : (LIKE (ANY-VALUE SELF))</I>
<DD>Lookup the entry identified by <VAR>key</VAR> in <VAR>self</VAR> and
return its value, or NULL if no such entry exists.    Uses an <CODE>eql?</CODE>
test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX340"></A>
<DL>
<DT><U>Method:</U> <B>insert-at</B> <I>((self STELLA-HASH-TABLE) (key (LIKE (ANY-KEY SELF))) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Set the value of the entry identified by <VAR>key</VAR> in <VAR>self</VAR>
to <VAR>value</VAR> or add a new entry if no entry with <VAR>key</VAR> exists yet.  Uses an
<CODE>eql?</CODE> test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX341"></A>
<DL>
<DT><U>Method:</U> <B>remove-at</B> <I>((self STELLA-HASH-TABLE) (key (LIKE (ANY-KEY SELF)))) :</I>
<DD>Remove the entry identified by <VAR>key</VAR> from <VAR>self</VAR>.  Uses an
<CODE>eql?</CODE> test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX342"></A>
<DL>
<DT><U>Method:</U> <B>length</B> <I>((self STELLA-HASH-TABLE)) : INTEGER</I>
<DD>Return the number of entries in <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX343"></A>
<DL>
<DT><U>Method:</U> <B>empty?</B> <I>((self STELLA-HASH-TABLE)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>self</VAR> has zero entries.
</DL>
</P><P>

<A NAME="IDX344"></A>
<DL>
<DT><U>Method:</U> <B>non-empty?</B> <I>((self STELLA-HASH-TABLE)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>self</VAR> has at least 1 entry.
</DL>
</P><P>

<A NAME="IDX345"></A>
<DL>
<DT><U>Method:</U> <B>copy</B> <I>((self STELLA-HASH-TABLE)) : (LIKE SELF)</I>
<DD>Return a copy of the hash table <VAR>self</VAR>.  The bucket table
and buckets are freshly allocated, however, the keys and values of entries
are not copied themselves (similar to what we do for lists, etc.).
</DL>
</P><P>

<A NAME="IDX346"></A>
<DL>
<DT><U>Method:</U> <B>clear</B> <I>((self STELLA-HASH-TABLE)) :</I>
<DD>Remove all entries from <VAR>self</VAR>.  This will result in a
re-initialization of the table upon the first insertion into <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX347"></A>
<DL>
<DT><U>Method:</U> <B>consify</B> <I>((self STELLA-HASH-TABLE)) : (CONS OF CONS)</I>
<DD>Collect all entries of <VAR>self</VAR> into a cons list of
<CODE>(&#60;key&#62; &#60;value&#62;)</CODE> pairs and return the result.
</DL>
</P><P>

<A NAME="IDX348"></A>
<DL>
<DT><U>Method:</U> <B>object-equal?</B> <I>((x STELLA-HASH-TABLE) (y OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>x</VAR> and <VAR>y</VAR> represent the same set of key/value pairs.
</DL>
</P><P>

<A NAME="IDX349"></A>
<DL>
<DT><U>Method:</U> <B>equal-hash-code</B> <I>((self STELLA-HASH-TABLE)) : INTEGER</I>
<DD>Return an <CODE>equal?</CODE> hash code for <VAR>self</VAR>.  Note that this
is O(N) in the number of entries of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX350"></A>
<DL>
<DT><U>Method:</U> <B>allocate-iterator</B> <I>((self STELLA-HASH-TABLE)) : (STELLA-HASH-TABLE-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))</I>
<DD>Allocate an iterator for <VAR>self</VAR>.
</DL>
</P><P>

Hashing objects into STELLA hash tables is accomplished via
<CODE>hash-code</CODE> and <CODE>equal-hash-code</CODE> methods.  These methods are
implemented for all built-in STELLA types but are user extensible for
cases where special functionality on user-defined objects is needed.
Defining new <CODE>hash-code</CODE> methods should only be necessary if new
wrapper types are defined, since for all types descending from
<CODE>STANDARD-OBJECT</CODE> the built-in method should be adequate.
</P><P>

<A NAME="IDX351"></A>
<DL>
<DT><U>Function:</U> <B>object-hash-code</B> <I>((self OBJECT)) : INTEGER</I>
<DD>Return a hash code for <VAR>self</VAR> (can be negative).  Two objects that are <CODE>eq?</CODE>
are guaranteed to generate the same hash code.  Two objects that are not <CODE>eq?</CODE>
do not necessarily generate different hash codes.  Similar to <CODE>hash-code</CODE> but
always hashes on the address of <VAR>self</VAR> even if it is a wrapper.
</DL>
</P><P>

<A NAME="IDX352"></A>
<DL>
<DT><U>Method:</U> <B>hash-code</B> <I>((self OBJECT)) : INTEGER</I>
<DD>Return a hash code for <VAR>self</VAR> (can be negative).  Two objects that are <CODE>eql?</CODE>
are guaranteed to generate the same hash code.  Two objects that are not <CODE>eql?</CODE>
do not necessarily generate different hash codes.
</DL>
</P><P>

<A NAME="IDX353"></A>
<DL>
<DT><U>Method:</U> <B>hash-code</B> <I>((self STANDARD-OBJECT)) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX354"></A>
<DL>
<DT><U>Method:</U> <B>hash-code</B> <I>((self STRING-WRAPPER)) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX355"></A>
<DL>
<DT><U>Method:</U> <B>hash-code</B> <I>((self INTEGER-WRAPPER)) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX356"></A>
<DL>
<DT><U>Method:</U> <B>hash-code</B> <I>((self FLOAT-WRAPPER)) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX357"></A>
<DL>
<DT><U>Method:</U> <B>hash-code</B> <I>((self CHARACTER-WRAPPER)) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX358"></A>
<DL>
<DT><U>Method:</U> <B>hash-code</B> <I>((self BOOLEAN-WRAPPER)) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX359"></A>
<DL>
<DT><U>Method:</U> <B>hash-code</B> <I>((self STRING)) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX360"></A>
<DL>
<DT><U>Method:</U> <B>hash-code</B> <I>((self INTEGER)) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX361"></A>
<DL>
<DT><U>Method:</U> <B>hash-code</B> <I>((self FLOAT)) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX362"></A>
<DL>
<DT><U>Method:</U> <B>hash-code</B> <I>((self CHARACTER)) : INTEGER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX363"></A>
<DL>
<DT><U>Method:</U> <B>equal-hash-code</B> <I>((self OBJECT)) : INTEGER</I>
<DD>Return a hash code for <VAR>self</VAR> (can be negative).  Two objects that are <CODE>equal?</CODE>
are guaranteed to generate the same hash code (provided, that writers of
<CODE>object-equal?</CODE> methods also implemented the appropriate <CODE>equal-hash-code</CODE>
method).  Two objects that are not <CODE>equal?</CODE>do not necessarily generate different
hash codes.
</DL>
</P><P>

The following low-level utilities are available to implement specialized
hashing schemes or for defining new versions of <CODE>equal-hash-code</CODE>.
</P><P>

<A NAME="IDX364"></A>
<DL>
<DT><U>Function:</U> <B>hashmod</B> <I>((code INTEGER) (size INTEGER)) : INTEGER</I>
<DD>Map the hash code <VAR>code</VAR> onto a bucket index for a hash table
of <VAR>size</VAR> (i.e., onto the interval [0..size-1].  This is just like <CODE>rem</CODE> for
positive hash codes but also works for negative hash codes by mapping those
onto a positive number first.  Note, that the sign conversion mapping is not
equivalent to calling the <CODE>abs</CODE> function (it simply masks the sign bit for
speed) and therefore really only makes sense for hash codes.
</DL>
</P><P>

<A NAME="IDX365"></A>
<DL>
<DT><U>Function:</U> <B>rotate-hash-code</B> <I>((arg INTEGER)) : INTEGER</I>
<DD>Rotate <VAR>arg</VAR> to the right by 1 position.  This means shift <VAR>arg</VAR> to the right
by one and feed in <VAR>arg</VAR>s bit zero from the left.  In Lisp the result will stay
in positive FIXNUM range.  In C++ and Java this might return a negative
value which might be equal to NULL-INTEGER.  Important: to make this inlinable,
it must be called with an atom (i.e., constant or variable) as its argument.
This function is primarily useful for hashing sequences of items where the hash
code should take the sequential order of elements into account (e.g., lists).
</DL>
</P><P>

<A NAME="Key Value Maps"></A>
<HR SIZE="6">
<A NAME="SEC42"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC41"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC43"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.10 Key Value Maps </H2>
<!--docid::SEC42::-->
<P>

<CODE>KEY-VALUE-MAP</CODE> is a full-featured dictionary class that supports
<CODE>eql?</CODE> or extensible <CODE>equal?</CODE> equality tests, O(1) access
operations even for large numbers of entries by using a hash table,
light-weight <CODE>KV-CONS</CODE> representation for small tables and
iteration even if the dictionary is represented by a hash table (note
that in STELLA we cannot iterate over regular <CODE>HASH-TABLE</CODE>'s, since
native Lisp hash tables do not allow us to implement a hash table
iterator).  Since large <CODE>KEY-VALUE-MAP</CODE>'s are implemented via
<CODE>STELLA-HASH-TABLE</CODE>'s, we can support iteration.
</P><P>

<A NAME="IDX366"></A>
<DL>
<DT><U>Method:</U> <B>lookup</B> <I>((self KEY-VALUE-MAP) (key (LIKE (ANY-KEY SELF)))) : (LIKE (ANY-VALUE SELF))</I>
<DD>Lookup the entry identified by <VAR>key</VAR> in <VAR>self</VAR> and
return its value, or NULL if no such entry exists.    Uses an <CODE>eql?</CODE>
test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX367"></A>
<DL>
<DT><U>Method:</U> <B>insert-at</B> <I>((self KEY-VALUE-MAP) (key (LIKE (ANY-KEY SELF))) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Set the value of the entry identified by <VAR>key</VAR> in <VAR>self</VAR>
to <VAR>value</VAR> or add a new entry if no entry with <VAR>key</VAR> exists yet.  Uses an
<CODE>eql?</CODE> test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX368"></A>
<DL>
<DT><U>Method:</U> <B>remove-at</B> <I>((self KEY-VALUE-MAP) (key (LIKE (ANY-KEY SELF)))) :</I>
<DD>Remove the entry identified by <VAR>key</VAR> from <VAR>self</VAR>.  Uses an
<CODE>eql?</CODE> test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX369"></A>
<DL>
<DT><U>Method:</U> <B>length</B> <I>((self KEY-VALUE-MAP)) : INTEGER</I>
<DD>Return the number of entries in <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX370"></A>
<DL>
<DT><U>Method:</U> <B>empty?</B> <I>((self KEY-VALUE-MAP)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>self</VAR> has zero entries.
</DL>
</P><P>

<A NAME="IDX371"></A>
<DL>
<DT><U>Method:</U> <B>non-empty?</B> <I>((self KEY-VALUE-MAP)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>self</VAR> has at least 1 entry.
</DL>
</P><P>

<A NAME="IDX372"></A>
<DL>
<DT><U>Method:</U> <B>copy</B> <I>((self KEY-VALUE-MAP)) : (LIKE SELF)</I>
<DD>Return a copy of the map <VAR>self</VAR>.  All entries are freshly
allocated, however, the keys and values of entries are not copied themselves
 (similar to what we do for lists, etc.).
</DL>
</P><P>

<A NAME="IDX373"></A>
<DL>
<DT><U>Method:</U> <B>clear</B> <I>((self KEY-VALUE-MAP)) :</I>
<DD>Reset <VAR>self</VAR> to have zero entries.
</DL>
</P><P>

<A NAME="IDX374"></A>
<DL>
<DT><U>Method:</U> <B>allocate-iterator</B> <I>((self KEY-VALUE-MAP)) : (DICTIONARY-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF)))</I>
<DD>Allocate an iterator for <VAR>self</VAR>.  The only modifying
operations allowed during iteration are removal of the current element or
changing its value.  All other removal or insertion operations might lead
to corruption or undefined results.
</DL>
</P><P>

<A NAME="IDX375"></A>
<DL>
<DT><U>Method:</U> <B>consify</B> <I>((self KEY-VALUE-MAP)) : CONS</I>
<DD>Collect all entries of <VAR>self</VAR> into a cons list of
<CODE>(&#60;key&#62; &#60;value&#62;)</CODE> pairs and return the result.
</DL>
</P><P>

<A NAME="IDX376"></A>
<DL>
<DT><U>Method:</U> <B>object-equal?</B> <I>((x KEY-VALUE-MAP) (y OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>x</VAR> and <VAR>y</VAR> represent the same set of key/value pairs.
</DL>
</P><P>

<A NAME="IDX377"></A>
<DL>
<DT><U>Method:</U> <B>equal-hash-code</B> <I>((self KEY-VALUE-MAP)) : INTEGER</I>
<DD>Return an <CODE>equal?</CODE> hash code for <VAR>self</VAR>.  Note that this
is O(N) in the number of entries of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="Hash Sets"></A>
<HR SIZE="6">
<A NAME="SEC43"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC42"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC44"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.11 Hash Sets </H2>
<!--docid::SEC43::-->
<P>

<CODE>HASH-SET</CODE> is a full-featured set class that supports <CODE>eql?</CODE>
or extensible <CODE>equal?</CODE> equality tests, O(1) insert and
<CODE>member?</CODE> operations, O(N) <CODE>intersection</CODE> etc. operations even
for large numbers of entries by using a STELLA hash table, light-weight
<CODE>KV-CONS</CODE> representation for small sets and iteration even if the
set is represented by a hash table.  The only minor drawback right now
is that we waste one value slot per entry, since we piggy-back off
<CODE>KEY-VALUE-MAP</CODE>'s, however, that wastes at most 25% space.
</P><P>

<A NAME="IDX378"></A>
<DL>
<DT><U>Function:</U> <B>hash-set</B> <I>(&#38;rest (values OBJECT)) : HASH-SET</I>
<DD>Return an <CODE>eql?</CODE> HASH-SET containing <VAR>values</VAR>.
</DL>
</P><P>

<A NAME="IDX379"></A>
<DL>
<DT><U>Method:</U> <B>member?</B> <I>((self HASH-SET) (object OBJECT)) : BOOLEAN</I>
<DD>Return TRUE iff <VAR>object</VAR> is a member of the set <VAR>self</VAR>.
Uses an <CODE>eql?</CODE> test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX380"></A>
<DL>
<DT><U>Method:</U> <B>insert</B> <I>((self HASH-SET) (value (LIKE (ANY-VALUE SELF)))) :</I>
<DD>Add <VAR>value</VAR> to the set <VAR>self</VAR> unless it is already a member.
Uses an <CODE>eql?</CODE> test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX381"></A>
<DL>
<DT><U>Method:</U> <B>remove</B> <I>((self HASH-SET) (value (LIKE (ANY-VALUE SELF)))) : (LIKE SELF)</I>
<DD>Destructively remove <VAR>value</VAR> from the set <VAR>self</VAR> if it is a member and
return <VAR>self</VAR>.  Uses an <CODE>eql?</CODE> test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of
<VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX382"></A>
<DL>
<DT><U>Method:</U> <B>remove-if</B> <I>((self HASH-SET) (test? FUNCTION-CODE)) : (LIKE SELF)</I>
<DD>Destructively remove all elements of the set <VAR>self</VAR> for which
<VAR>test?</VAR> evaluates to TRUE.  <VAR>test?</VAR> takes a single argument of type OBJECT and
returns TRUE or FALSE.  Returns <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX383"></A>
<DL>
<DT><U>Method:</U> <B>pop</B> <I>((self HASH-SET)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Remove and return an arbitrary element of the set <VAR>self</VAR>.
Return NULL if the set is empty.  Performance note: for large sets implemented
via hash tables it takes O(N) to empty out the set with repeated calls to <CODE>pop</CODE>,
since the emptier the table gets, the longer it takes to find an element.
Therefore, it is usually better to use iteration with embedded removals for
such cases.
</DL>
</P><P>

<A NAME="IDX384"></A>
<DL>
<DT><U>Method:</U> <B>substitute</B> <I>((self HASH-SET) (new OBJECT) (old OBJECT)) : (LIKE SELF)</I>
<DD>Destructively replace <VAR>old</VAR> with <VAR>new</VAR> in the set <VAR>self</VAR>
unless <VAR>new</VAR> is already a member.  Uses an <CODE>eql?</CODE> test by default or <CODE>equal?</CODE>
if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX385"></A>
<DL>
<DT><U>Method:</U> <B>copy</B> <I>((self HASH-SET)) : (LIKE SELF)</I>
<DD>Return a copy of the set <VAR>self</VAR>.  All entries are freshly
allocated, however, the values are not copied themselves (similar to what we
do for lists, etc.).
</DL>
</P><P>

<A NAME="IDX386"></A>
<DL>
<DT><U>Method:</U> <B>consify</B> <I>((self HASH-SET)) : (CONS OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Collect all entries of <VAR>self</VAR> into a cons list and return the result.
</DL>
</P><P>

<A NAME="IDX387"></A>
<DL>
<DT><U>Method:</U> <B>subset?</B> <I>((self HASH-SET) (otherSet HASH-SET)) : BOOLEAN</I>
<DD>Return true if every element of <VAR>self</VAR> also occurs in <VAR>otherSet</VAR>.
Uses an <CODE>eql?</CODE> test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX388"></A>
<DL>
<DT><U>Method:</U> <B>equivalent-sets?</B> <I>((self HASH-SET) (otherSet HASH-SET)) : BOOLEAN</I>
<DD>Return true if every element of <VAR>self</VAR> occurs in <VAR>otherSet</VAR> and vice versa.
Uses an <CODE>eql?</CODE> test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX389"></A>
<DL>
<DT><U>Method:</U> <B>intersection</B> <I>((self HASH-SET) (otherSet HASH-SET)) : HASH-SET</I>
<DD>Return the set intersection of <VAR>self</VAR> and <VAR>otherSet</VAR> as a new set.
Uses an <CODE>eql?</CODE> test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX390"></A>
<DL>
<DT><U>Method:</U> <B>union</B> <I>((self HASH-SET) (otherSet HASH-SET)) : HASH-SET</I>
<DD>Return the set union of <VAR>self</VAR> and <VAR>otherSet</VAR> as a new set.
Uses an <CODE>eql?</CODE> test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX391"></A>
<DL>
<DT><U>Method:</U> <B>difference</B> <I>((self HASH-SET) (otherSet HASH-SET)) : HASH-SET</I>
<DD>Return the set difference of <VAR>self</VAR> and <VAR>otherSet</VAR> as a new set (i.e.,
all elements that are in <VAR>self</VAR> but not in <VAR>otherSet</VAR>).  Uses an <CODE>eql?</CODE> test
by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX392"></A>
<DL>
<DT><U>Method:</U> <B>subtract</B> <I>((self HASH-SET) (otherSet HASH-SET)) : HASH-SET</I>
<DD>Return the set difference of <VAR>self</VAR> and <VAR>otherSet</VAR> by destructively
removing elements from <VAR>self</VAR> that also occur in <VAR>otherSet</VAR>.  Uses an <CODE>eql?</CODE>
test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <VAR>self</VAR> is TRUE.
</DL>
</P><P>

<A NAME="IDX393"></A>
<DL>
<DT><U>Method:</U> <B>object-equal?</B> <I>((x HASH-SET) (y OBJECT)) : BOOLEAN</I>
<DD>Return TRUE iff sets <VAR>x</VAR> and <VAR>y</VAR> are HASH-SET's with equivalent members.
Uses an <CODE>eql?</CODE> test by default or <CODE>equal?</CODE> if <CODE>equal-test?</CODE> of <CODE>self</CODE> is TRUE.
This is equivalent to calling <CODE>equivalent-sets?</CODE>.
</DL>
</P><P>

<A NAME="IDX394"></A>
<DL>
<DT><U>Method:</U> <B>equal-hash-code</B> <I>((self HASH-SET)) : INTEGER</I>
<DD>Return an <CODE>equal?</CODE> hash code for <VAR>self</VAR>.  Note that this
is O(N) in the number of elements of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="Iterators"></A>
<HR SIZE="6">
<A NAME="SEC44"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC43"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC45"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.12 Iterators </H2>
<!--docid::SEC44::-->
<P>

<A NAME="IDX395"></A>
<DL>
<DT><U>Method:</U> <B>empty?</B> <I>((self ITERATOR)) : BOOLEAN</I>
<DD>Return TRUE if the sequence represented by <VAR>self</VAR>
has no elements.  Side-effect free.
</DL>
</P><P>

<A NAME="IDX396"></A>
<DL>
<DT><U>Method:</U> <B>member?</B> <I>((self ITERATOR) (value OBJECT)) : BOOLEAN</I>
<DD>Iterate over values of <VAR>self</VAR>, returning TRUE
if one of them is <CODE>eql</CODE> to 'value.
</DL>
</P><P>

<A NAME="IDX397"></A>
<DL>
<DT><U>Method:</U> <B>length</B> <I>((self ABSTRACT-ITERATOR)) : INTEGER</I>
<DD>Iterate over <VAR>self</VAR>, and count how many
items there are.  Bad idea if <VAR>self</VAR> iterates over an infinite
collection, since in that case it will run forever.'
</DL>
</P><P>

<A NAME="IDX398"></A>
<DL>
<DT><U>Method:</U> <B>pop</B> <I>((self ITERATOR)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the first item of the sequence represented by <VAR>self</VAR>,
or NULL if it is empty.  Destructively uses up the first iteration element.
</DL>
</P><P>

<A NAME="IDX399"></A>
<DL>
<DT><U>Method:</U> <B>advance</B> <I>((self ITERATOR) (n INTEGER)) : (LIKE SELF)</I>
<DD>Return <VAR>self</VAR> after skipping over the first
<VAR>n</VAR> elements in the (remainder of the) iteration.
</DL>
</P><P>

<A NAME="IDX400"></A>
<DL>
<DT><U>Method:</U> <B>concatenate</B> <I>((iterator1 ITERATOR) (iterator2 ITERATOR) &#38;rest (otherIterators ITERATOR)) : ALL-PURPOSE-ITERATOR</I>
<DD>Return an iterator that first generates all values of
<VAR>iterator1</VAR>, then those of <VAR>iterator2</VAR>, and then those of all <VAR>otherIterators</VAR>.
The generated values can be filtered by supplying a filter function to the
resulting iterator.
</DL>
</P><P>

<A NAME="IDX401"></A>
<DL>
<DT><U>Method:</U> <B>consify</B> <I>((self ITERATOR)) : (CONS OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return a list of elements generated by <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX402"></A>
<DL>
<DT><U>Method:</U> <B>next?</B> <I>((self ALL-PURPOSE-ITERATOR)) : BOOLEAN</I>
<DD>Apply the stored <CODE>next?</CODE> function to <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="Symbols"></A>
<HR SIZE="6">
<A NAME="SEC45"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC44"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC46"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.13 Symbols </H2>
<!--docid::SEC45::-->
<P>

<A NAME="IDX403"></A>
<DL>
<DT><U>Function:</U> <B>lookup-symbol</B> <I>((name STRING)) : SYMBOL</I>
<DD>Return the first symbol with <VAR>name</VAR> visible from the current module.
</DL>
</P><P>

<A NAME="IDX404"></A>
<DL>
<DT><U>Function:</U> <B>intern-symbol</B> <I>((name STRING)) : SYMBOL</I>
<DD>Return a newly-created or existing symbol with name <VAR>name</VAR>.
</DL>
</P><P>

<A NAME="IDX405"></A>
<DL>
<DT><U>Function:</U> <B>unintern-symbol</B> <I>((self SYMBOL)) :</I>
<DD>Remove <VAR>self</VAR> from its home module and the symbol table.
</DL>
</P><P>

<A NAME="IDX406"></A>
<DL>
<DT><U>Function:</U> <B>lookup-symbol-in-module</B> <I>((name STRING) (module MODULE) (local? BOOLEAN)) : SYMBOL</I>
<DD>Return the first symbol with <VAR>name</VAR> visible from <VAR>module</VAR>.
If <VAR>local?</VAR> only consider symbols directly interned in <VAR>module</VAR>.
If <VAR>module</VAR> is <CODE>null</CODE>, use <CODE>*MODULE*</CODE> instead.
</DL>
</P><P>

<A NAME="IDX407"></A>
<DL>
<DT><U>Function:</U> <B>intern-symbol-in-module</B> <I>((name STRING) (module MODULE) (local? BOOLEAN)) : SYMBOL</I>
<DD>Look for a symbol named <VAR>name</VAR> in <VAR>module</VAR> (if <VAR>local?</VAR> do
not consider inherited modules).  If none exists, intern it locally in
<VAR>module</VAR>.  Return the existing or newly-created symbol.
</DL>
</P><P>

<A NAME="IDX408"></A>
<DL>
<DT><U>Function:</U> <B>intern-derived-symbol</B> <I>((baseSymbol GENERALIZED-SYMBOL) (newName STRING)) : SYMBOL</I>
<DD>Return a newly-created or existing symbol with name
<VAR>newName</VAR> which is interned in the same module as <VAR>baseSymbol</VAR>.
</DL>
</P><P>

<A NAME="IDX409"></A>
<DL>
<DT><U>Function:</U> <B>visible-symbol?</B> <I>((self SYMBOL)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>self</VAR> is visible from the current module.
</DL>
</P><P>

<A NAME="IDX410"></A>
<DL>
<DT><U>Function:</U> <B>lookup-visible-symbols-in-module</B> <I>((name STRING) (module MODULE) (enforceShadowing? BOOLEAN)) : (CONS OF SYMBOL)</I>
<DD>Return the list of symbols with <VAR>name</VAR> visible from <VAR>module</VAR>.
More specific symbols (relative to the module precedence order defined by
<CODE>visible-modules</CODE>) come earlier in the list.  If <VAR>module</VAR> is <CODE>null</CODE>, start
from <CODE>*MODULE*</CODE> instead.  If <VAR>enforceShadowing?</VAR> is true, do not return any
symbols that are shadowed due to some :SHADOW declaration.
</DL>
</P><P>

<A NAME="IDX411"></A>
<DL>
<DT><U>Function:</U> <B>import-symbol</B> <I>((symbol SYMBOL) (module MODULE)) : SYMBOL</I>
<DD>Import <VAR>symbol</VAR> into <VAR>module</VAR> and return the imported <VAR>symbol</VAR>.
Signal an error if a different symbol with the same name already exists
locally in <VAR>module</VAR>.  Any symbol with the same name visible in <VAR>module</VAR> by
inheritance will be shadowed by the newly imported <VAR>symbol</VAR>.
</DL>
</P><P>

<A NAME="IDX412"></A>
<DL>
<DT><U>Function:</U> <B>safe-import-symbol</B> <I>((symbol SYMBOL) (module MODULE)) : SYMBOL</I>
<DD>Safe version of <CODE>import-symbol</CODE> (which see).  Only imports <VAR>symbol</VAR> if
no symbol with that name is currently interned or visible in <VAR>module</VAR>.
Returns <VAR>symbol</VAR> if it was imported or the conflicting symbol in <VAR>module</VAR>
otherwise.
</DL>
</P><P>

<A NAME="IDX413"></A>
<DL>
<DT><U>Function:</U> <B>lookup-surrogate</B> <I>((name STRING)) : SURROGATE</I>
<DD>Return the first surrogate with <VAR>name</VAR> visible from the current module.
</DL>
</P><P>

<A NAME="IDX414"></A>
<DL>
<DT><U>Function:</U> <B>intern-surrogate</B> <I>((name STRING)) : SURROGATE</I>
<DD>Return a newly-created or existing surrogate with name <VAR>name</VAR>.
</DL>
</P><P>

<A NAME="IDX415"></A>
<DL>
<DT><U>Function:</U> <B>unintern-surrogate</B> <I>((self SURROGATE)) :</I>
<DD>Remove <VAR>self</VAR> from its home module and the surrogate table.
</DL>
</P><P>

<A NAME="IDX416"></A>
<DL>
<DT><U>Function:</U> <B>lookup-surrogate-in-module</B> <I>((name STRING) (module MODULE) (local? BOOLEAN)) : SURROGATE</I>
<DD>Return the first surrogate with <VAR>name</VAR> visible from <VAR>module</VAR>.
If <VAR>local?</VAR> only consider surrogates directly interned in <VAR>module</VAR>.
If <VAR>module</VAR> is <CODE>null</CODE>, use <CODE>*MODULE*</CODE> instead.
</DL>
</P><P>

<A NAME="IDX417"></A>
<DL>
<DT><U>Function:</U> <B>intern-surrogate-in-module</B> <I>((name STRING) (module MODULE) (local? BOOLEAN)) : SURROGATE</I>
<DD>Look for a symbol named <VAR>name</VAR> in <VAR>module</VAR> (if <VAR>local?</VAR> do
not consider inherited modules).  If none exists, intern it locally in
<VAR>module</VAR>.  Return the existing or newly-created symbol.
</DL>
</P><P>

<A NAME="IDX418"></A>
<DL>
<DT><U>Function:</U> <B>intern-derived-surrogate</B> <I>((baseSymbol GENERALIZED-SYMBOL) (newName STRING)) : SURROGATE</I>
<DD>Return a newly-created or existing surrogate with name
<VAR>newName</VAR> which is interned in the same module as <VAR>baseSymbol</VAR>.
</DL>
</P><P>

<A NAME="IDX419"></A>
<DL>
<DT><U>Function:</U> <B>visible-surrogate?</B> <I>((self SURROGATE)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>self</VAR> is visible from the current module.
</DL>
</P><P>

<A NAME="IDX420"></A>
<DL>
<DT><U>Function:</U> <B>lookup-visible-surrogates-in-module</B> <I>((name STRING) (module MODULE) (enforceShadowing? BOOLEAN)) : (CONS OF SURROGATE)</I>
<DD>Return the list of surrogates with <VAR>name</VAR> visible from <VAR>module</VAR>.
More specific surrogates (relative to the module precedence order defined by
<CODE>visible-modules</CODE>) come earlier in the list.  If <VAR>module</VAR> is <CODE>null</CODE>, start
from <CODE>*MODULE*</CODE> instead.  If <VAR>enforceShadowing?</VAR> is true, do not return any
surrogates that are shadowed due to some :SHADOW declaration.
</DL>
</P><P>

<A NAME="IDX421"></A>
<DL>
<DT><U>Function:</U> <B>import-surrogate</B> <I>((surrogate SURROGATE) (module MODULE)) : SURROGATE</I>
<DD>Import <VAR>surrogate</VAR> into <VAR>module</VAR> and return the imported <VAR>surrogate</VAR>.
Signal an error if a different surrogate with the same name already exists
locally in <VAR>module</VAR>.  Any surrogate with the same name visible in <VAR>module</VAR> by
inheritance will be shadowed by the newly imported <VAR>surrogate</VAR>.
</DL>
</P><P>

<A NAME="IDX422"></A>
<DL>
<DT><U>Function:</U> <B>safe-import-surrogate</B> <I>((surrogate SURROGATE) (module MODULE)) : SURROGATE</I>
<DD>Safe version of <CODE>import-surrogate</CODE> (which see).  Only imports <VAR>surrogate</VAR> if
no surrogate with that name is currently interned or visible in <VAR>module</VAR>.
Returns <VAR>surrogate</VAR> if it was imported or the conflicting surrogate in <VAR>module</VAR>
otherwise.
</DL>
</P><P>

<A NAME="IDX423"></A>
<DL>
<DT><U>Function:</U> <B>lookup-keyword</B> <I>((name STRING)) : KEYWORD</I>
<DD>Return the keyword with <VAR>name</VAR> if it exists.
</DL>
</P><P>

<A NAME="IDX424"></A>
<DL>
<DT><U>Function:</U> <B>intern-keyword</B> <I>((name STRING)) : KEYWORD</I>
<DD>Return a newly-created or existing keyword with name
<VAR>name</VAR>.  Storage note: a COPY of <VAR>name</VAR> is stored in the keyword
</DL>
</P><P>

<A NAME="IDX425"></A>
<DL>
<DT><U>Function:</U> <B>gensym</B> <I>((prefix STRING)) : SYMBOL</I>
<DD>Return a transient symbol with a name beginning with
<VAR>prefix</VAR> and ending with a globally gensym'd integer.
</DL>
</P><P>

<A NAME="IDX426"></A>
<DL>
<DT><U>Function:</U> <B>local-gensym</B> <I>((prefix STRING)) : SYMBOL</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX427"></A>
<DL>
<DT><U>Function:</U> <B>symbol-plist</B> <I>((symbol SYMBOL)) : CONS</I>
<DD>Return the property list of <VAR>symbol</VAR>.  The <CODE>symbol-plist</CODE>
of a symbol can be set with <CODE>setf</CODE>.  IMPORTANT: Property list are modified 
destructively, hence, if you supply it as a whole make sure to always supply
a modfiable copy, e.g., by using <CODE>bquote</CODE>.
</DL>
</P><P>

<A NAME="IDX428"></A>
<DL>
<DT><U>Function:</U> <B>symbol-property</B> <I>((symbol SYMBOL) (key STANDARD-OBJECT)) : OBJECT</I>
<DD>Return the property of <VAR>symbol</VAR> whose key is <CODE>eq?</CODE> to <VAR>key</VAR>.
Symbol properties can be set with <CODE>setf</CODE>.
</DL>
</P><P>

<A NAME="IDX429"></A>
<DL>
<DT><U>Function:</U> <B>symbol-value</B> <I>((symbol SYMBOL)) : OBJECT</I>
<DD>Return the value of <VAR>symbol</VAR>.  Note, that this value is not
visible to code that references a variable with the same name as <VAR>symbol</VAR>.
The <CODE>symbol-value</CODE> is simply a special property that can always be accessed
in constant time.  The <CODE>symbol-value</CODE> of a symbol can be changed with <CODE>setf</CODE>.
</DL>
</P><P>

<A NAME="IDX430"></A>
<DL>
<DT><U>Function:</U> <B>symbolize</B> <I>((surrogate SURROGATE)) : SYMBOL</I>
<DD>Convert <VAR>surrogate</VAR> into a symbol with the same name and module.
</DL>
</P><P>

<A NAME="Contexts and Modules"></A>
<HR SIZE="6">
<A NAME="SEC46"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC45"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC47"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.14 Context and Modules </H2>
<!--docid::SEC46::-->
<P>

<A NAME="IDX431"></A>
<DL>
<DT><U>Function:</U> <B>get-stella-context</B> <I>((pathName STRING) (error? BOOLEAN)) : CONTEXT</I>
<DD>Return the context located at <VAR>pathName</VAR>, or <CODE>null</CODE>
if no such context exists.  If <VAR>error?</VAR> is <CODE>true</CODE>, throw an exception
if no context is found, otherwise silently return <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX432"></A>
<DL>
<DT><U>Function:</U> <B>clear-context</B> <I>((self CONTEXT)) :</I>
<DD>Destroy all objects belonging to <VAR>self</VAR> or any of its subcontexts.
</DL>
</P><P>

<A NAME="IDX433"></A>
<DL>
<DT><U>Macro:</U> <B>within-context</B> <I>((contextForm OBJECT) &#38;body (body CONS)) : OBJECT</I>
<DD>Execute <VAR>body</VAR> within the context resulting from <VAR>contextForm</VAR>.
</DL>
</P><P>

<A NAME="IDX434"></A>
<DL>
<DT><U>Method:</U> <B>destroy-context</B> <I>((self CONTEXT)) :</I>
<DD>Make the translator happy.
</DL>
</P><P>

<A NAME="IDX435"></A>
<DL>
<DT><U>Method:</U> <B>destroy-context</B> <I>((self STRING)) :</I>
<DD>Destroy the context <VAR>self</VAR>, and recursively destroy
all contexts that inherit <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX436"></A>
<DL>
<DT><U>Method:</U> <B>change-context</B> <I>((context CONTEXT)) : CONTEXT</I>
<DD>Change the current context to be the context
<VAR>context</VAR>.
</DL>
</P><P>

<A NAME="IDX437"></A>
<DL>
<DT><U>Method:</U> <B>change-context</B> <I>((contextName STRING)) : CONTEXT</I>
<DD>Change the current context to be the context named
<VAR>contextName</VAR>.
</DL>
</P><P>

<A NAME="IDX438"></A>
<DL>
<DT><U>Command:</U> <B>cc</B> <I>(&#38;rest (name NAME)) : CONTEXT</I>
<DD>Change the current context to the one named <VAR>name</VAR>.  Return the
value of the new current context.  If no <VAR>name</VAR> is supplied, return
the pre-existing value of the current context.  <CODE>cc</CODE> is a no-op if the
context reference cannot be successfully evaluated.
</DL>
</P><P>

<A NAME="IDX439"></A>
<DL>
<DT><U>Command:</U> <B>defmodule</B> <I>((name NAME) &#38;rest (options OBJECT)) :</I>
<DD>Define (or redefine) a module named <VAR>name</VAR>.
The accepted syntax is:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  (defmodule &#60;module-name&#62;
     [:documentation &#60;docstring&#62;]
     [:includes {&#60;module-name&#62; | (&#60;module-name&#62;*)}]
     [:uses {&#60;module-name&#62; | (&#60;module-name&#62;*)}]
     [:lisp-package &#60;package-name-string&#62;]
     [:java-package &#60;package-specification-string&#62;]
     [:cpp-namespace &#60;namespace-name-string&#62;]
     [:java-catchall-class
     [:api? {TRUE | FALSE}]
     [:case-sensitive? {TRUE | FALSE}]
     [:shadow (&#60;symbol&#62;*)]
     [:java-catchall-class &#60;class-name-string&#62;]
     [&#60;other-options&#62;*])
</pre></td></tr></table></P><P>

<VAR>name</VAR> can be a string or a symbol.
</P><P>

Modules include objects from other modules via two separate mechanisms:
(1) they inherit from their parents specified via the <CODE>:includes</CODE> option
and/or a fully qualified module name, and (2) they inherit from used
modules specified via the <CODE>:uses</CODE> option.  The main difference between
the two mechanisms is that inheritance from parents is transitive, while
uses-links are only followed one level deep.  I.e., a module A that uses
B will see all objects of B (and any of B's parents) but not see anything
from modules used by B.  Another difference is that only objects declared
as public can be inherited via uses-links (this is not yet enforced).
Note that - contrary to Lisp - there are separate name spaces for classes,
functions, and variables.  For example, a module could inherit the class
<CODE>CONS</CODE> from the <CODE>STELLA</CODE> module, but shadow the function of the same name.
</P><P>

The above discussion of <CODE>:includes</CODE> and <CODE>:uses</CODE> semantics keyed on the
inheritance/visibility of symbols. The PowerLoom system makes another
very important distinction: If a module <CODE>A</CODE> is inherited directly or
indirectly via <CODE>:includes</CODE> specification(s) by a submodule <CODE>B</CODE>, then all
definitions and facts asserted in <CODE>A</CODE> are visible in <CODE>B</CODE>. This is not the
cases for <CODE>:uses</CODE>; the <CODE>:uses</CODE> options does not impact inheritance of
propositions at all.
</P><P>

The list of modules specified in the
<CODE>:includes</CODE> option plus (if supplied) the parent in the path used for
<VAR>name</VAR> become the new module's parents. If no <CODE>:uses</CODE> option was
supplied, the new module will use the <CODE>STELLA</CODE> module by default,
otherwise, it will use the set of specified modules.
If <CODE>:case-sensitive?</CODE> is supplied as TRUE, symbols in the module will be
interned case-sensitively, otherwise (the default), they will be
converted to uppercase before they get interned. Modules can shadow
definitions of functions and classes inherited from parents or used
modules. Shadowing is done automatically, but generates a warning unless
the shadowed type or function name is listed in the <CODE>:shadow</CODE> option of
the module definition .
</P><P>

Examples:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>  (defmodule "PL-KERNEL/PL-USER"
    :uses ("LOGIC" "STELLA")
    :package "PL-USER")

  (defmodule PL-USER/GENEALOGY)
</pre></td></tr></table></P><P>

The remaining options are relevant only for modules that contain STELLA
code.  Modules used only to contain knowledge base definitions and assertions
have no use for them:
</P><P>

The keywords <CODE>:lisp-package</CODE>, <CODE>:java-package</CODE>, and <CODE>:cpp-package</CODE> specify
the name of a native package or name space in which symbols of the module
should be allocated when they get translated into one of Lisp, Java, or
C++. By default, Lisp symbols are allocated in the <CODE>STELLA</CODE> package, and
C++ names are translated without any prefixes. The rules that the STELLA
translator uses to attach translated Java objects to classes and packages
are somewhat complex. Use :java-package option to specify a list of
package names (separated by periods) that prefix the Java object in this
module.  Use :java-catchall-class to specify the name of the Java class to
contain all global &#38; special variables, parameter-less functions and functions 
defined on arguments that are not classes in the current module.
The default value will be the name of the module.
</P><P>

When set to TRUE, the :api? option tells the PowerLoom User Manual
generator that all functions defined in this module should be included in
the API section. Additionally, the Java translator makes all API
functions <CODE>synchronized</CODE>.
</P><P>

</DL>
</P><P>

<A NAME="IDX440"></A>
<DL>
<DT><U>Function:</U> <B>get-stella-module</B> <I>((pathName STRING) (error? BOOLEAN)) : MODULE</I>
<DD>Return the module located at <VAR>pathName</VAR>, or <CODE>null</CODE>
if no such module exists.  The search looks at ancestors and top-most
 (cardinal) modules.  If <VAR>error?</VAR> is <CODE>true</CODE>, throw an exception if no
 module is found.
</DL>
</P><P>

<A NAME="IDX441"></A>
<DL>
<DT><U>Function:</U> <B>find-or-create-module</B> <I>((pathname STRING)) : MODULE</I>
<DD>Return a module located at <VAR>pathname</VAR> if one exists,
  otherwise create one
</DL>
</P><P>

<A NAME="IDX442"></A>
<DL>
<DT><U>Command:</U> <B>clear-module</B> <I>(&#38;rest (name NAME)) :</I>
<DD>Destroy all objects belonging to module <VAR>name</VAR> or any of its children.
If no <VAR>name</VAR> is supplied, the current module will be cleared after
confirming with the user.  Important modules such as STELLA are protected
against accidental clearing.
</DL>
</P><P>

<A NAME="IDX443"></A>
<DL>
<DT><U>Function:</U> <B>destroy-module</B> <I>((self MODULE)) :</I>
<DD>Destroy the module <VAR>self</VAR>, and recursively destroy
all contexts that inherit <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX444"></A>
<DL>
<DT><U>Method:</U> <B>destroy-context</B> <I>((self MODULE)) :</I>
<DD>Destroy the context <VAR>self</VAR>, and recursively destroy
all contexts that inherit <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX445"></A>
<DL>
<DT><U>Function:</U> <B>visible-modules</B> <I>((from MODULE)) : (CONS OF MODULE)</I>
<DD>Return a list of all modules visible from module <VAR>from</VAR> (or <CODE>*module*</CODE>
if <VAR>from</VAR> is NULL.  The generated modules are generated from most to
least-specific and will start with the module <VAR>from</VAR>.
</DL>
</P><P>

<A NAME="IDX446"></A>
<DL>
<DT><U>Macro:</U> <B>within-module</B> <I>((moduleForm OBJECT) &#38;body (body CONS)) : OBJECT</I>
<DD>Execute <VAR>body</VAR> within the module resulting from <VAR>moduleForm</VAR>.
<CODE>*module*</CODE> is an acceptable <VAR>moduleForm</VAR>.  It will locally rebind 
<CODE>*module*</CODE> and <CODE>*context*</CODE> and shield the outer bindings from changes.
</DL>
</P><P>

<A NAME="IDX447"></A>
<DL>
<DT><U>Command:</U> <B>in-module</B> <I>((name NAME)) : MODULE</I>
<DD>Change the current module to the module named <VAR>name</VAR>.
</DL>
</P><P>

<A NAME="IDX448"></A>
<DL>
<DT><U>Method:</U> <B>change-module</B> <I>((module MODULE)) : MODULE</I>
<DD>Change the current module to be the module
<VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX449"></A>
<DL>
<DT><U>Method:</U> <B>change-module</B> <I>((moduleName STRING)) : MODULE</I>
<DD>Change the current module to be the module named
<VAR>moduleName</VAR>.
</DL>
</P><P>

<A NAME="IDX450"></A>
<DL>
<DT><U>Function:</U> <B>create-world</B> <I>((parentContext CONTEXT) (name STRING)) : WORLD</I>
<DD>Create a new world below the world or module <VAR>parentContext</VAR>.
Optionally, specify a name.
</DL>
</P><P>

<A NAME="IDX451"></A>
<DL>
<DT><U>Function:</U> <B>push-world</B> <I>() : WORLD</I>
<DD>Spawn a new world that is a child of the current context,
and change the current context to the new world.
</DL>
</P><P>

<A NAME="IDX452"></A>
<DL>
<DT><U>Function:</U> <B>pop-world</B> <I>() : CONTEXT</I>
<DD>Destroy the current world and change the current
context to be its parent.  Return the current context. Nothing happens
if there is no current world.
</DL>
</P><P>

<A NAME="IDX453"></A>
<DL>
<DT><U>Method:</U> <B>destroy-context</B> <I>((self WORLD)) :</I>
<DD>Destroy the context <VAR>self</VAR>, and recursively destroy
all contexts that inherit <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX454"></A>
<DL>
<DT><U>Macro:</U> <B>within-world</B> <I>((worldForm OBJECT) &#38;body (body CONS)) : OBJECT</I>
<DD>Execute <VAR>body</VAR> within the world resulting from <VAR>worldForm</VAR>.
</DL>
</P><P>

<A NAME="Input and Output"></A>
<HR SIZE="6">
<A NAME="SEC47"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC46"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC48"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.15 Input and Output </H2>
<!--docid::SEC47::-->
<P>

<A NAME="IDX455"></A>
<DL>
<DT><U>Function:</U> <B>read-s-expression</B> <I>((stream INPUT-STREAM)) : OBJECT BOOLEAN</I>
<DD>Read one STELLA s-expression from <VAR>stream</VAR> and return
the result.  Return <CODE>true</CODE> as the second value on EOF.
</DL>
</P><P>

<A NAME="IDX456"></A>
<DL>
<DT><U>Function:</U> <B>read-s-expression-from-string</B> <I>((string STRING)) : OBJECT</I>
<DD>Read one STELLA s-expression from <VAR>string</VAR> and
return the result.
</DL>
</P><P>

<A NAME="IDX457"></A>
<DL>
<DT><U>Function:</U> <B>read-line</B> <I>((inputStream INPUT-STREAM)) : STRING BOOLEAN</I>
<DD>Read one line from <VAR>inputStream</VAR> and return the result.
Return <CODE>true</CODE> as the second value on EOF.
</DL>
</P><P>

<A NAME="IDX458"></A>
<DL>
<DT><U>Function:</U> <B>read-character</B> <I>((inputStream INPUT-STREAM)) : CHARACTER BOOLEAN</I>
<DD>Read one character from <VAR>inputStream</VAR> and return the result.
Return <CODE>true</CODE> as the second value on EOF.
</DL>
</P><P>

<A NAME="IDX459"></A>
<DL>
<DT><U>Function:</U> <B>unread-character</B> <I>((ch CHARACTER) (inputStream INPUT-STREAM)) :</I>
<DD>Unread <VAR>ch</VAR> from <VAR>inputStream</VAR>.  Signal an error if <VAR>ch</VAR>
was not the last character read.
</DL>
</P><P>

<A NAME="IDX460"></A>
<DL>
<DT><U>Function:</U> <B>y-or-n?</B> <I>((message STRING)) : BOOLEAN</I>
<DD>Read a line of input from STANDARD-INPUT and return <CODE>true</CODE>
if the input was <CODE>y</CODE> or <CODE>false</CODE> if the input was <CODE>n</CODE>.  Loop until either
<CODE>y</CODE> or <CODE>n</CODE> was entered.  If <VAR>message</VAR> is non-`null' prompt with it before
the input is read.  See also special variable <CODE>*USER-QUERY-ACTION*</CODE>.
</DL>
</P><P>

<A NAME="IDX461"></A>
<DL>
<DT><U>Function:</U> <B>yes-or-no?</B> <I>((message STRING)) : BOOLEAN</I>
<DD>Read a line of input from STANDARD-INPUT and return <CODE>true</CODE>
if the input was <CODE>yes</CODE> or <CODE>false</CODE> if the input was <CODE>no</CODE>.  Loop until either
<CODE>yes</CODE> or <CODE>no</CODE> was entered.  If <VAR>message</VAR> is non-`null' prompt with it before
the input is read.  See also special variable <CODE>*USER-QUERY-ACTION*</CODE>.
</DL>
</P><P>

<A NAME="Files"></A>
<HR SIZE="6">
<A NAME="SEC48"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC47"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC49"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.16 Files </H2>
<!--docid::SEC48::-->
<P>

<A NAME="IDX462"></A>
<DL>
<DT><U>Function:</U> <B>probe-file?</B> <I>((fileName FILE-NAME)) : BOOLEAN</I>
<DD>Return true if file <VAR>fileName</VAR> exists.  Note that this does
not necessarily mean that the file can also be read.
</DL>
</P><P>

<A NAME="IDX463"></A>
<DL>
<DT><U>Function:</U> <B>file-write-date</B> <I>((fileName FILE-NAME)) : CALENDAR-DATE</I>
<DD>Return the time at which file <VAR>fileName</VAR> was last modified or
NULL if that cannot be determined.
</DL>
</P><P>

<A NAME="IDX464"></A>
<DL>
<DT><U>Function:</U> <B>file-length</B> <I>((fileName FILE-NAME)) : INTEGER</I>
<DD>Return the length of file <VAR>fileName</VAR> in bytes or NULL if that
cannot be determined.  Note that this will currently overrun for files that
are longer than what can be represented by a STELLA integer.
</DL>
</P><P>

<A NAME="IDX465"></A>
<DL>
<DT><U>Function:</U> <B>copy-file</B> <I>((fromFile FILE-NAME) (toFile FILE-NAME)) :</I>
<DD>Copy file <VAR>fromFile</VAR> to file <VAR>toFile</VAR>, clobbering
any data already in <VAR>toFile</VAR>.
</DL>
</P><P>

<A NAME="IDX466"></A>
<DL>
<DT><U>Function:</U> <B>delete-file</B> <I>((fileName FILE-NAME)) :</I>
<DD>Delete the file <VAR>fileName</VAR>.
</DL>
</P><P>

<A NAME="IDX467"></A>
<DL>
<DT><U>Function:</U> <B>directory-file-name</B> <I>((directory FILE-NAME)) : FILE-NAME</I>
<DD>Return <VAR>directory</VAR> as a file name, i.e., without a terminating
directory separator.
</DL>
</P><P>

<A NAME="IDX468"></A>
<DL>
<DT><U>Function:</U> <B>directory-parent-directory</B> <I>((directory FILE-NAME) (level INTEGER)) : FILE-NAME</I>
<DD>Return the <VAR>level</VAR>-th parent directory component of <VAR>directory</VAR>
including the final directory separator, or the empty string if <VAR>directory</VAR> does
not have that many parents.
</DL>
</P><P>

<A NAME="IDX469"></A>
<DL>
<DT><U>Function:</U> <B>file-name-as-directory</B> <I>((file FILE-NAME)) : FILE-NAME</I>
<DD>Return <VAR>file</VAR> interpreted as a directory, i.e., with a
terminating directory separator.  If <VAR>file</VAR> is the empty string simply
return the empty string, i.e., interpret it as the current directory instead
of the root directory.
</DL>
</P><P>

<A NAME="IDX470"></A>
<DL>
<DT><U>Function:</U> <B>file-name-directory</B> <I>((file FILE-NAME)) : FILE-NAME</I>
<DD>Return the directory component of <VAR>file</VAR> including the final
directory separator or the empty string if <VAR>file</VAR> does not include a directory.
Note that for purposes of this function, a logical host is considered part of
the directory portion of <VAR>file</VAR>
</DL>
</P><P>

<A NAME="IDX471"></A>
<DL>
<DT><U>Function:</U> <B>file-name-without-directory</B> <I>((file FILE-NAME)) : FILE-NAME</I>
<DD>Return the file name portion of <VAR>file</VAR> by removing any
directory and logical host components.
</DL>
</P><P>

<A NAME="IDX472"></A>
<DL>
<DT><U>Function:</U> <B>file-name-without-extension</B> <I>((file FILE-NAME)) : FILE-NAME</I>
<DD>Remove <VAR>file</VAR>s extension (or type) if there is any and
return the result.
</DL>
</P><P>

<A NAME="IDX473"></A>
<DL>
<DT><U>Function:</U> <B>file-extension</B> <I>((file FILE-NAME)) : STRING</I>
<DD>Return <VAR>file</VAR>s extension (or type) if it has any including
the separator character.
</DL>
</P><P>

<A NAME="IDX474"></A>
<DL>
<DT><U>Function:</U> <B>file-base-name</B> <I>((file FILE-NAME)) : FILE-NAME</I>
<DD>Remove <VAR>file</VAR>s directory (including logical host) and
extension components and return the result.
</DL>
</P><P>

<A NAME="IDX475"></A>
<DL>
<DT><U>Function:</U> <B>absolute-pathname?</B> <I>((pathname STRING)) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX476"></A>
<DL>
<DT><U>Function:</U> <B>logical-host?</B> <I>((host STRING)) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX477"></A>
<DL>
<DT><U>Function:</U> <B>logical-pathname?</B> <I>((pathname STRING)) : BOOLEAN</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX478"></A>
<DL>
<DT><U>Function:</U> <B>translate-logical-pathname</B> <I>((pathname STRING)) : STRING</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX479"></A>
<DL>
<DT><U>Function:</U> <B>directory-separator</B> <I>() : CHARACTER</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX480"></A>
<DL>
<DT><U>Function:</U> <B>directory-separator-string</B> <I>() : STRING</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="Dates and Times"></A>
<HR SIZE="6">
<A NAME="SEC49"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC48"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC50"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.17 Dates and Times </H2>
<!--docid::SEC49::-->
<P>

<A NAME="IDX481"></A>
<DL>
<DT><U>Function:</U> <B>get-current-date-time</B> <I>() : INTEGER INTEGER INTEGER KEYWORD INTEGER INTEGER INTEGER INTEGER</I>
<DD>Returns the current time in UTC as multiple values of
year month day day-of-week hour minute second millisecond.  Currently
millisecond will always be zero (even in Java where it is technically available).
</DL>
</P><P>

<A NAME="IDX482"></A>
<DL>
<DT><U>Function:</U> <B>get-local-time-zone</B> <I>() : FLOAT</I>
<DD>Returns the current time zone offset from UTC as a float,
considering the effects of daylight savings time.
</DL>
</P><P>

<A NAME="IDX483"></A>
<DL>
<DT><U>Function:</U> <B>make-current-date-time</B> <I>() : CALENDAR-DATE</I>
<DD>Create a calendar date with current time and date.
</DL>
</P><P>

<A NAME="IDX484"></A>
<DL>
<DT><U>Function:</U> <B>make-date-time</B> <I>((year INTEGER) (month INTEGER) (day INTEGER) (hour INTEGER) (minute INTEGER) (second INTEGER) (millis INTEGER) (timezone FLOAT)) : CALENDAR-DATE</I>
<DD>Create a calendar date with the specified components.  <VAR>year</VAR> must be
the complete year (i.e., a year of 98 is 98 A.D in the 1st century).
<VAR>timezone</VAR> is a real number in the range -12.0 to +14.0 where UTC is zone 0.0;  The number
is the number of hours to add to UTC to arrive at local time.
</DL>
</P><P>

<A NAME="IDX485"></A>
<DL>
<DT><U>Function:</U> <B>parse-date-time</B> <I>((date-time-string STRING) (start INTEGER) (end INTEGER) (error-on-mismatch? BOOLEAN)) : DECODED-DATE-TIME</I>
<DD>Tries very hard to make sense out of the argument <VAR>date-time-string</VAR> and
returns a time structure if successful.  If not, it returns <CODE>null</CODE>.
If <VAR>error-on-mismatch?</VAR> is true, parse-date-time will signal an error instead of
returning <CODE>null</CODE>.  
Default values are 00:00:00 local time on the current date
</DL>
</P><P>

<A NAME="IDX486"></A>
<DL>
<DT><U>Method:</U> <B>decode-calendar-date</B> <I>((date CALENDAR-DATE) (timezone FLOAT)) : DECODED-DATE-TIME</I>
<DD>Returns a decoded time object for <VAR>date</VAR> interpreted in <VAR>timezone</VAR>
<VAR>timezone</VAR> is the number of hours added to UTC to get local time.  It is 
in the range -12.0 to +14.0 where UTC is zone 0.0
</DL>
</P><P>

<A NAME="IDX487"></A>
<DL>
<DT><U>Method:</U> <B>encode-calendar-date</B> <I>((time-structure DECODED-DATE-TIME)) : CALENDAR-DATE</I>
<DD>Returns a calendar date object for <VAR>time-structure</VAR>.
</DL>
</P><P>

<A NAME="IDX488"></A>
<DL>
<DT><U>Function:</U> <B>calendar-date-to-string</B> <I>((date CALENDAR-DATE) (timezone FLOAT) (include-timezone? BOOLEAN)) : STRING</I>
<DD>Returns a string representation of <VAR>date</VAR> adjusted for <VAR>timezone</VAR>
</DL>
</P><P>

<A NAME="IDX489"></A>
<DL>
<DT><U>Function:</U> <B>string-to-calendar-date</B> <I>((input STRING)) : CALENDAR-DATE</I>
<DD>Returns a calendar date object representing the date and time
parsed from the <VAR>input</VAR> string.  If no valid parse is found,
<CODE>null</CODE> is returned.
</DL>
</P><P>

<A NAME="IDX490"></A>
<DL>
<DT><U>???:</U> <B>relative-date-to-string</B>
<DD>Not yet implemented.
</DL>
</P><P>

<A NAME="IDX491"></A>
<DL>
<DT><U>Function:</U> <B>compute-calendar-date</B> <I>((julian-day INTEGER)) : INTEGER INTEGER INTEGER KEYWORD</I>
<DD>Returns the YEAR, MONTH, DAY, DAY-OF-WEEK on which the given
<VAR>julian-day</VAR> begins at noon.
</DL>
</P><P>

<A NAME="IDX492"></A>
<DL>
<DT><U>Function:</U> <B>compute-day-of-week</B> <I>((yyyy INTEGER) (mm INTEGER) (dd INTEGER)) : KEYWORD</I>
<DD>Returns the day of the week for yyyy-mm-dd.
</DL>
</P><P>

<A NAME="IDX493"></A>
<DL>
<DT><U>Function:</U> <B>compute-day-of-week-julian</B> <I>((julian-day INTEGER)) : KEYWORD</I>
<DD>Returns the day of the week for julian-day
</DL>
</P><P>

<A NAME="IDX494"></A>
<DL>
<DT><U>Function:</U> <B>compute-julian-day</B> <I>((yyyy INTEGER) (mm INTEGER) (dd INTEGER)) : INTEGER</I>
<DD>Returns the Julian day that starts at noon on yyyy-mm-dd.
<VAR>yyyy</VAR> is the year.  <VAR>mm</VAR> is the month.  <VAR>dd</VAR> is the day of month.
Negative years are B.C.  Remember there is no year zero.
</DL>
</P><P>

<A NAME="IDX495"></A>
<DL>
<DT><U>Function:</U> <B>compute-next-moon-phase</B> <I>((n INTEGER) (phase KEYWORD)) : INTEGER FLOAT</I>
<DD>Returns the Julian Day and fraction of day of the Nth occurence
since January 1, 1900 of moon PHASE.  PHASE is one of :NEW-MOON, :FIRST-QUARTER,
:FULL-MOON, :LAST-QUARTER
</DL>
</P><P>

<A NAME="IDX496"></A>
<DL>
<DT><U>Function:</U> <B>decode-time-in-millis</B> <I>((time INTEGER)) : INTEGER INTEGER INTEGER INTEGER</I>
<DD>Returns multiple values of hours, minutes, seconds, milliseconds for
<VAR>time</VAR> specified in milliseconds.
</DL>
</P><P>

<A NAME="IDX497"></A>
<DL>
<DT><U>Function:</U> <B>julian-day-to-modified-julian-day</B> <I>((julian-day INTEGER)) : INTEGER</I>
<DD>Returns the modified Julian day during which <VAR>julian-day</VAR>starts at noon.
</DL>
</P><P>

<A NAME="IDX498"></A>
<DL>
<DT><U>Function:</U> <B>modified-julian-day-to-julian-day</B> <I>((modified-julian-day INTEGER)) : INTEGER</I>
<DD>Returns the modified Julian day during which <CODE>julian-day</CODE>starts at noon.
</DL>
</P><P>

<A NAME="IDX499"></A>
<DL>
<DT><U>Function:</U> <B>time-add</B> <I>((t1 DATE-TIME-OBJECT) (t2 DATE-TIME-OBJECT)) : DATE-TIME-OBJECT</I>
<DD>Add <VAR>t1</VAR> to <VAR>t2</VAR>.
If one of <VAR>t1</VAR> or <VAR>t2</VAR> is a calendar date, then the result is a calendar date.
If both <VAR>t1</VAR> and <VAR>t2</VAR> are relative dates, then the result is a relative date.
<VAR>t1</VAR> and <VAR>t2</VAR> cannot both be calendar dates.
</DL>
</P><P>

<A NAME="IDX500"></A>
<DL>
<DT><U>Function:</U> <B>time-divide</B> <I>((t1 TIME-DURATION) (t2 OBJECT)) : OBJECT</I>
<DD>Divides the relative date <VAR>t1</VAR> by <VAR>t2</VAR>.  <VAR>t2</VAR> must be
either a relative date or a wrapped number.  If <VAR>t2</VAR> is a relative date,
then the return value will be a wrapped float.  If <VAR>t2</VAR> is a wrapped number,
then the reutrn value will be a relative date.
</DL>
</P><P>

<A NAME="IDX501"></A>
<DL>
<DT><U>Function:</U> <B>time-multiply</B> <I>((t1 OBJECT) (t2 OBJECT)) : TIME-DURATION</I>
<DD>Multiplies a relative date by a wrapped number.  One of <VAR>t1</VAR> or <VAR>t2</VAR>
must be a relative date and the other a wrapped number.
</DL>
</P><P>

<A NAME="IDX502"></A>
<DL>
<DT><U>Function:</U> <B>time-subtract</B> <I>((t1 DATE-TIME-OBJECT) (t2 DATE-TIME-OBJECT)) : DATE-TIME-OBJECT</I>
<DD>Subtract <VAR>t2</VAR> from <VAR>t1</VAR>.  If <VAR>t1</VAR> is a calendar date, then <VAR>t2</VAR> can
be either a calendar date (in which case the return value is a relative date) or it
can be a relative date (in which case the return value is a calendar date).  If <VAR>t1</VAR>
is a relative date, then <VAR>t2</VAR> must also be a relative date and a relative date is returned.
</DL>
</P><P>

<A NAME="IDX503"></A>
<DL>
<DT><U>Function:</U> <B>get-ticktock</B> <I>() : TICKTOCK</I>
<DD>Return the current CPU time.  If the current OS/Language
combination does not support measuring of CPU time, return real time instead.
Use <CODE>ticktock-difference</CODE> to measure the time difference between values
returned by this function.  This is an attempt to provide some platform
independent support to measure (at least approximately) consumed CPU time.
</DL>
</P><P>

<A NAME="IDX504"></A>
<DL>
<DT><U>Function:</U> <B>ticktock-difference</B> <I>((t1 TICKTOCK) (t2 TICKTOCK)) : FLOAT</I>
<DD>The difference in two TICKTOCK time values in seconds where
<VAR>t1</VAR> is the earlier time.  The resolution is implementation dependent but will
normally be some fractional value of a second.
</DL>
</P><P>

<A NAME="IDX505"></A>
<DL>
<DT><U>Function:</U> <B>ticktock-resolution</B> <I>() : FLOAT</I>
<DD>The minimum theoretically detectable resolution of the
difference in two TICKTOCK time values in seconds.  This
resolution is implementation dependent.  It may also not
be realizable in practice, since the timing grain size may
be larger than this resolution.
</DL>
</P><P>

<A NAME="IDX506"></A>
<DL>
<DT><U>Function:</U> <B>sleep</B> <I>((seconds FLOAT)) :</I>
<DD>The program will sleep for the indicated number of seconds.
Fractional values are allowed, but the results are implementation dependent:
Common Lisp uses the fractions natively, Java with a resolution of 0.001,
and C++ can only use integral values.
</DL>
</P><P>

<A NAME="XML Support"></A>
<HR SIZE="6">
<A NAME="SEC50"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC49"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC51"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.18 XML Support </H2>
<!--docid::SEC50::-->
<P>

<A NAME="IDX507"></A>
<DL>
<DT><U>Function:</U> <B>make-xml-element</B> <I>((name STRING) (namespace-name STRING) (namespace STRING)) : XML-ELEMENT</I>
<DD>Creates and interns an XML element object <VAR>name</VAR> using <VAR>namespace-name</VAR>
to refer to  <VAR>namespace</VAR>.  If <VAR>namespace</VAR> is <CODE>null</CODE>, then the element will
be interned in the null namespace.   <VAR>namespace</VAR> must otherwise be a URI.
</DL>
</P><P>

<A NAME="IDX508"></A>
<DL>
<DT><U>Function:</U> <B>make-xml-global-attribute</B> <I>((name STRING) (namespace-name STRING) (namespace STRING)) : XML-GLOBAL-ATTRIBUTE</I>
<DD>Creates and interns an XML global attribute object with <VAR>name</VAR> using 
<VAR>namespace-name</VAR> to refer to  <VAR>namespace</VAR>.  <VAR>namespace</VAR>must be a URI.
</DL>
</P><P>

<A NAME="IDX509"></A>
<DL>
<DT><U>Function:</U> <B>make-xml-local-attribute</B> <I>((name STRING) (element XML-ELEMENT)) : XML-LOCAL-ATTRIBUTE</I>
<DD>Make an XML-LOCAL-ATTRIBUTE named <VAR>name</VAR> associated with <VAR>element</VAR>
</DL>
</P><P>

<A NAME="IDX510"></A>
<DL>
<DT><U>Function:</U> <B>get-xml-tag</B> <I>((expression CONS)) : XML-ELEMENT</I>
<DD>Return the XML tag object of an XML <VAR>expression</VAR>.
</DL>
</P><P>

<A NAME="IDX511"></A>
<DL>
<DT><U>Function:</U> <B>get-xml-attributes</B> <I>((expression CONS)) : CONS</I>
<DD>Return the list of attributes of an XML <VAR>expression</VAR> (may be empty).
</DL>
</P><P>

<A NAME="IDX512"></A>
<DL>
<DT><U>Function:</U> <B>get-xml-content</B> <I>((expression CONS)) : CONS</I>
<DD>Return the list of content elements of an XML <VAR>expression</VAR> (may be empty).
</DL>
</P><P>

<A NAME="IDX513"></A>
<DL>
<DT><U>Function:</U> <B>get-xml-cdata-content</B> <I>((form CONS)) : STRING</I>
<DD>Return the CDATA content of a CDATA <VAR>form</VAR>.  Does NOT make sure that <VAR>form</VAR>
actually is a CDATA form, so bad things can happen if it is given wrong input.
</DL>
</P><P>

<A NAME="IDX514"></A>
<DL>
<DT><U>Function:</U> <B>xml-declaration?</B> <I>((item OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>item</VAR> is an XML declaration object
</DL>
</P><P>

<A NAME="IDX515"></A>
<DL>
<DT><U>Function:</U> <B>xml-element?</B> <I>((item OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>item</VAR> is an XML element object
</DL>
</P><P>

<A NAME="IDX516"></A>
<DL>
<DT><U>Function:</U> <B>xml-attribute?</B> <I>((item OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>item</VAR> is an XML attribute object
</DL>
</P><P>

<A NAME="IDX517"></A>
<DL>
<DT><U>Function:</U> <B>xml-cdata?</B> <I>((item OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>item</VAR> is an XML CDATA tag object
</DL>
</P><P>

<A NAME="IDX518"></A>
<DL>
<DT><U>Function:</U> <B>xml-cdata-form?</B> <I>((form OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>form</VAR> is an CONS headed by a CDATA tag
</DL>
</P><P>

<A NAME="IDX519"></A>
<DL>
<DT><U>Method:</U> <B>xml-element-match?</B> <I>((tag XML-ELEMENT) (name STRING) (namespace STRING)) : BOOLEAN</I>
<DD>Returns <CODE>true</CODE> if <VAR>tag</VAR> is an XML element with the name <VAR>name</VAR>
in namespace <VAR>namespace</VAR>.  Note that <VAR>namespace</VAR> is the full URI, not an abbreviation.
Also, <VAR>namespace</VAR> may be <CODE>null</CODE>, in which case <VAR>tag</VAR> must not have a namespace
associated with it.
</DL>
</P><P>

<A NAME="IDX520"></A>
<DL>
<DT><U>Method:</U> <B>xml-attribute-match?</B> <I>((attribute XML-ATTRIBUTE) (name STRING) (namespace STRING)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>attribute</VAR> is an XML attribute with name <VAR>name</VAR>
in namespace <VAR>namespace</VAR>.  Note that <VAR>namespace</VAR> is the full URI, not an
abbreviation.  Also, <VAR>namespace</VAR> may be <CODE>null</CODE>, in which case <VAR>attribute</VAR>
must not have a namespace associated with it.
</DL>
</P><P>

<A NAME="IDX521"></A>
<DL>
<DT><U>Method:</U> <B>xml-attribute-match?</B> <I>((attribute XML-GLOBAL-ATTRIBUTE) (name STRING) (namespace STRING)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>attribute</VAR> is a global  XML attribute with name <VAR>name</VAR>
in namespace <VAR>namespace</VAR>.  Note that <VAR>namespace</VAR> is the full URI, not an
abbreviation.  Also, <VAR>namespace</VAR> may be <CODE>null</CODE>, in which case <VAR>attribute</VAR>
must not have a namespace associated with it.
</DL>
</P><P>

<A NAME="IDX522"></A>
<DL>
<DT><U>Method:</U> <B>xml-attribute-match?</B> <I>((attribute XML-LOCAL-ATTRIBUTE) (name STRING) (namespace STRING)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>attribute</VAR> is a local XML attribute with name <VAR>name</VAR>.
Note that <VAR>namespace</VAR> must be <CODE>null</CODE> and that the <VAR>attribute</VAR>s parent element
element is not considered by the match.  To take the parent element into
account use <CODE>xml-local-attribute-match?</CODE>.
</DL>
</P><P>

<A NAME="IDX523"></A>
<DL>
<DT><U>Function:</U> <B>xml-local-attribute-match?</B> <I>((attribute XML-LOCAL-ATTRIBUTE) (name STRING) (element-name STRING) (element-namespace STRING)) : BOOLEAN</I>
<DD>Return true if <VAR>attribute</VAR> is a local attribute with <VAR>name</VAR> and whose
parent element matches <VAR>element-name</VAR> and <VAR>element-namespace</VAR>.
</DL>
</P><P>

<A NAME="IDX524"></A>
<DL>
<DT><U>Function:</U> <B>xml-lookup-attribute</B> <I>((attributes CONS) (name STRING) (namespace STRING)) : STRING</I>
<DD>Find the XML attribute in <VAR>attributes</VAR> with <VAR>name</VAR> and <VAR>namespace</VAR> and
return its value.  Note that it is assumed that all <VAR>attributes</VAR> come from
the same known tag, hence, the parent elements of any local attributes are
not considered by the lookup.
</DL>
</P><P>

<A NAME="IDX525"></A>
<DL>
<DT><U>Macro:</U> <B>xml-tag-case</B> <I>((item OBJECT) &#38;body (clauses CONS)) : OBJECT</I>
<DD>A case form for matching <VAR>item</VAR> against XML element tags.  Each
element of <VAR>clauses</VAR> should be a clause with the form
  ("tagname" ...)     or
  (("tagname" "namespace-uri") ...)
The clause heads can optionally be symbols instead of strings.  The key forms the
parameters to the method <CODE>xml-element-match?</CODE>, with a missing namespace argument
passed as NULL.
</P><P>

The namespace argument will be evaluated, so one can use bound variables in
place of a fixed string.   As a special case, if the namespace argument is
:ANY, then the test will be done for a match on the tag name alone.
</DL>
</P><P>

<A NAME="IDX526"></A>
<DL>
<DT><U>Function:</U> <B>read-xml-expression</B> <I>((stream INPUT-STREAM) (start-tag OBJECT)) : OBJECT BOOLEAN</I>
<DD>Read one balanced XML expression from <VAR>stream</VAR> and return
its s-expression representation (see <CODE>xml-token-list-to-s-expression</CODE>).  If
<CODE>startTagName</CODE> is non-`null', skip all tags until a start tag matching <VAR>start-tag</VAR>
is encountered.  XML namespaces are ignored for outside of the start tag.
Use s-expression representation to specify <VAR>start-tag</VAR>, e.g., <CODE>(KIF (:version "1.0"))</CODE>.
The tag can be an XML element object, a symbol, a string or a cons.  If the tag is a cons
the first element can also be (name namespace) pair.
</P><P>

Return <CODE>true</CODE> as the second value on EOF.
</P><P>

CHANGE WARNING:  It is anticipated that this function will change to
 a) Properly take XML namespaces into account and
 b) require XML element objects instead of strings as the second argument.
This change will not be backwards-compatible.
</DL>
</P><P>

<A NAME="IDX527"></A>
<DL>
<DT><U>Function:</U> <B>xml-expressions</B> <I>((stream INPUT-STREAM) (regionTag OBJECT)) : XML-EXPRESSION-ITERATOR</I>
<DD>Return an XML-expression-iterator (which see) reading from
<VAR>stream</VAR>.  <VAR>regionTag</VAR> can be used to define delimited regions from which
expressions should be considered. Use s-expression representation to specify
<VAR>regionTag</VAR>, e.g., <CODE>(KIF (:version "1.0"))</CODE>.  The tag can be an XML element
object, a symbol, a string or a cons.  If the tag is a cons the first element
can also be (name namespace) pair.
</DL>
</P><P>

<A NAME="IDX528"></A>
<DL>
<DT><U>Function:</U> <B>print-xml-expression</B> <I>((stream OUTPUT-STREAM) (xml-expression CONS) (indent INTEGER)) :</I>
<DD>Prints <VAR>xml-expression</VAR> on <VAR>stream</VAR>.  Indentation begins with the
value of <VAR>indent</VAR>.  If this is the <CODE>null</CODE> integer, no indentation is
performed.  Otherwise it should normally be specified as 0 (zero) for
top-level calls.
</P><P>

It is assumed that the <VAR>xml-expression</VAR> is a well-formed CONS-list
representation of an XML  form.  It expects a form like that form
returned by <CODE>read-XML-expression</CODE>.
</P><P>

Also handles a list of xml forms such as that returned by <CODE>XML-expressions</CODE>.
In that case, each of the forms is indented by <VAR>indent</VAR> spaces.
</DL>
</P><P>

<A NAME="IDX529"></A>
<DL>
<DT><U>Function:</U> <B>reset-xml-hash-tables</B> <I>() :</I>
<DD>Resets Hashtables used for interning XML elements and global
attribute objects.  This will allow garbage collection of no-longer used
objects, but will also mean that newly parsed xml elements and global attributes
will not be eq? to already existing ones with the same name.
</DL>
</P><P>

<A NAME="Miscellaneous"></A>
<HR SIZE="6">
<A NAME="SEC51"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC50"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.19 Miscellaneous </H2>
<!--docid::SEC51::-->
<P>

This is a catch-all section for functions and methods that haven't been
categorized yet into any of the previous sections.  They are in random
order and many of them will never be part of the official STELLA
interface.  So beware!
</P><P>

<A NAME="IDX530"></A>
<DL>
<DT><U>Function:</U> <B>operating-system</B> <I>() : KEYWORD</I>
<DD>Not documented.
</DL>
</P><P>

<A NAME="IDX531"></A>
<DL>
<DT><U>Function:</U> <B>activate-demon</B> <I>((demon DEMON)) :</I>
<DD>Install <VAR>demon</VAR> in the location(s) specified by its internal
structure.
</DL>
</P><P>

<A NAME="IDX532"></A>
<DL>
<DT><U>Method:</U> <B>active?</B> <I>((self POLYMORPHIC-RELATION)) : BOOLEAN</I>
<DD>True if <VAR>self</VAR> or a superslot of <VAR>self</VAR> is marked active.
</DL>
</P><P>

<A NAME="IDX533"></A>
<DL>
<DT><U>Function:</U> <B>add-hook</B> <I>((hookList HOOK-LIST) (hookFunction SYMBOL)) :</I>
<DD>Insert the function named <VAR>hookFunction</VAR> into <VAR>hookList</VAR>.
</DL>
</P><P>

<A NAME="IDX534"></A>
<DL>
<DT><U>Command:</U> <B>add-trace</B> <I>(&#38;rest (keywords GENERALIZED-SYMBOL)) : LIST</I>
<DD>Enable trace messages identified by any of the listed <VAR>keywords</VAR>.  After
calling (<CODE>add-trace</CODE> &#60;keyword&#62;) code guarded by (<CODE>trace-if</CODE> &#60;keyword&#62; ...)
will be executed when it is encountered.
</DL>
</P><P>

<A NAME="IDX535"></A>
<DL>
<DT><U>Function:</U> <B>all-classes</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF CLASS)</I>
<DD>Iterate over all classes visible from <VAR>module</VAR>.
If <VAR>local?</VAR>, return only classes interned in <VAR>module</VAR>.
If <VAR>module</VAR> is null, return all classes interned everywhere.
</DL>
</P><P>

<A NAME="IDX536"></A>
<DL>
<DT><U>Function:</U> <B>all-contexts</B> <I>() : (ITERATOR OF CONTEXT)</I>
<DD>Return an iterator that generates all contexts.
</DL>
</P><P>

<A NAME="IDX537"></A>
<DL>
<DT><U>Macro:</U> <B>all-defined?</B> <I>(&#38;body (forms CONS)) : OBJECT</I>
<DD>Evaluate each of the forms in <VAR>forms</VAR>, and
return TRUE if none of them are NULL.
</DL>
</P><P>

<A NAME="IDX538"></A>
<DL>
<DT><U>Function:</U> <B>all-functions</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF FUNCTION)</I>
<DD>Iterate over all functions visible from <VAR>module</VAR>.
If <VAR>local?</VAR>, return only functions bound to symbols interned in <VAR>module</VAR>.
If <VAR>module</VAR> is null, return all functions defined everywhere.
</DL>
</P><P>

<A NAME="IDX539"></A>
<DL>
<DT><U>Function:</U> <B>all-included-modules</B> <I>((self MODULE)) : (ITERATOR OF MODULE)</I>
<DD>Generate a sequence of all modules included
by <VAR>self</VAR>, inclusive, starting from the highest ancestor and working
down to <VAR>self</VAR> (which is last).
</DL>
</P><P>

<A NAME="IDX540"></A>
<DL>
<DT><U>Function:</U> <B>all-methods</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF METHOD-SLOT)</I>
<DD>Iterate over all methods visible from <VAR>module</VAR>.
If <VAR>local?</VAR>, return only methods interned in <VAR>module</VAR>.
If <VAR>module</VAR> is null, return all methods interned everywhere.
</DL>
</P><P>

<A NAME="IDX541"></A>
<DL>
<DT><U>Function:</U> <B>all-modules</B> <I>() : (ITERATOR OF MODULE)</I>
<DD>Return an iterator that generates all modules.
</DL>
</P><P>

<A NAME="IDX542"></A>
<DL>
<DT><U>Function:</U> <B>all-public-functions</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF FUNCTION)</I>
<DD>Iterate over all functions visible from <VAR>module</VAR>.
If <VAR>local?</VAR>, return only functions bound to symbols interned in <VAR>module</VAR>.
If <VAR>module</VAR> is null, return all functions defined everywhere.
</DL>
</P><P>

<A NAME="IDX543"></A>
<DL>
<DT><U>Function:</U> <B>all-public-methods</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF METHOD-SLOT)</I>
<DD>Iterate over all public methods visible from <VAR>module</VAR>.
If <VAR>local?</VAR>, return only methods interned in <VAR>module</VAR>.
If <VAR>module</VAR> is null, return all methods interned everywhere.
</DL>
</P><P>

<A NAME="IDX544"></A>
<DL>
<DT><U>Function:</U> <B>all-slots</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF SLOT)</I>
<DD>Iterate over all slots visible from <VAR>module</VAR>.
If <VAR>local?</VAR>, return only methods interned in <VAR>module</VAR>.
If <VAR>module</VAR> is null, return all methods interned everywhere.
</DL>
</P><P>

<A NAME="IDX545"></A>
<DL>
<DT><U>Function:</U> <B>all-subcontexts</B> <I>((context CONTEXT) (traversal KEYWORD)) : (ALL-PURPOSE-ITERATOR OF CONTEXT)</I>
<DD>Return an iterator that generates all subcontexts of
<CODE>self</CODE> (not including <CODE>self</CODE>) in the order specified by <VAR>traversal</VAR> (one
of :preorder, :inorder, or :postorder).
</DL>
</P><P>

<A NAME="IDX546"></A>
<DL>
<DT><U>Function:</U> <B>all-surrogates</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF SURROGATE)</I>
<DD>Iterate over all surrogates visible from <VAR>module</VAR>.
If <VAR>local?</VAR>, return only surrogates interned in <VAR>module</VAR>.
If <VAR>module</VAR> is null, return all surrogates interned everywhere.
</DL>
</P><P>

<A NAME="IDX547"></A>
<DL>
<DT><U>Function:</U> <B>all-symbols</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF SYMBOL)</I>
<DD>Iterate over all symbols visible from <VAR>module</VAR>.
If <VAR>local?</VAR>, return only symbols interned in <VAR>module</VAR>.
If <VAR>module</VAR> is null, return all symbols interned everywhere.
</DL>
</P><P>

<A NAME="IDX548"></A>
<DL>
<DT><U>Function:</U> <B>all-variables</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF GLOBAL-VARIABLE)</I>
<DD>Iterate over all variables visible from <VAR>module</VAR>.
If <VAR>local?</VAR>, return only variables bound to symbols interned in <VAR>module</VAR>.
If <VAR>module</VAR> is null, return all variables defined everywhere.
</DL>
</P><P>

<A NAME="IDX549"></A>
<DL>
<DT><U>Method:</U> <B>allocate-iterator</B> <I>((self ABSTRACT-ITERATOR)) : (LIKE SELF)</I>
<DD>Iterator objects return themselves when asked
for an iterator (they occupy the same position as a collection
within a <CODE>foreach</CODE> statement).
</DL>
</P><P>

<A NAME="IDX550"></A>
<DL>
<DT><U>Method:</U> <B>allocate-iterator</B> <I>((self MEMOIZABLE-ITERATOR)) : (ITERATOR OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Alias for <CODE>clone-memoized-iterator</CODE>.
</DL>
</P><P>

<A NAME="IDX551"></A>
<DL>
<DT><U>Method:</U> <B>allocation</B> <I>((self STORAGE-SLOT)) : KEYWORD</I>
<DD>Return the most specific :allocation facet, or
:instance if all inherited values are NULL.
</DL>
</P><P>

<A NAME="IDX552"></A>
<DL>
<DT><U>Function:</U> <B>apply</B> <I>((code FUNCTION-CODE) (arguments (CONS OF OBJECT))) : OBJECT</I>
<DD>Apply <VAR>code</VAR> to <VAR>arguments</VAR>, returning a value of type
OBJECT.
</DL>
</P><P>

<A NAME="IDX553"></A>
<DL>
<DT><U>Function:</U> <B>apply-boolean-method</B> <I>((code METHOD-CODE) (arguments (CONS OF OBJECT))) : BOOLEAN</I>
<DD>Apply <VAR>code</VAR> to <VAR>arguments</VAR>, returning a value of type
BOOLEAN.
</DL>
</P><P>

<A NAME="IDX554"></A>
<DL>
<DT><U>Function:</U> <B>apply-float-method</B> <I>((code METHOD-CODE) (arguments (CONS OF OBJECT))) : FLOAT</I>
<DD>Apply <VAR>code</VAR> to <VAR>arguments</VAR>, returning a value of type
FLOAT.
</DL>
</P><P>

<A NAME="IDX555"></A>
<DL>
<DT><U>Function:</U> <B>apply-integer-method</B> <I>((code METHOD-CODE) (arguments (CONS OF OBJECT))) : INTEGER</I>
<DD>Apply <VAR>code</VAR> to <VAR>arguments</VAR>, returning a value of type
INTEGER.
</DL>
</P><P>

<A NAME="IDX556"></A>
<DL>
<DT><U>Function:</U> <B>apply-method</B> <I>((code METHOD-CODE) (arguments (CONS OF OBJECT))) : OBJECT</I>
<DD>Apply <VAR>code</VAR> to <VAR>arguments</VAR>, returning a value of type
OBJECT.
</DL>
</P><P>

<A NAME="IDX557"></A>
<DL>
<DT><U>Function:</U> <B>apply-string-method</B> <I>((code METHOD-CODE) (arguments (CONS OF OBJECT))) : STRING</I>
<DD>Apply <VAR>code</VAR> to <VAR>arguments</VAR>, returning a value of type
STRING.
</DL>
</P><P>

<A NAME="IDX558"></A>
<DL>
<DT><U>Function:</U> <B>break-program</B> <I>((message STRING)) :</I>
<DD>Interrupt the program and print <VAR>message</VAR>.  Continue after
confirmation with the user.
</DL>
</P><P>

<A NAME="IDX559"></A>
<DL>
<DT><U>Command:</U> <B>call-clear-module</B> <I>(&#38;rest (name NAME)) :</I>
<DD>Destroy all objects belonging to module <VAR>name</VAR> or any of its children.
If no <VAR>name</VAR> is supplied, the current module will be cleared after
confirming with the user.  Important modules such as STELLA are protected
against accidental clearing.
</DL>
</P><P>

<A NAME="IDX560"></A>
<DL>
<DT><U>Function:</U> <B>cast</B> <I>((value OBJECT) (type TYPE)) : OBJECT</I>
<DD>Perform a run-time type check, and then return <VAR>value</VAR>.
</DL>
</P><P>

<A NAME="IDX561"></A>
<DL>
<DT><U>Command:</U> <B>ccc</B> <I>(&#38;rest (name NAME)) : CONTEXT</I>
<DD>Change the current context to the one named <VAR>name</VAR>.  Return the
value of the new current context.  If no <VAR>name</VAR> is supplied, return
the pre-existing value of the current context.  <CODE>cc</CODE> is a no-op if the
context reference cannot be successfully evaluated.
In CommonLisp, if the new context is case sensitive, then change
the readtable case to :INVERT, otherwise to :UPCASE.
</DL>
</P><P>

<A NAME="IDX562"></A>
<DL>
<DT><U>Function:</U> <B>cl-slot-value</B> <I>((object OBJECT) (slotName STRING) (dontConvert? BOOLEAN)) : LISP-CODE</I>
<DD>Lookup slot <VAR>slotName</VAR> on <VAR>object</VAR> and return the lispified
slot value (see <CODE>lispify</CODE>).  If <VAR>dontConvert?</VAR> is TRUE, the returned slot value
will not be lispified.  Generate a warning if no such slot exists on <VAR>object</VAR>.
In a call directly from Lisp <VAR>slotName</VAR> can also be supplied as a Lisp symbol.
</DL>
</P><P>

<A NAME="IDX563"></A>
<DL>
<DT><U>Function:</U> <B>cl-slot-value-setter</B> <I>((object OBJECT) (slotName STRING) (value LISP-CODE) (dontConvert? BOOLEAN)) : LISP-CODE</I>
<DD>Lookup slot <VAR>slotName</VAR> on <VAR>object</VAR> and set its value to
the stellafied <VAR>value</VAR> (see <CODE>stellafy</CODE>).  If <VAR>dontConvert?</VAR> is TRUE, <VAR>value</VAR>
will not be stellafied before it gets assigned.  Generate a warning if no
such slot exists on <VAR>object</VAR>, or if <VAR>value</VAR> has the wrong type.  In a call
directly from Lisp <VAR>slotName</VAR> can also be supplied as a Lisp symbol.
</DL>
</P><P>

<A NAME="IDX564"></A>
<DL>
<DT><U>Function:</U> <B>cl-translate-file</B> <I>((file FILE-NAME) (relative? BOOLEAN)) :</I>
<DD>Translate a Stella <VAR>file</VAR> to Common-Lisp.  If
<VAR>relative?</VAR>, concatenate root directory to <VAR>file</VAR>.
</DL>
</P><P>

<A NAME="IDX565"></A>
<DL>
<DT><U>Function:</U> <B>cl-translate-system</B> <I>((system-name STRING)) :</I>
<DD>Translate a Stella system named <VAR>system-name</VAR> to Common Lisp.
</DL>
</P><P>

<A NAME="IDX566"></A>
<DL>
<DT><U>Function:</U> <B>cleanup-unfinalized-classes</B> <I>() :</I>
<DD>Remove all finalized classes from <CODE>*UNFINALIZED-CLASSES*</CODE>,
and set <CODE>*NEWLY-UNFINALIZED-CLASSES?*</CODE> to <CODE>false</CODE>.
</DL>
</P><P>

<A NAME="IDX567"></A>
<DL>
<DT><U>Function:</U> <B>clear-recycle-list</B> <I>((list RECYCLE-LIST)) :</I>
<DD>Reset <VAR>list</VAR> to its empty state.
</DL>
</P><P>

<A NAME="IDX568"></A>
<DL>
<DT><U>Function:</U> <B>clear-recycle-lists</B> <I>() :</I>
<DD>Reset all currently active recycle lists to their empty state.
</DL>
</P><P>

<A NAME="IDX569"></A>
<DL>
<DT><U>Function:</U> <B>clear-system</B> <I>((name STRING)) :</I>
<DD>Clears out the system definition named <VAR>name</VAR>.  If
<VAR>name</VAR> is <CODE>null</CODE>, then clear out all system definitions.  This function
is useful when changes have been made to the system definition, and one
wants to have it reloaded from the standard location in the file system.
</DL>
</P><P>

<A NAME="IDX570"></A>
<DL>
<DT><U>Command:</U> <B>clear-trace</B> <I>() :</I>
<DD>Disable all tracing previously enabled with <CODE>add-trace</CODE>.
</DL>
</P><P>

<A NAME="IDX571"></A>
<DL>
<DT><U>Function:</U> <B>clone-memoized-iterator</B> <I>((self MEMOIZABLE-ITERATOR)) : (ITERATOR OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Clone the memoized iterator <VAR>self</VAR> so it can be used to
iterate over the collection represented by <VAR>self</VAR>, while allowing to iterate
over it multiple times via multiple clones.
</DL>
</P><P>

<A NAME="IDX572"></A>
<DL>
<DT><U>Function:</U> <B>close-all-files</B> <I>() :</I>
<DD>Close all currently open file streams.  Use for emergencies or for cleanup.
</DL>
</P><P>

<A NAME="IDX573"></A>
<DL>
<DT><U>Function:</U> <B>close-stream</B> <I>((self STREAM)) :</I>
<DD>Close the stream <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX574"></A>
<DL>
<DT><U>Macro:</U> <B>coerce-&#38;rest-to-cons</B> <I>((restVariable SYMBOL)) : OBJECT</I>
<DD>Coerce the argument list variable <VAR>restVariable</VAR> into a CONS
list containing all its elements (uses argument list iteration to do so).  If
<VAR>restVariable</VAR> already is a CONS due to argument listification, this is a no-op.
</DL>
</P><P>

<A NAME="IDX575"></A>
<DL>
<DT><U>Function:</U> <B>coerce-to-symbol</B> <I>((name NAME)) : GENERALIZED-SYMBOL</I>
<DD>Return the (generalized) symbol represented by <VAR>name</VAR>.
Return <CODE>null</CODE> if <VAR>name</VAR> is undefined or does not represent a string.
</DL>
</P><P>

<A NAME="IDX576"></A>
<DL>
<DT><U>Macro:</U> <B>collect</B> <I>((collectvariable SYMBOL) &#38;body (body CONS)) : OBJECT</I>
<DD>Use a VRLET to collect values.  Input has the form
<CODE>(collect &#60;x&#62; in &#60;expression&#62; where (&#60;test&#62; &#60;x&#62;))</CODE>.
</DL>
</P><P>

<A NAME="IDX577"></A>
<DL>
<DT><U>Method:</U> <B>collection-valued?</B> <I>((self SLOT)) : BOOLEAN</I>
<DD>True if slot values are collections.
</DL>
</P><P>

<A NAME="IDX578"></A>
<DL>
<DT><U>Function:</U> <B>command?</B> <I>((method METHOD-SLOT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>method</VAR> is an evaluable command.
</DL>
</P><P>

<A NAME="IDX579"></A>
<DL>
<DT><U>Method:</U> <B>component?</B> <I>((self STORAGE-SLOT)) : BOOLEAN</I>
<DD>True if fillers of this slot are components of the
owner slot, and therefore should be deleted if the owner is deleted.
</DL>
</P><P>

<A NAME="IDX580"></A>
<DL>
<DT><U>Function:</U> <B>compose-namestring</B> <I>((name-components (CONS OF STRING-WRAPPER)) &#38;rest (options OBJECT)) : STRING</I>
<DD><VAR>name-components</VAR> is a cons to be processed into a namestring.
<CODE>:prefix</CODE> and <CODE>:suffix</CODE> are strings that will NOT be case-converted.
<CODE>:case</CODE> is one of :UPCASE :TitleCase :titleCaseX :downcase :Capitalize
        default is :TitleCase
<CODE>:separator</CODE> is a string that should separate word elements.  It does not
       separate the prefix or suffix.  Default is ""
<CODE>:translation-table</CODE> should be a STRING-HASH-TABLE hash table that strings into their
       desired printed representation as a string.  In general the argument
       will be strings, but that is not strictly necessary.
</P><P>

</DL>
</P><P>

<A NAME="IDX581"></A>
<DL>
<DT><U>Function:</U> <B>compose-namestring-full</B> <I>((strings (CONS OF STRING-WRAPPER)) (prefix STRING) (suffix STRING) (outputcase KEYWORD) (outputseparator STRING) (translationtable STRING-HASH-TABLE) (useacronymheuristics? BOOLEAN)) : STRING</I>
<DD>Non-keyword version of <CODE>compose-namestring</CODE>, which will probably be
easier to use when called from non-Lisp languages.
</DL>
</P><P>

<A NAME="IDX582"></A>
<DL>
<DT><U>Function:</U> <B>configure-stella</B> <I>((file FILE-NAME)) :</I>
<DD>Perform STELLA run-time configuration.  If supplied, load the
configuration file <VAR>file</VAR> first which should be supplied with a physical pathname.
</DL>
</P><P>

<A NAME="IDX583"></A>
<DL>
<DT><U>Method:</U> <B>consify</B> <I>((self OBJECT)) : CONS</I>
<DD>If <CODE>object</CODE> is a CONS, return it.  Otherwise, return
a singleton cons list containing it.
</DL>
</P><P>

<A NAME="IDX584"></A>
<DL>
<DT><U>Macro:</U> <B>continuable-error</B> <I>(&#38;body (body CONS)) : OBJECT</I>
<DD>Signal error message, placing non-string arguments in quotes.
</DL>
</P><P>

<A NAME="IDX585"></A>
<DL>
<DT><U>Function:</U> <B>cpp-translate-system</B> <I>((systemName STRING)) :</I>
<DD>Translate the system <VAR>systemName</VAR> to C++.
</DL>
</P><P>

<A NAME="IDX586"></A>
<DL>
<DT><U>Command:</U> <B>cpptrans</B> <I>((statement OBJECT)) :</I>
<DD>Translate <VAR>statement</VAR> to C++ and print the result.
</DL>
</P><P>

<A NAME="IDX587"></A>
<DL>
<DT><U>Function:</U> <B>create-derived-list</B> <I>((self LIST)) : LIST</I>
<DD>Create a new list object with the same type as <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX588"></A>
<DL>
<DT><U>Function:</U> <B>create-object</B> <I>((type TYPE) &#38;rest (initial-value-pairs OBJECT)) : OBJECT</I>
<DD>Funcallable version of the <CODE>new</CODE> operator.
Return an instance of the class named by <VAR>type</VAR>.  If <VAR>initial-value-pairs</VAR>
is supplied, it has to be a key/value list similar to what's accepted by <CODE>new</CODE>
and the named slots will be initialized with the supplied values.  Similar to
<CODE>new</CODE>, all required arguments for <VAR>type</VAR> must be included.  Since all the
slot initialization, etc. is handled dynamically at run time, <CODE>create-object</CODE>
is much slower than <CODE>new</CODE>; therefore, it should only be used if <VAR>type</VAR> cannot
be known at translation time.
</DL>
</P><P>

<A NAME="IDX589"></A>
<DL>
<DT><U>Function:</U> <B>deactivate-demon</B> <I>((demon DEMON)) :</I>
<DD>Detach <VAR>demon</VAR> from the location(s) specified by its internal
structure.
</DL>
</P><P>

<A NAME="IDX590"></A>
<DL>
<DT><U>Function:</U> <B>decompose-namestring</B> <I>((namestring STRING) &#38;rest (options OBJECT)) : (CONS OF STRING-WRAPPER)</I>
<DD>Keyword options:
  :break-on-cap    one of  :YES :NO :CLEVER         default is :CLEVER
  :break-on-number one of  :YES :NO :CLEVER         default is :CLEVER
  :break-on-separators string                       default is "-_ "
</P><P>

  DECOMPOSE-NAMESTRING returns a cons of STRING-WRAPPERS that are the decomposition of the
input STRING.  The arguments are used as follows:
  <VAR>namestring</VAR>       is the input string.
  :break-on-cap    is a keyword controlling whether changes in capitalization is used
                   to indicate word boundaries.  If :YES, then all capitalization
                   changes delineate words.  If :CLEVER, then unbroken runs of
                   capitalized letters are treated as acronyms and remain grouped.
                   If :NO or NULL, there is no breaking of words based on capitalization.
  :break-on-number is a flag controlling whether encountering a number indicates
                   a word boundary.  If :YES, then each run of numbers is treated as
		   a word separate from surrounding words.  If :CLEVER, then an 
		   attempt is made to recognize ordinal numbers (ie, 101st) and
		   treat them as separate words.  If :NO or NULL, there is no breaking
                   of words when numbers are encountered.
  :break-on-separators   A string of characters which constitute word delimiters in
                         the input word.  This is used to determine how to break
                   the name into individual words.  Defaults are space, <CODE>-</CODE> and <CODE>_</CODE>.
</DL>
</P><P>

<A NAME="IDX591"></A>
<DL>
<DT><U>Function:</U> <B>decompose-namestring-full</B> <I>((namestring STRING) (break-on-cap KEYWORD) (break-on-number KEYWORD) (break-on-separators STRING)) : (CONS OF STRING-WRAPPER)</I>
<DD>Non-keyword version of <CODE>decompose-namestring</CODE>, which will probably be
easier to use when called from non-Lisp languages.
</DL>
</P><P>

<A NAME="IDX592"></A>
<DL>
<DT><U>Method:</U> <B>default-form</B> <I>((self STORAGE-SLOT)) : OBJECT</I>
<DD>Returns the current value of default expression when the
slot has not been assigned a value.
</DL>
</P><P>

<A NAME="IDX593"></A>
<DL>
<DT><U>Macro:</U> <B>defdemon</B> <I>((name STRING-WRAPPER) (parameterstree CONS) &#38;body (optionsandbody CONS)) : OBJECT</I>
<DD>Define a demon <VAR>name</VAR> and attach it to a class or slot.
</DL>
</P><P>

<A NAME="IDX594"></A>
<DL>
<DT><U>Function:</U> <B>define-demon</B> <I>((name STRING) &#38;rest (options OBJECT)) : DEMON</I>
<DD>Define a class or slot demon.  Options are :create,
:destroy, :class, :slot, :guard?, :code, :method, :inherit?, and :documentation.
</DL>
</P><P>

<A NAME="IDX595"></A>
<DL>
<DT><U>Function:</U> <B>define-logical-host-property</B> <I>((host STRING) (property KEYWORD) (value OBJECT)) :</I>
<DD>Define <VAR>property</VAR> with <VAR>value</VAR> for the logical host <VAR>host</VAR>.
As a side-effect, this also defines <VAR>host</VAR> as a logical host (both
<VAR>property</VAR> and <VAR>value</VAR> can be supplied as NULL).  If :ROOT-DIRECTORY
is specified, all pathnames with <VAR>host</VAR> are assumed to be relative to
that directory (even if they are absolute) and will be rerooted upon
translation.  :ROOT-DIRECTORY can be a logical or physical pathname.
If :LISP-TRANSLATIONS is specified, those will be used verbatimely as
the value of <CODE>(CL:logical-pathname-translations host)</CODE> if we are
running in Lisp, which allows us to depend on the native
<CODE>CL:translate-logical-pathname</CODE> for more complex translation operations.
</DL>
</P><P>

<A NAME="IDX596"></A>
<DL>
<DT><U>Function:</U> <B>define-module</B> <I>((name STRING) (options CONS)) : MODULE</I>
<DD>Define or redefine a module named <VAR>name</VAR> having the
options <VAR>options</VAR>.  Return the new module.
</DL>
</P><P>

<A NAME="IDX597"></A>
<DL>
<DT><U>Function:</U> <B>define-stella-class</B> <I>((name TYPE) (supers (LIST OF TYPE)) (slots (LIST OF SLOT)) (options KEYWORD-KEY-VALUE-LIST)) : CLASS</I>
<DD>Return a Stella class with name <VAR>name</VAR>.
Caution:  If the class already exists, the Stella class object gets
redefined, but the native C++ class is not redefined.
</DL>
</P><P>

<A NAME="IDX598"></A>
<DL>
<DT><U>Function:</U> <B>define-stella-method-slot</B> <I>((inputname SYMBOL) (returntypes CONS) (function? BOOLEAN) (inputParameters CONS) (options KEYWORD-KEY-VALUE-LIST)) : METHOD-SLOT</I>
<DD>Define a new Stella method object (a slot), and attach it
to the class identified by the first parameter in <VAR>inputParameters</VAR>.
</DL>
</P><P>

<A NAME="IDX599"></A>
<DL>
<DT><U>Macro:</U> <B>defmain</B> <I>((varList CONS) &#38;body (body CONS)) : OBJECT</I>
<DD>Defines a function called MAIN which will have the appropriate
signature for the target translation language.  The signature will be:
  C++:   public static int main (int v1, char** v2) {&#60;body&#62;}
  Java:  public static void main (String [] v2) {&#60;body&#62;}
  Lisp:  (defun main (&#38;rest args) &#60;body&#62;)
The argument <VAR>varList</VAR> must have two symbols, which will be the names for the
INTEGER argument count and an array of STRINGs with the argument values.  It
can also be empty to indicate that no command line arguments will be handled.
The startup function for the containing system will automatically be called
before <VAR>body</VAR> is executed unless the option :STARTUP-SYSTEM? was supplied as
FALSE.  There can only be one DEFMAIN per module.
</DL>
</P><P>

<A NAME="IDX600"></A>
<DL>
<DT><U>Command:</U> <B>defsystem</B> <I>((name SYMBOL) &#38;rest (options OBJECT)) : SYSTEM-DEFINITION</I>
<DD>Define a system of files that collectively define
a Stella application.
   Required options are:
   :directory -- the path from the Stella root directory to the directory
                 containing the system files.  Can be a string or a list
                 of strings (do not include directory separators).
   :files -- a list of files in the system, containing strings and lists
             of strings; the latter defines exploded paths to files
             in subdirectories.
   Optional options are:
   :required-systems -- a list of systems (strings) that should be loaded
                        prior to loading this system.
   :cardinal-module -- the name (a string) of the principal module for this
                       system.
   :copyright-header -- string with a header for inclusion into all translated
                        files produced by Stella.
   :lisp-only-files  -- Like the :files keyword, but these are only included
   :cpp-only-files      in the translation for the specific language, namely
   :java-only-files     Common Lisp, C++ or Java
</DL>
</P><P>

<A NAME="IDX601"></A>
<DL>
<DT><U>Method:</U> <B>deleted?</B> <I>((self OBJECT)) : BOOLEAN</I>
<DD>Default <CODE>deleted?</CODE> method which always returns FALSE.  Objects
that inherit DYNAMIC-SLOTS-MIXIN also inherit the dynamically-allocated slot
<CODE>deleted-object?</CODE> which is read/writable with specializations of this method.
</DL>
</P><P>

<A NAME="IDX602"></A>
<DL>
<DT><U>Command:</U> <B>describe</B> <I>((name OBJECT) &#38;rest (mode OBJECT)) :</I>
<DD>Print a description of an object in :verbose, :terse,
or :source modes.
</DL>
</P><P>

<A NAME="IDX603"></A>
<DL>
<DT><U>Method:</U> <B>describe-object</B> <I>((self OBJECT) (stream OUTPUT-STREAM) (mode KEYWORD)) :</I>
<DD>Prints a description of <VAR>self</VAR> to stream <VAR>stream</VAR>.  <VAR>mode</VAR>
can be :terse, :verbose, or :source.  The :terse mode is often equivalent
to the standard print function.
</DL>
</P><P>

<A NAME="IDX604"></A>
<DL>
<DT><U>Method:</U> <B>destroy-class</B> <I>((self CLASS)) :</I>
<DD>Destroy the Stella class <VAR>self</VAR>.  
Unfinalize its subclasses (if it has any).
</DL>
</P><P>

<A NAME="IDX605"></A>
<DL>
<DT><U>Function:</U> <B>destroy-class-and-subclasses</B> <I>((self CLASS)) :</I>
<DD>Destroy the Stella class <VAR>self</VAR> and all its subclasses.
</DL>
</P><P>

<A NAME="IDX606"></A>
<DL>
<DT><U>Function:</U> <B>destructure-defmethod-tree</B> <I>((method-tree CONS) (options-table KEY-VALUE-LIST)) : OBJECT CONS CONS</I>
<DD>Return three parse trees representing the name,
parameters, and code body of the parse tree <VAR>method-tree</VAR>.  Fill
<VAR>options-table</VAR> with a dictionary of method options.
Storage note:  Options are treated specially because the other return
values are subtrees of <VAR>method-tree</VAR>, while <VAR>options-table</VAR> is a newly-created
cons tree.  Note also, the parameter and body trees are destructively
removed from <VAR>method-tree</VAR>.
</DL>
</P><P>

<A NAME="IDX607"></A>
<DL>
<DT><U>Function:</U> <B>dictionary</B> <I>((collectionType TYPE) &#38;rest (alternatingkeysandvalues OBJECT)) : (ABSTRACT-DICTIONARY OF OBJECT OBJECT)</I>
<DD>Return a dictionary of <VAR>collectionType</VAR> containing <CODE>values</CODE>, in order.
Currently supported <VAR>collectionType</VAR>s are @HASH-TABLE, @STELLA-HASH-TABLE,
@KEY-VALUE-LIST, @KEY-VALUE-MAP and @PROPERTY-LIST.
</DL>
</P><P>

<A NAME="IDX608"></A>
<DL>
<DT><U>Method:</U> <B>direct-super-classes</B> <I>((self CLASS)) : (ITERATOR OF CLASS)</I>
<DD>Returns an iterator that generates all direct
super classes of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX609"></A>
<DL>
<DT><U>Command:</U> <B>disable-memoization</B> <I>() :</I>
<DD>Enable memoization and use of memoized expression results.
</DL>
</P><P>

<A NAME="IDX610"></A>
<DL>
<DT><U>Function:</U> <B>disabled-stella-feature?</B> <I>((feature KEYWORD)) : BOOLEAN</I>
<DD>Return true if the STELLA <VAR>feature</VAR> is currently disabled.
</DL>
</P><P>

<A NAME="IDX611"></A>
<DL>
<DT><U>Function:</U> <B>drop-hook</B> <I>((hookList HOOK-LIST) (hookFunction SYMBOL)) :</I>
<DD>Remove the function named <VAR>hookFunction</VAR> from <VAR>hookList</VAR>.
</DL>
</P><P>

<A NAME="IDX612"></A>
<DL>
<DT><U>Command:</U> <B>drop-trace</B> <I>(&#38;rest (keywords GENERALIZED-SYMBOL)) : LIST</I>
<DD>Disable trace messages identified by any of the listed <VAR>keywords</VAR>.  After
calling (<CODE>drop-trace</CODE> &#60;keyword&#62;) code guarded by (<CODE>trace-if</CODE> &#60;keyword&#62; ...)
will not be executed when it is encountered.
</DL>
</P><P>

<A NAME="IDX613"></A>
<DL>
<DT><U>Macro:</U> <B>either</B> <I>((value1 OBJECT) (value2 OBJECT)) : OBJECT</I>
<DD>If <VAR>value1</VAR> is defined, return that, else return <VAR>value2</VAR>.
</DL>
</P><P>

<A NAME="IDX614"></A>
<DL>
<DT><U>Method:</U> <B>empty?</B> <I>((x STRING-WRAPPER)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is the wrapped empty string ""
</DL>
</P><P>

<A NAME="IDX615"></A>
<DL>
<DT><U>Command:</U> <B>enable-memoization</B> <I>() :</I>
<DD>Enable memoization and use of memoized expression results.
</DL>
</P><P>

<A NAME="IDX616"></A>
<DL>
<DT><U>Function:</U> <B>enabled-stella-feature?</B> <I>((feature KEYWORD)) : BOOLEAN</I>
<DD>Return true if the STELLA <VAR>feature</VAR> is currently enabled.
</DL>
</P><P>

<A NAME="IDX617"></A>
<DL>
<DT><U>Macro:</U> <B>error</B> <I>(&#38;body (body CONS)) : OBJECT</I>
<DD>Signal error message, placing non-string arguments in quotes.
</DL>
</P><P>

<A NAME="IDX618"></A>
<DL>
<DT><U>Function:</U> <B>evaluate</B> <I>((expression OBJECT)) : OBJECT</I>
<DD>Evaluate the expression <VAR>expression</VAR> and return the result.
Currently, only the evaluation of (possibly nested) commands and global
variables is supported.  The second return value indicates the actual type 
of the result (which might have been wrapped), and the third return value
indicates whether an error occurred during the evaluation.  Expressions
are simple to program in Common Lisp, since they are built into the language,
and relatively awkward in Java and C++.  Users of either of those 
languages are more likely to want to call <CODE>evaluate-string</CODE>.
</DL>
</P><P>

<A NAME="IDX619"></A>
<DL>
<DT><U>Function:</U> <B>evaluate-string</B> <I>((expression STRING)) : OBJECT</I>
<DD>Evaluate the expression represented by <VAR>expression</VAR> and return the result.
This is equivalent to <CODE>(evaluate (unstringify expression))</CODE>.
</DL>
</P><P>

<A NAME="IDX620"></A>
<DL>
<DT><U>Function:</U> <B>exception-message</B> <I>((e NATIVE-EXCEPTION)) : STRING</I>
<DD>Accesses the error message of the exception <VAR>e</VAR>.
</DL>
</P><P>

<A NAME="IDX621"></A>
<DL>
<DT><U>Method:</U> <B>extension</B> <I>((self CLASS)) : CLASS-EXTENSION</I>
<DD>Return the nearest class extension that records instances
of the class <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX622"></A>
<DL>
<DT><U>Function:</U> <B>fill-in-date-substitution</B> <I>((substitution-list (KEY-VALUE-LIST OF STRING-WRAPPER STRING-WRAPPER))) :</I>
<DD>Fill in <VAR>substitution-list</VAR> with template variable substitions
for the names YEAR and DATE which correspond to the current year and date.
These substitutions can then be used with <CODE>substitute-template-variables-in-string</CODE>
</DL>
</P><P>

<A NAME="IDX623"></A>
<DL>
<DT><U>Function:</U> <B>finalize-classes</B> <I>() :</I>
<DD>Finalize all currently unfinalized classes.
</DL>
</P><P>

<A NAME="IDX624"></A>
<DL>
<DT><U>Function:</U> <B>finalize-classes-and-slots</B> <I>() :</I>
<DD>Finalize all currently unfinalized classes and slots.
</DL>
</P><P>

<A NAME="IDX625"></A>
<DL>
<DT><U>Function:</U> <B>finalize-slots</B> <I>() :</I>
<DD>Finalize all currently unfinalized slots.
</DL>
</P><P>

<A NAME="IDX626"></A>
<DL>
<DT><U>Macro:</U> <B>first-defined</B> <I>(&#38;body (forms CONS)) : OBJECT</I>
<DD>Return the result of the first form in <VAR>forms</VAR> whose value is defined
or NULL otherwise.
</DL>
</P><P>

<A NAME="IDX627"></A>
<DL>
<DT><U>Function:</U> <B>flush-output</B> <I>((self OUTPUT-STREAM)) :</I>
<DD>Flush all buffered output of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX628"></A>
<DL>
<DT><U>Function:</U> <B>format-with-padding</B> <I>((input STRING) (length INTEGER) (padchar CHARACTER) (align KEYWORD) (truncate? BOOLEAN)) : STRING</I>
<DD>Formats <VAR>input</VAR> to be (at least) <VAR>length</VAR> long, using <VAR>padchar</VAR> to
fill if necessary.  <VAR>align</VAR> must be one of :LEFT, :RIGHT, :CENTER and will control
how <VAR>input</VAR> will be justified in the resulting string.  If <VAR>truncate?</VAR> is true, then
then an overlength string will be truncated, using the opposite of <VAR>align</VAR> to pick
the truncation direction.
</DL>
</P><P>

<A NAME="IDX629"></A>
<DL>
<DT><U>Method:</U> <B>free</B> <I>((self ACTIVE-OBJECT)) :</I>
<DD>Remove all pointers between <VAR>self</VAR> and other objects,
and then deallocate the storage for self.
</DL>
</P><P>

<A NAME="IDX630"></A>
<DL>
<DT><U>Method:</U> <B>free</B> <I>((self OBJECT)) :</I>
<DD>Default method.  Deallocate storage for <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX631"></A>
<DL>
<DT><U>Method:</U> <B>free-hash-table-values</B> <I>((self ABSTRACT-HASH-TABLE)) :</I>
<DD>Call free on each value in the hash table <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX632"></A>
<DL>
<DT><U>Method:</U> <B>get-calendar-date</B> <I>((date CALENDAR-DATE) (timezone FLOAT)) : INTEGER INTEGER INTEGER KEYWORD</I>
<DD>Returns multiple values of year, month, day and day of week for <VAR>date</VAR>
in <VAR>timezone</VAR>.  <VAR>timezone</VAR> is the number of hours added to UTC to get local time.  It
is in the range -12.0 to +14.0 where UTC is zone 0.0
</DL>
</P><P>

<A NAME="IDX633"></A>
<DL>
<DT><U>Function:</U> <B>get-global-value</B> <I>((self SURROGATE)) : OBJECT</I>
<DD>Return the (possibly-wrapped) value of the global
variable for the surrogate <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX634"></A>
<DL>
<DT><U>Function:</U> <B>get-local-standard-time-zone</B> <I>() : FLOAT</I>
<DD>Returns the standard time zone offset from UTC as a float,
without considering the effects of daylight savings time.
</DL>
</P><P>

<A NAME="IDX635"></A>
<DL>
<DT><U>Function:</U> <B>get-local-time-zone-for-date</B> <I>((year INTEGER) (month INTEGER) (day INTEGER) (hour INTEGER) (minute INTEGER) (second INTEGER)) : FLOAT</I>
<DD>Returns the time zone offset from UTC (as a float)
that is applicable to the given date.  Assumes that the date is one
that is valid for the underlying programming language.  If not, then
returns 0.0
</DL>
</P><P>

<A NAME="IDX636"></A>
<DL>
<DT><U>Function:</U> <B>get-quoted-tree</B> <I>((tree-name STRING) (modulename STRING)) : CONS</I>
<DD>Return the quoted tree with name <VAR>tree-name</VAR>.
</DL>
</P><P>

<A NAME="IDX637"></A>
<DL>
<DT><U>Function:</U> <B>get-slot</B> <I>((self STANDARD-OBJECT) (slot-name SYMBOL)) : SLOT</I>
<DD>Return the slot named <VAR>slot-name</VAR> on the class
representing the type of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX638"></A>
<DL>
<DT><U>Method:</U> <B>get-stella-class</B> <I>((class-name TYPE) (error? BOOLEAN)) : CLASS</I>
<DD>Return a class with name <VAR>class-name</VAR>.  If none exists, break
if <VAR>error?</VAR>, else return <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX639"></A>
<DL>
<DT><U>Method:</U> <B>get-stella-class</B> <I>((class-name SYMBOL) (error? BOOLEAN)) : CLASS</I>
<DD>Return a class with name <VAR>class-name</VAR>.  If non exists, break
if <VAR>error?</VAR>, else return <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX640"></A>
<DL>
<DT><U>Method:</U> <B>get-stella-class</B> <I>((class-name STRING) (error? BOOLEAN)) : CLASS</I>
<DD>Return a class with name <VAR>class-name</VAR>.  If none exists, break
if <VAR>error?</VAR>, else return <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX641"></A>
<DL>
<DT><U>Method:</U> <B>get-time</B> <I>((date CALENDAR-DATE) (timezone FLOAT)) : INTEGER INTEGER INTEGER INTEGER</I>
<DD>Returns multiple values of hours, minutes, seconds, milliseconds for
the calendar date <VAR>date</VAR> in <VAR>timezone</VAR>.  <VAR>timezone</VAR> is the number of hours added to UTC
to get local time.  It is in the range -12.0 to +14.0 where UTC is zone 0.0
</DL>
</P><P>

<A NAME="IDX642"></A>
<DL>
<DT><U>Function:</U> <B>global-variable-type-spec</B> <I>((global GLOBAL-VARIABLE)) : TYPE-SPEC</I>
<DD>Return the type spec for the global variable <VAR>global</VAR>.
</DL>
</P><P>

<A NAME="IDX643"></A>
<DL>
<DT><U>Function:</U> <B>hash-string</B> <I>((string STRING) (seedCode INTEGER)) : INTEGER</I>
<DD>Generate a hash-code for <VAR>string</VAR> and return it.
Two strings that are equal but not eq will generate the same code.
The hash-code is based on <VAR>seedCode</VAR> which usually will be 0.  However,
<VAR>seedCode</VAR> can also be used to supply the result of a previous hash
operation to achieve hashing on sequences of strings without actually
having to concatenate them.
</DL>
</P><P>

<A NAME="IDX644"></A>
<DL>
<DT><U>Function:</U> <B>help-get-stella-module</B> <I>((pathName STRING) (error? BOOLEAN)) : MODULE</I>
<DD>Return the module located at <VAR>pathName</VAR>, or <CODE>null</CODE>
if no such module exists.  The search looks at ancestors and top-most
 (cardinal) modules.  If <VAR>error?</VAR> is <CODE>true</CODE>, throw an exception if no
 module is found.
</DL>
</P><P>

<A NAME="IDX645"></A>
<DL>
<DT><U>Method:</U> <B>home-module</B> <I>((self OBJECT)) : MODULE</I>
<DD>Return the home module of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX646"></A>
<DL>
<DT><U>Macro:</U> <B>if-output-language</B> <I>((language KEYWORD) (thenForm OBJECT) (elseForm OBJECT)) : OBJECT</I>
<DD>Expand to <VAR>thenForm</VAR> if the current translator output
language equals <VAR>language</VAR>.  Otherwise, expand to <VAR>elseForm</VAR>.  This can
be used to conditionally translate Stella code.
</DL>
</P><P>

<A NAME="IDX647"></A>
<DL>
<DT><U>Macro:</U> <B>if-stella-feature</B> <I>((feature KEYWORD) (thenForm OBJECT) (elseForm OBJECT)) : OBJECT</I>
<DD>Expand to <VAR>thenForm</VAR> if <VAR>feature</VAR> is a currently enabled
STELLA environment feature.  Otherwise, expand to <VAR>elseForm</VAR>.  This can
be used to conditionally translate Stella code.
</DL>
</P><P>

<A NAME="IDX648"></A>
<DL>
<DT><U>Macro:</U> <B>ignore</B> <I>(&#38;body (variables CONS)) : OBJECT</I>
<DD>Ignore unused <VAR>variables</VAR> with NoOp <CODE>setq</CODE> statements.
</DL>
</P><P>

<A NAME="IDX649"></A>
<DL>
<DT><U>Function:</U> <B>incrementally-translate</B> <I>((tree OBJECT)) : OBJECT</I>
<DD>Translate a single Stella expression <VAR>tree</VAR> and return
the result.  For C++ and Java print the translation to standard output and
return NIL instead.
</DL>
</P><P>

<A NAME="IDX650"></A>
<DL>
<DT><U>Macro:</U> <B>inform</B> <I>(&#38;body (body CONS)) : OBJECT</I>
<DD>Print informative message, placing non-string arguments in quotes,
and terminating with a newline.
</DL>
</P><P>

<A NAME="IDX651"></A>
<DL>
<DT><U>Method:</U> <B>initial-value</B> <I>((self CLASS)) : OBJECT</I>
<DD>Return an initial value for the class <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX652"></A>
<DL>
<DT><U>Method:</U> <B>initial-value</B> <I>((self STORAGE-SLOT)) : OBJECT</I>
<DD>Return an initial value for <VAR>self</VAR>, or <CODE>null</CODE>.  The
initial value can be defined by the slot itself, inherited from an
equivalent slot, or inherit from the :initial-value option for the 
class representing the type of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX653"></A>
<DL>
<DT><U>Method:</U> <B>initialize-hash-table</B> <I>((self STELLA-HASH-TABLE)) :</I>
<DD>Initialize the STELLA hash table <VAR>self</VAR>.  This is a
no-op and primarily exists to shadow the standard initializer inherited
from ABSTRACT-HASH-TABLE.  STELLA hash tables are initialized at the
first insertion operation.
</DL>
</P><P>

<A NAME="IDX654"></A>
<DL>
<DT><U>Method:</U> <B>initially</B> <I>((self STORAGE-SLOT)) : OBJECT</I>
<DD>Defines the value of a slot before it has been assigned
a value.
</DL>
</P><P>

<A NAME="IDX655"></A>
<DL>
<DT><U>Function:</U> <B>interpret-command-line-arguments</B> <I>((count INTEGER) (arguments (ARRAY () OF STRING))) :</I>
<DD>Interpret any STELLA-relevant command line <VAR>arguments</VAR>.
</DL>
</P><P>

<A NAME="IDX656"></A>
<DL>
<DT><U>Function:</U> <B>isa?</B> <I>((object OBJECT) (type TYPE)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> iff <VAR>object</VAR> is an instance of the class named <VAR>type</VAR>.
</DL>
</P><P>

<A NAME="IDX657"></A>
<DL>
<DT><U>Function:</U> <B>java-translate-system</B> <I>((systemName STRING)) :</I>
<DD>Translate the system <VAR>systemName</VAR> to Java.
</DL>
</P><P>

<A NAME="IDX658"></A>
<DL>
<DT><U>Command:</U> <B>jptrans</B> <I>((statement OBJECT)) :</I>
<DD>Translate <VAR>statement</VAR> to C++ and print the result.
</DL>
</P><P>

<A NAME="IDX659"></A>
<DL>
<DT><U>Method:</U> <B>length</B> <I>((self CONS-ITERATOR)) : INTEGER</I>
<DD>Iterate over <VAR>self</VAR>, and count how many items there are.
</DL>
</P><P>

<A NAME="IDX660"></A>
<DL>
<DT><U>Function:</U> <B>lispify</B> <I>((thing UNKNOWN)) : LISP-CODE</I>
<DD>Convert a Stella <VAR>thing</VAR> as much as possible into a
Common-Lisp analogue.  The currently supported <VAR>thing</VAR> types are CONS, LIST,
KEY-VALUE-LIST, ITERATOR, SYMBOL, KEYWORD, and all wrapped and unwrapped
literal types.  BOOLEANs are translated into Lisp's CL:T and CL:NIL logic.
Unsupported types are left unchanged.
</DL>
</P><P>

<A NAME="IDX661"></A>
<DL>
<DT><U>Function:</U> <B>lispify-boolean</B> <I>((thing UNKNOWN)) : LISP-CODE</I>
<DD>Lispify <VAR>thing</VAR> which is assumed to be a (possibly wrapped) 
Stella boolean.
</DL>
</P><P>

<A NAME="IDX662"></A>
<DL>
<DT><U>Method:</U> <B>listify</B> <I>((self CONS)) : (LIST OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return a list of elements in <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX663"></A>
<DL>
<DT><U>Method:</U> <B>listify</B> <I>((self LIST)) : (LIST OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX664"></A>
<DL>
<DT><U>Method:</U> <B>listify</B> <I>((self KEY-VALUE-LIST)) : (LIST OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return a list of key-value pairs in <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX665"></A>
<DL>
<DT><U>Method:</U> <B>listify</B> <I>((self VECTOR)) : (LIST OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return a list of elements in <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX666"></A>
<DL>
<DT><U>Method:</U> <B>listify</B> <I>((self ITERATOR)) : (LIST OF (LIKE (ANY-VALUE SELF)))</I>
<DD>Return a list of elements generated by <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX667"></A>
<DL>
<DT><U>Function:</U> <B>load-configuration-file</B> <I>((file FILE-NAME)) : CONFIGURATION-TABLE</I>
<DD>Read a configuration <VAR>file</VAR> and return its content as a configuration table.
Also enter each property read into the global system configuration table.
Assumes Java-style property file syntax.  Each property name is represented
as a wrapped string and each value as a wrapped string/integer/float or boolean.
</DL>
</P><P>

<A NAME="IDX668"></A>
<DL>
<DT><U>Command:</U> <B>load-file</B> <I>((file STRING)) :</I>
<DD>Read STELLA commands from <VAR>file</VAR> and evaluate them.
The file should begin with an <CODE>in-module</CODE> declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
<CODE>evaluate</CODE> to each of them.
</DL>
</P><P>

<A NAME="IDX669"></A>
<DL>
<DT><U>Function:</U> <B>load-system</B> <I>((systemName STRING) (language KEYWORD) &#38;rest (options OBJECT)) : BOOLEAN</I>
<DD>Natively <VAR>language</VAR>-compile out-of-date translated files of system
<VAR>systemName</VAR> and then load them into the running system (this is only
supported/possible for Lisp at the moment).  Return true if at least one
file was compiled. The following keyword/value <VAR>options</VAR> are recognized:
</P><P>

<CODE>:force-recompilation?</CODE> (default false): if true, files will be compiled
whether or not their compilations are up-to-date.
</P><P>

<CODE>:startup?</CODE> (default true): if true, the system startup function will
be called once all files have been loaded.
</DL>
</P><P>

<A NAME="IDX670"></A>
<DL>
<DT><U>Method:</U> <B>lookup-class</B> <I>((name SYMBOL)) : CLASS</I>
<DD>Return a class with name <VAR>name</VAR>.  Scan all
visible surrogates looking for one that has a class defined for it.
</DL>
</P><P>

<A NAME="IDX671"></A>
<DL>
<DT><U>Method:</U> <B>lookup-class</B> <I>((name STRING)) : CLASS</I>
<DD>Return a class with name <VAR>name</VAR>.  Scan all
visible surrogates looking for one that has a class defined for it.
</DL>
</P><P>

<A NAME="IDX672"></A>
<DL>
<DT><U>Function:</U> <B>lookup-command</B> <I>((name SYMBOL)) : METHOD-SLOT</I>
<DD>If <VAR>name</VAR> names an evaluable command return its associated
command object;  otherwise, return <CODE>null</CODE>.  Currently, commands are not
polymorphic, i.e., they can only be implemented by functions.
</DL>
</P><P>

<A NAME="IDX673"></A>
<DL>
<DT><U>Function:</U> <B>lookup-configuration-property</B> <I>((property STRING) (defaultValue WRAPPER) (configuration CONFIGURATION-TABLE)) : WRAPPER</I>
<DD>Lookup <VAR>property</VAR> in <VAR>configuration</VAR> and return its value.
Use the global system configuration table if <VAR>configuration</VAR> is NULL.  Return
<VAR>defaultValue</VAR> if <VAR>property</VAR> is not defined.
</DL>
</P><P>

<A NAME="IDX674"></A>
<DL>
<DT><U>Function:</U> <B>lookup-demon</B> <I>((name STRING)) : DEMON</I>
<DD>Return the demon named <VAR>name</VAR>.
</DL>
</P><P>

<A NAME="IDX675"></A>
<DL>
<DT><U>Function:</U> <B>lookup-function</B> <I>((functionSymbol SYMBOL)) : FUNCTION</I>
<DD>Return the function defined for <VAR>functionSymbol</VAR>, if it exists.
</DL>
</P><P>

<A NAME="IDX676"></A>
<DL>
<DT><U>Function:</U> <B>lookup-function-by-name</B> <I>((name STRING)) : FUNCTION</I>
<DD>Return a function with name <VAR>name</VAR> visible from the current module.
Scan all visible symbols looking for one that has a function defined for it.
</DL>
</P><P>

<A NAME="IDX677"></A>
<DL>
<DT><U>Method:</U> <B>lookup-global-variable</B> <I>((self SURROGATE)) : GLOBAL-VARIABLE</I>
<DD>Return a global variable with name <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX678"></A>
<DL>
<DT><U>Method:</U> <B>lookup-global-variable</B> <I>((self GENERALIZED-SYMBOL)) : GLOBAL-VARIABLE</I>
<DD>Return a global variable with name <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX679"></A>
<DL>
<DT><U>Method:</U> <B>lookup-global-variable</B> <I>((self STRING)) : GLOBAL-VARIABLE</I>
<DD>Return a global variable with name <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX680"></A>
<DL>
<DT><U>Function:</U> <B>lookup-local-slot</B> <I>((class CLASS) (slot-name SYMBOL)) : SLOT</I>
<DD>Lookup a local slot with <VAR>slot-name</VAR> on <VAR>class</VAR>.
</DL>
</P><P>

<A NAME="IDX681"></A>
<DL>
<DT><U>Function:</U> <B>lookup-macro</B> <I>((name SYMBOL)) : METHOD-SLOT</I>
<DD>If <VAR>name</VAR> has a macro definition, return the method object
holding its expander function.
</DL>
</P><P>

<A NAME="IDX682"></A>
<DL>
<DT><U>Function:</U> <B>lookup-slot</B> <I>((class CLASS) (slot-name SYMBOL)) : SLOT</I>
<DD>Return a slot owned by the class <VAR>class</VAR> with name <VAR>slot-name</VAR>.
Multiply inherited slots are disambiguated by a left-to-right class
precedence order for classes with multiple parents (similar to CLOS).
</DL>
</P><P>

<A NAME="IDX683"></A>
<DL>
<DT><U>Command:</U> <B>lptrans</B> <I>((statement OBJECT)) :</I>
<DD>Translate <VAR>statement</VAR> to Common-Lisp and print the result.
</DL>
</P><P>

<A NAME="IDX684"></A>
<DL>
<DT><U>Function:</U> <B>make-matching-name</B> <I>((original STRING) &#38;rest (options OBJECT)) : STRING</I>
<DD>Keyword options:
  :break-on-cap    one of  :YES :NO :CLEVER         default is :CLEVER
  :break-on-number one of  :YES :NO :CLEVER         default is :CLEVER
  :break-on-separators string                       default is "-_ "
  :remove-prefix   string
  :remove-suffix   string
  
  :case            one of  :UPCASE :TitleCase :titleCaseX :downcase :Capitalize :preserve
                                                     default is :TitleCase
  :separator       string                            default is ""
  :add-prefix      string
  :add-suffix      string
</P><P>

  MAKE-MATCHING-NAME returns a matching name (a string) for the input name (a string).
A matching name is constructed by breaking the input into <CODE>words</CODE> and then applying
appropriate transforms.  The arguments are used as follows:
  <VAR>original</VAR>         is the input name.  It is a string.
  :break-on-cap    is a keyword controlling whether changes in capitalization is used
                   to indicate word boundaries.  If :YES, then all capitalization
                   changes delineate words.  If :CLEVER, then unbroken runs of
                   capitalized letters are treated as acronyms and remain grouped.
                   If :NO or NULL, there is no breaking of words based on capitalization.
  :break-on-number is a flag controlling whether encountering a number indicates
                   a word boundary.  If :YES, then each run of numbers is treated as
		   a word separate from surrounding words.  If :CLEVER, then an 
		   attempt is made to recognize ordinal numbers (ie, 101st) and
		   treat them as separate words.  If :NO or NULL, there is no breaking
                   of words when numbers are encountered.
  :break-on-separators   A string of characters which constitute word delimiters in
                         the input word.  This is used to determine how to break
                   the name into individual words.  Defaults are space, <CODE>-</CODE> and <CODE>_</CODE>.
  :remove-prefix   Specifies a prefix or suffix that is stripped from the input
  :remove-suffix   name before any other processing.  This allows the removal of
                   any naming convention dictated prefixes or suffixes.
  :add-prefix      Specifies a prefix or suffix that is added to the output name
  :add-suffix      after all other processing.  This allows the addition of any
                   naming convention dictated prefixes or suffixes.
  :case            The case of the resulting name.  This is applied to the name 
                   before adding prefixes or suffixes.  The two title case options 
                   differ only in how the first word of the name is treated.
                   :TitleCase capitalizes the first letter of the first word and
                       also the first letter of all other words.
                   :TitleCaseX does not capitalizes the first letter of the first
		       word but capitalizes the first letter of all subsequent words.
		   :preserve results in no change in case.
  :separator       This is a string specifying the word separator to use in the
                   returned name.  An empty string (the default) means that the
                   resulting words are concatenated without any separation.  This
                   normally only makes sense when using one of the title case values
                   for the case keyword.
</DL>
</P><P>

<A NAME="IDX685"></A>
<DL>
<DT><U>Function:</U> <B>make-matching-name-full</B> <I>((originalname STRING) (breakoncap KEYWORD) (breakonnumber KEYWORD) (breakonseparators STRING) (removeprefix STRING) (removesuffix STRING) (addprefix STRING) (addsuffix STRING) (outputcase KEYWORD) (outputseparator STRING)) : STRING</I>
<DD>Non-keyword version of <CODE>make-matching-name</CODE>, which will probably be
easier to use when called from non-Lisp languages.
</DL>
</P><P>

<A NAME="IDX686"></A>
<DL>
<DT><U>Command:</U> <B>make-system</B> <I>((systemName STRING) (language KEYWORD) &#38;rest (options OBJECT)) : BOOLEAN</I>
<DD>Translate all out-of-date files of system <VAR>systemName</VAR>
into <VAR>language</VAR> and then compile and load them (the latter is only possible
for Lisp right now).  The following keyword/value <VAR>options</VAR> are recognized:
</P><P>

<CODE>:two-pass?</CODE>: if true, all files will be scanned twice, once to
load the signatures of objects defined in them, and once to actually
translate the definitions.  Otherwise, the translator will make one pass in
the case that the system is already loaded (and is being remade), and two
passes otherwise.
</P><P>

<CODE>:development-settings?</CODE> (default false): if true translation will favor
safe, readable and debuggable code over efficiency (according to the value
of <CODE>:development-settings</CODE> on the system definition).  If false, efficiency
will be favored instead (according to the value of <CODE>:production-settings</CODE>
on the system definition).
</P><P>

<CODE>:production-settings?</CODE> (default true): inverse to <CODE>:development-settings?</CODE>.
</P><P>

<CODE>:force-translation?</CODE> (default false): if true, files will be translated
whether or not their translations are up-to-date.
</P><P>

<CODE>:force-recompilation?</CODE> (default false): if true, translated files will be
recompiled whether or not their compilations are up-to-date (only supported
in Lisp right now).
</P><P>

<CODE>:load-system?</CODE> (default true): if true, compiled files will be loaded into
the current STELLA image (only supported in Lisp right now).
</P><P>

<CODE>:startup?</CODE> (default true): if true, the system startup function will
be called once all files have been loaded.
</DL>
</P><P>

<A NAME="IDX687"></A>
<DL>
<DT><U>Method:</U> <B>member?</B> <I>((self CONS-ITERATOR) (value OBJECT)) : BOOLEAN</I>
<DD>Iterate over values of <VAR>self</VAR> and return TRUE
if one of them is <CODE>eql?</CODE> to 'value.
</DL>
</P><P>

<A NAME="IDX688"></A>
<DL>
<DT><U>Method:</U> <B>member?</B> <I>((self COLLECTION) (object OBJECT)) : BOOLEAN</I>
<DD>Return true iff <VAR>object</VAR> is a member of the collection <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX689"></A>
<DL>
<DT><U>Method:</U> <B>member?</B> <I>((self SEQUENCE) (value OBJECT)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>value</VAR> is a member of the sequence <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX690"></A>
<DL>
<DT><U>Macro:</U> <B>memoize</B> <I>((inputArgs CONS) &#38;body (body CONS)) : OBJECT</I>
<DD>Compute the value of an expression and memoize it relative to
   the values of <VAR>inputArgs</VAR>.
<VAR>inputArgs</VAR> should characterize the complete set of values upon which
   the computation of the result depended.
Calls to <CODE>memoize</CODE> should be of the form
</P><P>

      (memoize (&#60;arg&#62;+) {:&#60;option&#62; &#60;value&#62;}* &#60;expression&#62;)
</P><P>

   and have the status of an expression.
   The following options are supported:
</P><P>

      :timestamps   A single or list of keywords specifying the names of
                    timestamps which when bumped should invalidate all
                    entries currently memoized in this table.
      :name         Names the memoization table so it can be shared by other
                    memoization sites.  By default, a gensymed name is used.
                    CAUTION: IT IS ASSUMED THAT ALL ENTRIES IN A MEMOZATION
                    TABLE DEPEND ON THE SAME NUMBER OF ARGUMENTS!!
      :max-values   The maximum number of values to be memoized.  Only the
                    <CODE>:max-values</CODE> most recently used values will be kept
                    in the memoization table, older values will be discarded
                    and recomputed if needed.  Without a <CODE>:max-values</CODE>
                    specification, the memoization table will grow
                    indefinitely.
</P><P>

PERFORMANCE NOTES: For most efficient lookup, input arguments that vary the most
should be listed first.  Also, arguments of type STANDARD-OBJECT (and all its
subtypes) can be memoized more efficiently than arguments of type OBJECT or
wrapped literals (with the exception of BOOLEANs).
</DL>
</P><P>

<A NAME="IDX691"></A>
<DL>
<DT><U>Function:</U> <B>merge-file-names</B> <I>((baseFile FILE-NAME) (defaults FILE-NAME)) : FILE-NAME</I>
<DD>Parse <VAR>baseFile</VAR>, supply any missing components from
<VAR>defaults</VAR> if supplied and return the result.
</DL>
</P><P>

<A NAME="IDX692"></A>
<DL>
<DT><U>Method:</U> <B>multiple-parents?</B> <I>((class CLASS)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>class</VAR> has more than one direct superclass.
</DL>
</P><P>

<A NAME="IDX693"></A>
<DL>
<DT><U>Method:</U> <B>multiple-parents?</B> <I>((module MODULE)) : BOOLEAN</I>
<DD>Return TRUE if <VAR>module</VAR> has more than one parent.
</DL>
</P><P>

<A NAME="IDX694"></A>
<DL>
<DT><U>Function:</U> <B>name-to-string</B> <I>((name OBJECT)) : STRING</I>
<DD>Return the string represented by <VAR>name</VAR>.  Return <CODE>null</CODE>
if <VAR>name</VAR> is undefined or does not represent a string.
</DL>
</P><P>

<A NAME="IDX695"></A>
<DL>
<DT><U>Method:</U> <B>next?</B> <I>((self MEMOIZABLE-ITERATOR)) : BOOLEAN</I>
<DD>Generate the next value of the memoized iterator <VAR>self</VAR> (or
one of its clones) by either using one of the values generated so far or by
generating and saving the next value of the <CODE>base-iterator</CODE>.
</DL>
</P><P>

<A NAME="IDX696"></A>
<DL>
<DT><U>Method:</U> <B>no-duplicates?</B> <I>((self COLLECTION)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if the collection <VAR>self</VAR> forbids duplicate values.
</DL>
</P><P>

<A NAME="IDX697"></A>
<DL>
<DT><U>Method:</U> <B>non-empty?</B> <I>((x STRING-WRAPPER)) : BOOLEAN</I>
<DD>Return true if <VAR>x</VAR> is not the wrapped empty string ""
</DL>
</P><P>

<A NAME="IDX698"></A>
<DL>
<DT><U>Method:</U> <B>nth</B> <I>((self NATIVE-VECTOR) (position INTEGER)) : (LIKE (ANY-VALUE SELF))</I>
<DD>Return the element in <VAR>self</VAR> at <VAR>position</VAR>.
</DL>
</P><P>

<A NAME="IDX699"></A>
<DL>
<DT><U>Macro:</U> <B>only-if</B> <I>((test OBJECT) (expression OBJECT)) : OBJECT</I>
<DD>If <VAR>test</VAR> is TRUE, return the result of evaluating 
<VAR>expression</VAR>.
</DL>
</P><P>

<A NAME="IDX700"></A>
<DL>
<DT><U>Function:</U> <B>open-network-stream</B> <I>((host STRING) (port INTEGER)) : INPUT-STREAM OUTPUT-STREAM</I>
<DD>Open a TCP/IP network stream to <VAR>host</VAR> at <VAR>port</VAR> and return the result
as an input/output stream pair.
</DL>
</P><P>

<A NAME="IDX701"></A>
<DL>
<DT><U>Method:</U> <B>ordered?</B> <I>((self COLLECTION)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if the collection <VAR>self</VAR> is ordered.
</DL>
</P><P>

<A NAME="IDX702"></A>
<DL>
<DT><U>Method:</U> <B>parameters</B> <I>((self CLASS)) : (LIST OF SYMBOL)</I>
<DD>Returns the list of parameters names of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX703"></A>
<DL>
<DT><U>Function:</U> <B>parse-date-time-in-time-zone</B> <I>((date-time-string STRING) (time-zone FLOAT) (start INTEGER) (end INTEGER) (error-on-mismatch? BOOLEAN)) : DECODED-DATE-TIME</I>
<DD>Tries very hard to make sense out of the argument <VAR>date-time-string</VAR> and
returns a time structure if successful.  If not, it returns <CODE>null</CODE>.
If <VAR>error-on-mismatch?</VAR> is true, parse-date-time will signal an error instead of
returning <CODE>null</CODE>.  
Default values are 00:00:00 in the given timezone on the current date.  If the
given <VAR>time-zone</VAR> value is <CODE>null</CODE>, then the local time zone for the given date
and time will be used as determined by the operating system.
</DL>
</P><P>

<A NAME="IDX704"></A>
<DL>
<DT><U>Function:</U> <B>pick-hash-table-size-prime</B> <I>((minSize INTEGER)) : INTEGER</I>
<DD>Return a hash table prime of at least <VAR>minSize</VAR>.
</DL>
</P><P>

<A NAME="IDX705"></A>
<DL>
<DT><U>Method:</U> <B>primary-type</B> <I>((self OBJECT)) : TYPE</I>
<DD>Returns the primary type of <VAR>self</VAR>.
Gets defined automatically for every non-abstract subclass of OBJECT.
</DL>
</P><P>

<A NAME="IDX706"></A>
<DL>
<DT><U>Method:</U> <B>primitive?</B> <I>((self RELATION)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>self</VAR> is not a defined relation.
</DL>
</P><P>

<A NAME="IDX707"></A>
<DL>
<DT><U>Macro:</U> <B>print</B> <I>(&#38;body (body CONS)) : OBJECT</I>
<DD>Print arguments to the standard output stream.
</DL>
</P><P>

<A NAME="IDX708"></A>
<DL>
<DT><U>Function:</U> <B>print-exception-context</B> <I>((e NATIVE-EXCEPTION) (stream OUTPUT-STREAM)) :</I>
<DD>Prints a system dependent information about the context of the specified
exception.  For example, in Java it prints a stack trace.  In Lisp, it is vendor dependent.
</DL>
</P><P>

<A NAME="IDX709"></A>
<DL>
<DT><U>Function:</U> <B>print-recycle-lists</B> <I>() :</I>
<DD>Print the current state of all recycle lists.
</DL>
</P><P>

<A NAME="IDX710"></A>
<DL>
<DT><U>Macro:</U> <B>print-spaces</B> <I>(&#38;body (body CONS)) : OBJECT</I>
<DD>(print-spaces [stream] N) prints N spaces onto stream.  If
no stream form is provided, then STANDARD-OUTPUT will be used.
</DL>
</P><P>

<A NAME="IDX711"></A>
<DL>
<DT><U>Command:</U> <B>print-stella-features</B> <I>() :</I>
<DD>Print the list of enabled and disabled STELLA features.
</DL>
</P><P>

<A NAME="IDX712"></A>
<DL>
<DT><U>Command:</U> <B>print-unbound-surrogates</B> <I>(&#38;rest (args OBJECT)) :</I>
<DD>Print all unbound surrogates visible from the module named by the first
argument (a symbol or string).  Look at all modules if no module name or
<CODE>null</CODE> was supplied.  If the second argument is <CODE>true</CODE>, only consider
surrogates interned in the specified module.
</DL>
</P><P>

<A NAME="IDX713"></A>
<DL>
<DT><U>Function:</U> <B>print-undefined-methods</B> <I>((module MODULE) (local? BOOLEAN)) :</I>
<DD>Print all declared but not yet defined functions and methods
in <VAR>module</VAR>.  If <VAR>local?</VAR> is true, do not consider any parent modules of
<VAR>module</VAR>.  If <VAR>module</VAR> is NULL, look at all modules in the system.  This
is handy to pinpoint forward declarations that haven't been followed up
by actual definitions.
</DL>
</P><P>

<A NAME="IDX714"></A>
<DL>
<DT><U>Command:</U> <B>print-undefined-super-classes</B> <I>((class NAME)) :</I>
<DD>Print all undefined or bad (indirect) super classes of <VAR>class</VAR>.
</DL>
</P><P>

<A NAME="IDX715"></A>
<DL>
<DT><U>Function:</U> <B>private-class-methods</B> <I>((class CLASS)) : (ITERATOR OF METHOD-SLOT)</I>
<DD>Iterate over all private methods attached to <VAR>class</VAR>.
</DL>
</P><P>

<A NAME="IDX716"></A>
<DL>
<DT><U>Function:</U> <B>private-class-storage-slots</B> <I>((class CLASS)) : (ITERATOR OF STORAGE-SLOT)</I>
<DD>Iterate over all private storage-slots attached to <VAR>class</VAR>.
</DL>
</P><P>

<A NAME="IDX717"></A>
<DL>
<DT><U>Method:</U> <B>private?</B> <I>((self RELATION)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>self</VAR> is not public.
</DL>
</P><P>

<A NAME="IDX718"></A>
<DL>
<DT><U>Command:</U> <B>ptrans</B> <I>((statement OBJECT)) :</I>
<DD>Translate <VAR>statement</VAR> to Common-Lisp and print the result.
</DL>
</P><P>

<A NAME="IDX719"></A>
<DL>
<DT><U>Function:</U> <B>public-class-methods</B> <I>((class CLASS)) : (ITERATOR OF METHOD-SLOT)</I>
<DD>Iterate over all private methods attached to <VAR>class</VAR>.
</DL>
</P><P>

<A NAME="IDX720"></A>
<DL>
<DT><U>Function:</U> <B>public-class-storage-slots</B> <I>((class CLASS)) : (ITERATOR OF STORAGE-SLOT)</I>
<DD>Iterate over all public storage-slots attached to <VAR>class</VAR>.
</DL>
</P><P>

<A NAME="IDX721"></A>
<DL>
<DT><U>Method:</U> <B>public-slots</B> <I>((self CLASS)) : (ITERATOR OF SLOT)</I>
<DD>Return an iterator over public slots of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX722"></A>
<DL>
<DT><U>Method:</U> <B>public-slots</B> <I>((self OBJECT)) : (ITERATOR OF SLOT)</I>
<DD>Return an iterator over public slots of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX723"></A>
<DL>
<DT><U>Method:</U> <B>public?</B> <I>((self SLOT)) : BOOLEAN</I>
<DD>True if <VAR>self</VAR> or one it its ancestors is marked public.
</DL>
</P><P>

<A NAME="IDX724"></A>
<DL>
<DT><U>Macro:</U> <B>pushf</B> <I>((place CONS) (value OBJECT)) : OBJECT</I>
<DD>Push <VAR>value</VAR> onto the cons list <VAR>place</VAR>.
</DL>
</P><P>

<A NAME="IDX725"></A>
<DL>
<DT><U>Method:</U> <B>reader</B> <I>((self STORAGE-SLOT)) : SYMBOL</I>
<DD>Name of a method called to read the value of the slot
<VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX726"></A>
<DL>
<DT><U>Method:</U> <B>remove-duplicates</B> <I>((self COLLECTION)) : (LIKE SELF)</I>
<DD>Return <VAR>self</VAR> with duplicates removed.  Preserves the
original order of the remaining members.
</DL>
</P><P>

<A NAME="IDX727"></A>
<DL>
<DT><U>Method:</U> <B>required-slots</B> <I>((self CLASS)) : (LIST OF SYMBOL)</I>
<DD>Returns a list of names of required slots for <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX728"></A>
<DL>
<DT><U>Method:</U> <B>required?</B> <I>((self STORAGE-SLOT)) : BOOLEAN</I>
<DD>True if a value must be assigned to this slot at
creation time.
</DL>
</P><P>

<A NAME="IDX729"></A>
<DL>
<DT><U>Command:</U> <B>reset-stella-features</B> <I>() :</I>
<DD>Reset STELLA features to their default settings.
</DL>
</P><P>

<A NAME="IDX730"></A>
<DL>
<DT><U>Function:</U> <B>reverse-interval</B> <I>((lowerbound INTEGER) (upperbound INTEGER)) : REVERSE-INTEGER-INTERVAL-ITERATOR</I>
<DD>Create a reverse interval object.
</DL>
</P><P>

<A NAME="IDX731"></A>
<DL>
<DT><U>Function:</U> <B>run-hooks</B> <I>((hooklist HOOK-LIST) (argument OBJECT)) :</I>
<DD>Run all hook functions in <VAR>hooklist</VAR>, applying
each one to <VAR>argument</VAR>.
</DL>
</P><P>

<A NAME="IDX732"></A>
<DL>
<DT><U>Function:</U> <B>running-as-lisp?</B> <I>() : BOOLEAN</I>
<DD>Return true if the executable code is a Common Lisp application.
</DL>
</P><P>

<A NAME="IDX733"></A>
<DL>
<DT><U>Function:</U> <B>safe-equal-hash-code</B> <I>((self OBJECT)) : INTEGER</I>
<DD>Return a hash code for <VAR>self</VAR>.  Just like <CODE>equal-hash-code</CODE>
- which see, but also works for NULL.  <CODE>equal-hash-code</CODE> methods that expect to
handle NULL components should use this function for recursive calls.
</DL>
</P><P>

<A NAME="IDX734"></A>
<DL>
<DT><U>Function:</U> <B>safe-hash-code</B> <I>((self OBJECT)) : INTEGER</I>
<DD>Return a hash code for <VAR>self</VAR>.  Just like <CODE>hash-code</CODE>
- which see, but also works for NULL.
</DL>
</P><P>

<A NAME="IDX735"></A>
<DL>
<DT><U>Function:</U> <B>safe-lookup-slot</B> <I>((class CLASS) (slot-name SYMBOL)) : SLOT</I>
<DD>Alias for <CODE>lookup-slot</CODE>.  Kept for backwards compatibility.
</DL>
</P><P>

<A NAME="IDX736"></A>
<DL>
<DT><U>Macro:</U> <B>safety</B> <I>((level INTEGER-WRAPPER) (test OBJECT) &#38;body (body CONS)) : OBJECT</I>
<DD>Signal warning message, placing non-string arguments in quotes.
</DL>
</P><P>

<A NAME="IDX737"></A>
<DL>
<DT><U>Function:</U> <B>search-cons-tree-with-filter?</B> <I>((tree OBJECT) (value OBJECT) (filter CONS)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> iff the value <VAR>value</VAR> is embedded within
the cons tree <VAR>tree</VAR>.  Uses an <CODE>eql?</CODE> test.  Does not descend into any
cons whose first element matches an element of <VAR>filter</VAR>.
</DL>
</P><P>

<A NAME="IDX738"></A>
<DL>
<DT><U>Function:</U> <B>search-for-object</B> <I>((self OBJECT) (typeref OBJECT)) : OBJECT</I>
<DD>If <VAR>self</VAR> is a string or a symbol, search for an object named
<VAR>self</VAR> of type <CODE>type</CODE>.  Otherwise, if <VAR>self</VAR> is an object, return it.
</DL>
</P><P>

<A NAME="IDX739"></A>
<DL>
<DT><U>Function:</U> <B>seed-random-number-generator</B> <I>() :</I>
<DD>Seeds the random number generator with the current time.
</DL>
</P><P>

<A NAME="IDX740"></A>
<DL>
<DT><U>Function:</U> <B>sequence</B> <I>((collectiontype TYPE) &#38;rest (values OBJECT)) : (SEQUENCE OF OBJECT)</I>
<DD>Return a sequence containing <VAR>values</VAR>, in order.
</DL>
</P><P>

<A NAME="IDX741"></A>
<DL>
<DT><U>Command:</U> <B>set-call-log-break-point</B> <I>((count INTEGER)) :</I>
<DD>Set a call log break point to <VAR>count</VAR>.  Execution will be
interrupted right at the entry of the <VAR>count</VAR>th logged function call.
</DL>
</P><P>

<A NAME="IDX742"></A>
<DL>
<DT><U>Function:</U> <B>set-configuration-property</B> <I>((property STRING) (value WRAPPER) (configuration CONFIGURATION-TABLE)) : WRAPPER</I>
<DD>Set <VAR>property</VAR> in <VAR>configuration</VAR> to <VAR>value</VAR> and return it.
Use the global system configuration table if <VAR>configuration</VAR> is NULL.
</DL>
</P><P>

<A NAME="IDX743"></A>
<DL>
<DT><U>Function:</U> <B>set-global-value</B> <I>((self SURROGATE) (value OBJECT)) : OBJECT</I>
<DD>Set the value of the global variable for the surrogate
<VAR>self</VAR> to <VAR>value</VAR>.
</DL>
</P><P>

<A NAME="IDX744"></A>
<DL>
<DT><U>Function:</U> <B>set-optimization-levels</B> <I>((safety INTEGER) (debug INTEGER) (speed INTEGER) (space INTEGER)) :</I>
<DD>Set optimization levels for the qualities <VAR>safety</VAR>, <VAR>debug</VAR>,
<VAR>speed</VAR>, and <VAR>space</VAR>.
</DL>
</P><P>

<A NAME="IDX745"></A>
<DL>
<DT><U>Command:</U> <B>set-stella-feature</B> <I>(&#38;rest (features KEYWORD)) :</I>
<DD>Enable all listed STELLA <VAR>features</VAR>.
</DL>
</P><P>

<A NAME="IDX746"></A>
<DL>
<DT><U>Command:</U> <B>set-translator-output-language</B> <I>((new-language KEYWORD)) : KEYWORD</I>
<DD>Set output language to <VAR>new-language</VAR>.  Return previous language.
</DL>
</P><P>

<A NAME="IDX747"></A>
<DL>
<DT><U>Macro:</U> <B>setq?</B> <I>((variable SYMBOL) (expression CONS)) : OBJECT</I>
<DD>Assign <VAR>variable</VAR> the result of evaluating <VAR>expression</VAR>, 
and return TRUE if <VAR>expression</VAR> is not NULL else return FALSE.
</DL>
</P><P>

<A NAME="IDX748"></A>
<DL>
<DT><U>Function:</U> <B>shadowed-symbol?</B> <I>((symbol GENERALIZED-SYMBOL)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>symbol</VAR> is shadowed in its home module.
</DL>
</P><P>

<A NAME="IDX749"></A>
<DL>
<DT><U>Function:</U> <B>shift-right</B> <I>((arg INTEGER) (count INTEGER)) : INTEGER</I>
<DD>Shift <VAR>arg</VAR> to the right by <VAR>count</VAR> positions and
0-extend from the left if <VAR>arg</VAR> is positive or 1-extend if it is
negative.  This is an arithmetic shift that preserve the sign of <VAR>arg</VAR>
and is equivalent to dividing <VAR>arg</VAR> by 2** <VAR>count</VAR>.
</DL>
</P><P>

<A NAME="IDX750"></A>
<DL>
<DT><U>Macro:</U> <B>signal</B> <I>((type SYMBOL) &#38;body (body CONS)) : OBJECT</I>
<DD>Signal error message, placing non-string arguments in quotes.
</DL>
</P><P>

<A NAME="IDX751"></A>
<DL>
<DT><U>Macro:</U> <B>signal-read-error</B> <I>(&#38;body (body CONS)) : OBJECT</I>
<DD>Specialized version of <CODE>signal</CODE> that throws a READ-EXCEPTION.
</DL>
</P><P>

<A NAME="IDX752"></A>
<DL>
<DT><U>Command:</U> <B>start-function-call-logging</B> <I>((fileName STRING)) :</I>
<DD>Start function call logging to <VAR>fileName</VAR>.
</DL>
</P><P>

<A NAME="IDX753"></A>
<DL>
<DT><U>Function:</U> <B>stella-collection?</B> <I>((self OBJECT)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>self</VAR> is a native collection.
</DL>
</P><P>

<A NAME="IDX754"></A>
<DL>
<DT><U>Function:</U> <B>stella-object?</B> <I>((self OBJECT)) : BOOLEAN</I>
<DD>Return true if <VAR>self</VAR> is a member of the STELLA class <CODE>OBJECT</CODE>.
</DL>
</P><P>

<A NAME="IDX755"></A>
<DL>
<DT><U>Function:</U> <B>stella-version-string</B> <I>() : STRING</I>
<DD>Return a string identifying the current version of STELLA.
</DL>
</P><P>

<A NAME="IDX756"></A>
<DL>
<DT><U>Function:</U> <B>stellafy</B> <I>((thing LISP-CODE) (targetType TYPE)) : OBJECT</I>
<DD>Partial inverse to <CODE>lispify</CODE>.  Convert the Lisp object 
<VAR>thing</VAR> into a Stella analogue of type <VAR>targetType</VAR>.
Note: See also <CODE>stellify</CODE>. it is similar, but guesses <VAR>targetType</VAR> on its own,
and makes somewhat different translations.
</DL>
</P><P>

<A NAME="IDX757"></A>
<DL>
<DT><U>Function:</U> <B>stellify</B> <I>((self OBJECT)) : OBJECT</I>
<DD>Convert a Lisp object into a STELLA object.
</DL>
</P><P>

<A NAME="IDX758"></A>
<DL>
<DT><U>Command:</U> <B>stop-function-call-logging</B> <I>() :</I>
<DD>Stop function call logging and close the current log file.
</DL>
</P><P>

<A NAME="IDX759"></A>
<DL>
<DT><U>Function:</U> <B>string-to-time-duration</B> <I>((duration STRING)) : TIME-DURATION</I>
<DD>Parses and returns an time-duration object corresponding to <VAR>duration</VAR>.
The syntax for time duration strings is "{plus|minus} N days[; M ms]" where N and M are
integer values for days and milliseconds.  If no valid parse is found, <CODE>null</CODE> is returned.
</DL>
</P><P>

<A NAME="IDX760"></A>
<DL>
<DT><U>Function:</U> <B>subclass-of?</B> <I>((subClass CLASS) (superClass CLASS)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if <VAR>subClass</VAR> is a subclass of <VAR>superClass</VAR>.
</DL>
</P><P>

<A NAME="IDX761"></A>
<DL>
<DT><U>Method:</U> <B>subsequence</B> <I>((string MUTABLE-STRING) (start INTEGER) (end INTEGER)) : STRING</I>
<DD>Return a substring of <VAR>string</VAR> beginning at position <VAR>start</VAR>
and ending up to but not including position <VAR>end</VAR>, counting from zero.  An
<VAR>end</VAR> value of NULL stands for the rest of the string.
</DL>
</P><P>

<A NAME="IDX762"></A>
<DL>
<DT><U>Method:</U> <B>substitute-characters</B> <I>((self STRING) (new-chars STRING) (old-chars STRING)) : STRING</I>
<DD>Substitute all occurences of of a member of <VAR>old-chars</VAR> with the 
corresponding member of <VAR>new-chars</VAR> in the string <VAR>self</VAR>.  Returns a new string.
</DL>
</P><P>

<A NAME="IDX763"></A>
<DL>
<DT><U>Method:</U> <B>substitute-characters</B> <I>((self MUTABLE-STRING) (new-chars STRING) (old-chars STRING)) : MUTABLE-STRING</I>
<DD>Substitute all occurences of of a member of <VAR>old-chars</VAR> with the 
corresponding member of <VAR>new-chars</VAR> in the string <VAR>self</VAR>.  IMPORTANT:  The return
value should be used instead of relying on destructive substitution, since the
substitution will not be destructive in all translated languages.
</DL>
</P><P>

<A NAME="IDX764"></A>
<DL>
<DT><U>Function:</U> <B>subtype-of?</B> <I>((sub-type TYPE) (super-type TYPE)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> iff the class named <VAR>sub-type</VAR> is a subclass 
of the class named <VAR>super-type</VAR>.
</DL>
</P><P>

<A NAME="IDX765"></A>
<DL>
<DT><U>Method:</U> <B>super-classes</B> <I>((self CLASS)) : (ITERATOR OF CLASS)</I>
<DD>Returns an iterator that generates all super classes
of <VAR>self</VAR>.  Non-reflexive.
</DL>
</P><P>

<A NAME="IDX766"></A>
<DL>
<DT><U>Method:</U> <B>sweep</B> <I>((self OBJECT)) :</I>
<DD>Default method.  Sweep up all <VAR>self</VAR>-type objects.
</DL>
</P><P>

<A NAME="IDX767"></A>
<DL>
<DT><U>Method:</U> <B>system-default-value</B> <I>((self STORAGE-SLOT)) : OBJECT</I>
<DD>Return a default value expression, or if <VAR>self</VAR>
has dynamic storage, an initial value expression.
</DL>
</P><P>

<A NAME="IDX768"></A>
<DL>
<DT><U>Method:</U> <B>system-default-value</B> <I>((self SLOT)) : OBJECT</I>
<DD>Return a default value expression, or if <VAR>self</VAR>
has dynamic storage, an initial value expression.
</DL>
</P><P>

<A NAME="IDX769"></A>
<DL>
<DT><U>Function:</U> <B>system-loaded?</B> <I>((name STRING)) : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if system <VAR>name</VAR> has been loaded.
</DL>
</P><P>

<A NAME="IDX770"></A>
<DL>
<DT><U>Function:</U> <B>terminate-program</B> <I>() :</I>
<DD>Terminate and exit the program with normal exit code.
</DL>
</P><P>

<A NAME="IDX771"></A>
<DL>
<DT><U>Function:</U> <B>time-duration-to-string</B> <I>((date TIME-DURATION)) : STRING</I>
<DD>Returns a string representation of <VAR>date</VAR>
</DL>
</P><P>

<A NAME="IDX772"></A>
<DL>
<DT><U>Function:</U> <B>toggle-output-language</B> <I>() : KEYWORD</I>
<DD>Switch between Common Lisp and C++ as output languages.
</DL>
</P><P>

<A NAME="IDX773"></A>
<DL>
<DT><U>Macro:</U> <B>trace-if</B> <I>((keyword OBJECT) &#38;body (body CONS)) : OBJECT</I>
<DD>If <VAR>keyword</VAR> is a trace keyword that has been enabled with <CODE>add-trace</CODE>
print all the elements in <VAR>body</VAR> to standard output.  Otherwise, do nothing.
<VAR>keyword</VAR> can also be a list of keywords in which case printing is done if
one or more of them are trace enabled.
</DL>
</P><P>

<A NAME="IDX774"></A>
<DL>
<DT><U>Function:</U> <B>translate-system</B> <I>((systemName STRING) (outputLanguage KEYWORD) &#38;rest (options OBJECT)) : BOOLEAN</I>
<DD>Translate all of the STELLA source files in system <VAR>systemName</VAR> into
<VAR>outputLanguage</VAR>.  The following keyword/value <VAR>options</VAR> are recognized:
</P><P>

<CODE>:two-pass?</CODE> (default false): if true, all files will be scanned twice, once
to load the signatures of objects defined in them, and once to actually
translate the definitions.
</P><P>

<CODE>:force-translation?</CODE> (default false): if true, files will be translated
whether or not their translations are up-to-date.
</P><P>

<CODE>:development-settings?</CODE> (default false): if true translation will favor
safe, readable and debuggable code over efficiency (according to the value
of <CODE>:development-settings</CODE> on the system definition).  If false, efficiency
will be favored instead (according to the value of <CODE>:production-settings</CODE>
on the system definition).
</P><P>

<CODE>:production-settings?</CODE> (default true): inverse to <CODE>:development-settings?</CODE>.
</DL>
</P><P>

<A NAME="IDX775"></A>
<DL>
<DT><U>Function:</U> <B>translate-to-common-lisp?</B> <I>() : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if current output language is Common-Lisp.
</DL>
</P><P>

<A NAME="IDX776"></A>
<DL>
<DT><U>Function:</U> <B>translate-to-cpp?</B> <I>() : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if current output language is C++
</DL>
</P><P>

<A NAME="IDX777"></A>
<DL>
<DT><U>Function:</U> <B>translate-to-java?</B> <I>() : BOOLEAN</I>
<DD>Return <CODE>true</CODE> if current output language is Java
</DL>
</P><P>

<A NAME="IDX778"></A>
<DL>
<DT><U>Function:</U> <B>try-to-evaluate</B> <I>((tree OBJECT)) : OBJECT</I>
<DD>Variant of <CODE>evaluate</CODE> that only evaluates <VAR>tree</VAR> if it
represents an evaluable expression.  If it does not, <VAR>tree</VAR> is returned
unmodified.  This can be used to implement commands with mixed argument
evaluation strategies.
</DL>
</P><P>

<A NAME="IDX779"></A>
<DL>
<DT><U>Function:</U> <B>two-argument-least-common-superclass</B> <I>((class1 CLASS) (class2 CLASS)) : CLASS</I>
<DD>Return the most specific class that is a superclass of
both <VAR>class1</VAR> and <VAR>class2</VAR>.  If there is more than one, arbitrarily pick one.
If there is none, return <CODE>null</CODE>.
</DL>
</P><P>

<A NAME="IDX780"></A>
<DL>
<DT><U>Function:</U> <B>two-argument-least-common-supertype</B> <I>((type1 TYPE-SPEC) (type2 TYPE-SPEC)) : TYPE-SPEC</I>
<DD>Return the most specific type that is a supertype of
both <VAR>type1</VAR> and <VAR>type2</VAR>.  If there is more than one, arbitrarily pick one.
If there is none, return @VOID.  If one or both types are parametric,
also try to generalize parameter types if necessary.
</DL>
</P><P>

<A NAME="IDX781"></A>
<DL>
<DT><U>Method:</U> <B>type</B> <I>((self SLOT)) : TYPE</I>
<DD>The type of a storage slot is its base type.
</DL>
</P><P>

<A NAME="IDX782"></A>
<DL>
<DT><U>Method:</U> <B>type-specifier</B> <I>((self SLOT)) : TYPE-SPEC</I>
<DD>If <VAR>self</VAR> has a complex type return its
type specifier, otherwise, return <CODE>type</CODE> of <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX783"></A>
<DL>
<DT><U>Function:</U> <B>type-to-symbol</B> <I>((type TYPE)) : SYMBOL</I>
<DD>Convert <VAR>type</VAR> into a symbol with the same name and module.
</DL>
</P><P>

<A NAME="IDX784"></A>
<DL>
<DT><U>Method:</U> <B>type-to-wrapped-type</B> <I>((self TYPE)) : TYPE</I>
<DD>Return the wrapped type for the type <VAR>self</VAR>,
or <VAR>self</VAR> if it is not a bare literal type.
</DL>
</P><P>

<A NAME="IDX785"></A>
<DL>
<DT><U>Function:</U> <B>unbound-surrogates</B> <I>((module MODULE) (local? BOOLEAN)) : (ITERATOR OF SURROGATE)</I>
<DD>Iterate over all unbound surrogates visible from <VAR>module</VAR>.
Look at all modules if <VAR>module</VAR> is <CODE>null</CODE>.  If <VAR>local?</VAR>, only consider
surrogates interned in <VAR>module</VAR>.
</DL>
</P><P>

<A NAME="IDX786"></A>
<DL>
<DT><U>Function:</U> <B>unescape-html-string</B> <I>((input STRING)) : STRING</I>
<DD>Replaces HTML escape sequences such as &#38;amp; with their
associated characters.
</DL>
</P><P>

<A NAME="IDX787"></A>
<DL>
<DT><U>Function:</U> <B>unescape-url-string</B> <I>((input STRING)) : STRING</I>
<DD>Takes a string and replaces %-format URL escape sequences with their real
character equivalent according to RFC 2396.
</DL>
</P><P>

<A NAME="IDX788"></A>
<DL>
<DT><U>Command:</U> <B>unset-stella-feature</B> <I>(&#38;rest (features KEYWORD)) :</I>
<DD>Disable all listed STELLA <VAR>features</VAR>.
</DL>
</P><P>

<A NAME="IDX789"></A>
<DL>
<DT><U>Function:</U> <B>unsigned-shift-right-by-1</B> <I>((arg INTEGER)) : INTEGER</I>
<DD>Shift <VAR>arg</VAR> to the right by 1 position and 0-extend
from the left.  This does not preserve the sign of <VAR>arg</VAR> and shifts
the sign-bit just like a regular bit.  In Common-Lisp we can't do that
directly and need to do some extra masking.
</DL>
</P><P>

<A NAME="IDX790"></A>
<DL>
<DT><U>Function:</U> <B>unstringify-stella-source</B> <I>((source STRING) (module MODULE)) : OBJECT</I>
<DD>Unstringify a STELLA <VAR>source</VAR> string relative to <VAR>module</VAR>,
or <CODE>*MODULE*</CODE> if no module is specified.  This function allocates transient
objects as opposed to <CODE>unstringify-in-module</CODE> or the regular <CODE>unstringify</CODE>.
</DL>
</P><P>

<A NAME="IDX791"></A>
<DL>
<DT><U>Function:</U> <B>unwrap-boolean</B> <I>((wrapper BOOLEAN-WRAPPER)) : BOOLEAN</I>
<DD>Unwrap <VAR>wrapper</VAR> and return its values as a regular BOOLEAN.
Map NULL onto FALSE.
</DL>
</P><P>

<A NAME="IDX792"></A>
<DL>
<DT><U>Function:</U> <B>unwrap-function-code</B> <I>((wrapper FUNCTION-CODE-WRAPPER)) : FUNCTION-CODE</I>
<DD>Unwrap <VAR>wrapper</VAR> and return the result.
Return NULL if <VAR>wrapper</VAR> is NULL.
</DL>
</P><P>

<A NAME="IDX793"></A>
<DL>
<DT><U>Function:</U> <B>unwrap-method-code</B> <I>((wrapper METHOD-CODE-WRAPPER)) : METHOD-CODE</I>
<DD>Unwrap <VAR>wrapper</VAR> and return the result.
Return NULL if <VAR>wrapper</VAR> is NULL.
</DL>
</P><P>

<A NAME="IDX794"></A>
<DL>
<DT><U>Method:</U> <B>value-setter</B> <I>((self ABSTRACT-DICTIONARY-ITERATOR) (value (LIKE (ANY-VALUE SELF)))) : (LIKE (ANY-VALUE SELF))</I>
<DD>Abstract method needed to allow application of this
method on abstract iterator classes that do not implement it.  By having
this here all <CODE>next?</CODE> methods of dictionary iterators MUST use the <CODE>slot-value</CODE>
paradigm to set the iterator value.
</DL>
</P><P>

<A NAME="IDX795"></A>
<DL>
<DT><U>Macro:</U> <B>warn</B> <I>(&#38;body (body CONS)) : OBJECT</I>
<DD>Signal warning message, placing non-string arguments in quotes.
</DL>
</P><P>

<A NAME="IDX796"></A>
<DL>
<DT><U>Macro:</U> <B>with-input-file</B> <I>((binding CONS) &#38;body (body CONS)) : OBJECT</I>
<DD>Sets up an unwind-protected form which opens a file for
input and closes it afterwards.  The stream for reading is bound to the
variable provided in the macro form.
Syntax is (WITH-INPUT-FILE (var filename) body+)
</DL>
</P><P>

<A NAME="IDX797"></A>
<DL>
<DT><U>Macro:</U> <B>with-network-stream</B> <I>((binding CONS) &#38;body (body CONS)) : OBJECT</I>
<DD>Sets up an unwind-protected form which opens a network
socket stream to a host and port for input and output and closes it afterwards.
Separate variables as provided in the call are bound to the input and output
streams. Syntax is (WITH-NETWORK-STREAM (varIn varOut hostname port) body+)
</DL>
</P><P>

<A NAME="IDX798"></A>
<DL>
<DT><U>Macro:</U> <B>with-output-file</B> <I>((binding CONS) &#38;body (body CONS)) : OBJECT</I>
<DD>Sets up an unwind-protected form which opens a file for
output and closes it afterwards.  The stream for writing is bound to the
variable provided in the macro form.
Syntax is (WITH-OUTPUT-FILE (var filename) body+)
</DL>
</P><P>

<A NAME="IDX799"></A>
<DL>
<DT><U>Macro:</U> <B>with-permanent-objects</B> <I>(&#38;body (body CONS)) : OBJECT</I>
<DD>Allocate <CODE>permanent</CODE> (as opposed to <CODE>transient</CODE>)
objects within the scope of this declaration.
</DL>
</P><P>

<A NAME="IDX800"></A>
<DL>
<DT><U>Macro:</U> <B>with-system-definition</B> <I>((systemnameexpression OBJECT) &#38;body (body CONS)) : OBJECT</I>
<DD>Set *currentSystemDefinition* to the system definition named <CODE>system</CODE>.
Set *currentSystemDefinitionSubdirectory* to match. Execute <VAR>body</VAR> within
that scope.
</DL>
</P><P>

<A NAME="IDX801"></A>
<DL>
<DT><U>Macro:</U> <B>with-transient-objects</B> <I>(&#38;body (body CONS)) : OBJECT</I>
<DD>Allocate <CODE>transient</CODE> (as opposed to <CODE>permanent</CODE>)
objects within the scope of this declaration.
CAUTION: The default assumption is the allocation of permanent objects.
The scope of <CODE>with-transient-objects</CODE> should be as small as possible, and
the user has to make sure that code that wasn't explicitly written to
account for transient objects will continue to work correctly.
</DL>
</P><P>

<A NAME="IDX802"></A>
<DL>
<DT><U>Function:</U> <B>wrap-boolean</B> <I>((value BOOLEAN)) : BOOLEAN-WRAPPER</I>
<DD>Return a literal object whose value is the BOOLEAN <VAR>value</VAR>.
</DL>
</P><P>

<A NAME="IDX803"></A>
<DL>
<DT><U>Function:</U> <B>wrap-function-code</B> <I>((value FUNCTION-CODE)) : FUNCTION-CODE-WRAPPER</I>
<DD>Return a literal object whose value is the FUNCTION-CODE <VAR>value</VAR>.
</DL>
</P><P>

<A NAME="IDX804"></A>
<DL>
<DT><U>Function:</U> <B>wrap-method-code</B> <I>((value METHOD-CODE)) : METHOD-CODE-WRAPPER</I>
<DD>Return a literal object whose value is the METHOD-CODE <VAR>value</VAR>.
</DL>
</P><P>

<A NAME="IDX805"></A>
<DL>
<DT><U>Function:</U> <B>wrapped-type-to-type</B> <I>((self TYPE)) : TYPE</I>
<DD>Return the unwrapped type for the wrapped type <VAR>self</VAR>,
or <VAR>self</VAR> if it is not a wrapped type.
</DL>
</P><P>

<A NAME="IDX806"></A>
<DL>
<DT><U>Function:</U> <B>wrapper-value-type</B> <I>((self WRAPPER)) : TYPE</I>
<DD>Return the type of the value stored in the wrapper <VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX807"></A>
<DL>
<DT><U>Function:</U> <B>write-html-escaping-url-special-characters</B> <I>((stream NATIVE-OUTPUT-STREAM) (input STRING)) :</I>
<DD>Writes a string and replaces unallowed URL characters according to RFC 2396
with %-format URL escape sequences.
</DL>
</P><P>

<A NAME="IDX808"></A>
<DL>
<DT><U>Method:</U> <B>writer</B> <I>((self STORAGE-SLOT)) : SYMBOL</I>
<DD>Name of a method called to write the value of the slot
<VAR>self</VAR>.
</DL>
</P><P>

<A NAME="IDX809"></A>
<DL>
<DT><U>Function:</U> <B>xml-token-list-to-s-expression</B> <I>((tokenList TOKENIZER-TOKEN)) : OBJECT</I>
<DD>Convert the XML <VAR>tokenList</VAR> into a representative s-expression
and return the result.  Every XML tag is represented as a cons-list starting
with the tag as its header, followed by a possibly empty list of keyword
value pairs representing tag attributes, followed by a possibly empty list of
content expressions which might themselves be XML expressions.  For example,
the expression
</P><P>

    &#60;a a1=v1 a2='v2'&#62; foo &#60;b a3=v3/&#62; bar &#60;/a&#62;
</P><P>

becomes
</P><P>

   (&#60;a&#62; (&#60;a1&#62; "v1" <a2> "v2") "foo" (&#60;b&#62; (&#60;a3&#62; "v3")) "bar")
</P><P>

when represented as an s-expression.  The tag names are subtypes of XML-OBJECT
such as XML-ELEMENT, XML-LOCAL-ATTRIBUTE, XML-GLOBAL-ATTRIBUTE, etc.
?, ! and [ prefixed tags are encoded as their own subtypes of XML-OBJECT, namely
XML-PROCESSING-INSTRUCTION, XML-DECLARATION, XML-SPECIAL, XML-COMMENT, etc.
CDATA is an XML-SPECIAL tag with a name of CDATA.
</P><P>

The name is available using class accessors.
</DL>
</P><P>

<A NAME="IDX810"></A>
<DL>
<DT><U>Function:</U> <B>yield-define-stella-class</B> <I>((class CLASS)) : CONS</I>
<DD>Return a cons tree that (when evaluated) constructs
a Stella class object.
</DL>
</P><P>

<A NAME="Function Index"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_6.html#SEC30"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Hans Chalupsky</I> on <I>October, 28  2003</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
