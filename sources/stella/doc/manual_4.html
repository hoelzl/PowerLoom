<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<!-- Created on May, 21  2006 by texi2html 1.65 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>STELLA Manual: Programming in STELLA</TITLE>

<META NAME="description" CONTENT="STELLA Manual: Programming in STELLA">
<META NAME="keywords" CONTENT="STELLA Manual: Programming in STELLA">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.65">

</HEAD>

<BODY LANG="en" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC21"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC20"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC22"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_3.html#SEC11"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_5.html#SEC29"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 4. Programming in STELLA </H1>
<!--docid::SEC21::-->
<P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_4.html#SEC22">4.1 Hello World in STELLA</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_4.html#SEC26">4.2 Incrementally Developing STELLA Code</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_4.html#SEC27">4.3 Performance Hints</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Hello World in STELLA"></A>
<HR SIZE="6">
<A NAME="SEC22"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC21"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC23"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC21"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC21"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC26"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 4.1 Hello World in STELLA </H2>
<!--docid::SEC22::-->
<P>

Included with the STELLA distribution is a simple Hello World
application that shows you how to organize your own STELLA code and
build a working STELLA application.  The sources for the Hello World
system consist of the following files:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>sources/systems/hello-world-system.ste
sources/hello-world/file-a.ste
sources/hello-world/file-b.ste
</pre></td></tr></table></P><P>

STELLA organizes code modules with a simple system facility.
Translation always operates on a complete system, so you always need to
create a system definition for the STELLA files comprising your
application (somewhat similar to what you would put in a Unix Makefile).
</P><P>

For the Hello World system the system definition already exists and
resides in the file `<TT>sources/systems/hello-world-system.ste</TT>'.  By
default, STELLA looks in the directory `<TT>sources/systems</TT>' to find
the definition of a particular system.  `<TT>hello-world-system.ste</TT>'
defines two things:
</P><P>

(1) The <CODE>HELLO-WORLD</CODE> module which defines a namespace for all
objects in the Hello World systems.  STELLA modules are mapped onto
corresponding native namespace constructs, i.e., Lisp packages, C++
namespaces or Java packages.  The exact mapping for each language can be
defined via the keyword options <CODE>:lisp-package</CODE>,
<CODE>:cpp-package</CODE> and <CODE>:java-package</CODE> in the module definition,
for example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defmodule "HELLO-WORLD"
  :lisp-package "STELLA"
  :cpp-package "hello_world"
  :java-package "edu.isi.hello_world"
  :uses ("STELLA"))
</pre></td></tr></table></P><P>

The <CODE>:uses</CODE> directive tells STELLA from what other modules this one
inherits.
</P><P>

(2) The actual system definitions defining what source files comprise
the system, and what parent systems this one depends on, plus a variety
of other options:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defsystem HELLO-WORLD
  :directory "hello-world"
  :required-systems ("stella")
  :cardinal-module "HELLO-WORLD"
  :production-settings (1 0 3 3)
  :development-settings (3 2 3 3)
  :files ("file-a"
          "file-b"))
</pre></td></tr></table></P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_4.html#SEC23">4.1.1 Hello World in Lisp</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_4.html#SEC24">4.1.2 Hello World in C++</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_4.html#SEC25">4.1.3 Hello World in Java</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Hello World in Lisp"></A>
<HR SIZE="6">
<A NAME="SEC23"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC22"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC24"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC21"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC22"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC26"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 4.1.1 Hello World in Lisp </H3>
<!--docid::SEC23::-->
<P>

To generate a Lisp translation of Hello World you can use either the
Lisp, C++ or Java version of STELLA.  Before you can translate you have
to make sure the following native directories exist:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>native/lisp/hello-world/
bin/acl7.0/hello-world/
</pre></td></tr></table></P><P>

The directory `<TT>native/lisp/hello-world/</TT>' will hold the Lisp
translations of the corresponding STELLA source files.  The directory
`<TT>bin/acl7.0/hello-world/</TT>' will hold the compiled Lisp files if you
are using Allegro CL 7.0.  If you are using a different Lisp, one of the
other binary directories as defined in the top-level file
`<TT>translations.lisp</TT>' will be used.  The directory
`<TT>bin/lisp/hello-world/</TT>' will be used as a fall-back if your version
of Lisp is not yet handled in `<TT>translations.lisp</TT>'.
</P><P>

If you create your own system, you will need to create those directories
by hand (future versions of STELLA might do that automatically).  For
the Hello World system these directories already exist.
</P><P>

To generate a Lisp translation of Hello World using Lisp startup a Lisp
version of STELLA (see <A HREF="manual_2.html#SEC6">2.3 Lisp Installation</A>).  The following idiom
will then translate the system into Lisp and also Lisp-compile and load it.
The first argument to <CODE>make-system</CODE> is the name of the system, and
the second argument indicates into what language it should be
translated:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>STELLA(3): (make-system "hello-world" :common-lisp)
Processing `/tmp/stella-3.1.0/sources/hello-world/file-a.ste':
*** Pass 1, generating objects...
Processing `/tmp/stella-3.1.0/sources/hello-world/file-b.ste':
*** Pass 1, generating objects...
   .........................................
;;; Writing fasl file
;;;   /tmp/stella-3.1.0/native/lisp/bin/acl7.0/hello-world/startup-system.fasl
;;; Fasl write complete
; Fast loading
;    /tmp/stella-3.1.0/native/lisp/bin/acl7.0/hello-world/startup-system.fasl
CL:T
STELLA(4): 
</pre></td></tr></table></P><P>

After the system is loaded you can call its <CODE>main</CODE> function:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>STELLA(10): (main)
Hello World A
Hello World B
bye
()
STELLA(11): 
</pre></td></tr></table></P><P>

Using <CODE>main</CODE> in the Lisp version will not always make sense, since
you can call any function directly at the Lisp top level, but both C++
and Java always need a <CODE>main</CODE> function as a top-level entry point.
</P><P>

While this would be somewhat unusual, you could also generate the Lisp
translation using the C++ or Java version of STELLA.  The easiest way to
do that is to run the <CODE>stella</CODE> script in the STELLA directory like
this:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>% ./stella -e '(make-system "hello-world" :common-lisp)'
Running C++ version of STELLA...
Welcome to STELLA 3.4.0
Processing `sources/hello-world/file-a.ste':
*** Pass 1, generating objects...
Processing `sources/hello-world/file-b.ste':
*** Pass 1, generating objects...
  ...............................................
Translating `sources/hello-world/file-a.ste' to `Common Lisp'...
Writing `native/lisp/hello-world/file-a.lisp'...
Translating `sources/hello-world/startup-system.ste' to `Common Lisp'...
Writing `native/lisp/hello-world/startup-system.lisp'...
</pre></td></tr></table></P><P>

The <CODE>-e</CODE> command line option is used to evaluate an evaluable
STELLA command.  Conveniently, <CODE>make-system</CODE> is such a command, so
you can supply a <CODE>make-system</CODE> form to the C++ or Java version of
STELLA just as you would do in Lisp.  Note the extra quotes around the
expression to protect the characters from interpretation by the Unix
shell.
</P><P>

To compile and load the translated Lisp files into Lisp you then have to
startup a Lisp version of STELLA and call <CODE>make-system</CODE> again which
now will only compile and load the necessary files, since the
translations have already been generated in the previous step.
</P><P>

<A NAME="Hello World in C++"></A>
<HR SIZE="6">
<A NAME="SEC24"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC23"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC25"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC21"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC22"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC26"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 4.1.2 Hello World in C++ </H3>
<!--docid::SEC24::-->
<P>

To generate a C++ translation of Hello World you can use either the
Lisp, C++ or Java version of STELLA.  Before you can translate you have
to make sure the following native directory exists:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>native/cpp/hello-world/
</pre></td></tr></table></P><P>

The directory `<TT>native/cpp/hello-world/</TT>' will hold the C++
translations of the corresponding STELLA source files.  If you create
your own system, you will need to create this directory by hand (future
versions of STELLA might do that automatically).  For the Hello World
system the directory already exist.
</P><P>

To generate a C++ translation of Hello World using Lisp startup a Lisp
version of STELLA (see <A HREF="manual_2.html#SEC6">2.3 Lisp Installation</A>).  The following idiom
will then translate the system into C++.  The first argument to
<CODE>make-system</CODE> is the name of the system, and the second argument
indicates into what language it should be translated:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>STELLA(4): (make-system "hello-world" :cpp)
Processing `/tmp/stella-3.1.0/sources/hello-world/file-a.ste':
*** Pass 1, generating objects...
Processing `/tmp/stella-3.1.0/sources/hello-world/file-b.ste':
*** Pass 1, generating objects...
  ...............................................
Writing `/tmp/stella-3.1.0/native/cpp/hello-world/file-b.hh'...
Writing `/tmp/stella-3.1.0/native/cpp/hello-world/file-b.cc'...
Translating `/tmp/stella-3.1.0/sources/hello-world/startup-system.ste'.
Writing `/tmp/stella-3.1.0/native/cpp/hello-world/startup-system.hh'...
Writing `/tmp/stella-3.1.0/native/cpp/hello-world/startup-system.cc'...
:VOID
STELLA(5): 
</pre></td></tr></table></P><P>

Alternatively, you can generate the translation using the C++ or Java
version of STELLA.  The easiest way to do that is to run the
<CODE>stella</CODE> script in the STELLA directory like this:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>% ./stella -e '(make-system "hello-world" :cpp)'
Running C++ version of STELLA...
Welcome to STELLA 3.4.0
Processing `sources/hello-world/file-a.ste':
*** Pass 1, generating objects...
Processing `sources/hello-world/file-b.ste':
*** Pass 1, generating objects...
  ...............................................
Writing `native/cpp/hello-world/file-b.hh'...
Writing `native/cpp/hello-world/file-b.cc'...
Translating `sources/hello-world/startup-system.ste'.
Writing `native/cpp/hello-world/startup-system.hh'...
Writing `native/cpp/hello-world/startup-system.cc'...
</pre></td></tr></table></P><P>

The <CODE>-e</CODE> command line option is used to evaluate an evaluable
STELLA command.  Conveniently, <CODE>make-system</CODE> is such a command, so
you can supply a <CODE>make-system</CODE> form to the C++ or Java version of
STELLA just as you would do in Lisp.  Note the extra quotes around the
expression to protect the characters from interpretation by the Unix
shell.
</P><P>

Different from Lisp, neither of the above idioms will compile and load
the generated C++ code.  Instead you have to use the Unix `<TT>make</TT>'
facility to compile and link the C++ sources.  First change into the
native `<TT>hello-world</TT>' directory and then call <CODE>make</CODE>
(<STRONG>important</STRONG>: the generated Makefiles currently require the GNU
version of <CODE>make</CODE>):
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>% cd native/cpp/hello-world/
% make
g++ -w -g -O2  -DSTELLA_USE_GC -I../stella/cpp-lib/gc/include \ 
    -c -I.. main.cc
g++ -w -g -O2  -DSTELLA_USE_GC -I../stella/cpp-lib/gc/include \ 
    -c -I.. file-a.cc
g++ -w -g -O2  -DSTELLA_USE_GC -I../stella/cpp-lib/gc/include \ 
    -c -I.. file-b.cc
g++ -w -g -O2  -DSTELLA_USE_GC -I../stella/cpp-lib/gc/include \ 
    -c -I.. startup-system.cc
  ..................................
g++ -dynamic  -L../stella/cpp-lib/gc -Xlinker -rpath -Xlinker \
       '../lib:/tmp/stella-3.1.0/native/cpp/lib' \
       main.o -o hello-world \
       -L../lib -lhello-world -L../lib -lstella -lgc -lm
</pre></td></tr></table></P><P>

The first time around this will also compile the C++ version of STELLA
and the C++ garbage collector and create a STELLA library file.  Future
builds of the Hello World and other systems will use the STELLA library
file directly.  To run the Hello World system simply run the
`<TT>hello-world</TT>' executable that was built in the previous step:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>% ./hello-world
Hello World A
Hello World B
bye
</pre></td></tr></table></P><P>

<A NAME="Hello World in Java"></A>
<HR SIZE="6">
<A NAME="SEC25"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC24"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC26"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC21"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC22"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC26"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 4.1.3 Hello World in Java </H3>
<!--docid::SEC25::-->
<P>

To generate a Java translation of Hello World you can use either the
Lisp, C++ or Java version of STELLA.  Before you can translate you have
to make sure the following native directory exists:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>native/java/edu/isi/hello-world/
</pre></td></tr></table></P><P>

The directory `<TT>native/java/edu/isi/hello-world/</TT>' will hold the Java
translations of the corresponding STELLA source files.  If you create
your own system, you will need to create this directory by hand (future
versions of STELLA might do that automatically).  For the Hello World
system the directory already exist.
</P><P>

Note that following Java convention we use the package
<CODE>edu.isi.hello_world</CODE> to hold the Hello World system.  This was
specified via the <CODE>:java-package</CODE> option in the definition of the
<CODE>HELLO-WORLD</CODE> module.  Also note that we use <CODE>hello_world</CODE>
instead of <CODE>hello-world</CODE> as the package name, since a dash cannot
legally appear as part of a Java identifier.
</P><P>

To generate a Java translation of Hello World using Lisp startup a Lisp
version of STELLA (see <A HREF="manual_2.html#SEC6">2.3 Lisp Installation</A>).  The following idiom
will then translate the system into Java.  The first argument to
<CODE>make-system</CODE> is the name of the system, and the second argument
indicates into what language it should be translated:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>STELLA(5): (make-system "hello-world" :java)
Processing `/tmp/stella-3.1.0/sources/hello-world/file-a.ste':
*** Pass 1, generating objects...
   ..............................................
Writing `/tmp/stella-3.1.0/native/java/hello_world/Startup_Hello_...
:VOID
STELLA(6): 
</pre></td></tr></table></P><P>

Alternatively, you can generate the translation using the C++ or Java
version of STELLA.  The easiest way to do that is to run the
<CODE>stella</CODE> script in the STELLA directory like this:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>% ./stella -e '(make-system "hello-world" :java)'
Running C++ version of STELLA...
Welcome to STELLA 3.4.0
Processing `sources/hello-world/file-a.ste':
*** Pass 1, generating objects...
Processing `sources/hello-world/file-b.ste':
*** Pass 1, generating objects...
  ...............................................
Writing `native/java/edu/isi/hello_world/HelloWorld.java'...
Writing `native/java/edu/isi/hello_world/StartupFileA.java'...
Writing `native/java/edu/isi/hello_world/StartupFileB.java'...
Writing `native/java/edu/isi/hello_world/StartupHelloWorldSystem.java'...
</pre></td></tr></table></P><P>

The <CODE>-e</CODE> command line option is used to evaluate an evaluable
STELLA command.  Conveniently, <CODE>make-system</CODE> is such a command, so
you can supply a <CODE>make-system</CODE> form to the C++ or Java version of
STELLA just as you would do in Lisp.  Note the extra quotes around the
expression to protect the characters from interpretation by the Unix
shell.
</P><P>

Different from Lisp, neither of the above idioms will compile and load
the generated C++ code.  Instead you have to use the Java compiler to
compile and Java to run the compiled Java sources.  First change into
the top-level native Java directory `<TT>native/java</TT>' and then compile
and run the Hello World system like this:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>% cd native/java/
% javac edu/isi/hello_world/*.java
% java edu.isi.hello_world.HelloWorld
Hello World A
Hello World B
bye
</pre></td></tr></table></P><P>

It is not necessary to Java-compile STELLA first, since STELLA already
ships with a Java compilation of the STELLA system.
</P><P>

<A NAME="Incrementally Developing STELLA Code"></A>
<HR SIZE="6">
<A NAME="SEC26"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC25"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC27"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC22"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC21"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_5.html#SEC29"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 4.2 Incrementally Developing STELLA Code </H2>
<!--docid::SEC26::-->
<P>

The preferred method of STELLA code development is to use a Lisp-based
version of STELLA for all the prototyping and testing, since that allows
you to exploit most (or all) of the rapid-prototyping advantages of
Lisp.  Once a system has reached a certain point of stability, it can be
translated into C++ or Java for delivery or to interface it with other
C++ or Java code.
</P><P>

In the following, we assume an X/Emacs-based Lisp development
environment such as the Allegro CL Emacs interface, where Lisp is run in
an Emacs subprocess, and Lisp source can be compiled and evaluated
directly from the source buffers.  By "Lisp buffer" we mean the listener
buffer in which Lisp is actually running, and by "source buffer" we mean
a buffer that is used to edit a file that contains STELLA source.
</P><P>

Included in the distribution is the Hello World system comprised of the
files
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>sources/systems/hello-world-system.ste
sources/hello-world/file-a.ste
sources/hello-world/file-b.ste
</pre></td></tr></table></P><P>

To get started, simply add your code to either `<TT>file-a.ste</TT>' or
`<TT>file-b.ste</TT>', since all the necessary definitions and directories
for these files are already set up properly.  See section ??? on how to
setup your own system.
</P><P>

Make sure the Hello World system is loaded into Lisp by doing the
following:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(make-system "hello-world" :common-lisp)
</pre></td></tr></table></P><P>

This will make sure that the system definition is loaded and the
necessary module definition is evaluated.
</P><P>

Now suppose you add the following function to `<TT>file-a.ste</TT>':
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(defun (factorial INTEGER) ((n INTEGER))
  (if (eql? n 0)
      (return 1)
    (return (* n (factorial (1- n))))))
</pre></td></tr></table></P><P>

There are various options for translating and evaluating this
definition.  For example, you can simply remake the complete system
similar to what you would do for a C++ or Java program:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(make-system "hello-world" :common-lisp)
</pre></td></tr></table></P><P>

This will retranslate the modified files, recompile them and reload them
into your Lisp image.
</P><P>

Instead of retranslating and recompiling everything, you can
incrementally evaluate the definition of <CODE>factorial</CODE> from your
Emacs-to-Lisp interface.  Simply put your cursor somewhere inside the
definition in the source buffer and evaluate it by typing <KBD>M-C-x</KBD>.
This translates the STELLA code into Lisp and compiles (or evaluates)
the resulting Lisp code.  Now you can actually try it out in the Lisp
buffer, for example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>STELLA(4): (factorial 6)
720
</pre></td></tr></table></P><P>

Finally, instead of evaluating the definition in the source buffer, you
can also enter it directly at the Lisp prompt with the same effect.  
</P><P>

The way this works is that the Lisp symbol <CODE>stella::defun</CODE> is
actually bound to a Lisp macro that calls all the necessary translation
machinery to convert the STELLA <CODE>defun</CODE> into Lisp code.  Look at
the file `<TT>sources/stella/cl-lib/stella-to-cl.ste</TT>' for the complete
set of such macros.  This might be a bit confusing, since there are now
three different bindings (or meanings) of <CODE>defun</CODE>:
</P><P>

<OL>
<LI>
The STELLA operator <CODE>defun</CODE> used to define STELLA functions.
<P>

<LI>
The Lisp macro <CODE>stella::defun</CODE> that resides in the <CODE>STELLA</CODE>
Lisp package and is only available for convenience in Lisp versions of
STELLA.
<P>

<LI>
The Lisp macro <CODE>CL:defun</CODE> which is the standard Common Lisp macro
used to define Lisp functions.
</OL>
<P>

We'll try to explicitly qualify which meaning is used wherever there
might be some doubt which one is meant.  In general, every unqualified
symbol mentioned below is either part of the STELLA language or resides
in the STELLA Lisp package.
</P><P>

Since a newly-written STELLA function might have errors, it is prudent
to first only translate it without actually executing the result of the
translation.  In the source buffer you can do that by macro-expanding
the <CODE>defun</CODE>.  For example, if you use the Allegro CL interface you
would position the cursor on the opening parenthesis of the <CODE>defun</CODE>
and then type <KBD>M-M</KBD>.  Any errors discovered by the STELLA translator
are reported in the Lisp buffer window.  The expansion will be a
<CODE>CL:progn</CODE> that contains the translated definition as the first
element plus various startup-time (initialization) code following it.
</P><P>

In the Lisp buffer you can achieve a similar effect with the
<CODE>lptrans</CODE> macro.  For example, executing
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(lptrans
 (defun (factorial INTEGER) ((n INTEGER))
   (if (eql? n 0)
       (return 1)
     (return (* n (factorial (1- n)))))))
</pre></td></tr></table></P><P>

in the Lisp buffer first Lisp-translates the definition, and then prints
the translation.  To see the C++ translation you can use
<CODE>cpptrans</CODE>, calling <CODE>jptrans</CODE> will generate the Java
translation.
</P><P>

You can also use <CODE>lptrans</CODE>/<CODE>cpptrans</CODE>/<CODE>jptrans</CODE> to
translate code fragments that are not top-level definitions such as
<CODE>defun</CODE> and its friends.  For example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>STELLA(8): (lptrans
            (foreach element in (list 1 2 3)
                do (print element EOL)))

(CL:LET* ((ELEMENT NULL)
          (ITER-003
           (%THE-CONS-LIST (LIST (WRAP-INTEGER 1) (WRAP-INTEGER 2)
                                 (WRAP-INTEGER 3)))))
  (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
           (CL:PROGN (SETQ ELEMENT (%%VALUE ITER-003))
                     (SETQ ITER-003 (%%REST ITER-003)))
           (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) 
                           ELEMENT EOL)))
()
STELLA(9): (cpptrans
            (foreach element in (list 1 2 3)
                do (print element EOL)))
{ Object* element = NULL;
  Cons* iter004 = list(3, wrapInteger(1), wrapInteger(2),
                          wrapInteger(3))-&#62; theConsList;

  while (!(iter004 == NIL)) {
    element = iter004-&#62;value;
    iter004 = iter004-&#62;rest;
    cout &#60;&#60; element &#60;&#60; endl;
  }
}
:VOID
STELLA(10): (jptrans
             (foreach element in (list 1 2 3)
                 do (print element EOL)))
{ Stella_Object element = null;
  Cons iter005 = Stella.list
                  (Stella_Object.cons
                    (IntegerWrapper.wrapInteger(1), 
                     Stella_Object.cons
                      (IntegerWrapper.wrapInteger(2), 
                       Stella_Object.cons
                        (IntegerWrapper.wrapInteger(3), 
                         Stella.NIL)))).theConsList;

  while (!(iter005 == Stella.NIL)) {
    {
      element = iter005.value;
      iter005 = iter005.rest;
    }
    java.lang.System.out.println(element);
  }
}
:VOID
</pre></td></tr></table></P><P>

The use of <CODE>lptrans</CODE> is really necessary here, since there is no
Lisp macro <CODE>foreach</CODE> that knows how to translate STELLA
<CODE>foreach</CODE> loops (those Lisp macros only exist for top-level
definition commands such as <CODE>defun</CODE>).  In order to translate such
code fragments without error messages, they need to be self-contained,
i.e., all referenced variables have to be either bound by a surrounding
<CODE>let</CODE>, or they must be globally defined variables.  Otherwise, the
STELLA translator will generate various "undefined variable" error
messages.
</P><P>

You can use the STELLA Lisp macro <CODE>eval</CODE> (i.e., <CODE>stella::eval</CODE>
not <CODE>CL:eval</CODE>) to actually execute such a code fragment.  For
example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>STELLA(11): (eval
             (foreach element in (list 1 2 3)
                 do (print element EOL)))
|L|1
|L|2
|L|3
()
</pre></td></tr></table></P><P>

This translates the loop and executes the result, which prints the
wrapped numbers (hence, the <CODE>|L|</CODE> prefix) to standard output.  The
<CODE>()</CODE> at the end is the resulting Lisp value returned by the loop
(in Lisp everything returns a value, even though for STELLA
<CODE>foreach</CODE> is a statement, not an expression).
</P><P>

Make it a habit to wrap <CODE>eval</CODE> around any STELLA code you
incrementally evaluate in the Lips buffer.  This makes sure that all the
arguments to a function, etc., are translated into the appropriate
STELLA objects.  For example, evaluating
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(eval (list :a :b :c))
</pre></td></tr></table></P><P>

in the Lisp buffer generates a STELLA list that points to the STELLA
keywords <CODE>:a</CODE>, <CODE>:b</CODE> and <CODE>:c</CODE>.  If you don't use
<CODE>eval</CODE>, for example,
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(list :a :b :c)
</pre></td></tr></table></P><P>

a STELLA list containing the Lisp keywords `:a', `:b' and `:c' will be
created.  Lisp keywords are a completely different data structure than
STELLA keywords, and any STELLA code expecting a STELLA keyword but
finding a Lisp keyword will break, since Lisp keywords are not a legal
STELLA data structure.  Unfortunately, such cases can be very confusing,
since Lisp and STELLA keywords look/print exactly alike.
</P><P>

<CODE>eval</CODE> is also necessary to access STELLA symbols and surrogates in
the Lisp buffer.  For example, to access a STELLA symbol, you can use
<CODE>quote</CODE> (again, this is the STELLA <CODE>quote</CODE> not
<CODE>CL:quote</CODE>):
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(eval (quote foo))
</pre></td></tr></table></P><P>

This returns the STELLA symbol <CODE>foo</CODE>.  We explicitly used
<CODE>quote</CODE> here, since code typed at the Lisp prompt is first passed
through the Lisp reader before the STELLA translator sees it, and the
default Lisp reader interprets the <CODE>'</CODE> character differently than
the STELLA reader.  Within a STELLA file you can use the syntax
<CODE>'foo</CODE>, since it will be read directly by the STELLA reader that
knows how to interpret it correctly.
</P><P>

<CODE>lptrans</CODE>, <CODE>cpptrans</CODE> and <CODE>jptrans</CODE> are evaluable STELLA
commands that can also be evaluated by the C++ and Java version of
STELLA.  For example, to generate a Java translation of a little STELLA
code fragment you could run the <CODE>stella</CODE> script in the STELLA
directory like this (the output below has been additionally indented by
hand for clarity):
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>% ./stella -e '(jptrans\
                 (foreach element in (list 1 2 3)\
                    do (print element EOL)))'
Running C++ version of STELLA...
Welcome to STELLA 3.4.0
{ Stella_Object element = null;
  Cons iter001 = Stella.list
                  (Stella_Object.cons
                    (IntegerWrapper.wrapInteger(1), 
                     Stella_Object.cons
                      (IntegerWrapper.wrapInteger(2), 
                       Stella_Object.cons
                        (IntegerWrapper.wrapInteger(3), 
                         Stella.NIL)))).theConsList;

  while (!(iter001 == Stella.NIL)) {
    {
      element = iter001.value;
      iter001 = iter001.rest;
    }
    java.lang.System.out.println(element);
  }
}
</pre></td></tr></table></P><P>

<A NAME="Performance Hints"></A>
<HR SIZE="6">
<A NAME="SEC27"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC26"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC28"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC21"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC21"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_5.html#SEC29"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 4.3 Performance Hints </H2>
<!--docid::SEC27::-->
<P>

Here are a few things to watch out for once you get serious about the
performance of your translated STELLA programs:
</P><P>

<STRONG>Safety checks:</STRONG> The STELLA variable <CODE>*safety*</CODE> controls
whether certain safety code is added to your translated STELLA program.
For Lisp translations it also controls whether <CODE>cast</CODE>'s will be
translated into run-time type checks or not.  There is no run-time type
checking performed in C++.  In Java native casts will always perform
runtime type tests.  The default <CODE>*safety*</CODE> level is 3 which
enables the translation of all <CODE>safety</CODE> clauses with level 3 or
lower.  A safety level of 1 or lower disables the generation of calls to
the <CODE>cast</CODE> function in Lisp.  <CODE>cast</CODE> performs run-time type
checks which are somewhat expensive.  However, you should not disable
run-time type checking in Lisp until you have fully debugged your
program.  Once you are confident that your program works correctly, you
can set <CODE>*safety*</CODE> to 0 before you translate it.  That way you will
avoid the generation and execution of any safety code at all.  All of
the core STELLA system was translated with <CODE>*safety*</CODE> set to 1.
</P><P>

<STRONG>Quoted cons trees:</STRONG> Access to quoted constants that are not
symbols is somewhat slow, since it currently uses hashing to find them
in a table.  Hence, access to quoted constants such as <CODE>(quote (foo
bar fum))</CODE> should be avoided in inner loops.  Access to quoted symbols
such as <CODE>(quote foo)</CODE> is fast and does not cause any performance
problems.  The use of <CODE>quote</CODE> for constant cons trees is rare in
STELLA (and somewhat deprecated), which is the reason why this mechanism
is not all that well supported.  Future versions of STELLA might
re-implement the handling of constants and alleviate this performance
problem.
</P><P>

<STRONG>Equality tests:</STRONG> The standard equality test in STELLA is
<CODE>eql?</CODE>, which the translator will translate into the most efficient
equality test for the particular types of operands (<CODE>eql?</CODE> is
somewhat similar to the Lisp function <CODE>CL:eql</CODE> with the exception
of comparing strings).  If the translator can determine that at least
one of the operands is a subtype of <CODE>STANDARD-OBJECT</CODE>, it will
translate the test into a fast pointer comparison with the Lisp function
<CODE>CL:eq</CODE> or the C++/Java <CODE>==</CODE> operator.  However, if both
operands are of type <CODE>OBJECT</CODE>, they might be wrapped literals such
as wrapped integers or strings.  In that case the equality test
translates into a call to the function <CODE>eql?</CODE> which in turn uses
method calls to handle comparison of different types of wrapped literals
(two wrapped literals are equal if their wrapped content is equal).
This is of course a lot less efficient than a simple pointer comparison.
It also means that if you can restrict the type of a variable that will
be tested with <CODE>eql?</CODE> to <CODE>STANDARD-OBJECT</CODE>, you probably
should do so for performance reasons.
</P><P>

<STRONG>Type tests:</STRONG> Run-time type tests as used implicitly within a
<CODE>typecase</CODE> or explicitly with functions such as <CODE>cons?</CODE> have
to use a call to the method <CODE>primary-type</CODE>.  Hence, in
performance-critical portions of your code you should try to keep the
number of such tests as small as possible.
</P><P>

<STRONG>Wrapping and unwrapping literals:</STRONG> The STELLA translator
automatically wraps (or objectifies) literals such as numbers or strings
when they are stored in a variable or slot of type <CODE>OBJECT</CODE>.
Similarly, it unwraps wrapped literals automatically to operate on the
literal directly.  This is very convenient, since it relieves the
programmer from having to perform these conversions by hand and makes
the code less cluttered.  For example, consider the following code
fragment:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(let ((l (cons "foo" nil))
      (x (concatenate "bar" (first l))))
  (print x EOL)))
</pre></td></tr></table>Here is its C++ translation:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>{ Cons* l = cons(wrapString("foo"), NIL);
   char* x = stringConcatenate
              ("bar", ((StringWrapper*)(l-&#62;value))-&#62;wrapperValue, 0);

  std::cout &#60;&#60; x &#60;&#60; std::endl;
}
</pre></td></tr></table></P><P>

Notice how the string literal <CODE>"foo"</CODE> is first wrapped so it can be
inserted into the <CODE>CONS</CODE> list <CODE>l</CODE> and then automatically
unwrapped in the call to <CODE>concatenate</CODE>.  While this is very
convenient, it does cause a certain overhead that should be avoided in
performance critical loops, etc.  In such situations, it often helps to
use auxiliary variables of the appropriate literal type to avoid
unnecessary wrap/unwrap operations.
</P><P>

<STRONG>Lisp-style property lists:</STRONG> Lisp programs often use property
lists for fast retrieval of information that is linked to symbols.  To
support the easy translation of existing Lisp programs that use this
paradigm into STELLA, a similar mechanism implemented by the functions
<CODE>symbol-value</CODE>, <CODE>symbol-plist</CODE>, and <CODE>symbol-property</CODE> is
available that preserves the performance benefits of this storage scheme
(see the file <CODE>sources/stella/symbols.ste</CODE>).  However, property
lists do not fit the object-oriented programming paradigm supported by
STELLA, and, hence, are frowned upon.
</P><P>

<STRONG>Compiler optimization:</STRONG> The optimization settings used with the
native Lisp or C++ compiler can greatly influence performance results.
In particular, using high optimization settings with the Lisp compiler
can greatly improve slot access time on STELLA objects.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="manual_4.html#SEC28">4.3.1 Lisp Performance Hints</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Lisp Performance Hints"></A>
<HR SIZE="6">
<A NAME="SEC28"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC27"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_5.html#SEC29"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC26"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC27"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_5.html#SEC29"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 4.3.1 Lisp Performance Hints </H3>
<!--docid::SEC28::-->
<P>

The standard Lisp implementation for STELLA objects are CLOS objects,
since CLOS provides the most natural Lisp implementation for the STELLA
object system.  However, there is a price to pay, since in Lisp slot
access on CLOS objects is a lot slower than slot access on structs.  For
example, in Allegro CL 4.3, the access to the <CODE>value</CODE> slot of a
STELLA CONS cell takes about 4 times longer on a CLOS object
implementation of <CODE>CONS</CODE> than on a struct implementation.
Unfortunately, the struct implementation itself takes about 3 times
longer than calling <CODE>CL:car</CODE> on a Lisp cons, which is why we are
actually using Lisp conses as the Lisp implementation for STELLA
<CODE>CONS</CODE>es.  Note, that in the C++ and Java translation these
slot-access performance problems are nonexistent.
</P><P>

In order to get the maximum performance out of the Lisp version of
STELLA, you can tell the translator to use structs as the implementation
for STELLA objects.  It does so by using <CODE>CL:defstruct</CODE> instead of
<CODE>CL:defclass</CODE> and dispatches methods directly on the structure
object.
</P><P>

To use the struct translation scheme evaluate
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(set-stella-feature :use-common-lisp-structs)
</pre></td></tr></table></P><P>

before you translate a STELLA system.  This will generate translated
files with a <CODE>.slisp</CODE> extension.  Make sure that after you
translated all the files you are interested in, you disable the above
feature with
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(unset-stella-feature :use-common-lisp-structs)
</pre></td></tr></table></P><P>

Otherwise, subsequent incremental translations in that Lisp image might
fail, since different translation schemes cannot be mixed.  If you
already are using the struct version of STELLA, all systems will be
translated in struct mode by default.
</P><P>

To use the struct translation of your system you have to use the struct
version of STELLA.  To do so do the following:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(CL:setq cl-user::*load-cl-struct-stella?* CL:t)
(CL:load "load-stella.lisp")
</pre></td></tr></table></P><P>

Alternatively, you can edit the initial value of the variable
<CODE>*load-cl-struct-stella?*</CODE> in the file `<TT>load-stella.lisp</TT>'
(see also <A HREF="manual_2.html#SEC6">2.3 Lisp Installation</A>).
</P><P>

The reasons why the struct translation scheme is not enabled by
default are the following:
</P><P>

<UL>
<LI>
Incremental redefinition of STELLA classes does not redefine any objects
created with the old definition, and, hence, slot accessors might simply
break or retrieve the value of a different slot when applied to such an
old object.  The programmer therefore has to be very careful when
redefining a STELLA class while in struct mode.  This means, that you
should view the usage of the struct-translation scheme for Lisp as a kind
of delivery option, similar to translating into C++.  Part of the reason
why slot access on CLOS object is expensive is the indirection machinery
that allows redefinition of classes and their associated instances.
This is great for code development, but the flexibility and expense is
usually not needed or warranted for delivered code.
<P>

<LI>
The performance trade-offs between CLOS and struct versions might be
different in different versions of Lisp.  For example, in older version
of Allegro CL slot access on structs was fast, but method dispatch was
significantly slower than for CLOS objects which eliminated some/all of
the performance gains.
</UL>
<P>

<A NAME="Library Classes"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_4.html#SEC26"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_5.html#SEC29"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_7.html#SEC52">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Hans Chalupsky</I> on <I>May, 21  2006</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>
</FONT>

</BODY>
</HTML>
