;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;; BEGIN LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
; Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          ;
;                                                                            ;
; The contents of this file are subject to the Mozilla Public License        ;
; Version 1.1 (the "License"); you may not use this file except in           ;
; compliance with the License. You may obtain a copy of the License at       ;
; http://www.mozilla.org/MPL/                                                ;
;                                                                            ;
; Software distributed under the License is distributed on an "AS IS" basis, ;
; WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   ;
; for the specific language governing rights and limitations under the       ;
; License.                                                                   ;
;                                                                            ;
; The Original Code is the STELLA Programming Language.                      ;
;                                                                            ;
; The Initial Developer of the Original Code is                              ;
; UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          ;
; 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               ;
;                                                                            ;
; Portions created by the Initial Developer are Copyright (C) 1996-2003      ;
; the Initial Developer. All Rights Reserved.                                ;
;                                                                            ;
; Contributor(s):                                                            ;
;                                                                            ;
; Alternatively, the contents of this file may be used under the terms of    ;
; either the GNU General Public License Version 2 or later (the "GPL"), or   ;
; the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   ;
; in which case the provisions of the GPL or the LGPL are applicable instead ;
; of those above. If you wish to allow use of your version of this file only ;
; under the terms of either the GPL or the LGPL, and not to allow others to  ;
; use your version of this file under the terms of the MPL, indicate your    ;
; decision by deleting the provisions above and replace them with the notice ;
; and other provisions required by the GPL or the LGPL. If you do not delete ;
; the provisions above, a recipient may use your version of this file under  ;
; the terms of any one of the MPL, the GPL or the LGPL.                      ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; END LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; Version: primal.ste,v 1.114 2003/09/30 00:35:14 hans Exp

;;; Declarations for objects implemented by native constructs.

(in-package "STELLA")

(in-module "/STELLA")


;;; Most functions declared in this file must be implemented by directly 
;;;    calling Common Lisp, C++ or Java functions.  By declaring them here
;;;    their signatures become available to the STELLA code walker.
;;;    The implementations can be found in the associated cl-primal.lisp,
;;;    cpp-primal.cc and Native.java files.

  ;;
;;;;;; Built-in constants:
  ;;

(defconstant TRUE BOOLEAN
  (verbatim :common-lisp CL:t :cpp "1" :java "true")
  :public? TRUE
  :documentation "Represents the boolean true truth value.")

(defconstant FALSE BOOLEAN
  (verbatim :common-lisp CL:nil :cpp "0" :java "false")
  :public? TRUE
  :documentation "Represents the boolean false truth value.")

(defconstant PI FLOAT
  (verbatim :common-lisp "(cl:float CL:PI 0.0d0)"  ;; in case it's a long float
            :cpp "3.141592653589793"
            :java "java.lang.Math.PI")
  :public? TRUE
  :documentation "A float approximation of the mathematical constant pi.")

(startup-time-progn
 ;; Need a variable object without generating an actual variable:
 (define-stella-global-variable-from-stringified-source
    "(defconstant NULL UNKNOWN NULL
       :public? TRUE
       :documentation
       \"Generic undefined value for any STELLA data type.  The STELLA
translator substitutes specific NULL-values appropriate for a particular data
type.  For example, NULL-INTEGER represents the undefined INTEGER value.\")"))

(defconstant NULL-INTEGER INTEGER
  (verbatim :common-lisp CL:MOST-NEGATIVE-FIXNUM
            :cpp "1 << (sizeof (int) / sizeof (char) * 8 - 1)"
	    :java "Integer.MIN_VALUE")
    :public? TRUE)

(defconstant NULL-SHORT-INTEGER SHORT-INTEGER
  (verbatim :common-lisp CL:MOST-NEGATIVE-FIXNUM
            :cpp "1 << (sizeof (short int) / sizeof (char) * 8 - 1)"
	    :java "Short.MIN_VALUE")
  :public? TRUE)

(defconstant NULL-LONG-INTEGER LONG-INTEGER
  (verbatim :common-lisp CL:MOST-NEGATIVE-FIXNUM
            :cpp "1 << (sizeof (long int) / sizeof (char) * 8 - 1)"
	    :java "Long.MIN_VALUE")
  :public? TRUE)   ;; Use 64-bit ints rather than 32 bit longs.

(defconstant NULL-UNSIGNED-SHORT-INTEGER UNSIGNED-SHORT-INTEGER
  (verbatim :common-lisp CL:MOST-NEGATIVE-FIXNUM
            :cpp "(unsigned short int) -1"
	    :java "Short.MIN_VALUE"
	    )
  :public? TRUE)

(defconstant NULL-UNSIGNED-LONG-INTEGER UNSIGNED-LONG-INTEGER
  (verbatim :common-lisp CL:MOST-NEGATIVE-FIXNUM
            :cpp "(unsigned long int) -1"
	    :java "Long.MIN_VALUE")
  :public? TRUE)


;; JAVA NOTE:  Using the NaN value would be a better solution, but it
;;      requires that the defined? and null? tests be modified to call
;;      the isNaN static function rather than doing a comparison with
;;      == or !=, since Java doesn't consider NaNs to be comparable.
;;     -- TAR 11/12/98

(defconstant NULL-FLOAT FLOAT
  (verbatim :common-lisp CL:MOST-NEGATIVE-DOUBLE-FLOAT
            :cpp "-HUGE_VAL /* IEEE infinity, defined in <math.h> */"
	    ; :java "Double.NaN; // IEEE Not a Number"
	    :java "Double.NEGATIVE_INFINITY; /* IEEE Infinity */"
	    )
    :public? TRUE)

(defconstant NULL-SINGLE-FLOAT SINGLE-FLOAT
  (verbatim :common-lisp CL:MOST-NEGATIVE-SINGLE-FLOAT
            :cpp "-HUGE_VAL /* IEEE infinity, defined in <math.h> */"
	    ; :java "Float.NaN; /* IEEE Not a Number */"
	    :java "Float.NEGATIVE_INFINITY; /* IEEE Infinity */"
	    )
    :public? TRUE)

(defconstant NULL-DOUBLE-FLOAT DOUBLE-FLOAT
  (verbatim :common-lisp CL:MOST-NEGATIVE-DOUBLE-FLOAT
	    :cpp "-HUGE_VAL /* IEEE infinity, defined in <math.h> */"
            ; :java "Double.NaN; /* IEEE Not a Number */"
	    :java "Double.NEGATIVE_INFINITY; /* IEEE Infinity */"
	    )
    :public? TRUE)

(defconstant NULL-CHARACTER CHARACTER
  (verbatim :common-lisp (CL:code-char 0)
            :cpp "'\\0'"
	    :java "Character.MIN_VALUE")
    :public? TRUE)

(defconstant NULL-BYTE BYTE (verbatim :common-lisp "255"
				      :cpp "255"
				      :java "-128")
    :public? TRUE)

(defconstant NULL-OCTET OCTET (verbatim :common-lisp "255"
					:cpp "255"
					:java "-128")
    :public? TRUE)

  ;;
;;;;;; `null?' and `defined?':
  ;;

(defmethod (null? BOOLEAN) ((x UNKNOWN))
  :documentation
  "Return true if `x' is undefined (handled specially by all translators)."
  :public? TRUE :native? TRUE)
(defmethod (null? BOOLEAN) ((x OBJECT))
  :documentation
  "Return true if `x' is undefined (handled specially by all translators)."
  :public? TRUE :native? TRUE)
(defmethod (null? BOOLEAN) ((x SECOND-CLASS-OBJECT))
  :documentation
  "Return true if `x' is undefined (handled specially by all translators)."
  :public? TRUE :native? TRUE)
(defmethod (null? BOOLEAN) ((x NATIVE-VECTOR))
  :documentation
  "Return true if `x' is undefined (handled specially by all translators)."
  :public? TRUE :native? TRUE)
(defmethod (null? BOOLEAN) ((x STRING))
  :documentation
  "Return true if `x' is undefined (handled specially by all translators)."
  :public? TRUE :native? TRUE)
(defmethod (null? BOOLEAN) ((x MUTABLE-STRING))
  :documentation
  "Return true if `x' is undefined (handled specially by all translators)."
  :public? TRUE :native? TRUE)
(defmethod (null? BOOLEAN) ((x CHARACTER))
  :documentation
  "Return true if `x' is undefined (handled specially by all translators)."
  :public? TRUE :native? TRUE)
(defmethod (null? BOOLEAN) ((x CODE))
  :documentation
  "Return true if `x' is undefined (handled specially by all translators)."
  :public? TRUE :native? TRUE)
(defmethod (null? BOOLEAN) ((x INTEGER))
  :documentation
  "Return true if `x' is undefined (handled specially by all translators)."
  :public? TRUE :native? TRUE)
(defmethod (null? BOOLEAN) ((x FLOAT))
  :documentation
  "Return true if `x' is undefined (handled specially by all translators)."
  :public? TRUE :native? TRUE)

(defmethod (defined? BOOLEAN) ((x UNKNOWN))
  :documentation
  "Return true if `x' is defined (handled specially by all translators)."
  :public? TRUE :native? TRUE)
(defmethod (defined? BOOLEAN) ((x OBJECT))
  :documentation
  "Return true if `x' is defined (handled specially by all translators)."
  :public? TRUE :native? TRUE)
(defmethod (defined? BOOLEAN) ((x SECOND-CLASS-OBJECT))
  :documentation
  "Return true if `x' is defined (handled specially by all translators)."
  :public? TRUE :native? TRUE)
(defmethod (defined? BOOLEAN) ((x NATIVE-VECTOR))
  :documentation
  "Return true if `x' is defined (handled specially by all translators)."
  :public? TRUE :native? TRUE)
(defmethod (defined? BOOLEAN) ((x STRING))
  :documentation
  "Return true if `x' is defined (handled specially by all translators)."
  :public? TRUE :native? TRUE)
(defmethod (defined? BOOLEAN) ((x MUTABLE-STRING))
  :documentation
  "Return true if `x' is defined (handled specially by all translators)."
  :public? TRUE :native? TRUE)
(defmethod (defined? BOOLEAN) ((x CHARACTER))
  :documentation
  "Return true if `x' is defined (handled specially by all translators)."
  :public? TRUE :native? TRUE)
(defmethod (defined? BOOLEAN) ((x CODE))
  :documentation
  "Return true if `x' is defined (handled specially by all translators)."
  :public? TRUE :native? TRUE)
(defmethod (defined? BOOLEAN) ((x INTEGER))
  :documentation
  "Return true if `x' is defined (handled specially by all translators)."
  :public? TRUE :native? TRUE)
(defmethod (defined? BOOLEAN) ((x FLOAT))
  :documentation
  "Return true if `x' is defined (handled specially by all translators)."
  :public? TRUE :native? TRUE)


  ;;
;;;;;; Equality tests:
  ;;

(defun (eq? BOOLEAN) ((x UNKNOWN) (y UNKNOWN))
  :documentation "Return true if `x' and `y' are literally the same object (or
simple number).  Analogue to the Common Lisp EQL and C++ and Java's ==."
  :public? TRUE :native? TRUE)

(defun (= BOOLEAN) ((x NUMBER) (y NUMBER))
  :documentation
  "Return true if `x' and `y' are numbers of exactly the same magnitude."
  :public? TRUE :native? TRUE)

(defun (eql? BOOLEAN) ((x OBJECT) (y OBJECT))
  :documentation "Return true if `x' and `y' are `eq?' or equivalent literals
such as strings that also might be wrapped in non-identical wrappers.  For
the case where `x' or `y' are plain literals such as strings or integers, the
STELLA translator substitutes the equality test appropriate for the particular
target language and does not actually call this function.  For cases where
`x' or `y' are known to be of type STANDARD-OBJECT, the STELLA translator
substitutes the faster `eq?' test inline."
  :public? TRUE
  (return (choose (null? x) (null? y) (or (eq? x y) (object-eql? x y)))))

(defun (equal? BOOLEAN) ((x OBJECT) (y OBJECT))
  :documentation "Return true if `x' and `y' are `eql?' or considered equal
by a user-defined `object-equal?' method.  This implements a fully extensible
equality test similar to Java's `equals' method.  Note that writers of custom
`object-equal?' methods must also implement a corresponding `equal-hash-code'
method."
  :public? TRUE
  (return (choose (null? x)
                  (null? y)
                  (or (eq? x y)
                      (object-equal? x y)))))

(defmethod (object-equal? BOOLEAN) ((x OBJECT) (y OBJECT))
  :documentation "Return true if `x' and `y' are `eq?'."
  :public? TRUE
  (return (eq? x y)))

(defmethod (object-equal? BOOLEAN) ((x WRAPPER) (y OBJECT))
  :documentation "Return true if `x' and `y' are literal wrappers whose
literals are considered `eql?'."
  :public? TRUE
  (return (object-eql? x y)))


  ;;
;;;;;; Arithmetic and math support functions
  ;;


;;; Operators are translated directly.

(defun (> BOOLEAN) ((x NUMBER) (y NUMBER))
  :documentation "Return true if `x' is greater than `y'."
  :public? TRUE :native? TRUE)
(defun (>= BOOLEAN) ((x NUMBER) (y NUMBER))
  :documentation "Return true if `x' is greater than or equal to `y'."
  :public? TRUE :native? TRUE)
(defun (< BOOLEAN) ((x NUMBER) (y NUMBER))
  :documentation "Return true if `x' is less than `y'."
  :public? TRUE :native? TRUE)
(defun (<= BOOLEAN) ((x NUMBER) (y NUMBER))
  :documentation "Return true if `x' is less than or equal to `y'."
  :public? TRUE :native? TRUE)
(defun (+ NUMBER) (&rest (arguments NUMBER))
  :documentation "Return the sum of all `arguments'."
  :public? TRUE :native? TRUE)
(defun (- NUMBER) ((x NUMBER) &rest (arguments NUMBER))
  :documentation "If only `x' was supplied return the result of 0 - `x'.
Otherwise, return the result of (...((`x' - arg1) - arg2) - ... - argN)."
  :public? TRUE :native? TRUE)
(defun (* NUMBER) (&rest (arguments NUMBER))
  :documentation "Return the product of all `arguments'."
  :public? TRUE :native? TRUE)
(defun (/ NUMBER) ((x NUMBER) &rest (arguments NUMBER))
  :documentation "If only `x' was supplied return the result of 1 / `x'.
Otherwise, return the result of (...((`x' / arg1) / arg2 ) / ... / argN)."
  :public? TRUE :native? TRUE)

(defun (zero? BOOLEAN) ((x INTEGER))
  :documentation "Return true if `x' is 0."
  :public? TRUE :globally-inline? TRUE
  (return
    (verbatim :common-lisp (CL:= x 0)
              :cpp "(!x)"
              :java "(x == 0)")))

(defun (plus? BOOLEAN) ((x INTEGER))
  :documentation "Return true if `x' is greater than 0."
  :public? TRUE :globally-inline? TRUE
  (return
    (verbatim :common-lisp (CL:> x 0)
              :cpp "(x > 0)"
              :java "(x > 0)")))
  
(defun (even? BOOLEAN) ((x INTEGER))
  :documentation "Return true if `x' is an even number."
  :public? TRUE :globally-inline? TRUE
  (return
    (verbatim :common-lisp (CL:not (CL:logbitp 0 x))
              :cpp "!(x % 2)"
              :java "((x % 2) == 0)")))

(defun (odd? BOOLEAN) ((x INTEGER))
  :documentation "Return true if `x' is an odd number."
  :public? TRUE :globally-inline? TRUE
  (return
    (verbatim :common-lisp (CL:logbitp 0 x)
              :cpp "(x % 2)"
              :java "((x % 2) == 1)")))

(defun (div INTEGER) ((x INTEGER) (y INTEGER))
  :documentation "Return the integer quotient from dividing `x' by `y'."
  :public? TRUE :globally-inline? TRUE
  (return
    (verbatim :common-lisp (CL:VALUES (CL:truncate x y))
              :cpp "(x / y)"
              :java "(x / y)")))

(defun (rem INTEGER) ((x INTEGER) (y INTEGER))
  :documentation "Return the remainder from dividing `x' by `y'.  The
sign of the result is always the same as the sign of `x'.  This has slightly
different behavior than the `mod' function, and has less overhead in C++ and
Java, which don't have direct support for a true modulus function."
  :public? TRUE :globally-inline? TRUE
  (return
    (verbatim :common-lisp (CL:rem x y)
              :cpp "(x % y)"
              :java "(x % y)")))

(defun (mod INTEGER) ((x INTEGER) (modulus INTEGER))
  :documentation "True modulus.  Return the result of `x' mod `modulo'.
Note: In C++ and Java, `mod' has more overhead than the similar
function `rem'.  The  answers returned by `mod' and `rem' are only
different when the signs of `x' and `modulo' are different."
  :public? TRUE
  (let ((remainder (verbatim :common-lisp (cl:mod x modulus)
                             :otherwise (rem x modulus))))
    ;; At this point, remainder is the correct answer in Common Lisp,
    ;; but needs to be modified if the signs of x and modulus are
    ;; different for the other languages that do not have a native
    ;; modulus function.
    (verbatim :common-lisp NULL
              :otherwise
              (cond ((> remainder 0)
                     (when (< modulus 0)
                       (setq remainder (+ modulus remainder))))
                    ((< remainder 0)
                     (when (> modulus 0)
                       (setq remainder (+ modulus remainder))))))
    (return remainder)))

(defun (gcd INTEGER) ((x INTEGER) (y INTEGER))
  :documentation "Return the greatest common divisor of `x' and `y'."
  :public? TRUE
  (when (< x 0)
    (setq x (- x)))
  (when (< y 0)
    (setq y (- y)))
  (let ((temp 0))
    (while (not (= y 0))
      (setq temp (rem x y))
      (setq x y)
      (setq y temp))
    (return x)))

(defun (ceiling INTEGER) ((n NUMBER))
  :documentation "Return the smallest integer >= `n'."
  :native? TRUE :public? TRUE)
(defun (floor INTEGER) ((n NUMBER))
  :documentation "Return the biggest integer <= `n'."
  :native? TRUE :public? TRUE)
(defun (round INTEGER) ((n NUMBER))
  :documentation "Round `n' to the closest integer and return the result."
  :native? TRUE :public? TRUE)

(defun (random INTEGER) ((n INTEGER))
  :public? TRUE
  :documentation "Generate a random integer in the interval [0..n-1].
`n' must be <= 2^15."
  (when (> n 32768)
    ;; This is a C++ restricition:
    (error "random: Can only generate random numbers between 0 and (2^15)-1."))
  (let ((rNum INTEGER
              (verbatim
                  :common-lisp (CL:random n)
		  ;; NOTE: For large n (on the order of 2^13) this can
		  ;; skew the distribution unless n is a factor of 2,
		  ;; but this probably isn't worth worrying about. - TAR
		  ;; 11/12/98
                  :cpp "abs(rand()) % n"
		  ;; NOTE: This might also produce some problems, since
		  ;; the input of the random number generator is an
		  ;; integer that has been converted to a double.
		  :java "(int) Math.floor(Math.random()*n)"
		  )))
    (return rNum)))

(defun seed-random-number-generator ()
  :public? TRUE
  :documentation "Seeds the random number generator with the current time."
  (verbatim
      :cpp "srand(time(NULL));"
      :otherwise NULL))

;; Some useful math library functions

(defun (sqrt FLOAT) ((n FLOAT))
  :public? TRUE :globally-inline? TRUE
  :documentation "Return the square root of `n'."
  (return
    (verbatim
	:common-lisp (CL:sqrt n)
	:cpp "::sqrt(n)"
        :java "Math.sqrt(n)")))

(defun (cos FLOAT) ((n FLOAT))
  :public? TRUE :globally-inline? TRUE
  :documentation "Return the cosine of `n' radians."
  (return
    (verbatim
	:common-lisp (CL:cos n)
	:cpp "::cos(n)"
        :java "Math.cos(n)")))

(defun (sin FLOAT) ((n FLOAT))
  :public? TRUE :globally-inline? TRUE
  :documentation "Return the sine of `n' radians."
  (return
    (verbatim
	:common-lisp (CL:sin n)
	:cpp "::sin(n)"
        :java "Math.sin(n)")))

(defun (tan FLOAT) ((n FLOAT))
  :public? TRUE :globally-inline? TRUE
  :documentation "Return the tangent of `n' radians."
  (return
    (verbatim
	:common-lisp (CL:tan n)
	:cpp "::tan(n)"
        :java "Math.tan(n)")))

(defun (acos FLOAT) ((n FLOAT))
  :public? TRUE :globally-inline? TRUE
  :documentation "Return the arccosine of `n' in radians."
  (return
    (verbatim
	:common-lisp (CL:acos n)
	:cpp "::acos(n)"
        :java "Math.acos(n)")))

(defun (asin FLOAT) ((n FLOAT))
  :public? TRUE :globally-inline? TRUE
  :documentation "Return the arcsine of `n' in radians."
  (return
    (verbatim
	:common-lisp (CL:asin n)
	:cpp "::asin(n)"
        :java "Math.asin(n)")))

(defun (atan FLOAT) ((n FLOAT))
  :public? TRUE :globally-inline? TRUE
  :documentation "Return the arc tangent of `n' in radians."
  (return
    (verbatim
	:common-lisp (CL:atan n)
	:cpp "::atan(n)"
        :java "Math.atan(n)")))

(defun (atan2 FLOAT) ((x FLOAT) (y FLOAT))
  :public? TRUE :globally-inline? TRUE
  :documentation "Return the arc tangent of `x' / `y' in radians."
  (return
    (verbatim
	:common-lisp (CL:atan x y)
	:cpp "::atan2(x,y)"
        :java "Math.atan2(x,y)")))

(defconstant RECIPROCAL-NL10 FLOAT (/ 1.0 (log 10.0))
  :documentation "1 / (log 10) Reciprocal of the Log base e of 10.
Used for log 10 conversions.")

(defun (log FLOAT) ((n FLOAT))
  :public? TRUE :globally-inline? TRUE
  :documentation "Return the natural logarithm (base e) of `n'."
  (return
    (verbatim
	:common-lisp (CL:log n)
	:cpp "::log(n)"
        :java "Math.log(n)")))

(defun (log10 FLOAT) ((n FLOAT))
  :public? TRUE :globally-inline? TRUE
  :documentation "Return the logarithm (base 10) of `n'."
  (return
    (verbatim
	:common-lisp (CL:log n 10.0d0)
	:otherwise (* (log n) RECIPROCAL-NL10))))

(defun (exp FLOAT) ((n FLOAT))
  :public? TRUE :globally-inline? TRUE
  :documentation "Return the e to the power `n'."
  (return
    (verbatim
	:common-lisp (CL:exp n)
	:cpp "::exp(n)"
        :java "Math.exp(n)")))

(defun (expt FLOAT) ((x FLOAT) (y FLOAT))
  :public? TRUE :globally-inline? TRUE
  :documentation "Return `x' ^ `y'."
  (return
    (verbatim
	:common-lisp (CL:expt x y)
	:cpp "::pow(x,y)"
        :java "Math.pow(x,y)")))

;; QUESTION (1): SHOULDN'T THESE BE DEFINED ON NUMBER RATHER THAN INTEGER?
;; QUESTION (2): SHOULD WE IMPLEMENT NATIVE VERSIONS OF INSTEAD?
(defun (min INTEGER) ((x INTEGER) (y INTEGER))
  :documentation
  "Return the minimum of `x' and `y'.  If either is NULL, return the other."
  :public? TRUE 
  (when (null? x)
    (return y))
  (when (null? y)
    (return x))
  (return (choose (< x y) x y)))

(defun (max INTEGER) ((x INTEGER) (y INTEGER))
  :documentation
  "Return the maximum of `x' and `y'.  If either is NULL, return the other."
  :public? TRUE
  (when (null? x)
    (return y))
  (when (null? y)
    (return x))
  (return (choose (> x y) x y)))

(defmethod (abs INTEGER) ((x INTEGER))
  :documentation "Return the absolute value of `x'."
  :globally-inline? TRUE :public? TRUE
  (return (choose (< x 0) (- 0 x) x)))

(defmethod (abs FLOAT) ((x FLOAT))
  :documentation "Return the absolute value of `x'."
  :globally-inline? TRUE :public? TRUE 
  (return (choose (< x 0.0) (- 0.0 x) x)))

;; Avoiding name clashes or ambiguity:
(startup-time-progn
  ;; The version defined in `math.h' returns a double float (eventually,
  ;;    we'll have to prefix all C++ translations of STELLA functions
  ;;    with `stella_' which will solve this problem as a side-effect):
  (register-native-name (quote floor) :cpp :function)
  (register-native-name (quote round) :cpp :function)
  ;; Once we translate literal methods to overloaded functions we'll need this:
  ;(register-native-name (quote abs) :cpp :function)
  ;; Some Unix'es have `random' as part of the standard C library:
  (register-native-name (quote random) :cpp :function)
  (register-native-name (quote sqrt) :cpp :function)
  (register-native-name (quote cos) :cpp :function)
  (register-native-name (quote sin) :cpp :function)
  (register-native-name (quote tan) :cpp :function)
  (register-native-name (quote acos) :cpp :function)
  (register-native-name (quote asin) :cpp :function)
  (register-native-name (quote atan) :cpp :function)
  (register-native-name (quote atan2) :cpp :function)
  (register-native-name (quote exp) :cpp :function)
  (register-native-name (quote log) :cpp :function)
  ;; handle conflict with STL functions:
  (register-native-name (quote min) :cpp :function)
  (register-native-name (quote max) :cpp :function))


  ;;
;;;;;; Character library functions
  ;;

(defun (character-code INTEGER) ((ch CHARACTER))
  :documentation "Return the 8-bit ASCII code of `ch' as an integer."
  :public? TRUE :globally-inline? TRUE
  (return
    ;; NOTE: Common Lisp is not required by the standard to use ASCII
    ;; character codes, although in practice the existing
    ;; implementations do.
    (verbatim :common-lisp (CL:char-code ch)
              :cpp "(int)(unsigned char) ch"
	      ;; NOTE: Java natively uses UNICODE characters, but the
	      ;; ASCII characters are a subset, so this should work as
	      ;; expected for them.
	      :java "(int) ch")))

(defun (code-character CHARACTER) ((code INTEGER))
  :documentation "Return the character encoded by `code' (0 <= `code' <= 255)."
  :public? TRUE :globally-inline? TRUE
  (return
    (verbatim :common-lisp (CL:code-char code)
              :cpp "(char) code"
	      :java "(char) code")))

(defun (character-downcase CHARACTER) ((ch CHARACTER))
  :documentation "If `ch' is lowercase, return its uppercase version,
otherwise, return 'ch' unmodified."
  :public? TRUE :globally-inline? TRUE
  (return (downcase-character ch)))

(defun (character-upcase CHARACTER) ((ch CHARACTER))
  :documentation "If `ch' is uppercase, return its lowercase version,
otherwise, return 'ch' unmodified.  If only the first character of
a sequence of characters is to be capitalized, `character-capitalize'
should be used instead."
  :public? TRUE :globally-inline? TRUE
  (return (upcase-character ch)))

(defun (character-capitalize CHARACTER) ((ch CHARACTER))
  :documentation "Return the capitalized character for `ch'.  This is generally the same
as the uppercase character, except for obscure non-English characters in Java.  It should
be used if only the first character of a sequence of characters is to be capitalized."
  :public? TRUE :globally-inline? TRUE
  (return
    (verbatim :java "Character.toTitleCase(ch)"
              :otherwise (character-upcase ch))))

  ;;
;;;;;; String library functions
  ;;

;;; Special variable that guides transient or permanent storage allocation
;;;    USE WITH GREAT CAUTION (see `with-transient-objects' and
;;;    `with-permanent-objects' macros).
(defspecial *transientObjects?* BOOLEAN FALSE :public? TRUE)

(defun (string-eql? BOOLEAN) ((x STRING) (y STRING))
  :documentation
  "Return true if `x' and `y' are equal strings or are both undefined.  This
test is substituted automatically by the STELLA translator if `eql?' is applied
to strings."
  :public? TRUE
  (if (null? x)
      (return (null? y))
    (return (and (defined? y)
                 (verbatim :common-lisp "(CL:string= x y)"
                           :cpp "!strcmp(x, y)"
                           :java "x.equals(y)")))))

(defun (string-equal? BOOLEAN) ((x STRING) (y STRING))
  :documentation
  "Return true if `x' and `y' are equal strings ignoring character case or
are both undefined."
  :public? TRUE
  (if (null? x)
      (return (null? y))
    (return (and (defined? y)
                 (verbatim :common-lisp "(CL:string-equal x y)"
			   :cpp "!strcasecmp(x, y)"
                           :java "x.equalsIgnoreCase(y)")))))

(defun (string-compare INTEGER) ((x STRING) (y STRING) (case-sensitive? BOOLEAN))
  :public? TRUE
  :documentation "Compare `x' and `y' lexicographically, and return -1, 0, 
or 1, depending on whether `x' is less than, equal, or greater than `y'.
If `case-sensitive?' is true, then case does matter for the comparison"
  (if case-sensitive?
      (return (verbatim :common-lisp (cl:cond ((cl:string< x y) -1)
					      ((cl:string> x y) 1)
					      (cl:t 0))
			:cpp "strcmp(x, y)"
			:java "x.compareTo(y)"))
    (return (verbatim :common-lisp (cl:cond ((cl:string-lessp x y) -1)
					    ((cl:string-greaterp x y) 1)
					    (cl:t 0))
		      :cpp "strcasecmp(x, y)"
		      :java "x.compareToIgnoreCase(y)"))))

(defmethod (empty? BOOLEAN) ((x STRING))
  :documentation "Return true if `x' is the empty string \"\""
  :public? TRUE :globally-inline? TRUE
  (return (string-eql? x "")))

(defmethod (non-empty? BOOLEAN) ((x STRING))
  :documentation "Return true if `x' is not the empty string \"\""
  :public? TRUE :globally-inline? TRUE
  (return (not (empty? x))))

;;;;; THESE SHOULD BECOME OBSOLETE BY UPGRADING THE METHOD CALL WALKER A BIT:
(defmethod (empty? BOOLEAN) ((x STRING-WRAPPER))
  :documentation "Return true if `x' is the wrapped empty string \"\""
  :public? TRUE :globally-inline? TRUE
  (return (string-eql? (wrapper-value x) "")))

(defmethod (non-empty? BOOLEAN) ((x STRING-WRAPPER))
  :documentation "Return true if `x' is not the wrapped empty string \"\""
  :public? TRUE :globally-inline? TRUE
  (return (not (empty? x))))

;;
;; The Common Lisp verbatim does null tests on all of these in order
;;   to handle true values other than T, which some Lisps (i.e., ACL 5.0.1)
;;   return at high compiler optimization levels.

(defun (string< BOOLEAN) ((x STRING) (y STRING))
  :public? TRUE
  :documentation "Return true if `x' is lexicographically < `y', considering case."
  (return (verbatim :common-lisp (cl:null (cl:string>= x y))
		    :otherwise (< (string-compare x y true) 0))))

(defun (string<= BOOLEAN) ((x STRING) (y STRING))
  :public? TRUE
  :documentation "Return true if `x' is lexicographically <= `y', considering case."
  (return (verbatim :common-lisp (cl:null (cl:string> x y))
		    :otherwise (<= (string-compare x y true) 0))))

(defun (string>= BOOLEAN) ((x STRING) (y STRING))
  :public? TRUE
  :documentation "Return true if `x' is lexicographically >= `y', considering case."
  (return (verbatim :common-lisp (cl:null (cl:string< x y))
		    :otherwise (>= (string-compare x y true) 0))))

(defun (string> BOOLEAN) ((x STRING) (y STRING))
  :public? TRUE
  :documentation "Return true if `x' is lexicographically > `y', considering case."
  (return (verbatim :common-lisp (cl:null (cl:string<= x y))
		    :otherwise (> (string-compare x y true) 0))))

(defun (string-less? BOOLEAN) ((x STRING) (y STRING))
  :public? TRUE
  :documentation "Return true if `x' is lexicographically < `y', ignoring case."
  (return (verbatim :common-lisp (cl:null (cl:string-not-lessp x y))
		    :otherwise (< (string-compare x y false) 0))))

(defun (string-less-equal? BOOLEAN) ((x STRING) (y STRING))
  :public? TRUE
  :documentation "Return true if `x' is lexicographically <= `y', ignoring case."
  (return (verbatim :common-lisp (cl:null (cl:string-greaterp x y))
		    :otherwise (<= (string-compare x y false) 0))))

(defun (string-greater-equal? BOOLEAN) ((x STRING) (y STRING))
  :public? TRUE
  :documentation "Return true if `x' is lexicographically >= `y', ignoring case."
  (return (verbatim :common-lisp (cl:null (cl:string-lessp x y))
		    :otherwise (>= (string-compare x y false) 0))))

(defun (string-greater? BOOLEAN) ((x STRING) (y STRING))
  :public? TRUE
  :documentation "Return true if `x' is lexicographically > `y', ignoring case."
  (return (verbatim :common-lisp (cl:null (cl:string-not-greaterp x y))
		    :otherwise (> (string-compare x y false) 0))))

#|
;; Test function for the string comparison:

(defun test-string-functions ()
  (let ((w "abc")
	(x "def")
	(y "ABC")
	(z "DEF"))
    (print "  x     y     =   equal?  <     >    <=    >=   less great leseq grteq" EOL)
    (print " " w "  " x " " 
	   (string-eql? w x) (string-equal? w x)
	   (string< w x) (string> w x) (string<= w x) (string>= w x)
	   (string-less? w x) (string-greater? w x)
	   (string-less-equal? w x) (string-greater-equal? w x) EOL)
    (print " " x "  " y " " 
	   (string-eql? x y) (string-equal? x y)
	   (string< x y) (string> x y) (string<= x y) (string>= x y)
	   (string-less? x y) (string-greater? x y)
	   (string-less-equal? x y) (string-greater-equal? x y) EOL)
    (print " " w "  " y " " 
	   (string-eql? w y) (string-equal? w y)
	   (string< w y) (string> w y) (string<= w y) (string>= w y)
	   (string-less? w y) (string-greater? w y)
	   (string-less-equal? w y) (string-greater-equal? w y) EOL)
    (print " " w "  " z " " 
	   (string-eql? w z) (string-equal? w z)
	   (string< w z) (string> w z) (string<= w z) (string>= w z)
	   (string-less? w z) (string-greater? w z)
	   (string-less-equal? w z) (string-greater-equal? w z) EOL)
    (print " " w "  " w " " 
	   (string-eql? w w) (string-equal? w w)
	   (string< w w) (string> w w) (string<= w w) (string>= w w)
	   (string-less? w w) (string-greater? w w)
	   (string-less-equal? w w) (string-greater-equal? w w) EOL)
    ))

;; Should produce the following output:

  x     y    =   equal?  <     >     <=    >=   less great leseq grteq
 abc  def  FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE
 def  ABC  FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE
 abc  ABC  FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE
 abc  DEF  FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE
 abc  abc   TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE

|#


(defun (make-string STRING) ((size INTEGER) (initchar CHARACTER))
  :documentation "Return a new string filled with `size' `initchar's."
  :public? TRUE :native? TRUE)


(defun (make-mutable-string MUTABLE-STRING) ((size INTEGER) (initchar CHARACTER))
  :documentation
  "Return a new mutable string filled with `size' `initchar's."
  :public? TRUE :globally-inline? TRUE
  (return
    (verbatim :common-lisp (CL:make-string size :initial-element initchar)
              :cpp "makeString(size, initchar)"
              :java "#$(STELLAROOT).javalib.Native.makeMutableString(size, initchar)")))

(defun (make-raw-mutable-string MUTABLE-STRING) ((size INTEGER))
  :documentation "Return a new uninitialized mutable string of `size'."
  ;; Since for characters we can't distinguish between a NULL init character
  ;;    and the NULL character as an initializer, we need a separate function
  ;;    to generate uninitialized strings.
  ;; NOTE: A similar function for non-mutable strings doesn't make sense,
  ;;    since we could never initialize the content of the resulting string.
  ;; TO DO: FIX THE PERFORMANCE PENALTY WE ARE INHERITING DUE TO THE JAVA LOGIC:
  :public? TRUE :globally-inline? TRUE
  (let ((s MUTABLE-STRING NULL))
    (verbatim :common-lisp (setq s (CL:make-string size))
              :cpp "s = new (GC) char[size+1]; s[size]='\\0'"
              ;; annoying that we have to explicitly set the length:
              :java "s = new StringBuffer(size); s.setLength(size)")
    (return s)))

(defun (string-concatenate STRING) ((string1 STRING) (string2 STRING))
  :documentation "Return a new string representing the concatenation of
`string1' and `string2'."
  :native? TRUE)

(defmethod (concatenate STRING)
    ((string1 STRING) (string2 STRING) &rest (otherStrings STRING))
  :public? TRUE
  :documentation "Return a new string representing the concatenation
of `string1', `string2', and `otherStrings'.  The two mandatory parameters
allow us to optimize the common binary case by not relying on the somewhat
less efficient variable arguments mechanism."
  ;; NOTE: To make this a method we need at least one mandatory parameter,
  ;;    thus, we could never completely emulate `CL:concatenate'.
  (when (= (length otherStrings) 0)
    (return (string-concatenate string1 string2)))
  (let ((result MUTABLE-STRING NULL)
        (length (+ (length string1) (length string2)))
        (index 0))
    (foreach string in otherStrings
        do (setq length (+ length (length string))))
    (setq result (make-raw-mutable-string length))
    (foreach ch in string1
        do (setf (nth result index) ch)
           (++ index))
    (foreach ch in string2
        do (setf (nth result index) ch)
           (++ index))
    (foreach string in otherStrings
        do (foreach ch in string
               do (setf (nth result index) ch)
                  (++ index)))
    (return result) ))

(defun (string-upcase STRING) ((string STRING))
  :documentation "Return an upper-case copy of `string'."
  :native? TRUE
  :public? TRUE)
 
(defun (string-downcase STRING) ((string STRING))
  :documentation "Return a lower-case copy of `string'."
  :native? TRUE
  :public? TRUE)

(defun (string-capitalize STRING) ((string STRING))
  :documentation "Return a capitalized version of `string'."
  :native? TRUE :public? TRUE)

(defmethod (copy STRING) ((string STRING))
  :documentation "Return a copy of `string'."
  :native? TRUE)

(defmethod (substitute STRING)
    ((self STRING) (new-char CHARACTER) (old-char CHARACTER))
  :documentation "Substitute all occurences of `old-char' with `new-char'
in the string `self'."
  :native? TRUE :public? TRUE)

(defmethod (substitute MUTABLE-STRING)
    ((self MUTABLE-STRING) (new-char CHARACTER) (old-char CHARACTER))
  :documentation "Substitute all occurences of `old-char' with `new-char'
in the string `self'."
  :native? TRUE :public? TRUE)

(defun (help-substitute-characters MUTABLE-STRING)
    ((self MUTABLE-STRING) (new-chars STRING) (old-chars STRING))
  :public? FALSE
  :globally-inline? TRUE
  (let ((pos INTEGER NULL))
    (foreach i in (interval 0 (1- (length self)))
	do (setq pos (position old-chars (nth self i) 0))
	   (when (defined? pos)
	     (setf (nth self i) (nth new-chars pos))))
    (return self)))

;; NOTE:
;; The following two methods need to be in this order so that they will
;; be properly handled in Common Lisp.  The second definition must take
;; precedence

(defmethod (substitute-characters MUTABLE-STRING)
    ((self MUTABLE-STRING) (new-chars STRING) (old-chars STRING))
  :documentation "Substitute all occurences of of a member of `old-chars' with the 
corresponding member of `new-chars' in the string `self'.  IMPORTANT:  The return
value should be used instead of relying on destructive substitution, since the
substitution will not be destructive in all translated languages."
  :public? TRUE
  (return (help-substitute-characters self new-chars old-chars)))

(defmethod (substitute-characters STRING)
    ((self STRING) (new-chars STRING) (old-chars STRING))
  :documentation "Substitute all occurences of of a member of `old-chars' with the 
corresponding member of `new-chars' in the string `self'.  Returns a new string."
  :public? TRUE
  (return 
    (help-substitute-characters self new-chars old-chars)))

(defun (replace-substrings STRING) ((string STRING) (new STRING) (old STRING))
  :documentation "Replace all occurrences of `old' in `string' with `new'."
  :public? TRUE
  (let ((stringLength (length string))
        (oldLength (length old))
        (newLength (length new))
        (nofOccurrences 0)
	(oldStart 0)
        (cursor 0)
        (resultCursor 0)
        (result MUTABLE-STRING NULL))
    ;; we scan `string' twice to minimize intermediate memory consumption:
    (while (defined? (setq oldStart (string-search string old cursor)))
      (++ nofOccurrences)
      (setq cursor (+ oldStart oldLength)))
    (when (= nofOccurrences 0)
      (return string))
    (setq result
      (make-raw-mutable-string
       (+ stringLength (* nofOccurrences (- newLength oldLength)))))
    (setq cursor 0)
    (while (defined? (setq oldStart (string-search string old cursor)))
      (foreach i in (interval cursor (1- oldStart))
          do (setf (nth result resultCursor) (nth string i))
             (++ resultCursor))
      (foreach char in new
          do (setf (nth result resultCursor) char)
             (++ resultCursor))
      (setq cursor (+ oldStart oldLength)))
    (foreach i in (interval cursor (1- stringLength))
        do (setf (nth result resultCursor) (nth string i))
           (++ resultCursor))
    (return result)))

(defun (insert-string INTEGER) ((source STRING)
				(start INTEGER)
				(end INTEGER)
				(target MUTABLE-STRING)
				(target-index INTEGER)
				(case-conversion KEYWORD))
  :documentation "Inserts characters from `source' begining at `start' and
ending at `end' into `target' starting at `target-index'.  If `end' is `null',
then the entire length of the string is used. The copy of characters is affected
by the `case-conversion' keyword which should be one of
   :UPCASE :DOWNCASE :CAPITALIZE :PRESERVE.

The final value of target-index is returned."
  (when (null? end) (setq end (1- (length source))))
  (when (< end start) (return target-index))
  (safety 2 (< (+ target-index (- end start)) (length target))
	  "Target String not long enough in INSERT-STRING.")
  (case case-conversion
    (:UPCASE
     (foreach j in (interval start end)
	 do (setf (nth target target-index) 
	      (upcase-character (nth source j)))
	    (++ target-index)))
    (:DOWNCASE
     (foreach j in (interval start end)
	 do (setf (nth target target-index) 
	      (downcase-character (nth source j)))
	    (++ target-index)))
    (:CAPITALIZE
     (setf (nth target target-index) 
       (upcase-character (nth source start)))
     (++ target-index)
     (foreach j in (interval (1+ start) end)
	 do (setf (nth target target-index) 
	      (downcase-character (nth source j)))
	    (++ target-index)))
    (:preserve
     (foreach j in (interval start end)
	 do (setf (nth target target-index) (nth source j))
	    (++ target-index))))
  (return target-index))

(defun (integer-to-string STRING) ((i INTEGER))
  :documentation "Print `i' to a string and return the result.  This is more
efficient than using a string stream."
  :native? TRUE :public? TRUE)

(defun (float-to-string STRING)   ((f FLOAT))
  :documentation "Print `f' to a string and return the result.  This is more
efficient than using a string stream."
  :native? TRUE :public? TRUE)

(defun (character-to-string STRING) ((c CHARACTER))
  :documentation "Convert `c' into a one-element string and return the result."
  :public? TRUE :globally-inline? TRUE
  (return (make-string 1 c)))

(defun (string-to-integer INTEGER) ((string STRING))
  :documentation
  "Convert a `string' representation of an integer into an integer."
  :native? TRUE :public? TRUE)

(defun (string-to-float FLOAT) ((string STRING))
  :documentation
  "Convert a `string' representation of a float into a float."
  :native? TRUE :public? TRUE)

(defun (format-float STRING) ((f FLOAT) (nDecimals INTEGER))
  :documentation
  "Print `f' in fixed-point format with `nDecimals' behind the decimal point
and return the result as a string."
  :native? TRUE :public? TRUE)

(defun (format-with-padding STRING) ((input STRING)
				     (length INTEGER) 
				     (padchar CHARACTER)
				     (align KEYWORD)
				     (truncate? BOOLEAN))
  :public? TRUE
  :documentation "Formats `input' to be (at least) `length' long, using `padchar' to
fill if necessary.  `align' must be one of :LEFT, :RIGHT, :CENTER and will control
how `input' will be justified in the resulting string.  If `truncate?' is true, then
then an overlength string will be truncated, using the opposite of `align' to pick
the truncation direction."
  (let ((len (length input)))
    (cond ((= len length)
	   (return input))
	  ((> len length)
	   (if truncate?
	     (case align
	       (:LEFT  
		(return (subsequence input (- len length) len)))
	       (:RIGHT
		(return (subsequence input 0 (- len length))))
	       (:CENTER
		(let ((left INTEGER (/ (- len length) 2)))
		  (return (subsequence input left (+ left length))))))
	     (return input)))
	  (otherwise
	   (case align
	     (:LEFT 
	      (return 
		(concatenate input (make-string (- length len) padchar))))
	     (:RIGHT 
	      (return 
		(concatenate (make-string (- length len) padchar) input)))
	     (:CENTER 
	      (let ((left INTEGER (/ (- length len) 2)))
		(return 
		  (concatenate (make-string left padchar)
			       input
			       (make-string (- length len left) padchar)))))))) ))


(defmethod (member? BOOLEAN) ((self STRING) (char CHARACTER)) :native? TRUE :public? TRUE)

(defmethod (first CHARACTER) ((self STRING))
  :documentation "Return the first character of `self'."
  :globally-inline? TRUE :public? TRUE
  (return (nth self 0)))

(defmethod (first CHARACTER) ((self MUTABLE-STRING))
  :documentation "Return the first character of `self' (settable via `setf')."
  :globally-inline? TRUE :public? TRUE
  (return (nth self 0)))

(defmethod (first-setter CHARACTER) ((self MUTABLE-STRING) (ch CHARACTER))
  :documentation "Set the first character of `self' to `ch' and return `ch'."
  :globally-inline? TRUE :public? TRUE
  (return (setf (nth self 0) ch)))

(defmethod (second CHARACTER) ((self STRING))
  :documentation "Return the second character of `self'."
  :globally-inline? TRUE :public? TRUE
  (return (nth self 1)))

(defmethod (second CHARACTER) ((self MUTABLE-STRING))
  :documentation "Return the second character of `self' (settable via `setf')."
  :globally-inline? TRUE :public? TRUE
  (return (nth self 1)))

(defmethod (second-setter CHARACTER) ((self MUTABLE-STRING) (ch CHARACTER))
  :documentation "Set the second character of `self' to `ch' and return `ch'."
  :globally-inline? TRUE :public? TRUE
  (return (setf (nth self 1) ch)))

(defmethod (third CHARACTER) ((self STRING))
  :documentation "Return the third character of `self'."
  :globally-inline? TRUE :public? TRUE
  (return (nth self 2)))

(defmethod (third CHARACTER) ((self MUTABLE-STRING))
  :documentation "Return the third character of `self' (settable via `setf')."
  :globally-inline? TRUE :public? TRUE
  (return (nth self 2)))

(defmethod (third-setter CHARACTER) ((self MUTABLE-STRING) (ch CHARACTER))
  :documentation "Set the third character of `self' to `ch' and return `ch'."
  :globally-inline? TRUE :public? TRUE
  (return (setf (nth self 2) ch)))

(defmethod (fourth CHARACTER) ((self STRING))
  :documentation "Return the fourth character of `self'."
  :globally-inline? TRUE :public? TRUE
  (return (nth self 3)))

(defmethod (fourth CHARACTER) ((self MUTABLE-STRING))
  :documentation "Return the fourth character of `self' (settable via `setf')."
  :globally-inline? TRUE :public? TRUE
  (return (nth self 3)))

(defmethod (fourth-setter CHARACTER) ((self MUTABLE-STRING) (ch CHARACTER))
  :documentation "Set the fourth character of `self' to `ch' and return `ch'."
  :globally-inline? TRUE :public? TRUE
  (return (setf (nth self 3) ch)))

(defmethod (fifth CHARACTER) ((self STRING))
  :documentation "Return the fifth character of `self'."
  :globally-inline? TRUE :public? TRUE
  (return (nth self 4)))

(defmethod (fifth CHARACTER) ((self MUTABLE-STRING))
  :documentation "Return the fifth character of `self' (settable via `setf')."
  :globally-inline? TRUE :public? TRUE
  (return (nth self 4)))

(defmethod (fifth-setter CHARACTER) ((self MUTABLE-STRING) (ch CHARACTER))
  :documentation "Set the fifth character of `self' to `ch' and return `ch'."
  :globally-inline? TRUE :public? TRUE
  (return (setf (nth self 4) ch)))

(defmethod (nth CHARACTER) ((self STRING) (position INTEGER))
  :documentation "Return the character in `self' at `position'."
  :globally-inline? TRUE :public? TRUE
  (return
    (verbatim :common-lisp (cl:schar (CL:the CL:simple-string self)
                                     (CL:the CL:fixnum position))
              :cpp "self[position]"
              :java "self.charAt(position)")))

(defmethod (nth CHARACTER) ((self MUTABLE-STRING) (position INTEGER))
  :documentation "Return the character in `self' at `position'."
  :globally-inline? TRUE :public? TRUE
  (return
    (verbatim :common-lisp (cl:schar (CL:the CL:simple-string self)
                                     (CL:the CL:fixnum position))
              :cpp "self[position]"
              :java "self.charAt(position)")))

(defmethod (nth-setter CHARACTER)
    ((self MUTABLE-STRING) (ch CHARACTER) (position INTEGER))
  :documentation "Set the character in `self' at `position' to `ch'."
  :globally-inline? TRUE :public? TRUE
  (return
    (verbatim :common-lisp (setf (cl:schar (CL:the CL:simple-string self)
                                           (CL:the CL:fixnum position))
                                 (CL:the CL:character ch))
              :cpp "self[position] = ch"
              ;; Unfortunately, we need another function call here, since the
              ;;    native Java setter method doesn't return a result:
              :java "#$(STELLAROOT).javalib.Native.mutableString_nthSetter(self, ch, position)")))

(defmethod (rest STRING) ((self STRING)) :native? TRUE :public? TRUE)

(defmethod (length INTEGER) ((self STRING))
  :documentation "Return the length of the string `self'."
  :public? TRUE :globally-inline? TRUE
  (return
    (verbatim :common-lisp (CL:length self)
              :cpp "strlen(self)"
	      :java "self.length()")))

(defmethod (length INTEGER) ((self MUTABLE-STRING))
  :documentation "Return the length of the string `self'."
  :public? TRUE :globally-inline? TRUE
  (return
    (verbatim :common-lisp (CL:length self)
              :cpp "strlen(self)"
	      :java "self.length()")))

(defmethod (position INTEGER)
    ((string STRING) (character CHARACTER) (start INTEGER))
  :documentation "Return the position of `character' within `string' (counting
from zero); or return NULL if `character' does not occur within `string'.
If `start' was supplied as non-NULL, only consider the substring starting
at `start', however, the returned position will always be relative to the
entire string."
  :native? TRUE
  :public? TRUE)

;(defmethod (search INTEGER)
;    ((string STRING) (substring STRING) (start INTEGER))
;  :documentation "Return start position of the left-most occurrence of
;`substring' in `string', beginning from `start'.  Return NULL if it is not
;a substring."
;  :native? TRUE)

(defun (string-search INTEGER)
    ((string STRING) (substring STRING) (start INTEGER))
  :documentation "Return start position of the left-most occurrence of
`substring' in `string', beginning from `start'.  Return NULL if it is not
a substring."
  :native? TRUE :public? TRUE)

(defmethod (subsequence STRING)
    ((string STRING) (start INTEGER) (end INTEGER))
  :documentation "Return a substring of `string' beginning at position `start'
and ending up to but not including position `end', counting from zero.  An
`end' value of NULL stands for the rest of the string."
  :native? TRUE :public? TRUE)

(defmethod (subsequence STRING)
    ((string MUTABLE-STRING) (start INTEGER) (end INTEGER))
  :documentation "Return a substring of `string' beginning at position `start'
and ending up to but not including position `end', counting from zero.  An
`end' value of NULL stands for the rest of the string."
  :native? TRUE :public? TRUE)

(defun (stringify STRING) ((expression OBJECT))
  :documentation "Print `expression' onto a string and return the result.
Printing is done with `*printReadably?*' set to true and with `*printPretty?*'
set to false."
  :native? TRUE :public? TRUE)

(defun (unstringify OBJECT) ((string STRING))
  :documentation "Read a STELLA expression from `string' and return the result.
This is identical to `read-s-expression-from-string'."
  :public? TRUE :globally-inline? TRUE
  (return (read-s-expression-from-string string)))

  ;;
;;;;;; Hash tables
  ;;

(verbatim
    :cpp "# include \"stella/cpp-lib/cpp-hashtable.hh\"
"
    :otherwise NULL)

(defmethod free-hash-table-values ((self ABSTRACT-HASH-TABLE))
  :documentation "Call free on each value in the hash table `self'."
  (when *use-stella-hash-tables?*
    (return))
  (let ((native-table (the-hash-table self)))
    (verbatim
	:common-lisp "(CL:maphash #'(CL:lambda (key value)
				     (CL:declare (CL:ignore key))
				     (free value))
				 native-table)"
	:cpp "std::cout << \"WARNING: freeHashTableValues not yet implemented\" << std::endl;"
	:java "java.util.Iterator iter = nativeTable.values().iterator();
      while (iter.hasNext()) {
         ((Stella_Object) iter.next()).free();
      }")))

(defmethod initialize-hash-table ((self ABSTRACT-HASH-TABLE))
  :documentation "Insert a newly-created native hash table into `self'."
  (when *use-stella-hash-tables?*
    (setf (the-stella-hash-table self) (new STELLA-HASH-TABLE))
    (return))
  (setf (the-hash-table self)
    (verbatim
	:common-lisp "(CL:make-hash-table :test #'CL:eql)"
	:cpp "(cpp_hash_table*)(new Native_EQL_Hash_Table<Object*, Object*>)"
	:java "new java.util.HashMap()")))

;;; --------- Objects to Objects ------------

;; These used to be defined as methods with :NATIVE? TRUE, but since our
;; Java translation can't handle native METHODS on Stella-defined
;; classes we have to write these with verbatim statements.

(defmethod (lookup (LIKE (any-value self)))
    ((self HASH-TABLE) (key (LIKE (any-key self))))
  :public? TRUE
  (when *use-stella-hash-tables?*
    (return (stella-hash-table-lookup (the-stella-hash-table self) key)))
  (let ((native-table (the-hash-table self)))
    (return
      (verbatim
          :common-lisp (CL:or (CL:gethash key native-table) NULL)
          :cpp "((Native_EQL_Hash_Table<Object*, Object*>*)nativeTable)->get(key)"
	  :java "(Stella_Object) nativeTable.get(key)"
          ))))

(defmethod insert-at ((self HASH-TABLE) (key (LIKE (any-key self)))
                      (value (LIKE (any-value self))))
  :public? TRUE
  (when *use-stella-hash-tables?*
    (stella-hash-table-insert-at (the-stella-hash-table self) key value)
    (return))
  (let ((native-table (the-hash-table self)))
    (verbatim
	:common-lisp (CL:setf (CL:gethash key native-table) value)
	:cpp "(*((Native_EQL_Hash_Table<Object*, Object*>*)nativeTable))[key] = value;"
	:java "nativeTable.put(key, value)")))

(defmethod remove-at ((self HASH-TABLE) (key (LIKE (any-key self))))
  :public? TRUE
  (when *use-stella-hash-tables?*
    (stella-hash-table-remove-at (the-stella-hash-table self) key)
    (return))
  (let ((native-table (the-hash-table self)))
    (verbatim
	:common-lisp (CL:remhash key native-table)
	:cpp "((Native_EQL_Hash_Table<Object*, Object*>*)nativeTable)->erase(key);"
	:java "nativeTable.remove(key);")))

;;; --------- Integers to Objects ------------

(defmethod initialize-hash-table ((self INTEGER-HASH-TABLE))
  :documentation "Insert a newly-created native hash table into `self'."
  (when *use-stella-hash-tables?*
    (setf (the-stella-hash-table self) (new STELLA-HASH-TABLE))
    (return))
  (setf (the-hash-table self)
    (verbatim
	:common-lisp "(CL:make-hash-table :test #'CL:eql)"
	:cpp "((cpp_hash_table*)(new Native_EQL_Hash_Table<int, Object*>))"
	:java "new java.util.HashMap()")))

(defmethod (lookup (LIKE (any-value self)))
    ((self INTEGER-HASH-TABLE) (key INTEGER))
  :public? TRUE
  (when *use-stella-hash-tables?*
    (return (stella-hash-table-lookup (the-stella-hash-table self) key)))
  (let ((native-table (the-hash-table self)))
    (return 
      (verbatim
	  :common-lisp (CL:or (CL:gethash key native-table) NULL)
	  :cpp "((Native_EQL_Hash_Table<int, Object*>*)nativeTable)->get(key)"
	  :java "(Stella_Object) nativeTable.get(new Integer(key))"))))

(defmethod insert-at ((self INTEGER-HASH-TABLE) (key INTEGER) (value OBJECT))
  :public? TRUE
  (when *use-stella-hash-tables?*
    (stella-hash-table-insert-at (the-stella-hash-table self) key value)
    (return))
  (let ((native-table (the-hash-table self)))
    (verbatim :common-lisp (CL:declare (CL:fixnum key))
	      :otherwise NULL)
    (verbatim
	:common-lisp (CL:setf (CL:gethash key native-table) value)
	:cpp "(*((Native_EQL_Hash_Table<int, Object*>*)nativeTable))[key] = value;"
	:java "nativeTable.put(new Integer(key), value);")))

(defmethod remove-at ((self INTEGER-HASH-TABLE) (key (LIKE (any-key self))))
  (when *use-stella-hash-tables?*
    (stella-hash-table-remove-at (the-stella-hash-table self) key)
    (return))
  (let ((native-table (the-hash-table self)))
    (verbatim
	:common-lisp (CL:remhash key native-table)
	:cpp "((Native_EQL_Hash_Table<int, Object*>*)nativeTable)->erase(key);"
	:java "nativeTable.remove(new Integer(key));")))

;;; --------- Floats to Objects ------------

(defmethod initialize-hash-table ((self FLOAT-HASH-TABLE))
  :documentation "Insert a newly-created native hash table into `self'."
  (when *use-stella-hash-tables?*
    (setf (the-stella-hash-table self) (new STELLA-HASH-TABLE))
    (return))
  (setf (the-hash-table self)
    (verbatim
	:common-lisp "(CL:make-hash-table :test #'CL:eql)"
	:cpp "(cpp_hash_table*)(new Native_EQL_Hash_Table<double, Object*>)"
	:java "new java.util.HashMap()")))

(defmethod (lookup (LIKE (any-value self)))
    ((self FLOAT-HASH-TABLE) (key FLOAT))
  :public? TRUE
  (when *use-stella-hash-tables?*
    (return (stella-hash-table-lookup (the-stella-hash-table self) key)))
  (let ((native-table (the-hash-table self)))
    (return 
      (verbatim
	  :common-lisp (CL:or (CL:gethash key native-table) NULL)
	  :cpp "((Native_EQL_Hash_Table<double, Object*>*)nativeTable)->get(key)"
	  :java "(Stella_Object) nativeTable.get(new Double(key))"))))

(defmethod insert-at ((self FLOAT-HASH-TABLE) (key FLOAT) (value OBJECT))
  :public? TRUE
  (when *use-stella-hash-tables?*
    (stella-hash-table-insert-at (the-stella-hash-table self) key value)
    (return))
  (let ((native-table (the-hash-table self)))
    (verbatim
	:common-lisp (CL:setf (CL:gethash key native-table) value)
	:cpp "(*((Native_EQL_Hash_Table<double, Object*>*)nativeTable))[key] = value;"
	:java "nativeTable.put(new Double(key), value);")))

(defmethod remove-at ((self FLOAT-HASH-TABLE) (key (LIKE (any-key self))))
  (when *use-stella-hash-tables?*
    (stella-hash-table-remove-at (the-stella-hash-table self) key)
    (return))
  (let ((native-table (the-hash-table self)))
    (verbatim
	:common-lisp (CL:remhash key native-table)
	:cpp "((Native_EQL_Hash_Table<double, Object*>*)nativeTable)->erase(key);"
	:java "nativeTable.remove(new Double(key));")))

;;; --------- Strings to Objects ------------

(defmethod initialize-hash-table ((self STRING-HASH-TABLE))
  :documentation "Insert a newly-created native hash table into `self'."
  (when *use-stella-hash-tables?*
    (setf (the-stella-hash-table self) (new STELLA-HASH-TABLE))
    (return))
  (setf (the-hash-table self)
    (verbatim
	:common-lisp "(CL:make-hash-table :test #'CL:equal)"
	:cpp "(cpp_hash_table*)(new Native_EQL_Hash_Table<char*, Object*>)"
	:java "new java.util.HashMap()")))

(defmethod (lookup (LIKE (any-value self)))
    ((self STRING-HASH-TABLE) (key STRING))
  :public? TRUE
  (when *use-stella-hash-tables?*
    (return
      (stella-string-hash-table-lookup (the-stella-hash-table self) key)))
  (let ((native-table (the-hash-table self)))
    (return (verbatim
		:common-lisp (CL:or (CL:gethash key native-table) NULL)
		:cpp "((Native_EQL_Hash_Table<char*, Object*>*)nativeTable)->get(key)"
		:java "((Stella_Object) nativeTable.get(key))"
		))))

(defmethod insert-at ((self STRING-HASH-TABLE) (key STRING) (value OBJECT))
  :public? TRUE
  (when *use-stella-hash-tables?*
    (stella-hash-table-insert-at (the-stella-hash-table self) key value)
    (return))
  (let ((native-table (the-hash-table self)))
    (verbatim
	:common-lisp (CL:setf (CL:gethash key native-table) value)
	:cpp "(*((Native_EQL_Hash_Table<char*, Object*>*)nativeTable))[key] = value;"
	:java "nativeTable.put(key, value);")))

(defmethod remove-at ((self STRING-HASH-TABLE) (key STRING))
  :public? TRUE
  (when *use-stella-hash-tables?*
    (stella-hash-table-remove-at (the-stella-hash-table self) key)
    (return))
  (let ((native-table (the-hash-table self)))
    (verbatim
	:common-lisp (CL:remhash key native-table)
	:cpp "((Native_EQL_Hash_Table<char*, Object*>*)nativeTable)->erase(key);"
	:java "nativeTable.remove(key);")))

;;; --------- Strings to Integers ------------

(defmethod initialize-hash-table ((self STRING-TO-INTEGER-HASH-TABLE))
  :documentation "Insert a newly-created native hash table into `self'."
  (when *use-stella-hash-tables?*
    (setf (the-stella-hash-table self) (new STELLA-HASH-TABLE))
    (return))
  (setf (the-hash-table self)
    (verbatim
	:common-lisp "(CL:make-hash-table :test #'CL:equal)"
	:cpp "(cpp_hash_table*)(new Native_EQL_Hash_Table<char*, int>(NULL_INTEGER))"
	:java "new java.util.HashMap()")))

(defmethod (lookup INTEGER) ((self STRING-TO-INTEGER-HASH-TABLE) (key STRING))
  :public? TRUE
  (when *use-stella-hash-tables?*
    (return
      (unwrap-integer
       (stella-string-hash-table-lookup (the-stella-hash-table self) key))))
  (let ((native-table (the-hash-table self))
	(result INTEGER NULL))
    (verbatim :common-lisp (CL:setq result (CL:or (CL:gethash key native-table) NULL-INTEGER))
	      :cpp "result = ((Native_EQL_Hash_Table<char*, int>*)nativeTable)->get(key)"
	      :java "Integer rawResult = (Integer) nativeTable.get(key);
      if (rawResult != null) result = rawResult.intValue()")
    (return result) ))

(defmethod insert-at ((self STRING-TO-INTEGER-HASH-TABLE) (key STRING) (value INTEGER))
  :public? TRUE
  (when *use-stella-hash-tables?*
    (stella-hash-table-insert-at (the-stella-hash-table self) key value)
    (return))
  (let ((native-table (the-hash-table self)))
    (verbatim
	:common-lisp (CL:setf (CL:gethash key native-table) value)
	:cpp "(*((Native_EQL_Hash_Table<char*, int>*)nativeTable))[key] = value;"
	:java "nativeTable.put(key, new Integer(value));")))

(defmethod remove-at ((self STRING-TO-INTEGER-HASH-TABLE) (key STRING))
  :public? TRUE
  (when *use-stella-hash-tables?*
    (stella-hash-table-remove-at (the-stella-hash-table self) key)
    (return))
  (let ((native-table (the-hash-table self)))
    (verbatim
	:common-lisp (CL:remhash key native-table)
	:cpp "((Native_EQL_Hash_Table<char*, int>*)nativeTable)->erase(key);"
	:java "nativeTable.remove(key);")))

;;; --------- User-level hash functions ------------

;; Avoiding name clashes:
(startup-time-progn
    (register-native-name (quote hash-code) :java :function))

(defglobal *hash-byte-random-table* (ARRAY (256) OF INTEGER) NULL
  :documentation "A table of 256 26-bit random numbers that can be used to
hash sequences of bytes.  Each bit-column in the table has an approximately
even number of 0's and 1's.")

(startup-time-progn :early-inits
  (setq *hash-byte-random-table* (new (ARRAY (256) OF INTEGER)))
  (foreach i in (interval 0 255)
      do (setf (aref *hash-byte-random-table* i) 0))
  ;; generate 26-bit random numbers (CL:FIXNUM restriction) that have an
  ;;    approximately even number of 0's and 1's in each bit column:
  (foreach bit in (interval 0 25)
      do (foreach i in (interval 0 255)
             do (setf (aref *hash-byte-random-table* i)
                  (logor (aref *hash-byte-random-table* i)
                         ;; depends somewhat on an unbiased coin:
                         (shift-left (random 2) bit))))))

(defconstant *integer-msb-mask* INTEGER
   ;; Since this is initialized via a `verbatim' expression this will
   ;; be initialized immediately (i.e., before `main' is run).
   (verbatim
     :common-lisp
     ;; this restricts us to positive fixnums, since shifting
     ;;    the mask by one more position gets us into bignums:
     "#.(CL:ash 1 (CL:1- (CL:integer-length CL:most-positive-fixnum)))"
     ;; identical to C++ version of NULL-INTEGER - let's
     ;;    hope the compiler does constant evaluation here:
     :cpp "1 << (sizeof (int) / sizeof (char) * 8 - 1)"
     ;; Java guarantees 32-bit integers:
     :java "0x80000000")
   :documentation "The most significant bit of a regular integer (FIXNUM
in Common-Lisp).  In C++ and Java this corresponds to the sign bit, in
Lisp this corresponds to the left-most bit of `CL:most-positive-fixnum'.")

(defconstant *integer-unsigned-bits-mask* INTEGER
  (verbatim :common-lisp (CL:logior (CL:1- *integer-msb-mask*) *integer-msb-mask*)
            :otherwise (lognot *integer-msb-mask*))
  :documentation "Mask that covers all the unsigned bits of an integer.")

(defun (hashmod INTEGER) ((code INTEGER) (size INTEGER))
  :documentation "Map the hash code `code' onto a bucket index for a hash table
of `size' (i.e., onto the interval [0..size-1].  This is just like `rem' for
positive hash codes but also works for negative hash codes by mapping those
onto a positive number first.  Note, that the sign conversion mapping is not
equivalent to calling the `abs' function (it simply masks the sign bit for
speed) and therefore really only makes sense for hash codes."
  :public? TRUE :globally-inline? TRUE
  (return
    (verbatim
      :common-lisp
      (CL:rem (CL:the CL:FIXNUM
                (CL:logand code *integer-unsigned-bits-mask*))
              size)
      :cpp "(((unsigned int) code) % size)"
      :java "((code & 0x7FFFFFFF) % size)")))

(defun (rotate-hash-code INTEGER) ((arg INTEGER))
  :documentation
  "Rotate `arg' to the right by 1 position.  This means shift `arg' to the right
by one and feed in `arg's bit zero from the left.  In Lisp the result will stay
in positive FIXNUM range.  In C++ and Java this might return a negative
value which might be equal to NULL-INTEGER.  Important: to make this inlinable,
it must be called with an atom (i.e., constant or variable) as its argument.
This function is primarily useful for hashing sequences of items where the hash
code should take the sequential order of elements into account (e.g., lists)."
  :public? TRUE :globally-inline? TRUE
  (return
    (choose (= (logand arg 1) 0)
            (unsigned-shift-right-by-1 arg)
            (logor (shift-right arg 1) *integer-msb-mask*))))

(defun (object-hash-code INTEGER) ((self OBJECT))
  :documentation
  "Return a hash code for `self' (can be negative).  Two objects that are `eq?'
are guaranteed to generate the same hash code.  Two objects that are not `eq?'
do not necessarily generate different hash codes.  Similar to `hash-code' but
always hashes on the address of `self' even if it is a wrapper."
  :public? TRUE :globally-inline? TRUE
  (return
    (verbatim :common-lisp "(STELLA::%%OBJECT-HASH-CODE SELF)"
              :cpp "(size_t)self" ;; assumes a non-copying gc
              :java "self.hashCode()")))

(defmethod (hash-code INTEGER) ((self OBJECT))
  :documentation
  "Return a hash code for `self' (can be negative).  Two objects that are `eql?'
are guaranteed to generate the same hash code.  Two objects that are not `eql?'
do not necessarily generate different hash codes."
  :public? TRUE
  (return (object-hash-code self)))

(defun (safe-hash-code INTEGER) ((self OBJECT))
  :documentation "Return a hash code for `self'.  Just like `hash-code'
- which see, but also works for NULL."
  :public? TRUE
  (if (null? self)
      (return 63842277) ;; (hash-string "NULL" 0)
    (return (hash-code self))))

;; duplicated to allow inlining on STANDARD-OBJECTs:
(defmethod (hash-code INTEGER) ((self STANDARD-OBJECT))
  :public? TRUE :globally-inline? TRUE
  (return (object-hash-code self)))

(defmethod (hash-code INTEGER) ((self WRAPPER))
  :public? TRUE
  (error "WRAPPER.hash-code: Don't know how to hash on " self))

(defmethod (hash-code INTEGER) ((self STRING-WRAPPER))
  :public? TRUE :globally-inline? TRUE
  (return (hash-code (wrapper-value self))))

(defmethod (hash-code INTEGER) ((self INTEGER-WRAPPER))
  :public? TRUE :globally-inline? TRUE
  (return (hash-code (wrapper-value self))))

(defmethod (hash-code INTEGER) ((self FLOAT-WRAPPER))
  :public? TRUE :globally-inline? TRUE
  (return (hash-code (wrapper-value self))))

(defmethod (hash-code INTEGER) ((self CHARACTER-WRAPPER))
  :public? TRUE :globally-inline? TRUE
  (return (hash-code (wrapper-value self))))

(defmethod (hash-code INTEGER) ((self BOOLEAN-WRAPPER))
  :public? TRUE :globally-inline? TRUE
  (return (choose (wrapper-value self) 27333705 31891526))) ;; random #'s

(defmethod (hash-code INTEGER) ((self STRING))
  :public? TRUE :globally-inline? TRUE
  (return
    ;; RETHINK THE USE OF `CL:sxhash' SINCE (AT LEAST IN ALLEGRO) IT SEEMS TO
    ;;    BE RESTRICTED TO 16-BIT CODES WHICH IS PROBLEMATIC FOR LARGE TABLES:
    (verbatim :common-lisp (CL:sxhash self)
              :java "self.hashCode()"
              :cpp "native_hash_string(self)"
              :otherwise (hash-string self 0))))

(defmethod (hash-code INTEGER) ((self INTEGER))
  :public? TRUE :globally-inline? TRUE
  ;; should we use byte-sequence hashing similar to `hash-string' instead?
  (return self))

(defmethod (hash-code INTEGER) ((self FLOAT))
  :public? TRUE :globally-inline? TRUE
  (return
    (verbatim :common-lisp (CL:sxhash self)
              :cpp "(size_t)self"                    ;; assumes a non-copying gc
              :java "(int)(Double.doubleToLongBits(self)^(Double.doubleToLongBits(self)>>>32))"
	      ;; Java code is inline version of "new Double(self).hashCode()"
	      ;; One could use only half of the inline, but that could lead to
	      ;; too many collisions for either integer floats or else very small ones.
	      )))

(defmethod (hash-code INTEGER) ((self CHARACTER))
  :public? TRUE :globally-inline? TRUE
  (return (logxor (aref *hash-byte-random-table* (character-code self))
                  ;; some random number to differentiate character hash
                  ;;    codes from those of single-element strings:
                  33485726)))

(defmethod (equal-hash-code INTEGER) ((self OBJECT))
  :documentation
  "Return a hash code for `self' (can be negative).  Two objects that are `equal?'
are guaranteed to generate the same hash code (provided, that writers of
`object-equal?' methods also implemented the appropriate `equal-hash-code'
method).  Two objects that are not `equal?'do not necessarily generate different
hash codes."
  :public? TRUE
  (return (hash-code self)))

(defun (safe-equal-hash-code INTEGER) ((self OBJECT))
  :documentation "Return a hash code for `self'.  Just like `equal-hash-code'
- which see, but also works for NULL.  `equal-hash-code' methods that expect to
handle NULL components should use this function for recursive calls."
  :public? TRUE
  (if (null? self)
      (return 63842277) ;; (hash-string "NULL" 0)
    (return (equal-hash-code self))))

(defun (hash-string INTEGER) ((string STRING) (seedCode INTEGER))
  :globally-inline? TRUE :public? TRUE
  :documentation "Generate a hash-code for `string' and return it.
Two strings that are equal but not eq will generate the same code.
The hash-code is based on `seedCode' which usually will be 0.  However,
`seedCode' can also be used to supply the result of a previous hash
operation to achieve hashing on sequences of strings without actually
having to concatenate them."
  ;; This hashes better than the Allegro-CL `sxhash' but is significantly
  ;;    slower (factor 2-10) for long strings.  The problem with `CL:sxhash'
  ;;    is that it only produces 16-bit hash codes which causes collision
  ;;    problems if we have large symbol tables, for example.
  (let ((code seedCode)
        (cursor (length string)))
    (if (= cursor 0)
        (return 4303803) ;; some random #
      (-- cursor))
    (loop
      (setq code (logxor code (aref *hash-byte-random-table*
                                    (character-code (nth string cursor)))))
      (if (= cursor 0)
          (break)
        (-- cursor))
      ;; rotate to take sequence ordering into account:
      (setq code (rotate-hash-code code)))
    (return code)))

(defglobal *hash-table-size-primes* (VECTOR OF INTEGER-WRAPPER) NULL
  :documentation "List of prime numbers approximately growing by a factor of 2
that are suitable to be used as hash table sizes."
  :public? TRUE)

(startup-time-progn :early-inits
  (setq *hash-table-size-primes*
    (vector 29    53   97         193       389       769
        1543       3079       6151      12289     24593
        49157      98317      196613    393241    786433
        1572869    3145739    6291469   12582917  25165843
        50331653   100663319  201326611 402653189 #|805306457 
        1610612741 3221225473 4294967291|#)))

(defun (pick-hash-table-size-prime INTEGER) ((minSize INTEGER))
  :documentation "Return a hash table prime of at least `minSize'."
  :public? TRUE
  (foreach prime in *hash-table-size-primes*
      where (>= prime minSize)
      do (return prime))
  (error "pick-hash-table-size-prime: minimum size is too large"))


  ;;
;;;;;; Low-level support for VECTORs:
  ;;

(defmethod initialize-vector ((self VECTOR))
  (let ((size (array-size self)))
    (setf (the-array self)
      (verbatim 
          :common-lisp (CL:make-array size :initial-element NULL)
          :cpp  "new (GC) Object*[size]"
          :java "new #$(STELLAROOT).Stella_Object[size]"))
    ;; initialize array elements (only needed in C++):
    (verbatim
        :common-lisp "(setq size size)"
        :java "size = size"
        :otherwise
        (let ((array (the-array self)))
          (foreach i in (interval 0 (1- size))
              do (setf (nth array i) NULL))))))

(defun resize-vector ((self VECTOR) (size INTEGER))
  :documentation "Change the size of `self' to `size'.  If `size' is smaller
than the current size of `self' the vector will be truncated.  Otherwise, 
the internal array of `self' will be grown to `size' and unused elements
will be initialized to NULL."
  :public? TRUE
  ;; This duplicates some of the functionality of `VECTOR.initialize-vector'
  ;;    for efficiency.
  (let ((old_size (array-size self))
        (i old_size)
        (old_array (the-array self))
        (new_array old_array))
    (when (= size old_size)
      (return))
    (setq new_array
      (verbatim 
          :common-lisp (CL:make-array size :initial-element NULL)
          :cpp  "new (GC) Object*[size]"
          :java "new #$(STELLAROOT).Stella_Object[size]"))
    (when (< size old_size)
      (setq old_size size)
      (setq i old_size))
    ;; copy elements of the old array:
    (while (>= (-- i) 0)
      (setf (nth new_array i) (nth old_array i)))
    ;; initialize unused elements of new array (only needed in C++):
    (verbatim
        :common-lisp "(setq i i)"
        :java "i = i"
        :otherwise
        (foreach i in (interval old_size (1- size))
            do (setf (nth new_array i) NULL)))
    ;; update the vector:
    (setf (the-array self) new_array)
    (setf (array-size self) size)))

(defmethod (nth (LIKE (any-value self))) ((self NATIVE-VECTOR) (position INTEGER))
  :documentation "Return the element in `self' at `position'."
  :public? TRUE :globally-inline? TRUE
  (return
    (verbatim :common-lisp (CL:aref self position)
              :cpp "self[position]"
              :java "self[position]")))

(defmethod (nth-setter (LIKE (any-value self)))
    ((self NATIVE-VECTOR) (value (LIKE (any-value self))) (position INTEGER))
  :documentation "Set the element in `self' at `position' to `value'."
  :public? TRUE :globally-inline? TRUE
  (return
    ;; TO DO: IMPROVE LISP INLINING TO AVOID THE AUXILIARY `CL:LET' HERE:
    (verbatim :common-lisp (CL:setf (CL:aref self position) value)
              :cpp "self[position] = value"
              :java "self[position] = value")))

  ;;
;;;;;; Object Destruction
  ;;

;;; ELIMINATE THIS, SINCE IT DOESN'T DO ANYTHING USEFUL:
(defun unmake ((self OBJECT))
  (ignore self)
  NULL)

  ;;
;;;;;; File operations
  ;;

(defun (probe-file? BOOLEAN) ((fileName FILE-NAME))
  :documentation "Return true if file `fileName' exists.  Note that this does
not necessarily mean that the file can also be read."
  :native? TRUE :public? TRUE)

(defun (file-write-date CALENDAR-DATE) ((fileName FILE-NAME))
  :documentation "Return the time at which file `fileName' was last modified or
NULL if that cannot be determined."
  :native? TRUE :public? TRUE)

(defun (file-length INTEGER) ((fileName FILE-NAME))
  :documentation "Return the length of file `fileName' in bytes or NULL if that
cannot be determined.  Note that this will currently overrun for files that
are longer than what can be represented by a STELLA integer."
  :native? TRUE :public? TRUE)

(defun delete-file ((fileName FILE-NAME))
  :documentation "Delete the file `fileName'."
  :native? TRUE :public? TRUE)

(defun copy-file ((fromFile FILE-NAME) (toFile FILE-NAME))
  :documentation "Copy file `fromFile' to file `toFile', clobbering
any data already in `toFile'."
  :public? TRUE
  (when (not (probe-file? fromFile))
    (error "Can't copy non-existent file: " fromFile EOL))
  (with-input-file (from fromFile)
    (with-output-file (to toFile)
       (let ((buffer (make-tokenizer-byte-array *tokenizer-initial-buffer-size*))
             (bytes-read 0))
         (loop 
           (setq bytes-read (byte-array-read-sequence buffer from
                                                      0 *tokenizer-initial-buffer-size*))
           (if (> bytes-read 0)
             (byte-array-write-sequence buffer to 0 bytes-read)
             (break)))))))


  ;;
;;;;;; Bit operations
  ;;

(defun (lognot INTEGER) ((arg INTEGER))
  :globally-inline? TRUE
  :public? TRUE
  (return
    (verbatim
        :common-lisp (CL:lognot arg)
        :cpp "(~ arg)"
	:java "(~ arg)")))

(defun (logand INTEGER) ((arg1 INTEGER) (arg2 INTEGER))
  :globally-inline? TRUE
  :public? TRUE
  (return
    (verbatim
        :common-lisp (CL:logand arg1 arg2)
        :cpp "(arg1 & arg2)"
	:java "(arg1 & arg2)")))

(defun (logor INTEGER) ((arg1 INTEGER) (arg2 INTEGER))
  :globally-inline? TRUE
  :public? TRUE
  (return
    (verbatim
        :common-lisp (CL:logior arg1 arg2)
        :cpp "(arg1 | arg2)"
	:java "(arg1 | arg2)")))

(defun (logxor INTEGER) ((arg1 INTEGER) (arg2 INTEGER))
  :globally-inline? TRUE
  :public? TRUE
  (return
    (verbatim
        :common-lisp (CL:logxor arg1 arg2)
        :cpp "(arg1 ^ arg2)"
	:java "(arg1 ^ arg2)")))

(defun (integer-length INTEGER) ((arg INTEGER))
  :native? TRUE
  :public? TRUE)

(defun (shift-left INTEGER) ((arg INTEGER) (count INTEGER))
  :globally-inline? TRUE
  :public? TRUE
  (return
    (verbatim
        :common-lisp (CL:ash arg count)
        :cpp "(arg << count)"
	:java "(arg << count)")))

(defun (shift-right INTEGER) ((arg INTEGER) (count INTEGER))
  :documentation "Shift `arg' to the right by `count' positions and
0-extend from the left if `arg' is positive or 1-extend if it is
negative.  This is an arithmetic shift that preserve the sign of `arg'
and is equivalent to dividing `arg' by 2** `count'."
  :globally-inline? TRUE :public? TRUE
  (return
    (verbatim
        :common-lisp (CL:ash arg (CL:the CL:FIXNUM (CL:- count)))
        :cpp "(arg >> count)"
	:java "(arg >> count)")))

(defun (unsigned-shift-right-by-1 INTEGER) ((arg INTEGER))
  :documentation "Shift `arg' to the right by 1 position and 0-extend
from the left.  This does not preserve the sign of `arg' and shifts
the sign-bit just like a regular bit.  In Common-Lisp we can't do that
directly and need to do some extra masking."
  :globally-inline? TRUE :public? TRUE
  (return
    (verbatim
      ;; If `arg' is positive, this works just like a regular `shift-right';
      ;; if it is negative, this shifts in the sign bit and then masks it
      ;; emulating a 0 shifted in from the left:
      :common-lisp (CL:logand (CL:the CL:FIXNUM (CL:ash arg -1))
                              *integer-unsigned-bits-mask*)
      :cpp "((unsigned int)arg >> 1)"
      :java "(arg >>> 1)")))

#|
(defun (unsigned-shift-right INTEGER) ((arg INTEGER) (count INTEGER))
  :documentation "Shift `arg' to the right by `count' positions and
0-extend from the left.  This does not preserve the sign of `arg' and
shifts the sign-bit just like a regular bit.  In Common-Lisp we can't
do that directly..."
  :globally-inline? TRUE :public? TRUE
  (return
    (verbatim
      :common-lisp "...hairy, since once we've shifted in the sign bit
                    we want to do a regular shift for count-1 positions.
                    Not that this is hard but it is unfortunately complex
                    for a bit operation."
      :cpp "((unsigned int)arg >> count)"
      :java "(arg >>> count)")))
|#

  ;;
;;;;;; Lisp support functions -- converting Lisp object to Stella objectsn
  ;;

;; These need to be here, because they are called from
;; general (non-Lisp specific) code.  They are no-ops
;; except in Lisp.

(defun (stellify OBJECT) ((self OBJECT))
  :documentation "Convert a Lisp object into a STELLA object."
  :public? TRUE
  ;; Note: This resembles `stellafy', but it decides on its own what
  ;;    Stella type `object' should be converted to.
  (let ((result self))
    (verbatim
      :common-lisp
      "(CL:typecase self
        (CL:NULL (cl:setq result STELLA::NIL))
        (CL:CONS (cl:setq result (stella::cons (stellify (CL:car self))
                                               (stellify (CL:cdr self)))))
        (CL:KEYWORD (cl:setq result (intern-keyword (CL:symbol-name self))))
        (CL:SYMBOL
         (CL:if (cl:eq self CL:t)
           (cl:setq result TRUE-WRAPPER)
           (cl:setq result (intern-symbol (CL:symbol-name self)))))
        ((CL:or CL:NUMBER CL:STRING) (cl:setq result (wrap-literal self)))
        (STELLA::OBJECT (cl:setq result self))
        (CL:t (CL:error \"Can't stellify: \" self)))"
      :otherwise NULL)
    (return result) ))

(defun (stella-object? BOOLEAN) ((self OBJECT))
  :documentation "Return true if `self' is a member of the STELLA class `OBJECT'."
  (let ((result? TRUE))
    (verbatim
      :common-lisp
      "(CL:setq result? (CL:or (CL:typep self 'STELLA::OBJECT)
                               (CL:listp self)))"
      :otherwise NULL)
    (return result?) ))

(defun (running-as-lisp? BOOLEAN) ()
  :documentation "Return true if the executable code is a Common Lisp application."
  (let ((result? FALSE))
    (verbatim :common-lisp "(cl:setq result? TRUE)"
              :otherwise NULL)
    (return result?)) )


  ;;
;;;;;; Internal timer class and functions.  Sleep.
  ;;

(defun (get-ticktock TICKTOCK) ()
  :documentation "Return the current CPU time.  If the current OS/Language
combination does not support measuring of CPU time, return real time instead.
Use `ticktock-difference' to measure the time difference between values
returned by this function.  This is an attempt to provide some platform
independent support to measure (at least approximately) consumed CPU time."
  :public? TRUE
  :native? TRUE)

(defun (ticktock-difference FLOAT) ((t1 TICKTOCK) (t2 TICKTOCK))
  :documentation "The difference in two TICKTOCK time values in seconds where
`t1' is the earlier time.  The resolution is implementation dependent but will
normally be some fractional value of a second."
  :public? TRUE
  :native? TRUE)

(defun (ticktock-resolution FLOAT) ()
  :documentation "The minimum theoretically detectable resolution of the
difference in two TICKTOCK time values in seconds.  This
resolution is implementation dependent.  It may also not
be realizable in practice, since the timing grain size may
be larger than this resolution."
  :public? TRUE
  :native? TRUE)

(startup-time-progn
  (register-native-name (quote sleep) :cpp :function))
  
(defun sleep ((seconds FLOAT))
  :documentation "The program will sleep for the indicated number of seconds.
Fractional values are allowed, but the results are implementation dependent:
Common Lisp uses the fractions natively, Java with a resolution of 0.001,
and C++ can only use integral values."
  (verbatim
      :common-lisp "(cl:sleep seconds)"
      :java "try {
      Thread.sleep((long)(seconds * 1000.0));
    } catch (InterruptedException e) {
    }
"
      ;; Do we need to do something to include the header file unistd.h ?
      :cpp "sleep((unsigned int)seconds)"))

  ;;
;;;;;; Exception support functions
  ;;

(defun (exception-message STRING) ((e NATIVE-EXCEPTION))
  :public? TRUE
  :documentation "Accesses the error message of the exception `e'."
  (return (verbatim :java "e.getMessage()"
		    :common-lisp (%%get-exception-message e)
		    :cpp "(char*)e->what()")))

(defun print-exception-context ((e NATIVE-EXCEPTION) (stream OUTPUT-STREAM))
  :public? true
  :documentation "Prints a system dependent information about the context of the specified
exception.  For example, in Java it prints a stack trace.  In Lisp, it is vendor dependent."
  (let ((s (native-stream stream)))
    (verbatim
      :java "e.printStackTrace(s);"
      :common-lisp (%%print-exception-context e s)
      :otherwise (print-stream stream "No exception context available" EOL))))

  ;;
;;;;;; Process synchronization support functions
  ;;

(defun (make-process-lock PROCESS-LOCK-OBJECT) ()
  (return (verbatim 
	      :common-lisp "(%make-process-lock)"
	    :java "new java.lang.Object()"
	    :cpp "NULL")))
